function Nk(n, e) { for (var t = 0; t < e.length; t++) { const r = e[t]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in n)) { const o = Object.getOwnPropertyDescriptor(r, i); o && Object.defineProperty(n, i, o.get ? o : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(i) { if (i.ep) return; i.ep = !0; const o = t(i); fetch(i.href, o) } })(); function Rp(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var b3 = { exports: {} }, kt = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pp = Symbol.for("react.element"), zk = Symbol.for("react.portal"), Gk = Symbol.for("react.fragment"), Hk = Symbol.for("react.strict_mode"), Vk = Symbol.for("react.profiler"), Wk = Symbol.for("react.provider"), jk = Symbol.for("react.context"), Xk = Symbol.for("react.forward_ref"), Jk = Symbol.for("react.suspense"), Kk = Symbol.for("react.memo"), Yk = Symbol.for("react.lazy"), NC = Symbol.iterator; function $k(n) { return n === null || typeof n != "object" ? null : (n = NC && n[NC] || n["@@iterator"], typeof n == "function" ? n : null) } var C3 = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, T3 = Object.assign, R3 = {}; function rd(n, e, t) { this.props = n, this.context = e, this.refs = R3, this.updater = t || C3 } rd.prototype.isReactComponent = {}; rd.prototype.setState = function (n, e) { if (typeof n != "object" && typeof n != "function" && n != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, n, e, "setState") }; rd.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, "forceUpdate") }; function P3() { } P3.prototype = rd.prototype; function CE(n, e, t) { this.props = n, this.context = e, this.refs = R3, this.updater = t || C3 } var TE = CE.prototype = new P3; TE.constructor = CE; T3(TE, rd.prototype); TE.isPureReactComponent = !0; var zC = Array.isArray, B3 = Object.prototype.hasOwnProperty, RE = { current: null }, I3 = { key: !0, ref: !0, __self: !0, __source: !0 }; function L3(n, e, t) { var r, i = {}, o = null, s = null; if (e != null) for (r in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e) B3.call(e, r) && !I3.hasOwnProperty(r) && (i[r] = e[r]); var a = arguments.length - 2; if (a === 1) i.children = t; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; i.children = l } if (n && n.defaultProps) for (r in a = n.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: Pp, type: n, key: o, ref: s, props: i, _owner: RE.current } } function Qk(n, e) { return { $$typeof: Pp, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner } } function PE(n) { return typeof n == "object" && n !== null && n.$$typeof === Pp } function Zk(n) { var e = { "=": "=0", ":": "=2" }; return "$" + n.replace(/[=:]/g, function (t) { return e[t] }) } var GC = /\/+/g; function g_(n, e) { return typeof n == "object" && n !== null && n.key != null ? Zk("" + n.key) : e.toString(36) } function _0(n, e, t, r, i) { var o = typeof n; (o === "undefined" || o === "boolean") && (n = null); var s = !1; if (n === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (n.$$typeof) { case Pp: case zk: s = !0 } }if (s) return s = n, i = i(s), n = r === "" ? "." + g_(s, 0) : r, zC(i) ? (t = "", n != null && (t = n.replace(GC, "$&/") + "/"), _0(i, e, t, "", function (c) { return c })) : i != null && (PE(i) && (i = Qk(i, t + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(GC, "$&/") + "/") + n)), e.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", zC(n)) for (var a = 0; a < n.length; a++) { o = n[a]; var l = r + g_(o, a); s += _0(o, e, t, l, i) } else if (l = $k(n), typeof l == "function") for (n = l.call(n), a = 0; !(o = n.next()).done;)o = o.value, l = r + g_(o, a++), s += _0(o, e, t, l, i); else if (o === "object") throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return s } function Ym(n, e, t) { if (n == null) return n; var r = [], i = 0; return _0(n, r, "", "", function (o) { return e.call(t, o, i++) }), r } function qk(n) { if (n._status === -1) { var e = n._result; e = e(), e.then(function (t) { (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t) }, function (t) { (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t) }), n._status === -1 && (n._status = 0, n._result = e) } if (n._status === 1) return n._result.default; throw n._result } var gi = { current: null }, x0 = { transition: null }, eN = { ReactCurrentDispatcher: gi, ReactCurrentBatchConfig: x0, ReactCurrentOwner: RE }; kt.Children = { map: Ym, forEach: function (n, e, t) { Ym(n, function () { e.apply(this, arguments) }, t) }, count: function (n) { var e = 0; return Ym(n, function () { e++ }), e }, toArray: function (n) { return Ym(n, function (e) { return e }) || [] }, only: function (n) { if (!PE(n)) throw Error("React.Children.only expected to receive a single React element child."); return n } }; kt.Component = rd; kt.Fragment = Gk; kt.Profiler = Vk; kt.PureComponent = CE; kt.StrictMode = Hk; kt.Suspense = Jk; kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eN; kt.cloneElement = function (n, e, t) { if (n == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + "."); var r = T3({}, n.props), i = n.key, o = n.ref, s = n._owner; if (e != null) { if (e.ref !== void 0 && (o = e.ref, s = RE.current), e.key !== void 0 && (i = "" + e.key), n.type && n.type.defaultProps) var a = n.type.defaultProps; for (l in e) B3.call(e, l) && !I3.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) r.children = t; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; r.children = a } return { $$typeof: Pp, type: n.type, key: i, ref: o, props: r, _owner: s } }; kt.createContext = function (n) { return n = { $$typeof: jk, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: Wk, _context: n }, n.Consumer = n }; kt.createElement = L3; kt.createFactory = function (n) { var e = L3.bind(null, n); return e.type = n, e }; kt.createRef = function () { return { current: null } }; kt.forwardRef = function (n) { return { $$typeof: Xk, render: n } }; kt.isValidElement = PE; kt.lazy = function (n) { return { $$typeof: Yk, _payload: { _status: -1, _result: n }, _init: qk } }; kt.memo = function (n, e) { return { $$typeof: Kk, type: n, compare: e === void 0 ? null : e } }; kt.startTransition = function (n) { var e = x0.transition; x0.transition = {}; try { n() } finally { x0.transition = e } }; kt.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; kt.useCallback = function (n, e) { return gi.current.useCallback(n, e) }; kt.useContext = function (n) { return gi.current.useContext(n) }; kt.useDebugValue = function () { }; kt.useDeferredValue = function (n) { return gi.current.useDeferredValue(n) }; kt.useEffect = function (n, e) { return gi.current.useEffect(n, e) }; kt.useId = function () { return gi.current.useId() }; kt.useImperativeHandle = function (n, e, t) { return gi.current.useImperativeHandle(n, e, t) }; kt.useInsertionEffect = function (n, e) { return gi.current.useInsertionEffect(n, e) }; kt.useLayoutEffect = function (n, e) { return gi.current.useLayoutEffect(n, e) }; kt.useMemo = function (n, e) { return gi.current.useMemo(n, e) }; kt.useReducer = function (n, e, t) { return gi.current.useReducer(n, e, t) }; kt.useRef = function (n) { return gi.current.useRef(n) }; kt.useState = function (n) { return gi.current.useState(n) }; kt.useSyncExternalStore = function (n, e, t) { return gi.current.useSyncExternalStore(n, e, t) }; kt.useTransition = function () { return gi.current.useTransition() }; kt.version = "18.2.0"; b3.exports = kt; var N = b3.exports; const D = Rp(N), oS = Nk({ __proto__: null, default: D }, [N]); var sS = {}, D3 = { exports: {} }, lo = {}, O3 = { exports: {} }, F3 = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(W, V) { var J = W.length; W.push(V); e: for (; 0 < J;) { var O = J - 1 >>> 1, k = W[O]; if (0 < i(k, V)) W[O] = V, W[J] = k, J = O; else break e } } function t(W) { return W.length === 0 ? null : W[0] } function r(W) { if (W.length === 0) return null; var V = W[0], J = W.pop(); if (J !== V) { W[0] = J; e: for (var O = 0, k = W.length, Z = k >>> 1; O < Z;) { var ee = 2 * (O + 1) - 1, ne = W[ee], K = ee + 1, ae = W[K]; if (0 > i(ne, J)) K < k && 0 > i(ae, ne) ? (W[O] = ae, W[K] = J, O = K) : (W[O] = ne, W[ee] = J, O = ee); else if (K < k && 0 > i(ae, J)) W[O] = ae, W[K] = J, O = K; else break e } } return V } function i(W, V) { var J = W.sortIndex - V.sortIndex; return J !== 0 ? J : W.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; n.unstable_now = function () { return o.now() } } else { var s = Date, a = s.now(); n.unstable_now = function () { return s.now() - a } } var l = [], c = [], u = 1, d = null, p = 3, m = !1, v = !1, y = !1, _ = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, x = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function A(W) { for (var V = t(c); V !== null;) { if (V.callback === null) r(c); else if (V.startTime <= W) r(c), V.sortIndex = V.expirationTime, e(l, V); else break; V = t(c) } } function E(W) { if (y = !1, A(W), !v) if (t(l) !== null) v = !0, q(w); else { var V = t(c); V !== null && se(E, V.startTime - W) } } function w(W, V) { v = !1, y && (y = !1, g(B), B = -1), m = !0; var J = p; try { for (A(V), d = t(l); d !== null && (!(d.expirationTime > V) || W && !U());) { var O = d.callback; if (typeof O == "function") { d.callback = null, p = d.priorityLevel; var k = O(d.expirationTime <= V); V = n.unstable_now(), typeof k == "function" ? d.callback = k : d === t(l) && r(l), A(V) } else r(l); d = t(l) } if (d !== null) var Z = !0; else { var ee = t(c); ee !== null && se(E, ee.startTime - V), Z = !1 } return Z } finally { d = null, p = J, m = !1 } } var b = !1, T = null, B = -1, R = 5, P = -1; function U() { return !(n.unstable_now() - P < R) } function G() { if (T !== null) { var W = n.unstable_now(); P = W; var V = !0; try { V = T(!0, W) } finally { V ? $() : (b = !1, T = null) } } else b = !1 } var $; if (typeof x == "function") $ = function () { x(G) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, j = z.port2; z.port1.onmessage = G, $ = function () { j.postMessage(null) } } else $ = function () { _(G, 0) }; function q(W) { T = W, b || (b = !0, $()) } function se(W, V) { B = _(function () { W(n.unstable_now()) }, V) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (W) { W.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, q(w)) }, n.unstable_forceFrameRate = function (W) { 0 > W || 125 < W ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < W ? Math.floor(1e3 / W) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (W) { switch (p) { case 1: case 2: case 3: var V = 3; break; default: V = p }var J = p; p = V; try { return W() } finally { p = J } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (W, V) { switch (W) { case 1: case 2: case 3: case 4: case 5: break; default: W = 3 }var J = p; p = W; try { return V() } finally { p = J } }, n.unstable_scheduleCallback = function (W, V, J) { var O = n.unstable_now(); switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? O + J : O) : J = O, W) { case 1: var k = -1; break; case 2: k = 250; break; case 5: k = 1073741823; break; case 4: k = 1e4; break; default: k = 5e3 }return k = J + k, W = { id: u++, callback: V, priorityLevel: W, startTime: J, expirationTime: k, sortIndex: -1 }, J > O ? (W.sortIndex = J, e(c, W), t(l) === null && W === t(c) && (y ? (g(B), B = -1) : y = !0, se(E, J - O))) : (W.sortIndex = k, e(l, W), v || m || (v = !0, q(w))), W }, n.unstable_shouldYield = U, n.unstable_wrapCallback = function (W) { var V = p; return function () { var J = p; p = V; try { return W.apply(this, arguments) } finally { p = J } } } })(F3); O3.exports = F3; var tN = O3.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var U3 = N, ro = tN; function Xe(n) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var k3 = new Set, zh = {}; function Yc(n, e) { If(n, e), If(n + "Capture", e) } function If(n, e) { for (zh[n] = e, n = 0; n < e.length; n++)k3.add(e[n]) } var pa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), aS = Object.prototype.hasOwnProperty, nN = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, HC = {}, VC = {}; function rN(n) { return aS.call(VC, n) ? !0 : aS.call(HC, n) ? !1 : nN.test(n) ? VC[n] = !0 : (HC[n] = !0, !1) } function iN(n, e, t, r) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-"); default: return !1 } } function oN(n, e, t, r) { if (e === null || typeof e > "u" || iN(n, e, t, r)) return !0; if (r) return !1; if (t !== null) switch (t.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function vi(n, e, t, r, i, o, s) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s } var Br = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { Br[n] = new vi(n, 0, !1, n, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var e = n[0]; Br[e] = new vi(e, 1, !1, n[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { Br[n] = new vi(n, 2, !1, n.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { Br[n] = new vi(n, 2, !1, n, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { Br[n] = new vi(n, 3, !1, n.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (n) { Br[n] = new vi(n, 3, !0, n, null, !1, !1) });["capture", "download"].forEach(function (n) { Br[n] = new vi(n, 4, !1, n, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (n) { Br[n] = new vi(n, 6, !1, n, null, !1, !1) });["rowSpan", "start"].forEach(function (n) { Br[n] = new vi(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var BE = /[\-:]([a-z])/g; function IE(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var e = n.replace(BE, IE); Br[e] = new vi(e, 1, !1, n, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var e = n.replace(BE, IE); Br[e] = new vi(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var e = n.replace(BE, IE); Br[e] = new vi(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (n) { Br[n] = new vi(n, 1, !1, n.toLowerCase(), null, !1, !1) }); Br.xlinkHref = new vi("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (n) { Br[n] = new vi(n, 1, !1, n.toLowerCase(), null, !0, !0) }); function LE(n, e, t, r) { var i = Br.hasOwnProperty(e) ? Br[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (oN(e, t, i, r) && (t = null), r || i === null ? rN(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : i.mustUseProperty ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : "" : t : (e = i.attributeName, r = i.attributeNamespace, t === null ? n.removeAttribute(e) : (i = i.type, t = i === 3 || i === 4 && t === !0 ? "" : "" + t, r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t)))) } var wa = U3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, $m = Symbol.for("react.element"), Zu = Symbol.for("react.portal"), qu = Symbol.for("react.fragment"), DE = Symbol.for("react.strict_mode"), lS = Symbol.for("react.profiler"), N3 = Symbol.for("react.provider"), z3 = Symbol.for("react.context"), OE = Symbol.for("react.forward_ref"), cS = Symbol.for("react.suspense"), uS = Symbol.for("react.suspense_list"), FE = Symbol.for("react.memo"), Ya = Symbol.for("react.lazy"), G3 = Symbol.for("react.offscreen"), WC = Symbol.iterator; function Fd(n) { return n === null || typeof n != "object" ? null : (n = WC && n[WC] || n["@@iterator"], typeof n == "function" ? n : null) } var Dn = Object.assign, v_; function ch(n) {
	if (v_ === void 0) try { throw Error() } catch (t) { var e = t.stack.trim().match(/\n( *(at )?)/); v_ = e && e[1] || "" } return `
`+ v_ + n
} var y_ = !1; function __(n, e) {
	if (!n || y_) return ""; y_ = !0; var t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (c) { var r = c } Reflect.construct(n, [], e) } else { try { e.call() } catch (c) { r = c } n.call(e.prototype) } else { try { throw Error() } catch (c) { r = c } n() } } catch (c) {
		if (c && r && typeof c.stack == "string") {
			for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
				if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
					var l = `
`+ i[s].replace(" at new ", " at "); return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)), l
				} while (1 <= s && 0 <= a); break
			}
		}
	} finally { y_ = !1, Error.prepareStackTrace = t } return (n = n ? n.displayName || n.name : "") ? ch(n) : ""
} function sN(n) { switch (n.tag) { case 5: return ch(n.type); case 16: return ch("Lazy"); case 13: return ch("Suspense"); case 19: return ch("SuspenseList"); case 0: case 2: case 15: return n = __(n.type, !1), n; case 11: return n = __(n.type.render, !1), n; case 1: return n = __(n.type, !0), n; default: return "" } } function fS(n) { if (n == null) return null; if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n; switch (n) { case qu: return "Fragment"; case Zu: return "Portal"; case lS: return "Profiler"; case DE: return "StrictMode"; case cS: return "Suspense"; case uS: return "SuspenseList" }if (typeof n == "object") switch (n.$$typeof) { case z3: return (n.displayName || "Context") + ".Consumer"; case N3: return (n._context.displayName || "Context") + ".Provider"; case OE: var e = n.render; return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case FE: return e = n.displayName || null, e !== null ? e : fS(n.type) || "Memo"; case Ya: e = n._payload, n = n._init; try { return fS(n(e)) } catch { } }return null } function aN(n) { var e = n.type; switch (n.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return fS(e); case 8: return e === DE ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function _l(n) { switch (typeof n) { case "boolean": case "number": case "string": case "undefined": return n; case "object": return n; default: return "" } } function H3(n) { var e = n.type; return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function lN(n) { var e = H3(n) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e), r = "" + n[e]; if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") { var i = t.get, o = t.set; return Object.defineProperty(n, e, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { n._valueTracker = null, delete n[e] } } } } function Qm(n) { n._valueTracker || (n._valueTracker = lN(n)) } function V3(n) { if (!n) return !1; var e = n._valueTracker; if (!e) return !0; var t = e.getValue(), r = ""; return n && (r = H3(n) ? n.checked ? "true" : "false" : n.value), n = r, n !== t ? (e.setValue(n), !0) : !1 } function K0(n) { if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null; try { return n.activeElement || n.body } catch { return n.body } } function dS(n, e) { var t = e.checked; return Dn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked }) } function jC(n, e) { var t = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; t = _l(e.value != null ? e.value : t), n._wrapperState = { initialChecked: r, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function W3(n, e) { e = e.checked, e != null && LE(n, "checked", e, !1) } function hS(n, e) { W3(n, e); var t = _l(e.value), r = e.type; if (t != null) r === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t); else if (r === "submit" || r === "reset") { n.removeAttribute("value"); return } e.hasOwnProperty("value") ? pS(n, e.type, t) : e.hasOwnProperty("defaultValue") && pS(n, e.type, _l(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked) } function XC(n, e, t) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e } t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t) } function pS(n, e, t) { (e !== "number" || K0(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t)) } var uh = Array.isArray; function yf(n, e, t, r) { if (n = n.options, e) { e = {}; for (var i = 0; i < t.length; i++)e["$" + t[i]] = !0; for (t = 0; t < n.length; t++)i = e.hasOwnProperty("$" + n[t].value), n[t].selected !== i && (n[t].selected = i), i && r && (n[t].defaultSelected = !0) } else { for (t = "" + _l(t), e = null, i = 0; i < n.length; i++) { if (n[i].value === t) { n[i].selected = !0, r && (n[i].defaultSelected = !0); return } e !== null || n[i].disabled || (e = n[i]) } e !== null && (e.selected = !0) } } function mS(n, e) { if (e.dangerouslySetInnerHTML != null) throw Error(Xe(91)); return Dn({}, e, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue }) } function JC(n, e) { var t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(Xe(92)); if (uh(t)) { if (1 < t.length) throw Error(Xe(93)); t = t[0] } e = t } e == null && (e = ""), t = e } n._wrapperState = { initialValue: _l(t) } } function j3(n, e) { var t = _l(e.value), r = _l(e.defaultValue); t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), r != null && (n.defaultValue = "" + r) } function KC(n) { var e = n.textContent; e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e) } function X3(n) { switch (n) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function gS(n, e) { return n == null || n === "http://www.w3.org/1999/xhtml" ? X3(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n } var Zm, J3 = function (n) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, t, r, i) { MSApp.execUnsafeLocalFunction(function () { return n(e, t, r, i) }) } : n }(function (n, e) { if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) n.innerHTML = e; else { for (Zm = Zm || document.createElement("div"), Zm.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Zm.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (; e.firstChild;)n.appendChild(e.firstChild) } }); function Gh(n, e) { if (e) { var t = n.firstChild; if (t && t === n.lastChild && t.nodeType === 3) { t.nodeValue = e; return } } n.textContent = e } var yh = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, cN = ["Webkit", "ms", "Moz", "O"]; Object.keys(yh).forEach(function (n) { cN.forEach(function (e) { e = e + n.charAt(0).toUpperCase() + n.substring(1), yh[e] = yh[n] }) }); function K3(n, e, t) { return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || yh.hasOwnProperty(n) && yh[n] ? ("" + e).trim() : e + "px" } function Y3(n, e) { n = n.style; for (var t in e) if (e.hasOwnProperty(t)) { var r = t.indexOf("--") === 0, i = K3(t, e[t], r); t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : n[t] = i } } var uN = Dn({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function vS(n, e) { if (e) { if (uN[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Xe(137, n)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(Xe(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Xe(61)) } if (e.style != null && typeof e.style != "object") throw Error(Xe(62)) } } function yS(n, e) { if (n.indexOf("-") === -1) return typeof e.is == "string"; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var _S = null; function UE(n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } var xS = null, _f = null, xf = null; function YC(n) { if (n = Lp(n)) { if (typeof xS != "function") throw Error(Xe(280)); var e = n.stateNode; e && (e = Jv(e), xS(n.stateNode, n.type, e)) } } function $3(n) { _f ? xf ? xf.push(n) : xf = [n] : _f = n } function Q3() { if (_f) { var n = _f, e = xf; if (xf = _f = null, YC(n), e) for (n = 0; n < e.length; n++)YC(e[n]) } } function Z3(n, e) { return n(e) } function q3() { } var x_ = !1; function eI(n, e, t) { if (x_) return n(e, t); x_ = !0; try { return Z3(n, e, t) } finally { x_ = !1, (_f !== null || xf !== null) && (q3(), Q3()) } } function Hh(n, e) { var t = n.stateNode; if (t === null) return null; var r = Jv(t); if (r === null) return null; t = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (n = n.type, r = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !r; break e; default: n = !1 }if (n) return null; if (t && typeof t != "function") throw Error(Xe(231, e, typeof t)); return t } var SS = !1; if (pa) try { var Ud = {}; Object.defineProperty(Ud, "passive", { get: function () { SS = !0 } }), window.addEventListener("test", Ud, Ud), window.removeEventListener("test", Ud, Ud) } catch { SS = !1 } function fN(n, e, t, r, i, o, s, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { e.apply(t, c) } catch (u) { this.onError(u) } } var _h = !1, Y0 = null, $0 = !1, AS = null, dN = { onError: function (n) { _h = !0, Y0 = n } }; function hN(n, e, t, r, i, o, s, a, l) { _h = !1, Y0 = null, fN.apply(dN, arguments) } function pN(n, e, t, r, i, o, s, a, l) { if (hN.apply(this, arguments), _h) { if (_h) { var c = Y0; _h = !1, Y0 = null } else throw Error(Xe(198)); $0 || ($0 = !0, AS = c) } } function $c(n) { var e = n, t = n; if (n.alternate) for (; e.return;)e = e.return; else { n = e; do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n) } return e.tag === 3 ? t : null } function tI(n) { if (n.tag === 13) { var e = n.memoizedState; if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated } return null } function $C(n) { if ($c(n) !== n) throw Error(Xe(188)) } function mN(n) { var e = n.alternate; if (!e) { if (e = $c(n), e === null) throw Error(Xe(188)); return e !== n ? null : n } for (var t = n, r = e; ;) { var i = t.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { t = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === t) return $C(i), n; if (o === r) return $C(i), e; o = o.sibling } throw Error(Xe(188)) } if (t.return !== r.return) t = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === t) { s = !0, t = i, r = o; break } if (a === r) { s = !0, r = i, t = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === t) { s = !0, t = o, r = i; break } if (a === r) { s = !0, r = o, t = i; break } a = a.sibling } if (!s) throw Error(Xe(189)) } } if (t.alternate !== r) throw Error(Xe(190)) } if (t.tag !== 3) throw Error(Xe(188)); return t.stateNode.current === t ? n : e } function nI(n) { return n = mN(n), n !== null ? rI(n) : null } function rI(n) { if (n.tag === 5 || n.tag === 6) return n; for (n = n.child; n !== null;) { var e = rI(n); if (e !== null) return e; n = n.sibling } return null } var iI = ro.unstable_scheduleCallback, QC = ro.unstable_cancelCallback, gN = ro.unstable_shouldYield, vN = ro.unstable_requestPaint, Kn = ro.unstable_now, yN = ro.unstable_getCurrentPriorityLevel, kE = ro.unstable_ImmediatePriority, oI = ro.unstable_UserBlockingPriority, Q0 = ro.unstable_NormalPriority, _N = ro.unstable_LowPriority, sI = ro.unstable_IdlePriority, Vv = null, Ms = null; function xN(n) { if (Ms && typeof Ms.onCommitFiberRoot == "function") try { Ms.onCommitFiberRoot(Vv, n, void 0, (n.current.flags & 128) === 128) } catch { } } var Ko = Math.clz32 ? Math.clz32 : EN, SN = Math.log, AN = Math.LN2; function EN(n) { return n >>>= 0, n === 0 ? 32 : 31 - (SN(n) / AN | 0) | 0 } var qm = 64, eg = 4194304; function fh(n) { switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return n & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return n } } function Z0(n, e) { var t = n.pendingLanes; if (t === 0) return 0; var r = 0, i = n.suspendedLanes, o = n.pingedLanes, s = t & 268435455; if (s !== 0) { var a = s & ~i; a !== 0 ? r = fh(a) : (o &= s, o !== 0 && (r = fh(o))) } else s = t & ~i, s !== 0 ? r = fh(s) : o !== 0 && (r = fh(o)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, o = e & -e, i >= o || i === 16 && (o & 4194240) !== 0)) return e; if (r & 4 && (r |= t & 16), e = n.entangledLanes, e !== 0) for (n = n.entanglements, e &= r; 0 < e;)t = 31 - Ko(e), i = 1 << t, r |= n[t], e &= ~i; return r } function MN(n, e) { switch (n) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function wN(n, e) { for (var t = n.suspendedLanes, r = n.pingedLanes, i = n.expirationTimes, o = n.pendingLanes; 0 < o;) { var s = 31 - Ko(o), a = 1 << s, l = i[s]; l === -1 ? (!(a & t) || a & r) && (i[s] = MN(a, e)) : l <= e && (n.expiredLanes |= a), o &= ~a } } function ES(n) { return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0 } function aI() { var n = qm; return qm <<= 1, !(qm & 4194240) && (qm = 64), n } function S_(n) { for (var e = [], t = 0; 31 > t; t++)e.push(n); return e } function Bp(n, e, t) { n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - Ko(e), n[e] = t } function bN(n, e) { var t = n.pendingLanes & ~e; n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements; var r = n.eventTimes; for (n = n.expirationTimes; 0 < t;) { var i = 31 - Ko(t), o = 1 << i; e[i] = 0, r[i] = -1, n[i] = -1, t &= ~o } } function NE(n, e) { var t = n.entangledLanes |= e; for (n = n.entanglements; t;) { var r = 31 - Ko(t), i = 1 << r; i & e | n[r] & e && (n[r] |= e), t &= ~i } } var on = 0; function lI(n) { return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1 } var cI, zE, uI, fI, dI, MS = !1, tg = [], ol = null, sl = null, al = null, Vh = new Map, Wh = new Map, Za = [], CN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function ZC(n, e) { switch (n) { case "focusin": case "focusout": ol = null; break; case "dragenter": case "dragleave": sl = null; break; case "mouseover": case "mouseout": al = null; break; case "pointerover": case "pointerout": Vh.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Wh.delete(e.pointerId) } } function kd(n, e, t, r, i, o) { return n === null || n.nativeEvent !== o ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, e !== null && (e = Lp(e), e !== null && zE(e)), n) : (n.eventSystemFlags |= r, e = n.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), n) } function TN(n, e, t, r, i) { switch (e) { case "focusin": return ol = kd(ol, n, e, t, r, i), !0; case "dragenter": return sl = kd(sl, n, e, t, r, i), !0; case "mouseover": return al = kd(al, n, e, t, r, i), !0; case "pointerover": var o = i.pointerId; return Vh.set(o, kd(Vh.get(o) || null, n, e, t, r, i)), !0; case "gotpointercapture": return o = i.pointerId, Wh.set(o, kd(Wh.get(o) || null, n, e, t, r, i)), !0 }return !1 } function hI(n) { var e = vc(n.target); if (e !== null) { var t = $c(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = tI(t), e !== null) { n.blockedOn = e, dI(n.priority, function () { uI(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } } n.blockedOn = null } function S0(n) { if (n.blockedOn !== null) return !1; for (var e = n.targetContainers; 0 < e.length;) { var t = wS(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent); if (t === null) { t = n.nativeEvent; var r = new t.constructor(t.type, t); _S = r, t.target.dispatchEvent(r), _S = null } else return e = Lp(t), e !== null && zE(e), n.blockedOn = t, !1; e.shift() } return !0 } function qC(n, e, t) { S0(n) && t.delete(e) } function RN() { MS = !1, ol !== null && S0(ol) && (ol = null), sl !== null && S0(sl) && (sl = null), al !== null && S0(al) && (al = null), Vh.forEach(qC), Wh.forEach(qC) } function Nd(n, e) { n.blockedOn === e && (n.blockedOn = null, MS || (MS = !0, ro.unstable_scheduleCallback(ro.unstable_NormalPriority, RN))) } function jh(n) { function e(i) { return Nd(i, n) } if (0 < tg.length) { Nd(tg[0], n); for (var t = 1; t < tg.length; t++) { var r = tg[t]; r.blockedOn === n && (r.blockedOn = null) } } for (ol !== null && Nd(ol, n), sl !== null && Nd(sl, n), al !== null && Nd(al, n), Vh.forEach(e), Wh.forEach(e), t = 0; t < Za.length; t++)r = Za[t], r.blockedOn === n && (r.blockedOn = null); for (; 0 < Za.length && (t = Za[0], t.blockedOn === null);)hI(t), t.blockedOn === null && Za.shift() } var Sf = wa.ReactCurrentBatchConfig, q0 = !0; function PN(n, e, t, r) { var i = on, o = Sf.transition; Sf.transition = null; try { on = 1, GE(n, e, t, r) } finally { on = i, Sf.transition = o } } function BN(n, e, t, r) { var i = on, o = Sf.transition; Sf.transition = null; try { on = 4, GE(n, e, t, r) } finally { on = i, Sf.transition = o } } function GE(n, e, t, r) { if (q0) { var i = wS(n, e, t, r); if (i === null) B_(n, e, r, ev, t), ZC(n, r); else if (TN(i, n, e, t, r)) r.stopPropagation(); else if (ZC(n, r), e & 4 && -1 < CN.indexOf(n)) { for (; i !== null;) { var o = Lp(i); if (o !== null && cI(o), o = wS(n, e, t, r), o === null && B_(n, e, r, ev, t), o === i) break; i = o } i !== null && r.stopPropagation() } else B_(n, e, r, null, t) } } var ev = null; function wS(n, e, t, r) { if (ev = null, n = UE(r), n = vc(n), n !== null) if (e = $c(n), e === null) n = null; else if (t = e.tag, t === 13) { if (n = tI(e), n !== null) return n; n = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; n = null } else e !== n && (n = null); return ev = n, null } function pI(n) { switch (n) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (yN()) { case kE: return 1; case oI: return 4; case Q0: case _N: return 16; case sI: return 536870912; default: return 16 }default: return 16 } } var tl = null, HE = null, A0 = null; function mI() { if (A0) return A0; var n, e = HE, t = e.length, r, i = "value" in tl ? tl.value : tl.textContent, o = i.length; for (n = 0; n < t && e[n] === i[n]; n++); var s = t - n; for (r = 1; r <= s && e[t - r] === i[o - r]; r++); return A0 = i.slice(n, 1 < r ? 1 - r : void 0) } function E0(n) { var e = n.keyCode; return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0 } function ng() { return !0 } function eT() { return !1 } function co(n) { function e(t, r, i, o, s) { this._reactName = t, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in n) n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? ng : eT, this.isPropagationStopped = eT, this } return Dn(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = ng) }, stopPropagation: function () { var t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = ng) }, persist: function () { }, isPersistent: ng }), e } var id = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, VE = co(id), Ip = Dn({}, id, { view: 0, detail: 0 }), IN = co(Ip), A_, E_, zd, Wv = Dn({}, Ip, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: WE, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== zd && (zd && n.type === "mousemove" ? (A_ = n.screenX - zd.screenX, E_ = n.screenY - zd.screenY) : E_ = A_ = 0, zd = n), A_) }, movementY: function (n) { return "movementY" in n ? n.movementY : E_ } }), tT = co(Wv), LN = Dn({}, Wv, { dataTransfer: 0 }), DN = co(LN), ON = Dn({}, Ip, { relatedTarget: 0 }), M_ = co(ON), FN = Dn({}, id, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), UN = co(FN), kN = Dn({}, id, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } }), NN = co(kN), zN = Dn({}, id, { data: 0 }), nT = co(zN), GN = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, HN = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, VN = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function WN(n) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(n) : (n = VN[n]) ? !!e[n] : !1 } function WE() { return WN } var jN = Dn({}, Ip, { key: function (n) { if (n.key) { var e = GN[n.key] || n.key; if (e !== "Unidentified") return e } return n.type === "keypress" ? (n = E0(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? HN[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: WE, charCode: function (n) { return n.type === "keypress" ? E0(n) : 0 }, keyCode: function (n) { return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 }, which: function (n) { return n.type === "keypress" ? E0(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 } }), XN = co(jN), JN = Dn({}, Wv, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), rT = co(JN), KN = Dn({}, Ip, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: WE }), YN = co(KN), $N = Dn({}, id, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), QN = co($N), ZN = Dn({}, Wv, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), qN = co(ZN), e4 = [9, 13, 27, 32], jE = pa && "CompositionEvent" in window, xh = null; pa && "documentMode" in document && (xh = document.documentMode); var t4 = pa && "TextEvent" in window && !xh, gI = pa && (!jE || xh && 8 < xh && 11 >= xh), iT = String.fromCharCode(32), oT = !1; function vI(n, e) { switch (n) { case "keyup": return e4.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function yI(n) { return n = n.detail, typeof n == "object" && "data" in n ? n.data : null } var ef = !1; function n4(n, e) { switch (n) { case "compositionend": return yI(e); case "keypress": return e.which !== 32 ? null : (oT = !0, iT); case "textInput": return n = e.data, n === iT && oT ? null : n; default: return null } } function r4(n, e) { if (ef) return n === "compositionend" || !jE && vI(n, e) ? (n = mI(), A0 = HE = tl = null, ef = !1, n) : null; switch (n) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return gI && e.locale !== "ko" ? null : e.data; default: return null } } var i4 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function sT(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e === "input" ? !!i4[n.type] : e === "textarea" } function _I(n, e, t, r) { $3(r), e = tv(e, "onChange"), 0 < e.length && (t = new VE("onChange", "change", null, t, r), n.push({ event: t, listeners: e })) } var Sh = null, Xh = null; function o4(n) { PI(n, 0) } function jv(n) { var e = rf(n); if (V3(e)) return n } function s4(n, e) { if (n === "change") return e } var xI = !1; if (pa) { var w_; if (pa) { var b_ = "oninput" in document; if (!b_) { var aT = document.createElement("div"); aT.setAttribute("oninput", "return;"), b_ = typeof aT.oninput == "function" } w_ = b_ } else w_ = !1; xI = w_ && (!document.documentMode || 9 < document.documentMode) } function lT() { Sh && (Sh.detachEvent("onpropertychange", SI), Xh = Sh = null) } function SI(n) { if (n.propertyName === "value" && jv(Xh)) { var e = []; _I(e, Xh, n, UE(n)), eI(o4, e) } } function a4(n, e, t) { n === "focusin" ? (lT(), Sh = e, Xh = t, Sh.attachEvent("onpropertychange", SI)) : n === "focusout" && lT() } function l4(n) { if (n === "selectionchange" || n === "keyup" || n === "keydown") return jv(Xh) } function c4(n, e) { if (n === "click") return jv(e) } function u4(n, e) { if (n === "input" || n === "change") return jv(e) } function f4(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var Zo = typeof Object.is == "function" ? Object.is : f4; function Jh(n, e) { if (Zo(n, e)) return !0; if (typeof n != "object" || n === null || typeof e != "object" || e === null) return !1; var t = Object.keys(n), r = Object.keys(e); if (t.length !== r.length) return !1; for (r = 0; r < t.length; r++) { var i = t[r]; if (!aS.call(e, i) || !Zo(n[i], e[i])) return !1 } return !0 } function cT(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function uT(n, e) { var t = cT(n); n = 0; for (var r; t;) { if (t.nodeType === 3) { if (r = n + t.textContent.length, n <= e && r >= e) return { node: t, offset: e - n }; n = r } e: { for (; t;) { if (t.nextSibling) { t = t.nextSibling; break e } t = t.parentNode } t = void 0 } t = cT(t) } } function AI(n, e) { return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? AI(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1 } function EI() { for (var n = window, e = K0(); e instanceof n.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href == "string" } catch { t = !1 } if (t) n = e.contentWindow; else break; e = K0(n.document) } return e } function XE(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true") } function d4(n) { var e = EI(), t = n.focusedElem, r = n.selectionRange; if (e !== t && t && t.ownerDocument && AI(t.ownerDocument.documentElement, t)) { if (r !== null && XE(t)) { if (e = r.start, n = r.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); var i = t.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !n.extend && o > r && (i = r, r = o, o = i), i = uT(t, o); var s = uT(t, r); i && s && (n.rangeCount !== 1 || n.anchorNode !== i.node || n.anchorOffset !== i.offset || n.focusNode !== s.node || n.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), n.removeAllRanges(), o > r ? (n.addRange(e), n.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } var h4 = pa && "documentMode" in document && 11 >= document.documentMode, tf = null, bS = null, Ah = null, CS = !1; function fT(n, e, t) { var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; CS || tf == null || tf !== K0(r) || (r = tf, "selectionStart" in r && XE(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ah && Jh(Ah, r) || (Ah = r, r = tv(bS, "onSelect"), 0 < r.length && (e = new VE("onSelect", "select", null, e, t), n.push({ event: e, listeners: r }), e.target = tf))) } function rg(n, e) { var t = {}; return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t } var nf = { animationend: rg("Animation", "AnimationEnd"), animationiteration: rg("Animation", "AnimationIteration"), animationstart: rg("Animation", "AnimationStart"), transitionend: rg("Transition", "TransitionEnd") }, C_ = {}, MI = {}; pa && (MI = document.createElement("div").style, "AnimationEvent" in window || (delete nf.animationend.animation, delete nf.animationiteration.animation, delete nf.animationstart.animation), "TransitionEvent" in window || delete nf.transitionend.transition); function Xv(n) { if (C_[n]) return C_[n]; if (!nf[n]) return n; var e = nf[n], t; for (t in e) if (e.hasOwnProperty(t) && t in MI) return C_[n] = e[t]; return n } var wI = Xv("animationend"), bI = Xv("animationiteration"), CI = Xv("animationstart"), TI = Xv("transitionend"), RI = new Map, dT = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function bl(n, e) { RI.set(n, e), Yc(e, [n]) } for (var T_ = 0; T_ < dT.length; T_++) { var R_ = dT[T_], p4 = R_.toLowerCase(), m4 = R_[0].toUpperCase() + R_.slice(1); bl(p4, "on" + m4) } bl(wI, "onAnimationEnd"); bl(bI, "onAnimationIteration"); bl(CI, "onAnimationStart"); bl("dblclick", "onDoubleClick"); bl("focusin", "onFocus"); bl("focusout", "onBlur"); bl(TI, "onTransitionEnd"); If("onMouseEnter", ["mouseout", "mouseover"]); If("onMouseLeave", ["mouseout", "mouseover"]); If("onPointerEnter", ["pointerout", "pointerover"]); If("onPointerLeave", ["pointerout", "pointerover"]); Yc("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Yc("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Yc("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Yc("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Yc("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Yc("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var dh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), g4 = new Set("cancel close invalid load scroll toggle".split(" ").concat(dh)); function hT(n, e, t) { var r = n.type || "unknown-event"; n.currentTarget = t, pN(r, e, void 0, n), n.currentTarget = null } function PI(n, e) { e = (e & 4) !== 0; for (var t = 0; t < n.length; t++) { var r = n[t], i = r.event; r = r.listeners; e: { var o = void 0; if (e) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; hT(i, a, c), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; hT(i, a, c), o = l } } } if ($0) throw n = AS, $0 = !1, AS = null, n } function vn(n, e) { var t = e[IS]; t === void 0 && (t = e[IS] = new Set); var r = n + "__bubble"; t.has(r) || (BI(e, n, 2, !1), t.add(r)) } function P_(n, e, t) { var r = 0; e && (r |= 4), BI(t, n, r, e) } var ig = "_reactListening" + Math.random().toString(36).slice(2); function Kh(n) { if (!n[ig]) { n[ig] = !0, k3.forEach(function (t) { t !== "selectionchange" && (g4.has(t) || P_(t, !1, n), P_(t, !0, n)) }); var e = n.nodeType === 9 ? n : n.ownerDocument; e === null || e[ig] || (e[ig] = !0, P_("selectionchange", !1, e)) } } function BI(n, e, t, r) { switch (pI(e)) { case 1: var i = PN; break; case 4: i = BN; break; default: i = GE }t = i.bind(null, e, t, n), i = void 0, !SS || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: i }) : n.addEventListener(e, t, !0) : i !== void 0 ? n.addEventListener(e, t, { passive: i }) : n.addEventListener(e, t, !1) } function B_(n, e, t, r, i) { var o = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = vc(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } eI(function () { var c = o, u = UE(t), d = []; e: { var p = RI.get(n); if (p !== void 0) { var m = VE, v = n; switch (n) { case "keypress": if (E0(t) === 0) break e; case "keydown": case "keyup": m = XN; break; case "focusin": v = "focus", m = M_; break; case "focusout": v = "blur", m = M_; break; case "beforeblur": case "afterblur": m = M_; break; case "click": if (t.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = tT; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = DN; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = YN; break; case wI: case bI: case CI: m = UN; break; case TI: m = QN; break; case "scroll": m = IN; break; case "wheel": m = qN; break; case "copy": case "cut": case "paste": m = NN; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = rT }var y = (e & 4) !== 0, _ = !y && n === "scroll", g = y ? p !== null ? p + "Capture" : null : p; y = []; for (var x = c, A; x !== null;) { A = x; var E = A.stateNode; if (A.tag === 5 && E !== null && (A = E, g !== null && (E = Hh(x, g), E != null && y.push(Yh(x, E, A)))), _) break; x = x.return } 0 < y.length && (p = new m(p, v, null, t, u), d.push({ event: p, listeners: y })) } } if (!(e & 7)) { e: { if (p = n === "mouseover" || n === "pointerover", m = n === "mouseout" || n === "pointerout", p && t !== _S && (v = t.relatedTarget || t.fromElement) && (vc(v) || v[ma])) break e; if ((m || p) && (p = u.window === u ? u : (p = u.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (v = t.relatedTarget || t.toElement, m = c, v = v ? vc(v) : null, v !== null && (_ = $c(v), v !== _ || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null, v = c), m !== v)) { if (y = tT, E = "onMouseLeave", g = "onMouseEnter", x = "mouse", (n === "pointerout" || n === "pointerover") && (y = rT, E = "onPointerLeave", g = "onPointerEnter", x = "pointer"), _ = m == null ? p : rf(m), A = v == null ? p : rf(v), p = new y(E, x + "leave", m, t, u), p.target = _, p.relatedTarget = A, E = null, vc(u) === c && (y = new y(g, x + "enter", v, t, u), y.target = A, y.relatedTarget = _, E = y), _ = E, m && v) t: { for (y = m, g = v, x = 0, A = y; A; A = yu(A))x++; for (A = 0, E = g; E; E = yu(E))A++; for (; 0 < x - A;)y = yu(y), x--; for (; 0 < A - x;)g = yu(g), A--; for (; x--;) { if (y === g || g !== null && y === g.alternate) break t; y = yu(y), g = yu(g) } y = null } else y = null; m !== null && pT(d, p, m, y, !1), v !== null && _ !== null && pT(d, _, v, y, !0) } } e: { if (p = c ? rf(c) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var w = s4; else if (sT(p)) if (xI) w = u4; else { w = l4; var b = a4 } else (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (w = c4); if (w && (w = w(n, c))) { _I(d, w, t, u); break e } b && b(n, p, c), n === "focusout" && (b = p._wrapperState) && b.controlled && p.type === "number" && pS(p, "number", p.value) } switch (b = c ? rf(c) : window, n) { case "focusin": (sT(b) || b.contentEditable === "true") && (tf = b, bS = c, Ah = null); break; case "focusout": Ah = bS = tf = null; break; case "mousedown": CS = !0; break; case "contextmenu": case "mouseup": case "dragend": CS = !1, fT(d, t, u); break; case "selectionchange": if (h4) break; case "keydown": case "keyup": fT(d, t, u) }var T; if (jE) e: { switch (n) { case "compositionstart": var B = "onCompositionStart"; break e; case "compositionend": B = "onCompositionEnd"; break e; case "compositionupdate": B = "onCompositionUpdate"; break e }B = void 0 } else ef ? vI(n, t) && (B = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (B = "onCompositionStart"); B && (gI && t.locale !== "ko" && (ef || B !== "onCompositionStart" ? B === "onCompositionEnd" && ef && (T = mI()) : (tl = u, HE = "value" in tl ? tl.value : tl.textContent, ef = !0)), b = tv(c, B), 0 < b.length && (B = new nT(B, n, null, t, u), d.push({ event: B, listeners: b }), T ? B.data = T : (T = yI(t), T !== null && (B.data = T)))), (T = t4 ? n4(n, t) : r4(n, t)) && (c = tv(c, "onBeforeInput"), 0 < c.length && (u = new nT("onBeforeInput", "beforeinput", null, t, u), d.push({ event: u, listeners: c }), u.data = T)) } PI(d, e) }) } function Yh(n, e, t) { return { instance: n, listener: e, currentTarget: t } } function tv(n, e) { for (var t = e + "Capture", r = []; n !== null;) { var i = n, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = Hh(n, t), o != null && r.unshift(Yh(n, o, i)), o = Hh(n, e), o != null && r.push(Yh(n, o, i))), n = n.return } return r } function yu(n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5); return n || null } function pT(n, e, t, r, i) { for (var o = e._reactName, s = []; t !== null && t !== r;) { var a = t, l = a.alternate, c = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && c !== null && (a = c, i ? (l = Hh(t, o), l != null && s.unshift(Yh(t, l, a))) : i || (l = Hh(t, o), l != null && s.push(Yh(t, l, a)))), t = t.return } s.length !== 0 && n.push({ event: e, listeners: s }) } var v4 = /\r\n?/g, y4 = /\u0000|\uFFFD/g; function mT(n) {
	return (typeof n == "string" ? n : "" + n).replace(v4, `
`).replace(y4, "")
} function og(n, e, t) { if (e = mT(e), mT(n) !== e && t) throw Error(Xe(425)) } function nv() { } var TS = null, RS = null; function PS(n, e) { return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var BS = typeof setTimeout == "function" ? setTimeout : void 0, _4 = typeof clearTimeout == "function" ? clearTimeout : void 0, gT = typeof Promise == "function" ? Promise : void 0, x4 = typeof queueMicrotask == "function" ? queueMicrotask : typeof gT < "u" ? function (n) { return gT.resolve(null).then(n).catch(S4) } : BS; function S4(n) { setTimeout(function () { throw n }) } function I_(n, e) { var t = e, r = 0; do { var i = t.nextSibling; if (n.removeChild(t), i && i.nodeType === 8) if (t = i.data, t === "/$") { if (r === 0) { n.removeChild(i), jh(e); return } r-- } else t !== "$" && t !== "$?" && t !== "$!" || r++; t = i } while (t); jh(e) } function ll(n) { for (; n != null; n = n.nextSibling) { var e = n.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = n.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return n } function vT(n) { n = n.previousSibling; for (var e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "$" || t === "$!" || t === "$?") { if (e === 0) return n; e-- } else t === "/$" && e++ } n = n.previousSibling } return null } var od = Math.random().toString(36).slice(2), _s = "__reactFiber$" + od, $h = "__reactProps$" + od, ma = "__reactContainer$" + od, IS = "__reactEvents$" + od, A4 = "__reactListeners$" + od, E4 = "__reactHandles$" + od; function vc(n) { var e = n[_s]; if (e) return e; for (var t = n.parentNode; t;) { if (e = t[ma] || t[_s]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n = vT(n); n !== null;) { if (t = n[_s]) return t; n = vT(n) } return e } n = t, t = n.parentNode } return null } function Lp(n) { return n = n[_s] || n[ma], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n } function rf(n) { if (n.tag === 5 || n.tag === 6) return n.stateNode; throw Error(Xe(33)) } function Jv(n) { return n[$h] || null } var LS = [], of = -1; function Cl(n) { return { current: n } } function Sn(n) { 0 > of || (n.current = LS[of], LS[of] = null, of--) } function pn(n, e) { of++, LS[of] = n.current, n.current = e } var xl = {}, Zr = Cl(xl), Ii = Cl(!1), Fc = xl; function Lf(n, e) { var t = n.type.contextTypes; if (!t) return xl; var r = n.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, o; for (o in t) i[o] = e[o]; return r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = i), i } function Li(n) { return n = n.childContextTypes, n != null } function rv() { Sn(Ii), Sn(Zr) } function yT(n, e, t) { if (Zr.current !== xl) throw Error(Xe(168)); pn(Zr, e), pn(Ii, t) } function II(n, e, t) { var r = n.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return t; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(Xe(108, aN(n) || "Unknown", i)); return Dn({}, t, r) } function iv(n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || xl, Fc = Zr.current, pn(Zr, n), pn(Ii, Ii.current), !0 } function _T(n, e, t) { var r = n.stateNode; if (!r) throw Error(Xe(169)); t ? (n = II(n, e, Fc), r.__reactInternalMemoizedMergedChildContext = n, Sn(Ii), Sn(Zr), pn(Zr, n)) : Sn(Ii), pn(Ii, t) } var ia = null, Kv = !1, L_ = !1; function LI(n) { ia === null ? ia = [n] : ia.push(n) } function M4(n) { Kv = !0, LI(n) } function Tl() { if (!L_ && ia !== null) { L_ = !0; var n = 0, e = on; try { var t = ia; for (on = 1; n < t.length; n++) { var r = t[n]; do r = r(!0); while (r !== null) } ia = null, Kv = !1 } catch (i) { throw ia !== null && (ia = ia.slice(n + 1)), iI(kE, Tl), i } finally { on = e, L_ = !1 } } return null } var sf = [], af = 0, ov = null, sv = 0, Mo = [], wo = 0, Uc = null, la = 1, ca = ""; function ac(n, e) { sf[af++] = sv, sf[af++] = ov, ov = n, sv = e } function DI(n, e, t) { Mo[wo++] = la, Mo[wo++] = ca, Mo[wo++] = Uc, Uc = n; var r = la; n = ca; var i = 32 - Ko(r) - 1; r &= ~(1 << i), t += 1; var o = 32 - Ko(e) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, la = 1 << 32 - Ko(e) + i | t << i | r, ca = o + n } else la = 1 << o | t << i | r, ca = n } function JE(n) { n.return !== null && (ac(n, 1), DI(n, 1, 0)) } function KE(n) { for (; n === ov;)ov = sf[--af], sf[af] = null, sv = sf[--af], sf[af] = null; for (; n === Uc;)Uc = Mo[--wo], Mo[wo] = null, ca = Mo[--wo], Mo[wo] = null, la = Mo[--wo], Mo[wo] = null } var eo = null, Zi = null, Cn = !1, Wo = null; function OI(n, e) { var t = bo(5, null, null, 0); t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t) } function xT(n, e) { switch (n.tag) { case 5: var t = n.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, eo = n, Zi = ll(e.firstChild), !0) : !1; case 6: return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, eo = n, Zi = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Uc !== null ? { id: la, overflow: ca } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = bo(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, eo = n, Zi = null, !0) : !1; default: return !1 } } function DS(n) { return (n.mode & 1) !== 0 && (n.flags & 128) === 0 } function OS(n) { if (Cn) { var e = Zi; if (e) { var t = e; if (!xT(n, e)) { if (DS(n)) throw Error(Xe(418)); e = ll(t.nextSibling); var r = eo; e && xT(n, e) ? OI(r, t) : (n.flags = n.flags & -4097 | 2, Cn = !1, eo = n) } } else { if (DS(n)) throw Error(Xe(418)); n.flags = n.flags & -4097 | 2, Cn = !1, eo = n } } } function ST(n) { for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;)n = n.return; eo = n } function sg(n) { if (n !== eo) return !1; if (!Cn) return ST(n), Cn = !0, !1; var e; if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !PS(n.type, n.memoizedProps)), e && (e = Zi)) { if (DS(n)) throw FI(), Error(Xe(418)); for (; e;)OI(n, e), e = ll(e.nextSibling) } if (ST(n), n.tag === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(Xe(317)); e: { for (n = n.nextSibling, e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "/$") { if (e === 0) { Zi = ll(n.nextSibling); break e } e-- } else t !== "$" && t !== "$!" && t !== "$?" || e++ } n = n.nextSibling } Zi = null } } else Zi = eo ? ll(n.stateNode.nextSibling) : null; return !0 } function FI() { for (var n = Zi; n;)n = ll(n.nextSibling) } function Df() { Zi = eo = null, Cn = !1 } function YE(n) { Wo === null ? Wo = [n] : Wo.push(n) } var w4 = wa.ReactCurrentBatchConfig; function Go(n, e) { if (n && n.defaultProps) { e = Dn({}, e), n = n.defaultProps; for (var t in n) e[t] === void 0 && (e[t] = n[t]); return e } return e } var av = Cl(null), lv = null, lf = null, $E = null; function QE() { $E = lf = lv = null } function ZE(n) { var e = av.current; Sn(av), n._currentValue = e } function FS(n, e, t) { for (; n !== null;) { var r = n.alternate; if ((n.childLanes & e) !== e ? (n.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), n === t) break; n = n.return } } function Af(n, e) { lv = n, $E = lf = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (Pi = !0), n.firstContext = null) } function Ro(n) { var e = n._currentValue; if ($E !== n) if (n = { context: n, memoizedValue: e, next: null }, lf === null) { if (lv === null) throw Error(Xe(308)); lf = n, lv.dependencies = { lanes: 0, firstContext: n } } else lf = lf.next = n; return e } var yc = null; function qE(n) { yc === null ? yc = [n] : yc.push(n) } function UI(n, e, t, r) { var i = e.interleaved; return i === null ? (t.next = t, qE(e)) : (t.next = i.next, i.next = t), e.interleaved = t, ga(n, r) } function ga(n, e) { n.lanes |= e; var t = n.alternate; for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;)n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return; return t.tag === 3 ? t.stateNode : null } var $a = !1; function eM(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function kI(n, e) { n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function ha(n, e) { return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null } } function cl(n, e, t) { var r = n.updateQueue; if (r === null) return null; if (r = r.shared, Vt & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, ga(n, t) } return i = r.interleaved, i === null ? (e.next = e, qE(r)) : (e.next = i.next, i.next = e), r.interleaved = e, ga(n, t) } function M0(n, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { var r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, NE(n, t) } } function AT(n, e) { var t = n.updateQueue, r = n.alternate; if (r !== null && (r = r.updateQueue, t === r)) { var i = null, o = null; if (t = t.firstBaseUpdate, t !== null) { do { var s = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; o === null ? i = o = s : o = o.next = s, t = t.next } while (t !== null); o === null ? i = o = e : o = o.next = e } else i = o = e; t = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, n.updateQueue = t; return } n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e } function cv(n, e, t, r) { var i = n.updateQueue; $a = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, c = l.next; l.next = null, s === null ? o = c : s.next = c, s = l; var u = n.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (o !== null) { var d = i.baseState; s = 0, u = c = l = null, a = o; do { var p = a.lane, m = a.eventTime; if ((r & p) === p) { u !== null && (u = u.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var v = n, y = a; switch (p = e, m = t, y.tag) { case 1: if (v = y.payload, typeof v == "function") { d = v.call(m, d, p); break e } d = v; break e; case 3: v.flags = v.flags & -65537 | 128; case 0: if (v = y.payload, p = typeof v == "function" ? v.call(m, d, p) : v, p == null) break e; d = Dn({}, d, p); break e; case 2: $a = !0 } } a.callback !== null && a.lane !== 0 && (n.flags |= 64, p = i.effects, p === null ? i.effects = [a] : p.push(a)) } else m = { eventTime: m, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = m, l = d) : u = u.next = m, s |= p; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null } } while (1); if (u === null && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) { i = e; do s |= i.lane, i = i.next; while (i !== e) } else o === null && (i.shared.lanes = 0); Nc |= s, n.lanes = s, n.memoizedState = d } } function ET(n, e, t) { if (n = e.effects, e.effects = null, n !== null) for (e = 0; e < n.length; e++) { var r = n[e], i = r.callback; if (i !== null) { if (r.callback = null, r = t, typeof i != "function") throw Error(Xe(191, i)); i.call(r) } } } var NI = new U3.Component().refs; function US(n, e, t, r) { e = n.memoizedState, t = t(r, e), t = t == null ? e : Dn({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t) } var Yv = { isMounted: function (n) { return (n = n._reactInternals) ? $c(n) === n : !1 }, enqueueSetState: function (n, e, t) { n = n._reactInternals; var r = pi(), i = fl(n), o = ha(r, i); o.payload = e, t != null && (o.callback = t), e = cl(n, o, i), e !== null && (Yo(e, n, i, r), M0(e, n, i)) }, enqueueReplaceState: function (n, e, t) { n = n._reactInternals; var r = pi(), i = fl(n), o = ha(r, i); o.tag = 1, o.payload = e, t != null && (o.callback = t), e = cl(n, o, i), e !== null && (Yo(e, n, i, r), M0(e, n, i)) }, enqueueForceUpdate: function (n, e) { n = n._reactInternals; var t = pi(), r = fl(n), i = ha(t, r); i.tag = 2, e != null && (i.callback = e), e = cl(n, i, r), e !== null && (Yo(e, n, r, t), M0(e, n, r)) } }; function MT(n, e, t, r, i, o, s) { return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(r, o, s) : e.prototype && e.prototype.isPureReactComponent ? !Jh(t, r) || !Jh(i, o) : !0 } function zI(n, e, t) { var r = !1, i = xl, o = e.contextType; return typeof o == "object" && o !== null ? o = Ro(o) : (i = Li(e) ? Fc : Zr.current, r = e.contextTypes, o = (r = r != null) ? Lf(n, i) : xl), e = new e(t, o), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Yv, n.stateNode = e, e._reactInternals = n, r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = i, n.__reactInternalMemoizedMaskedChildContext = o), e } function wT(n, e, t, r) { n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, r), e.state !== n && Yv.enqueueReplaceState(e, e.state, null) } function kS(n, e, t, r) { var i = n.stateNode; i.props = t, i.state = n.memoizedState, i.refs = NI, eM(n); var o = e.contextType; typeof o == "object" && o !== null ? i.context = Ro(o) : (o = Li(e) ? Fc : Zr.current, i.context = Lf(n, o)), i.state = n.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (US(n, e, o, t), i.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Yv.enqueueReplaceState(i, i.state, null), cv(n, t, i, r), i.state = n.memoizedState), typeof i.componentDidMount == "function" && (n.flags |= 4194308) } function Gd(n, e, t) { if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(Xe(309)); var r = t.stateNode } if (!r) throw Error(Xe(147, n)); var i = r, o = "" + n; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function (s) { var a = i.refs; a === NI && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s }, e._stringRef = o, e) } if (typeof n != "string") throw Error(Xe(284)); if (!t._owner) throw Error(Xe(290, n)) } return n } function ag(n, e) { throw n = Object.prototype.toString.call(e), Error(Xe(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n)) } function bT(n) { var e = n._init; return e(n._payload) } function GI(n) { function e(g, x) { if (n) { var A = g.deletions; A === null ? (g.deletions = [x], g.flags |= 16) : A.push(x) } } function t(g, x) { if (!n) return null; for (; x !== null;)e(g, x), x = x.sibling; return null } function r(g, x) { for (g = new Map; x !== null;)x.key !== null ? g.set(x.key, x) : g.set(x.index, x), x = x.sibling; return g } function i(g, x) { return g = dl(g, x), g.index = 0, g.sibling = null, g } function o(g, x, A) { return g.index = A, n ? (A = g.alternate, A !== null ? (A = A.index, A < x ? (g.flags |= 2, x) : A) : (g.flags |= 2, x)) : (g.flags |= 1048576, x) } function s(g) { return n && g.alternate === null && (g.flags |= 2), g } function a(g, x, A, E) { return x === null || x.tag !== 6 ? (x = z_(A, g.mode, E), x.return = g, x) : (x = i(x, A), x.return = g, x) } function l(g, x, A, E) { var w = A.type; return w === qu ? u(g, x, A.props.children, E, A.key) : x !== null && (x.elementType === w || typeof w == "object" && w !== null && w.$$typeof === Ya && bT(w) === x.type) ? (E = i(x, A.props), E.ref = Gd(g, x, A), E.return = g, E) : (E = P0(A.type, A.key, A.props, null, g.mode, E), E.ref = Gd(g, x, A), E.return = g, E) } function c(g, x, A, E) { return x === null || x.tag !== 4 || x.stateNode.containerInfo !== A.containerInfo || x.stateNode.implementation !== A.implementation ? (x = G_(A, g.mode, E), x.return = g, x) : (x = i(x, A.children || []), x.return = g, x) } function u(g, x, A, E, w) { return x === null || x.tag !== 7 ? (x = Tc(A, g.mode, E, w), x.return = g, x) : (x = i(x, A), x.return = g, x) } function d(g, x, A) { if (typeof x == "string" && x !== "" || typeof x == "number") return x = z_("" + x, g.mode, A), x.return = g, x; if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case $m: return A = P0(x.type, x.key, x.props, null, g.mode, A), A.ref = Gd(g, null, x), A.return = g, A; case Zu: return x = G_(x, g.mode, A), x.return = g, x; case Ya: var E = x._init; return d(g, E(x._payload), A) }if (uh(x) || Fd(x)) return x = Tc(x, g.mode, A, null), x.return = g, x; ag(g, x) } return null } function p(g, x, A, E) { var w = x !== null ? x.key : null; if (typeof A == "string" && A !== "" || typeof A == "number") return w !== null ? null : a(g, x, "" + A, E); if (typeof A == "object" && A !== null) { switch (A.$$typeof) { case $m: return A.key === w ? l(g, x, A, E) : null; case Zu: return A.key === w ? c(g, x, A, E) : null; case Ya: return w = A._init, p(g, x, w(A._payload), E) }if (uh(A) || Fd(A)) return w !== null ? null : u(g, x, A, E, null); ag(g, A) } return null } function m(g, x, A, E, w) { if (typeof E == "string" && E !== "" || typeof E == "number") return g = g.get(A) || null, a(x, g, "" + E, w); if (typeof E == "object" && E !== null) { switch (E.$$typeof) { case $m: return g = g.get(E.key === null ? A : E.key) || null, l(x, g, E, w); case Zu: return g = g.get(E.key === null ? A : E.key) || null, c(x, g, E, w); case Ya: var b = E._init; return m(g, x, A, b(E._payload), w) }if (uh(E) || Fd(E)) return g = g.get(A) || null, u(x, g, E, w, null); ag(x, E) } return null } function v(g, x, A, E) { for (var w = null, b = null, T = x, B = x = 0, R = null; T !== null && B < A.length; B++) { T.index > B ? (R = T, T = null) : R = T.sibling; var P = p(g, T, A[B], E); if (P === null) { T === null && (T = R); break } n && T && P.alternate === null && e(g, T), x = o(P, x, B), b === null ? w = P : b.sibling = P, b = P, T = R } if (B === A.length) return t(g, T), Cn && ac(g, B), w; if (T === null) { for (; B < A.length; B++)T = d(g, A[B], E), T !== null && (x = o(T, x, B), b === null ? w = T : b.sibling = T, b = T); return Cn && ac(g, B), w } for (T = r(g, T); B < A.length; B++)R = m(T, g, B, A[B], E), R !== null && (n && R.alternate !== null && T.delete(R.key === null ? B : R.key), x = o(R, x, B), b === null ? w = R : b.sibling = R, b = R); return n && T.forEach(function (U) { return e(g, U) }), Cn && ac(g, B), w } function y(g, x, A, E) { var w = Fd(A); if (typeof w != "function") throw Error(Xe(150)); if (A = w.call(A), A == null) throw Error(Xe(151)); for (var b = w = null, T = x, B = x = 0, R = null, P = A.next(); T !== null && !P.done; B++, P = A.next()) { T.index > B ? (R = T, T = null) : R = T.sibling; var U = p(g, T, P.value, E); if (U === null) { T === null && (T = R); break } n && T && U.alternate === null && e(g, T), x = o(U, x, B), b === null ? w = U : b.sibling = U, b = U, T = R } if (P.done) return t(g, T), Cn && ac(g, B), w; if (T === null) { for (; !P.done; B++, P = A.next())P = d(g, P.value, E), P !== null && (x = o(P, x, B), b === null ? w = P : b.sibling = P, b = P); return Cn && ac(g, B), w } for (T = r(g, T); !P.done; B++, P = A.next())P = m(T, g, B, P.value, E), P !== null && (n && P.alternate !== null && T.delete(P.key === null ? B : P.key), x = o(P, x, B), b === null ? w = P : b.sibling = P, b = P); return n && T.forEach(function (G) { return e(g, G) }), Cn && ac(g, B), w } function _(g, x, A, E) { if (typeof A == "object" && A !== null && A.type === qu && A.key === null && (A = A.props.children), typeof A == "object" && A !== null) { switch (A.$$typeof) { case $m: e: { for (var w = A.key, b = x; b !== null;) { if (b.key === w) { if (w = A.type, w === qu) { if (b.tag === 7) { t(g, b.sibling), x = i(b, A.props.children), x.return = g, g = x; break e } } else if (b.elementType === w || typeof w == "object" && w !== null && w.$$typeof === Ya && bT(w) === b.type) { t(g, b.sibling), x = i(b, A.props), x.ref = Gd(g, b, A), x.return = g, g = x; break e } t(g, b); break } else e(g, b); b = b.sibling } A.type === qu ? (x = Tc(A.props.children, g.mode, E, A.key), x.return = g, g = x) : (E = P0(A.type, A.key, A.props, null, g.mode, E), E.ref = Gd(g, x, A), E.return = g, g = E) } return s(g); case Zu: e: { for (b = A.key; x !== null;) { if (x.key === b) if (x.tag === 4 && x.stateNode.containerInfo === A.containerInfo && x.stateNode.implementation === A.implementation) { t(g, x.sibling), x = i(x, A.children || []), x.return = g, g = x; break e } else { t(g, x); break } else e(g, x); x = x.sibling } x = G_(A, g.mode, E), x.return = g, g = x } return s(g); case Ya: return b = A._init, _(g, x, b(A._payload), E) }if (uh(A)) return v(g, x, A, E); if (Fd(A)) return y(g, x, A, E); ag(g, A) } return typeof A == "string" && A !== "" || typeof A == "number" ? (A = "" + A, x !== null && x.tag === 6 ? (t(g, x.sibling), x = i(x, A), x.return = g, g = x) : (t(g, x), x = z_(A, g.mode, E), x.return = g, g = x), s(g)) : t(g, x) } return _ } var Of = GI(!0), HI = GI(!1), Dp = {}, ws = Cl(Dp), Qh = Cl(Dp), Zh = Cl(Dp); function _c(n) { if (n === Dp) throw Error(Xe(174)); return n } function tM(n, e) { switch (pn(Zh, e), pn(Qh, n), pn(ws, Dp), n = e.nodeType, n) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : gS(null, ""); break; default: n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = gS(e, n) }Sn(ws), pn(ws, e) } function Ff() { Sn(ws), Sn(Qh), Sn(Zh) } function VI(n) { _c(Zh.current); var e = _c(ws.current), t = gS(e, n.type); e !== t && (pn(Qh, n), pn(ws, t)) } function nM(n) { Qh.current === n && (Sn(ws), Sn(Qh)) } var Pn = Cl(0); function uv(n) { for (var e = n; e !== null;) { if (e.tag === 13) { var t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var D_ = []; function rM() { for (var n = 0; n < D_.length; n++)D_[n]._workInProgressVersionPrimary = null; D_.length = 0 } var w0 = wa.ReactCurrentDispatcher, O_ = wa.ReactCurrentBatchConfig, kc = 0, Ln = null, sr = null, yr = null, fv = !1, Eh = !1, qh = 0, b4 = 0; function Gr() { throw Error(Xe(321)) } function iM(n, e) { if (e === null) return !1; for (var t = 0; t < e.length && t < n.length; t++)if (!Zo(n[t], e[t])) return !1; return !0 } function oM(n, e, t, r, i, o) { if (kc = o, Ln = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, w0.current = n === null || n.memoizedState === null ? P4 : B4, n = t(r, i), Eh) { o = 0; do { if (Eh = !1, qh = 0, 25 <= o) throw Error(Xe(301)); o += 1, yr = sr = null, e.updateQueue = null, w0.current = I4, n = t(r, i) } while (Eh) } if (w0.current = dv, e = sr !== null && sr.next !== null, kc = 0, yr = sr = Ln = null, fv = !1, e) throw Error(Xe(300)); return n } function sM() { var n = qh !== 0; return qh = 0, n } function ms() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return yr === null ? Ln.memoizedState = yr = n : yr = yr.next = n, yr } function Po() { if (sr === null) { var n = Ln.alternate; n = n !== null ? n.memoizedState : null } else n = sr.next; var e = yr === null ? Ln.memoizedState : yr.next; if (e !== null) yr = e, sr = n; else { if (n === null) throw Error(Xe(310)); sr = n, n = { memoizedState: sr.memoizedState, baseState: sr.baseState, baseQueue: sr.baseQueue, queue: sr.queue, next: null }, yr === null ? Ln.memoizedState = yr = n : yr = yr.next = n } return yr } function ep(n, e) { return typeof e == "function" ? e(n) : e } function F_(n) { var e = Po(), t = e.queue; if (t === null) throw Error(Xe(311)); t.lastRenderedReducer = n; var r = sr, i = r.baseQueue, o = t.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, t.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, c = o; do { var u = c.lane; if ((kc & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : n(r, c.action); else { var d = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = d, s = r) : l = l.next = d, Ln.lanes |= u, Nc |= u } c = c.next } while (c !== null && c !== o); l === null ? s = r : l.next = a, Zo(r, e.memoizedState) || (Pi = !0), e.memoizedState = r, e.baseState = s, e.baseQueue = l, t.lastRenderedState = r } if (n = t.interleaved, n !== null) { i = n; do o = i.lane, Ln.lanes |= o, Nc |= o, i = i.next; while (i !== n) } else i === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function U_(n) { var e = Po(), t = e.queue; if (t === null) throw Error(Xe(311)); t.lastRenderedReducer = n; var r = t.dispatch, i = t.pending, o = e.memoizedState; if (i !== null) { t.pending = null; var s = i = i.next; do o = n(o, s.action), s = s.next; while (s !== i); Zo(o, e.memoizedState) || (Pi = !0), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), t.lastRenderedState = o } return [o, r] } function WI() { } function jI(n, e) { var t = Ln, r = Po(), i = e(), o = !Zo(r.memoizedState, i); if (o && (r.memoizedState = i, Pi = !0), r = r.queue, aM(KI.bind(null, t, r, n), [n]), r.getSnapshot !== e || o || yr !== null && yr.memoizedState.tag & 1) { if (t.flags |= 2048, tp(9, JI.bind(null, t, r, i, e), void 0, null), xr === null) throw Error(Xe(349)); kc & 30 || XI(t, e, i) } return i } function XI(n, e, t) { n.flags |= 16384, n = { getSnapshot: e, value: t }, e = Ln.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ln.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n)) } function JI(n, e, t, r) { e.value = t, e.getSnapshot = r, YI(e) && $I(n) } function KI(n, e, t) { return t(function () { YI(e) && $I(n) }) } function YI(n) { var e = n.getSnapshot; n = n.value; try { var t = e(); return !Zo(n, t) } catch { return !0 } } function $I(n) { var e = ga(n, 1); e !== null && Yo(e, n, 1, -1) } function CT(n) { var e = ms(); return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ep, lastRenderedState: n }, e.queue = n, n = n.dispatch = R4.bind(null, Ln, n), [e.memoizedState, n] } function tp(n, e, t, r) { return n = { tag: n, create: e, destroy: t, deps: r, next: null }, e = Ln.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ln.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (r = t.next, t.next = n, n.next = r, e.lastEffect = n)), n } function QI() { return Po().memoizedState } function b0(n, e, t, r) { var i = ms(); Ln.flags |= n, i.memoizedState = tp(1 | e, t, void 0, r === void 0 ? null : r) } function $v(n, e, t, r) { var i = Po(); r = r === void 0 ? null : r; var o = void 0; if (sr !== null) { var s = sr.memoizedState; if (o = s.destroy, r !== null && iM(r, s.deps)) { i.memoizedState = tp(e, t, o, r); return } } Ln.flags |= n, i.memoizedState = tp(1 | e, t, o, r) } function TT(n, e) { return b0(8390656, 8, n, e) } function aM(n, e) { return $v(2048, 8, n, e) } function ZI(n, e) { return $v(4, 2, n, e) } function qI(n, e) { return $v(4, 4, n, e) } function eL(n, e) { if (typeof e == "function") return n = n(), e(n), function () { e(null) }; if (e != null) return n = n(), e.current = n, function () { e.current = null } } function tL(n, e, t) { return t = t != null ? t.concat([n]) : null, $v(4, 4, eL.bind(null, e, n), t) } function lM() { } function nL(n, e) { var t = Po(); e = e === void 0 ? null : e; var r = t.memoizedState; return r !== null && e !== null && iM(e, r[1]) ? r[0] : (t.memoizedState = [n, e], n) } function rL(n, e) { var t = Po(); e = e === void 0 ? null : e; var r = t.memoizedState; return r !== null && e !== null && iM(e, r[1]) ? r[0] : (n = n(), t.memoizedState = [n, e], n) } function iL(n, e, t) { return kc & 21 ? (Zo(t, e) || (t = aI(), Ln.lanes |= t, Nc |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, Pi = !0), n.memoizedState = t) } function C4(n, e) { var t = on; on = t !== 0 && 4 > t ? t : 4, n(!0); var r = O_.transition; O_.transition = {}; try { n(!1), e() } finally { on = t, O_.transition = r } } function oL() { return Po().memoizedState } function T4(n, e, t) { var r = fl(n); if (t = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }, sL(n)) aL(e, t); else if (t = UI(n, e, t, r), t !== null) { var i = pi(); Yo(t, n, r, i), lL(t, e, r) } } function R4(n, e, t) { var r = fl(n), i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }; if (sL(n)) aL(e, i); else { var o = n.alternate; if (n.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null)) try { var s = e.lastRenderedState, a = o(s, t); if (i.hasEagerState = !0, i.eagerState = a, Zo(a, s)) { var l = e.interleaved; l === null ? (i.next = i, qE(e)) : (i.next = l.next, l.next = i), e.interleaved = i; return } } catch { } finally { } t = UI(n, e, i, r), t !== null && (i = pi(), Yo(t, n, r, i), lL(t, e, r)) } } function sL(n) { var e = n.alternate; return n === Ln || e !== null && e === Ln } function aL(n, e) { Eh = fv = !0; var t = n.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e } function lL(n, e, t) { if (t & 4194240) { var r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, NE(n, t) } } var dv = { readContext: Ro, useCallback: Gr, useContext: Gr, useEffect: Gr, useImperativeHandle: Gr, useInsertionEffect: Gr, useLayoutEffect: Gr, useMemo: Gr, useReducer: Gr, useRef: Gr, useState: Gr, useDebugValue: Gr, useDeferredValue: Gr, useTransition: Gr, useMutableSource: Gr, useSyncExternalStore: Gr, useId: Gr, unstable_isNewReconciler: !1 }, P4 = { readContext: Ro, useCallback: function (n, e) { return ms().memoizedState = [n, e === void 0 ? null : e], n }, useContext: Ro, useEffect: TT, useImperativeHandle: function (n, e, t) { return t = t != null ? t.concat([n]) : null, b0(4194308, 4, eL.bind(null, e, n), t) }, useLayoutEffect: function (n, e) { return b0(4194308, 4, n, e) }, useInsertionEffect: function (n, e) { return b0(4, 2, n, e) }, useMemo: function (n, e) { var t = ms(); return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n }, useReducer: function (n, e, t) { var r = ms(); return e = t !== void 0 ? t(e) : e, r.memoizedState = r.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, r.queue = n, n = n.dispatch = T4.bind(null, Ln, n), [r.memoizedState, n] }, useRef: function (n) { var e = ms(); return n = { current: n }, e.memoizedState = n }, useState: CT, useDebugValue: lM, useDeferredValue: function (n) { return ms().memoizedState = n }, useTransition: function () { var n = CT(!1), e = n[0]; return n = C4.bind(null, n[1]), ms().memoizedState = n, [e, n] }, useMutableSource: function () { }, useSyncExternalStore: function (n, e, t) { var r = Ln, i = ms(); if (Cn) { if (t === void 0) throw Error(Xe(407)); t = t() } else { if (t = e(), xr === null) throw Error(Xe(349)); kc & 30 || XI(r, e, t) } i.memoizedState = t; var o = { value: t, getSnapshot: e }; return i.queue = o, TT(KI.bind(null, r, o, n), [n]), r.flags |= 2048, tp(9, JI.bind(null, r, o, t, e), void 0, null), t }, useId: function () { var n = ms(), e = xr.identifierPrefix; if (Cn) { var t = ca, r = la; t = (r & ~(1 << 32 - Ko(r) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = qh++, 0 < t && (e += "H" + t.toString(32)), e += ":" } else t = b4++, e = ":" + e + "r" + t.toString(32) + ":"; return n.memoizedState = e }, unstable_isNewReconciler: !1 }, B4 = { readContext: Ro, useCallback: nL, useContext: Ro, useEffect: aM, useImperativeHandle: tL, useInsertionEffect: ZI, useLayoutEffect: qI, useMemo: rL, useReducer: F_, useRef: QI, useState: function () { return F_(ep) }, useDebugValue: lM, useDeferredValue: function (n) { var e = Po(); return iL(e, sr.memoizedState, n) }, useTransition: function () { var n = F_(ep)[0], e = Po().memoizedState; return [n, e] }, useMutableSource: WI, useSyncExternalStore: jI, useId: oL, unstable_isNewReconciler: !1 }, I4 = { readContext: Ro, useCallback: nL, useContext: Ro, useEffect: aM, useImperativeHandle: tL, useInsertionEffect: ZI, useLayoutEffect: qI, useMemo: rL, useReducer: U_, useRef: QI, useState: function () { return U_(ep) }, useDebugValue: lM, useDeferredValue: function (n) { var e = Po(); return sr === null ? e.memoizedState = n : iL(e, sr.memoizedState, n) }, useTransition: function () { var n = U_(ep)[0], e = Po().memoizedState; return [n, e] }, useMutableSource: WI, useSyncExternalStore: jI, useId: oL, unstable_isNewReconciler: !1 }; function Uf(n, e) {
	try { var t = "", r = e; do t += sN(r), r = r.return; while (r); var i = t } catch (o) {
		i = `
Error generating stack: `+ o.message + `
`+ o.stack
	} return { value: n, source: e, stack: i, digest: null }
} function k_(n, e, t) { return { value: n, source: null, stack: t ?? null, digest: e ?? null } } function NS(n, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } var L4 = typeof WeakMap == "function" ? WeakMap : Map; function cL(n, e, t) { t = ha(-1, t), t.tag = 3, t.payload = { element: null }; var r = e.value; return t.callback = function () { pv || (pv = !0, YS = r), NS(n, e) }, t } function uL(n, e, t) { t = ha(-1, t), t.tag = 3; var r = n.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; t.payload = function () { return r(i) }, t.callback = function () { NS(n, e) } } var o = n.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (t.callback = function () { NS(n, e), typeof r != "function" && (ul === null ? ul = new Set([this]) : ul.add(this)); var s = e.stack; this.componentDidCatch(e.value, { componentStack: s !== null ? s : "" }) }), t } function RT(n, e, t) { var r = n.pingCache; if (r === null) { r = n.pingCache = new L4; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(t) || (i.add(t), n = J4.bind(null, n, e, t), e.then(n, n)) } function PT(n) { do { var e; if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n; n = n.return } while (n !== null); return null } function BT(n, e, t, r, i) { return n.mode & 1 ? (n.flags |= 65536, n.lanes = i, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = ha(-1, 1), e.tag = 2, cl(t, e, 1))), t.lanes |= 1), n) } var D4 = wa.ReactCurrentOwner, Pi = !1; function di(n, e, t, r) { e.child = n === null ? HI(e, null, t, r) : Of(e, n.child, t, r) } function IT(n, e, t, r, i) { t = t.render; var o = e.ref; return Af(e, i), r = oM(n, e, t, r, o, i), t = sM(), n !== null && !Pi ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, va(n, e, i)) : (Cn && t && JE(e), e.flags |= 1, di(n, e, r, i), e.child) } function LT(n, e, t, r, i) { if (n === null) { var o = t.type; return typeof o == "function" && !gM(o) && o.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = o, fL(n, e, o, r, i)) : (n = P0(t.type, null, r, e, e.mode, i), n.ref = e.ref, n.return = e, e.child = n) } if (o = n.child, !(n.lanes & i)) { var s = o.memoizedProps; if (t = t.compare, t = t !== null ? t : Jh, t(s, r) && n.ref === e.ref) return va(n, e, i) } return e.flags |= 1, n = dl(o, r), n.ref = e.ref, n.return = e, e.child = n } function fL(n, e, t, r, i) { if (n !== null) { var o = n.memoizedProps; if (Jh(o, r) && n.ref === e.ref) if (Pi = !1, e.pendingProps = r = o, (n.lanes & i) !== 0) n.flags & 131072 && (Pi = !0); else return e.lanes = n.lanes, va(n, e, i) } return zS(n, e, t, r, i) } function dL(n, e, t) { var r = e.pendingProps, i = r.children, o = n !== null ? n.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, pn(uf, Ki), Ki |= t; else { if (!(t & 1073741824)) return n = o !== null ? o.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, pn(uf, Ki), Ki |= n, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : t, pn(uf, Ki), Ki |= r } else o !== null ? (r = o.baseLanes | t, e.memoizedState = null) : r = t, pn(uf, Ki), Ki |= r; return di(n, e, i, t), e.child } function hL(n, e) { var t = e.ref; (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function zS(n, e, t, r, i) { var o = Li(t) ? Fc : Zr.current; return o = Lf(e, o), Af(e, i), t = oM(n, e, t, r, o, i), r = sM(), n !== null && !Pi ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, va(n, e, i)) : (Cn && r && JE(e), e.flags |= 1, di(n, e, t, i), e.child) } function DT(n, e, t, r, i) { if (Li(t)) { var o = !0; iv(e) } else o = !1; if (Af(e, i), e.stateNode === null) C0(n, e), zI(e, t, r), kS(e, t, r, i), r = !0; else if (n === null) { var s = e.stateNode, a = e.memoizedProps; s.props = a; var l = s.context, c = t.contextType; typeof c == "object" && c !== null ? c = Ro(c) : (c = Li(t) ? Fc : Zr.current, c = Lf(e, c)); var u = t.getDerivedStateFromProps, d = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"; d || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && wT(e, s, r, c), $a = !1; var p = e.memoizedState; s.state = p, cv(e, r, s, i), l = e.memoizedState, a !== r || p !== l || Ii.current || $a ? (typeof u == "function" && (US(e, t, u, r), l = e.memoizedState), (a = $a || MT(e, t, a, r, p, l, c)) ? (d || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { s = e.stateNode, kI(n, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Go(e.type, a), s.props = c, d = e.pendingProps, p = s.context, l = t.contextType, typeof l == "object" && l !== null ? l = Ro(l) : (l = Li(t) ? Fc : Zr.current, l = Lf(e, l)); var m = t.getDerivedStateFromProps; (u = typeof m == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== d || p !== l) && wT(e, s, r, l), $a = !1, p = e.memoizedState, s.state = p, cv(e, r, s, i); var v = e.memoizedState; a !== d || p !== v || Ii.current || $a ? (typeof m == "function" && (US(e, t, m, r), v = e.memoizedState), (c = $a || MT(e, t, c, r, p, v, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, v, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, v, l)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = v), s.props = r, s.state = v, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), r = !1) } return GS(n, e, t, r, o, i) } function GS(n, e, t, r, i, o) { hL(n, e); var s = (e.flags & 128) !== 0; if (!r && !s) return i && _T(e, t, !1), va(n, e, o); r = e.stateNode, D4.current = e; var a = s && typeof t.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, n !== null && s ? (e.child = Of(e, n.child, null, o), e.child = Of(e, null, a, o)) : di(n, e, a, o), e.memoizedState = r.state, i && _T(e, t, !0), e.child } function pL(n) { var e = n.stateNode; e.pendingContext ? yT(n, e.pendingContext, e.pendingContext !== e.context) : e.context && yT(n, e.context, !1), tM(n, e.containerInfo) } function OT(n, e, t, r, i) { return Df(), YE(i), e.flags |= 256, di(n, e, t, r), e.child } var HS = { dehydrated: null, treeContext: null, retryLane: 0 }; function VS(n) { return { baseLanes: n, cachePool: null, transitions: null } } function mL(n, e, t) { var r = e.pendingProps, i = Pn.current, o = !1, s = (e.flags & 128) !== 0, a; if ((a = s) || (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0), a ? (o = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (i |= 1), pn(Pn, i & 1), n === null) return OS(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (s = r.children, n = r.fallback, o ? (r = e.mode, o = e.child, s = { mode: "hidden", children: s }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = qv(s, r, 0, null), n = Tc(n, r, t, null), o.return = e, n.return = e, o.sibling = n, e.child = o, e.child.memoizedState = VS(t), e.memoizedState = HS, n) : cM(e, s)); if (i = n.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return O4(n, e, s, r, a, i, t); if (o) { o = r.fallback, s = e.mode, i = n.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(s & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = dl(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = dl(a, o) : (o = Tc(o, s, t, null), o.flags |= 2), o.return = e, r.return = e, r.sibling = o, e.child = r, r = o, o = e.child, s = n.child.memoizedState, s = s === null ? VS(t) : { baseLanes: s.baseLanes | t, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = n.childLanes & ~t, e.memoizedState = HS, r } return o = n.child, n = o.sibling, r = dl(o, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = t), r.return = e, r.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = r, e.memoizedState = null, r } function cM(n, e) { return e = qv({ mode: "visible", children: e }, n.mode, 0, null), e.return = n, n.child = e } function lg(n, e, t, r) { return r !== null && YE(r), Of(e, n.child, null, t), n = cM(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n } function O4(n, e, t, r, i, o, s) { if (t) return e.flags & 256 ? (e.flags &= -257, r = k_(Error(Xe(422))), lg(n, e, s, r)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (o = r.fallback, i = e.mode, r = qv({ mode: "visible", children: r.children }, i, 0, null), o = Tc(o, i, s, null), o.flags |= 2, r.return = e, o.return = e, r.sibling = o, e.child = r, e.mode & 1 && Of(e, n.child, null, s), e.child.memoizedState = VS(s), e.memoizedState = HS, o); if (!(e.mode & 1)) return lg(n, e, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(Xe(419)), r = k_(o, r, void 0), lg(n, e, s, r) } if (a = (s & n.childLanes) !== 0, Pi || a) { if (r = xr, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, ga(n, i), Yo(r, n, i, -1)) } return mM(), r = k_(Error(Xe(421))), lg(n, e, s, r) } return i.data === "$?" ? (e.flags |= 128, e.child = n.child, e = K4.bind(null, n), i._reactRetry = e, null) : (n = o.treeContext, Zi = ll(i.nextSibling), eo = e, Cn = !0, Wo = null, n !== null && (Mo[wo++] = la, Mo[wo++] = ca, Mo[wo++] = Uc, la = n.id, ca = n.overflow, Uc = e), e = cM(e, r.children), e.flags |= 4096, e) } function FT(n, e, t) { n.lanes |= e; var r = n.alternate; r !== null && (r.lanes |= e), FS(n.return, e, t) } function N_(n, e, t, r, i) { var o = n.memoizedState; o === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: t, tailMode: i } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = t, o.tailMode = i) } function gL(n, e, t) { var r = e.pendingProps, i = r.revealOrder, o = r.tail; if (di(n, e, r.children, t), r = Pn.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (n !== null && n.flags & 128) e: for (n = e.child; n !== null;) { if (n.tag === 13) n.memoizedState !== null && FT(n, t, e); else if (n.tag === 19) FT(n, t, e); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (; n.sibling === null;) { if (n.return === null || n.return === e) break e; n = n.return } n.sibling.return = n.return, n = n.sibling } r &= 1 } if (pn(Pn, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (t = e.child, i = null; t !== null;)n = t.alternate, n !== null && uv(n) === null && (i = t), t = t.sibling; t = i, t === null ? (i = e.child, e.child = null) : (i = t.sibling, t.sibling = null), N_(e, !1, i, t, o); break; case "backwards": for (t = null, i = e.child, e.child = null; i !== null;) { if (n = i.alternate, n !== null && uv(n) === null) { e.child = i; break } n = i.sibling, i.sibling = t, t = i, i = n } N_(e, !0, t, null, o); break; case "together": N_(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function C0(n, e) { !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2) } function va(n, e, t) { if (n !== null && (e.dependencies = n.dependencies), Nc |= e.lanes, !(t & e.childLanes)) return null; if (n !== null && e.child !== n.child) throw Error(Xe(153)); if (e.child !== null) { for (n = e.child, t = dl(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;)n = n.sibling, t = t.sibling = dl(n, n.pendingProps), t.return = e; t.sibling = null } return e.child } function F4(n, e, t) { switch (e.tag) { case 3: pL(e), Df(); break; case 5: VI(e); break; case 1: Li(e.type) && iv(e); break; case 4: tM(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; pn(av, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (pn(Pn, Pn.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? mL(n, e, t) : (pn(Pn, Pn.current & 1), n = va(n, e, t), n !== null ? n.sibling : null); pn(Pn, Pn.current & 1); break; case 19: if (r = (t & e.childLanes) !== 0, n.flags & 128) { if (r) return gL(n, e, t); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), pn(Pn, Pn.current), r) break; return null; case 22: case 23: return e.lanes = 0, dL(n, e, t) }return va(n, e, t) } var vL, WS, yL, _L; vL = function (n, e) { for (var t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return } t.sibling.return = t.return, t = t.sibling } }; WS = function () { }; yL = function (n, e, t, r) { var i = n.memoizedProps; if (i !== r) { n = e.stateNode, _c(ws.current); var o = null; switch (t) { case "input": i = dS(n, i), r = dS(n, r), o = []; break; case "select": i = Dn({}, i, { value: void 0 }), r = Dn({}, r, { value: void 0 }), o = []; break; case "textarea": i = mS(n, i), r = mS(n, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (n.onclick = nv) }vS(t, r); var s; t = null; for (c in i) if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === "style") { var a = i[c]; for (s in a) a.hasOwnProperty(s) && (t || (t = {}), t[s] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (zh.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null)); for (c in r) { var l = r[c]; if (a = i != null ? i[c] : void 0, r.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (t || (t = {}), t[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (t || (t = {}), t[s] = l[s]) } else t || (o || (o = []), o.push(c, t)), t = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (zh.hasOwnProperty(c) ? (l != null && c === "onScroll" && vn("scroll", n), o || a === l || (o = [])) : (o = o || []).push(c, l)) } t && (o = o || []).push("style", t); var c = o; (e.updateQueue = c) && (e.flags |= 4) } }; _L = function (n, e, t, r) { t !== r && (e.flags |= 4) }; function Hd(n, e) { if (!Cn) switch (n.tailMode) { case "hidden": e = n.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? n.tail = null : t.sibling = null; break; case "collapsed": t = n.tail; for (var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling; r === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : r.sibling = null } } function Hr(n) { var e = n.alternate !== null && n.alternate.child === n.child, t = 0, r = 0; if (e) for (var i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = n, i = i.sibling; else for (i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = n, i = i.sibling; return n.subtreeFlags |= r, n.childLanes = t, e } function U4(n, e, t) { var r = e.pendingProps; switch (KE(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Hr(e), null; case 1: return Li(e.type) && rv(), Hr(e), null; case 3: return r = e.stateNode, Ff(), Sn(Ii), Sn(Zr), rM(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (n === null || n.child === null) && (sg(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Wo !== null && (ZS(Wo), Wo = null))), WS(n, e), Hr(e), null; case 5: nM(e); var i = _c(Zh.current); if (t = e.type, n !== null && e.stateNode != null) yL(n, e, t, r, i), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(Xe(166)); return Hr(e), null } if (n = _c(ws.current), sg(e)) { r = e.stateNode, t = e.type; var o = e.memoizedProps; switch (r[_s] = e, r[$h] = o, n = (e.mode & 1) !== 0, t) { case "dialog": vn("cancel", r), vn("close", r); break; case "iframe": case "object": case "embed": vn("load", r); break; case "video": case "audio": for (i = 0; i < dh.length; i++)vn(dh[i], r); break; case "source": vn("error", r); break; case "img": case "image": case "link": vn("error", r), vn("load", r); break; case "details": vn("toggle", r); break; case "input": jC(r, o), vn("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, vn("invalid", r); break; case "textarea": JC(r, o), vn("invalid", r) }vS(t, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && og(r.textContent, a, n), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && og(r.textContent, a, n), i = ["children", "" + a]) : zh.hasOwnProperty(s) && a != null && s === "onScroll" && vn("scroll", r) } switch (t) { case "input": Qm(r), XC(r, o, !0); break; case "textarea": Qm(r), KC(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = nv) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = X3(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = s.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof r.is == "string" ? n = s.createElement(t, { is: r.is }) : (n = s.createElement(t), t === "select" && (s = n, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : n = s.createElementNS(n, t), n[_s] = e, n[$h] = r, vL(n, e, !1, !1), e.stateNode = n; e: { switch (s = yS(t, r), t) { case "dialog": vn("cancel", n), vn("close", n), i = r; break; case "iframe": case "object": case "embed": vn("load", n), i = r; break; case "video": case "audio": for (i = 0; i < dh.length; i++)vn(dh[i], n); i = r; break; case "source": vn("error", n), i = r; break; case "img": case "image": case "link": vn("error", n), vn("load", n), i = r; break; case "details": vn("toggle", n), i = r; break; case "input": jC(n, r), i = dS(n, r), vn("invalid", n); break; case "option": i = r; break; case "select": n._wrapperState = { wasMultiple: !!r.multiple }, i = Dn({}, r, { value: void 0 }), vn("invalid", n); break; case "textarea": JC(n, r), i = mS(n, r), vn("invalid", n); break; default: i = r }vS(t, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? Y3(n, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && J3(n, l)) : o === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Gh(n, l) : typeof l == "number" && Gh(n, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (zh.hasOwnProperty(o) ? l != null && o === "onScroll" && vn("scroll", n) : l != null && LE(n, o, l, s)) } switch (t) { case "input": Qm(n), XC(n, r, !1); break; case "textarea": Qm(n), KC(n); break; case "option": r.value != null && n.setAttribute("value", "" + _l(r.value)); break; case "select": n.multiple = !!r.multiple, o = r.value, o != null ? yf(n, !!r.multiple, o, !1) : r.defaultValue != null && yf(n, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (n.onclick = nv) }switch (t) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Hr(e), null; case 6: if (n && e.stateNode != null) _L(n, e, n.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(Xe(166)); if (t = _c(Zh.current), _c(ws.current), sg(e)) { if (r = e.stateNode, t = e.memoizedProps, r[_s] = e, (o = r.nodeValue !== t) && (n = eo, n !== null)) switch (n.tag) { case 3: og(r.nodeValue, t, (n.mode & 1) !== 0); break; case 5: n.memoizedProps.suppressHydrationWarning !== !0 && og(r.nodeValue, t, (n.mode & 1) !== 0) }o && (e.flags |= 4) } else r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r), r[_s] = e, e.stateNode = r } return Hr(e), null; case 13: if (Sn(Pn), r = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (Cn && Zi !== null && e.mode & 1 && !(e.flags & 128)) FI(), Df(), e.flags |= 98560, o = !1; else if (o = sg(e), r !== null && r.dehydrated !== null) { if (n === null) { if (!o) throw Error(Xe(318)); if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(Xe(317)); o[_s] = e } else Df(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Hr(e), o = !1 } else Wo !== null && (ZS(Wo), Wo = null), o = !0; if (!o) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (r = r !== null, r !== (n !== null && n.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (n === null || Pn.current & 1 ? cr === 0 && (cr = 3) : mM())), e.updateQueue !== null && (e.flags |= 4), Hr(e), null); case 4: return Ff(), WS(n, e), n === null && Kh(e.stateNode.containerInfo), Hr(e), null; case 10: return ZE(e.type._context), Hr(e), null; case 17: return Li(e.type) && rv(), Hr(e), null; case 19: if (Sn(Pn), o = e.memoizedState, o === null) return Hr(e), null; if (r = (e.flags & 128) !== 0, s = o.rendering, s === null) if (r) Hd(o, !1); else { if (cr !== 0 || n !== null && n.flags & 128) for (n = e.child; n !== null;) { if (s = uv(n), s !== null) { for (e.flags |= 128, Hd(o, !1), r = s.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = t, t = e.child; t !== null;)o = t, n = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = n, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, n = s.dependencies, o.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling; return pn(Pn, Pn.current & 1 | 2), e.child } n = n.sibling } o.tail !== null && Kn() > kf && (e.flags |= 128, r = !0, Hd(o, !1), e.lanes = 4194304) } else { if (!r) if (n = uv(s), n !== null) { if (e.flags |= 128, r = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Hd(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Cn) return Hr(e), null } else 2 * Kn() - o.renderingStartTime > kf && t !== 1073741824 && (e.flags |= 128, r = !0, Hd(o, !1), e.lanes = 4194304); o.isBackwards ? (s.sibling = e.child, e.child = s) : (t = o.last, t !== null ? t.sibling = s : e.child = s, o.last = s) } return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = Kn(), e.sibling = null, t = Pn.current, pn(Pn, r ? t & 1 | 2 : t & 1), e) : (Hr(e), null); case 22: case 23: return pM(), r = e.memoizedState !== null, n !== null && n.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Ki & 1073741824 && (Hr(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Hr(e), null; case 24: return null; case 25: return null }throw Error(Xe(156, e.tag)) } function k4(n, e) { switch (KE(e), e.tag) { case 1: return Li(e.type) && rv(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 3: return Ff(), Sn(Ii), Sn(Zr), rM(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null; case 5: return nM(e), null; case 13: if (Sn(Pn), n = e.memoizedState, n !== null && n.dehydrated !== null) { if (e.alternate === null) throw Error(Xe(340)); Df() } return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 19: return Sn(Pn), null; case 4: return Ff(), null; case 10: return ZE(e.type._context), null; case 22: case 23: return pM(), null; case 24: return null; default: return null } } var cg = !1, Kr = !1, N4 = typeof WeakSet == "function" ? WeakSet : Set, at = null; function cf(n, e) { var t = n.ref; if (t !== null) if (typeof t == "function") try { t(null) } catch (r) { zn(n, e, r) } else t.current = null } function jS(n, e, t) { try { t() } catch (r) { zn(n, e, r) } } var UT = !1; function z4(n, e) { if (TS = q0, n = EI(), XE(n)) { if ("selectionStart" in n) var t = { start: n.selectionStart, end: n.selectionEnd }; else e: { t = (t = n.ownerDocument) && t.defaultView || window; var r = t.getSelection && t.getSelection(); if (r && r.rangeCount !== 0) { t = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { t.nodeType, o.nodeType } catch { t = null; break e } var s = 0, a = -1, l = -1, c = 0, u = 0, d = n, p = null; t: for (; ;) { for (var m; d !== t || i !== 0 && d.nodeType !== 3 || (a = s + i), d !== o || r !== 0 && d.nodeType !== 3 || (l = s + r), d.nodeType === 3 && (s += d.nodeValue.length), (m = d.firstChild) !== null;)p = d, d = m; for (; ;) { if (d === n) break t; if (p === t && ++c === i && (a = s), p === o && ++u === r && (l = s), (m = d.nextSibling) !== null) break; d = p, p = d.parentNode } d = m } t = a === -1 || l === -1 ? null : { start: a, end: l } } else t = null } t = t || { start: 0, end: 0 } } else t = null; for (RS = { focusedElem: n, selectionRange: t }, q0 = !1, at = e; at !== null;)if (e = at, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null) n.return = e, at = n; else for (; at !== null;) { e = at; try { var v = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (v !== null) { var y = v.memoizedProps, _ = v.memoizedState, g = e.stateNode, x = g.getSnapshotBeforeUpdate(e.elementType === e.type ? y : Go(e.type, y), _); g.__reactInternalSnapshotBeforeUpdate = x } break; case 3: var A = e.stateNode.containerInfo; A.nodeType === 1 ? A.textContent = "" : A.nodeType === 9 && A.documentElement && A.removeChild(A.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(Xe(163)) } } catch (E) { zn(e, e.return, E) } if (n = e.sibling, n !== null) { n.return = e.return, at = n; break } at = e.return } return v = UT, UT = !1, v } function Mh(n, e, t) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & n) === n) { var o = i.destroy; i.destroy = void 0, o !== void 0 && jS(e, t, o) } i = i.next } while (i !== r) } } function Qv(n, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var t = e = e.next; do { if ((t.tag & n) === n) { var r = t.create; t.destroy = r() } t = t.next } while (t !== e) } } function XS(n) { var e = n.ref; if (e !== null) { var t = n.stateNode; switch (n.tag) { case 5: n = t; break; default: n = t }typeof e == "function" ? e(n) : e.current = n } } function xL(n) { var e = n.alternate; e !== null && (n.alternate = null, xL(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[_s], delete e[$h], delete e[IS], delete e[A4], delete e[E4])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } function SL(n) { return n.tag === 5 || n.tag === 3 || n.tag === 4 } function kT(n) { e: for (; ;) { for (; n.sibling === null;) { if (n.return === null || SL(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.flags & 2 || n.child === null || n.tag === 4) continue e; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function JS(n, e, t) { var r = n.tag; if (r === 5 || r === 6) n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = nv)); else if (r !== 4 && (n = n.child, n !== null)) for (JS(n, e, t), n = n.sibling; n !== null;)JS(n, e, t), n = n.sibling } function KS(n, e, t) { var r = n.tag; if (r === 5 || r === 6) n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n); else if (r !== 4 && (n = n.child, n !== null)) for (KS(n, e, t), n = n.sibling; n !== null;)KS(n, e, t), n = n.sibling } var Cr = null, Vo = !1; function za(n, e, t) { for (t = t.child; t !== null;)AL(n, e, t), t = t.sibling } function AL(n, e, t) { if (Ms && typeof Ms.onCommitFiberUnmount == "function") try { Ms.onCommitFiberUnmount(Vv, t) } catch { } switch (t.tag) { case 5: Kr || cf(t, e); case 6: var r = Cr, i = Vo; Cr = null, za(n, e, t), Cr = r, Vo = i, Cr !== null && (Vo ? (n = Cr, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Cr.removeChild(t.stateNode)); break; case 18: Cr !== null && (Vo ? (n = Cr, t = t.stateNode, n.nodeType === 8 ? I_(n.parentNode, t) : n.nodeType === 1 && I_(n, t), jh(n)) : I_(Cr, t.stateNode)); break; case 4: r = Cr, i = Vo, Cr = t.stateNode.containerInfo, Vo = !0, za(n, e, t), Cr = r, Vo = i; break; case 0: case 11: case 14: case 15: if (!Kr && (r = t.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && jS(t, e, s), i = i.next } while (i !== r) } za(n, e, t); break; case 1: if (!Kr && (cf(t, e), r = t.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = t.memoizedProps, r.state = t.memoizedState, r.componentWillUnmount() } catch (a) { zn(t, e, a) } za(n, e, t); break; case 21: za(n, e, t); break; case 22: t.mode & 1 ? (Kr = (r = Kr) || t.memoizedState !== null, za(n, e, t), Kr = r) : za(n, e, t); break; default: za(n, e, t) } } function NT(n) { var e = n.updateQueue; if (e !== null) { n.updateQueue = null; var t = n.stateNode; t === null && (t = n.stateNode = new N4), e.forEach(function (r) { var i = Y4.bind(null, n, r); t.has(r) || (t.add(r), r.then(i, i)) }) } } function Uo(n, e) { var t = e.deletions; if (t !== null) for (var r = 0; r < t.length; r++) { var i = t[r]; try { var o = n, s = e, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: Cr = a.stateNode, Vo = !1; break e; case 3: Cr = a.stateNode.containerInfo, Vo = !0; break e; case 4: Cr = a.stateNode.containerInfo, Vo = !0; break e }a = a.return } if (Cr === null) throw Error(Xe(160)); AL(o, s, i), Cr = null, Vo = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (c) { zn(i, e, c) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)EL(e, n), e = e.sibling } function EL(n, e) { var t = n.alternate, r = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: if (Uo(e, n), ds(n), r & 4) { try { Mh(3, n, n.return), Qv(3, n) } catch (y) { zn(n, n.return, y) } try { Mh(5, n, n.return) } catch (y) { zn(n, n.return, y) } } break; case 1: Uo(e, n), ds(n), r & 512 && t !== null && cf(t, t.return); break; case 5: if (Uo(e, n), ds(n), r & 512 && t !== null && cf(t, t.return), n.flags & 32) { var i = n.stateNode; try { Gh(i, "") } catch (y) { zn(n, n.return, y) } } if (r & 4 && (i = n.stateNode, i != null)) { var o = n.memoizedProps, s = t !== null ? t.memoizedProps : o, a = n.type, l = n.updateQueue; if (n.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && W3(i, o), yS(a, s); var c = yS(a, o); for (s = 0; s < l.length; s += 2) { var u = l[s], d = l[s + 1]; u === "style" ? Y3(i, d) : u === "dangerouslySetInnerHTML" ? J3(i, d) : u === "children" ? Gh(i, d) : LE(i, u, d, c) } switch (a) { case "input": hS(i, o); break; case "textarea": j3(i, o); break; case "select": var p = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var m = o.value; m != null ? yf(i, !!o.multiple, m, !1) : p !== !!o.multiple && (o.defaultValue != null ? yf(i, !!o.multiple, o.defaultValue, !0) : yf(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[$h] = o } catch (y) { zn(n, n.return, y) } } break; case 6: if (Uo(e, n), ds(n), r & 4) { if (n.stateNode === null) throw Error(Xe(162)); i = n.stateNode, o = n.memoizedProps; try { i.nodeValue = o } catch (y) { zn(n, n.return, y) } } break; case 3: if (Uo(e, n), ds(n), r & 4 && t !== null && t.memoizedState.isDehydrated) try { jh(e.containerInfo) } catch (y) { zn(n, n.return, y) } break; case 4: Uo(e, n), ds(n); break; case 13: Uo(e, n), ds(n), i = n.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (dM = Kn())), r & 4 && NT(n); break; case 22: if (u = t !== null && t.memoizedState !== null, n.mode & 1 ? (Kr = (c = Kr) || u, Uo(e, n), Kr = c) : Uo(e, n), ds(n), r & 8192) { if (c = n.memoizedState !== null, (n.stateNode.isHidden = c) && !u && n.mode & 1) for (at = n, u = n.child; u !== null;) { for (d = at = u; at !== null;) { switch (p = at, m = p.child, p.tag) { case 0: case 11: case 14: case 15: Mh(4, p, p.return); break; case 1: cf(p, p.return); var v = p.stateNode; if (typeof v.componentWillUnmount == "function") { r = p, t = p.return; try { e = r, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount() } catch (y) { zn(r, t, y) } } break; case 5: cf(p, p.return); break; case 22: if (p.memoizedState !== null) { GT(d); continue } }m !== null ? (m.return = p, at = m) : GT(d) } u = u.sibling } e: for (u = null, d = n; ;) { if (d.tag === 5) { if (u === null) { u = d; try { i = d.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = K3("display", s)) } catch (y) { zn(n, n.return, y) } } } else if (d.tag === 6) { if (u === null) try { d.stateNode.nodeValue = c ? "" : d.memoizedProps } catch (y) { zn(n, n.return, y) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === n) break e; for (; d.sibling === null;) { if (d.return === null || d.return === n) break e; u === d && (u = null), d = d.return } u === d && (u = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Uo(e, n), ds(n), r & 4 && NT(n); break; case 21: break; default: Uo(e, n), ds(n) } } function ds(n) { var e = n.flags; if (e & 2) { try { e: { for (var t = n.return; t !== null;) { if (SL(t)) { var r = t; break e } t = t.return } throw Error(Xe(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Gh(i, ""), r.flags &= -33); var o = kT(n); KS(n, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = kT(n); JS(n, a, s); break; default: throw Error(Xe(161)) } } catch (l) { zn(n, n.return, l) } n.flags &= -3 } e & 4096 && (n.flags &= -4097) } function G4(n, e, t) { at = n, ML(n) } function ML(n, e, t) { for (var r = (n.mode & 1) !== 0; at !== null;) { var i = at, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || cg; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || Kr; a = cg; var c = Kr; if (cg = s, (Kr = l) && !c) for (at = i; at !== null;)s = at, l = s.child, s.tag === 22 && s.memoizedState !== null ? HT(i) : l !== null ? (l.return = s, at = l) : HT(i); for (; o !== null;)at = o, ML(o), o = o.sibling; at = i, cg = a, Kr = c } zT(n) } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, at = o) : zT(n) } } function zT(n) { for (; at !== null;) { var e = at; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Kr || Qv(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !Kr) if (t === null) r.componentDidMount(); else { var i = e.elementType === e.type ? t.memoizedProps : Go(e.type, t.memoizedProps); r.componentDidUpdate(i, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = e.updateQueue; o !== null && ET(e, o, r); break; case 3: var s = e.updateQueue; if (s !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5: t = e.child.stateNode; break; case 1: t = e.child.stateNode }ET(e, s, t) } break; case 5: var a = e.stateNode; if (t === null && e.flags & 4) { t = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && t.focus(); break; case "img": l.src && (t.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var c = e.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var d = u.dehydrated; d !== null && jh(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(Xe(163)) }Kr || e.flags & 512 && XS(e) } catch (p) { zn(e, e.return, p) } } if (e === n) { at = null; break } if (t = e.sibling, t !== null) { t.return = e.return, at = t; break } at = e.return } } function GT(n) { for (; at !== null;) { var e = at; if (e === n) { at = null; break } var t = e.sibling; if (t !== null) { t.return = e.return, at = t; break } at = e.return } } function HT(n) { for (; at !== null;) { var e = at; try { switch (e.tag) { case 0: case 11: case 15: var t = e.return; try { Qv(4, e) } catch (l) { zn(e, t, l) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (l) { zn(e, i, l) } } var o = e.return; try { XS(e) } catch (l) { zn(e, o, l) } break; case 5: var s = e.return; try { XS(e) } catch (l) { zn(e, s, l) } } } catch (l) { zn(e, e.return, l) } if (e === n) { at = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, at = a; break } at = e.return } } var H4 = Math.ceil, hv = wa.ReactCurrentDispatcher, uM = wa.ReactCurrentOwner, Co = wa.ReactCurrentBatchConfig, Vt = 0, xr = null, nr = null, Pr = 0, Ki = 0, uf = Cl(0), cr = 0, np = null, Nc = 0, Zv = 0, fM = 0, wh = null, bi = null, dM = 0, kf = 1 / 0, ra = null, pv = !1, YS = null, ul = null, ug = !1, nl = null, mv = 0, bh = 0, $S = null, T0 = -1, R0 = 0; function pi() { return Vt & 6 ? Kn() : T0 !== -1 ? T0 : T0 = Kn() } function fl(n) { return n.mode & 1 ? Vt & 2 && Pr !== 0 ? Pr & -Pr : w4.transition !== null ? (R0 === 0 && (R0 = aI()), R0) : (n = on, n !== 0 || (n = window.event, n = n === void 0 ? 16 : pI(n.type)), n) : 1 } function Yo(n, e, t, r) { if (50 < bh) throw bh = 0, $S = null, Error(Xe(185)); Bp(n, t, r), (!(Vt & 2) || n !== xr) && (n === xr && (!(Vt & 2) && (Zv |= t), cr === 4 && qa(n, Pr)), Di(n, r), t === 1 && Vt === 0 && !(e.mode & 1) && (kf = Kn() + 500, Kv && Tl())) } function Di(n, e) { var t = n.callbackNode; wN(n, e); var r = Z0(n, n === xr ? Pr : 0); if (r === 0) t !== null && QC(t), n.callbackNode = null, n.callbackPriority = 0; else if (e = r & -r, n.callbackPriority !== e) { if (t != null && QC(t), e === 1) n.tag === 0 ? M4(VT.bind(null, n)) : LI(VT.bind(null, n)), x4(function () { !(Vt & 6) && Tl() }), t = null; else { switch (lI(r)) { case 1: t = kE; break; case 4: t = oI; break; case 16: t = Q0; break; case 536870912: t = sI; break; default: t = Q0 }t = IL(t, wL.bind(null, n)) } n.callbackPriority = e, n.callbackNode = t } } function wL(n, e) { if (T0 = -1, R0 = 0, Vt & 6) throw Error(Xe(327)); var t = n.callbackNode; if (Ef() && n.callbackNode !== t) return null; var r = Z0(n, n === xr ? Pr : 0); if (r === 0) return null; if (r & 30 || r & n.expiredLanes || e) e = gv(n, r); else { e = r; var i = Vt; Vt |= 2; var o = CL(); (xr !== n || Pr !== e) && (ra = null, kf = Kn() + 500, Cc(n, e)); do try { j4(); break } catch (a) { bL(n, a) } while (1); QE(), hv.current = o, Vt = i, nr !== null ? e = 0 : (xr = null, Pr = 0, e = cr) } if (e !== 0) { if (e === 2 && (i = ES(n), i !== 0 && (r = i, e = QS(n, i))), e === 1) throw t = np, Cc(n, 0), qa(n, r), Di(n, Kn()), t; if (e === 6) qa(n, r); else { if (i = n.current.alternate, !(r & 30) && !V4(i) && (e = gv(n, r), e === 2 && (o = ES(n), o !== 0 && (r = o, e = QS(n, o))), e === 1)) throw t = np, Cc(n, 0), qa(n, r), Di(n, Kn()), t; switch (n.finishedWork = i, n.finishedLanes = r, e) { case 0: case 1: throw Error(Xe(345)); case 2: lc(n, bi, ra); break; case 3: if (qa(n, r), (r & 130023424) === r && (e = dM + 500 - Kn(), 10 < e)) { if (Z0(n, 0) !== 0) break; if (i = n.suspendedLanes, (i & r) !== r) { pi(), n.pingedLanes |= n.suspendedLanes & i; break } n.timeoutHandle = BS(lc.bind(null, n, bi, ra), e); break } lc(n, bi, ra); break; case 4: if (qa(n, r), (r & 4194240) === r) break; for (e = n.eventTimes, i = -1; 0 < r;) { var s = 31 - Ko(r); o = 1 << s, s = e[s], s > i && (i = s), r &= ~o } if (r = i, r = Kn() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * H4(r / 1960)) - r, 10 < r) { n.timeoutHandle = BS(lc.bind(null, n, bi, ra), r); break } lc(n, bi, ra); break; case 5: lc(n, bi, ra); break; default: throw Error(Xe(329)) } } } return Di(n, Kn()), n.callbackNode === t ? wL.bind(null, n) : null } function QS(n, e) { var t = wh; return n.current.memoizedState.isDehydrated && (Cc(n, e).flags |= 256), n = gv(n, e), n !== 2 && (e = bi, bi = t, e !== null && ZS(e)), n } function ZS(n) { bi === null ? bi = n : bi.push.apply(bi, n) } function V4(n) { for (var e = n; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (var r = 0; r < t.length; r++) { var i = t[r], o = i.getSnapshot; i = i.value; try { if (!Zo(o(), i)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t; else { if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function qa(n, e) { for (e &= ~fM, e &= ~Zv, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e;) { var t = 31 - Ko(e), r = 1 << t; n[t] = -1, e &= ~r } } function VT(n) { if (Vt & 6) throw Error(Xe(327)); Ef(); var e = Z0(n, 0); if (!(e & 1)) return Di(n, Kn()), null; var t = gv(n, e); if (n.tag !== 0 && t === 2) { var r = ES(n); r !== 0 && (e = r, t = QS(n, r)) } if (t === 1) throw t = np, Cc(n, 0), qa(n, e), Di(n, Kn()), t; if (t === 6) throw Error(Xe(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = e, lc(n, bi, ra), Di(n, Kn()), null } function hM(n, e) { var t = Vt; Vt |= 1; try { return n(e) } finally { Vt = t, Vt === 0 && (kf = Kn() + 500, Kv && Tl()) } } function zc(n) { nl !== null && nl.tag === 0 && !(Vt & 6) && Ef(); var e = Vt; Vt |= 1; var t = Co.transition, r = on; try { if (Co.transition = null, on = 1, n) return n() } finally { on = r, Co.transition = t, Vt = e, !(Vt & 6) && Tl() } } function pM() { Ki = uf.current, Sn(uf) } function Cc(n, e) { n.finishedWork = null, n.finishedLanes = 0; var t = n.timeoutHandle; if (t !== -1 && (n.timeoutHandle = -1, _4(t)), nr !== null) for (t = nr.return; t !== null;) { var r = t; switch (KE(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && rv(); break; case 3: Ff(), Sn(Ii), Sn(Zr), rM(); break; case 5: nM(r); break; case 4: Ff(); break; case 13: Sn(Pn); break; case 19: Sn(Pn); break; case 10: ZE(r.type._context); break; case 22: case 23: pM() }t = t.return } if (xr = n, nr = n = dl(n.current, null), Pr = Ki = e, cr = 0, np = null, fM = Zv = Nc = 0, bi = wh = null, yc !== null) { for (e = 0; e < yc.length; e++)if (t = yc[e], r = t.interleaved, r !== null) { t.interleaved = null; var i = r.next, o = t.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } t.pending = r } yc = null } return n } function bL(n, e) { do { var t = nr; try { if (QE(), w0.current = dv, fv) { for (var r = Ln.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } fv = !1 } if (kc = 0, yr = sr = Ln = null, Eh = !1, qh = 0, uM.current = null, t === null || t.return === null) { cr = 1, np = e, nr = null; break } e: { var o = n, s = t.return, a = t, l = e; if (e = Pr, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, d = u.tag; if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) { var p = u.alternate; p ? (u.updateQueue = p.updateQueue, u.memoizedState = p.memoizedState, u.lanes = p.lanes) : (u.updateQueue = null, u.memoizedState = null) } var m = PT(s); if (m !== null) { m.flags &= -257, BT(m, s, a, o, e), m.mode & 1 && RT(o, c, e), e = m, l = c; var v = e.updateQueue; if (v === null) { var y = new Set; y.add(l), e.updateQueue = y } else v.add(l); break e } else { if (!(e & 1)) { RT(o, c, e), mM(); break e } l = Error(Xe(426)) } } else if (Cn && a.mode & 1) { var _ = PT(s); if (_ !== null) { !(_.flags & 65536) && (_.flags |= 256), BT(_, s, a, o, e), YE(Uf(l, a)); break e } } o = l = Uf(l, a), cr !== 4 && (cr = 2), wh === null ? wh = [o] : wh.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, e &= -e, o.lanes |= e; var g = cL(o, l, e); AT(o, g); break e; case 1: a = l; var x = o.type, A = o.stateNode; if (!(o.flags & 128) && (typeof x.getDerivedStateFromError == "function" || A !== null && typeof A.componentDidCatch == "function" && (ul === null || !ul.has(A)))) { o.flags |= 65536, e &= -e, o.lanes |= e; var E = uL(o, a, e); AT(o, E); break e } }o = o.return } while (o !== null) } RL(t) } catch (w) { e = w, nr === t && t !== null && (nr = t = t.return); continue } break } while (1) } function CL() { var n = hv.current; return hv.current = dv, n === null ? dv : n } function mM() { (cr === 0 || cr === 3 || cr === 2) && (cr = 4), xr === null || !(Nc & 268435455) && !(Zv & 268435455) || qa(xr, Pr) } function gv(n, e) { var t = Vt; Vt |= 2; var r = CL(); (xr !== n || Pr !== e) && (ra = null, Cc(n, e)); do try { W4(); break } catch (i) { bL(n, i) } while (1); if (QE(), Vt = t, hv.current = r, nr !== null) throw Error(Xe(261)); return xr = null, Pr = 0, cr } function W4() { for (; nr !== null;)TL(nr) } function j4() { for (; nr !== null && !gN();)TL(nr) } function TL(n) { var e = BL(n.alternate, n, Ki); n.memoizedProps = n.pendingProps, e === null ? RL(n) : nr = e, uM.current = null } function RL(n) { var e = n; do { var t = e.alternate; if (n = e.return, e.flags & 32768) { if (t = k4(t, e), t !== null) { t.flags &= 32767, nr = t; return } if (n !== null) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { cr = 6, nr = null; return } } else if (t = U4(t, e, Ki), t !== null) { nr = t; return } if (e = e.sibling, e !== null) { nr = e; return } nr = e = n } while (e !== null); cr === 0 && (cr = 5) } function lc(n, e, t) { var r = on, i = Co.transition; try { Co.transition = null, on = 1, X4(n, e, t, r) } finally { Co.transition = i, on = r } return null } function X4(n, e, t, r) { do Ef(); while (nl !== null); if (Vt & 6) throw Error(Xe(327)); t = n.finishedWork; var i = n.finishedLanes; if (t === null) return null; if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(Xe(177)); n.callbackNode = null, n.callbackPriority = 0; var o = t.lanes | t.childLanes; if (bN(n, o), n === xr && (nr = xr = null, Pr = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || ug || (ug = !0, IL(Q0, function () { return Ef(), null })), o = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || o) { o = Co.transition, Co.transition = null; var s = on; on = 1; var a = Vt; Vt |= 4, uM.current = null, z4(n, t), EL(t, n), d4(RS), q0 = !!TS, RS = TS = null, n.current = t, G4(t), vN(), Vt = a, on = s, Co.transition = o } else n.current = t; if (ug && (ug = !1, nl = n, mv = i), o = n.pendingLanes, o === 0 && (ul = null), xN(t.stateNode), Di(n, Kn()), e !== null) for (r = n.onRecoverableError, t = 0; t < e.length; t++)i = e[t], r(i.value, { componentStack: i.stack, digest: i.digest }); if (pv) throw pv = !1, n = YS, YS = null, n; return mv & 1 && n.tag !== 0 && Ef(), o = n.pendingLanes, o & 1 ? n === $S ? bh++ : (bh = 0, $S = n) : bh = 0, Tl(), null } function Ef() { if (nl !== null) { var n = lI(mv), e = Co.transition, t = on; try { if (Co.transition = null, on = 16 > n ? 16 : n, nl === null) var r = !1; else { if (n = nl, nl = null, mv = 0, Vt & 6) throw Error(Xe(331)); var i = Vt; for (Vt |= 4, at = n.current; at !== null;) { var o = at, s = o.child; if (at.flags & 16) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (at = c; at !== null;) { var u = at; switch (u.tag) { case 0: case 11: case 15: Mh(8, u, o) }var d = u.child; if (d !== null) d.return = u, at = d; else for (; at !== null;) { u = at; var p = u.sibling, m = u.return; if (xL(u), u === c) { at = null; break } if (p !== null) { p.return = m, at = p; break } at = m } } } var v = o.alternate; if (v !== null) { var y = v.child; if (y !== null) { v.child = null; do { var _ = y.sibling; y.sibling = null, y = _ } while (y !== null) } } at = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, at = s; else e: for (; at !== null;) { if (o = at, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: Mh(9, o, o.return) }var g = o.sibling; if (g !== null) { g.return = o.return, at = g; break e } at = o.return } } var x = n.current; for (at = x; at !== null;) { s = at; var A = s.child; if (s.subtreeFlags & 2064 && A !== null) A.return = s, at = A; else e: for (s = x; at !== null;) { if (a = at, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Qv(9, a) } } catch (w) { zn(a, a.return, w) } if (a === s) { at = null; break e } var E = a.sibling; if (E !== null) { E.return = a.return, at = E; break e } at = a.return } } if (Vt = i, Tl(), Ms && typeof Ms.onPostCommitFiberRoot == "function") try { Ms.onPostCommitFiberRoot(Vv, n) } catch { } r = !0 } return r } finally { on = t, Co.transition = e } } return !1 } function WT(n, e, t) { e = Uf(t, e), e = cL(n, e, 1), n = cl(n, e, 1), e = pi(), n !== null && (Bp(n, 1, e), Di(n, e)) } function zn(n, e, t) { if (n.tag === 3) WT(n, n, t); else for (; e !== null;) { if (e.tag === 3) { WT(e, n, t); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (ul === null || !ul.has(r))) { n = Uf(t, n), n = uL(e, n, 1), e = cl(e, n, 1), n = pi(), e !== null && (Bp(e, 1, n), Di(e, n)); break } } e = e.return } } function J4(n, e, t) { var r = n.pingCache; r !== null && r.delete(e), e = pi(), n.pingedLanes |= n.suspendedLanes & t, xr === n && (Pr & t) === t && (cr === 4 || cr === 3 && (Pr & 130023424) === Pr && 500 > Kn() - dM ? Cc(n, 0) : fM |= t), Di(n, e) } function PL(n, e) { e === 0 && (n.mode & 1 ? (e = eg, eg <<= 1, !(eg & 130023424) && (eg = 4194304)) : e = 1); var t = pi(); n = ga(n, e), n !== null && (Bp(n, e, t), Di(n, t)) } function K4(n) { var e = n.memoizedState, t = 0; e !== null && (t = e.retryLane), PL(n, t) } function Y4(n, e) { var t = 0; switch (n.tag) { case 13: var r = n.stateNode, i = n.memoizedState; i !== null && (t = i.retryLane); break; case 19: r = n.stateNode; break; default: throw Error(Xe(314)) }r !== null && r.delete(e), PL(n, t) } var BL; BL = function (n, e, t) { if (n !== null) if (n.memoizedProps !== e.pendingProps || Ii.current) Pi = !0; else { if (!(n.lanes & t) && !(e.flags & 128)) return Pi = !1, F4(n, e, t); Pi = !!(n.flags & 131072) } else Pi = !1, Cn && e.flags & 1048576 && DI(e, sv, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; C0(n, e), n = e.pendingProps; var i = Lf(e, Zr.current); Af(e, t), i = oM(null, e, r, n, i, t); var o = sM(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Li(r) ? (o = !0, iv(e)) : o = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, eM(e), i.updater = Yv, e.stateNode = i, i._reactInternals = e, kS(e, r, n, t), e = GS(null, e, r, !0, o, t)) : (e.tag = 0, Cn && o && JE(e), di(null, e, i, t), e = e.child), e; case 16: r = e.elementType; e: { switch (C0(n, e), n = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = Q4(r), n = Go(r, n), i) { case 0: e = zS(null, e, r, n, t); break e; case 1: e = DT(null, e, r, n, t); break e; case 11: e = IT(null, e, r, n, t); break e; case 14: e = LT(null, e, r, Go(r.type, n), t); break e }throw Error(Xe(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Go(r, i), zS(n, e, r, i, t); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Go(r, i), DT(n, e, r, i, t); case 3: e: { if (pL(e), n === null) throw Error(Xe(387)); r = e.pendingProps, o = e.memoizedState, i = o.element, kI(n, e), cv(e, r, null, t); var s = e.memoizedState; if (r = s.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) { i = Uf(Error(Xe(423)), e), e = OT(n, e, r, t, i); break e } else if (r !== i) { i = Uf(Error(Xe(424)), e), e = OT(n, e, r, t, i); break e } else for (Zi = ll(e.stateNode.containerInfo.firstChild), eo = e, Cn = !0, Wo = null, t = HI(e, null, r, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (Df(), r === i) { e = va(n, e, t); break e } di(n, e, r, t) } e = e.child } return e; case 5: return VI(e), n === null && OS(e), r = e.type, i = e.pendingProps, o = n !== null ? n.memoizedProps : null, s = i.children, PS(r, i) ? s = null : o !== null && PS(r, o) && (e.flags |= 32), hL(n, e), di(n, e, s, t), e.child; case 6: return n === null && OS(e), null; case 13: return mL(n, e, t); case 4: return tM(e, e.stateNode.containerInfo), r = e.pendingProps, n === null ? e.child = Of(e, null, r, t) : di(n, e, r, t), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Go(r, i), IT(n, e, r, i, t); case 7: return di(n, e, e.pendingProps, t), e.child; case 8: return di(n, e, e.pendingProps.children, t), e.child; case 12: return di(n, e, e.pendingProps.children, t), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, o = e.memoizedProps, s = i.value, pn(av, r._currentValue), r._currentValue = s, o !== null) if (Zo(o.value, s)) { if (o.children === i.children && !Ii.current) { e = va(n, e, t); break e } } else for (o = e.child, o !== null && (o.return = e); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = ha(-1, t & -t), l.tag = 2; var c = o.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } o.lanes |= t, l = o.alternate, l !== null && (l.lanes |= t), FS(o.return, t, e), a.lanes |= t; break } l = l.next } } else if (o.tag === 10) s = o.type === e.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(Xe(341)); s.lanes |= t, a = s.alternate, a !== null && (a.lanes |= t), FS(s, t, e), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === e) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } di(n, e, i.children, t), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, Af(e, t), i = Ro(i), r = r(i), e.flags |= 1, di(n, e, r, t), e.child; case 14: return r = e.type, i = Go(r, e.pendingProps), i = Go(r.type, i), LT(n, e, r, i, t); case 15: return fL(n, e, e.type, e.pendingProps, t); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Go(r, i), C0(n, e), e.tag = 1, Li(r) ? (n = !0, iv(e)) : n = !1, Af(e, t), zI(e, r, i), kS(e, r, i, t), GS(null, e, r, !0, n, t); case 19: return gL(n, e, t); case 22: return dL(n, e, t) }throw Error(Xe(156, e.tag)) }; function IL(n, e) { return iI(n, e) } function $4(n, e, t, r) { this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function bo(n, e, t, r) { return new $4(n, e, t, r) } function gM(n) { return n = n.prototype, !(!n || !n.isReactComponent) } function Q4(n) { if (typeof n == "function") return gM(n) ? 1 : 0; if (n != null) { if (n = n.$$typeof, n === OE) return 11; if (n === FE) return 14 } return 2 } function dl(n, e) { var t = n.alternate; return t === null ? (t = bo(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t } function P0(n, e, t, r, i, o) { var s = 2; if (r = n, typeof n == "function") gM(n) && (s = 1); else if (typeof n == "string") s = 5; else e: switch (n) { case qu: return Tc(t.children, i, o, e); case DE: s = 8, i |= 8; break; case lS: return n = bo(12, t, e, i | 2), n.elementType = lS, n.lanes = o, n; case cS: return n = bo(13, t, e, i), n.elementType = cS, n.lanes = o, n; case uS: return n = bo(19, t, e, i), n.elementType = uS, n.lanes = o, n; case G3: return qv(t, i, o, e); default: if (typeof n == "object" && n !== null) switch (n.$$typeof) { case N3: s = 10; break e; case z3: s = 9; break e; case OE: s = 11; break e; case FE: s = 14; break e; case Ya: s = 16, r = null; break e }throw Error(Xe(130, n == null ? n : typeof n, "")) }return e = bo(s, t, e, i), e.elementType = n, e.type = r, e.lanes = o, e } function Tc(n, e, t, r) { return n = bo(7, n, r, e), n.lanes = t, n } function qv(n, e, t, r) { return n = bo(22, n, r, e), n.elementType = G3, n.lanes = t, n.stateNode = { isHidden: !1 }, n } function z_(n, e, t) { return n = bo(6, n, null, e), n.lanes = t, n } function G_(n, e, t) { return e = bo(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e } function Z4(n, e, t, r, i) { this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = S_(0), this.expirationTimes = S_(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = S_(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function vM(n, e, t, r, i, o, s, a, l) { return n = new Z4(n, e, t, a, l), e === 1 ? (e = 1, o === !0 && (e |= 8)) : e = 0, o = bo(3, null, null, e), n.current = o, o.stateNode = n, o.memoizedState = { element: r, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, eM(o), n } function q4(n, e, t) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Zu, key: r == null ? null : "" + r, children: n, containerInfo: e, implementation: t } } function LL(n) { if (!n) return xl; n = n._reactInternals; e: { if ($c(n) !== n || n.tag !== 1) throw Error(Xe(170)); var e = n; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (Li(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(Xe(171)) } if (n.tag === 1) { var t = n.type; if (Li(t)) return II(n, t, e) } return e } function DL(n, e, t, r, i, o, s, a, l) { return n = vM(t, r, !0, n, i, o, s, a, l), n.context = LL(null), t = n.current, r = pi(), i = fl(t), o = ha(r, i), o.callback = e ?? null, cl(t, o, i), n.current.lanes = i, Bp(n, i, r), Di(n, r), n } function ey(n, e, t, r) { var i = e.current, o = pi(), s = fl(i); return t = LL(t), e.context === null ? e.context = t : e.pendingContext = t, e = ha(o, s), e.payload = { element: n }, r = r === void 0 ? null : r, r !== null && (e.callback = r), n = cl(i, e, s), n !== null && (Yo(n, i, s, o), M0(n, i, s)), s } function vv(n) { if (n = n.current, !n.child) return null; switch (n.child.tag) { case 5: return n.child.stateNode; default: return n.child.stateNode } } function jT(n, e) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { var t = n.retryLane; n.retryLane = t !== 0 && t < e ? t : e } } function yM(n, e) { jT(n, e), (n = n.alternate) && jT(n, e) } function e5() { return null } var OL = typeof reportError == "function" ? reportError : function (n) { console.error(n) }; function _M(n) { this._internalRoot = n } ty.prototype.render = _M.prototype.render = function (n) { var e = this._internalRoot; if (e === null) throw Error(Xe(409)); ey(n, e, null, null) }; ty.prototype.unmount = _M.prototype.unmount = function () { var n = this._internalRoot; if (n !== null) { this._internalRoot = null; var e = n.containerInfo; zc(function () { ey(null, n, null, null) }), e[ma] = null } }; function ty(n) { this._internalRoot = n } ty.prototype.unstable_scheduleHydration = function (n) { if (n) { var e = fI(); n = { blockedOn: null, target: n, priority: e }; for (var t = 0; t < Za.length && e !== 0 && e < Za[t].priority; t++); Za.splice(t, 0, n), t === 0 && hI(n) } }; function xM(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function ny(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable ")) } function XT() { } function t5(n, e, t, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var c = vv(s); o.call(c) } } var s = DL(e, r, n, 0, null, !1, !1, "", XT); return n._reactRootContainer = s, n[ma] = s.current, Kh(n.nodeType === 8 ? n.parentNode : n), zc(), s } for (; i = n.lastChild;)n.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var c = vv(l); a.call(c) } } var l = vM(n, 0, !1, null, null, !1, !1, "", XT); return n._reactRootContainer = l, n[ma] = l.current, Kh(n.nodeType === 8 ? n.parentNode : n), zc(function () { ey(e, l, t, r) }), l } function ry(n, e, t, r, i) { var o = t._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = vv(s); a.call(l) } } ey(e, s, n, i) } else s = t5(t, e, n, i, r); return vv(s) } cI = function (n) { switch (n.tag) { case 3: var e = n.stateNode; if (e.current.memoizedState.isDehydrated) { var t = fh(e.pendingLanes); t !== 0 && (NE(e, t | 1), Di(e, Kn()), !(Vt & 6) && (kf = Kn() + 500, Tl())) } break; case 13: zc(function () { var r = ga(n, 1); if (r !== null) { var i = pi(); Yo(r, n, 1, i) } }), yM(n, 1) } }; zE = function (n) { if (n.tag === 13) { var e = ga(n, 134217728); if (e !== null) { var t = pi(); Yo(e, n, 134217728, t) } yM(n, 134217728) } }; uI = function (n) { if (n.tag === 13) { var e = fl(n), t = ga(n, e); if (t !== null) { var r = pi(); Yo(t, n, e, r) } yM(n, e) } }; fI = function () { return on }; dI = function (n, e) { var t = on; try { return on = n, e() } finally { on = t } }; xS = function (n, e, t) { switch (e) { case "input": if (hS(n, t), e = t.name, t.type === "radio" && e != null) { for (t = n; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) { var r = t[e]; if (r !== n && r.form === n.form) { var i = Jv(r); if (!i) throw Error(Xe(90)); V3(r), hS(r, i) } } } break; case "textarea": j3(n, t); break; case "select": e = t.value, e != null && yf(n, !!t.multiple, e, !1) } }; Z3 = hM; q3 = zc; var n5 = { usingClientEntryPoint: !1, Events: [Lp, rf, Jv, $3, Q3, hM] }, Vd = { findFiberByHostInstance: vc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, r5 = { bundleType: Vd.bundleType, version: Vd.version, rendererPackageName: Vd.rendererPackageName, rendererConfig: Vd.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: wa.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return n = nI(n), n === null ? null : n.stateNode }, findFiberByHostInstance: Vd.findFiberByHostInstance || e5, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var fg = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!fg.isDisabled && fg.supportsFiber) try { Vv = fg.inject(r5), Ms = fg } catch { } } lo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = n5; lo.createPortal = function (n, e) { var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!xM(e)) throw Error(Xe(200)); return q4(n, e, null, t) }; lo.createRoot = function (n, e) { if (!xM(n)) throw Error(Xe(299)); var t = !1, r = "", i = OL; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = vM(n, 1, !1, null, null, t, !1, r, i), n[ma] = e.current, Kh(n.nodeType === 8 ? n.parentNode : n), new _M(e) }; lo.findDOMNode = function (n) { if (n == null) return null; if (n.nodeType === 1) return n; var e = n._reactInternals; if (e === void 0) throw typeof n.render == "function" ? Error(Xe(188)) : (n = Object.keys(n).join(","), Error(Xe(268, n))); return n = nI(e), n = n === null ? null : n.stateNode, n }; lo.flushSync = function (n) { return zc(n) }; lo.hydrate = function (n, e, t) { if (!ny(e)) throw Error(Xe(200)); return ry(null, n, e, !0, t) }; lo.hydrateRoot = function (n, e, t) { if (!xM(n)) throw Error(Xe(405)); var r = t != null && t.hydratedSources || null, i = !1, o = "", s = OL; if (t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (o = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), e = DL(e, null, n, 1, t ?? null, i, !1, o, s), n[ma] = e.current, Kh(n), r) for (n = 0; n < r.length; n++)t = r[n], i = t._getVersion, i = i(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, i] : e.mutableSourceEagerHydrationData.push(t, i); return new ty(e) }; lo.render = function (n, e, t) { if (!ny(e)) throw Error(Xe(200)); return ry(null, n, e, !1, t) }; lo.unmountComponentAtNode = function (n) { if (!ny(n)) throw Error(Xe(40)); return n._reactRootContainer ? (zc(function () { ry(null, null, n, !1, function () { n._reactRootContainer = null, n[ma] = null }) }), !0) : !1 }; lo.unstable_batchedUpdates = hM; lo.unstable_renderSubtreeIntoContainer = function (n, e, t, r) { if (!ny(t)) throw Error(Xe(200)); if (n == null || n._reactInternals === void 0) throw Error(Xe(38)); return ry(n, e, t, !1, r) }; lo.version = "18.2.0-next-9e3b772b8-20220608"; function FL() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(FL) } catch (n) { console.error(n) } } FL(), D3.exports = lo; var iy = D3.exports; const dg = Rp(iy); var UL, JT = iy; UL = sS.createRoot = JT.createRoot, sS.hydrateRoot = JT.hydrateRoot;/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Qc = "157", cc = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, uc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, kL = 0, qS = 1, NL = 2, i5 = 3, zL = 0, oy = 1, Ch = 2, Ho = 3, qo = 0, $r = 1, Ti = 2, o5 = 2, bs = 0, Rc = 1, yv = 2, eA = 3, tA = 4, GL = 5, mc = 100, HL = 101, VL = 102, nA = 103, rA = 104, WL = 200, jL = 201, XL = 202, JL = 203, SM = 204, AM = 205, KL = 206, YL = 207, $L = 208, QL = 209, ZL = 210, qL = 0, eD = 1, tD = 2, _v = 3, nD = 4, rD = 5, iD = 6, oD = 7, Op = 0, sD = 1, aD = 2, Cs = 0, lD = 1, cD = 2, uD = 3, EM = 4, fD = 5, sy = 300, ya = 301, Sl = 302, rp = 303, ip = 304, sd = 306, Al = 1e3, Rr = 1001, Nf = 1002, Gn = 1003, op = 1004, s5 = 1004, Mf = 1005, a5 = 1005, fn = 1006, ay = 1007, l5 = 1007, Ds = 1008, c5 = 1008, $o = 1009, dD = 1010, hD = 1011, ly = 1012, MM = 1013, ua = 1014, As = 1015, Ts = 1016, wM = 1017, bM = 1018, hl = 1020, pD = 1021, Yr = 1023, mD = 1024, gD = 1025, pl = 1026, Gc = 1027, vD = 1028, CM = 1029, yD = 1030, TM = 1031, RM = 1033, B0 = 33776, I0 = 33777, L0 = 33778, D0 = 33779, iA = 35840, oA = 35841, sA = 35842, aA = 35843, _D = 36196, lA = 37492, cA = 37496, uA = 37808, fA = 37809, dA = 37810, hA = 37811, pA = 37812, mA = 37813, gA = 37814, vA = 37815, yA = 37816, _A = 37817, xA = 37818, SA = 37819, AA = 37820, EA = 37821, O0 = 36492, MA = 36494, wA = 36495, xD = 36283, bA = 36284, CA = 36285, TA = 36286, SD = 2200, AD = 2201, ED = 2202, zf = 2300, Hc = 2301, F0 = 2302, xc = 2400, Sc = 2401, sp = 2402, cy = 2500, PM = 2501, MD = 0, BM = 1, xv = 2, IM = 3e3, ml = 3001, wD = 3200, LM = 3201, Rl = 0, bD = 1, $i = "", ar = "srgb", Os = "srgb-linear", uy = "display-p3", Fp = "display-p3-linear", ap = "linear", hn = "srgb", lp = "rec709", cp = "p3", u5 = 0, U0 = 7680, f5 = 7681, d5 = 7682, h5 = 7683, p5 = 34055, m5 = 34056, g5 = 5386, v5 = 512, y5 = 513, _5 = 514, x5 = 515, S5 = 516, A5 = 517, E5 = 518, CD = 519, TD = 512, RD = 513, PD = 514, BD = 515, ID = 516, LD = 517, DD = 518, OD = 519, up = 35044, M5 = 35048, w5 = 35040, b5 = 35045, C5 = 35049, T5 = 35041, R5 = 35046, P5 = 35050, B5 = 35042, I5 = "100", RA = "300 es", Sv = 1035, Es = 2e3, fp = 2001; class Us { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const r = this._listeners; r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const r = this._listeners; return r[e] !== void 0 && r[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const i = this._listeners[e]; if (i !== void 0) { const o = i.indexOf(t); o !== -1 && i.splice(o, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const r = this._listeners[e.type]; if (r !== void 0) { e.target = this; const i = r.slice(0); for (let o = 0, s = i.length; o < s; o++)i[o].call(this, e); e.target = null } } } const Vr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let KT = 1234567; const Pc = Math.PI / 180, Gf = 180 / Math.PI; function to() { const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0; return (Vr[n & 255] + Vr[n >> 8 & 255] + Vr[n >> 16 & 255] + Vr[n >> 24 & 255] + "-" + Vr[e & 255] + Vr[e >> 8 & 255] + "-" + Vr[e >> 16 & 15 | 64] + Vr[e >> 24 & 255] + "-" + Vr[t & 63 | 128] + Vr[t >> 8 & 255] + "-" + Vr[t >> 16 & 255] + Vr[t >> 24 & 255] + Vr[r & 255] + Vr[r >> 8 & 255] + Vr[r >> 16 & 255] + Vr[r >> 24 & 255]).toLowerCase() } function Hn(n, e, t) { return Math.max(e, Math.min(t, n)) } function DM(n, e) { return (n % e + e) % e } function L5(n, e, t, r, i) { return r + (n - e) * (i - r) / (t - e) } function D5(n, e, t) { return n !== e ? (t - n) / (e - n) : 0 } function Th(n, e, t) { return (1 - t) * n + t * e } function O5(n, e, t, r) { return Th(n, e, 1 - Math.exp(-t * r)) } function F5(n, e = 1) { return e - Math.abs(DM(n, e * 2) - e) } function U5(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n)) } function k5(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10)) } function N5(n, e) { return n + Math.floor(Math.random() * (e - n + 1)) } function z5(n, e) { return n + Math.random() * (e - n) } function G5(n) { return n * (.5 - Math.random()) } function H5(n) { n !== void 0 && (KT = n); let e = KT += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function V5(n) { return n * Pc } function W5(n) { return n * Gf } function PA(n) { return (n & n - 1) === 0 && n !== 0 } function FD(n) { return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2)) } function Av(n) { return Math.pow(2, Math.floor(Math.log(n) / Math.LN2)) } function j5(n, e, t, r, i) { const o = Math.cos, s = Math.sin, a = o(t / 2), l = s(t / 2), c = o((e + r) / 2), u = s((e + r) / 2), d = o((e - r) / 2), p = s((e - r) / 2), m = o((r - e) / 2), v = s((r - e) / 2); switch (i) { case "XYX": n.set(a * u, l * d, l * p, a * c); break; case "YZY": n.set(l * p, a * u, l * d, a * c); break; case "ZXZ": n.set(l * d, l * p, a * u, a * c); break; case "XZX": n.set(a * u, l * v, l * m, a * c); break; case "YXY": n.set(l * m, a * u, l * v, a * c); break; case "ZYZ": n.set(l * v, l * m, a * u, a * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } function Ri(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint32Array: return n / 4294967295; case Uint16Array: return n / 65535; case Uint8Array: return n / 255; case Int32Array: return Math.max(n / 2147483647, -1); case Int16Array: return Math.max(n / 32767, -1); case Int8Array: return Math.max(n / 127, -1); default: throw new Error("Invalid component type.") } } function Pt(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint32Array: return Math.round(n * 4294967295); case Uint16Array: return Math.round(n * 65535); case Uint8Array: return Math.round(n * 255); case Int32Array: return Math.round(n * 2147483647); case Int16Array: return Math.round(n * 32767); case Int8Array: return Math.round(n * 127); default: throw new Error("Invalid component type.") } } const Up = { DEG2RAD: Pc, RAD2DEG: Gf, generateUUID: to, clamp: Hn, euclideanModulo: DM, mapLinear: L5, inverseLerp: D5, lerp: Th, damp: O5, pingpong: F5, smoothstep: U5, smootherstep: k5, randInt: N5, randFloat: z5, randFloatSpread: G5, seededRandom: H5, degToRad: V5, radToDeg: W5, isPowerOfTwo: PA, ceilPowerOfTwo: FD, floorPowerOfTwo: Av, setQuaternionFromProperEuler: j5, normalize: Pt, denormalize: Ri }; class Be { constructor(e = 0, t = 0) { Be.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, r = this.y, i = e.elements; return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const r = this.dot(e) / t; return Math.acos(Hn(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, r = this.y - e.y; return t * t + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const r = Math.cos(t), i = Math.sin(t), o = this.x - e.x, s = this.y - e.y; return this.x = o * r - s * i + e.x, this.y = o * i + s * r + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Rt { constructor(e, t, r, i, o, s, a, l, c) { Rt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, r, i, o, s, a, l, c) } set(e, t, r, i, o, s, a, l, c) { const u = this.elements; return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = o, u[5] = l, u[6] = r, u[7] = s, u[8] = c, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, r = e.elements; return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this } extractBasis(e, t, r) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const r = e.elements, i = t.elements, o = this.elements, s = r[0], a = r[3], l = r[6], c = r[1], u = r[4], d = r[7], p = r[2], m = r[5], v = r[8], y = i[0], _ = i[3], g = i[6], x = i[1], A = i[4], E = i[7], w = i[2], b = i[5], T = i[8]; return o[0] = s * y + a * x + l * w, o[3] = s * _ + a * A + l * b, o[6] = s * g + a * E + l * T, o[1] = c * y + u * x + d * w, o[4] = c * _ + u * A + d * b, o[7] = c * g + u * E + d * T, o[2] = p * y + m * x + v * w, o[5] = p * _ + m * A + v * b, o[8] = p * g + m * E + v * T, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8]; return t * s * u - t * a * c - r * o * u + r * a * l + i * o * c - i * s * l } invert() { const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8], d = u * s - a * c, p = a * l - u * o, m = c * o - s * l, v = t * d + r * p + i * m; if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const y = 1 / v; return e[0] = d * y, e[1] = (i * c - u * r) * y, e[2] = (a * r - i * s) * y, e[3] = p * y, e[4] = (u * t - i * l) * y, e[5] = (i * o - a * t) * y, e[6] = m * y, e[7] = (r * l - c * t) * y, e[8] = (s * t - r * o) * y, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, r, i, o, s, a) { const l = Math.cos(o), c = Math.sin(o); return this.set(r * l, r * c, -r * (l * s + c * a) + s + e, -i * c, i * l, -i * (-c * s + l * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(H_.makeScale(e, t)), this } rotate(e) { return this.premultiply(H_.makeRotation(-e)), this } translate(e, t) { return this.premultiply(H_.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, r = e.elements; for (let i = 0; i < 9; i++)if (t[i] !== r[i]) return !1; return !0 } fromArray(e, t = 0) { for (let r = 0; r < 9; r++)this.elements[r] = e[r + t]; return this } toArray(e = [], t = 0) { const r = this.elements; return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const H_ = new Rt; function UD(n) { for (let e = n.length - 1; e >= 0; --e)if (n[e] >= 65535) return !0; return !1 } const X5 = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function ff(n, e) { return new X5[n](e) } function dp(n) { return document.createElementNS("http://www.w3.org/1999/xhtml", n) } function kD() { const n = dp("canvas"); return n.style.display = "block", n } const YT = {}; function Rh(n) { n in YT || (YT[n] = !0, console.warn(n)) } const $T = new Rt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199), QT = new Rt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735), hg = { [Os]: { transfer: ap, primaries: lp, toReference: n => n, fromReference: n => n }, [ar]: { transfer: hn, primaries: lp, toReference: n => n.convertSRGBToLinear(), fromReference: n => n.convertLinearToSRGB() }, [Fp]: { transfer: ap, primaries: cp, toReference: n => n.applyMatrix3(QT), fromReference: n => n.applyMatrix3($T) }, [uy]: { transfer: hn, primaries: cp, toReference: n => n.convertSRGBToLinear().applyMatrix3(QT), fromReference: n => n.applyMatrix3($T).convertLinearToSRGB() } }, J5 = new Set([Os, Fp]), nn = { enabled: !0, _workingColorSpace: Os, get legacyMode() { return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled }, set legacyMode(n) { console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n }, get workingColorSpace() { return this._workingColorSpace }, set workingColorSpace(n) { if (!J5.has(n)) throw new Error(`Unsupported working color space, "${n}".`); this._workingColorSpace = n }, convert: function (n, e, t) { if (this.enabled === !1 || e === t || !e || !t) return n; const r = hg[e].toReference, i = hg[t].fromReference; return i(r(n)) }, fromWorkingColorSpace: function (n, e) { return this.convert(n, this._workingColorSpace, e) }, toWorkingColorSpace: function (n, e) { return this.convert(n, e, this._workingColorSpace) }, getPrimaries: function (n) { return hg[n].primaries }, getTransfer: function (n) { return n === $i ? ap : hg[n].transfer } }; function wf(n) { return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4) } function V_(n) { return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055 } let _u; class OM { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { _u === void 0 && (_u = dp("canvas")), _u.width = e.width, _u.height = e.height; const r = _u.getContext("2d"); e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = _u } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = dp("canvas"); t.width = e.width, t.height = e.height; const r = t.getContext("2d"); r.drawImage(e, 0, 0, e.width, e.height); const i = r.getImageData(0, 0, e.width, e.height), o = i.data; for (let s = 0; s < o.length; s++)o[s] = wf(o[s] / 255) * 255; return r.putImageData(i, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let r = 0; r < t.length; r++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(wf(t[r] / 255) * 255) : t[r] = wf(t[r]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let K5 = 0; class Ac { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: K5++ }), this.uuid = to(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const r = { uuid: this.uuid, url: "" }, i = this.data; if (i !== null) { let o; if (Array.isArray(i)) { o = []; for (let s = 0, a = i.length; s < a; s++)i[s].isDataTexture ? o.push(W_(i[s].image)) : o.push(W_(i[s])) } else o = W_(i); r.url = o } return t || (e.images[this.uuid] = r), r } } function W_(n) { return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? OM.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let Y5 = 0; class An extends Us { constructor(e = An.DEFAULT_IMAGE, t = An.DEFAULT_MAPPING, r = Rr, i = Rr, o = fn, s = Ds, a = Yr, l = $o, c = An.DEFAULT_ANISOTROPY, u = $i) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Y5++ }), this.uuid = to(), this.name = "", this.source = new Ac(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = o, this.minFilter = s, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Be(0, 0), this.repeat = new Be(1, 1), this.center = new Be(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Rt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof u == "string" ? this.colorSpace = u : (Rh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = u === ml ? ar : $i), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const r = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== sy) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Al: e.x = e.x - Math.floor(e.x); break; case Rr: e.x = e.x < 0 ? 0 : 1; break; case Nf: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Al: e.y = e.y - Math.floor(e.y); break; case Rr: e.y = e.y < 0 ? 0 : 1; break; case Nf: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } get encoding() { return Rh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === ar ? ml : IM } set encoding(e) { Rh("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === ml ? ar : $i } } An.DEFAULT_IMAGE = null; An.DEFAULT_MAPPING = sy; An.DEFAULT_ANISOTROPY = 1; class Ft { constructor(e = 0, t = 0, r = 0, i = 1) { Ft.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, r, i) { return this.x = e, this.y = t, this.z = r, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, r = this.y, i = this.z, o = this.w, s = e.elements; return this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * o, this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * o, this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * o, this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * o, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, r, i, o; const l = e.elements, c = l[0], u = l[4], d = l[8], p = l[1], m = l[5], v = l[9], y = l[2], _ = l[6], g = l[10]; if (Math.abs(u - p) < .01 && Math.abs(d - y) < .01 && Math.abs(v - _) < .01) { if (Math.abs(u + p) < .1 && Math.abs(d + y) < .1 && Math.abs(v + _) < .1 && Math.abs(c + m + g - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const A = (c + 1) / 2, E = (m + 1) / 2, w = (g + 1) / 2, b = (u + p) / 4, T = (d + y) / 4, B = (v + _) / 4; return A > E && A > w ? A < .01 ? (r = 0, i = .707106781, o = .707106781) : (r = Math.sqrt(A), i = b / r, o = T / r) : E > w ? E < .01 ? (r = .707106781, i = 0, o = .707106781) : (i = Math.sqrt(E), r = b / i, o = B / i) : w < .01 ? (r = .707106781, i = .707106781, o = 0) : (o = Math.sqrt(w), r = T / o, i = B / o), this.set(r, i, o, t), this } let x = Math.sqrt((_ - v) * (_ - v) + (d - y) * (d - y) + (p - u) * (p - u)); return Math.abs(x) < .001 && (x = 1), this.x = (_ - v) / x, this.y = (d - y) / x, this.z = (p - u) / x, this.w = Math.acos((c + m + g - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class ND extends Us { constructor(e = 1, t = 1, r = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ft(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ft(0, 0, e, t); const i = { width: e, height: t, depth: 1 }; r.encoding !== void 0 && (Rh("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), r.colorSpace = r.encoding === ml ? ar : $i), r = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: fn, depthBuffer: !0, stencilBuffer: !1, depthTexture: null, samples: 0 }, r), this.texture = new An(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps, this.texture.internalFormat = r.internalFormat, this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.depthTexture = r.depthTexture, this.samples = r.samples } setSize(e, t, r = 1) { (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Ac(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Qr extends ND { constructor(e = 1, t = 1, r = {}) { super(e, t, r), this.isWebGLRenderTarget = !0 } } class fy extends An { constructor(e = null, t = 1, r = 1, i = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = Gn, this.minFilter = Gn, this.wrapR = Rr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class $5 extends Qr { constructor(e = 1, t = 1, r = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new fy(null, e, t, r), this.texture.isRenderTargetTexture = !0 } } class FM extends An { constructor(e = null, t = 1, r = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = Gn, this.minFilter = Gn, this.wrapR = Rr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class Q5 extends Qr { constructor(e = 1, t = 1, r = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new FM(null, e, t, r), this.texture.isRenderTargetTexture = !0 } } class Z5 extends Qr { constructor(e = 1, t = 1, r = 1, i = {}) { super(e, t, i), this.isWebGLMultipleRenderTargets = !0; const o = this.texture; this.texture = []; for (let s = 0; s < r; s++)this.texture[s] = o.clone(), this.texture[s].isRenderTargetTexture = !0 } setSize(e, t, r = 1) { if (this.width !== e || this.height !== t || this.depth !== r) { this.width = e, this.height = t, this.depth = r; for (let i = 0, o = this.texture.length; i < o; i++)this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = r; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, r = e.texture.length; t < r; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class Sr { constructor(e = 0, t = 0, r = 0, i = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i } static slerpFlat(e, t, r, i, o, s, a) { let l = r[i + 0], c = r[i + 1], u = r[i + 2], d = r[i + 3]; const p = o[s + 0], m = o[s + 1], v = o[s + 2], y = o[s + 3]; if (a === 0) { e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d; return } if (a === 1) { e[t + 0] = p, e[t + 1] = m, e[t + 2] = v, e[t + 3] = y; return } if (d !== y || l !== p || c !== m || u !== v) { let _ = 1 - a; const g = l * p + c * m + u * v + d * y, x = g >= 0 ? 1 : -1, A = 1 - g * g; if (A > Number.EPSILON) { const w = Math.sqrt(A), b = Math.atan2(w, g * x); _ = Math.sin(_ * b) / w, a = Math.sin(a * b) / w } const E = a * x; if (l = l * _ + p * E, c = c * _ + m * E, u = u * _ + v * E, d = d * _ + y * E, _ === 1 - a) { const w = 1 / Math.sqrt(l * l + c * c + u * u + d * d); l *= w, c *= w, u *= w, d *= w } } e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d } static multiplyQuaternionsFlat(e, t, r, i, o, s) { const a = r[i], l = r[i + 1], c = r[i + 2], u = r[i + 3], d = o[s], p = o[s + 1], m = o[s + 2], v = o[s + 3]; return e[t] = a * v + u * d + l * m - c * p, e[t + 1] = l * v + u * p + c * d - a * m, e[t + 2] = c * v + u * m + a * p - l * d, e[t + 3] = u * v - a * d - l * p - c * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, r, i) { return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const r = e._x, i = e._y, o = e._z, s = e._order, a = Math.cos, l = Math.sin, c = a(r / 2), u = a(i / 2), d = a(o / 2), p = l(r / 2), m = l(i / 2), v = l(o / 2); switch (s) { case "XYZ": this._x = p * u * d + c * m * v, this._y = c * m * d - p * u * v, this._z = c * u * v + p * m * d, this._w = c * u * d - p * m * v; break; case "YXZ": this._x = p * u * d + c * m * v, this._y = c * m * d - p * u * v, this._z = c * u * v - p * m * d, this._w = c * u * d + p * m * v; break; case "ZXY": this._x = p * u * d - c * m * v, this._y = c * m * d + p * u * v, this._z = c * u * v + p * m * d, this._w = c * u * d - p * m * v; break; case "ZYX": this._x = p * u * d - c * m * v, this._y = c * m * d + p * u * v, this._z = c * u * v - p * m * d, this._w = c * u * d + p * m * v; break; case "YZX": this._x = p * u * d + c * m * v, this._y = c * m * d + p * u * v, this._z = c * u * v - p * m * d, this._w = c * u * d - p * m * v; break; case "XZY": this._x = p * u * d - c * m * v, this._y = c * m * d - p * u * v, this._z = c * u * v + p * m * d, this._w = c * u * d + p * m * v; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const r = t / 2, i = Math.sin(r); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, r = t[0], i = t[4], o = t[8], s = t[1], a = t[5], l = t[9], c = t[2], u = t[6], d = t[10], p = r + a + d; if (p > 0) { const m = .5 / Math.sqrt(p + 1); this._w = .25 / m, this._x = (u - l) * m, this._y = (o - c) * m, this._z = (s - i) * m } else if (r > a && r > d) { const m = 2 * Math.sqrt(1 + r - a - d); this._w = (u - l) / m, this._x = .25 * m, this._y = (i + s) / m, this._z = (o + c) / m } else if (a > d) { const m = 2 * Math.sqrt(1 + a - r - d); this._w = (o - c) / m, this._x = (i + s) / m, this._y = .25 * m, this._z = (l + u) / m } else { const m = 2 * Math.sqrt(1 + d - r - a); this._w = (s - i) / m, this._x = (o + c) / m, this._y = (l + u) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let r = e.dot(t) + 1; return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(Hn(this.dot(e), -1, 1))) } rotateTowards(e, t) { const r = this.angleTo(e); if (r === 0) return this; const i = Math.min(1, t / r); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const r = e._x, i = e._y, o = e._z, s = e._w, a = t._x, l = t._y, c = t._z, u = t._w; return this._x = r * u + s * a + i * c - o * l, this._y = i * u + s * l + o * a - r * c, this._z = o * u + s * c + r * l - i * a, this._w = s * u - r * a - i * l - o * c, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const r = this._x, i = this._y, o = this._z, s = this._w; let a = s * e._w + r * e._x + i * e._y + o * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = r, this._y = i, this._z = o, this; const l = 1 - a * a; if (l <= Number.EPSILON) { const m = 1 - t; return this._w = m * s + t * this._w, this._x = m * r + t * this._x, this._y = m * i + t * this._y, this._z = m * o + t * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(l), u = Math.atan2(c, a), d = Math.sin((1 - t) * u) / c, p = Math.sin(t * u) / c; return this._w = s * d + this._w * p, this._x = r * d + this._x * p, this._y = i * d + this._y * p, this._z = o * d + this._z * p, this._onChangeCallback(), this } slerpQuaternions(e, t, r) { return this.copy(e).slerp(t, r) } random() { const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), i = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(i), r * Math.sin(o), r * Math.cos(o), t * Math.sin(i)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class X { constructor(e = 0, t = 0, r = 0) { X.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r } set(e, t, r) { return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(ZT.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(ZT.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, r = this.y, i = this.z, o = e.elements; return this.x = o[0] * t + o[3] * r + o[6] * i, this.y = o[1] * t + o[4] * r + o[7] * i, this.z = o[2] * t + o[5] * r + o[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, r = this.y, i = this.z, o = e.elements, s = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]); return this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * s, this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * s, this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * s, this } applyQuaternion(e) { const t = this.x, r = this.y, i = this.z, o = e.x, s = e.y, a = e.z, l = e.w, c = l * t + s * i - a * r, u = l * r + a * t - o * i, d = l * i + o * r - s * t, p = -o * t - s * r - a * i; return this.x = c * l + p * -o + u * -a - d * -s, this.y = u * l + p * -s + d * -o - c * -a, this.z = d * l + p * -a + c * -s - u * -o, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, r = this.y, i = this.z, o = e.elements; return this.x = o[0] * t + o[4] * r + o[8] * i, this.y = o[1] * t + o[5] * r + o[9] * i, this.z = o[2] * t + o[6] * r + o[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const r = e.x, i = e.y, o = e.z, s = t.x, a = t.y, l = t.z; return this.x = i * l - o * a, this.y = o * s - r * l, this.z = r * a - i * s, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const r = e.dot(this) / t; return this.copy(e).multiplyScalar(r) } projectOnPlane(e) { return j_.copy(this).projectOnVector(e), this.sub(j_) } reflect(e) { return this.sub(j_.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const r = this.dot(e) / t; return Math.acos(Hn(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z; return t * t + r * r + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, r) { const i = Math.sin(t) * e; return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, r) { return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = r, this.z = i, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2); return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const j_ = new X, ZT = new Sr; class yi { constructor(e = new X(1 / 0, 1 / 0, 1 / 0), t = new X(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t += 3)this.expandByPoint(Qs.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, r = e.count; t < r; t++)this.expandByPoint(Qs.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const r = Qs.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0) e.boundingBox === null && e.computeBoundingBox(), xu.copy(e.boundingBox), xu.applyMatrix4(e.matrixWorld), this.union(xu); else { const i = e.geometry; if (i !== void 0) if (t && i.attributes !== void 0 && i.attributes.position !== void 0) { const o = i.attributes.position; for (let s = 0, a = o.count; s < a; s++)Qs.fromBufferAttribute(o, s).applyMatrix4(e.matrixWorld), this.expandByPoint(Qs) } else i.boundingBox === null && i.computeBoundingBox(), xu.copy(i.boundingBox), xu.applyMatrix4(e.matrixWorld), this.union(xu) } const r = e.children; for (let i = 0, o = r.length; i < o; i++)this.expandByObject(r[i], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, Qs), Qs.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, r; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Wd), pg.subVectors(this.max, Wd), Su.subVectors(e.a, Wd), Au.subVectors(e.b, Wd), Eu.subVectors(e.c, Wd), Ga.subVectors(Au, Su), Ha.subVectors(Eu, Au), Yl.subVectors(Su, Eu); let t = [0, -Ga.z, Ga.y, 0, -Ha.z, Ha.y, 0, -Yl.z, Yl.y, Ga.z, 0, -Ga.x, Ha.z, 0, -Ha.x, Yl.z, 0, -Yl.x, -Ga.y, Ga.x, 0, -Ha.y, Ha.x, 0, -Yl.y, Yl.x, 0]; return !X_(t, Su, Au, Eu, pg) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !X_(t, Su, Au, Eu, pg)) ? !1 : (mg.crossVectors(Ga, Ha), t = [mg.x, mg.y, mg.z], X_(t, Su, Au, Eu, pg)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, Qs).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Qs).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : ($s[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), $s[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), $s[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), $s[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), $s[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), $s[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), $s[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), $s[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints($s), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const $s = [new X, new X, new X, new X, new X, new X, new X, new X], Qs = new X, xu = new yi, Su = new X, Au = new X, Eu = new X, Ga = new X, Ha = new X, Yl = new X, Wd = new X, pg = new X, mg = new X, $l = new X; function X_(n, e, t, r, i) { for (let o = 0, s = n.length - 3; o <= s; o += 3) { $l.fromArray(n, o); const a = i.x * Math.abs($l.x) + i.y * Math.abs($l.y) + i.z * Math.abs($l.z), l = e.dot($l), c = t.dot($l), u = r.dot($l); if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1 } return !0 } const q5 = new yi, jd = new X, J_ = new X; class _i { constructor(e = new X, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const r = this.center; t !== void 0 ? r.copy(t) : q5.setFromPoints(e).getCenter(r); let i = 0; for (let o = 0, s = e.length; o < s; o++)i = Math.max(i, r.distanceToSquared(e[o])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const r = this.center.distanceToSquared(e); return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; jd.subVectors(e, this.center); const t = jd.lengthSq(); if (t > this.radius * this.radius) { const r = Math.sqrt(t), i = (r - this.radius) * .5; this.center.addScaledVector(jd, i / r), this.radius += i } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (J_.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(jd.copy(e.center).add(J_)), this.expandByPoint(jd.copy(e.center).sub(J_))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const Zs = new X, K_ = new X, gg = new X, Va = new X, Y_ = new X, vg = new X, $_ = new X; class Zc { constructor(e = new X, t = new X(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Zs)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const r = t.dot(this.direction); return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Zs.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Zs.copy(this.origin).addScaledVector(this.direction, t), Zs.distanceToSquared(e)) } distanceSqToSegment(e, t, r, i) { K_.copy(e).add(t).multiplyScalar(.5), gg.copy(t).sub(e).normalize(), Va.copy(this.origin).sub(K_); const o = e.distanceTo(t) * .5, s = -this.direction.dot(gg), a = Va.dot(this.direction), l = -Va.dot(gg), c = Va.lengthSq(), u = Math.abs(1 - s * s); let d, p, m, v; if (u > 0) if (d = s * l - a, p = s * a - l, v = o * u, d >= 0) if (p >= -v) if (p <= v) { const y = 1 / u; d *= y, p *= y, m = d * (d + s * p + 2 * a) + p * (s * d + p + 2 * l) + c } else p = o, d = Math.max(0, -(s * p + a)), m = -d * d + p * (p + 2 * l) + c; else p = -o, d = Math.max(0, -(s * p + a)), m = -d * d + p * (p + 2 * l) + c; else p <= -v ? (d = Math.max(0, -(-s * o + a)), p = d > 0 ? -o : Math.min(Math.max(-o, -l), o), m = -d * d + p * (p + 2 * l) + c) : p <= v ? (d = 0, p = Math.min(Math.max(-o, -l), o), m = p * (p + 2 * l) + c) : (d = Math.max(0, -(s * o + a)), p = d > 0 ? o : Math.min(Math.max(-o, -l), o), m = -d * d + p * (p + 2 * l) + c); else p = s > 0 ? -o : o, d = Math.max(0, -(s * p + a)), m = -d * d + p * (p + 2 * l) + c; return r && r.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(K_).addScaledVector(gg, p), m } intersectSphere(e, t) { Zs.subVectors(e.center, this.origin); const r = Zs.dot(this.direction), i = Zs.dot(Zs) - r * r, o = e.radius * e.radius; if (i > o) return null; const s = Math.sqrt(o - i), a = r - s, l = r + s; return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const r = -(this.origin.dot(e.normal) + e.constant) / t; return r >= 0 ? r : null } intersectPlane(e, t) { const r = this.distanceToPlane(e); return r === null ? null : this.at(r, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let r, i, o, s, a, l; const c = 1 / this.direction.x, u = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin; return c >= 0 ? (r = (e.min.x - p.x) * c, i = (e.max.x - p.x) * c) : (r = (e.max.x - p.x) * c, i = (e.min.x - p.x) * c), u >= 0 ? (o = (e.min.y - p.y) * u, s = (e.max.y - p.y) * u) : (o = (e.max.y - p.y) * u, s = (e.min.y - p.y) * u), r > s || o > i || ((o > r || isNaN(r)) && (r = o), (s < i || isNaN(i)) && (i = s), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), r > l || a > i) || ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(r >= 0 ? r : i, t) } intersectsBox(e) { return this.intersectBox(e, Zs) !== null } intersectTriangle(e, t, r, i, o) { Y_.subVectors(t, e), vg.subVectors(r, e), $_.crossVectors(Y_, vg); let s = this.direction.dot($_), a; if (s > 0) { if (i) return null; a = 1 } else if (s < 0) a = -1, s = -s; else return null; Va.subVectors(this.origin, e); const l = a * this.direction.dot(vg.crossVectors(Va, vg)); if (l < 0) return null; const c = a * this.direction.dot(Y_.cross(Va)); if (c < 0 || l + c > s) return null; const u = -a * Va.dot($_); return u < 0 ? null : this.at(u / s, o) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class _t { constructor(e, t, r, i, o, s, a, l, c, u, d, p, m, v, y, _) { _t.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, r, i, o, s, a, l, c, u, d, p, m, v, y, _) } set(e, t, r, i, o, s, a, l, c, u, d, p, m, v, y, _) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = r, g[12] = i, g[1] = o, g[5] = s, g[9] = a, g[13] = l, g[2] = c, g[6] = u, g[10] = d, g[14] = p, g[3] = m, g[7] = v, g[11] = y, g[15] = _, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new _t().fromArray(this.elements) } copy(e) { const t = this.elements, r = e.elements; return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this } copyPosition(e) { const t = this.elements, r = e.elements; return t[12] = r[12], t[13] = r[13], t[14] = r[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, r) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this } makeBasis(e, t, r) { return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, r = e.elements, i = 1 / Mu.setFromMatrixColumn(e, 0).length(), o = 1 / Mu.setFromMatrixColumn(e, 1).length(), s = 1 / Mu.setFromMatrixColumn(e, 2).length(); return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * o, t[5] = r[5] * o, t[6] = r[6] * o, t[7] = 0, t[8] = r[8] * s, t[9] = r[9] * s, t[10] = r[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, r = e.x, i = e.y, o = e.z, s = Math.cos(r), a = Math.sin(r), l = Math.cos(i), c = Math.sin(i), u = Math.cos(o), d = Math.sin(o); if (e.order === "XYZ") { const p = s * u, m = s * d, v = a * u, y = a * d; t[0] = l * u, t[4] = -l * d, t[8] = c, t[1] = m + v * c, t[5] = p - y * c, t[9] = -a * l, t[2] = y - p * c, t[6] = v + m * c, t[10] = s * l } else if (e.order === "YXZ") { const p = l * u, m = l * d, v = c * u, y = c * d; t[0] = p + y * a, t[4] = v * a - m, t[8] = s * c, t[1] = s * d, t[5] = s * u, t[9] = -a, t[2] = m * a - v, t[6] = y + p * a, t[10] = s * l } else if (e.order === "ZXY") { const p = l * u, m = l * d, v = c * u, y = c * d; t[0] = p - y * a, t[4] = -s * d, t[8] = v + m * a, t[1] = m + v * a, t[5] = s * u, t[9] = y - p * a, t[2] = -s * c, t[6] = a, t[10] = s * l } else if (e.order === "ZYX") { const p = s * u, m = s * d, v = a * u, y = a * d; t[0] = l * u, t[4] = v * c - m, t[8] = p * c + y, t[1] = l * d, t[5] = y * c + p, t[9] = m * c - v, t[2] = -c, t[6] = a * l, t[10] = s * l } else if (e.order === "YZX") { const p = s * l, m = s * c, v = a * l, y = a * c; t[0] = l * u, t[4] = y - p * d, t[8] = v * d + m, t[1] = d, t[5] = s * u, t[9] = -a * u, t[2] = -c * u, t[6] = m * d + v, t[10] = p - y * d } else if (e.order === "XZY") { const p = s * l, m = s * c, v = a * l, y = a * c; t[0] = l * u, t[4] = -d, t[8] = c * u, t[1] = p * d + y, t[5] = s * u, t[9] = m * d - v, t[2] = v * d - m, t[6] = a * u, t[10] = y * d + p } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(ez, e, tz) } lookAt(e, t, r) { const i = this.elements; return Xi.subVectors(e, t), Xi.lengthSq() === 0 && (Xi.z = 1), Xi.normalize(), Wa.crossVectors(r, Xi), Wa.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Xi.x += 1e-4 : Xi.z += 1e-4, Xi.normalize(), Wa.crossVectors(r, Xi)), Wa.normalize(), yg.crossVectors(Xi, Wa), i[0] = Wa.x, i[4] = yg.x, i[8] = Xi.x, i[1] = Wa.y, i[5] = yg.y, i[9] = Xi.y, i[2] = Wa.z, i[6] = yg.z, i[10] = Xi.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const r = e.elements, i = t.elements, o = this.elements, s = r[0], a = r[4], l = r[8], c = r[12], u = r[1], d = r[5], p = r[9], m = r[13], v = r[2], y = r[6], _ = r[10], g = r[14], x = r[3], A = r[7], E = r[11], w = r[15], b = i[0], T = i[4], B = i[8], R = i[12], P = i[1], U = i[5], G = i[9], $ = i[13], z = i[2], j = i[6], q = i[10], se = i[14], W = i[3], V = i[7], J = i[11], O = i[15]; return o[0] = s * b + a * P + l * z + c * W, o[4] = s * T + a * U + l * j + c * V, o[8] = s * B + a * G + l * q + c * J, o[12] = s * R + a * $ + l * se + c * O, o[1] = u * b + d * P + p * z + m * W, o[5] = u * T + d * U + p * j + m * V, o[9] = u * B + d * G + p * q + m * J, o[13] = u * R + d * $ + p * se + m * O, o[2] = v * b + y * P + _ * z + g * W, o[6] = v * T + y * U + _ * j + g * V, o[10] = v * B + y * G + _ * q + g * J, o[14] = v * R + y * $ + _ * se + g * O, o[3] = x * b + A * P + E * z + w * W, o[7] = x * T + A * U + E * j + w * V, o[11] = x * B + A * G + E * q + w * J, o[15] = x * R + A * $ + E * se + w * O, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], r = e[4], i = e[8], o = e[12], s = e[1], a = e[5], l = e[9], c = e[13], u = e[2], d = e[6], p = e[10], m = e[14], v = e[3], y = e[7], _ = e[11], g = e[15]; return v * (+o * l * d - i * c * d - o * a * p + r * c * p + i * a * m - r * l * m) + y * (+t * l * m - t * c * p + o * s * p - i * s * m + i * c * u - o * l * u) + _ * (+t * c * d - t * a * m - o * s * d + r * s * m + o * a * u - r * c * u) + g * (-i * a * u - t * l * d + t * a * p + i * s * d - r * s * p + r * l * u) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, r) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this } invert() { const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8], d = e[9], p = e[10], m = e[11], v = e[12], y = e[13], _ = e[14], g = e[15], x = d * _ * c - y * p * c + y * l * m - a * _ * m - d * l * g + a * p * g, A = v * p * c - u * _ * c - v * l * m + s * _ * m + u * l * g - s * p * g, E = u * y * c - v * d * c + v * a * m - s * y * m - u * a * g + s * d * g, w = v * d * l - u * y * l - v * a * p + s * y * p + u * a * _ - s * d * _, b = t * x + r * A + i * E + o * w; if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const T = 1 / b; return e[0] = x * T, e[1] = (y * p * o - d * _ * o - y * i * m + r * _ * m + d * i * g - r * p * g) * T, e[2] = (a * _ * o - y * l * o + y * i * c - r * _ * c - a * i * g + r * l * g) * T, e[3] = (d * l * o - a * p * o - d * i * c + r * p * c + a * i * m - r * l * m) * T, e[4] = A * T, e[5] = (u * _ * o - v * p * o + v * i * m - t * _ * m - u * i * g + t * p * g) * T, e[6] = (v * l * o - s * _ * o - v * i * c + t * _ * c + s * i * g - t * l * g) * T, e[7] = (s * p * o - u * l * o + u * i * c - t * p * c - s * i * m + t * l * m) * T, e[8] = E * T, e[9] = (v * d * o - u * y * o - v * r * m + t * y * m + u * r * g - t * d * g) * T, e[10] = (s * y * o - v * a * o + v * r * c - t * y * c - s * r * g + t * a * g) * T, e[11] = (u * a * o - s * d * o - u * r * c + t * d * c + s * r * m - t * a * m) * T, e[12] = w * T, e[13] = (u * y * i - v * d * i + v * r * p - t * y * p - u * r * _ + t * d * _) * T, e[14] = (v * a * i - s * y * i - v * r * l + t * y * l + s * r * _ - t * a * _) * T, e[15] = (s * d * i - u * a * i + u * r * l - t * d * l - s * r * p + t * a * p) * T, this } scale(e) { const t = this.elements, r = e.x, i = e.y, o = e.z; return t[0] *= r, t[4] *= i, t[8] *= o, t[1] *= r, t[5] *= i, t[9] *= o, t[2] *= r, t[6] *= i, t[10] *= o, t[3] *= r, t[7] *= i, t[11] *= o, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, r, i)) } makeTranslation(e, t, r) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const r = Math.cos(t), i = Math.sin(t), o = 1 - r, s = e.x, a = e.y, l = e.z, c = o * s, u = o * a; return this.set(c * s + r, c * a - i * l, c * l + i * a, 0, c * a + i * l, u * a + r, u * l - i * s, 0, c * l - i * a, u * l + i * s, o * l * l + r, 0, 0, 0, 0, 1), this } makeScale(e, t, r) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this } makeShear(e, t, r, i, o, s) { return this.set(1, r, o, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this } compose(e, t, r) { const i = this.elements, o = t._x, s = t._y, a = t._z, l = t._w, c = o + o, u = s + s, d = a + a, p = o * c, m = o * u, v = o * d, y = s * u, _ = s * d, g = a * d, x = l * c, A = l * u, E = l * d, w = r.x, b = r.y, T = r.z; return i[0] = (1 - (y + g)) * w, i[1] = (m + E) * w, i[2] = (v - A) * w, i[3] = 0, i[4] = (m - E) * b, i[5] = (1 - (p + g)) * b, i[6] = (_ + x) * b, i[7] = 0, i[8] = (v + A) * T, i[9] = (_ - x) * T, i[10] = (1 - (p + y)) * T, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, t, r) { const i = this.elements; let o = Mu.set(i[0], i[1], i[2]).length(); const s = Mu.set(i[4], i[5], i[6]).length(), a = Mu.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], ko.copy(this); const c = 1 / o, u = 1 / s, d = 1 / a; return ko.elements[0] *= c, ko.elements[1] *= c, ko.elements[2] *= c, ko.elements[4] *= u, ko.elements[5] *= u, ko.elements[6] *= u, ko.elements[8] *= d, ko.elements[9] *= d, ko.elements[10] *= d, t.setFromRotationMatrix(ko), r.x = o, r.y = s, r.z = a, this } makePerspective(e, t, r, i, o, s, a = Es) { const l = this.elements, c = 2 * o / (t - e), u = 2 * o / (r - i), d = (t + e) / (t - e), p = (r + i) / (r - i); let m, v; if (a === Es) m = -(s + o) / (s - o), v = -2 * s * o / (s - o); else if (a === fp) m = -s / (s - o), v = -s * o / (s - o); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a); return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = v, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this } makeOrthographic(e, t, r, i, o, s, a = Es) { const l = this.elements, c = 1 / (t - e), u = 1 / (r - i), d = 1 / (s - o), p = (t + e) * c, m = (r + i) * u; let v, y; if (a === Es) v = (s + o) * d, y = -2 * d; else if (a === fp) v = o * d, y = -1 * d; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a); return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -p, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = y, l[14] = -v, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this } equals(e) { const t = this.elements, r = e.elements; for (let i = 0; i < 16; i++)if (t[i] !== r[i]) return !1; return !0 } fromArray(e, t = 0) { for (let r = 0; r < 16; r++)this.elements[r] = e[r + t]; return this } toArray(e = [], t = 0) { const r = this.elements; return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e } } const Mu = new X, ko = new _t, ez = new X(0, 0, 0), tz = new X(1, 1, 1), Wa = new X, yg = new X, Xi = new X, qT = new _t, e2 = new Sr; class kp { constructor(e = 0, t = 0, r = 0, i = kp.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, r, i = this._order) { return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, r = !0) { const i = e.elements, o = i[0], s = i[4], a = i[8], l = i[1], c = i[5], u = i[9], d = i[2], p = i[6], m = i[10]; switch (t) { case "XYZ": this._y = Math.asin(Hn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, m), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(p, c), this._z = 0); break; case "YXZ": this._x = Math.asin(-Hn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, o), this._z = 0); break; case "ZXY": this._x = Math.asin(Hn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(l, o)); break; case "ZYX": this._y = Math.asin(-Hn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-s, c)); break; case "YZX": this._z = Math.asin(Hn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-d, o)) : (this._x = 0, this._y = Math.atan2(a, m)); break; case "XZY": this._z = Math.asin(-Hn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, r === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, r) { return qT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(qT, t, r) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return e2.setFromEuler(this), this.setFromQuaternion(e2, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } kp.DEFAULT_ORDER = "XYZ"; class Bc { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let nz = 0; const t2 = new X, wu = new Sr, qs = new _t, _g = new X, Xd = new X, rz = new X, iz = new Sr, n2 = new X(1, 0, 0), r2 = new X(0, 1, 0), i2 = new X(0, 0, 1), oz = { type: "added" }, sz = { type: "removed" }; class Ut extends Us { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: nz++ }), this.uuid = to(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ut.DEFAULT_UP.clone(); const e = new X, t = new kp, r = new Sr, i = new X(1, 1, 1); function o() { r.setFromEuler(t, !1) } function s() { t.setFromQuaternion(r, void 0, !1) } t._onChange(o), r._onChange(s), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: r }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new _t }, normalMatrix: { value: new Rt } }), this.matrix = new _t, this.matrixWorld = new _t, this.matrixAutoUpdate = Ut.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Bc, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return wu.setFromAxisAngle(e, t), this.quaternion.multiply(wu), this } rotateOnWorldAxis(e, t) { return wu.setFromAxisAngle(e, t), this.quaternion.premultiply(wu), this } rotateX(e) { return this.rotateOnAxis(n2, e) } rotateY(e) { return this.rotateOnAxis(r2, e) } rotateZ(e) { return this.rotateOnAxis(i2, e) } translateOnAxis(e, t) { return t2.copy(e).applyQuaternion(this.quaternion), this.position.add(t2.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(n2, e) } translateY(e) { return this.translateOnAxis(r2, e) } translateZ(e) { return this.translateOnAxis(i2, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(qs.copy(this.matrixWorld).invert()) } lookAt(e, t, r) { e.isVector3 ? _g.copy(e) : _g.set(e, t, r); const i = this.parent; this.updateWorldMatrix(!0, !1), Xd.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? qs.lookAt(Xd, _g, this.up) : qs.lookAt(_g, Xd, this.up), this.quaternion.setFromRotationMatrix(qs), i && (qs.extractRotation(i.matrixWorld), wu.setFromRotationMatrix(qs), this.quaternion.premultiply(wu.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(oz)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let r = 0; r < arguments.length; r++)this.remove(arguments[r]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(sz)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), qs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), qs.multiply(e.parent.matrixWorld)), e.applyMatrix4(qs), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let r = 0, i = this.children.length; r < i; r++) { const s = this.children[r].getObjectByProperty(e, t); if (s !== void 0) return s } } getObjectsByProperty(e, t) { let r = []; this[e] === t && r.push(this); for (let i = 0, o = this.children.length; i < o; i++) { const s = this.children[i].getObjectsByProperty(e, t); s.length > 0 && (r = r.concat(s)) } return r } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xd, e, rz), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xd, iz, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let r = 0, i = t.length; r < i; r++)t[r].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let r = 0, i = t.length; r < i; r++)t[r].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let r = 0, i = t.length; r < i; r++) { const o = t[r]; (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const r = this.parent; if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const i = this.children; for (let o = 0, s = i.length; o < s; o++) { const a = i[o]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", r = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, r.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const i = {}; i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())); function o(a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = o(e.geometries, this.geometry); const a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { const l = a.shapes; if (Array.isArray(l)) for (let c = 0, u = l.length; c < u; c++) { const d = l[c]; o(e.shapes, d) } else o(e.shapes, l) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const a = []; for (let l = 0, c = this.material.length; l < c; l++)a.push(o(e.materials, this.material[l])); i.material = a } else i.material = o(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let a = 0; a < this.children.length; a++)i.children.push(this.children[a].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let a = 0; a < this.animations.length; a++) { const l = this.animations[a]; i.animations.push(o(e.animations, l)) } } if (t) { const a = s(e.geometries), l = s(e.materials), c = s(e.textures), u = s(e.images), d = s(e.shapes), p = s(e.skeletons), m = s(e.animations), v = s(e.nodes); a.length > 0 && (r.geometries = a), l.length > 0 && (r.materials = l), c.length > 0 && (r.textures = c), u.length > 0 && (r.images = u), d.length > 0 && (r.shapes = d), p.length > 0 && (r.skeletons = p), m.length > 0 && (r.animations = m), v.length > 0 && (r.nodes = v) } return r.object = i, r; function s(a) { const l = []; for (const c in a) { const u = a[c]; delete u.metadata, l.push(u) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let r = 0; r < e.children.length; r++) { const i = e.children[r]; this.add(i.clone()) } return this } } Ut.DEFAULT_UP = new X(0, 1, 0); Ut.DEFAULT_MATRIX_AUTO_UPDATE = !0; Ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const No = new X, ea = new X, Q_ = new X, ta = new X, bu = new X, Cu = new X, o2 = new X, Z_ = new X, q_ = new X, ex = new X; let xg = !1; class Ci { constructor(e = new X, t = new X, r = new X) { this.a = e, this.b = t, this.c = r } static getNormal(e, t, r, i) { i.subVectors(r, t), No.subVectors(e, t), i.cross(No); const o = i.lengthSq(); return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0) } static getBarycoord(e, t, r, i, o) { No.subVectors(i, t), ea.subVectors(r, t), Q_.subVectors(e, t); const s = No.dot(No), a = No.dot(ea), l = No.dot(Q_), c = ea.dot(ea), u = ea.dot(Q_), d = s * c - a * a; if (d === 0) return o.set(-2, -1, -1); const p = 1 / d, m = (c * l - a * u) * p, v = (s * u - a * l) * p; return o.set(1 - m - v, v, m) } static containsPoint(e, t, r, i) { return this.getBarycoord(e, t, r, i, ta), ta.x >= 0 && ta.y >= 0 && ta.x + ta.y <= 1 } static getUV(e, t, r, i, o, s, a, l) { return xg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), xg = !0), this.getInterpolation(e, t, r, i, o, s, a, l) } static getInterpolation(e, t, r, i, o, s, a, l) { return this.getBarycoord(e, t, r, i, ta), l.setScalar(0), l.addScaledVector(o, ta.x), l.addScaledVector(s, ta.y), l.addScaledVector(a, ta.z), l } static isFrontFacing(e, t, r, i) { return No.subVectors(r, t), ea.subVectors(e, t), No.cross(ea).dot(i) < 0 } set(e, t, r) { return this.a.copy(e), this.b.copy(t), this.c.copy(r), this } setFromPointsAndIndices(e, t, r, i) { return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this } setFromAttributeAndIndices(e, t, r, i) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return No.subVectors(this.c, this.b), ea.subVectors(this.a, this.b), No.cross(ea).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Ci.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Ci.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, r, i, o) { return xg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), xg = !0), Ci.getInterpolation(e, this.a, this.b, this.c, t, r, i, o) } getInterpolation(e, t, r, i, o) { return Ci.getInterpolation(e, this.a, this.b, this.c, t, r, i, o) } containsPoint(e) { return Ci.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Ci.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const r = this.a, i = this.b, o = this.c; let s, a; bu.subVectors(i, r), Cu.subVectors(o, r), Z_.subVectors(e, r); const l = bu.dot(Z_), c = Cu.dot(Z_); if (l <= 0 && c <= 0) return t.copy(r); q_.subVectors(e, i); const u = bu.dot(q_), d = Cu.dot(q_); if (u >= 0 && d <= u) return t.copy(i); const p = l * d - u * c; if (p <= 0 && l >= 0 && u <= 0) return s = l / (l - u), t.copy(r).addScaledVector(bu, s); ex.subVectors(e, o); const m = bu.dot(ex), v = Cu.dot(ex); if (v >= 0 && m <= v) return t.copy(o); const y = m * c - l * v; if (y <= 0 && c >= 0 && v <= 0) return a = c / (c - v), t.copy(r).addScaledVector(Cu, a); const _ = u * v - m * d; if (_ <= 0 && d - u >= 0 && m - v >= 0) return o2.subVectors(o, i), a = (d - u) / (d - u + (m - v)), t.copy(i).addScaledVector(o2, a); const g = 1 / (_ + y + p); return s = y * g, a = p * g, t.copy(r).addScaledVector(bu, s).addScaledVector(Cu, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let az = 0; class rr extends Us { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: az++ }), this.uuid = to(), this.name = "", this.type = "Material", this.blending = Rc, this.side = qo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = SM, this.blendDst = AM, this.blendEquation = mc, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = _v, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = CD, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = U0, this.stencilZFail = U0, this.stencilZPass = U0, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const r = e[t]; if (r === void 0) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } const i = this[t]; if (i === void 0) { console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`); continue } i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const r = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== Rc && (r.blending = this.blending), this.side !== qo && (r.side = this.side), this.vertexColors === !0 && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = !0), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = !0), this.alphaToCoverage === !0 && (r.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0), this.forceSinglePass === !0 && (r.forceSinglePass = !0), this.wireframe === !0 && (r.wireframe = !0), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = !0), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData); function i(o) { const s = []; for (const a in o) { const l = o[a]; delete l.metadata, s.push(l) } return s } if (t) { const o = i(e.textures), s = i(e.images); o.length > 0 && (r.textures = o), s.length > 0 && (r.images = s) } return r } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let r = null; if (t !== null) { const i = t.length; r = new Array(i); for (let o = 0; o !== i; ++o)r[o] = t[o].clone() } return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } const zD = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ja = { h: 0, s: 0, l: 0 }, Sg = { h: 0, s: 0, l: 0 }; function tx(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n } class qe { constructor(e, t, r) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, r) } set(e, t, r) { if (t === void 0 && r === void 0) { const i = e; i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i) } else this.setRGB(e, t, r); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = ar) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, nn.toWorkingColorSpace(this, t), this } setRGB(e, t, r, i = nn.workingColorSpace) { return this.r = e, this.g = t, this.b = r, nn.toWorkingColorSpace(this, i), this } setHSL(e, t, r, i = nn.workingColorSpace) { if (e = DM(e, 1), t = Hn(t, 0, 1), r = Hn(r, 0, 1), t === 0) this.r = this.g = this.b = r; else { const o = r <= .5 ? r * (1 + t) : r + t - r * t, s = 2 * r - o; this.r = tx(s, o, e + 1 / 3), this.g = tx(s, o, e), this.b = tx(s, o, e - 1 / 3) } return nn.toWorkingColorSpace(this, i), this } setStyle(e, t = ar) { function r(o) { o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let i; if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) { let o; const s = i[1], a = i[2]; switch (s) { case "rgb": case "rgba": if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(o[4]), this.setRGB(Math.min(255, parseInt(o[1], 10)) / 255, Math.min(255, parseInt(o[2], 10)) / 255, Math.min(255, parseInt(o[3], 10)) / 255, t); if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(o[4]), this.setRGB(Math.min(100, parseInt(o[1], 10)) / 100, Math.min(100, parseInt(o[2], 10)) / 100, Math.min(100, parseInt(o[3], 10)) / 100, t); break; case "hsl": case "hsla": if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(o[4]), this.setHSL(parseFloat(o[1]) / 360, parseFloat(o[2]) / 100, parseFloat(o[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { const o = i[1], s = o.length; if (s === 3) return this.setRGB(parseInt(o.charAt(0), 16) / 15, parseInt(o.charAt(1), 16) / 15, parseInt(o.charAt(2), 16) / 15, t); if (s === 6) return this.setHex(parseInt(o, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = ar) { const r = zD[e.toLowerCase()]; return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = wf(e.r), this.g = wf(e.g), this.b = wf(e.b), this } copyLinearToSRGB(e) { return this.r = V_(e.r), this.g = V_(e.g), this.b = V_(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = ar) { return nn.fromWorkingColorSpace(Wr.copy(this), e), Math.round(Hn(Wr.r * 255, 0, 255)) * 65536 + Math.round(Hn(Wr.g * 255, 0, 255)) * 256 + Math.round(Hn(Wr.b * 255, 0, 255)) } getHexString(e = ar) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = nn.workingColorSpace) { nn.fromWorkingColorSpace(Wr.copy(this), t); const r = Wr.r, i = Wr.g, o = Wr.b, s = Math.max(r, i, o), a = Math.min(r, i, o); let l, c; const u = (a + s) / 2; if (a === s) l = 0, c = 0; else { const d = s - a; switch (c = u <= .5 ? d / (s + a) : d / (2 - s - a), s) { case r: l = (i - o) / d + (i < o ? 6 : 0); break; case i: l = (o - r) / d + 2; break; case o: l = (r - i) / d + 4; break }l /= 6 } return e.h = l, e.s = c, e.l = u, e } getRGB(e, t = nn.workingColorSpace) { return nn.fromWorkingColorSpace(Wr.copy(this), t), e.r = Wr.r, e.g = Wr.g, e.b = Wr.b, e } getStyle(e = ar) { nn.fromWorkingColorSpace(Wr.copy(this), e); const t = Wr.r, r = Wr.g, i = Wr.b; return e !== ar ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(i * 255)})` } offsetHSL(e, t, r) { return this.getHSL(ja), this.setHSL(ja.h + e, ja.s + t, ja.l + r) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, r) { return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this } lerpHSL(e, t) { this.getHSL(ja), e.getHSL(Sg); const r = Th(ja.h, Sg.h, t), i = Th(ja.s, Sg.s, t), o = Th(ja.l, Sg.l, t); return this.setHSL(r, i, o), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, r = this.g, i = this.b, o = e.elements; return this.r = o[0] * t + o[3] * r + o[6] * i, this.g = o[1] * t + o[4] * r + o[7] * i, this.b = o[2] * t + o[5] * r + o[8] * i, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const Wr = new qe; qe.NAMES = zD; class hi extends rr { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Op, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const sa = lz(); function lz() { const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), r = new Uint32Array(512), i = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const c = l - 127; c < -27 ? (r[l] = 0, r[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (r[l] = 1024 >> -c - 14, r[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (r[l] = c + 15 << 10, r[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (r[l] = 31744, r[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (r[l] = 31744, r[l | 256] = 64512, i[l] = 13, i[l | 256] = 13) } const o = new Uint32Array(2048), s = new Uint32Array(64), a = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let c = l << 13, u = 0; for (; !(c & 8388608);)c <<= 1, u -= 8388608; c &= -8388609, u += 947912704, o[l] = c | u } for (let l = 1024; l < 2048; ++l)o[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)s[l] = l << 23; s[31] = 1199570944, s[32] = 2147483648; for (let l = 33; l < 63; ++l)s[l] = 2147483648 + (l - 32 << 23); s[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (a[l] = 1024); return { floatView: e, uint32View: t, baseTable: r, shiftTable: i, mantissaTable: o, exponentTable: s, offsetTable: a } } function wi(n) { Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = Hn(n, -65504, 65504), sa.floatView[0] = n; const e = sa.uint32View[0], t = e >> 23 & 511; return sa.baseTable[t] + ((e & 8388607) >> sa.shiftTable[t]) } function hh(n) { const e = n >> 10; return sa.uint32View[0] = sa.mantissaTable[sa.offsetTable[e] + (n & 1023)] + sa.exponentTable[e], sa.floatView[0] } const cz = { toHalfFloat: wi, fromHalfFloat: hh }, er = new X, Ag = new Be; class Kt { constructor(e, t, r = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = up, this.updateRange = { offset: 0, count: -1 }, this.gpuType = As, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, r) { e *= this.itemSize, r *= t.itemSize; for (let i = 0, o = this.itemSize; i < o; i++)this.array[e + i] = t.array[r + i]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, r = this.count; t < r; t++)Ag.fromBufferAttribute(this, t), Ag.applyMatrix3(e), this.setXY(t, Ag.x, Ag.y); else if (this.itemSize === 3) for (let t = 0, r = this.count; t < r; t++)er.fromBufferAttribute(this, t), er.applyMatrix3(e), this.setXYZ(t, er.x, er.y, er.z); return this } applyMatrix4(e) { for (let t = 0, r = this.count; t < r; t++)er.fromBufferAttribute(this, t), er.applyMatrix4(e), this.setXYZ(t, er.x, er.y, er.z); return this } applyNormalMatrix(e) { for (let t = 0, r = this.count; t < r; t++)er.fromBufferAttribute(this, t), er.applyNormalMatrix(e), this.setXYZ(t, er.x, er.y, er.z); return this } transformDirection(e) { for (let t = 0, r = this.count; t < r; t++)er.fromBufferAttribute(this, t), er.transformDirection(e), this.setXYZ(t, er.x, er.y, er.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let r = this.array[e * this.itemSize + t]; return this.normalized && (r = Ri(r, this.array)), r } setComponent(e, t, r) { return this.normalized && (r = Pt(r, this.array)), this.array[e * this.itemSize + t] = r, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Ri(t, this.array)), t } setX(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Ri(t, this.array)), t } setY(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Ri(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Ri(t, this.array)), t } setW(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, r) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this } setXYZ(e, t, r, i) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this } setXYZW(e, t, r, i, o) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array), o = Pt(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = o, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== up && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } } class uz extends Kt { constructor(e, t, r) { super(new Int8Array(e), t, r) } } class fz extends Kt { constructor(e, t, r) { super(new Uint8Array(e), t, r) } } class dz extends Kt { constructor(e, t, r) { super(new Uint8ClampedArray(e), t, r) } } class hz extends Kt { constructor(e, t, r) { super(new Int16Array(e), t, r) } } class UM extends Kt { constructor(e, t, r) { super(new Uint16Array(e), t, r) } } class pz extends Kt { constructor(e, t, r) { super(new Int32Array(e), t, r) } } class kM extends Kt { constructor(e, t, r) { super(new Uint32Array(e), t, r) } } class mz extends Kt { constructor(e, t, r) { super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0 } getX(e) { let t = hh(this.array[e * this.itemSize]); return this.normalized && (t = Ri(t, this.array)), t } setX(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize] = wi(t), this } getY(e) { let t = hh(this.array[e * this.itemSize + 1]); return this.normalized && (t = Ri(t, this.array)), t } setY(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 1] = wi(t), this } getZ(e) { let t = hh(this.array[e * this.itemSize + 2]); return this.normalized && (t = Ri(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 2] = wi(t), this } getW(e) { let t = hh(this.array[e * this.itemSize + 3]); return this.normalized && (t = Ri(t, this.array)), t } setW(e, t) { return this.normalized && (t = Pt(t, this.array)), this.array[e * this.itemSize + 3] = wi(t), this } setXY(e, t, r) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array)), this.array[e + 0] = wi(t), this.array[e + 1] = wi(r), this } setXYZ(e, t, r, i) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array)), this.array[e + 0] = wi(t), this.array[e + 1] = wi(r), this.array[e + 2] = wi(i), this } setXYZW(e, t, r, i, o) { return e *= this.itemSize, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array), o = Pt(o, this.array)), this.array[e + 0] = wi(t), this.array[e + 1] = wi(r), this.array[e + 2] = wi(i), this.array[e + 3] = wi(o), this } } class ut extends Kt { constructor(e, t, r) { super(new Float32Array(e), t, r) } } class gz extends Kt { constructor(e, t, r) { super(new Float64Array(e), t, r) } } let vz = 0; const xo = new _t, nx = new Ut, Tu = new X, Ji = new yi, Jd = new yi, vr = new X; class bt extends Us { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: vz++ }), this.uuid = to(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (UD(e) ? kM : UM)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, r = 0) { this.groups.push({ start: e, count: t, materialIndex: r }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const r = this.attributes.normal; if (r !== void 0) { const o = new Rt().getNormalMatrix(e); r.applyNormalMatrix(o), r.needsUpdate = !0 } const i = this.attributes.tangent; return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return xo.makeRotationFromQuaternion(e), this.applyMatrix4(xo), this } rotateX(e) { return xo.makeRotationX(e), this.applyMatrix4(xo), this } rotateY(e) { return xo.makeRotationY(e), this.applyMatrix4(xo), this } rotateZ(e) { return xo.makeRotationZ(e), this.applyMatrix4(xo), this } translate(e, t, r) { return xo.makeTranslation(e, t, r), this.applyMatrix4(xo), this } scale(e, t, r) { return xo.makeScale(e, t, r), this.applyMatrix4(xo), this } lookAt(e) { return nx.lookAt(e), nx.updateMatrix(), this.applyMatrix4(nx.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Tu).negate(), this.translate(Tu.x, Tu.y, Tu.z), this } setFromPoints(e) { const t = []; for (let r = 0, i = e.length; r < i; r++) { const o = e[r]; t.push(o.x, o.y, o.z || 0) } return this.setAttribute("position", new ut(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new yi); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new X(-1 / 0, -1 / 0, -1 / 0), new X(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let r = 0, i = t.length; r < i; r++) { const o = t[r]; Ji.setFromBufferAttribute(o), this.morphTargetsRelative ? (vr.addVectors(this.boundingBox.min, Ji.min), this.boundingBox.expandByPoint(vr), vr.addVectors(this.boundingBox.max, Ji.max), this.boundingBox.expandByPoint(vr)) : (this.boundingBox.expandByPoint(Ji.min), this.boundingBox.expandByPoint(Ji.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new _i); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new X, 1 / 0); return } if (e) { const r = this.boundingSphere.center; if (Ji.setFromBufferAttribute(e), t) for (let o = 0, s = t.length; o < s; o++) { const a = t[o]; Jd.setFromBufferAttribute(a), this.morphTargetsRelative ? (vr.addVectors(Ji.min, Jd.min), Ji.expandByPoint(vr), vr.addVectors(Ji.max, Jd.max), Ji.expandByPoint(vr)) : (Ji.expandByPoint(Jd.min), Ji.expandByPoint(Jd.max)) } Ji.getCenter(r); let i = 0; for (let o = 0, s = e.count; o < s; o++)vr.fromBufferAttribute(e, o), i = Math.max(i, r.distanceToSquared(vr)); if (t) for (let o = 0, s = t.length; o < s; o++) { const a = t[o], l = this.morphTargetsRelative; for (let c = 0, u = a.count; c < u; c++)vr.fromBufferAttribute(a, c), l && (Tu.fromBufferAttribute(e, c), vr.add(Tu)), i = Math.max(i, r.distanceToSquared(vr)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const r = e.array, i = t.position.array, o = t.normal.array, s = t.uv.array, a = i.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Kt(new Float32Array(4 * a), 4)); const l = this.getAttribute("tangent").array, c = [], u = []; for (let P = 0; P < a; P++)c[P] = new X, u[P] = new X; const d = new X, p = new X, m = new X, v = new Be, y = new Be, _ = new Be, g = new X, x = new X; function A(P, U, G) { d.fromArray(i, P * 3), p.fromArray(i, U * 3), m.fromArray(i, G * 3), v.fromArray(s, P * 2), y.fromArray(s, U * 2), _.fromArray(s, G * 2), p.sub(d), m.sub(d), y.sub(v), _.sub(v); const $ = 1 / (y.x * _.y - _.x * y.y); isFinite($) && (g.copy(p).multiplyScalar(_.y).addScaledVector(m, -y.y).multiplyScalar($), x.copy(m).multiplyScalar(y.x).addScaledVector(p, -_.x).multiplyScalar($), c[P].add(g), c[U].add(g), c[G].add(g), u[P].add(x), u[U].add(x), u[G].add(x)) } let E = this.groups; E.length === 0 && (E = [{ start: 0, count: r.length }]); for (let P = 0, U = E.length; P < U; ++P) { const G = E[P], $ = G.start, z = G.count; for (let j = $, q = $ + z; j < q; j += 3)A(r[j + 0], r[j + 1], r[j + 2]) } const w = new X, b = new X, T = new X, B = new X; function R(P) { T.fromArray(o, P * 3), B.copy(T); const U = c[P]; w.copy(U), w.sub(T.multiplyScalar(T.dot(U))).normalize(), b.crossVectors(B, U); const $ = b.dot(u[P]) < 0 ? -1 : 1; l[P * 4] = w.x, l[P * 4 + 1] = w.y, l[P * 4 + 2] = w.z, l[P * 4 + 3] = $ } for (let P = 0, U = E.length; P < U; ++P) { const G = E[P], $ = G.start, z = G.count; for (let j = $, q = $ + z; j < q; j += 3)R(r[j + 0]), R(r[j + 1]), R(r[j + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let r = this.getAttribute("normal"); if (r === void 0) r = new Kt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r); else for (let p = 0, m = r.count; p < m; p++)r.setXYZ(p, 0, 0, 0); const i = new X, o = new X, s = new X, a = new X, l = new X, c = new X, u = new X, d = new X; if (e) for (let p = 0, m = e.count; p < m; p += 3) { const v = e.getX(p + 0), y = e.getX(p + 1), _ = e.getX(p + 2); i.fromBufferAttribute(t, v), o.fromBufferAttribute(t, y), s.fromBufferAttribute(t, _), u.subVectors(s, o), d.subVectors(i, o), u.cross(d), a.fromBufferAttribute(r, v), l.fromBufferAttribute(r, y), c.fromBufferAttribute(r, _), a.add(u), l.add(u), c.add(u), r.setXYZ(v, a.x, a.y, a.z), r.setXYZ(y, l.x, l.y, l.z), r.setXYZ(_, c.x, c.y, c.z) } else for (let p = 0, m = t.count; p < m; p += 3)i.fromBufferAttribute(t, p + 0), o.fromBufferAttribute(t, p + 1), s.fromBufferAttribute(t, p + 2), u.subVectors(s, o), d.subVectors(i, o), u.cross(d), r.setXYZ(p + 0, u.x, u.y, u.z), r.setXYZ(p + 1, u.x, u.y, u.z), r.setXYZ(p + 2, u.x, u.y, u.z); this.normalizeNormals(), r.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, r = e.count; t < r; t++)vr.fromBufferAttribute(e, t), vr.normalize(), e.setXYZ(t, vr.x, vr.y, vr.z) } toNonIndexed() { function e(a, l) { const c = a.array, u = a.itemSize, d = a.normalized, p = new c.constructor(l.length * u); let m = 0, v = 0; for (let y = 0, _ = l.length; y < _; y++) { a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * u; for (let g = 0; g < u; g++)p[v++] = c[m++] } return new Kt(p, u, d) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new bt, r = this.index.array, i = this.attributes; for (const a in i) { const l = i[a], c = e(l, r); t.setAttribute(a, c) } const o = this.morphAttributes; for (const a in o) { const l = [], c = o[a]; for (let u = 0, d = c.length; u < d; u++) { const p = c[u], m = e(p, r); l.push(m) } t.morphAttributes[a] = l } t.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let a = 0, l = s.length; a < l; a++) { const c = s[a]; t.addGroup(c.start, c.count, c.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const c in l) l[c] !== void 0 && (e[c] = l[c]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const r = this.attributes; for (const l in r) { const c = r[l]; e.data.attributes[l] = c.toJSON(e.data) } const i = {}; let o = !1; for (const l in this.morphAttributes) { const c = this.morphAttributes[l], u = []; for (let d = 0, p = c.length; d < p; d++) { const m = c[d]; u.push(m.toJSON(e.data)) } u.length > 0 && (i[l] = u, o = !0) } o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const a = this.boundingSphere; return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const r = e.index; r !== null && this.setIndex(r.clone(t)); const i = e.attributes; for (const c in i) { const u = i[c]; this.setAttribute(c, u.clone(t)) } const o = e.morphAttributes; for (const c in o) { const u = [], d = o[c]; for (let p = 0, m = d.length; p < m; p++)u.push(d[p].clone(t)); this.morphAttributes[c] = u } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let c = 0, u = s.length; c < u; c++) { const d = s[c]; this.addGroup(d.start, d.count, d.materialIndex) } const a = e.boundingBox; a !== null && (this.boundingBox = a.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const s2 = new _t, Ql = new Zc, Eg = new _i, a2 = new X, Ru = new X, Pu = new X, Bu = new X, rx = new X, Mg = new X, wg = new Be, bg = new Be, Cg = new Be, l2 = new X, c2 = new X, u2 = new X, Tg = new X, Rg = new X; class In extends Ut { constructor(e = new bt, t = new hi) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, s = i.length; o < s; o++) { const a = i[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o } } } } getVertexPosition(e, t) { const r = this.geometry, i = r.attributes.position, o = r.morphAttributes.position, s = r.morphTargetsRelative; t.fromBufferAttribute(i, e); const a = this.morphTargetInfluences; if (o && a) { Mg.set(0, 0, 0); for (let l = 0, c = o.length; l < c; l++) { const u = a[l], d = o[l]; u !== 0 && (rx.fromBufferAttribute(d, e), s ? Mg.addScaledVector(rx, u) : Mg.addScaledVector(rx.sub(t), u)) } t.add(Mg) } return t } raycast(e, t) { const r = this.geometry, i = this.material, o = this.matrixWorld; i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), Eg.copy(r.boundingSphere), Eg.applyMatrix4(o), Ql.copy(e.ray).recast(e.near), !(Eg.containsPoint(Ql.origin) === !1 && (Ql.intersectSphere(Eg, a2) === null || Ql.origin.distanceToSquared(a2) > (e.far - e.near) ** 2)) && (s2.copy(o).invert(), Ql.copy(e.ray).applyMatrix4(s2), !(r.boundingBox !== null && Ql.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, Ql))) } _computeIntersections(e, t, r) { let i; const o = this.geometry, s = this.material, a = o.index, l = o.attributes.position, c = o.attributes.uv, u = o.attributes.uv1, d = o.attributes.normal, p = o.groups, m = o.drawRange; if (a !== null) if (Array.isArray(s)) for (let v = 0, y = p.length; v < y; v++) { const _ = p[v], g = s[_.materialIndex], x = Math.max(_.start, m.start), A = Math.min(a.count, Math.min(_.start + _.count, m.start + m.count)); for (let E = x, w = A; E < w; E += 3) { const b = a.getX(E), T = a.getX(E + 1), B = a.getX(E + 2); i = Pg(this, g, e, r, c, u, d, b, T, B), i && (i.faceIndex = Math.floor(E / 3), i.face.materialIndex = _.materialIndex, t.push(i)) } } else { const v = Math.max(0, m.start), y = Math.min(a.count, m.start + m.count); for (let _ = v, g = y; _ < g; _ += 3) { const x = a.getX(_), A = a.getX(_ + 1), E = a.getX(_ + 2); i = Pg(this, s, e, r, c, u, d, x, A, E), i && (i.faceIndex = Math.floor(_ / 3), t.push(i)) } } else if (l !== void 0) if (Array.isArray(s)) for (let v = 0, y = p.length; v < y; v++) { const _ = p[v], g = s[_.materialIndex], x = Math.max(_.start, m.start), A = Math.min(l.count, Math.min(_.start + _.count, m.start + m.count)); for (let E = x, w = A; E < w; E += 3) { const b = E, T = E + 1, B = E + 2; i = Pg(this, g, e, r, c, u, d, b, T, B), i && (i.faceIndex = Math.floor(E / 3), i.face.materialIndex = _.materialIndex, t.push(i)) } } else { const v = Math.max(0, m.start), y = Math.min(l.count, m.start + m.count); for (let _ = v, g = y; _ < g; _ += 3) { const x = _, A = _ + 1, E = _ + 2; i = Pg(this, s, e, r, c, u, d, x, A, E), i && (i.faceIndex = Math.floor(_ / 3), t.push(i)) } } } } function yz(n, e, t, r, i, o, s, a) { let l; if (e.side === $r ? l = r.intersectTriangle(s, o, i, !0, a) : l = r.intersectTriangle(i, o, s, e.side === qo, a), l === null) return null; Rg.copy(a), Rg.applyMatrix4(n.matrixWorld); const c = t.ray.origin.distanceTo(Rg); return c < t.near || c > t.far ? null : { distance: c, point: Rg.clone(), object: n } } function Pg(n, e, t, r, i, o, s, a, l, c) { n.getVertexPosition(a, Ru), n.getVertexPosition(l, Pu), n.getVertexPosition(c, Bu); const u = yz(n, e, t, r, Ru, Pu, Bu, Tg); if (u) { i && (wg.fromBufferAttribute(i, a), bg.fromBufferAttribute(i, l), Cg.fromBufferAttribute(i, c), u.uv = Ci.getInterpolation(Tg, Ru, Pu, Bu, wg, bg, Cg, new Be)), o && (wg.fromBufferAttribute(o, a), bg.fromBufferAttribute(o, l), Cg.fromBufferAttribute(o, c), u.uv1 = Ci.getInterpolation(Tg, Ru, Pu, Bu, wg, bg, Cg, new Be), u.uv2 = u.uv1), s && (l2.fromBufferAttribute(s, a), c2.fromBufferAttribute(s, l), u2.fromBufferAttribute(s, c), u.normal = Ci.getInterpolation(Tg, Ru, Pu, Bu, l2, c2, u2, new X), u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1)); const d = { a, b: l, c, normal: new X, materialIndex: 0 }; Ci.getNormal(Ru, Pu, Bu, d.normal), u.face = d } return u } class qc extends bt { constructor(e = 1, t = 1, r = 1, i = 1, o = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: r, widthSegments: i, heightSegments: o, depthSegments: s }; const a = this; i = Math.floor(i), o = Math.floor(o), s = Math.floor(s); const l = [], c = [], u = [], d = []; let p = 0, m = 0; v("z", "y", "x", -1, -1, r, t, e, s, o, 0), v("z", "y", "x", 1, -1, r, t, -e, s, o, 1), v("x", "z", "y", 1, 1, e, r, t, i, s, 2), v("x", "z", "y", 1, -1, e, r, -t, i, s, 3), v("x", "y", "z", 1, -1, e, t, r, i, o, 4), v("x", "y", "z", -1, -1, e, t, -r, i, o, 5), this.setIndex(l), this.setAttribute("position", new ut(c, 3)), this.setAttribute("normal", new ut(u, 3)), this.setAttribute("uv", new ut(d, 2)); function v(y, _, g, x, A, E, w, b, T, B, R) { const P = E / T, U = w / B, G = E / 2, $ = w / 2, z = b / 2, j = T + 1, q = B + 1; let se = 0, W = 0; const V = new X; for (let J = 0; J < q; J++) { const O = J * U - $; for (let k = 0; k < j; k++) { const Z = k * P - G; V[y] = Z * x, V[_] = O * A, V[g] = z, c.push(V.x, V.y, V.z), V[y] = 0, V[_] = 0, V[g] = b > 0 ? 1 : -1, u.push(V.x, V.y, V.z), d.push(k / T), d.push(1 - J / B), se += 1 } } for (let J = 0; J < B; J++)for (let O = 0; O < T; O++) { const k = p + O + j * J, Z = p + O + j * (J + 1), ee = p + (O + 1) + j * (J + 1), ne = p + (O + 1) + j * J; l.push(k, Z, ne), l.push(Z, ee, ne), W += 6 } a.addGroup(m, W, R), m += W, p += se } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new qc(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Hf(n) { const e = {}; for (const t in n) { e[t] = {}; for (const r in n[t]) { const i = n[t][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][r] = null) : e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i } } return e } function fi(n) { const e = {}; for (let t = 0; t < n.length; t++) { const r = Hf(n[t]); for (const i in r) e[i] = r[i] } return e } function _z(n) { const e = []; for (let t = 0; t < n.length; t++)e.push(n[t].clone()); return e } function GD(n) { return n.getRenderTarget() === null ? n.outputColorSpace : nn.workingColorSpace } const _a = { clone: Hf, merge: fi }; var xz = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Sz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class _r extends rr { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = xz, this.fragmentShader = Sz, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Hf(e.uniforms), this.uniformsGroups = _z(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const i in this.uniforms) { const s = this.uniforms[i].value; s && s.isTexture ? t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid } : s && s.isColor ? t.uniforms[i] = { type: "c", value: s.getHex() } : s && s.isVector2 ? t.uniforms[i] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? t.uniforms[i] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? t.uniforms[i] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? t.uniforms[i] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? t.uniforms[i] = { type: "m4", value: s.toArray() } : t.uniforms[i] = { value: s } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const r = {}; for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0); return Object.keys(r).length > 0 && (t.extensions = r), t } } class Np extends Ut { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new _t, this.projectionMatrix = new _t, this.projectionMatrixInverse = new _t, this.coordinateSystem = Es } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } class xn extends Np { constructor(e = 50, t = 1, r = .1, i = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = Gf * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(Pc * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return Gf * 2 * Math.atan(Math.tan(Pc * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, r, i, o, s) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(Pc * .5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, o = -.5 * i; const s = this.view; if (this.view !== null && this.view.enabled) { const l = s.fullWidth, c = s.fullHeight; o += s.offsetX * i / l, t -= s.offsetY * r / c, i *= s.width / l, r *= s.height / c } const a = this.filmOffset; a !== 0 && (o += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const Iu = -90, Lu = 1; class HD extends Ut { constructor(e, t, r) { super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null, this.activeMipmapLevel = 0; const i = new xn(Iu, Lu, e, t); i.layers = this.layers, this.add(i); const o = new xn(Iu, Lu, e, t); o.layers = this.layers, this.add(o); const s = new xn(Iu, Lu, e, t); s.layers = this.layers, this.add(s); const a = new xn(Iu, Lu, e, t); a.layers = this.layers, this.add(a); const l = new xn(Iu, Lu, e, t); l.layers = this.layers, this.add(l); const c = new xn(Iu, Lu, e, t); c.layers = this.layers, this.add(c) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [r, i, o, s, a, l] = t; for (const c of t) this.remove(c); if (e === Es) r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1); else if (e === fp) r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (const c of t) this.add(c), c.updateMatrixWorld() } update(e, t) { this.parent === null && this.updateMatrixWorld(); const { renderTarget: r, activeMipmapLevel: i } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [o, s, a, l, c, u] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), m = e.getActiveMipmapLevel(), v = e.xr.enabled; e.xr.enabled = !1; const y = r.texture.generateMipmaps; r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0, i), e.render(t, o), e.setRenderTarget(r, 1, i), e.render(t, s), e.setRenderTarget(r, 2, i), e.render(t, a), e.setRenderTarget(r, 3, i), e.render(t, l), e.setRenderTarget(r, 4, i), e.render(t, c), r.texture.generateMipmaps = y, e.setRenderTarget(r, 5, i), e.render(t, u), e.setRenderTarget(d, p, m), e.xr.enabled = v, r.texture.needsPMREMUpdate = !0 } } class zp extends An { constructor(e, t, r, i, o, s, a, l, c, u) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : ya, super(e, t, r, i, o, s, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class VD extends Qr {
	constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r]; t.encoding !== void 0 && (Rh("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === ml ? ar : $i), this.texture = new zp(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : fn } fromEquirectangularTexture(e, t) {
		this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const r = {
			uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, i = new qc(5, 5, 5), o = new _r({ name: "CubemapFromEquirect", uniforms: Hf(r.uniforms), vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, side: $r, blending: bs }); o.uniforms.tEquirect.value = t; const s = new In(i, o), a = t.minFilter; return t.minFilter === Ds && (t.minFilter = fn), new HD(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
	} clear(e, t, r, i) { const o = e.getRenderTarget(); for (let s = 0; s < 6; s++)e.setRenderTarget(this, s), e.clear(t, r, i); e.setRenderTarget(o) }
} const ix = new X, Az = new X, Ez = new Rt; class oa { constructor(e = new X(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, r, i) { return this.normal.set(e, t, r), this.constant = i, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, r) { const i = ix.subVectors(r, t).cross(Az.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const r = e.delta(ix), i = this.normal.dot(r); if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const o = -(e.start.dot(this.normal) + this.constant) / i; return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o) } intersectsLine(e) { const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end); return t < 0 && r > 0 || r < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const r = t || Ez.getNormalMatrix(e), i = this.coplanarPoint(ix).applyMatrix4(e), o = this.normal.applyMatrix3(r).normalize(); return this.constant = -i.dot(o), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const Zl = new _i, Bg = new X; class dy { constructor(e = new oa, t = new oa, r = new oa, i = new oa, o = new oa, s = new oa) { this.planes = [e, t, r, i, o, s] } set(e, t, r, i, o, s) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(r), a[3].copy(i), a[4].copy(o), a[5].copy(s), this } copy(e) { const t = this.planes; for (let r = 0; r < 6; r++)t[r].copy(e.planes[r]); return this } setFromProjectionMatrix(e, t = Es) { const r = this.planes, i = e.elements, o = i[0], s = i[1], a = i[2], l = i[3], c = i[4], u = i[5], d = i[6], p = i[7], m = i[8], v = i[9], y = i[10], _ = i[11], g = i[12], x = i[13], A = i[14], E = i[15]; if (r[0].setComponents(l - o, p - c, _ - m, E - g).normalize(), r[1].setComponents(l + o, p + c, _ + m, E + g).normalize(), r[2].setComponents(l + s, p + u, _ + v, E + x).normalize(), r[3].setComponents(l - s, p - u, _ - v, E - x).normalize(), r[4].setComponents(l - a, p - d, _ - y, E - A).normalize(), t === Es) r[5].setComponents(l + a, p + d, _ + y, E + A).normalize(); else if (t === fp) r[5].setComponents(a, d, y, A).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); return this } intersectsObject(e) { if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Zl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; t.boundingSphere === null && t.computeBoundingSphere(), Zl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(Zl) } intersectsSprite(e) { return Zl.center.set(0, 0, 0), Zl.radius = .7071067811865476, Zl.applyMatrix4(e.matrixWorld), this.intersectsSphere(Zl) } intersectsSphere(e) { const t = this.planes, r = e.center, i = -e.radius; for (let o = 0; o < 6; o++)if (t[o].distanceToPoint(r) < i) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let r = 0; r < 6; r++) { const i = t[r]; if (Bg.x = i.normal.x > 0 ? e.max.x : e.min.x, Bg.y = i.normal.y > 0 ? e.max.y : e.min.y, Bg.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Bg) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let r = 0; r < 6; r++)if (t[r].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function WD() { let n = null, e = !1, t = null, r = null; function i(o, s) { t(o, s), r = n.requestAnimationFrame(i) } return { start: function () { e !== !0 && t !== null && (r = n.requestAnimationFrame(i), e = !0) }, stop: function () { n.cancelAnimationFrame(r), e = !1 }, setAnimationLoop: function (o) { t = o }, setContext: function (o) { n = o } } } function Mz(n, e) { const t = e.isWebGL2, r = new WeakMap; function i(c, u) { const d = c.array, p = c.usage, m = n.createBuffer(); n.bindBuffer(u, m), n.bufferData(u, d, p), c.onUploadCallback(); let v; if (d instanceof Float32Array) v = n.FLOAT; else if (d instanceof Uint16Array) if (c.isFloat16BufferAttribute) if (t) v = n.HALF_FLOAT; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else v = n.UNSIGNED_SHORT; else if (d instanceof Int16Array) v = n.SHORT; else if (d instanceof Uint32Array) v = n.UNSIGNED_INT; else if (d instanceof Int32Array) v = n.INT; else if (d instanceof Int8Array) v = n.BYTE; else if (d instanceof Uint8Array) v = n.UNSIGNED_BYTE; else if (d instanceof Uint8ClampedArray) v = n.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d); return { buffer: m, type: v, bytesPerElement: d.BYTES_PER_ELEMENT, version: c.version } } function o(c, u, d) { const p = u.array, m = u.updateRange; n.bindBuffer(d, c), m.count === -1 ? n.bufferSubData(d, 0, p) : (t ? n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), u.onUploadCallback() } function s(c) { return c.isInterleavedBufferAttribute && (c = c.data), r.get(c) } function a(c) { c.isInterleavedBufferAttribute && (c = c.data); const u = r.get(c); u && (n.deleteBuffer(u.buffer), r.delete(c)) } function l(c, u) { if (c.isGLBufferAttribute) { const p = r.get(c); (!p || p.version < c.version) && r.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version }); return } c.isInterleavedBufferAttribute && (c = c.data); const d = r.get(c); d === void 0 ? r.set(c, i(c, u)) : d.version < c.version && (o(d.buffer, c, u), d.version = c.version) } return { get: s, remove: a, update: l } } class ba extends bt { constructor(e = 1, t = 1, r = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: r, heightSegments: i }; const o = e / 2, s = t / 2, a = Math.floor(r), l = Math.floor(i), c = a + 1, u = l + 1, d = e / a, p = t / l, m = [], v = [], y = [], _ = []; for (let g = 0; g < u; g++) { const x = g * p - s; for (let A = 0; A < c; A++) { const E = A * d - o; v.push(E, -x, 0), y.push(0, 0, 1), _.push(A / a), _.push(1 - g / l) } } for (let g = 0; g < l; g++)for (let x = 0; x < a; x++) { const A = x + c * g, E = x + c * (g + 1), w = x + 1 + c * (g + 1), b = x + 1 + c * g; m.push(A, E, b), m.push(E, w, b) } this.setIndex(m), this.setAttribute("position", new ut(v, 3)), this.setAttribute("normal", new ut(y, 3)), this.setAttribute("uv", new ut(_, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new ba(e.width, e.height, e.widthSegments, e.heightSegments) } } var wz = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, bz = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Cz = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Tz = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Rz = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, Pz = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Bz = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Iz = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Lz = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Dz = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Oz = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Fz = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Uz = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, kz = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Nz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, zz = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Gz = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Hz = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Vz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Wz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, jz = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Xz = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Jz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Kz = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Yz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, $z = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Qz = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Zz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, qz = "gl_FragColor = linearToOutputTexel( gl_FragColor );", eG = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, tG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, nG = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, rG = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, iG = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, oG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, sG = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, aG = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, lG = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, cG = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, uG = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, fG = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, dG = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, hG = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, pG = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, mG = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, gG = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, vG = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, yG = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, _G = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, xG = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, SG = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, AG = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, EG = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal;
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, MG = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, wG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, bG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, CG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, TG = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, RG = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, PG = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, BG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, IG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, LG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, DG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, OG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, FG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, UG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, kG = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, NG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, zG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, GG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, HG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, VG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, WG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, jG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, XG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, JG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, KG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, YG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, $G = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, QG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, ZG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, qG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, eH = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, tH = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, nH = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, rH = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, iH = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, oH = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, sH = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, aH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, lH = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, cH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, uH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, fH = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, dH = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, hH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, pH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, mH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, gH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, vH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, yH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, _H = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, xH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, SH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const AH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, EH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, MH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, wH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, bH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, CH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, TH = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, RH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, PH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, BH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, IH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, LH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, DH = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, OH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, FH = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, UH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, kH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, NH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, zH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, GH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, HH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, VH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, WH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, jH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, JH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, KH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, YH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, $H = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, QH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, ZH = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, e8 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, t8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Tt = { alphahash_fragment: wz, alphahash_pars_fragment: bz, alphamap_fragment: Cz, alphamap_pars_fragment: Tz, alphatest_fragment: Rz, alphatest_pars_fragment: Pz, aomap_fragment: Bz, aomap_pars_fragment: Iz, begin_vertex: Lz, beginnormal_vertex: Dz, bsdfs: Oz, iridescence_fragment: Fz, bumpmap_pars_fragment: Uz, clipping_planes_fragment: kz, clipping_planes_pars_fragment: Nz, clipping_planes_pars_vertex: zz, clipping_planes_vertex: Gz, color_fragment: Hz, color_pars_fragment: Vz, color_pars_vertex: Wz, color_vertex: jz, common: Xz, cube_uv_reflection_fragment: Jz, defaultnormal_vertex: Kz, displacementmap_pars_vertex: Yz, displacementmap_vertex: $z, emissivemap_fragment: Qz, emissivemap_pars_fragment: Zz, colorspace_fragment: qz, colorspace_pars_fragment: eG, envmap_fragment: tG, envmap_common_pars_fragment: nG, envmap_pars_fragment: rG, envmap_pars_vertex: iG, envmap_physical_pars_fragment: gG, envmap_vertex: oG, fog_vertex: sG, fog_pars_vertex: aG, fog_fragment: lG, fog_pars_fragment: cG, gradientmap_pars_fragment: uG, lightmap_fragment: fG, lightmap_pars_fragment: dG, lights_lambert_fragment: hG, lights_lambert_pars_fragment: pG, lights_pars_begin: mG, lights_toon_fragment: vG, lights_toon_pars_fragment: yG, lights_phong_fragment: _G, lights_phong_pars_fragment: xG, lights_physical_fragment: SG, lights_physical_pars_fragment: AG, lights_fragment_begin: EG, lights_fragment_maps: MG, lights_fragment_end: wG, logdepthbuf_fragment: bG, logdepthbuf_pars_fragment: CG, logdepthbuf_pars_vertex: TG, logdepthbuf_vertex: RG, map_fragment: PG, map_pars_fragment: BG, map_particle_fragment: IG, map_particle_pars_fragment: LG, metalnessmap_fragment: DG, metalnessmap_pars_fragment: OG, morphcolor_vertex: FG, morphnormal_vertex: UG, morphtarget_pars_vertex: kG, morphtarget_vertex: NG, normal_fragment_begin: zG, normal_fragment_maps: GG, normal_pars_fragment: HG, normal_pars_vertex: VG, normal_vertex: WG, normalmap_pars_fragment: jG, clearcoat_normal_fragment_begin: XG, clearcoat_normal_fragment_maps: JG, clearcoat_pars_fragment: KG, iridescence_pars_fragment: YG, opaque_fragment: $G, packing: QG, premultiplied_alpha_fragment: ZG, project_vertex: qG, dithering_fragment: eH, dithering_pars_fragment: tH, roughnessmap_fragment: nH, roughnessmap_pars_fragment: rH, shadowmap_pars_fragment: iH, shadowmap_pars_vertex: oH, shadowmap_vertex: sH, shadowmask_pars_fragment: aH, skinbase_vertex: lH, skinning_pars_vertex: cH, skinning_vertex: uH, skinnormal_vertex: fH, specularmap_fragment: dH, specularmap_pars_fragment: hH, tonemapping_fragment: pH, tonemapping_pars_fragment: mH, transmission_fragment: gH, transmission_pars_fragment: vH, uv_pars_fragment: yH, uv_pars_vertex: _H, uv_vertex: xH, worldpos_vertex: SH, background_vert: AH, background_frag: EH, backgroundCube_vert: MH, backgroundCube_frag: wH, cube_vert: bH, cube_frag: CH, depth_vert: TH, depth_frag: RH, distanceRGBA_vert: PH, distanceRGBA_frag: BH, equirect_vert: IH, equirect_frag: LH, linedashed_vert: DH, linedashed_frag: OH, meshbasic_vert: FH, meshbasic_frag: UH, meshlambert_vert: kH, meshlambert_frag: NH, meshmatcap_vert: zH, meshmatcap_frag: GH, meshnormal_vert: HH, meshnormal_frag: VH, meshphong_vert: WH, meshphong_frag: jH, meshphysical_vert: XH, meshphysical_frag: JH, meshtoon_vert: KH, meshtoon_frag: YH, points_vert: $H, points_frag: QH, shadow_vert: ZH, shadow_frag: qH, sprite_vert: e8, sprite_frag: t8 }, et = { common: { diffuse: { value: new qe(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Rt }, alphaMap: { value: null }, alphaMapTransform: { value: new Rt }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Rt } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Rt } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Rt } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Rt }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Rt }, normalScale: { value: new Be(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Rt }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Rt } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Rt } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Rt } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new qe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new qe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Rt }, alphaTest: { value: 0 }, uvTransform: { value: new Rt } }, sprite: { diffuse: { value: new qe(16777215) }, opacity: { value: 1 }, center: { value: new Be(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Rt }, alphaMap: { value: null }, alphaMapTransform: { value: new Rt }, alphaTest: { value: 0 } } }, jo = { basic: { uniforms: fi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.fog]), vertexShader: Tt.meshbasic_vert, fragmentShader: Tt.meshbasic_frag }, lambert: { uniforms: fi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.fog, et.lights, { emissive: { value: new qe(0) } }]), vertexShader: Tt.meshlambert_vert, fragmentShader: Tt.meshlambert_frag }, phong: { uniforms: fi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.fog, et.lights, { emissive: { value: new qe(0) }, specular: { value: new qe(1118481) }, shininess: { value: 30 } }]), vertexShader: Tt.meshphong_vert, fragmentShader: Tt.meshphong_frag }, standard: { uniforms: fi([et.common, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.roughnessmap, et.metalnessmap, et.fog, et.lights, { emissive: { value: new qe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Tt.meshphysical_vert, fragmentShader: Tt.meshphysical_frag }, toon: { uniforms: fi([et.common, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.gradientmap, et.fog, et.lights, { emissive: { value: new qe(0) } }]), vertexShader: Tt.meshtoon_vert, fragmentShader: Tt.meshtoon_frag }, matcap: { uniforms: fi([et.common, et.bumpmap, et.normalmap, et.displacementmap, et.fog, { matcap: { value: null } }]), vertexShader: Tt.meshmatcap_vert, fragmentShader: Tt.meshmatcap_frag }, points: { uniforms: fi([et.points, et.fog]), vertexShader: Tt.points_vert, fragmentShader: Tt.points_frag }, dashed: { uniforms: fi([et.common, et.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Tt.linedashed_vert, fragmentShader: Tt.linedashed_frag }, depth: { uniforms: fi([et.common, et.displacementmap]), vertexShader: Tt.depth_vert, fragmentShader: Tt.depth_frag }, normal: { uniforms: fi([et.common, et.bumpmap, et.normalmap, et.displacementmap, { opacity: { value: 1 } }]), vertexShader: Tt.meshnormal_vert, fragmentShader: Tt.meshnormal_frag }, sprite: { uniforms: fi([et.sprite, et.fog]), vertexShader: Tt.sprite_vert, fragmentShader: Tt.sprite_frag }, background: { uniforms: { uvTransform: { value: new Rt }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Tt.background_vert, fragmentShader: Tt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Tt.backgroundCube_vert, fragmentShader: Tt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Tt.cube_vert, fragmentShader: Tt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Tt.equirect_vert, fragmentShader: Tt.equirect_frag }, distanceRGBA: { uniforms: fi([et.common, et.displacementmap, { referencePosition: { value: new X }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Tt.distanceRGBA_vert, fragmentShader: Tt.distanceRGBA_frag }, shadow: { uniforms: fi([et.lights, et.fog, { color: { value: new qe(0) }, opacity: { value: 1 } }]), vertexShader: Tt.shadow_vert, fragmentShader: Tt.shadow_frag } }; jo.physical = { uniforms: fi([jo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Rt }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Rt }, clearcoatNormalScale: { value: new Be(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Rt }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Rt }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Rt }, sheen: { value: 0 }, sheenColor: { value: new qe(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Rt }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Rt }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Rt }, transmissionSamplerSize: { value: new Be }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Rt }, attenuationDistance: { value: 0 }, attenuationColor: { value: new qe(0) }, specularColor: { value: new qe(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Rt }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Rt }, anisotropyVector: { value: new Be }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Rt } }]), vertexShader: Tt.meshphysical_vert, fragmentShader: Tt.meshphysical_frag }; const Ig = { r: 0, b: 0, g: 0 }; function n8(n, e, t, r, i, o, s) { const a = new qe(0); let l = o === !0 ? 0 : 1, c, u, d = null, p = 0, m = null; function v(_, g) { let x = !1, A = g.isScene === !0 ? g.background : null; A && A.isTexture && (A = (g.backgroundBlurriness > 0 ? t : e).get(A)), A === null ? y(a, l) : A && A.isColor && (y(A, 1), x = !0); const E = n.xr.getEnvironmentBlendMode(); E === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, s) : E === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s), (n.autoClear || x) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), A && (A.isCubeTexture || A.mapping === sd) ? (u === void 0 && (u = new In(new qc(1, 1, 1), new _r({ name: "BackgroundCubeMaterial", uniforms: Hf(jo.backgroundCube.uniforms), vertexShader: jo.backgroundCube.vertexShader, fragmentShader: jo.backgroundCube.fragmentShader, side: $r, depthTest: !1, depthWrite: !1, fog: !1 })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (w, b, T) { this.matrixWorld.copyPosition(T.matrixWorld) }, Object.defineProperty(u.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(u)), u.material.uniforms.envMap.value = A, u.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, u.material.toneMapped = nn.getTransfer(A.colorSpace) !== hn, (d !== A || p !== A.version || m !== n.toneMapping) && (u.material.needsUpdate = !0, d = A, p = A.version, m = n.toneMapping), u.layers.enableAll(), _.unshift(u, u.geometry, u.material, 0, 0, null)) : A && A.isTexture && (c === void 0 && (c = new In(new ba(2, 2), new _r({ name: "BackgroundMaterial", uniforms: Hf(jo.background.uniforms), vertexShader: jo.background.vertexShader, fragmentShader: jo.background.fragmentShader, side: qo, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(c)), c.material.uniforms.t2D.value = A, c.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, c.material.toneMapped = nn.getTransfer(A.colorSpace) !== hn, A.matrixAutoUpdate === !0 && A.updateMatrix(), c.material.uniforms.uvTransform.value.copy(A.matrix), (d !== A || p !== A.version || m !== n.toneMapping) && (c.material.needsUpdate = !0, d = A, p = A.version, m = n.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null)) } function y(_, g) { _.getRGB(Ig, GD(n)), r.buffers.color.setClear(Ig.r, Ig.g, Ig.b, g, s) } return { getClearColor: function () { return a }, setClearColor: function (_, g = 1) { a.set(_), l = g, y(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (_) { l = _, y(a, l) }, render: v } } function r8(n, e, t, r) { const i = n.getParameter(n.MAX_VERTEX_ATTRIBS), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = r.isWebGL2 || o !== null, a = {}, l = _(null); let c = l, u = !1; function d(z, j, q, se, W) { let V = !1; if (s) { const J = y(se, q, j); c !== J && (c = J, m(c.object)), V = g(z, se, q, W), V && x(z, se, q, W) } else { const J = j.wireframe === !0; (c.geometry !== se.id || c.program !== q.id || c.wireframe !== J) && (c.geometry = se.id, c.program = q.id, c.wireframe = J, V = !0) } W !== null && t.update(W, n.ELEMENT_ARRAY_BUFFER), (V || u) && (u = !1, B(z, j, q, se), W !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(W).buffer)) } function p() { return r.isWebGL2 ? n.createVertexArray() : o.createVertexArrayOES() } function m(z) { return r.isWebGL2 ? n.bindVertexArray(z) : o.bindVertexArrayOES(z) } function v(z) { return r.isWebGL2 ? n.deleteVertexArray(z) : o.deleteVertexArrayOES(z) } function y(z, j, q) { const se = q.wireframe === !0; let W = a[z.id]; W === void 0 && (W = {}, a[z.id] = W); let V = W[j.id]; V === void 0 && (V = {}, W[j.id] = V); let J = V[se]; return J === void 0 && (J = _(p()), V[se] = J), J } function _(z) { const j = [], q = [], se = []; for (let W = 0; W < i; W++)j[W] = 0, q[W] = 0, se[W] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: j, enabledAttributes: q, attributeDivisors: se, object: z, attributes: {}, index: null } } function g(z, j, q, se) { const W = c.attributes, V = j.attributes; let J = 0; const O = q.getAttributes(); for (const k in O) if (O[k].location >= 0) { const ee = W[k]; let ne = V[k]; if (ne === void 0 && (k === "instanceMatrix" && z.instanceMatrix && (ne = z.instanceMatrix), k === "instanceColor" && z.instanceColor && (ne = z.instanceColor)), ee === void 0 || ee.attribute !== ne || ne && ee.data !== ne.data) return !0; J++ } return c.attributesNum !== J || c.index !== se } function x(z, j, q, se) { const W = {}, V = j.attributes; let J = 0; const O = q.getAttributes(); for (const k in O) if (O[k].location >= 0) { let ee = V[k]; ee === void 0 && (k === "instanceMatrix" && z.instanceMatrix && (ee = z.instanceMatrix), k === "instanceColor" && z.instanceColor && (ee = z.instanceColor)); const ne = {}; ne.attribute = ee, ee && ee.data && (ne.data = ee.data), W[k] = ne, J++ } c.attributes = W, c.attributesNum = J, c.index = se } function A() { const z = c.newAttributes; for (let j = 0, q = z.length; j < q; j++)z[j] = 0 } function E(z) { w(z, 0) } function w(z, j) { const q = c.newAttributes, se = c.enabledAttributes, W = c.attributeDivisors; q[z] = 1, se[z] === 0 && (n.enableVertexAttribArray(z), se[z] = 1), W[z] !== j && ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](z, j), W[z] = j) } function b() { const z = c.newAttributes, j = c.enabledAttributes; for (let q = 0, se = j.length; q < se; q++)j[q] !== z[q] && (n.disableVertexAttribArray(q), j[q] = 0) } function T(z, j, q, se, W, V, J) { J === !0 ? n.vertexAttribIPointer(z, j, q, W, V) : n.vertexAttribPointer(z, j, q, se, W, V) } function B(z, j, q, se) { if (r.isWebGL2 === !1 && (z.isInstancedMesh || se.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; A(); const W = se.attributes, V = q.getAttributes(), J = j.defaultAttributeValues; for (const O in V) { const k = V[O]; if (k.location >= 0) { let Z = W[O]; if (Z === void 0 && (O === "instanceMatrix" && z.instanceMatrix && (Z = z.instanceMatrix), O === "instanceColor" && z.instanceColor && (Z = z.instanceColor)), Z !== void 0) { const ee = Z.normalized, ne = Z.itemSize, K = t.get(Z); if (K === void 0) continue; const ae = K.buffer, ie = K.type, Se = K.bytesPerElement, Ce = r.isWebGL2 === !0 && (ie === n.INT || ie === n.UNSIGNED_INT || Z.gpuType === MM); if (Z.isInterleavedBufferAttribute) { const le = Z.data, F = le.stride, me = Z.offset; if (le.isInstancedInterleavedBuffer) { for (let he = 0; he < k.locationSize; he++)w(k.location + he, le.meshPerAttribute); z.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = le.meshPerAttribute * le.count) } else for (let he = 0; he < k.locationSize; he++)E(k.location + he); n.bindBuffer(n.ARRAY_BUFFER, ae); for (let he = 0; he < k.locationSize; he++)T(k.location + he, ne / k.locationSize, ie, ee, F * Se, (me + ne / k.locationSize * he) * Se, Ce) } else { if (Z.isInstancedBufferAttribute) { for (let le = 0; le < k.locationSize; le++)w(k.location + le, Z.meshPerAttribute); z.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = Z.meshPerAttribute * Z.count) } else for (let le = 0; le < k.locationSize; le++)E(k.location + le); n.bindBuffer(n.ARRAY_BUFFER, ae); for (let le = 0; le < k.locationSize; le++)T(k.location + le, ne / k.locationSize, ie, ee, ne * Se, ne / k.locationSize * le * Se, Ce) } } else if (J !== void 0) { const ee = J[O]; if (ee !== void 0) switch (ee.length) { case 2: n.vertexAttrib2fv(k.location, ee); break; case 3: n.vertexAttrib3fv(k.location, ee); break; case 4: n.vertexAttrib4fv(k.location, ee); break; default: n.vertexAttrib1fv(k.location, ee) } } } } b() } function R() { G(); for (const z in a) { const j = a[z]; for (const q in j) { const se = j[q]; for (const W in se) v(se[W].object), delete se[W]; delete j[q] } delete a[z] } } function P(z) { if (a[z.id] === void 0) return; const j = a[z.id]; for (const q in j) { const se = j[q]; for (const W in se) v(se[W].object), delete se[W]; delete j[q] } delete a[z.id] } function U(z) { for (const j in a) { const q = a[j]; if (q[z.id] === void 0) continue; const se = q[z.id]; for (const W in se) v(se[W].object), delete se[W]; delete q[z.id] } } function G() { $(), u = !0, c !== l && (c = l, m(c.object)) } function $() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: d, reset: G, resetDefaultState: $, dispose: R, releaseStatesOfGeometry: P, releaseStatesOfProgram: U, initAttributes: A, enableAttribute: E, disableUnusedAttributes: b } } function i8(n, e, t, r) { const i = r.isWebGL2; let o; function s(c) { o = c } function a(c, u) { n.drawArrays(o, c, u), t.update(u, o, 1) } function l(c, u, d) { if (d === 0) return; let p, m; if (i) p = n, m = "drawArraysInstanced"; else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } p[m](o, c, u, d), t.update(u, o, d) } this.setMode = s, this.render = a, this.renderInstances = l } function o8(n, e, t) { let r; function i() { if (r !== void 0) return r; if (e.has("EXT_texture_filter_anisotropic") === !0) { const T = e.get("EXT_texture_filter_anisotropic"); r = n.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r } function o(T) { if (T === "highp") { if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp"; T = "mediump" } return T === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } const s = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext"; let a = t.precision !== void 0 ? t.precision : "highp"; const l = o(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); const c = s || e.has("WEBGL_draw_buffers"), u = t.logarithmicDepthBuffer === !0, d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = n.getParameter(n.MAX_TEXTURE_SIZE), v = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), y = n.getParameter(n.MAX_VERTEX_ATTRIBS), _ = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), g = n.getParameter(n.MAX_VARYING_VECTORS), x = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), A = p > 0, E = s || e.has("OES_texture_float"), w = A && E, b = s ? n.getParameter(n.MAX_SAMPLES) : 0; return { isWebGL2: s, drawBuffers: c, getMaxAnisotropy: i, getMaxPrecision: o, precision: a, logarithmicDepthBuffer: u, maxTextures: d, maxVertexTextures: p, maxTextureSize: m, maxCubemapSize: v, maxAttributes: y, maxVertexUniforms: _, maxVaryings: g, maxFragmentUniforms: x, vertexTextures: A, floatFragmentTextures: E, floatVertexTextures: w, maxSamples: b } } function s8(n) { const e = this; let t = null, r = 0, i = !1, o = !1; const s = new oa, a = new Rt, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, p) { const m = d.length !== 0 || p || r !== 0 || i; return i = p, r = d.length, m }, this.beginShadows = function () { o = !0, u(null) }, this.endShadows = function () { o = !1 }, this.setGlobalState = function (d, p) { t = u(d, p, 0) }, this.setState = function (d, p, m) { const v = d.clippingPlanes, y = d.clipIntersection, _ = d.clipShadows, g = n.get(d); if (!i || v === null || v.length === 0 || o && !_) o ? u(null) : c(); else { const x = o ? 0 : r, A = x * 4; let E = g.clippingState || null; l.value = E, E = u(v, p, A, m); for (let w = 0; w !== A; ++w)E[w] = t[w]; g.clippingState = E, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += x } }; function c() { l.value !== t && (l.value = t, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0 } function u(d, p, m, v) { const y = d !== null ? d.length : 0; let _ = null; if (y !== 0) { if (_ = l.value, v !== !0 || _ === null) { const g = m + y * 4, x = p.matrixWorldInverse; a.getNormalMatrix(x), (_ === null || _.length < g) && (_ = new Float32Array(g)); for (let A = 0, E = m; A !== y; ++A, E += 4)s.copy(d[A]).applyMatrix4(x, a), s.normal.toArray(_, E), _[E + 3] = s.constant } l.value = _, l.needsUpdate = !0 } return e.numPlanes = y, e.numIntersection = 0, _ } } function a8(n) { let e = new WeakMap; function t(s, a) { return a === rp ? s.mapping = ya : a === ip && (s.mapping = Sl), s } function r(s) { if (s && s.isTexture && s.isRenderTargetTexture === !1) { const a = s.mapping; if (a === rp || a === ip) if (e.has(s)) { const l = e.get(s).texture; return t(l, s.mapping) } else { const l = s.image; if (l && l.height > 0) { const c = new VD(l.height / 2); return c.fromEquirectangularTexture(n, s), e.set(s, c), s.addEventListener("dispose", i), t(c.texture, s.mapping) } else return null } } return s } function i(s) { const a = s.target; a.removeEventListener("dispose", i); const l = e.get(a); l !== void 0 && (e.delete(a), l.dispose()) } function o() { e = new WeakMap } return { get: r, dispose: o } } class qi extends Np { constructor(e = -1, t = 1, r = 1, i = -1, o = .1, s = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = o, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, r, i, o, s) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let o = r - e, s = r + e, a = i + t, l = i - t; if (this.view !== null && this.view.enabled) { const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom; o += c * this.view.offsetX, s = o + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height } this.projectionMatrix.makeOrthographic(o, s, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const df = 4, f2 = [.125, .215, .35, .446, .526, .582], gc = 20, ox = new qi, d2 = new qe; let sx = null; const fc = (1 + Math.sqrt(5)) / 2, Du = 1 / fc, h2 = [new X(1, 1, 1), new X(-1, 1, 1), new X(1, 1, -1), new X(-1, 1, -1), new X(0, fc, Du), new X(0, fc, -Du), new X(Du, 0, fc), new X(-Du, 0, fc), new X(fc, Du, 0), new X(-fc, Du, 0)]; class BA { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, r = .1, i = 100) { sx = this._renderer.getRenderTarget(), this._setSize(256); const o = this._allocateTargets(); return o.depthBuffer = !0, this._sceneToCubeUV(e, r, i, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = g2(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = m2(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(sx), e.scissorTest = !1, Lg(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === ya || e.mapping === Sl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), sx = this._renderer.getRenderTarget(); const r = t || this._allocateTargets(); return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = { magFilter: fn, minFilter: fn, generateMipmaps: !1, type: Ts, format: Yr, colorSpace: Os, depthBuffer: !1 }, i = p2(e, t, r); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = p2(e, t, r); const { _lodMax: o } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = l8(o)), this._blurMaterial = c8(o, e, t) } return i } _compileMaterial(e) { const t = new In(this._lodPlanes[0], e); this._renderer.compile(t, ox) } _sceneToCubeUV(e, t, r, i) { const a = new xn(90, 1, t, r), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], u = this._renderer, d = u.autoClear, p = u.toneMapping; u.getClearColor(d2), u.toneMapping = Cs, u.autoClear = !1; const m = new hi({ name: "PMREM.Background", side: $r, depthWrite: !1, depthTest: !1 }), v = new In(new qc, m); let y = !1; const _ = e.background; _ ? _.isColor && (m.color.copy(_), e.background = null, y = !0) : (m.color.copy(d2), y = !0); for (let g = 0; g < 6; g++) { const x = g % 3; x === 0 ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0)) : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g])); const A = this._cubeSize; Lg(i, x * A, g > 2 ? A : 0, A, A), u.setRenderTarget(i), y && u.render(v, a), u.render(e, a) } v.geometry.dispose(), v.material.dispose(), u.toneMapping = p, u.autoClear = d, e.background = _ } _textureToCubeUV(e, t) { const r = this._renderer, i = e.mapping === ya || e.mapping === Sl; i ? (this._cubemapMaterial === null && (this._cubemapMaterial = g2()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = m2()); const o = i ? this._cubemapMaterial : this._equirectMaterial, s = new In(this._lodPlanes[0], o), a = o.uniforms; a.envMap.value = e; const l = this._cubeSize; Lg(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(s, ox) } _applyPMREM(e) { const t = this._renderer, r = t.autoClear; t.autoClear = !1; for (let i = 1; i < this._lodPlanes.length; i++) { const o = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), s = h2[(i - 1) % h2.length]; this._blur(e, i - 1, i, o, s) } t.autoClear = r } _blur(e, t, r, i, o) { const s = this._pingPongRenderTarget; this._halfBlur(e, s, t, r, i, "latitudinal", o), this._halfBlur(s, e, r, r, i, "longitudinal", o) } _halfBlur(e, t, r, i, o, s, a) { const l = this._renderer, c = this._blurMaterial; s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const u = 3, d = new In(this._lodPlanes[i], c), p = c.uniforms, m = this._sizeLods[r] - 1, v = isFinite(o) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * gc - 1), y = o / v, _ = isFinite(o) ? 1 + Math.floor(u * y) : gc; _ > gc && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${gc}`); const g = []; let x = 0; for (let T = 0; T < gc; ++T) { const B = T / y, R = Math.exp(-B * B / 2); g.push(R), T === 0 ? x += R : T < _ && (x += 2 * R) } for (let T = 0; T < g.length; T++)g[T] = g[T] / x; p.envMap.value = e.texture, p.samples.value = _, p.weights.value = g, p.latitudinal.value = s === "latitudinal", a && (p.poleAxis.value = a); const { _lodMax: A } = this; p.dTheta.value = v, p.mipInt.value = A - r; const E = this._sizeLods[i], w = 3 * E * (i > A - df ? i - A + df : 0), b = 4 * (this._cubeSize - E); Lg(t, w, b, 3 * E, 2 * E), l.setRenderTarget(t), l.render(d, ox) } } function l8(n) { const e = [], t = [], r = []; let i = n; const o = n - df + 1 + f2.length; for (let s = 0; s < o; s++) { const a = Math.pow(2, i); t.push(a); let l = 1 / a; s > n - df ? l = f2[s - n + df - 1] : s === 0 && (l = 0), r.push(l); const c = 1 / (a - 2), u = -c, d = 1 + c, p = [u, u, d, u, d, d, u, u, d, d, u, d], m = 6, v = 6, y = 3, _ = 2, g = 1, x = new Float32Array(y * v * m), A = new Float32Array(_ * v * m), E = new Float32Array(g * v * m); for (let b = 0; b < m; b++) { const T = b % 3 * 2 / 3 - 1, B = b > 2 ? 0 : -1, R = [T, B, 0, T + 2 / 3, B, 0, T + 2 / 3, B + 1, 0, T, B, 0, T + 2 / 3, B + 1, 0, T, B + 1, 0]; x.set(R, y * v * b), A.set(p, _ * v * b); const P = [b, b, b, b, b, b]; E.set(P, g * v * b) } const w = new bt; w.setAttribute("position", new Kt(x, y)), w.setAttribute("uv", new Kt(A, _)), w.setAttribute("faceIndex", new Kt(E, g)), e.push(w), i > df && i-- } return { lodPlanes: e, sizeLods: t, sigmas: r } } function p2(n, e, t) { const r = new Qr(n, e, t); return r.texture.mapping = sd, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r } function Lg(n, e, t, r, i) { n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i) } function c8(n, e, t) {
	const r = new Float32Array(gc), i = new X(0, 1, 0); return new _r({
		name: "SphericalGaussianBlur", defines: { n: gc, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: NM(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: bs, depthTest: !1, depthWrite: !1
	})
} function m2() {
	return new _r({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: NM(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: bs, depthTest: !1, depthWrite: !1
	})
} function g2() {
	return new _r({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: NM(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: bs, depthTest: !1, depthWrite: !1
	})
} function NM() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function u8(n) { let e = new WeakMap, t = null; function r(a) { if (a && a.isTexture) { const l = a.mapping, c = l === rp || l === ip, u = l === ya || l === Sl; if (c || u) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let d = e.get(a); return t === null && (t = new BA(n)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture } else { if (e.has(a)) return e.get(a).texture; { const d = a.image; if (c && d && d.height > 0 || u && d && i(d)) { t === null && (t = new BA(n)); const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a); return e.set(a, p), a.addEventListener("dispose", o), p.texture } else return null } } } return a } function i(a) { let l = 0; const c = 6; for (let u = 0; u < c; u++)a[u] !== void 0 && l++; return l === c } function o(a) { const l = a.target; l.removeEventListener("dispose", o); const c = e.get(l); c !== void 0 && (e.delete(l), c.dispose()) } function s() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: r, dispose: s } } function f8(n) { const e = {}; function t(r) { if (e[r] !== void 0) return e[r]; let i; switch (r) { case "WEBGL_depth_texture": i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = n.getExtension(r) }return e[r] = i, i } return { has: function (r) { return t(r) !== null }, init: function (r) { r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (r) { const i = t(r); return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i } } } function d8(n, e, t, r) { const i = {}, o = new WeakMap; function s(d) { const p = d.target; p.index !== null && e.remove(p.index); for (const v in p.attributes) e.remove(p.attributes[v]); for (const v in p.morphAttributes) { const y = p.morphAttributes[v]; for (let _ = 0, g = y.length; _ < g; _++)e.remove(y[_]) } p.removeEventListener("dispose", s), delete i[p.id]; const m = o.get(p); m && (e.remove(m), o.delete(p)), r.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries-- } function a(d, p) { return i[p.id] === !0 || (p.addEventListener("dispose", s), i[p.id] = !0, t.memory.geometries++), p } function l(d) { const p = d.attributes; for (const v in p) e.update(p[v], n.ARRAY_BUFFER); const m = d.morphAttributes; for (const v in m) { const y = m[v]; for (let _ = 0, g = y.length; _ < g; _++)e.update(y[_], n.ARRAY_BUFFER) } } function c(d) { const p = [], m = d.index, v = d.attributes.position; let y = 0; if (m !== null) { const x = m.array; y = m.version; for (let A = 0, E = x.length; A < E; A += 3) { const w = x[A + 0], b = x[A + 1], T = x[A + 2]; p.push(w, b, b, T, T, w) } } else if (v !== void 0) { const x = v.array; y = v.version; for (let A = 0, E = x.length / 3 - 1; A < E; A += 3) { const w = A + 0, b = A + 1, T = A + 2; p.push(w, b, b, T, T, w) } } else return; const _ = new (UD(p) ? kM : UM)(p, 1); _.version = y; const g = o.get(d); g && e.remove(g), o.set(d, _) } function u(d) { const p = o.get(d); if (p) { const m = d.index; m !== null && p.version < m.version && c(d) } else c(d); return o.get(d) } return { get: a, update: l, getWireframeAttribute: u } } function h8(n, e, t, r) { const i = r.isWebGL2; let o; function s(p) { o = p } let a, l; function c(p) { a = p.type, l = p.bytesPerElement } function u(p, m) { n.drawElements(o, m, a, p * l), t.update(m, o, 1) } function d(p, m, v) { if (v === 0) return; let y, _; if (i) y = n, _ = "drawElementsInstanced"; else if (y = e.get("ANGLE_instanced_arrays"), _ = "drawElementsInstancedANGLE", y === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } y[_](o, m, a, p * l, v), t.update(m, o, v) } this.setMode = s, this.setIndex = c, this.render = u, this.renderInstances = d } function p8(n) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function r(o, s, a) { switch (t.calls++, s) { case n.TRIANGLES: t.triangles += a * (o / 3); break; case n.LINES: t.lines += a * (o / 2); break; case n.LINE_STRIP: t.lines += a * (o - 1); break; case n.LINE_LOOP: t.lines += a * o; break; case n.POINTS: t.points += a * o; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", s); break } } function i() { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: i, update: r } } function m8(n, e) { return n[0] - e[0] } function g8(n, e) { return Math.abs(e[1]) - Math.abs(n[1]) } function v8(n, e, t) { const r = {}, i = new Float32Array(8), o = new WeakMap, s = new Ft, a = []; for (let c = 0; c < 8; c++)a[c] = [c, 0]; function l(c, u, d) { const p = c.morphTargetInfluences; if (e.isWebGL2 === !0) { const v = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color, y = v !== void 0 ? v.length : 0; let _ = o.get(u); if (_ === void 0 || _.count !== y) { let j = function () { $.dispose(), o.delete(u), u.removeEventListener("dispose", j) }; var m = j; _ !== void 0 && _.texture.dispose(); const A = u.morphAttributes.position !== void 0, E = u.morphAttributes.normal !== void 0, w = u.morphAttributes.color !== void 0, b = u.morphAttributes.position || [], T = u.morphAttributes.normal || [], B = u.morphAttributes.color || []; let R = 0; A === !0 && (R = 1), E === !0 && (R = 2), w === !0 && (R = 3); let P = u.attributes.position.count * R, U = 1; P > e.maxTextureSize && (U = Math.ceil(P / e.maxTextureSize), P = e.maxTextureSize); const G = new Float32Array(P * U * 4 * y), $ = new fy(G, P, U, y); $.type = As, $.needsUpdate = !0; const z = R * 4; for (let q = 0; q < y; q++) { const se = b[q], W = T[q], V = B[q], J = P * U * 4 * q; for (let O = 0; O < se.count; O++) { const k = O * z; A === !0 && (s.fromBufferAttribute(se, O), G[J + k + 0] = s.x, G[J + k + 1] = s.y, G[J + k + 2] = s.z, G[J + k + 3] = 0), E === !0 && (s.fromBufferAttribute(W, O), G[J + k + 4] = s.x, G[J + k + 5] = s.y, G[J + k + 6] = s.z, G[J + k + 7] = 0), w === !0 && (s.fromBufferAttribute(V, O), G[J + k + 8] = s.x, G[J + k + 9] = s.y, G[J + k + 10] = s.z, G[J + k + 11] = V.itemSize === 4 ? s.w : 1) } } _ = { count: y, texture: $, size: new Be(P, U) }, o.set(u, _), u.addEventListener("dispose", j) } let g = 0; for (let A = 0; A < p.length; A++)g += p[A]; const x = u.morphTargetsRelative ? 1 : 1 - g; d.getUniforms().setValue(n, "morphTargetBaseInfluence", x), d.getUniforms().setValue(n, "morphTargetInfluences", p), d.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t), d.getUniforms().setValue(n, "morphTargetsTextureSize", _.size) } else { const v = p === void 0 ? 0 : p.length; let y = r[u.id]; if (y === void 0 || y.length !== v) { y = []; for (let E = 0; E < v; E++)y[E] = [E, 0]; r[u.id] = y } for (let E = 0; E < v; E++) { const w = y[E]; w[0] = E, w[1] = p[E] } y.sort(g8); for (let E = 0; E < 8; E++)E < v && y[E][1] ? (a[E][0] = y[E][0], a[E][1] = y[E][1]) : (a[E][0] = Number.MAX_SAFE_INTEGER, a[E][1] = 0); a.sort(m8); const _ = u.morphAttributes.position, g = u.morphAttributes.normal; let x = 0; for (let E = 0; E < 8; E++) { const w = a[E], b = w[0], T = w[1]; b !== Number.MAX_SAFE_INTEGER && T ? (_ && u.getAttribute("morphTarget" + E) !== _[b] && u.setAttribute("morphTarget" + E, _[b]), g && u.getAttribute("morphNormal" + E) !== g[b] && u.setAttribute("morphNormal" + E, g[b]), i[E] = T, x += T) : (_ && u.hasAttribute("morphTarget" + E) === !0 && u.deleteAttribute("morphTarget" + E), g && u.hasAttribute("morphNormal" + E) === !0 && u.deleteAttribute("morphNormal" + E), i[E] = 0) } const A = u.morphTargetsRelative ? 1 : 1 - x; d.getUniforms().setValue(n, "morphTargetBaseInfluence", A), d.getUniforms().setValue(n, "morphTargetInfluences", i) } } return { update: l } } function y8(n, e, t, r) { let i = new WeakMap; function o(l) { const c = r.render.frame, u = l.geometry, d = e.get(l, u); if (i.get(d) !== c && (e.update(d), i.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) { const p = l.skeleton; i.get(p) !== c && (p.update(), i.set(p, c)) } return d } function s() { i = new WeakMap } function a(l) { const c = l.target; c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor) } return { update: o, dispose: s } } const jD = new An, XD = new fy, JD = new FM, KD = new zp, v2 = [], y2 = [], _2 = new Float32Array(16), x2 = new Float32Array(9), S2 = new Float32Array(4); function ad(n, e, t) { const r = n[0]; if (r <= 0 || r > 0) return n; const i = e * t; let o = v2[i]; if (o === void 0 && (o = new Float32Array(i), v2[i] = o), e !== 0) { r.toArray(o, 0); for (let s = 1, a = 0; s !== e; ++s)a += t, n[s].toArray(o, a) } return o } function ur(n, e) { if (n.length !== e.length) return !1; for (let t = 0, r = n.length; t < r; t++)if (n[t] !== e[t]) return !1; return !0 } function fr(n, e) { for (let t = 0, r = e.length; t < r; t++)n[t] = e[t] } function hy(n, e) { let t = y2[e]; t === void 0 && (t = new Int32Array(e), y2[e] = t); for (let r = 0; r !== e; ++r)t[r] = n.allocateTextureUnit(); return t } function _8(n, e) { const t = this.cache; t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e) } function x8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (ur(t, e)) return; n.uniform2fv(this.addr, e), fr(t, e) } } function S8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (ur(t, e)) return; n.uniform3fv(this.addr, e), fr(t, e) } } function A8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (ur(t, e)) return; n.uniform4fv(this.addr, e), fr(t, e) } } function E8(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (ur(t, e)) return; n.uniformMatrix2fv(this.addr, !1, e), fr(t, e) } else { if (ur(t, r)) return; S2.set(r), n.uniformMatrix2fv(this.addr, !1, S2), fr(t, r) } } function M8(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (ur(t, e)) return; n.uniformMatrix3fv(this.addr, !1, e), fr(t, e) } else { if (ur(t, r)) return; x2.set(r), n.uniformMatrix3fv(this.addr, !1, x2), fr(t, r) } } function w8(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (ur(t, e)) return; n.uniformMatrix4fv(this.addr, !1, e), fr(t, e) } else { if (ur(t, r)) return; _2.set(r), n.uniformMatrix4fv(this.addr, !1, _2), fr(t, r) } } function b8(n, e) { const t = this.cache; t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e) } function C8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (ur(t, e)) return; n.uniform2iv(this.addr, e), fr(t, e) } } function T8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (ur(t, e)) return; n.uniform3iv(this.addr, e), fr(t, e) } } function R8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (ur(t, e)) return; n.uniform4iv(this.addr, e), fr(t, e) } } function P8(n, e) { const t = this.cache; t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e) } function B8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (ur(t, e)) return; n.uniform2uiv(this.addr, e), fr(t, e) } } function I8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (ur(t, e)) return; n.uniform3uiv(this.addr, e), fr(t, e) } } function L8(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (ur(t, e)) return; n.uniform4uiv(this.addr, e), fr(t, e) } } function D8(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2D(e || jD, i) } function O8(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || JD, i) } function F8(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || KD, i) } function U8(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || XD, i) } function k8(n) { switch (n) { case 5126: return _8; case 35664: return x8; case 35665: return S8; case 35666: return A8; case 35674: return E8; case 35675: return M8; case 35676: return w8; case 5124: case 35670: return b8; case 35667: case 35671: return C8; case 35668: case 35672: return T8; case 35669: case 35673: return R8; case 5125: return P8; case 36294: return B8; case 36295: return I8; case 36296: return L8; case 35678: case 36198: case 36298: case 36306: case 35682: return D8; case 35679: case 36299: case 36307: return O8; case 35680: case 36300: case 36308: case 36293: return F8; case 36289: case 36303: case 36311: case 36292: return U8 } } function N8(n, e) { n.uniform1fv(this.addr, e) } function z8(n, e) { const t = ad(e, this.size, 2); n.uniform2fv(this.addr, t) } function G8(n, e) { const t = ad(e, this.size, 3); n.uniform3fv(this.addr, t) } function H8(n, e) { const t = ad(e, this.size, 4); n.uniform4fv(this.addr, t) } function V8(n, e) { const t = ad(e, this.size, 4); n.uniformMatrix2fv(this.addr, !1, t) } function W8(n, e) { const t = ad(e, this.size, 9); n.uniformMatrix3fv(this.addr, !1, t) } function j8(n, e) { const t = ad(e, this.size, 16); n.uniformMatrix4fv(this.addr, !1, t) } function X8(n, e) { n.uniform1iv(this.addr, e) } function J8(n, e) { n.uniform2iv(this.addr, e) } function K8(n, e) { n.uniform3iv(this.addr, e) } function Y8(n, e) { n.uniform4iv(this.addr, e) } function $8(n, e) { n.uniform1uiv(this.addr, e) } function Q8(n, e) { n.uniform2uiv(this.addr, e) } function Z8(n, e) { n.uniform3uiv(this.addr, e) } function q8(n, e) { n.uniform4uiv(this.addr, e) } function e9(n, e, t) { const r = this.cache, i = e.length, o = hy(t, i); ur(r, o) || (n.uniform1iv(this.addr, o), fr(r, o)); for (let s = 0; s !== i; ++s)t.setTexture2D(e[s] || jD, o[s]) } function t9(n, e, t) { const r = this.cache, i = e.length, o = hy(t, i); ur(r, o) || (n.uniform1iv(this.addr, o), fr(r, o)); for (let s = 0; s !== i; ++s)t.setTexture3D(e[s] || JD, o[s]) } function n9(n, e, t) { const r = this.cache, i = e.length, o = hy(t, i); ur(r, o) || (n.uniform1iv(this.addr, o), fr(r, o)); for (let s = 0; s !== i; ++s)t.setTextureCube(e[s] || KD, o[s]) } function r9(n, e, t) { const r = this.cache, i = e.length, o = hy(t, i); ur(r, o) || (n.uniform1iv(this.addr, o), fr(r, o)); for (let s = 0; s !== i; ++s)t.setTexture2DArray(e[s] || XD, o[s]) } function i9(n) { switch (n) { case 5126: return N8; case 35664: return z8; case 35665: return G8; case 35666: return H8; case 35674: return V8; case 35675: return W8; case 35676: return j8; case 5124: case 35670: return X8; case 35667: case 35671: return J8; case 35668: case 35672: return K8; case 35669: case 35673: return Y8; case 5125: return $8; case 36294: return Q8; case 36295: return Z8; case 36296: return q8; case 35678: case 36198: case 36298: case 36306: case 35682: return e9; case 35679: case 36299: case 36307: return t9; case 35680: case 36300: case 36308: case 36293: return n9; case 36289: case 36303: case 36311: case 36292: return r9 } } class o9 { constructor(e, t, r) { this.id = e, this.addr = r, this.cache = [], this.setValue = k8(t.type) } } class s9 { constructor(e, t, r) { this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = i9(t.type) } } class a9 { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, r) { const i = this.seq; for (let o = 0, s = i.length; o !== s; ++o) { const a = i[o]; a.setValue(e, t[a.id], r) } } } const ax = /(\w+)(\])?(\[|\.)?/g; function A2(n, e) { n.seq.push(e), n.map[e.id] = e } function l9(n, e, t) { const r = n.name, i = r.length; for (ax.lastIndex = 0; ;) { const o = ax.exec(r), s = ax.lastIndex; let a = o[1]; const l = o[2] === "]", c = o[3]; if (l && (a = a | 0), c === void 0 || c === "[" && s + 2 === i) { A2(t, c === void 0 ? new o9(a, n, e) : new s9(a, n, e)); break } else { let d = t.map[a]; d === void 0 && (d = new a9(a), A2(t, d)), t = d } } } class k0 { constructor(e, t) { this.seq = [], this.map = {}; const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let i = 0; i < r; ++i) { const o = e.getActiveUniform(t, i), s = e.getUniformLocation(t, o.name); l9(o, s, this) } } setValue(e, t, r, i) { const o = this.map[t]; o !== void 0 && o.setValue(e, r, i) } setOptional(e, t, r) { const i = t[r]; i !== void 0 && this.setValue(e, r, i) } static upload(e, t, r, i) { for (let o = 0, s = t.length; o !== s; ++o) { const a = t[o], l = r[a.id]; l.needsUpdate !== !1 && a.setValue(e, l.value, i) } } static seqWithValue(e, t) { const r = []; for (let i = 0, o = e.length; i !== o; ++i) { const s = e[i]; s.id in t && r.push(s) } return r } } function E2(n, e, t) { const r = n.createShader(e); return n.shaderSource(r, t), n.compileShader(r), r } let c9 = 0; function u9(n, e) {
	const t = n.split(`
`), r = [], i = Math.max(e - 6, 0), o = Math.min(e + 6, t.length); for (let s = i; s < o; s++) { const a = s + 1; r.push(`${a === e ? ">" : " "} ${a}: ${t[s]}`) } return r.join(`
`)
} function f9(n) { const e = nn.getPrimaries(nn.workingColorSpace), t = nn.getPrimaries(n); let r; switch (e === t ? r = "" : e === cp && t === lp ? r = "LinearDisplayP3ToLinearSRGB" : e === lp && t === cp && (r = "LinearSRGBToLinearDisplayP3"), n) { case Os: case Fp: return [r, "LinearTransferOETF"]; case ar: case uy: return [r, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [r, "LinearTransferOETF"] } } function M2(n, e, t) {
	const r = n.getShaderParameter(e, n.COMPILE_STATUS), i = n.getShaderInfoLog(e).trim(); if (r && i === "") return ""; const o = /ERROR: 0:(\d+)/.exec(i); if (o) {
		const s = parseInt(o[1]); return t.toUpperCase() + `

`+ i + `

`+ u9(n.getShaderSource(e), s)
	} else return i
} function d9(n, e) { const t = f9(e); return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }` } function h9(n, e) { let t; switch (e) { case lD: t = "Linear"; break; case cD: t = "Reinhard"; break; case uD: t = "OptimizedCineon"; break; case EM: t = "ACESFilmic"; break; case fD: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function p9(n) {
	return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ph).join(`
`)
} function m9(n) {
	const e = []; for (const t in n) { const r = n[t]; r !== !1 && e.push("#define " + t + " " + r) } return e.join(`
`)
} function g9(n, e) { const t = {}, r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES); for (let i = 0; i < r; i++) { const o = n.getActiveAttrib(e, i), s = o.name; let a = 1; o.type === n.FLOAT_MAT2 && (a = 2), o.type === n.FLOAT_MAT3 && (a = 3), o.type === n.FLOAT_MAT4 && (a = 4), t[s] = { type: o.type, location: n.getAttribLocation(e, s), locationSize: a } } return t } function ph(n) { return n !== "" } function w2(n, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function b2(n, e) { return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const v9 = /^[ \t]*#include +<([\w\d./]+)>/gm; function IA(n) { return n.replace(v9, _9) } const y9 = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]); function _9(n, e) { let t = Tt[e]; if (t === void 0) { const r = y9.get(e); if (r !== void 0) t = Tt[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r); else throw new Error("Can not resolve #include <" + e + ">") } return IA(t) } const x9 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function C2(n) { return n.replace(x9, S9) } function S9(n, e, t, r) { let i = ""; for (let o = parseInt(e); o < parseInt(t); o++)i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o); return i } function T2(n) {
	let e = "precision " + n.precision + ` float;
precision `+ n.precision + " int;"; return n.precision === "highp" ? e += `
#define HIGH_PRECISION`: n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function A9(n) { let e = "SHADOWMAP_TYPE_BASIC"; return n.shadowMapType === oy ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Ch ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Ho && (e = "SHADOWMAP_TYPE_VSM"), e } function E9(n) { let e = "ENVMAP_TYPE_CUBE"; if (n.envMap) switch (n.envMapMode) { case ya: case Sl: e = "ENVMAP_TYPE_CUBE"; break; case sd: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function M9(n) { let e = "ENVMAP_MODE_REFLECTION"; if (n.envMap) switch (n.envMapMode) { case Sl: e = "ENVMAP_MODE_REFRACTION"; break }return e } function w9(n) { let e = "ENVMAP_BLENDING_NONE"; if (n.envMap) switch (n.combine) { case Op: e = "ENVMAP_BLENDING_MULTIPLY"; break; case sD: e = "ENVMAP_BLENDING_MIX"; break; case aD: e = "ENVMAP_BLENDING_ADD"; break }return e } function b9(n) { const e = n.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, r = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t } } function C9(n, e, t, r) {
	const i = n.getContext(), o = t.defines; let s = t.vertexShader, a = t.fragmentShader; const l = A9(t), c = E9(t), u = M9(t), d = w9(t), p = b9(t), m = t.isWebGL2 ? "" : p9(t), v = m9(o), y = i.createProgram(); let _, g, x = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (_ = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v].filter(ph).join(`
`), _.length > 0 && (_ += `
`), g = [m, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v].filter(ph).join(`
`), g.length > 0 && (g += `
`)) : (_ = [T2(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(ph).join(`
`), g = [m, T2(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Cs ? "#define TONE_MAPPING" : "", t.toneMapping !== Cs ? Tt.tonemapping_pars_fragment : "", t.toneMapping !== Cs ? h9("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Tt.colorspace_pars_fragment, d9("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(ph).join(`
`)), s = IA(s), s = w2(s, t), s = b2(s, t), a = IA(a), a = w2(a, t), a = b2(a, t), s = C2(s), a = C2(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, _ = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ _, g = ["#define varying in", t.glslVersion === RA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === RA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ g); const A = x + _ + s, E = x + g + a, w = E2(i, i.VERTEX_SHADER, A), b = E2(i, i.FRAGMENT_SHADER, E); if (i.attachShader(y, w), i.attachShader(y, b), t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y), n.debug.checkShaderErrors) {
		const R = i.getProgramInfoLog(y).trim(), P = i.getShaderInfoLog(w).trim(), U = i.getShaderInfoLog(b).trim(); let G = !0, $ = !0; if (i.getProgramParameter(y, i.LINK_STATUS) === !1) if (G = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(i, y, w, b); else {
			const z = M2(i, w, "vertex"), j = M2(i, b, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + `

Program Info Log: `+ R + `
`+ z + `
`+ j)
		} else R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (P === "" || U === "") && ($ = !1); $ && (this.diagnostics = { runnable: G, programLog: R, vertexShader: { log: P, prefix: _ }, fragmentShader: { log: U, prefix: g } })
	} i.deleteShader(w), i.deleteShader(b); let T; this.getUniforms = function () { return T === void 0 && (T = new k0(i, y)), T }; let B; return this.getAttributes = function () { return B === void 0 && (B = g9(i, y)), B }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0 }, this.type = t.shaderType, this.name = t.shaderName, this.id = c9++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = w, this.fragmentShader = b, this
} let T9 = 0; class R9 { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), o = this._getShaderStage(r), s = this._getShaderCacheForMaterial(e); return s.has(i) === !1 && (s.add(i), i.usedTimes++), s.has(o) === !1 && (s.add(o), o.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const r of t) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let r = t.get(e); return r === void 0 && (r = new Set, t.set(e, r)), r } _getShaderStage(e) { const t = this.shaderCache; let r = t.get(e); return r === void 0 && (r = new P9(e), t.set(e, r)), r } } class P9 { constructor(e) { this.id = T9++, this.code = e, this.usedTimes = 0 } } function B9(n, e, t, r, i, o, s) { const a = new Bc, l = new R9, c = [], u = i.isWebGL2, d = i.logarithmicDepthBuffer, p = i.vertexTextures; let m = i.precision; const v = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function y(R) { return R === 0 ? "uv" : `uv${R}` } function _(R, P, U, G, $) { const z = G.fog, j = $.geometry, q = R.isMeshStandardMaterial ? G.environment : null, se = (R.isMeshStandardMaterial ? t : e).get(R.envMap || q), W = se && se.mapping === sd ? se.image.height : null, V = v[R.type]; R.precision !== null && (m = i.getMaxPrecision(R.precision), m !== R.precision && console.warn("THREE.WebGLProgram.getParameters:", R.precision, "not supported, using", m, "instead.")); const J = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color, O = J !== void 0 ? J.length : 0; let k = 0; j.morphAttributes.position !== void 0 && (k = 1), j.morphAttributes.normal !== void 0 && (k = 2), j.morphAttributes.color !== void 0 && (k = 3); let Z, ee, ne, K; if (V) { const Ct = jo[V]; Z = Ct.vertexShader, ee = Ct.fragmentShader } else Z = R.vertexShader, ee = R.fragmentShader, l.update(R), ne = l.getVertexShaderID(R), K = l.getFragmentShaderID(R); const ae = n.getRenderTarget(), ie = $.isInstancedMesh === !0, Se = !!R.map, Ce = !!R.matcap, le = !!se, F = !!R.aoMap, me = !!R.lightMap, he = !!R.bumpMap, ce = !!R.normalMap, fe = !!R.displacementMap, Re = !!R.emissiveMap, de = !!R.metalnessMap, Ie = !!R.roughnessMap, we = R.anisotropy > 0, ge = R.clearcoat > 0, Ve = R.iridescence > 0, H = R.sheen > 0, L = R.transmission > 0, oe = we && !!R.anisotropyMap, Pe = ge && !!R.clearcoatMap, Ae = ge && !!R.clearcoatNormalMap, ye = ge && !!R.clearcoatRoughnessMap, be = Ve && !!R.iridescenceMap, ke = Ve && !!R.iridescenceThicknessMap, He = H && !!R.sheenColorMap, je = H && !!R.sheenRoughnessMap, nt = !!R.specularMap, Te = !!R.specularColorMap, Je = !!R.specularIntensityMap, re = L && !!R.transmissionMap, _e = L && !!R.thicknessMap, Ne = !!R.gradientMap, Y = !!R.alphaMap, Ue = R.alphaTest > 0, Ge = !!R.alphaHash, Ke = !!R.extensions, Qe = !!j.attributes.uv1, ze = !!j.attributes.uv2, Ze = !!j.attributes.uv3; let it = Cs; return R.toneMapped && (ae === null || ae.isXRRenderTarget === !0) && (it = n.toneMapping), { isWebGL2: u, shaderID: V, shaderType: R.type, shaderName: R.name, vertexShader: Z, fragmentShader: ee, defines: R.defines, customVertexShaderID: ne, customFragmentShaderID: K, isRawShaderMaterial: R.isRawShaderMaterial === !0, glslVersion: R.glslVersion, precision: m, instancing: ie, instancingColor: ie && $.instanceColor !== null, supportsVertexTextures: p, outputColorSpace: ae === null ? n.outputColorSpace : ae.isXRRenderTarget === !0 ? ae.texture.colorSpace : Os, map: Se, matcap: Ce, envMap: le, envMapMode: le && se.mapping, envMapCubeUVHeight: W, aoMap: F, lightMap: me, bumpMap: he, normalMap: ce, displacementMap: p && fe, emissiveMap: Re, normalMapObjectSpace: ce && R.normalMapType === bD, normalMapTangentSpace: ce && R.normalMapType === Rl, metalnessMap: de, roughnessMap: Ie, anisotropy: we, anisotropyMap: oe, clearcoat: ge, clearcoatMap: Pe, clearcoatNormalMap: Ae, clearcoatRoughnessMap: ye, iridescence: Ve, iridescenceMap: be, iridescenceThicknessMap: ke, sheen: H, sheenColorMap: He, sheenRoughnessMap: je, specularMap: nt, specularColorMap: Te, specularIntensityMap: Je, transmission: L, transmissionMap: re, thicknessMap: _e, gradientMap: Ne, opaque: R.transparent === !1 && R.blending === Rc, alphaMap: Y, alphaTest: Ue, alphaHash: Ge, combine: R.combine, mapUv: Se && y(R.map.channel), aoMapUv: F && y(R.aoMap.channel), lightMapUv: me && y(R.lightMap.channel), bumpMapUv: he && y(R.bumpMap.channel), normalMapUv: ce && y(R.normalMap.channel), displacementMapUv: fe && y(R.displacementMap.channel), emissiveMapUv: Re && y(R.emissiveMap.channel), metalnessMapUv: de && y(R.metalnessMap.channel), roughnessMapUv: Ie && y(R.roughnessMap.channel), anisotropyMapUv: oe && y(R.anisotropyMap.channel), clearcoatMapUv: Pe && y(R.clearcoatMap.channel), clearcoatNormalMapUv: Ae && y(R.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ye && y(R.clearcoatRoughnessMap.channel), iridescenceMapUv: be && y(R.iridescenceMap.channel), iridescenceThicknessMapUv: ke && y(R.iridescenceThicknessMap.channel), sheenColorMapUv: He && y(R.sheenColorMap.channel), sheenRoughnessMapUv: je && y(R.sheenRoughnessMap.channel), specularMapUv: nt && y(R.specularMap.channel), specularColorMapUv: Te && y(R.specularColorMap.channel), specularIntensityMapUv: Je && y(R.specularIntensityMap.channel), transmissionMapUv: re && y(R.transmissionMap.channel), thicknessMapUv: _e && y(R.thicknessMap.channel), alphaMapUv: Y && y(R.alphaMap.channel), vertexTangents: !!j.attributes.tangent && (ce || we), vertexColors: R.vertexColors, vertexAlphas: R.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4, vertexUv1s: Qe, vertexUv2s: ze, vertexUv3s: Ze, pointsUvs: $.isPoints === !0 && !!j.attributes.uv && (Se || Y), fog: !!z, useFog: R.fog === !0, fogExp2: z && z.isFogExp2, flatShading: R.flatShading === !0, sizeAttenuation: R.sizeAttenuation === !0, logarithmicDepthBuffer: d, skinning: $.isSkinnedMesh === !0, morphTargets: j.morphAttributes.position !== void 0, morphNormals: j.morphAttributes.normal !== void 0, morphColors: j.morphAttributes.color !== void 0, morphTargetsCount: O, morphTextureStride: k, numDirLights: P.directional.length, numPointLights: P.point.length, numSpotLights: P.spot.length, numSpotLightMaps: P.spotLightMap.length, numRectAreaLights: P.rectArea.length, numHemiLights: P.hemi.length, numDirLightShadows: P.directionalShadowMap.length, numPointLightShadows: P.pointShadowMap.length, numSpotLightShadows: P.spotShadowMap.length, numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps, numLightProbes: P.numLightProbes, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: R.dithering, shadowMapEnabled: n.shadowMap.enabled && U.length > 0, shadowMapType: n.shadowMap.type, toneMapping: it, useLegacyLights: n._useLegacyLights, decodeVideoTexture: Se && R.map.isVideoTexture === !0 && nn.getTransfer(R.map.colorSpace) === hn, premultipliedAlpha: R.premultipliedAlpha, doubleSided: R.side === Ti, flipSided: R.side === $r, useDepthPacking: R.depthPacking >= 0, depthPacking: R.depthPacking || 0, index0AttributeName: R.index0AttributeName, extensionDerivatives: Ke && R.extensions.derivatives === !0, extensionFragDepth: Ke && R.extensions.fragDepth === !0, extensionDrawBuffers: Ke && R.extensions.drawBuffers === !0, extensionShaderTextureLOD: Ke && R.extensions.shaderTextureLOD === !0, rendererExtensionFragDepth: u || r.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"), customProgramCacheKey: R.customProgramCacheKey() } } function g(R) { const P = []; if (R.shaderID ? P.push(R.shaderID) : (P.push(R.customVertexShaderID), P.push(R.customFragmentShaderID)), R.defines !== void 0) for (const U in R.defines) P.push(U), P.push(R.defines[U]); return R.isRawShaderMaterial === !1 && (x(P, R), A(P, R), P.push(n.outputColorSpace)), P.push(R.customProgramCacheKey), P.join() } function x(R, P) { R.push(P.precision), R.push(P.outputColorSpace), R.push(P.envMapMode), R.push(P.envMapCubeUVHeight), R.push(P.mapUv), R.push(P.alphaMapUv), R.push(P.lightMapUv), R.push(P.aoMapUv), R.push(P.bumpMapUv), R.push(P.normalMapUv), R.push(P.displacementMapUv), R.push(P.emissiveMapUv), R.push(P.metalnessMapUv), R.push(P.roughnessMapUv), R.push(P.anisotropyMapUv), R.push(P.clearcoatMapUv), R.push(P.clearcoatNormalMapUv), R.push(P.clearcoatRoughnessMapUv), R.push(P.iridescenceMapUv), R.push(P.iridescenceThicknessMapUv), R.push(P.sheenColorMapUv), R.push(P.sheenRoughnessMapUv), R.push(P.specularMapUv), R.push(P.specularColorMapUv), R.push(P.specularIntensityMapUv), R.push(P.transmissionMapUv), R.push(P.thicknessMapUv), R.push(P.combine), R.push(P.fogExp2), R.push(P.sizeAttenuation), R.push(P.morphTargetsCount), R.push(P.morphAttributeCount), R.push(P.numDirLights), R.push(P.numPointLights), R.push(P.numSpotLights), R.push(P.numSpotLightMaps), R.push(P.numHemiLights), R.push(P.numRectAreaLights), R.push(P.numDirLightShadows), R.push(P.numPointLightShadows), R.push(P.numSpotLightShadows), R.push(P.numSpotLightShadowsWithMaps), R.push(P.numLightProbes), R.push(P.shadowMapType), R.push(P.toneMapping), R.push(P.numClippingPlanes), R.push(P.numClipIntersection), R.push(P.depthPacking) } function A(R, P) { a.disableAll(), P.isWebGL2 && a.enable(0), P.supportsVertexTextures && a.enable(1), P.instancing && a.enable(2), P.instancingColor && a.enable(3), P.matcap && a.enable(4), P.envMap && a.enable(5), P.normalMapObjectSpace && a.enable(6), P.normalMapTangentSpace && a.enable(7), P.clearcoat && a.enable(8), P.iridescence && a.enable(9), P.alphaTest && a.enable(10), P.vertexColors && a.enable(11), P.vertexAlphas && a.enable(12), P.vertexUv1s && a.enable(13), P.vertexUv2s && a.enable(14), P.vertexUv3s && a.enable(15), P.vertexTangents && a.enable(16), P.anisotropy && a.enable(17), R.push(a.mask), a.disableAll(), P.fog && a.enable(0), P.useFog && a.enable(1), P.flatShading && a.enable(2), P.logarithmicDepthBuffer && a.enable(3), P.skinning && a.enable(4), P.morphTargets && a.enable(5), P.morphNormals && a.enable(6), P.morphColors && a.enable(7), P.premultipliedAlpha && a.enable(8), P.shadowMapEnabled && a.enable(9), P.useLegacyLights && a.enable(10), P.doubleSided && a.enable(11), P.flipSided && a.enable(12), P.useDepthPacking && a.enable(13), P.dithering && a.enable(14), P.transmission && a.enable(15), P.sheen && a.enable(16), P.opaque && a.enable(17), P.pointsUvs && a.enable(18), P.decodeVideoTexture && a.enable(19), R.push(a.mask) } function E(R) { const P = v[R.type]; let U; if (P) { const G = jo[P]; U = _a.clone(G.uniforms) } else U = R.uniforms; return U } function w(R, P) { let U; for (let G = 0, $ = c.length; G < $; G++) { const z = c[G]; if (z.cacheKey === P) { U = z, ++U.usedTimes; break } } return U === void 0 && (U = new C9(n, P, R, o), c.push(U)), U } function b(R) { if (--R.usedTimes === 0) { const P = c.indexOf(R); c[P] = c[c.length - 1], c.pop(), R.destroy() } } function T(R) { l.remove(R) } function B() { l.dispose() } return { getParameters: _, getProgramCacheKey: g, getUniforms: E, acquireProgram: w, releaseProgram: b, releaseShaderCache: T, programs: c, dispose: B } } function I9() { let n = new WeakMap; function e(o) { let s = n.get(o); return s === void 0 && (s = {}, n.set(o, s)), s } function t(o) { n.delete(o) } function r(o, s, a) { n.get(o)[s] = a } function i() { n = new WeakMap } return { get: e, remove: t, update: r, dispose: i } } function L9(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id } function R2(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id } function P2() { const n = []; let e = 0; const t = [], r = [], i = []; function o() { e = 0, t.length = 0, r.length = 0, i.length = 0 } function s(d, p, m, v, y, _) { let g = n[e]; return g === void 0 ? (g = { id: d.id, object: d, geometry: p, material: m, groupOrder: v, renderOrder: d.renderOrder, z: y, group: _ }, n[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = m, g.groupOrder = v, g.renderOrder = d.renderOrder, g.z = y, g.group = _), e++, g } function a(d, p, m, v, y, _) { const g = s(d, p, m, v, y, _); m.transmission > 0 ? r.push(g) : m.transparent === !0 ? i.push(g) : t.push(g) } function l(d, p, m, v, y, _) { const g = s(d, p, m, v, y, _); m.transmission > 0 ? r.unshift(g) : m.transparent === !0 ? i.unshift(g) : t.unshift(g) } function c(d, p) { t.length > 1 && t.sort(d || L9), r.length > 1 && r.sort(p || R2), i.length > 1 && i.sort(p || R2) } function u() { for (let d = e, p = n.length; d < p; d++) { const m = n[d]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: t, transmissive: r, transparent: i, init: o, push: a, unshift: l, finish: u, sort: c } } function D9() { let n = new WeakMap; function e(r, i) { const o = n.get(r); let s; return o === void 0 ? (s = new P2, n.set(r, [s])) : i >= o.length ? (s = new P2, o.push(s)) : s = o[i], s } function t() { n = new WeakMap } return { get: e, dispose: t } } function O9() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new X, color: new qe }; break; case "SpotLight": t = { position: new X, direction: new X, color: new qe, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new X, color: new qe, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new X, skyColor: new qe, groundColor: new qe }; break; case "RectAreaLight": t = { color: new qe, position: new X, halfWidth: new X, halfHeight: new X }; break }return n[e.id] = t, t } } } function F9() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Be }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Be }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Be, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return n[e.id] = t, t } } } let U9 = 0; function k9(n, e) { return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0) } function N9(n, e) { const t = new O9, r = F9(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let u = 0; u < 9; u++)i.probe.push(new X); const o = new X, s = new _t, a = new _t; function l(u, d) { let p = 0, m = 0, v = 0; for (let G = 0; G < 9; G++)i.probe[G].set(0, 0, 0); let y = 0, _ = 0, g = 0, x = 0, A = 0, E = 0, w = 0, b = 0, T = 0, B = 0, R = 0; u.sort(k9); const P = d === !0 ? Math.PI : 1; for (let G = 0, $ = u.length; G < $; G++) { const z = u[G], j = z.color, q = z.intensity, se = z.distance, W = z.shadow && z.shadow.map ? z.shadow.map.texture : null; if (z.isAmbientLight) p += j.r * q * P, m += j.g * q * P, v += j.b * q * P; else if (z.isLightProbe) { for (let V = 0; V < 9; V++)i.probe[V].addScaledVector(z.sh.coefficients[V], q); R++ } else if (z.isDirectionalLight) { const V = t.get(z); if (V.color.copy(z.color).multiplyScalar(z.intensity * P), z.castShadow) { const J = z.shadow, O = r.get(z); O.shadowBias = J.bias, O.shadowNormalBias = J.normalBias, O.shadowRadius = J.radius, O.shadowMapSize = J.mapSize, i.directionalShadow[y] = O, i.directionalShadowMap[y] = W, i.directionalShadowMatrix[y] = z.shadow.matrix, E++ } i.directional[y] = V, y++ } else if (z.isSpotLight) { const V = t.get(z); V.position.setFromMatrixPosition(z.matrixWorld), V.color.copy(j).multiplyScalar(q * P), V.distance = se, V.coneCos = Math.cos(z.angle), V.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)), V.decay = z.decay, i.spot[g] = V; const J = z.shadow; if (z.map && (i.spotLightMap[T] = z.map, T++, J.updateMatrices(z), z.castShadow && B++), i.spotLightMatrix[g] = J.matrix, z.castShadow) { const O = r.get(z); O.shadowBias = J.bias, O.shadowNormalBias = J.normalBias, O.shadowRadius = J.radius, O.shadowMapSize = J.mapSize, i.spotShadow[g] = O, i.spotShadowMap[g] = W, b++ } g++ } else if (z.isRectAreaLight) { const V = t.get(z); V.color.copy(j).multiplyScalar(q), V.halfWidth.set(z.width * .5, 0, 0), V.halfHeight.set(0, z.height * .5, 0), i.rectArea[x] = V, x++ } else if (z.isPointLight) { const V = t.get(z); if (V.color.copy(z.color).multiplyScalar(z.intensity * P), V.distance = z.distance, V.decay = z.decay, z.castShadow) { const J = z.shadow, O = r.get(z); O.shadowBias = J.bias, O.shadowNormalBias = J.normalBias, O.shadowRadius = J.radius, O.shadowMapSize = J.mapSize, O.shadowCameraNear = J.camera.near, O.shadowCameraFar = J.camera.far, i.pointShadow[_] = O, i.pointShadowMap[_] = W, i.pointShadowMatrix[_] = z.shadow.matrix, w++ } i.point[_] = V, _++ } else if (z.isHemisphereLight) { const V = t.get(z); V.skyColor.copy(z.color).multiplyScalar(q * P), V.groundColor.copy(z.groundColor).multiplyScalar(q * P), i.hemi[A] = V, A++ } } x > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = et.LTC_FLOAT_1, i.rectAreaLTC2 = et.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = et.LTC_HALF_1, i.rectAreaLTC2 = et.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = p, i.ambient[1] = m, i.ambient[2] = v; const U = i.hash; (U.directionalLength !== y || U.pointLength !== _ || U.spotLength !== g || U.rectAreaLength !== x || U.hemiLength !== A || U.numDirectionalShadows !== E || U.numPointShadows !== w || U.numSpotShadows !== b || U.numSpotMaps !== T || U.numLightProbes !== R) && (i.directional.length = y, i.spot.length = g, i.rectArea.length = x, i.point.length = _, i.hemi.length = A, i.directionalShadow.length = E, i.directionalShadowMap.length = E, i.pointShadow.length = w, i.pointShadowMap.length = w, i.spotShadow.length = b, i.spotShadowMap.length = b, i.directionalShadowMatrix.length = E, i.pointShadowMatrix.length = w, i.spotLightMatrix.length = b + T - B, i.spotLightMap.length = T, i.numSpotLightShadowsWithMaps = B, i.numLightProbes = R, U.directionalLength = y, U.pointLength = _, U.spotLength = g, U.rectAreaLength = x, U.hemiLength = A, U.numDirectionalShadows = E, U.numPointShadows = w, U.numSpotShadows = b, U.numSpotMaps = T, U.numLightProbes = R, i.version = U9++) } function c(u, d) { let p = 0, m = 0, v = 0, y = 0, _ = 0; const g = d.matrixWorldInverse; for (let x = 0, A = u.length; x < A; x++) { const E = u[x]; if (E.isDirectionalLight) { const w = i.directional[p]; w.direction.setFromMatrixPosition(E.matrixWorld), o.setFromMatrixPosition(E.target.matrixWorld), w.direction.sub(o), w.direction.transformDirection(g), p++ } else if (E.isSpotLight) { const w = i.spot[v]; w.position.setFromMatrixPosition(E.matrixWorld), w.position.applyMatrix4(g), w.direction.setFromMatrixPosition(E.matrixWorld), o.setFromMatrixPosition(E.target.matrixWorld), w.direction.sub(o), w.direction.transformDirection(g), v++ } else if (E.isRectAreaLight) { const w = i.rectArea[y]; w.position.setFromMatrixPosition(E.matrixWorld), w.position.applyMatrix4(g), a.identity(), s.copy(E.matrixWorld), s.premultiply(g), a.extractRotation(s), w.halfWidth.set(E.width * .5, 0, 0), w.halfHeight.set(0, E.height * .5, 0), w.halfWidth.applyMatrix4(a), w.halfHeight.applyMatrix4(a), y++ } else if (E.isPointLight) { const w = i.point[m]; w.position.setFromMatrixPosition(E.matrixWorld), w.position.applyMatrix4(g), m++ } else if (E.isHemisphereLight) { const w = i.hemi[_]; w.direction.setFromMatrixPosition(E.matrixWorld), w.direction.transformDirection(g), _++ } } } return { setup: l, setupView: c, state: i } } function B2(n, e) { const t = new N9(n, e), r = [], i = []; function o() { r.length = 0, i.length = 0 } function s(d) { r.push(d) } function a(d) { i.push(d) } function l(d) { t.setup(r, d) } function c(d) { t.setupView(r, d) } return { init: o, state: { lightsArray: r, shadowsArray: i, lights: t }, setupLights: l, setupLightsView: c, pushLight: s, pushShadow: a } } function z9(n, e) { let t = new WeakMap; function r(o, s = 0) { const a = t.get(o); let l; return a === void 0 ? (l = new B2(n, e), t.set(o, [l])) : s >= a.length ? (l = new B2(n, e), a.push(l)) : l = a[s], l } function i() { t = new WeakMap } return { get: r, dispose: i } } class py extends rr { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = wD, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class my extends rr { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const G9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, H9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function V9(n, e, t) { let r = new dy; const i = new Be, o = new Be, s = new Ft, a = new py({ depthPacking: LM }), l = new my, c = {}, u = t.maxTextureSize, d = { [qo]: $r, [$r]: qo, [Ti]: Ti }, p = new _r({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Be }, radius: { value: 4 } }, vertexShader: G9, fragmentShader: H9 }), m = p.clone(); m.defines.HORIZONTAL_PASS = 1; const v = new bt; v.setAttribute("position", new Kt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const y = new In(v, p), _ = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = oy; let g = this.type; this.render = function (w, b, T) { if (_.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 || w.length === 0) return; const B = n.getRenderTarget(), R = n.getActiveCubeFace(), P = n.getActiveMipmapLevel(), U = n.state; U.setBlending(bs), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1); const G = g !== Ho && this.type === Ho, $ = g === Ho && this.type !== Ho; for (let z = 0, j = w.length; z < j; z++) { const q = w[z], se = q.shadow; if (se === void 0) { console.warn("THREE.WebGLShadowMap:", q, "has no shadow."); continue } if (se.autoUpdate === !1 && se.needsUpdate === !1) continue; i.copy(se.mapSize); const W = se.getFrameExtents(); if (i.multiply(W), o.copy(se.mapSize), (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / W.x), i.x = o.x * W.x, se.mapSize.x = o.x), i.y > u && (o.y = Math.floor(u / W.y), i.y = o.y * W.y, se.mapSize.y = o.y)), se.map === null || G === !0 || $ === !0) { const J = this.type !== Ho ? { minFilter: Gn, magFilter: Gn } : {}; se.map !== null && se.map.dispose(), se.map = new Qr(i.x, i.y, J), se.map.texture.name = q.name + ".shadowMap", se.camera.updateProjectionMatrix() } n.setRenderTarget(se.map), n.clear(); const V = se.getViewportCount(); for (let J = 0; J < V; J++) { const O = se.getViewport(J); s.set(o.x * O.x, o.y * O.y, o.x * O.z, o.y * O.w), U.viewport(s), se.updateMatrices(q, J), r = se.getFrustum(), E(b, T, se.camera, q, this.type) } se.isPointLightShadow !== !0 && this.type === Ho && x(se, T), se.needsUpdate = !1 } g = this.type, _.needsUpdate = !1, n.setRenderTarget(B, R, P) }; function x(w, b) { const T = e.update(y); p.defines.VSM_SAMPLES !== w.blurSamples && (p.defines.VSM_SAMPLES = w.blurSamples, m.defines.VSM_SAMPLES = w.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), w.mapPass === null && (w.mapPass = new Qr(i.x, i.y)), p.uniforms.shadow_pass.value = w.map.texture, p.uniforms.resolution.value = w.mapSize, p.uniforms.radius.value = w.radius, n.setRenderTarget(w.mapPass), n.clear(), n.renderBufferDirect(b, null, T, p, y, null), m.uniforms.shadow_pass.value = w.mapPass.texture, m.uniforms.resolution.value = w.mapSize, m.uniforms.radius.value = w.radius, n.setRenderTarget(w.map), n.clear(), n.renderBufferDirect(b, null, T, m, y, null) } function A(w, b, T, B) { let R = null; const P = T.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial; if (P !== void 0) R = P; else if (R = T.isPointLight === !0 ? l : a, n.localClippingEnabled && b.clipShadows === !0 && Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 || b.displacementMap && b.displacementScale !== 0 || b.alphaMap && b.alphaTest > 0 || b.map && b.alphaTest > 0) { const U = R.uuid, G = b.uuid; let $ = c[U]; $ === void 0 && ($ = {}, c[U] = $); let z = $[G]; z === void 0 && (z = R.clone(), $[G] = z), R = z } if (R.visible = b.visible, R.wireframe = b.wireframe, B === Ho ? R.side = b.shadowSide !== null ? b.shadowSide : b.side : R.side = b.shadowSide !== null ? b.shadowSide : d[b.side], R.alphaMap = b.alphaMap, R.alphaTest = b.alphaTest, R.map = b.map, R.clipShadows = b.clipShadows, R.clippingPlanes = b.clippingPlanes, R.clipIntersection = b.clipIntersection, R.displacementMap = b.displacementMap, R.displacementScale = b.displacementScale, R.displacementBias = b.displacementBias, R.wireframeLinewidth = b.wireframeLinewidth, R.linewidth = b.linewidth, T.isPointLight === !0 && R.isMeshDistanceMaterial === !0) { const U = n.properties.get(R); U.light = T } return R } function E(w, b, T, B, R) { if (w.visible === !1) return; if (w.layers.test(b.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && R === Ho) && (!w.frustumCulled || r.intersectsObject(w))) { w.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, w.matrixWorld); const G = e.update(w), $ = w.material; if (Array.isArray($)) { const z = G.groups; for (let j = 0, q = z.length; j < q; j++) { const se = z[j], W = $[se.materialIndex]; if (W && W.visible) { const V = A(w, W, B, R); n.renderBufferDirect(T, null, G, V, w, se) } } } else if ($.visible) { const z = A(w, $, B, R); n.renderBufferDirect(T, null, G, z, w, null) } } const U = w.children; for (let G = 0, $ = U.length; G < $; G++)E(U[G], b, T, B, R) } } function W9(n, e, t) { const r = t.isWebGL2; function i() { let Y = !1; const Ue = new Ft; let Ge = null; const Ke = new Ft(0, 0, 0, 0); return { setMask: function (Qe) { Ge !== Qe && !Y && (n.colorMask(Qe, Qe, Qe, Qe), Ge = Qe) }, setLocked: function (Qe) { Y = Qe }, setClear: function (Qe, ze, Ze, it, yt) { yt === !0 && (Qe *= it, ze *= it, Ze *= it), Ue.set(Qe, ze, Ze, it), Ke.equals(Ue) === !1 && (n.clearColor(Qe, ze, Ze, it), Ke.copy(Ue)) }, reset: function () { Y = !1, Ge = null, Ke.set(-1, 0, 0, 0) } } } function o() { let Y = !1, Ue = null, Ge = null, Ke = null; return { setTest: function (Qe) { Qe ? ae(n.DEPTH_TEST) : ie(n.DEPTH_TEST) }, setMask: function (Qe) { Ue !== Qe && !Y && (n.depthMask(Qe), Ue = Qe) }, setFunc: function (Qe) { if (Ge !== Qe) { switch (Qe) { case qL: n.depthFunc(n.NEVER); break; case eD: n.depthFunc(n.ALWAYS); break; case tD: n.depthFunc(n.LESS); break; case _v: n.depthFunc(n.LEQUAL); break; case nD: n.depthFunc(n.EQUAL); break; case rD: n.depthFunc(n.GEQUAL); break; case iD: n.depthFunc(n.GREATER); break; case oD: n.depthFunc(n.NOTEQUAL); break; default: n.depthFunc(n.LEQUAL) }Ge = Qe } }, setLocked: function (Qe) { Y = Qe }, setClear: function (Qe) { Ke !== Qe && (n.clearDepth(Qe), Ke = Qe) }, reset: function () { Y = !1, Ue = null, Ge = null, Ke = null } } } function s() { let Y = !1, Ue = null, Ge = null, Ke = null, Qe = null, ze = null, Ze = null, it = null, yt = null; return { setTest: function (Ct) { Y || (Ct ? ae(n.STENCIL_TEST) : ie(n.STENCIL_TEST)) }, setMask: function (Ct) { Ue !== Ct && !Y && (n.stencilMask(Ct), Ue = Ct) }, setFunc: function (Ct, At, xt) { (Ge !== Ct || Ke !== At || Qe !== xt) && (n.stencilFunc(Ct, At, xt), Ge = Ct, Ke = At, Qe = xt) }, setOp: function (Ct, At, xt) { (ze !== Ct || Ze !== At || it !== xt) && (n.stencilOp(Ct, At, xt), ze = Ct, Ze = At, it = xt) }, setLocked: function (Ct) { Y = Ct }, setClear: function (Ct) { yt !== Ct && (n.clearStencil(Ct), yt = Ct) }, reset: function () { Y = !1, Ue = null, Ge = null, Ke = null, Qe = null, ze = null, Ze = null, it = null, yt = null } } } const a = new i, l = new o, c = new s, u = new WeakMap, d = new WeakMap; let p = {}, m = {}, v = new WeakMap, y = [], _ = null, g = !1, x = null, A = null, E = null, w = null, b = null, T = null, B = null, R = !1, P = null, U = null, G = null, $ = null, z = null; const j = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let q = !1, se = 0; const W = n.getParameter(n.VERSION); W.indexOf("WebGL") !== -1 ? (se = parseFloat(/^WebGL (\d)/.exec(W)[1]), q = se >= 1) : W.indexOf("OpenGL ES") !== -1 && (se = parseFloat(/^OpenGL ES (\d)/.exec(W)[1]), q = se >= 2); let V = null, J = {}; const O = n.getParameter(n.SCISSOR_BOX), k = n.getParameter(n.VIEWPORT), Z = new Ft().fromArray(O), ee = new Ft().fromArray(k); function ne(Y, Ue, Ge, Ke) { const Qe = new Uint8Array(4), ze = n.createTexture(); n.bindTexture(Y, ze), n.texParameteri(Y, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(Y, n.TEXTURE_MAG_FILTER, n.NEAREST); for (let Ze = 0; Ze < Ge; Ze++)r && (Y === n.TEXTURE_3D || Y === n.TEXTURE_2D_ARRAY) ? n.texImage3D(Ue, 0, n.RGBA, 1, 1, Ke, 0, n.RGBA, n.UNSIGNED_BYTE, Qe) : n.texImage2D(Ue + Ze, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Qe); return ze } const K = {}; K[n.TEXTURE_2D] = ne(n.TEXTURE_2D, n.TEXTURE_2D, 1), K[n.TEXTURE_CUBE_MAP] = ne(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (K[n.TEXTURE_2D_ARRAY] = ne(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), K[n.TEXTURE_3D] = ne(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ae(n.DEPTH_TEST), l.setFunc(_v), fe(!1), Re(qS), ae(n.CULL_FACE), he(bs); function ae(Y) { p[Y] !== !0 && (n.enable(Y), p[Y] = !0) } function ie(Y) { p[Y] !== !1 && (n.disable(Y), p[Y] = !1) } function Se(Y, Ue) { return m[Y] !== Ue ? (n.bindFramebuffer(Y, Ue), m[Y] = Ue, r && (Y === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Ue), Y === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Ue)), !0) : !1 } function Ce(Y, Ue) { let Ge = y, Ke = !1; if (Y) if (Ge = v.get(Ue), Ge === void 0 && (Ge = [], v.set(Ue, Ge)), Y.isWebGLMultipleRenderTargets) { const Qe = Y.texture; if (Ge.length !== Qe.length || Ge[0] !== n.COLOR_ATTACHMENT0) { for (let ze = 0, Ze = Qe.length; ze < Ze; ze++)Ge[ze] = n.COLOR_ATTACHMENT0 + ze; Ge.length = Qe.length, Ke = !0 } } else Ge[0] !== n.COLOR_ATTACHMENT0 && (Ge[0] = n.COLOR_ATTACHMENT0, Ke = !0); else Ge[0] !== n.BACK && (Ge[0] = n.BACK, Ke = !0); Ke && (t.isWebGL2 ? n.drawBuffers(Ge) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ge)) } function le(Y) { return _ !== Y ? (n.useProgram(Y), _ = Y, !0) : !1 } const F = { [mc]: n.FUNC_ADD, [HL]: n.FUNC_SUBTRACT, [VL]: n.FUNC_REVERSE_SUBTRACT }; if (r) F[nA] = n.MIN, F[rA] = n.MAX; else { const Y = e.get("EXT_blend_minmax"); Y !== null && (F[nA] = Y.MIN_EXT, F[rA] = Y.MAX_EXT) } const me = { [WL]: n.ZERO, [jL]: n.ONE, [XL]: n.SRC_COLOR, [SM]: n.SRC_ALPHA, [ZL]: n.SRC_ALPHA_SATURATE, [$L]: n.DST_COLOR, [KL]: n.DST_ALPHA, [JL]: n.ONE_MINUS_SRC_COLOR, [AM]: n.ONE_MINUS_SRC_ALPHA, [QL]: n.ONE_MINUS_DST_COLOR, [YL]: n.ONE_MINUS_DST_ALPHA }; function he(Y, Ue, Ge, Ke, Qe, ze, Ze, it) { if (Y === bs) { g === !0 && (ie(n.BLEND), g = !1); return } if (g === !1 && (ae(n.BLEND), g = !0), Y !== GL) { if (Y !== x || it !== R) { if ((A !== mc || b !== mc) && (n.blendEquation(n.FUNC_ADD), A = mc, b = mc), it) switch (Y) { case Rc: n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA); break; case yv: n.blendFunc(n.ONE, n.ONE); break; case eA: n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE); break; case tA: n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", Y); break } else switch (Y) { case Rc: n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA); break; case yv: n.blendFunc(n.SRC_ALPHA, n.ONE); break; case eA: n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE); break; case tA: n.blendFunc(n.ZERO, n.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", Y); break }E = null, w = null, T = null, B = null, x = Y, R = it } return } Qe = Qe || Ue, ze = ze || Ge, Ze = Ze || Ke, (Ue !== A || Qe !== b) && (n.blendEquationSeparate(F[Ue], F[Qe]), A = Ue, b = Qe), (Ge !== E || Ke !== w || ze !== T || Ze !== B) && (n.blendFuncSeparate(me[Ge], me[Ke], me[ze], me[Ze]), E = Ge, w = Ke, T = ze, B = Ze), x = Y, R = !1 } function ce(Y, Ue) { Y.side === Ti ? ie(n.CULL_FACE) : ae(n.CULL_FACE); let Ge = Y.side === $r; Ue && (Ge = !Ge), fe(Ge), Y.blending === Rc && Y.transparent === !1 ? he(bs) : he(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.premultipliedAlpha), l.setFunc(Y.depthFunc), l.setTest(Y.depthTest), l.setMask(Y.depthWrite), a.setMask(Y.colorWrite); const Ke = Y.stencilWrite; c.setTest(Ke), Ke && (c.setMask(Y.stencilWriteMask), c.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask), c.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)), Ie(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits), Y.alphaToCoverage === !0 ? ae(n.SAMPLE_ALPHA_TO_COVERAGE) : ie(n.SAMPLE_ALPHA_TO_COVERAGE) } function fe(Y) { P !== Y && (Y ? n.frontFace(n.CW) : n.frontFace(n.CCW), P = Y) } function Re(Y) { Y !== kL ? (ae(n.CULL_FACE), Y !== U && (Y === qS ? n.cullFace(n.BACK) : Y === NL ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ie(n.CULL_FACE), U = Y } function de(Y) { Y !== G && (q && n.lineWidth(Y), G = Y) } function Ie(Y, Ue, Ge) { Y ? (ae(n.POLYGON_OFFSET_FILL), ($ !== Ue || z !== Ge) && (n.polygonOffset(Ue, Ge), $ = Ue, z = Ge)) : ie(n.POLYGON_OFFSET_FILL) } function we(Y) { Y ? ae(n.SCISSOR_TEST) : ie(n.SCISSOR_TEST) } function ge(Y) { Y === void 0 && (Y = n.TEXTURE0 + j - 1), V !== Y && (n.activeTexture(Y), V = Y) } function Ve(Y, Ue, Ge) { Ge === void 0 && (V === null ? Ge = n.TEXTURE0 + j - 1 : Ge = V); let Ke = J[Ge]; Ke === void 0 && (Ke = { type: void 0, texture: void 0 }, J[Ge] = Ke), (Ke.type !== Y || Ke.texture !== Ue) && (V !== Ge && (n.activeTexture(Ge), V = Ge), n.bindTexture(Y, Ue || K[Y]), Ke.type = Y, Ke.texture = Ue) } function H() { const Y = J[V]; Y !== void 0 && Y.type !== void 0 && (n.bindTexture(Y.type, null), Y.type = void 0, Y.texture = void 0) } function L() { try { n.compressedTexImage2D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function oe() { try { n.compressedTexImage3D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Pe() { try { n.texSubImage2D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Ae() { try { n.texSubImage3D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function ye() { try { n.compressedTexSubImage2D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function be() { try { n.compressedTexSubImage3D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function ke() { try { n.texStorage2D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function He() { try { n.texStorage3D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function je() { try { n.texImage2D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function nt() { try { n.texImage3D.apply(n, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Te(Y) { Z.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w), Z.copy(Y)) } function Je(Y) { ee.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w), ee.copy(Y)) } function re(Y, Ue) { let Ge = d.get(Ue); Ge === void 0 && (Ge = new WeakMap, d.set(Ue, Ge)); let Ke = Ge.get(Y); Ke === void 0 && (Ke = n.getUniformBlockIndex(Ue, Y.name), Ge.set(Y, Ke)) } function _e(Y, Ue) { const Ke = d.get(Ue).get(Y); u.get(Ue) !== Ke && (n.uniformBlockBinding(Ue, Ke, Y.__bindingPointIndex), u.set(Ue, Ke)) } function Ne() { n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), r === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), p = {}, V = null, J = {}, m = {}, v = new WeakMap, y = [], _ = null, g = !1, x = null, A = null, E = null, w = null, b = null, T = null, B = null, R = !1, P = null, U = null, G = null, $ = null, z = null, Z.set(0, 0, n.canvas.width, n.canvas.height), ee.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), c.reset() } return { buffers: { color: a, depth: l, stencil: c }, enable: ae, disable: ie, bindFramebuffer: Se, drawBuffers: Ce, useProgram: le, setBlending: he, setMaterial: ce, setFlipSided: fe, setCullFace: Re, setLineWidth: de, setPolygonOffset: Ie, setScissorTest: we, activeTexture: ge, bindTexture: Ve, unbindTexture: H, compressedTexImage2D: L, compressedTexImage3D: oe, texImage2D: je, texImage3D: nt, updateUBOMapping: re, uniformBlockBinding: _e, texStorage2D: ke, texStorage3D: He, texSubImage2D: Pe, texSubImage3D: Ae, compressedTexSubImage2D: ye, compressedTexSubImage3D: be, scissor: Te, viewport: Je, reset: Ne } } function j9(n, e, t, r, i, o, s) { const a = i.isWebGL2, l = i.maxTextures, c = i.maxCubemapSize, u = i.maxTextureSize, d = i.maxSamples, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), v = new WeakMap; let y; const _ = new WeakMap; let g = !1; try { g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function x(H, L) { return g ? new OffscreenCanvas(H, L) : dp("canvas") } function A(H, L, oe, Pe) { let Ae = 1; if ((H.width > Pe || H.height > Pe) && (Ae = Pe / Math.max(H.width, H.height)), Ae < 1 || L === !0) if (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && H instanceof ImageBitmap) { const ye = L ? Av : Math.floor, be = ye(Ae * H.width), ke = ye(Ae * H.height); y === void 0 && (y = x(be, ke)); const He = oe ? x(be, ke) : y; return He.width = be, He.height = ke, He.getContext("2d").drawImage(H, 0, 0, be, ke), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + H.width + "x" + H.height + ") to (" + be + "x" + ke + ")."), He } else return "data" in H && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + H.width + "x" + H.height + ")."), H; return H } function E(H) { return PA(H.width) && PA(H.height) } function w(H) { return a ? !1 : H.wrapS !== Rr || H.wrapT !== Rr || H.minFilter !== Gn && H.minFilter !== fn } function b(H, L) { return H.generateMipmaps && L && H.minFilter !== Gn && H.minFilter !== fn } function T(H) { n.generateMipmap(H) } function B(H, L, oe, Pe, Ae = !1) { if (a === !1) return L; if (H !== null) { if (n[H] !== void 0) return n[H]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + H + "'") } let ye = L; if (L === n.RED && (oe === n.FLOAT && (ye = n.R32F), oe === n.HALF_FLOAT && (ye = n.R16F), oe === n.UNSIGNED_BYTE && (ye = n.R8)), L === n.RED_INTEGER && (oe === n.UNSIGNED_BYTE && (ye = n.R8UI), oe === n.UNSIGNED_SHORT && (ye = n.R16UI), oe === n.UNSIGNED_INT && (ye = n.R32UI), oe === n.BYTE && (ye = n.R8I), oe === n.SHORT && (ye = n.R16I), oe === n.INT && (ye = n.R32I)), L === n.RG && (oe === n.FLOAT && (ye = n.RG32F), oe === n.HALF_FLOAT && (ye = n.RG16F), oe === n.UNSIGNED_BYTE && (ye = n.RG8)), L === n.RGBA) { const be = Ae ? ap : nn.getTransfer(Pe); oe === n.FLOAT && (ye = n.RGBA32F), oe === n.HALF_FLOAT && (ye = n.RGBA16F), oe === n.UNSIGNED_BYTE && (ye = be === hn ? n.SRGB8_ALPHA8 : n.RGBA8), oe === n.UNSIGNED_SHORT_4_4_4_4 && (ye = n.RGBA4), oe === n.UNSIGNED_SHORT_5_5_5_1 && (ye = n.RGB5_A1) } return (ye === n.R16F || ye === n.R32F || ye === n.RG16F || ye === n.RG32F || ye === n.RGBA16F || ye === n.RGBA32F) && e.get("EXT_color_buffer_float"), ye } function R(H, L, oe) { return b(H, oe) === !0 || H.isFramebufferTexture && H.minFilter !== Gn && H.minFilter !== fn ? Math.log2(Math.max(L.width, L.height)) + 1 : H.mipmaps !== void 0 && H.mipmaps.length > 0 ? H.mipmaps.length : H.isCompressedTexture && Array.isArray(H.image) ? L.mipmaps.length : 1 } function P(H) { return H === Gn || H === op || H === Mf ? n.NEAREST : n.LINEAR } function U(H) { const L = H.target; L.removeEventListener("dispose", U), $(L), L.isVideoTexture && v.delete(L) } function G(H) { const L = H.target; L.removeEventListener("dispose", G), j(L) } function $(H) { const L = r.get(H); if (L.__webglInit === void 0) return; const oe = H.source, Pe = _.get(oe); if (Pe) { const Ae = Pe[L.__cacheKey]; Ae.usedTimes--, Ae.usedTimes === 0 && z(H), Object.keys(Pe).length === 0 && _.delete(oe) } r.remove(H) } function z(H) { const L = r.get(H); n.deleteTexture(L.__webglTexture); const oe = H.source, Pe = _.get(oe); delete Pe[L.__cacheKey], s.memory.textures-- } function j(H) { const L = H.texture, oe = r.get(H), Pe = r.get(L); if (Pe.__webglTexture !== void 0 && (n.deleteTexture(Pe.__webglTexture), s.memory.textures--), H.depthTexture && H.depthTexture.dispose(), H.isWebGLCubeRenderTarget) for (let Ae = 0; Ae < 6; Ae++) { if (Array.isArray(oe.__webglFramebuffer[Ae])) for (let ye = 0; ye < oe.__webglFramebuffer[Ae].length; ye++)n.deleteFramebuffer(oe.__webglFramebuffer[Ae][ye]); else n.deleteFramebuffer(oe.__webglFramebuffer[Ae]); oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer[Ae]) } else { if (Array.isArray(oe.__webglFramebuffer)) for (let Ae = 0; Ae < oe.__webglFramebuffer.length; Ae++)n.deleteFramebuffer(oe.__webglFramebuffer[Ae]); else n.deleteFramebuffer(oe.__webglFramebuffer); if (oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer), oe.__webglMultisampledFramebuffer && n.deleteFramebuffer(oe.__webglMultisampledFramebuffer), oe.__webglColorRenderbuffer) for (let Ae = 0; Ae < oe.__webglColorRenderbuffer.length; Ae++)oe.__webglColorRenderbuffer[Ae] && n.deleteRenderbuffer(oe.__webglColorRenderbuffer[Ae]); oe.__webglDepthRenderbuffer && n.deleteRenderbuffer(oe.__webglDepthRenderbuffer) } if (H.isWebGLMultipleRenderTargets) for (let Ae = 0, ye = L.length; Ae < ye; Ae++) { const be = r.get(L[Ae]); be.__webglTexture && (n.deleteTexture(be.__webglTexture), s.memory.textures--), r.remove(L[Ae]) } r.remove(L), r.remove(H) } let q = 0; function se() { q = 0 } function W() { const H = q; return H >= l && console.warn("THREE.WebGLTextures: Trying to use " + H + " texture units while this GPU supports only " + l), q += 1, H } function V(H) { const L = []; return L.push(H.wrapS), L.push(H.wrapT), L.push(H.wrapR || 0), L.push(H.magFilter), L.push(H.minFilter), L.push(H.anisotropy), L.push(H.internalFormat), L.push(H.format), L.push(H.type), L.push(H.generateMipmaps), L.push(H.premultiplyAlpha), L.push(H.flipY), L.push(H.unpackAlignment), L.push(H.colorSpace), L.join() } function J(H, L) { const oe = r.get(H); if (H.isVideoTexture && ge(H), H.isRenderTargetTexture === !1 && H.version > 0 && oe.__version !== H.version) { const Pe = H.image; if (Pe === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Pe.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { Se(oe, H, L); return } } t.bindTexture(n.TEXTURE_2D, oe.__webglTexture, n.TEXTURE0 + L) } function O(H, L) { const oe = r.get(H); if (H.version > 0 && oe.__version !== H.version) { Se(oe, H, L); return } t.bindTexture(n.TEXTURE_2D_ARRAY, oe.__webglTexture, n.TEXTURE0 + L) } function k(H, L) { const oe = r.get(H); if (H.version > 0 && oe.__version !== H.version) { Se(oe, H, L); return } t.bindTexture(n.TEXTURE_3D, oe.__webglTexture, n.TEXTURE0 + L) } function Z(H, L) { const oe = r.get(H); if (H.version > 0 && oe.__version !== H.version) { Ce(oe, H, L); return } t.bindTexture(n.TEXTURE_CUBE_MAP, oe.__webglTexture, n.TEXTURE0 + L) } const ee = { [Al]: n.REPEAT, [Rr]: n.CLAMP_TO_EDGE, [Nf]: n.MIRRORED_REPEAT }, ne = { [Gn]: n.NEAREST, [op]: n.NEAREST_MIPMAP_NEAREST, [Mf]: n.NEAREST_MIPMAP_LINEAR, [fn]: n.LINEAR, [ay]: n.LINEAR_MIPMAP_NEAREST, [Ds]: n.LINEAR_MIPMAP_LINEAR }, K = { [TD]: n.NEVER, [OD]: n.ALWAYS, [RD]: n.LESS, [BD]: n.LEQUAL, [PD]: n.EQUAL, [DD]: n.GEQUAL, [ID]: n.GREATER, [LD]: n.NOTEQUAL }; function ae(H, L, oe) { if (oe ? (n.texParameteri(H, n.TEXTURE_WRAP_S, ee[L.wrapS]), n.texParameteri(H, n.TEXTURE_WRAP_T, ee[L.wrapT]), (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) && n.texParameteri(H, n.TEXTURE_WRAP_R, ee[L.wrapR]), n.texParameteri(H, n.TEXTURE_MAG_FILTER, ne[L.magFilter]), n.texParameteri(H, n.TEXTURE_MIN_FILTER, ne[L.minFilter])) : (n.texParameteri(H, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(H, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) && n.texParameteri(H, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (L.wrapS !== Rr || L.wrapT !== Rr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(H, n.TEXTURE_MAG_FILTER, P(L.magFilter)), n.texParameteri(H, n.TEXTURE_MIN_FILTER, P(L.minFilter)), L.minFilter !== Gn && L.minFilter !== fn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), L.compareFunction && (n.texParameteri(H, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(H, n.TEXTURE_COMPARE_FUNC, K[L.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) { const Pe = e.get("EXT_texture_filter_anisotropic"); if (L.magFilter === Gn || L.minFilter !== Mf && L.minFilter !== Ds || L.type === As && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === Ts && e.has("OES_texture_half_float_linear") === !1) return; (L.anisotropy > 1 || r.get(L).__currentAnisotropy) && (n.texParameterf(H, Pe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, i.getMaxAnisotropy())), r.get(L).__currentAnisotropy = L.anisotropy) } } function ie(H, L) { let oe = !1; H.__webglInit === void 0 && (H.__webglInit = !0, L.addEventListener("dispose", U)); const Pe = L.source; let Ae = _.get(Pe); Ae === void 0 && (Ae = {}, _.set(Pe, Ae)); const ye = V(L); if (ye !== H.__cacheKey) { Ae[ye] === void 0 && (Ae[ye] = { texture: n.createTexture(), usedTimes: 0 }, s.memory.textures++, oe = !0), Ae[ye].usedTimes++; const be = Ae[H.__cacheKey]; be !== void 0 && (Ae[H.__cacheKey].usedTimes--, be.usedTimes === 0 && z(L)), H.__cacheKey = ye, H.__webglTexture = Ae[ye].texture } return oe } function Se(H, L, oe) { let Pe = n.TEXTURE_2D; (L.isDataArrayTexture || L.isCompressedArrayTexture) && (Pe = n.TEXTURE_2D_ARRAY), L.isData3DTexture && (Pe = n.TEXTURE_3D); const Ae = ie(H, L), ye = L.source; t.bindTexture(Pe, H.__webglTexture, n.TEXTURE0 + oe); const be = r.get(ye); if (ye.version !== be.__version || Ae === !0) { t.activeTexture(n.TEXTURE0 + oe); const ke = nn.getPrimaries(nn.workingColorSpace), He = L.colorSpace === $i ? null : nn.getPrimaries(L.colorSpace), je = L.colorSpace === $i || ke === He ? n.NONE : n.BROWSER_DEFAULT_WEBGL; n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, je); const nt = w(L) && E(L.image) === !1; let Te = A(L.image, nt, !1, u); Te = Ve(L, Te); const Je = E(Te) || a, re = o.convert(L.format, L.colorSpace); let _e = o.convert(L.type), Ne = B(L.internalFormat, re, _e, L.colorSpace, L.isVideoTexture); ae(Pe, L, Je); let Y; const Ue = L.mipmaps, Ge = a && L.isVideoTexture !== !0, Ke = be.__version === void 0 || Ae === !0, Qe = R(L, Te, Je); if (L.isDepthTexture) Ne = n.DEPTH_COMPONENT, a ? L.type === As ? Ne = n.DEPTH_COMPONENT32F : L.type === ua ? Ne = n.DEPTH_COMPONENT24 : L.type === hl ? Ne = n.DEPTH24_STENCIL8 : Ne = n.DEPTH_COMPONENT16 : L.type === As && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), L.format === pl && Ne === n.DEPTH_COMPONENT && L.type !== ly && L.type !== ua && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), L.type = ua, _e = o.convert(L.type)), L.format === Gc && Ne === n.DEPTH_COMPONENT && (Ne = n.DEPTH_STENCIL, L.type !== hl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), L.type = hl, _e = o.convert(L.type))), Ke && (Ge ? t.texStorage2D(n.TEXTURE_2D, 1, Ne, Te.width, Te.height) : t.texImage2D(n.TEXTURE_2D, 0, Ne, Te.width, Te.height, 0, re, _e, null)); else if (L.isDataTexture) if (Ue.length > 0 && Je) { Ge && Ke && t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Ue[0].width, Ue[0].height); for (let ze = 0, Ze = Ue.length; ze < Ze; ze++)Y = Ue[ze], Ge ? t.texSubImage2D(n.TEXTURE_2D, ze, 0, 0, Y.width, Y.height, re, _e, Y.data) : t.texImage2D(n.TEXTURE_2D, ze, Ne, Y.width, Y.height, 0, re, _e, Y.data); L.generateMipmaps = !1 } else Ge ? (Ke && t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Te.width, Te.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Te.width, Te.height, re, _e, Te.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ne, Te.width, Te.height, 0, re, _e, Te.data); else if (L.isCompressedTexture) if (L.isCompressedArrayTexture) { Ge && Ke && t.texStorage3D(n.TEXTURE_2D_ARRAY, Qe, Ne, Ue[0].width, Ue[0].height, Te.depth); for (let ze = 0, Ze = Ue.length; ze < Ze; ze++)Y = Ue[ze], L.format !== Yr ? re !== null ? Ge ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ze, 0, 0, 0, Y.width, Y.height, Te.depth, re, Y.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ze, Ne, Y.width, Y.height, Te.depth, 0, Y.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ge ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, ze, 0, 0, 0, Y.width, Y.height, Te.depth, re, _e, Y.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ze, Ne, Y.width, Y.height, Te.depth, 0, re, _e, Y.data) } else { Ge && Ke && t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Ue[0].width, Ue[0].height); for (let ze = 0, Ze = Ue.length; ze < Ze; ze++)Y = Ue[ze], L.format !== Yr ? re !== null ? Ge ? t.compressedTexSubImage2D(n.TEXTURE_2D, ze, 0, 0, Y.width, Y.height, re, Y.data) : t.compressedTexImage2D(n.TEXTURE_2D, ze, Ne, Y.width, Y.height, 0, Y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ge ? t.texSubImage2D(n.TEXTURE_2D, ze, 0, 0, Y.width, Y.height, re, _e, Y.data) : t.texImage2D(n.TEXTURE_2D, ze, Ne, Y.width, Y.height, 0, re, _e, Y.data) } else if (L.isDataArrayTexture) Ge ? (Ke && t.texStorage3D(n.TEXTURE_2D_ARRAY, Qe, Ne, Te.width, Te.height, Te.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Te.width, Te.height, Te.depth, re, _e, Te.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ne, Te.width, Te.height, Te.depth, 0, re, _e, Te.data); else if (L.isData3DTexture) Ge ? (Ke && t.texStorage3D(n.TEXTURE_3D, Qe, Ne, Te.width, Te.height, Te.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Te.width, Te.height, Te.depth, re, _e, Te.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ne, Te.width, Te.height, Te.depth, 0, re, _e, Te.data); else if (L.isFramebufferTexture) { if (Ke) if (Ge) t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Te.width, Te.height); else { let ze = Te.width, Ze = Te.height; for (let it = 0; it < Qe; it++)t.texImage2D(n.TEXTURE_2D, it, Ne, ze, Ze, 0, re, _e, null), ze >>= 1, Ze >>= 1 } } else if (Ue.length > 0 && Je) { Ge && Ke && t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Ue[0].width, Ue[0].height); for (let ze = 0, Ze = Ue.length; ze < Ze; ze++)Y = Ue[ze], Ge ? t.texSubImage2D(n.TEXTURE_2D, ze, 0, 0, re, _e, Y) : t.texImage2D(n.TEXTURE_2D, ze, Ne, re, _e, Y); L.generateMipmaps = !1 } else Ge ? (Ke && t.texStorage2D(n.TEXTURE_2D, Qe, Ne, Te.width, Te.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, re, _e, Te)) : t.texImage2D(n.TEXTURE_2D, 0, Ne, re, _e, Te); b(L, Je) && T(Pe), be.__version = ye.version, L.onUpdate && L.onUpdate(L) } H.__version = L.version } function Ce(H, L, oe) { if (L.image.length !== 6) return; const Pe = ie(H, L), Ae = L.source; t.bindTexture(n.TEXTURE_CUBE_MAP, H.__webglTexture, n.TEXTURE0 + oe); const ye = r.get(Ae); if (Ae.version !== ye.__version || Pe === !0) { t.activeTexture(n.TEXTURE0 + oe); const be = nn.getPrimaries(nn.workingColorSpace), ke = L.colorSpace === $i ? null : nn.getPrimaries(L.colorSpace), He = L.colorSpace === $i || be === ke ? n.NONE : n.BROWSER_DEFAULT_WEBGL; n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, He); const je = L.isCompressedTexture || L.image[0].isCompressedTexture, nt = L.image[0] && L.image[0].isDataTexture, Te = []; for (let ze = 0; ze < 6; ze++)!je && !nt ? Te[ze] = A(L.image[ze], !1, !0, c) : Te[ze] = nt ? L.image[ze].image : L.image[ze], Te[ze] = Ve(L, Te[ze]); const Je = Te[0], re = E(Je) || a, _e = o.convert(L.format, L.colorSpace), Ne = o.convert(L.type), Y = B(L.internalFormat, _e, Ne, L.colorSpace), Ue = a && L.isVideoTexture !== !0, Ge = ye.__version === void 0 || Pe === !0; let Ke = R(L, Je, re); ae(n.TEXTURE_CUBE_MAP, L, re); let Qe; if (je) { Ue && Ge && t.texStorage2D(n.TEXTURE_CUBE_MAP, Ke, Y, Je.width, Je.height); for (let ze = 0; ze < 6; ze++) { Qe = Te[ze].mipmaps; for (let Ze = 0; Ze < Qe.length; Ze++) { const it = Qe[Ze]; L.format !== Yr ? _e !== null ? Ue ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze, 0, 0, it.width, it.height, _e, it.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze, Y, it.width, it.height, 0, it.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ue ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze, 0, 0, it.width, it.height, _e, Ne, it.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze, Y, it.width, it.height, 0, _e, Ne, it.data) } } } else { Qe = L.mipmaps, Ue && Ge && (Qe.length > 0 && Ke++, t.texStorage2D(n.TEXTURE_CUBE_MAP, Ke, Y, Te[0].width, Te[0].height)); for (let ze = 0; ze < 6; ze++)if (nt) { Ue ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0, 0, 0, Te[ze].width, Te[ze].height, _e, Ne, Te[ze].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0, Y, Te[ze].width, Te[ze].height, 0, _e, Ne, Te[ze].data); for (let Ze = 0; Ze < Qe.length; Ze++) { const yt = Qe[Ze].image[ze].image; Ue ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze + 1, 0, 0, yt.width, yt.height, _e, Ne, yt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze + 1, Y, yt.width, yt.height, 0, _e, Ne, yt.data) } } else { Ue ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0, 0, 0, _e, Ne, Te[ze]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0, Y, _e, Ne, Te[ze]); for (let Ze = 0; Ze < Qe.length; Ze++) { const it = Qe[Ze]; Ue ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze + 1, 0, 0, _e, Ne, it.image[ze]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Ze + 1, Y, _e, Ne, it.image[ze]) } } } b(L, re) && T(n.TEXTURE_CUBE_MAP), ye.__version = Ae.version, L.onUpdate && L.onUpdate(L) } H.__version = L.version } function le(H, L, oe, Pe, Ae, ye) { const be = o.convert(oe.format, oe.colorSpace), ke = o.convert(oe.type), He = B(oe.internalFormat, be, ke, oe.colorSpace); if (!r.get(L).__hasExternalTextures) { const nt = Math.max(1, L.width >> ye), Te = Math.max(1, L.height >> ye); Ae === n.TEXTURE_3D || Ae === n.TEXTURE_2D_ARRAY ? t.texImage3D(Ae, ye, He, nt, Te, L.depth, 0, be, ke, null) : t.texImage2D(Ae, ye, He, nt, Te, 0, be, ke, null) } t.bindFramebuffer(n.FRAMEBUFFER, H), we(L) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Pe, Ae, r.get(oe).__webglTexture, 0, Ie(L)) : (Ae === n.TEXTURE_2D || Ae >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Pe, Ae, r.get(oe).__webglTexture, ye), t.bindFramebuffer(n.FRAMEBUFFER, null) } function F(H, L, oe) { if (n.bindRenderbuffer(n.RENDERBUFFER, H), L.depthBuffer && !L.stencilBuffer) { let Pe = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16; if (oe || we(L)) { const Ae = L.depthTexture; Ae && Ae.isDepthTexture && (Ae.type === As ? Pe = n.DEPTH_COMPONENT32F : Ae.type === ua && (Pe = n.DEPTH_COMPONENT24)); const ye = Ie(L); we(L) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ye, Pe, L.width, L.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, ye, Pe, L.width, L.height) } else n.renderbufferStorage(n.RENDERBUFFER, Pe, L.width, L.height); n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, H) } else if (L.depthBuffer && L.stencilBuffer) { const Pe = Ie(L); oe && we(L) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Pe, n.DEPTH24_STENCIL8, L.width, L.height) : we(L) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Pe, n.DEPTH24_STENCIL8, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, L.width, L.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, H) } else { const Pe = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture]; for (let Ae = 0; Ae < Pe.length; Ae++) { const ye = Pe[Ae], be = o.convert(ye.format, ye.colorSpace), ke = o.convert(ye.type), He = B(ye.internalFormat, be, ke, ye.colorSpace), je = Ie(L); oe && we(L) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, je, He, L.width, L.height) : we(L) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, je, He, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, He, L.width, L.height) } } n.bindRenderbuffer(n.RENDERBUFFER, null) } function me(H, L) { if (L && L.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(n.FRAMEBUFFER, H), !(L.depthTexture && L.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!r.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width, L.depthTexture.image.height = L.height, L.depthTexture.needsUpdate = !0), J(L.depthTexture, 0); const Pe = r.get(L.depthTexture).__webglTexture, Ae = Ie(L); if (L.depthTexture.format === pl) we(L) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Pe, 0, Ae) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Pe, 0); else if (L.depthTexture.format === Gc) we(L) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Pe, 0, Ae) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Pe, 0); else throw new Error("Unknown depthTexture format") } function he(H) { const L = r.get(H), oe = H.isWebGLCubeRenderTarget === !0; if (H.depthTexture && !L.__autoAllocateDepthBuffer) { if (oe) throw new Error("target.depthTexture not supported in Cube render targets"); me(L.__webglFramebuffer, H) } else if (oe) { L.__webglDepthbuffer = []; for (let Pe = 0; Pe < 6; Pe++)t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer[Pe]), L.__webglDepthbuffer[Pe] = n.createRenderbuffer(), F(L.__webglDepthbuffer[Pe], H, !1) } else t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer), L.__webglDepthbuffer = n.createRenderbuffer(), F(L.__webglDepthbuffer, H, !1); t.bindFramebuffer(n.FRAMEBUFFER, null) } function ce(H, L, oe) { const Pe = r.get(H); L !== void 0 && le(Pe.__webglFramebuffer, H, H.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), oe !== void 0 && he(H) } function fe(H) { const L = H.texture, oe = r.get(H), Pe = r.get(L); H.addEventListener("dispose", G), H.isWebGLMultipleRenderTargets !== !0 && (Pe.__webglTexture === void 0 && (Pe.__webglTexture = n.createTexture()), Pe.__version = L.version, s.memory.textures++); const Ae = H.isWebGLCubeRenderTarget === !0, ye = H.isWebGLMultipleRenderTargets === !0, be = E(H) || a; if (Ae) { oe.__webglFramebuffer = []; for (let ke = 0; ke < 6; ke++)if (a && L.mipmaps && L.mipmaps.length > 0) { oe.__webglFramebuffer[ke] = []; for (let He = 0; He < L.mipmaps.length; He++)oe.__webglFramebuffer[ke][He] = n.createFramebuffer() } else oe.__webglFramebuffer[ke] = n.createFramebuffer() } else { if (a && L.mipmaps && L.mipmaps.length > 0) { oe.__webglFramebuffer = []; for (let ke = 0; ke < L.mipmaps.length; ke++)oe.__webglFramebuffer[ke] = n.createFramebuffer() } else oe.__webglFramebuffer = n.createFramebuffer(); if (ye) if (i.drawBuffers) { const ke = H.texture; for (let He = 0, je = ke.length; He < je; He++) { const nt = r.get(ke[He]); nt.__webglTexture === void 0 && (nt.__webglTexture = n.createTexture(), s.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && H.samples > 0 && we(H) === !1) { const ke = ye ? L : [L]; oe.__webglMultisampledFramebuffer = n.createFramebuffer(), oe.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, oe.__webglMultisampledFramebuffer); for (let He = 0; He < ke.length; He++) { const je = ke[He]; oe.__webglColorRenderbuffer[He] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, oe.__webglColorRenderbuffer[He]); const nt = o.convert(je.format, je.colorSpace), Te = o.convert(je.type), Je = B(je.internalFormat, nt, Te, je.colorSpace, H.isXRRenderTarget === !0), re = Ie(H); n.renderbufferStorageMultisample(n.RENDERBUFFER, re, Je, H.width, H.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.RENDERBUFFER, oe.__webglColorRenderbuffer[He]) } n.bindRenderbuffer(n.RENDERBUFFER, null), H.depthBuffer && (oe.__webglDepthRenderbuffer = n.createRenderbuffer(), F(oe.__webglDepthRenderbuffer, H, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null) } } if (Ae) { t.bindTexture(n.TEXTURE_CUBE_MAP, Pe.__webglTexture), ae(n.TEXTURE_CUBE_MAP, L, be); for (let ke = 0; ke < 6; ke++)if (a && L.mipmaps && L.mipmaps.length > 0) for (let He = 0; He < L.mipmaps.length; He++)le(oe.__webglFramebuffer[ke][He], H, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + ke, He); else le(oe.__webglFramebuffer[ke], H, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0); b(L, be) && T(n.TEXTURE_CUBE_MAP), t.unbindTexture() } else if (ye) { const ke = H.texture; for (let He = 0, je = ke.length; He < je; He++) { const nt = ke[He], Te = r.get(nt); t.bindTexture(n.TEXTURE_2D, Te.__webglTexture), ae(n.TEXTURE_2D, nt, be), le(oe.__webglFramebuffer, H, nt, n.COLOR_ATTACHMENT0 + He, n.TEXTURE_2D, 0), b(nt, be) && T(n.TEXTURE_2D) } t.unbindTexture() } else { let ke = n.TEXTURE_2D; if ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) && (a ? ke = H.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(ke, Pe.__webglTexture), ae(ke, L, be), a && L.mipmaps && L.mipmaps.length > 0) for (let He = 0; He < L.mipmaps.length; He++)le(oe.__webglFramebuffer[He], H, L, n.COLOR_ATTACHMENT0, ke, He); else le(oe.__webglFramebuffer, H, L, n.COLOR_ATTACHMENT0, ke, 0); b(L, be) && T(ke), t.unbindTexture() } H.depthBuffer && he(H) } function Re(H) { const L = E(H) || a, oe = H.isWebGLMultipleRenderTargets === !0 ? H.texture : [H.texture]; for (let Pe = 0, Ae = oe.length; Pe < Ae; Pe++) { const ye = oe[Pe]; if (b(ye, L)) { const be = H.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, ke = r.get(ye).__webglTexture; t.bindTexture(be, ke), T(be), t.unbindTexture() } } } function de(H) { if (a && H.samples > 0 && we(H) === !1) { const L = H.isWebGLMultipleRenderTargets ? H.texture : [H.texture], oe = H.width, Pe = H.height; let Ae = n.COLOR_BUFFER_BIT; const ye = [], be = H.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, ke = r.get(H), He = H.isWebGLMultipleRenderTargets === !0; if (He) for (let je = 0; je < L.length; je++)t.bindFramebuffer(n.FRAMEBUFFER, ke.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + je, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, ke.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + je, n.TEXTURE_2D, null, 0); t.bindFramebuffer(n.READ_FRAMEBUFFER, ke.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ke.__webglFramebuffer); for (let je = 0; je < L.length; je++) { ye.push(n.COLOR_ATTACHMENT0 + je), H.depthBuffer && ye.push(be); const nt = ke.__ignoreDepthValues !== void 0 ? ke.__ignoreDepthValues : !1; if (nt === !1 && (H.depthBuffer && (Ae |= n.DEPTH_BUFFER_BIT), H.stencilBuffer && (Ae |= n.STENCIL_BUFFER_BIT)), He && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, ke.__webglColorRenderbuffer[je]), nt === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [be]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [be])), He) { const Te = r.get(L[je]).__webglTexture; n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Te, 0) } n.blitFramebuffer(0, 0, oe, Pe, 0, 0, oe, Pe, Ae, n.NEAREST), m && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ye) } if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), He) for (let je = 0; je < L.length; je++) { t.bindFramebuffer(n.FRAMEBUFFER, ke.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + je, n.RENDERBUFFER, ke.__webglColorRenderbuffer[je]); const nt = r.get(L[je]).__webglTexture; t.bindFramebuffer(n.FRAMEBUFFER, ke.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + je, n.TEXTURE_2D, nt, 0) } t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ke.__webglMultisampledFramebuffer) } } function Ie(H) { return Math.min(d, H.samples) } function we(H) { const L = r.get(H); return a && H.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1 } function ge(H) { const L = s.render.frame; v.get(H) !== L && (v.set(H, L), H.update()) } function Ve(H, L) { const oe = H.colorSpace, Pe = H.format, Ae = H.type; return H.isCompressedTexture === !0 || H.isVideoTexture === !0 || H.format === Sv || oe !== Os && oe !== $i && (nn.getTransfer(oe) === hn ? a === !1 ? e.has("EXT_sRGB") === !0 && Pe === Yr ? (H.format = Sv, H.minFilter = fn, H.generateMipmaps = !1) : L = OM.sRGBToLinear(L) : (Pe !== Yr || Ae !== $o) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", oe)), L } this.allocateTextureUnit = W, this.resetTextureUnits = se, this.setTexture2D = J, this.setTexture2DArray = O, this.setTexture3D = k, this.setTextureCube = Z, this.rebindTextures = ce, this.setupRenderTarget = fe, this.updateRenderTargetMipmap = Re, this.updateMultisampleRenderTarget = de, this.setupDepthRenderbuffer = he, this.setupFrameBufferTexture = le, this.useMultisampledRTT = we } function YD(n, e, t) { const r = t.isWebGL2; function i(o, s = $i) { let a; const l = nn.getTransfer(s); if (o === $o) return n.UNSIGNED_BYTE; if (o === wM) return n.UNSIGNED_SHORT_4_4_4_4; if (o === bM) return n.UNSIGNED_SHORT_5_5_5_1; if (o === dD) return n.BYTE; if (o === hD) return n.SHORT; if (o === ly) return n.UNSIGNED_SHORT; if (o === MM) return n.INT; if (o === ua) return n.UNSIGNED_INT; if (o === As) return n.FLOAT; if (o === Ts) return r ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (o === pD) return n.ALPHA; if (o === Yr) return n.RGBA; if (o === mD) return n.LUMINANCE; if (o === gD) return n.LUMINANCE_ALPHA; if (o === pl) return n.DEPTH_COMPONENT; if (o === Gc) return n.DEPTH_STENCIL; if (o === Sv) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (o === vD) return n.RED; if (o === CM) return n.RED_INTEGER; if (o === yD) return n.RG; if (o === TM) return n.RG_INTEGER; if (o === RM) return n.RGBA_INTEGER; if (o === B0 || o === I0 || o === L0 || o === D0) if (l === hn) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (o === B0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (o === I0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (o === L0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (o === D0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (o === B0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (o === I0) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (o === L0) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (o === D0) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (o === iA || o === oA || o === sA || o === aA) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (o === iA) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (o === oA) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (o === sA) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (o === aA) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (o === _D) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (o === lA || o === cA) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (o === lA) return l === hn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (o === cA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (o === uA || o === fA || o === dA || o === hA || o === pA || o === mA || o === gA || o === vA || o === yA || o === _A || o === xA || o === SA || o === AA || o === EA) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (o === uA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (o === fA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (o === dA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (o === hA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (o === pA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (o === mA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (o === gA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (o === vA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (o === yA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (o === _A) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (o === xA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (o === SA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (o === AA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (o === EA) return l === hn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (o === O0 || o === MA || o === wA) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (o === O0) return l === hn ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (o === MA) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (o === wA) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } else return null; if (o === xD || o === bA || o === CA || o === TA) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) { if (o === O0) return a.COMPRESSED_RED_RGTC1_EXT; if (o === bA) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (o === CA) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (o === TA) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return o === hl ? r ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[o] !== void 0 ? n[o] : null } return { convert: i } } class $D extends xn { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class fa extends Ut { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const X9 = { type: "move" }; class lx { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new fa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new fa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new X, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new X), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new fa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new X, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new X), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const r of e.hand.values()) this._getHandJoint(t, r) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, t, r) { let i = null, o = null, s = null; const a = this._targetRay, l = this._grip, c = this._hand; if (e && t.session.visibilityState !== "visible-blurred") { if (c && e.hand) { s = !0; for (const y of e.hand.values()) { const _ = t.getJointPose(y, r), g = this._getHandJoint(c, y); _ !== null && (g.matrix.fromArray(_.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = _.radius), g.visible = _ !== null } const u = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = u.position.distanceTo(d.position), m = .02, v = .005; c.inputState.pinching && p > m + v ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && p <= m - v && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else l !== null && e.gripSpace && (o = t.getPose(e.gripSpace, r), o !== null && (l.matrix.fromArray(o.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(o.linearVelocity)) : l.hasLinearVelocity = !1, o.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(o.angularVelocity)) : l.hasAngularVelocity = !1)); a !== null && (i = t.getPose(e.targetRaySpace, r), i === null && o !== null && (i = o), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(X9))) } return a !== null && (a.visible = i !== null), l !== null && (l.visible = o !== null), c !== null && (c.visible = s !== null), this } _getHandJoint(e, t) { if (e.joints[t.jointName] === void 0) { const r = new fa; r.matrixAutoUpdate = !1, r.visible = !1, e.joints[t.jointName] = r, e.add(r) } return e.joints[t.jointName] } } class QD extends An { constructor(e, t, r, i, o, s, a, l, c, u) { if (u = u !== void 0 ? u : pl, u !== pl && u !== Gc) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); r === void 0 && u === pl && (r = ua), r === void 0 && u === Gc && (r = hl), super(null, i, o, s, a, l, u, r, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Gn, this.minFilter = l !== void 0 ? l : Gn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t } } class J9 extends Us { constructor(e, t) { super(); const r = this; let i = null, o = 1, s = null, a = "local-floor", l = 1, c = null, u = null, d = null, p = null, m = null, v = null; const y = t.getContextAttributes(); let _ = null, g = null; const x = [], A = [], E = new xn; E.layers.enable(1), E.viewport = new Ft; const w = new xn; w.layers.enable(2), w.viewport = new Ft; const b = [E, w], T = new $D; T.layers.enable(1), T.layers.enable(2); let B = null, R = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (O) { let k = x[O]; return k === void 0 && (k = new lx, x[O] = k), k.getTargetRaySpace() }, this.getControllerGrip = function (O) { let k = x[O]; return k === void 0 && (k = new lx, x[O] = k), k.getGripSpace() }, this.getHand = function (O) { let k = x[O]; return k === void 0 && (k = new lx, x[O] = k), k.getHandSpace() }; function P(O) { const k = A.indexOf(O.inputSource); if (k === -1) return; const Z = x[k]; Z !== void 0 && (Z.update(O.inputSource, O.frame, c || s), Z.dispatchEvent({ type: O.type, data: O.inputSource })) } function U() { i.removeEventListener("select", P), i.removeEventListener("selectstart", P), i.removeEventListener("selectend", P), i.removeEventListener("squeeze", P), i.removeEventListener("squeezestart", P), i.removeEventListener("squeezeend", P), i.removeEventListener("end", U), i.removeEventListener("inputsourceschange", G); for (let O = 0; O < x.length; O++) { const k = A[O]; k !== null && (A[O] = null, x[O].disconnect(k)) } B = null, R = null, e.setRenderTarget(_), m = null, p = null, d = null, i = null, g = null, J.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (O) { o = O, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (O) { a = O, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return c || s }, this.setReferenceSpace = function (O) { c = O }, this.getBaseLayer = function () { return p !== null ? p : m }, this.getBinding = function () { return d }, this.getFrame = function () { return v }, this.getSession = function () { return i }, this.setSession = async function (O) { if (i = O, i !== null) { if (_ = e.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", U), i.addEventListener("inputsourceschange", G), y.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const k = { antialias: i.renderState.layers === void 0 ? y.antialias : !0, alpha: !0, depth: y.depth, stencil: y.stencil, framebufferScaleFactor: o }; m = new XRWebGLLayer(i, t, k), i.updateRenderState({ baseLayer: m }), g = new Qr(m.framebufferWidth, m.framebufferHeight, { format: Yr, type: $o, colorSpace: e.outputColorSpace, stencilBuffer: y.stencil }) } else { let k = null, Z = null, ee = null; y.depth && (ee = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, k = y.stencil ? Gc : pl, Z = y.stencil ? hl : ua); const ne = { colorFormat: t.RGBA8, depthFormat: ee, scaleFactor: o }; d = new XRWebGLBinding(i, t), p = d.createProjectionLayer(ne), i.updateRenderState({ layers: [p] }), g = new Qr(p.textureWidth, p.textureHeight, { format: Yr, type: $o, depthTexture: new QD(p.textureWidth, p.textureHeight, Z, void 0, void 0, void 0, void 0, void 0, void 0, k), stencilBuffer: y.stencil, colorSpace: e.outputColorSpace, samples: y.antialias ? 4 : 0 }); const K = e.properties.get(g); K.__ignoreDepthValues = p.ignoreDepthValues } g.isXRRenderTarget = !0, this.setFoveation(l), c = null, s = await i.requestReferenceSpace(a), J.setContext(i), J.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (i !== null) return i.environmentBlendMode }; function G(O) { for (let k = 0; k < O.removed.length; k++) { const Z = O.removed[k], ee = A.indexOf(Z); ee >= 0 && (A[ee] = null, x[ee].disconnect(Z)) } for (let k = 0; k < O.added.length; k++) { const Z = O.added[k]; let ee = A.indexOf(Z); if (ee === -1) { for (let K = 0; K < x.length; K++)if (K >= A.length) { A.push(Z), ee = K; break } else if (A[K] === null) { A[K] = Z, ee = K; break } if (ee === -1) break } const ne = x[ee]; ne && ne.connect(Z) } } const $ = new X, z = new X; function j(O, k, Z) { $.setFromMatrixPosition(k.matrixWorld), z.setFromMatrixPosition(Z.matrixWorld); const ee = $.distanceTo(z), ne = k.projectionMatrix.elements, K = Z.projectionMatrix.elements, ae = ne[14] / (ne[10] - 1), ie = ne[14] / (ne[10] + 1), Se = (ne[9] + 1) / ne[5], Ce = (ne[9] - 1) / ne[5], le = (ne[8] - 1) / ne[0], F = (K[8] + 1) / K[0], me = ae * le, he = ae * F, ce = ee / (-le + F), fe = ce * -le; k.matrixWorld.decompose(O.position, O.quaternion, O.scale), O.translateX(fe), O.translateZ(ce), O.matrixWorld.compose(O.position, O.quaternion, O.scale), O.matrixWorldInverse.copy(O.matrixWorld).invert(); const Re = ae + ce, de = ie + ce, Ie = me - fe, we = he + (ee - fe), ge = Se * ie / de * Re, Ve = Ce * ie / de * Re; O.projectionMatrix.makePerspective(Ie, we, ge, Ve, Re, de), O.projectionMatrixInverse.copy(O.projectionMatrix).invert() } function q(O, k) { k === null ? O.matrixWorld.copy(O.matrix) : O.matrixWorld.multiplyMatrices(k.matrixWorld, O.matrix), O.matrixWorldInverse.copy(O.matrixWorld).invert() } this.updateCamera = function (O) { if (i === null) return; T.near = w.near = E.near = O.near, T.far = w.far = E.far = O.far, (B !== T.near || R !== T.far) && (i.updateRenderState({ depthNear: T.near, depthFar: T.far }), B = T.near, R = T.far); const k = O.parent, Z = T.cameras; q(T, k); for (let ee = 0; ee < Z.length; ee++)q(Z[ee], k); Z.length === 2 ? j(T, E, w) : T.projectionMatrix.copy(E.projectionMatrix), se(O, T, k) }; function se(O, k, Z) { Z === null ? O.matrix.copy(k.matrixWorld) : (O.matrix.copy(Z.matrixWorld), O.matrix.invert(), O.matrix.multiply(k.matrixWorld)), O.matrix.decompose(O.position, O.quaternion, O.scale), O.updateMatrixWorld(!0), O.projectionMatrix.copy(k.projectionMatrix), O.projectionMatrixInverse.copy(k.projectionMatrixInverse), O.isPerspectiveCamera && (O.fov = Gf * 2 * Math.atan(1 / O.projectionMatrix.elements[5]), O.zoom = 1) } this.getCamera = function () { return T }, this.getFoveation = function () { if (!(p === null && m === null)) return l }, this.setFoveation = function (O) { l = O, p !== null && (p.fixedFoveation = O), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = O) }; let W = null; function V(O, k) { if (u = k.getViewerPose(c || s), v = k, u !== null) { const Z = u.views; m !== null && (e.setRenderTargetFramebuffer(g, m.framebuffer), e.setRenderTarget(g)); let ee = !1; Z.length !== T.cameras.length && (T.cameras.length = 0, ee = !0); for (let ne = 0; ne < Z.length; ne++) { const K = Z[ne]; let ae = null; if (m !== null) ae = m.getViewport(K); else { const Se = d.getViewSubImage(p, K); ae = Se.viewport, ne === 0 && (e.setRenderTargetTextures(g, Se.colorTexture, p.ignoreDepthValues ? void 0 : Se.depthStencilTexture), e.setRenderTarget(g)) } let ie = b[ne]; ie === void 0 && (ie = new xn, ie.layers.enable(ne), ie.viewport = new Ft, b[ne] = ie), ie.matrix.fromArray(K.transform.matrix), ie.matrix.decompose(ie.position, ie.quaternion, ie.scale), ie.projectionMatrix.fromArray(K.projectionMatrix), ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert(), ie.viewport.set(ae.x, ae.y, ae.width, ae.height), ne === 0 && (T.matrix.copy(ie.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), ee === !0 && T.cameras.push(ie) } } for (let Z = 0; Z < x.length; Z++) { const ee = A[Z], ne = x[Z]; ee !== null && ne !== void 0 && ne.update(ee, k, c || s) } W && W(O, k), k.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: k }), v = null } const J = new WD; J.setAnimationLoop(V), this.setAnimationLoop = function (O) { W = O }, this.dispose = function () { } } } function K9(n, e) { function t(_, g) { _.matrixAutoUpdate === !0 && _.updateMatrix(), g.value.copy(_.matrix) } function r(_, g) { g.color.getRGB(_.fogColor.value, GD(n)), g.isFog ? (_.fogNear.value = g.near, _.fogFar.value = g.far) : g.isFogExp2 && (_.fogDensity.value = g.density) } function i(_, g, x, A, E) { g.isMeshBasicMaterial || g.isMeshLambertMaterial ? o(_, g) : g.isMeshToonMaterial ? (o(_, g), d(_, g)) : g.isMeshPhongMaterial ? (o(_, g), u(_, g)) : g.isMeshStandardMaterial ? (o(_, g), p(_, g), g.isMeshPhysicalMaterial && m(_, g, E)) : g.isMeshMatcapMaterial ? (o(_, g), v(_, g)) : g.isMeshDepthMaterial ? o(_, g) : g.isMeshDistanceMaterial ? (o(_, g), y(_, g)) : g.isMeshNormalMaterial ? o(_, g) : g.isLineBasicMaterial ? (s(_, g), g.isLineDashedMaterial && a(_, g)) : g.isPointsMaterial ? l(_, g, x, A) : g.isSpriteMaterial ? c(_, g) : g.isShadowMaterial ? (_.color.value.copy(g.color), _.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1) } function o(_, g) { _.opacity.value = g.opacity, g.color && _.diffuse.value.copy(g.color), g.emissive && _.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (_.map.value = g.map, t(g.map, _.mapTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, t(g.alphaMap, _.alphaMapTransform)), g.bumpMap && (_.bumpMap.value = g.bumpMap, t(g.bumpMap, _.bumpMapTransform), _.bumpScale.value = g.bumpScale, g.side === $r && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, t(g.normalMap, _.normalMapTransform), _.normalScale.value.copy(g.normalScale), g.side === $r && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, t(g.displacementMap, _.displacementMapTransform), _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap, t(g.emissiveMap, _.emissiveMapTransform)), g.specularMap && (_.specularMap.value = g.specularMap, t(g.specularMap, _.specularMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest); const x = e.get(g).envMap; if (x && (_.envMap.value = x, _.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, _.reflectivity.value = g.reflectivity, _.ior.value = g.ior, _.refractionRatio.value = g.refractionRatio), g.lightMap) { _.lightMap.value = g.lightMap; const A = n._useLegacyLights === !0 ? Math.PI : 1; _.lightMapIntensity.value = g.lightMapIntensity * A, t(g.lightMap, _.lightMapTransform) } g.aoMap && (_.aoMap.value = g.aoMap, _.aoMapIntensity.value = g.aoMapIntensity, t(g.aoMap, _.aoMapTransform)) } function s(_, g) { _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, g.map && (_.map.value = g.map, t(g.map, _.mapTransform)) } function a(_, g) { _.dashSize.value = g.dashSize, _.totalSize.value = g.dashSize + g.gapSize, _.scale.value = g.scale } function l(_, g, x, A) { _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.size.value = g.size * x, _.scale.value = A * .5, g.map && (_.map.value = g.map, t(g.map, _.uvTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, t(g.alphaMap, _.alphaMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest) } function c(_, g) { _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.rotation.value = g.rotation, g.map && (_.map.value = g.map, t(g.map, _.mapTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, t(g.alphaMap, _.alphaMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest) } function u(_, g) { _.specular.value.copy(g.specular), _.shininess.value = Math.max(g.shininess, 1e-4) } function d(_, g) { g.gradientMap && (_.gradientMap.value = g.gradientMap) } function p(_, g) { _.metalness.value = g.metalness, g.metalnessMap && (_.metalnessMap.value = g.metalnessMap, t(g.metalnessMap, _.metalnessMapTransform)), _.roughness.value = g.roughness, g.roughnessMap && (_.roughnessMap.value = g.roughnessMap, t(g.roughnessMap, _.roughnessMapTransform)), e.get(g).envMap && (_.envMapIntensity.value = g.envMapIntensity) } function m(_, g, x) { _.ior.value = g.ior, g.sheen > 0 && (_.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), _.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (_.sheenColorMap.value = g.sheenColorMap, t(g.sheenColorMap, _.sheenColorMapTransform)), g.sheenRoughnessMap && (_.sheenRoughnessMap.value = g.sheenRoughnessMap, t(g.sheenRoughnessMap, _.sheenRoughnessMapTransform))), g.clearcoat > 0 && (_.clearcoat.value = g.clearcoat, _.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (_.clearcoatMap.value = g.clearcoatMap, t(g.clearcoatMap, _.clearcoatMapTransform)), g.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, t(g.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (_.clearcoatNormalMap.value = g.clearcoatNormalMap, t(g.clearcoatNormalMap, _.clearcoatNormalMapTransform), _.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === $r && _.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (_.iridescence.value = g.iridescence, _.iridescenceIOR.value = g.iridescenceIOR, _.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (_.iridescenceMap.value = g.iridescenceMap, t(g.iridescenceMap, _.iridescenceMapTransform)), g.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = g.iridescenceThicknessMap, t(g.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))), g.transmission > 0 && (_.transmission.value = g.transmission, _.transmissionSamplerMap.value = x.texture, _.transmissionSamplerSize.value.set(x.width, x.height), g.transmissionMap && (_.transmissionMap.value = g.transmissionMap, t(g.transmissionMap, _.transmissionMapTransform)), _.thickness.value = g.thickness, g.thicknessMap && (_.thicknessMap.value = g.thicknessMap, t(g.thicknessMap, _.thicknessMapTransform)), _.attenuationDistance.value = g.attenuationDistance, _.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (_.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (_.anisotropyMap.value = g.anisotropyMap, t(g.anisotropyMap, _.anisotropyMapTransform))), _.specularIntensity.value = g.specularIntensity, _.specularColor.value.copy(g.specularColor), g.specularColorMap && (_.specularColorMap.value = g.specularColorMap, t(g.specularColorMap, _.specularColorMapTransform)), g.specularIntensityMap && (_.specularIntensityMap.value = g.specularIntensityMap, t(g.specularIntensityMap, _.specularIntensityMapTransform)) } function v(_, g) { g.matcap && (_.matcap.value = g.matcap) } function y(_, g) { const x = e.get(g).light; _.referencePosition.value.setFromMatrixPosition(x.matrixWorld), _.nearDistance.value = x.shadow.camera.near, _.farDistance.value = x.shadow.camera.far } return { refreshFogUniforms: r, refreshMaterialUniforms: i } } function Y9(n, e, t, r) { let i = {}, o = {}, s = []; const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0; function l(x, A) { const E = A.program; r.uniformBlockBinding(x, E) } function c(x, A) { let E = i[x.id]; E === void 0 && (v(x), E = u(x), i[x.id] = E, x.addEventListener("dispose", _)); const w = A.program; r.updateUBOMapping(x, w); const b = e.render.frame; o[x.id] !== b && (p(x), o[x.id] = b) } function u(x) { const A = d(); x.__bindingPointIndex = A; const E = n.createBuffer(), w = x.__size, b = x.usage; return n.bindBuffer(n.UNIFORM_BUFFER, E), n.bufferData(n.UNIFORM_BUFFER, w, b), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, A, E), E } function d() { for (let x = 0; x < a; x++)if (s.indexOf(x) === -1) return s.push(x), x; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function p(x) { const A = i[x.id], E = x.uniforms, w = x.__cache; n.bindBuffer(n.UNIFORM_BUFFER, A); for (let b = 0, T = E.length; b < T; b++) { const B = E[b]; if (m(B, b, w) === !0) { const R = B.__offset, P = Array.isArray(B.value) ? B.value : [B.value]; let U = 0; for (let G = 0; G < P.length; G++) { const $ = P[G], z = y($); typeof $ == "number" ? (B.__data[0] = $, n.bufferSubData(n.UNIFORM_BUFFER, R + U, B.__data)) : $.isMatrix3 ? (B.__data[0] = $.elements[0], B.__data[1] = $.elements[1], B.__data[2] = $.elements[2], B.__data[3] = $.elements[0], B.__data[4] = $.elements[3], B.__data[5] = $.elements[4], B.__data[6] = $.elements[5], B.__data[7] = $.elements[0], B.__data[8] = $.elements[6], B.__data[9] = $.elements[7], B.__data[10] = $.elements[8], B.__data[11] = $.elements[0]) : ($.toArray(B.__data, U), U += z.storage / Float32Array.BYTES_PER_ELEMENT) } n.bufferSubData(n.UNIFORM_BUFFER, R, B.__data) } } n.bindBuffer(n.UNIFORM_BUFFER, null) } function m(x, A, E) { const w = x.value; if (E[A] === void 0) { if (typeof w == "number") E[A] = w; else { const b = Array.isArray(w) ? w : [w], T = []; for (let B = 0; B < b.length; B++)T.push(b[B].clone()); E[A] = T } return !0 } else if (typeof w == "number") { if (E[A] !== w) return E[A] = w, !0 } else { const b = Array.isArray(E[A]) ? E[A] : [E[A]], T = Array.isArray(w) ? w : [w]; for (let B = 0; B < b.length; B++) { const R = b[B]; if (R.equals(T[B]) === !1) return R.copy(T[B]), !0 } } return !1 } function v(x) { const A = x.uniforms; let E = 0; const w = 16; let b = 0; for (let T = 0, B = A.length; T < B; T++) { const R = A[T], P = { boundary: 0, storage: 0 }, U = Array.isArray(R.value) ? R.value : [R.value]; for (let G = 0, $ = U.length; G < $; G++) { const z = U[G], j = y(z); P.boundary += j.boundary, P.storage += j.storage } if (R.__data = new Float32Array(P.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = E, T > 0) { b = E % w; const G = w - b; b !== 0 && G - P.boundary < 0 && (E += w - b, R.__offset = E) } E += P.storage } return b = E % w, b > 0 && (E += w - b), x.__size = E, x.__cache = {}, this } function y(x) { const A = { boundary: 0, storage: 0 }; return typeof x == "number" ? (A.boundary = 4, A.storage = 4) : x.isVector2 ? (A.boundary = 8, A.storage = 8) : x.isVector3 || x.isColor ? (A.boundary = 16, A.storage = 12) : x.isVector4 ? (A.boundary = 16, A.storage = 16) : x.isMatrix3 ? (A.boundary = 48, A.storage = 48) : x.isMatrix4 ? (A.boundary = 64, A.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), A } function _(x) { const A = x.target; A.removeEventListener("dispose", _); const E = s.indexOf(A.__bindingPointIndex); s.splice(E, 1), n.deleteBuffer(i[A.id]), delete i[A.id], delete o[A.id] } function g() { for (const x in i) n.deleteBuffer(i[x]); s = [], i = {}, o = {} } return { bind: l, update: c, dispose: g } } class zM { constructor(e = {}) { const { canvas: t = kD(), context: r = null, depth: i = !0, stencil: o = !0, alpha: s = !1, antialias: a = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: c = !1, powerPreference: u = "default", failIfMajorPerformanceCaveat: d = !1 } = e; this.isWebGLRenderer = !0; let p; r !== null ? p = r.getContextAttributes().alpha : p = s; const m = new Uint32Array(4), v = new Int32Array(4); let y = null, _ = null; const g = [], x = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = ar, this._useLegacyLights = !1, this.toneMapping = Cs, this.toneMappingExposure = 1; const A = this; let E = !1, w = 0, b = 0, T = null, B = -1, R = null; const P = new Ft, U = new Ft; let G = null; const $ = new qe(0); let z = 0, j = t.width, q = t.height, se = 1, W = null, V = null; const J = new Ft(0, 0, j, q), O = new Ft(0, 0, j, q); let k = !1; const Z = new dy; let ee = !1, ne = !1, K = null; const ae = new _t, ie = new Be, Se = new X, Ce = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function le() { return T === null ? se : 1 } let F = r; function me(Q, ve) { for (let De = 0; De < Q.length; De++) { const xe = Q[De], Oe = t.getContext(xe, ve); if (Oe !== null) return Oe } return null } try { const Q = { alpha: !0, depth: i, stencil: o, antialias: a, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: u, failIfMajorPerformanceCaveat: d }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Qc}`), t.addEventListener("webglcontextlost", Ue, !1), t.addEventListener("webglcontextrestored", Ge, !1), t.addEventListener("webglcontextcreationerror", Ke, !1), F === null) { const ve = ["webgl2", "webgl", "experimental-webgl"]; if (A.isWebGL1Renderer === !0 && ve.shift(), F = me(ve, Q), F === null) throw me(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } typeof WebGLRenderingContext < "u" && F instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), F.getShaderPrecisionFormat === void 0 && (F.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (Q) { throw console.error("THREE.WebGLRenderer: " + Q.message), Q } let he, ce, fe, Re, de, Ie, we, ge, Ve, H, L, oe, Pe, Ae, ye, be, ke, He, je, nt, Te, Je, re, _e; function Ne() { he = new f8(F), ce = new o8(F, he, e), he.init(ce), Je = new YD(F, he, ce), fe = new W9(F, he, ce), Re = new p8(F), de = new I9, Ie = new j9(F, he, fe, de, ce, Je, Re), we = new a8(A), ge = new u8(A), Ve = new Mz(F, ce), re = new r8(F, he, Ve, ce), H = new d8(F, Ve, Re, re), L = new y8(F, H, Ve, Re), je = new v8(F, ce, Ie), be = new s8(de), oe = new B9(A, we, ge, he, ce, re, be), Pe = new K9(A, de), Ae = new D9, ye = new z9(he, ce), He = new n8(A, we, ge, fe, L, p, l), ke = new V9(A, L, ce), _e = new Y9(F, Re, ce, fe), nt = new i8(F, he, Re, ce), Te = new h8(F, he, Re, ce), Re.programs = oe.programs, A.capabilities = ce, A.extensions = he, A.properties = de, A.renderLists = Ae, A.shadowMap = ke, A.state = fe, A.info = Re } Ne(); const Y = new J9(A, F); this.xr = Y, this.getContext = function () { return F }, this.getContextAttributes = function () { return F.getContextAttributes() }, this.forceContextLoss = function () { const Q = he.get("WEBGL_lose_context"); Q && Q.loseContext() }, this.forceContextRestore = function () { const Q = he.get("WEBGL_lose_context"); Q && Q.restoreContext() }, this.getPixelRatio = function () { return se }, this.setPixelRatio = function (Q) { Q !== void 0 && (se = Q, this.setSize(j, q, !1)) }, this.getSize = function (Q) { return Q.set(j, q) }, this.setSize = function (Q, ve, De = !0) { if (Y.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } j = Q, q = ve, t.width = Math.floor(Q * se), t.height = Math.floor(ve * se), De === !0 && (t.style.width = Q + "px", t.style.height = ve + "px"), this.setViewport(0, 0, Q, ve) }, this.getDrawingBufferSize = function (Q) { return Q.set(j * se, q * se).floor() }, this.setDrawingBufferSize = function (Q, ve, De) { j = Q, q = ve, se = De, t.width = Math.floor(Q * De), t.height = Math.floor(ve * De), this.setViewport(0, 0, Q, ve) }, this.getCurrentViewport = function (Q) { return Q.copy(P) }, this.getViewport = function (Q) { return Q.copy(J) }, this.setViewport = function (Q, ve, De, xe) { Q.isVector4 ? J.set(Q.x, Q.y, Q.z, Q.w) : J.set(Q, ve, De, xe), fe.viewport(P.copy(J).multiplyScalar(se).floor()) }, this.getScissor = function (Q) { return Q.copy(O) }, this.setScissor = function (Q, ve, De, xe) { Q.isVector4 ? O.set(Q.x, Q.y, Q.z, Q.w) : O.set(Q, ve, De, xe), fe.scissor(U.copy(O).multiplyScalar(se).floor()) }, this.getScissorTest = function () { return k }, this.setScissorTest = function (Q) { fe.setScissorTest(k = Q) }, this.setOpaqueSort = function (Q) { W = Q }, this.setTransparentSort = function (Q) { V = Q }, this.getClearColor = function (Q) { return Q.copy(He.getClearColor()) }, this.setClearColor = function () { He.setClearColor.apply(He, arguments) }, this.getClearAlpha = function () { return He.getClearAlpha() }, this.setClearAlpha = function () { He.setClearAlpha.apply(He, arguments) }, this.clear = function (Q = !0, ve = !0, De = !0) { let xe = 0; if (Q) { let Oe = !1; if (T !== null) { const ot = T.texture.format; Oe = ot === RM || ot === TM || ot === CM } if (Oe) { const ot = T.texture.type, dt = ot === $o || ot === ua || ot === ly || ot === hl || ot === wM || ot === bM, Ye = He.getClearColor(), lt = He.getClearAlpha(), Et = Ye.r, We = Ye.g, pt = Ye.b; dt ? (m[0] = Et, m[1] = We, m[2] = pt, m[3] = lt, F.clearBufferuiv(F.COLOR, 0, m)) : (v[0] = Et, v[1] = We, v[2] = pt, v[3] = lt, F.clearBufferiv(F.COLOR, 0, v)) } else xe |= F.COLOR_BUFFER_BIT } ve && (xe |= F.DEPTH_BUFFER_BIT), De && (xe |= F.STENCIL_BUFFER_BIT), F.clear(xe) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Ue, !1), t.removeEventListener("webglcontextrestored", Ge, !1), t.removeEventListener("webglcontextcreationerror", Ke, !1), Ae.dispose(), ye.dispose(), de.dispose(), we.dispose(), ge.dispose(), L.dispose(), re.dispose(), _e.dispose(), oe.dispose(), Y.dispose(), Y.removeEventListener("sessionstart", Ct), Y.removeEventListener("sessionend", At), K && (K.dispose(), K = null), xt.stop() }; function Ue(Q) { Q.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), E = !0 } function Ge() { console.log("THREE.WebGLRenderer: Context Restored."), E = !1; const Q = Re.autoReset, ve = ke.enabled, De = ke.autoUpdate, xe = ke.needsUpdate, Oe = ke.type; Ne(), Re.autoReset = Q, ke.enabled = ve, ke.autoUpdate = De, ke.needsUpdate = xe, ke.type = Oe } function Ke(Q) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Q.statusMessage) } function Qe(Q) { const ve = Q.target; ve.removeEventListener("dispose", Qe), ze(ve) } function ze(Q) { Ze(Q), de.remove(Q) } function Ze(Q) { const ve = de.get(Q).programs; ve !== void 0 && (ve.forEach(function (De) { oe.releaseProgram(De) }), Q.isShaderMaterial && oe.releaseShaderCache(Q)) } this.renderBufferDirect = function (Q, ve, De, xe, Oe, ot) { ve === null && (ve = Ce); const dt = Oe.isMesh && Oe.matrixWorld.determinant() < 0, Ye = gn(Q, ve, De, xe, Oe); fe.setMaterial(xe, dt); let lt = De.index, Et = 1; if (xe.wireframe === !0) { if (lt = H.getWireframeAttribute(De), lt === void 0) return; Et = 2 } const We = De.drawRange, pt = De.attributes.position; let ln = We.start * Et, jt = (We.start + We.count) * Et; ot !== null && (ln = Math.max(ln, ot.start * Et), jt = Math.min(jt, (ot.start + ot.count) * Et)), lt !== null ? (ln = Math.max(ln, 0), jt = Math.min(jt, lt.count)) : pt != null && (ln = Math.max(ln, 0), jt = Math.min(jt, pt.count)); const ir = jt - ln; if (ir < 0 || ir === 1 / 0) return; re.setup(Oe, xe, Ye, De, lt); let Or, Yt = nt; if (lt !== null && (Or = Ve.get(lt), Yt = Te, Yt.setIndex(Or)), Oe.isMesh) xe.wireframe === !0 ? (fe.setLineWidth(xe.wireframeLinewidth * le()), Yt.setMode(F.LINES)) : Yt.setMode(F.TRIANGLES); else if (Oe.isLine) { let gt = xe.linewidth; gt === void 0 && (gt = 1), fe.setLineWidth(gt * le()), Oe.isLineSegments ? Yt.setMode(F.LINES) : Oe.isLineLoop ? Yt.setMode(F.LINE_LOOP) : Yt.setMode(F.LINE_STRIP) } else Oe.isPoints ? Yt.setMode(F.POINTS) : Oe.isSprite && Yt.setMode(F.TRIANGLES); if (Oe.isInstancedMesh) Yt.renderInstances(ln, ir, Oe.count); else if (De.isInstancedBufferGeometry) { const gt = De._maxInstanceCount !== void 0 ? De._maxInstanceCount : 1 / 0, zt = Math.min(De.instanceCount, gt); Yt.renderInstances(ln, ir, zt) } else Yt.render(ln, ir) }, this.compile = function (Q, ve) { function De(xe, Oe, ot) { xe.transparent === !0 && xe.side === Ti && xe.forceSinglePass === !1 ? (xe.side = $r, xe.needsUpdate = !0, Ht(xe, Oe, ot), xe.side = qo, xe.needsUpdate = !0, Ht(xe, Oe, ot), xe.side = Ti) : Ht(xe, Oe, ot) } _ = ye.get(Q), _.init(), x.push(_), Q.traverseVisible(function (xe) { xe.isLight && xe.layers.test(ve.layers) && (_.pushLight(xe), xe.castShadow && _.pushShadow(xe)) }), _.setupLights(A._useLegacyLights), Q.traverse(function (xe) { const Oe = xe.material; if (Oe) if (Array.isArray(Oe)) for (let ot = 0; ot < Oe.length; ot++) { const dt = Oe[ot]; De(dt, Q, xe) } else De(Oe, Q, xe) }), x.pop(), _ = null }; let it = null; function yt(Q) { it && it(Q) } function Ct() { xt.stop() } function At() { xt.start() } const xt = new WD; xt.setAnimationLoop(yt), typeof self < "u" && xt.setContext(self), this.setAnimationLoop = function (Q) { it = Q, Y.setAnimationLoop(Q), Q === null ? xt.stop() : xt.start() }, Y.addEventListener("sessionstart", Ct), Y.addEventListener("sessionend", At), this.render = function (Q, ve) { if (ve !== void 0 && ve.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (E === !0) return; Q.matrixWorldAutoUpdate === !0 && Q.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), Y.enabled === !0 && Y.isPresenting === !0 && (Y.cameraAutoUpdate === !0 && Y.updateCamera(ve), ve = Y.getCamera()), Q.isScene === !0 && Q.onBeforeRender(A, Q, ve, T), _ = ye.get(Q, x.length), _.init(), x.push(_), ae.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), Z.setFromProjectionMatrix(ae), ne = this.localClippingEnabled, ee = be.init(this.clippingPlanes, ne), y = Ae.get(Q, g.length), y.init(), g.push(y), Yn(Q, ve, 0, A.sortObjects), y.finish(), A.sortObjects === !0 && y.sort(W, V), this.info.render.frame++, ee === !0 && be.beginShadows(); const De = _.state.shadowsArray; if (ke.render(De, Q, ve), ee === !0 && be.endShadows(), this.info.autoReset === !0 && this.info.reset(), He.render(y, Q), _.setupLights(A._useLegacyLights), ve.isArrayCamera) { const xe = ve.cameras; for (let Oe = 0, ot = xe.length; Oe < ot; Oe++) { const dt = xe[Oe]; $n(y, Q, dt, dt.viewport) } } else $n(y, Q, ve); T !== null && (Ie.updateMultisampleRenderTarget(T), Ie.updateRenderTargetMipmap(T)), Q.isScene === !0 && Q.onAfterRender(A, Q, ve), re.resetDefaultState(), B = -1, R = null, x.pop(), x.length > 0 ? _ = x[x.length - 1] : _ = null, g.pop(), g.length > 0 ? y = g[g.length - 1] : y = null }; function Yn(Q, ve, De, xe) { if (Q.visible === !1) return; if (Q.layers.test(ve.layers)) { if (Q.isGroup) De = Q.renderOrder; else if (Q.isLOD) Q.autoUpdate === !0 && Q.update(ve); else if (Q.isLight) _.pushLight(Q), Q.castShadow && _.pushShadow(Q); else if (Q.isSprite) { if (!Q.frustumCulled || Z.intersectsSprite(Q)) { xe && Se.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(ae); const dt = L.update(Q), Ye = Q.material; Ye.visible && y.push(Q, dt, Ye, De, Se.z, null) } } else if ((Q.isMesh || Q.isLine || Q.isPoints) && (!Q.frustumCulled || Z.intersectsObject(Q))) { const dt = L.update(Q), Ye = Q.material; if (xe && (Q.boundingSphere !== void 0 ? (Q.boundingSphere === null && Q.computeBoundingSphere(), Se.copy(Q.boundingSphere.center)) : (dt.boundingSphere === null && dt.computeBoundingSphere(), Se.copy(dt.boundingSphere.center)), Se.applyMatrix4(Q.matrixWorld).applyMatrix4(ae)), Array.isArray(Ye)) { const lt = dt.groups; for (let Et = 0, We = lt.length; Et < We; Et++) { const pt = lt[Et], ln = Ye[pt.materialIndex]; ln && ln.visible && y.push(Q, dt, ln, De, Se.z, pt) } } else Ye.visible && y.push(Q, dt, Ye, De, Se.z, null) } } const ot = Q.children; for (let dt = 0, Ye = ot.length; dt < Ye; dt++)Yn(ot[dt], ve, De, xe) } function $n(Q, ve, De, xe) { const Oe = Q.opaque, ot = Q.transmissive, dt = Q.transparent; _.setupLightsView(De), ee === !0 && be.setGlobalState(A.clippingPlanes, De), ot.length > 0 && Dt(Oe, ot, ve, De), xe && fe.viewport(P.copy(xe)), Oe.length > 0 && qt(Oe, ve, De), ot.length > 0 && qt(ot, ve, De), dt.length > 0 && qt(dt, ve, De), fe.buffers.depth.setTest(!0), fe.buffers.depth.setMask(!0), fe.buffers.color.setMask(!0), fe.setPolygonOffset(!1) } function Dt(Q, ve, De, xe) { const Oe = ce.isWebGL2; K === null && (K = new Qr(1, 1, { generateMipmaps: !0, type: he.has("EXT_color_buffer_half_float") ? Ts : $o, minFilter: Ds, samples: Oe ? 4 : 0 })), A.getDrawingBufferSize(ie), Oe ? K.setSize(ie.x, ie.y) : K.setSize(Av(ie.x), Av(ie.y)); const ot = A.getRenderTarget(); A.setRenderTarget(K), A.getClearColor($), z = A.getClearAlpha(), z < 1 && A.setClearColor(16777215, .5), A.clear(); const dt = A.toneMapping; A.toneMapping = Cs, qt(Q, De, xe), Ie.updateMultisampleRenderTarget(K), Ie.updateRenderTargetMipmap(K); let Ye = !1; for (let lt = 0, Et = ve.length; lt < Et; lt++) { const We = ve[lt], pt = We.object, ln = We.geometry, jt = We.material, ir = We.group; if (jt.side === Ti && pt.layers.test(xe.layers)) { const Or = jt.side; jt.side = $r, jt.needsUpdate = !0, tn(pt, De, xe, ln, jt, ir), jt.side = Or, jt.needsUpdate = !0, Ye = !0 } } Ye === !0 && (Ie.updateMultisampleRenderTarget(K), Ie.updateRenderTargetMipmap(K)), A.setRenderTarget(ot), A.setClearColor($, z), A.toneMapping = dt } function qt(Q, ve, De) { const xe = ve.isScene === !0 ? ve.overrideMaterial : null; for (let Oe = 0, ot = Q.length; Oe < ot; Oe++) { const dt = Q[Oe], Ye = dt.object, lt = dt.geometry, Et = xe === null ? dt.material : xe, We = dt.group; Ye.layers.test(De.layers) && tn(Ye, ve, De, lt, Et, We) } } function tn(Q, ve, De, xe, Oe, ot) { Q.onBeforeRender(A, ve, De, xe, Oe, ot), Q.modelViewMatrix.multiplyMatrices(De.matrixWorldInverse, Q.matrixWorld), Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix), Oe.onBeforeRender(A, ve, De, xe, Q, ot), Oe.transparent === !0 && Oe.side === Ti && Oe.forceSinglePass === !1 ? (Oe.side = $r, Oe.needsUpdate = !0, A.renderBufferDirect(De, ve, xe, Oe, Q, ot), Oe.side = qo, Oe.needsUpdate = !0, A.renderBufferDirect(De, ve, xe, Oe, Q, ot), Oe.side = Ti) : A.renderBufferDirect(De, ve, xe, Oe, Q, ot), Q.onAfterRender(A, ve, De, xe, Oe, ot) } function Ht(Q, ve, De) { ve.isScene !== !0 && (ve = Ce); const xe = de.get(Q), Oe = _.state.lights, ot = _.state.shadowsArray, dt = Oe.state.version, Ye = oe.getParameters(Q, Oe.state, ot, ve, De), lt = oe.getProgramCacheKey(Ye); let Et = xe.programs; xe.environment = Q.isMeshStandardMaterial ? ve.environment : null, xe.fog = ve.fog, xe.envMap = (Q.isMeshStandardMaterial ? ge : we).get(Q.envMap || xe.environment), Et === void 0 && (Q.addEventListener("dispose", Qe), Et = new Map, xe.programs = Et); let We = Et.get(lt); if (We !== void 0) { if (xe.currentProgram === We && xe.lightsStateVersion === dt) return mn(Q, Ye), We } else Ye.uniforms = oe.getUniforms(Q), Q.onBuild(De, Ye, A), Q.onBeforeCompile(Ye, A), We = oe.acquireProgram(Ye, lt), Et.set(lt, We), xe.uniforms = Ye.uniforms; const pt = xe.uniforms; (!Q.isShaderMaterial && !Q.isRawShaderMaterial || Q.clipping === !0) && (pt.clippingPlanes = be.uniform), mn(Q, Ye), xe.needsLights = dr(Q), xe.lightsStateVersion = dt, xe.needsLights && (pt.ambientLightColor.value = Oe.state.ambient, pt.lightProbe.value = Oe.state.probe, pt.directionalLights.value = Oe.state.directional, pt.directionalLightShadows.value = Oe.state.directionalShadow, pt.spotLights.value = Oe.state.spot, pt.spotLightShadows.value = Oe.state.spotShadow, pt.rectAreaLights.value = Oe.state.rectArea, pt.ltc_1.value = Oe.state.rectAreaLTC1, pt.ltc_2.value = Oe.state.rectAreaLTC2, pt.pointLights.value = Oe.state.point, pt.pointLightShadows.value = Oe.state.pointShadow, pt.hemisphereLights.value = Oe.state.hemi, pt.directionalShadowMap.value = Oe.state.directionalShadowMap, pt.directionalShadowMatrix.value = Oe.state.directionalShadowMatrix, pt.spotShadowMap.value = Oe.state.spotShadowMap, pt.spotLightMatrix.value = Oe.state.spotLightMatrix, pt.spotLightMap.value = Oe.state.spotLightMap, pt.pointShadowMap.value = Oe.state.pointShadowMap, pt.pointShadowMatrix.value = Oe.state.pointShadowMatrix); const ln = We.getUniforms(), jt = k0.seqWithValue(ln.seq, pt); return xe.currentProgram = We, xe.uniformsList = jt, We } function mn(Q, ve) { const De = de.get(Q); De.outputColorSpace = ve.outputColorSpace, De.instancing = ve.instancing, De.instancingColor = ve.instancingColor, De.skinning = ve.skinning, De.morphTargets = ve.morphTargets, De.morphNormals = ve.morphNormals, De.morphColors = ve.morphColors, De.morphTargetsCount = ve.morphTargetsCount, De.numClippingPlanes = ve.numClippingPlanes, De.numIntersection = ve.numClipIntersection, De.vertexAlphas = ve.vertexAlphas, De.vertexTangents = ve.vertexTangents, De.toneMapping = ve.toneMapping } function gn(Q, ve, De, xe, Oe) { ve.isScene !== !0 && (ve = Ce), Ie.resetTextureUnits(); const ot = ve.fog, dt = xe.isMeshStandardMaterial ? ve.environment : null, Ye = T === null ? A.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : Os, lt = (xe.isMeshStandardMaterial ? ge : we).get(xe.envMap || dt), Et = xe.vertexColors === !0 && !!De.attributes.color && De.attributes.color.itemSize === 4, We = !!De.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0), pt = !!De.morphAttributes.position, ln = !!De.morphAttributes.normal, jt = !!De.morphAttributes.color; let ir = Cs; xe.toneMapped && (T === null || T.isXRRenderTarget === !0) && (ir = A.toneMapping); const Or = De.morphAttributes.position || De.morphAttributes.normal || De.morphAttributes.color, Yt = Or !== void 0 ? Or.length : 0, gt = de.get(xe), zt = _.state.lights; if (ee === !0 && (ne === !0 || Q !== R)) { const Qn = Q === R && xe.id === B; be.setState(xe, Q, Qn) } let vt = !1; xe.version === gt.__version ? (gt.needsLights && gt.lightsStateVersion !== zt.state.version || gt.outputColorSpace !== Ye || Oe.isInstancedMesh && gt.instancing === !1 || !Oe.isInstancedMesh && gt.instancing === !0 || Oe.isSkinnedMesh && gt.skinning === !1 || !Oe.isSkinnedMesh && gt.skinning === !0 || Oe.isInstancedMesh && gt.instancingColor === !0 && Oe.instanceColor === null || Oe.isInstancedMesh && gt.instancingColor === !1 && Oe.instanceColor !== null || gt.envMap !== lt || xe.fog === !0 && gt.fog !== ot || gt.numClippingPlanes !== void 0 && (gt.numClippingPlanes !== be.numPlanes || gt.numIntersection !== be.numIntersection) || gt.vertexAlphas !== Et || gt.vertexTangents !== We || gt.morphTargets !== pt || gt.morphNormals !== ln || gt.morphColors !== jt || gt.toneMapping !== ir || ce.isWebGL2 === !0 && gt.morphTargetsCount !== Yt) && (vt = !0) : (vt = !0, gt.__version = xe.version); let Vn = gt.currentProgram; vt === !0 && (Vn = Ht(xe, ve, Oe)); let On = !1, En = !1, xi = !1; const cn = Vn.getUniforms(), dn = gt.uniforms; if (fe.useProgram(Vn.program) && (On = !0, En = !0, xi = !0), xe.id !== B && (B = xe.id, En = !0), On || R !== Q) { cn.setValue(F, "projectionMatrix", Q.projectionMatrix), cn.setValue(F, "viewMatrix", Q.matrixWorldInverse); const Qn = cn.map.cameraPosition; Qn !== void 0 && Qn.setValue(F, Se.setFromMatrixPosition(Q.matrixWorld)), ce.logarithmicDepthBuffer && cn.setValue(F, "logDepthBufFC", 2 / (Math.log(Q.far + 1) / Math.LN2)), (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && cn.setValue(F, "isOrthographic", Q.isOrthographicCamera === !0), R !== Q && (R = Q, En = !0, xi = !0) } if (Oe.isSkinnedMesh) { cn.setOptional(F, Oe, "bindMatrix"), cn.setOptional(F, Oe, "bindMatrixInverse"); const Qn = Oe.skeleton; Qn && (ce.floatVertexTextures ? (Qn.boneTexture === null && Qn.computeBoneTexture(), cn.setValue(F, "boneTexture", Qn.boneTexture, Ie), cn.setValue(F, "boneTextureSize", Qn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const ri = De.morphAttributes; if ((ri.position !== void 0 || ri.normal !== void 0 || ri.color !== void 0 && ce.isWebGL2 === !0) && je.update(Oe, De, Vn), (En || gt.receiveShadow !== Oe.receiveShadow) && (gt.receiveShadow = Oe.receiveShadow, cn.setValue(F, "receiveShadow", Oe.receiveShadow)), xe.isMeshGouraudMaterial && xe.envMap !== null && (dn.envMap.value = lt, dn.flipEnvMap.value = lt.isCubeTexture && lt.isRenderTargetTexture === !1 ? -1 : 1), En && (cn.setValue(F, "toneMappingExposure", A.toneMappingExposure), gt.needsLights && Dr(dn, xi), ot && xe.fog === !0 && Pe.refreshFogUniforms(dn, ot), Pe.refreshMaterialUniforms(dn, xe, se, q, K), k0.upload(F, gt.uniformsList, dn, Ie)), xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (k0.upload(F, gt.uniformsList, dn, Ie), xe.uniformsNeedUpdate = !1), xe.isSpriteMaterial && cn.setValue(F, "center", Oe.center), cn.setValue(F, "modelViewMatrix", Oe.modelViewMatrix), cn.setValue(F, "normalMatrix", Oe.normalMatrix), cn.setValue(F, "modelMatrix", Oe.matrixWorld), xe.isShaderMaterial || xe.isRawShaderMaterial) { const Qn = xe.uniformsGroups; for (let is = 0, os = Qn.length; is < os; is++)if (ce.isWebGL2) { const Fr = Qn[is]; _e.update(Fr, Vn), _e.bind(Fr, Vn) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return Vn } function Dr(Q, ve) { Q.ambientLightColor.needsUpdate = ve, Q.lightProbe.needsUpdate = ve, Q.directionalLights.needsUpdate = ve, Q.directionalLightShadows.needsUpdate = ve, Q.pointLights.needsUpdate = ve, Q.pointLightShadows.needsUpdate = ve, Q.spotLights.needsUpdate = ve, Q.spotLightShadows.needsUpdate = ve, Q.rectAreaLights.needsUpdate = ve, Q.hemisphereLights.needsUpdate = ve } function dr(Q) { return Q.isMeshLambertMaterial || Q.isMeshToonMaterial || Q.isMeshPhongMaterial || Q.isMeshStandardMaterial || Q.isShadowMaterial || Q.isShaderMaterial && Q.lights === !0 } this.getActiveCubeFace = function () { return w }, this.getActiveMipmapLevel = function () { return b }, this.getRenderTarget = function () { return T }, this.setRenderTargetTextures = function (Q, ve, De) { de.get(Q.texture).__webglTexture = ve, de.get(Q.depthTexture).__webglTexture = De; const xe = de.get(Q); xe.__hasExternalTextures = !0, xe.__hasExternalTextures && (xe.__autoAllocateDepthBuffer = De === void 0, xe.__autoAllocateDepthBuffer || he.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), xe.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (Q, ve) { const De = de.get(Q); De.__webglFramebuffer = ve, De.__useDefaultFramebuffer = ve === void 0 }, this.setRenderTarget = function (Q, ve = 0, De = 0) { T = Q, w = ve, b = De; let xe = !0, Oe = null, ot = !1, dt = !1; if (Q) { const lt = de.get(Q); lt.__useDefaultFramebuffer !== void 0 ? (fe.bindFramebuffer(F.FRAMEBUFFER, null), xe = !1) : lt.__webglFramebuffer === void 0 ? Ie.setupRenderTarget(Q) : lt.__hasExternalTextures && Ie.rebindTextures(Q, de.get(Q.texture).__webglTexture, de.get(Q.depthTexture).__webglTexture); const Et = Q.texture; (Et.isData3DTexture || Et.isDataArrayTexture || Et.isCompressedArrayTexture) && (dt = !0); const We = de.get(Q).__webglFramebuffer; Q.isWebGLCubeRenderTarget ? (Array.isArray(We[ve]) ? Oe = We[ve][De] : Oe = We[ve], ot = !0) : ce.isWebGL2 && Q.samples > 0 && Ie.useMultisampledRTT(Q) === !1 ? Oe = de.get(Q).__webglMultisampledFramebuffer : Array.isArray(We) ? Oe = We[De] : Oe = We, P.copy(Q.viewport), U.copy(Q.scissor), G = Q.scissorTest } else P.copy(J).multiplyScalar(se).floor(), U.copy(O).multiplyScalar(se).floor(), G = k; if (fe.bindFramebuffer(F.FRAMEBUFFER, Oe) && ce.drawBuffers && xe && fe.drawBuffers(Q, Oe), fe.viewport(P), fe.scissor(U), fe.setScissorTest(G), ot) { const lt = de.get(Q.texture); F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + ve, lt.__webglTexture, De) } else if (dt) { const lt = de.get(Q.texture), Et = ve || 0; F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, lt.__webglTexture, De || 0, Et) } B = -1 }, this.readRenderTargetPixels = function (Q, ve, De, xe, Oe, ot, dt) { if (!(Q && Q.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let Ye = de.get(Q).__webglFramebuffer; if (Q.isWebGLCubeRenderTarget && dt !== void 0 && (Ye = Ye[dt]), Ye) { fe.bindFramebuffer(F.FRAMEBUFFER, Ye); try { const lt = Q.texture, Et = lt.format, We = lt.type; if (Et !== Yr && Je.convert(Et) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const pt = We === Ts && (he.has("EXT_color_buffer_half_float") || ce.isWebGL2 && he.has("EXT_color_buffer_float")); if (We !== $o && Je.convert(We) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE) && !(We === As && (ce.isWebGL2 || he.has("OES_texture_float") || he.has("WEBGL_color_buffer_float"))) && !pt) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ve >= 0 && ve <= Q.width - xe && De >= 0 && De <= Q.height - Oe && F.readPixels(ve, De, xe, Oe, Je.convert(Et), Je.convert(We), ot) } finally { const lt = T !== null ? de.get(T).__webglFramebuffer : null; fe.bindFramebuffer(F.FRAMEBUFFER, lt) } } }, this.copyFramebufferToTexture = function (Q, ve, De = 0) { const xe = Math.pow(2, -De), Oe = Math.floor(ve.image.width * xe), ot = Math.floor(ve.image.height * xe); Ie.setTexture2D(ve, 0), F.copyTexSubImage2D(F.TEXTURE_2D, De, 0, 0, Q.x, Q.y, Oe, ot), fe.unbindTexture() }, this.copyTextureToTexture = function (Q, ve, De, xe = 0) { const Oe = ve.image.width, ot = ve.image.height, dt = Je.convert(De.format), Ye = Je.convert(De.type); Ie.setTexture2D(De, 0), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, De.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, De.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, De.unpackAlignment), ve.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, xe, Q.x, Q.y, Oe, ot, dt, Ye, ve.image.data) : ve.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, xe, Q.x, Q.y, ve.mipmaps[0].width, ve.mipmaps[0].height, dt, ve.mipmaps[0].data) : F.texSubImage2D(F.TEXTURE_2D, xe, Q.x, Q.y, dt, Ye, ve.image), xe === 0 && De.generateMipmaps && F.generateMipmap(F.TEXTURE_2D), fe.unbindTexture() }, this.copyTextureToTexture3D = function (Q, ve, De, xe, Oe = 0) { if (A.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const ot = Q.max.x - Q.min.x + 1, dt = Q.max.y - Q.min.y + 1, Ye = Q.max.z - Q.min.z + 1, lt = Je.convert(xe.format), Et = Je.convert(xe.type); let We; if (xe.isData3DTexture) Ie.setTexture3D(xe, 0), We = F.TEXTURE_3D; else if (xe.isDataArrayTexture) Ie.setTexture2DArray(xe, 0), We = F.TEXTURE_2D_ARRAY; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, xe.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, xe.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, xe.unpackAlignment); const pt = F.getParameter(F.UNPACK_ROW_LENGTH), ln = F.getParameter(F.UNPACK_IMAGE_HEIGHT), jt = F.getParameter(F.UNPACK_SKIP_PIXELS), ir = F.getParameter(F.UNPACK_SKIP_ROWS), Or = F.getParameter(F.UNPACK_SKIP_IMAGES), Yt = De.isCompressedTexture ? De.mipmaps[0] : De.image; F.pixelStorei(F.UNPACK_ROW_LENGTH, Yt.width), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, Yt.height), F.pixelStorei(F.UNPACK_SKIP_PIXELS, Q.min.x), F.pixelStorei(F.UNPACK_SKIP_ROWS, Q.min.y), F.pixelStorei(F.UNPACK_SKIP_IMAGES, Q.min.z), De.isDataTexture || De.isData3DTexture ? F.texSubImage3D(We, Oe, ve.x, ve.y, ve.z, ot, dt, Ye, lt, Et, Yt.data) : De.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), F.compressedTexSubImage3D(We, Oe, ve.x, ve.y, ve.z, ot, dt, Ye, lt, Yt.data)) : F.texSubImage3D(We, Oe, ve.x, ve.y, ve.z, ot, dt, Ye, lt, Et, Yt), F.pixelStorei(F.UNPACK_ROW_LENGTH, pt), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, ln), F.pixelStorei(F.UNPACK_SKIP_PIXELS, jt), F.pixelStorei(F.UNPACK_SKIP_ROWS, ir), F.pixelStorei(F.UNPACK_SKIP_IMAGES, Or), Oe === 0 && xe.generateMipmaps && F.generateMipmap(We), fe.unbindTexture() }, this.initTexture = function (Q) { Q.isCubeTexture ? Ie.setTextureCube(Q, 0) : Q.isData3DTexture ? Ie.setTexture3D(Q, 0) : Q.isDataArrayTexture || Q.isCompressedArrayTexture ? Ie.setTexture2DArray(Q, 0) : Ie.setTexture2D(Q, 0), fe.unbindTexture() }, this.resetState = function () { w = 0, b = 0, T = null, fe.reset(), re.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return Es } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const t = this.getContext(); t.drawingBufferColorSpace = e === uy ? "display-p3" : "srgb", t.unpackColorSpace = nn.workingColorSpace === Fp ? "display-p3" : "srgb" } get physicallyCorrectLights() { return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights } set physicallyCorrectLights(e) { console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e } get outputEncoding() { return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === ar ? ml : IM } set outputEncoding(e) { console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === ml ? ar : Os } get useLegacyLights() { return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights } set useLegacyLights(e) { console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e } } class ZD extends zM { } ZD.prototype.isWebGL1Renderer = !0; class gy { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new qe(e), this.density = t } clone() { return new gy(this.color, this.density) } toJSON() { return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density } } } class vy { constructor(e, t = 1, r = 1e3) { this.isFog = !0, this.name = "", this.color = new qe(e), this.near = t, this.far = r } clone() { return new vy(this.color, this.near, this.far) } toJSON() { return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far } } } let Ev = class extends Ut { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t } }; class Gp { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = up, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = to() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, r) { e *= this.stride, r *= t.stride; for (let i = 0, o = this.stride; i < o; i++)this.array[e + i] = t.array[r + i]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = to()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride); return r.setUsage(this.usage), r } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = to()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const ui = new X; class Bi { constructor(e, t, r, i = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, r = this.data.count; t < r; t++)ui.fromBufferAttribute(this, t), ui.applyMatrix4(e), this.setXYZ(t, ui.x, ui.y, ui.z); return this } applyNormalMatrix(e) { for (let t = 0, r = this.count; t < r; t++)ui.fromBufferAttribute(this, t), ui.applyNormalMatrix(e), this.setXYZ(t, ui.x, ui.y, ui.z); return this } transformDirection(e) { for (let t = 0, r = this.count; t < r; t++)ui.fromBufferAttribute(this, t), ui.transformDirection(e), this.setXYZ(t, ui.x, ui.y, ui.z); return this } setX(e, t) { return this.normalized && (t = Pt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = Pt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = Pt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = Pt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Ri(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Ri(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Ri(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Ri(t, this.array)), t } setXY(e, t, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this } setXYZ(e, t, r, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this } setXYZW(e, t, r, i, o) { return e = e * this.data.stride + this.offset, this.normalized && (t = Pt(t, this.array), r = Pt(r, this.array), i = Pt(i, this.array), o = Pt(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let o = 0; o < this.itemSize; o++)t.push(this.data.array[i + o]) } return new Kt(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Bi(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let o = 0; o < this.itemSize; o++)t.push(this.data.array[i + o]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class GM extends rr { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new qe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let Ou; const Kd = new X, Fu = new X, Uu = new X, ku = new Be, Yd = new Be, qD = new _t, Dg = new X, $d = new X, Og = new X, I2 = new Be, cx = new Be, L2 = new Be; class eO extends Ut { constructor(e = new GM) { if (super(), this.isSprite = !0, this.type = "Sprite", Ou === void 0) { Ou = new bt; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), r = new Gp(t, 5); Ou.setIndex([0, 1, 2, 0, 2, 3]), Ou.setAttribute("position", new Bi(r, 3, 0, !1)), Ou.setAttribute("uv", new Bi(r, 2, 3, !1)) } this.geometry = Ou, this.material = e, this.center = new Be(.5, .5) } raycast(e, t) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Fu.setFromMatrixScale(this.matrixWorld), qD.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Uu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Fu.multiplyScalar(-Uu.z); const r = this.material.rotation; let i, o; r !== 0 && (o = Math.cos(r), i = Math.sin(r)); const s = this.center; Fg(Dg.set(-.5, -.5, 0), Uu, s, Fu, i, o), Fg($d.set(.5, -.5, 0), Uu, s, Fu, i, o), Fg(Og.set(.5, .5, 0), Uu, s, Fu, i, o), I2.set(0, 0), cx.set(1, 0), L2.set(1, 1); let a = e.ray.intersectTriangle(Dg, $d, Og, !1, Kd); if (a === null && (Fg($d.set(-.5, .5, 0), Uu, s, Fu, i, o), cx.set(0, 1), a = e.ray.intersectTriangle(Dg, Og, $d, !1, Kd), a === null)) return; const l = e.ray.origin.distanceTo(Kd); l < e.near || l > e.far || t.push({ distance: l, point: Kd.clone(), uv: Ci.getInterpolation(Kd, Dg, $d, Og, I2, cx, L2, new Be), face: null, object: this }) } copy(e, t) { return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function Fg(n, e, t, r, i, o) { ku.subVectors(n, t).addScalar(.5).multiply(r), i !== void 0 ? (Yd.x = o * ku.x - i * ku.y, Yd.y = i * ku.x + o * ku.y) : Yd.copy(ku), n.copy(e), n.x += Yd.x, n.y += Yd.y, n.applyMatrix4(qD) } const Ug = new X, D2 = new X; class tO extends Ut { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let r = 0, i = t.length; r < i; r++) { const o = t[r]; this.addLevel(o.object.clone(), o.distance, o.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, r = 0) { t = Math.abs(t); const i = this.levels; let o; for (o = 0; o < i.length && !(t < i[o].distance); o++); return i.splice(o, 0, { distance: t, hysteresis: r, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let r, i; for (r = 1, i = t.length; r < i; r++) { let o = t[r].distance; if (t[r].object.visible && (o -= o * t[r].hysteresis), e < o) break } return t[r - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { Ug.setFromMatrixPosition(this.matrixWorld); const i = e.ray.origin.distanceTo(Ug); this.getObjectForDistance(i).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { Ug.setFromMatrixPosition(e.matrixWorld), D2.setFromMatrixPosition(this.matrixWorld); const r = Ug.distanceTo(D2) / e.zoom; t[0].object.visible = !0; let i, o; for (i = 1, o = t.length; i < o; i++) { let s = t[i].distance; if (t[i].object.visible && (s -= s * t[i].hysteresis), r >= s) t[i - 1].object.visible = !1, t[i].object.visible = !0; else break } for (this._currentLevel = i - 1; i < o; i++)t[i].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = []; const r = this.levels; for (let i = 0, o = r.length; i < o; i++) { const s = r[i]; t.object.levels.push({ object: s.object.uuid, distance: s.distance, hysteresis: s.hysteresis }) } return t } } const O2 = new X, F2 = new Ft, U2 = new Ft, $9 = new X, k2 = new _t, Nu = new X, ux = new _i, N2 = new _t, fx = new Zc; class HM extends In { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new _t, this.bindMatrixInverse = new _t, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; this.boundingBox === null && (this.boundingBox = new yi), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let r = 0; r < t.count; r++)Nu.fromBufferAttribute(t, r), this.applyBoneTransform(r, Nu), this.boundingBox.expandByPoint(Nu) } computeBoundingSphere() { const e = this.geometry; this.boundingSphere === null && (this.boundingSphere = new _i), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let r = 0; r < t.count; r++)Nu.fromBufferAttribute(t, r), this.applyBoneTransform(r, Nu), this.boundingSphere.expandByPoint(Nu) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const r = this.material, i = this.matrixWorld; r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ux.copy(this.boundingSphere), ux.applyMatrix4(i), e.ray.intersectsSphere(ux) !== !1 && (N2.copy(i).invert(), fx.copy(e.ray).applyMatrix4(N2), !(this.boundingBox !== null && fx.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, fx))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Ft, t = this.geometry.attributes.skinWeight; for (let r = 0, i = t.count; r < i; r++) { e.fromBufferAttribute(t, r); const o = 1 / e.manhattanLength(); o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { const r = this.skeleton, i = this.geometry; F2.fromBufferAttribute(i.attributes.skinIndex, e), U2.fromBufferAttribute(i.attributes.skinWeight, e), O2.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let o = 0; o < 4; o++) { const s = U2.getComponent(o); if (s !== 0) { const a = F2.getComponent(o); k2.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]), t.addScaledVector($9.copy(O2).applyMatrix4(k2), s) } } return t.applyMatrix4(this.bindMatrixInverse) } boneTransform(e, t) { return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t) } } class yy extends Ut { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class bf extends An { constructor(e = null, t = 1, r = 1, i, o, s, a, l, c = Gn, u = Gn, d, p) { super(null, s, a, l, c, u, i, o, d, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const z2 = new _t, Q9 = new _t; class Hp { constructor(e = [], t = []) { this.uuid = to(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let r = 0, i = this.bones.length; r < i; r++)this.boneInverses.push(new _t) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const r = new _t; this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && r.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale)) } } update() { const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture; for (let o = 0, s = e.length; o < s; o++) { const a = e[o] ? e[o].matrixWorld : Q9; z2.multiplyMatrices(a, t[o]), z2.toArray(r, o * 16) } i !== null && (i.needsUpdate = !0) } clone() { return new Hp(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = FD(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const r = new bf(t, e, e, Yr, As); return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, r = this.bones.length; t < r; t++) { const i = this.bones[t]; if (i.name === e) return i } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let r = 0, i = e.bones.length; r < i; r++) { const o = e.bones[r]; let s = t[o]; s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), s = new yy), this.bones.push(s), this.boneInverses.push(new _t().fromArray(e.boneInverses[r])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, r = this.boneInverses; for (let i = 0, o = t.length; i < o; i++) { const s = t[i]; e.bones.push(s.uuid); const a = r[i]; e.boneInverses.push(a.toArray()) } return e } } class Vc extends Kt { constructor(e, t, r, i = 1) { super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const zu = new _t, G2 = new _t, kg = [], H2 = new yi, Z9 = new _t, Qd = new In, Zd = new _i; class VM extends In { constructor(e, t, r) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Vc(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.boundingBox = null, this.boundingSphere = null; for (let i = 0; i < r; i++)this.setMatrixAt(i, Z9) } computeBoundingBox() { const e = this.geometry, t = this.count; this.boundingBox === null && (this.boundingBox = new yi), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let r = 0; r < t; r++)this.getMatrixAt(r, zu), H2.copy(e.boundingBox).applyMatrix4(zu), this.boundingBox.union(H2) } computeBoundingSphere() { const e = this.geometry, t = this.count; this.boundingSphere === null && (this.boundingSphere = new _i), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let r = 0; r < t; r++)this.getMatrixAt(r, zu), Zd.copy(e.boundingSphere).applyMatrix4(zu), this.boundingSphere.union(Zd) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const r = this.matrixWorld, i = this.count; if (Qd.geometry = this.geometry, Qd.material = this.material, Qd.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Zd.copy(this.boundingSphere), Zd.applyMatrix4(r), e.ray.intersectsSphere(Zd) !== !1)) for (let o = 0; o < i; o++) { this.getMatrixAt(o, zu), G2.multiplyMatrices(r, zu), Qd.matrixWorld = G2, Qd.raycast(e, kg); for (let s = 0, a = kg.length; s < a; s++) { const l = kg[s]; l.instanceId = o, l.object = this, t.push(l) } kg.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new Vc(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class qr extends rr { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new qe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const V2 = new X, W2 = new X, j2 = new _t, dx = new Zc, Ng = new _i; let xa = class extends Ut { constructor(e = new bt, t = new qr) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, r = [0]; for (let i = 1, o = t.count; i < o; i++)V2.fromBufferAttribute(t, i - 1), W2.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += V2.distanceTo(W2); e.setAttribute("lineDistance", new ut(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const r = this.geometry, i = this.matrixWorld, o = e.params.Line.threshold, s = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), Ng.copy(r.boundingSphere), Ng.applyMatrix4(i), Ng.radius += o, e.ray.intersectsSphere(Ng) === !1) return; j2.copy(i).invert(), dx.copy(e.ray).applyMatrix4(j2); const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new X, u = new X, d = new X, p = new X, m = this.isLineSegments ? 2 : 1, v = r.index, _ = r.attributes.position; if (v !== null) { const g = Math.max(0, s.start), x = Math.min(v.count, s.start + s.count); for (let A = g, E = x - 1; A < E; A += m) { const w = v.getX(A), b = v.getX(A + 1); if (c.fromBufferAttribute(_, w), u.fromBufferAttribute(_, b), dx.distanceSqToSegment(c, u, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const B = e.ray.origin.distanceTo(p); B < e.near || B > e.far || t.push({ distance: B, point: d.clone().applyMatrix4(this.matrixWorld), index: A, face: null, faceIndex: null, object: this }) } } else { const g = Math.max(0, s.start), x = Math.min(_.count, s.start + s.count); for (let A = g, E = x - 1; A < E; A += m) { if (c.fromBufferAttribute(_, A), u.fromBufferAttribute(_, A + 1), dx.distanceSqToSegment(c, u, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const b = e.ray.origin.distanceTo(p); b < e.near || b > e.far || t.push({ distance: b, point: d.clone().applyMatrix4(this.matrixWorld), index: A, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, s = i.length; o < s; o++) { const a = i[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o } } } } }; const X2 = new X, J2 = new X; class es extends xa { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, r = []; for (let i = 0, o = t.count; i < o; i += 2)X2.fromBufferAttribute(t, i), J2.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + X2.distanceTo(J2); e.setAttribute("lineDistance", new ut(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class WM extends xa { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class _y extends rr { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new qe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const K2 = new _t, LA = new Zc, zg = new _i, Gg = new X; class jM extends Ut { constructor(e = new bt, t = new _y) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { const r = this.geometry, i = this.matrixWorld, o = e.params.Points.threshold, s = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), zg.copy(r.boundingSphere), zg.applyMatrix4(i), zg.radius += o, e.ray.intersectsSphere(zg) === !1) return; K2.copy(i).invert(), LA.copy(e.ray).applyMatrix4(K2); const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = r.index, d = r.attributes.position; if (c !== null) { const p = Math.max(0, s.start), m = Math.min(c.count, s.start + s.count); for (let v = p, y = m; v < y; v++) { const _ = c.getX(v); Gg.fromBufferAttribute(d, _), Y2(Gg, _, l, i, e, t, this) } } else { const p = Math.max(0, s.start), m = Math.min(d.count, s.start + s.count); for (let v = p, y = m; v < y; v++)Gg.fromBufferAttribute(d, v), Y2(Gg, v, l, i, e, t, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, s = i.length; o < s; o++) { const a = i[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o } } } } } function Y2(n, e, t, r, i, o, s) { const a = LA.distanceSqToPoint(n); if (a < t) { const l = new X; LA.closestPointToPoint(n, l), l.applyMatrix4(r); const c = i.ray.origin.distanceTo(l); if (c < i.near || c > i.far) return; o.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: s }) } } class q9 extends An { constructor(e, t, r, i, o, s, a, l, c) { super(e, t, r, i, o, s, a, l, c), this.isVideoTexture = !0, this.minFilter = s !== void 0 ? s : fn, this.magFilter = o !== void 0 ? o : fn, this.generateMipmaps = !1; const u = this; function d() { u.needsUpdate = !0, e.requestVideoFrameCallback(d) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class e6 extends An { constructor(e, t) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Gn, this.minFilter = Gn, this.generateMipmaps = !1, this.needsUpdate = !0 } } class xy extends An { constructor(e, t, r, i, o, s, a, l, c, u, d, p) { super(null, s, a, l, c, u, i, o, d, p), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class t6 extends xy { constructor(e, t, r, i, o, s) { super(e, t, r, o, s), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Rr } } class n6 extends xy { constructor(e, t, r) { super(void 0, e[0].width, e[0].height, t, r, ya), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class r6 extends An { constructor(e, t, r, i, o, s, a, l, c) { super(e, t, r, i, o, s, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class ts { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const r = this.getUtoTmapping(e); return this.getPoint(r, t) } getPoints(e = 5) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPoint(r / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPointAt(r / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let r, i = this.getPoint(0), o = 0; t.push(0); for (let s = 1; s <= e; s++)r = this.getPoint(s / e), o += r.distanceTo(i), t.push(o), i = r; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const r = this.getLengths(); let i = 0; const o = r.length; let s; t ? s = t : s = e * r[o - 1]; let a = 0, l = o - 1, c; for (; a <= l;)if (i = Math.floor(a + (l - a) / 2), c = r[i] - s, c < 0) a = i + 1; else if (c > 0) l = i - 1; else { l = i; break } if (i = l, r[i] === s) return i / (o - 1); const u = r[i], p = r[i + 1] - u, m = (s - u) / p; return (i + m) / (o - 1) } getTangent(e, t) { let i = e - 1e-4, o = e + 1e-4; i < 0 && (i = 0), o > 1 && (o = 1); const s = this.getPoint(i), a = this.getPoint(o), l = t || (s.isVector2 ? new Be : new X); return l.copy(a).sub(s).normalize(), l } getTangentAt(e, t) { const r = this.getUtoTmapping(e); return this.getTangent(r, t) } computeFrenetFrames(e, t) { const r = new X, i = [], o = [], s = [], a = new X, l = new _t; for (let m = 0; m <= e; m++) { const v = m / e; i[m] = this.getTangentAt(v, new X) } o[0] = new X, s[0] = new X; let c = Number.MAX_VALUE; const u = Math.abs(i[0].x), d = Math.abs(i[0].y), p = Math.abs(i[0].z); u <= c && (c = u, r.set(1, 0, 0)), d <= c && (c = d, r.set(0, 1, 0)), p <= c && r.set(0, 0, 1), a.crossVectors(i[0], r).normalize(), o[0].crossVectors(i[0], a), s[0].crossVectors(i[0], o[0]); for (let m = 1; m <= e; m++) { if (o[m] = o[m - 1].clone(), s[m] = s[m - 1].clone(), a.crossVectors(i[m - 1], i[m]), a.length() > Number.EPSILON) { a.normalize(); const v = Math.acos(Hn(i[m - 1].dot(i[m]), -1, 1)); o[m].applyMatrix4(l.makeRotationAxis(a, v)) } s[m].crossVectors(i[m], o[m]) } if (t === !0) { let m = Math.acos(Hn(o[0].dot(o[e]), -1, 1)); m /= e, i[0].dot(a.crossVectors(o[0], o[e])) > 0 && (m = -m); for (let v = 1; v <= e; v++)o[v].applyMatrix4(l.makeRotationAxis(i[v], m * v)), s[v].crossVectors(i[v], o[v]) } return { tangents: i, normals: o, binormals: s } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class Sy extends ts { constructor(e = 0, t = 0, r = 1, i = 1, o = 0, s = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = o, this.aEndAngle = s, this.aClockwise = a, this.aRotation = l } getPoint(e, t) { const r = t || new Be, i = Math.PI * 2; let o = this.aEndAngle - this.aStartAngle; const s = Math.abs(o) < Number.EPSILON; for (; o < 0;)o += i; for (; o > i;)o -= i; o < Number.EPSILON && (s ? o = 0 : o = i), this.aClockwise === !0 && !s && (o === i ? o = -i : o = o - i); const a = this.aStartAngle + e * o; let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { const u = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, m = c - this.aY; l = p * u - m * d + this.aX, c = p * d + m * u + this.aY } return r.set(l, c) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class nO extends Sy { constructor(e, t, r, i, o, s) { super(e, t, r, r, i, o, s), this.isArcCurve = !0, this.type = "ArcCurve" } } function XM() { let n = 0, e = 0, t = 0, r = 0; function i(o, s, a, l) { n = o, e = a, t = -3 * o + 3 * s - 2 * a - l, r = 2 * o - 2 * s + a + l } return { initCatmullRom: function (o, s, a, l, c) { i(s, a, c * (a - o), c * (l - s)) }, initNonuniformCatmullRom: function (o, s, a, l, c, u, d) { let p = (s - o) / c - (a - o) / (c + u) + (a - s) / u, m = (a - s) / u - (l - s) / (u + d) + (l - a) / d; p *= u, m *= u, i(s, a, p, m) }, calc: function (o) { const s = o * o, a = s * o; return n + e * o + t * s + r * a } } } const Hg = new X, hx = new XM, px = new XM, mx = new XM; class rO extends ts { constructor(e = [], t = !1, r = "centripetal", i = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i } getPoint(e, t = new X) { const r = t, i = this.points, o = i.length, s = (o - (this.closed ? 0 : 1)) * e; let a = Math.floor(s), l = s - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / o) + 1) * o : l === 0 && a === o - 1 && (a = o - 2, l = 1); let c, u; this.closed || a > 0 ? c = i[(a - 1) % o] : (Hg.subVectors(i[0], i[1]).add(i[0]), c = Hg); const d = i[a % o], p = i[(a + 1) % o]; if (this.closed || a + 2 < o ? u = i[(a + 2) % o] : (Hg.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), u = Hg), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let v = Math.pow(c.distanceToSquared(d), m), y = Math.pow(d.distanceToSquared(p), m), _ = Math.pow(p.distanceToSquared(u), m); y < 1e-4 && (y = 1), v < 1e-4 && (v = y), _ < 1e-4 && (_ = y), hx.initNonuniformCatmullRom(c.x, d.x, p.x, u.x, v, y, _), px.initNonuniformCatmullRom(c.y, d.y, p.y, u.y, v, y, _), mx.initNonuniformCatmullRom(c.z, d.z, p.z, u.z, v, y, _) } else this.curveType === "catmullrom" && (hx.initCatmullRom(c.x, d.x, p.x, u.x, this.tension), px.initCatmullRom(c.y, d.y, p.y, u.y, this.tension), mx.initCatmullRom(c.z, d.z, p.z, u.z, this.tension)); return r.set(hx.calc(l), px.calc(l), mx.calc(l)), r } copy(e) { super.copy(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, r = this.points.length; t < r; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(new X().fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function $2(n, e, t, r, i) { const o = (r - e) * .5, s = (i - t) * .5, a = n * n, l = n * a; return (2 * t - 2 * r + o + s) * l + (-3 * t + 3 * r - 2 * o - s) * a + o * n + t } function i6(n, e) { const t = 1 - n; return t * t * e } function o6(n, e) { return 2 * (1 - n) * n * e } function s6(n, e) { return n * n * e } function Ph(n, e, t, r) { return i6(n, e) + o6(n, t) + s6(n, r) } function a6(n, e) { const t = 1 - n; return t * t * t * e } function l6(n, e) { const t = 1 - n; return 3 * t * t * n * e } function c6(n, e) { return 3 * (1 - n) * n * n * e } function u6(n, e) { return n * n * n * e } function Bh(n, e, t, r, i) { return a6(n, e) + l6(n, t) + c6(n, r) + u6(n, i) } class JM extends ts { constructor(e = new Be, t = new Be, r = new Be, i = new Be) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i } getPoint(e, t = new Be) { const r = t, i = this.v0, o = this.v1, s = this.v2, a = this.v3; return r.set(Bh(e, i.x, o.x, s.x, a.x), Bh(e, i.y, o.y, s.y, a.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class iO extends ts { constructor(e = new X, t = new X, r = new X, i = new X) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i } getPoint(e, t = new X) { const r = t, i = this.v0, o = this.v1, s = this.v2, a = this.v3; return r.set(Bh(e, i.x, o.x, s.x, a.x), Bh(e, i.y, o.y, s.y, a.y), Bh(e, i.z, o.z, s.z, a.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class KM extends ts { constructor(e = new Be, t = new Be) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new Be) { const r = t; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new Be) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class oO extends ts { constructor(e = new X, t = new X) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new X) { const r = t; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new X) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class YM extends ts { constructor(e = new Be, t = new Be, r = new Be) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r } getPoint(e, t = new Be) { const r = t, i = this.v0, o = this.v1, s = this.v2; return r.set(Ph(e, i.x, o.x, s.x), Ph(e, i.y, o.y, s.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class $M extends ts { constructor(e = new X, t = new X, r = new X) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r } getPoint(e, t = new X) { const r = t, i = this.v0, o = this.v1, s = this.v2; return r.set(Ph(e, i.x, o.x, s.x), Ph(e, i.y, o.y, s.y), Ph(e, i.z, o.z, s.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class QM extends ts { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new Be) { const r = t, i = this.points, o = (i.length - 1) * e, s = Math.floor(o), a = o - s, l = i[s === 0 ? s : s - 1], c = i[s], u = i[s > i.length - 2 ? i.length - 1 : s + 1], d = i[s > i.length - 3 ? i.length - 1 : s + 2]; return r.set($2(a, l.x, c.x, u.x, d.x), $2(a, l.y, c.y, u.y, d.y)), r } copy(e) { super.copy(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, r = this.points.length; t < r; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(new Be().fromArray(i)) } return this } } var Mv = Object.freeze({ __proto__: null, ArcCurve: nO, CatmullRomCurve3: rO, CubicBezierCurve: JM, CubicBezierCurve3: iO, EllipseCurve: Sy, LineCurve: KM, LineCurve3: oO, QuadraticBezierCurve: YM, QuadraticBezierCurve3: $M, SplineCurve: QM }); class sO extends ts { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); if (!e.equals(t)) { const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3"; this.curves.push(new Mv[r](t, e)) } return this } getPoint(e, t) { const r = e * this.getLength(), i = this.getCurveLengths(); let o = 0; for (; o < i.length;) { if (i[o] >= r) { const s = i[o] - r, a = this.curves[o], l = a.getLength(), c = l === 0 ? 0 : 1 - s / l; return a.getPointAt(c, t) } o++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let r = 0, i = this.curves.length; r < i; r++)t += this.curves[r].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPoint(r / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let r; for (let i = 0, o = this.curves; i < o.length; i++) { const s = o[i], a = s.isEllipseCurve ? e * 2 : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e, l = s.getPoints(a); for (let c = 0; c < l.length; c++) { const u = l[c]; r && r.equals(u) || (t.push(u), r = u) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, r = e.curves.length; t < r; t++) { const i = e.curves[t]; this.curves.push(i.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, r = this.curves.length; t < r; t++) { const i = this.curves[t]; e.curves.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, r = e.curves.length; t < r; t++) { const i = e.curves[t]; this.curves.push(new Mv[i.type]().fromJSON(i)) } return this } } class hp extends sO { constructor(e) { super(), this.type = "Path", this.currentPoint = new Be, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, r = e.length; t < r; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const r = new KM(this.currentPoint.clone(), new Be(e, t)); return this.curves.push(r), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, r, i) { const o = new YM(this.currentPoint.clone(), new Be(e, t), new Be(r, i)); return this.curves.push(o), this.currentPoint.set(r, i), this } bezierCurveTo(e, t, r, i, o, s) { const a = new JM(this.currentPoint.clone(), new Be(e, t), new Be(r, i), new Be(o, s)); return this.curves.push(a), this.currentPoint.set(o, s), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), r = new QM(t); return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, r, i, o, s) { const a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + a, t + l, r, i, o, s), this } absarc(e, t, r, i, o, s) { return this.absellipse(e, t, r, r, i, o, s), this } ellipse(e, t, r, i, o, s, a, l) { const c = this.currentPoint.x, u = this.currentPoint.y; return this.absellipse(e + c, t + u, r, i, o, s, a, l), this } absellipse(e, t, r, i, o, s, a, l) { const c = new Sy(e, t, r, i, o, s, a, l); if (this.curves.length > 0) { const d = c.getPoint(0); d.equals(this.currentPoint) || this.lineTo(d.x, d.y) } this.curves.push(c); const u = c.getPoint(1); return this.currentPoint.copy(u), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Vp extends bt { constructor(e = [new Be(0, -.5), new Be(.5, 0), new Be(0, .5)], t = 12, r = 0, i = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }, t = Math.floor(t), i = Hn(i, 0, Math.PI * 2); const o = [], s = [], a = [], l = [], c = [], u = 1 / t, d = new X, p = new Be, m = new X, v = new X, y = new X; let _ = 0, g = 0; for (let x = 0; x <= e.length - 1; x++)switch (x) { case 0: _ = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, m.x = g * 1, m.y = -_, m.z = g * 0, y.copy(m), m.normalize(), l.push(m.x, m.y, m.z); break; case e.length - 1: l.push(y.x, y.y, y.z); break; default: _ = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, m.x = g * 1, m.y = -_, m.z = g * 0, v.copy(m), m.x += y.x, m.y += y.y, m.z += y.z, m.normalize(), l.push(m.x, m.y, m.z), y.copy(v) }for (let x = 0; x <= t; x++) { const A = r + x * u * i, E = Math.sin(A), w = Math.cos(A); for (let b = 0; b <= e.length - 1; b++) { d.x = e[b].x * E, d.y = e[b].y, d.z = e[b].x * w, s.push(d.x, d.y, d.z), p.x = x / t, p.y = b / (e.length - 1), a.push(p.x, p.y); const T = l[3 * b + 0] * E, B = l[3 * b + 1], R = l[3 * b + 0] * w; c.push(T, B, R) } } for (let x = 0; x < t; x++)for (let A = 0; A < e.length - 1; A++) { const E = A + x * e.length, w = E, b = E + e.length, T = E + e.length + 1, B = E + 1; o.push(w, b, B), o.push(T, B, b) } this.setIndex(o), this.setAttribute("position", new ut(s, 3)), this.setAttribute("uv", new ut(a, 2)), this.setAttribute("normal", new ut(c, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Vp(e.points, e.segments, e.phiStart, e.phiLength) } } class Ay extends Vp { constructor(e = 1, t = 1, r = 4, i = 8) { const o = new hp; o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * .5), super(o.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: r, radialSegments: i } } static fromJSON(e) { return new Ay(e.radius, e.length, e.capSegments, e.radialSegments) } } class Ey extends bt { constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: r, thetaLength: i }, t = Math.max(3, t); const o = [], s = [], a = [], l = [], c = new X, u = new Be; s.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5); for (let d = 0, p = 3; d <= t; d++, p += 3) { const m = r + d / t * i; c.x = e * Math.cos(m), c.y = e * Math.sin(m), s.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (s[p] / e + 1) / 2, u.y = (s[p + 1] / e + 1) / 2, l.push(u.x, u.y) } for (let d = 1; d <= t; d++)o.push(d, d + 1, 0); this.setIndex(o), this.setAttribute("position", new ut(s, 3)), this.setAttribute("normal", new ut(a, 3)), this.setAttribute("uv", new ut(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ey(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class ld extends bt { constructor(e = 1, t = 1, r = 1, i = 32, o = 1, s = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: r, radialSegments: i, heightSegments: o, openEnded: s, thetaStart: a, thetaLength: l }; const c = this; i = Math.floor(i), o = Math.floor(o); const u = [], d = [], p = [], m = []; let v = 0; const y = [], _ = r / 2; let g = 0; x(), s === !1 && (e > 0 && A(!0), t > 0 && A(!1)), this.setIndex(u), this.setAttribute("position", new ut(d, 3)), this.setAttribute("normal", new ut(p, 3)), this.setAttribute("uv", new ut(m, 2)); function x() { const E = new X, w = new X; let b = 0; const T = (t - e) / r; for (let B = 0; B <= o; B++) { const R = [], P = B / o, U = P * (t - e) + e; for (let G = 0; G <= i; G++) { const $ = G / i, z = $ * l + a, j = Math.sin(z), q = Math.cos(z); w.x = U * j, w.y = -P * r + _, w.z = U * q, d.push(w.x, w.y, w.z), E.set(j, T, q).normalize(), p.push(E.x, E.y, E.z), m.push($, 1 - P), R.push(v++) } y.push(R) } for (let B = 0; B < i; B++)for (let R = 0; R < o; R++) { const P = y[R][B], U = y[R + 1][B], G = y[R + 1][B + 1], $ = y[R][B + 1]; u.push(P, U, $), u.push(U, G, $), b += 6 } c.addGroup(g, b, 0), g += b } function A(E) { const w = v, b = new Be, T = new X; let B = 0; const R = E === !0 ? e : t, P = E === !0 ? 1 : -1; for (let G = 1; G <= i; G++)d.push(0, _ * P, 0), p.push(0, P, 0), m.push(.5, .5), v++; const U = v; for (let G = 0; G <= i; G++) { const z = G / i * l + a, j = Math.cos(z), q = Math.sin(z); T.x = R * q, T.y = _ * P, T.z = R * j, d.push(T.x, T.y, T.z), p.push(0, P, 0), b.x = j * .5 + .5, b.y = q * .5 * P + .5, m.push(b.x, b.y), v++ } for (let G = 0; G < i; G++) { const $ = w + G, z = U + G; E === !0 ? u.push(z, z + 1, $) : u.push(z + 1, z, $), B += 3 } c.addGroup(g, B, E === !0 ? 1 : 2), g += B } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new ld(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class My extends ld { constructor(e = 1, t = 1, r = 32, i = 1, o = !1, s = 0, a = Math.PI * 2) { super(0, e, t, r, i, o, s, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: s, thetaLength: a } } static fromJSON(e) { return new My(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Pl extends bt { constructor(e = [], t = [], r = 1, i = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: r, detail: i }; const o = [], s = []; a(i), c(r), u(), this.setAttribute("position", new ut(o, 3)), this.setAttribute("normal", new ut(o.slice(), 3)), this.setAttribute("uv", new ut(s, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a(x) { const A = new X, E = new X, w = new X; for (let b = 0; b < t.length; b += 3)m(t[b + 0], A), m(t[b + 1], E), m(t[b + 2], w), l(A, E, w, x) } function l(x, A, E, w) { const b = w + 1, T = []; for (let B = 0; B <= b; B++) { T[B] = []; const R = x.clone().lerp(E, B / b), P = A.clone().lerp(E, B / b), U = b - B; for (let G = 0; G <= U; G++)G === 0 && B === b ? T[B][G] = R : T[B][G] = R.clone().lerp(P, G / U) } for (let B = 0; B < b; B++)for (let R = 0; R < 2 * (b - B) - 1; R++) { const P = Math.floor(R / 2); R % 2 === 0 ? (p(T[B][P + 1]), p(T[B + 1][P]), p(T[B][P])) : (p(T[B][P + 1]), p(T[B + 1][P + 1]), p(T[B + 1][P])) } } function c(x) { const A = new X; for (let E = 0; E < o.length; E += 3)A.x = o[E + 0], A.y = o[E + 1], A.z = o[E + 2], A.normalize().multiplyScalar(x), o[E + 0] = A.x, o[E + 1] = A.y, o[E + 2] = A.z } function u() { const x = new X; for (let A = 0; A < o.length; A += 3) { x.x = o[A + 0], x.y = o[A + 1], x.z = o[A + 2]; const E = _(x) / 2 / Math.PI + .5, w = g(x) / Math.PI + .5; s.push(E, 1 - w) } v(), d() } function d() { for (let x = 0; x < s.length; x += 6) { const A = s[x + 0], E = s[x + 2], w = s[x + 4], b = Math.max(A, E, w), T = Math.min(A, E, w); b > .9 && T < .1 && (A < .2 && (s[x + 0] += 1), E < .2 && (s[x + 2] += 1), w < .2 && (s[x + 4] += 1)) } } function p(x) { o.push(x.x, x.y, x.z) } function m(x, A) { const E = x * 3; A.x = e[E + 0], A.y = e[E + 1], A.z = e[E + 2] } function v() { const x = new X, A = new X, E = new X, w = new X, b = new Be, T = new Be, B = new Be; for (let R = 0, P = 0; R < o.length; R += 9, P += 6) { x.set(o[R + 0], o[R + 1], o[R + 2]), A.set(o[R + 3], o[R + 4], o[R + 5]), E.set(o[R + 6], o[R + 7], o[R + 8]), b.set(s[P + 0], s[P + 1]), T.set(s[P + 2], s[P + 3]), B.set(s[P + 4], s[P + 5]), w.copy(x).add(A).add(E).divideScalar(3); const U = _(w); y(b, P + 0, x, U), y(T, P + 2, A, U), y(B, P + 4, E, U) } } function y(x, A, E, w) { w < 0 && x.x === 1 && (s[A] = x.x - 1), E.x === 0 && E.z === 0 && (s[A] = w / 2 / Math.PI + .5) } function _(x) { return Math.atan2(x.z, -x.x) } function g(x) { return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Pl(e.vertices, e.indices, e.radius, e.details) } } class wy extends Pl { constructor(e = 1, t = 0) { const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i], s = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(o, s, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new wy(e.radius, e.detail) } } const Vg = new X, Wg = new X, gx = new X, jg = new Ci; class aO extends bt { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const i = Math.pow(10, 4), o = Math.cos(Pc * t), s = e.getIndex(), a = e.getAttribute("position"), l = s ? s.count : a.count, c = [0, 0, 0], u = ["a", "b", "c"], d = new Array(3), p = {}, m = []; for (let v = 0; v < l; v += 3) { s ? (c[0] = s.getX(v), c[1] = s.getX(v + 1), c[2] = s.getX(v + 2)) : (c[0] = v, c[1] = v + 1, c[2] = v + 2); const { a: y, b: _, c: g } = jg; if (y.fromBufferAttribute(a, c[0]), _.fromBufferAttribute(a, c[1]), g.fromBufferAttribute(a, c[2]), jg.getNormal(gx), d[0] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(y.z * i)}`, d[1] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(_.z * i)}`, d[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(g.z * i)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let x = 0; x < 3; x++) { const A = (x + 1) % 3, E = d[x], w = d[A], b = jg[u[x]], T = jg[u[A]], B = `${E}_${w}`, R = `${w}_${E}`; R in p && p[R] ? (gx.dot(p[R].normal) <= o && (m.push(b.x, b.y, b.z), m.push(T.x, T.y, T.z)), p[R] = null) : B in p || (p[B] = { index0: c[x], index1: c[A], normal: gx.clone() }) } } for (const v in p) if (p[v]) { const { index0: y, index1: _ } = p[v]; Vg.fromBufferAttribute(a, y), Wg.fromBufferAttribute(a, _), m.push(Vg.x, Vg.y, Vg.z), m.push(Wg.x, Wg.y, Wg.z) } this.setAttribute("position", new ut(m, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class Ic extends hp { constructor(e) { super(e), this.uuid = to(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let r = 0, i = this.holes.length; r < i; r++)t[r] = this.holes[r].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, r = e.holes.length; t < r; t++) { const i = e.holes[t]; this.holes.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, r = this.holes.length; t < r; t++) { const i = this.holes[t]; e.holes.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, r = e.holes.length; t < r; t++) { const i = e.holes[t]; this.holes.push(new hp().fromJSON(i)) } return this } } const f6 = { triangulate: function (n, e, t = 2) { const r = e && e.length, i = r ? e[0] * t : n.length; let o = lO(n, 0, i, t, !0); const s = []; if (!o || o.next === o.prev) return s; let a, l, c, u, d, p, m; if (r && (o = g6(n, e, o, t)), n.length > 80 * t) { a = c = n[0], l = u = n[1]; for (let v = t; v < i; v += t)d = n[v], p = n[v + 1], d < a && (a = d), p < l && (l = p), d > c && (c = d), p > u && (u = p); m = Math.max(c - a, u - l), m = m !== 0 ? 32767 / m : 0 } return pp(o, s, t, a, l, m, 0), s } }; function lO(n, e, t, r, i) { let o, s; if (i === C6(n, e, t, r) > 0) for (o = e; o < t; o += r)s = Q2(o, n[o], n[o + 1], s); else for (o = t - r; o >= e; o -= r)s = Q2(o, n[o], n[o + 1], s); return s && by(s, s.next) && (gp(s), s = s.next), s } function Wc(n, e) { if (!n) return n; e || (e = n); let t = n, r; do if (r = !1, !t.steiner && (by(t, t.next) || Bn(t.prev, t, t.next) === 0)) { if (gp(t), t = e = t.prev, t === t.next) break; r = !0 } else t = t.next; while (r || t !== e); return e } function pp(n, e, t, r, i, o, s) { if (!n) return; !s && o && S6(n, r, i, o); let a = n, l, c; for (; n.prev !== n.next;) { if (l = n.prev, c = n.next, o ? h6(n, r, i, o) : d6(n)) { e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(c.i / t | 0), gp(n), n = c.next, a = c.next; continue } if (n = c, n === a) { s ? s === 1 ? (n = p6(Wc(n), e, t), pp(n, e, t, r, i, o, 2)) : s === 2 && m6(n, e, t, r, i, o) : pp(Wc(n), e, t, r, i, o, 1); break } } } function d6(n) { const e = n.prev, t = n, r = n.next; if (Bn(e, t, r) >= 0) return !1; const i = e.x, o = t.x, s = r.x, a = e.y, l = t.y, c = r.y, u = i < o ? i < s ? i : s : o < s ? o : s, d = a < l ? a < c ? a : c : l < c ? l : c, p = i > o ? i > s ? i : s : o > s ? o : s, m = a > l ? a > c ? a : c : l > c ? l : c; let v = r.next; for (; v !== e;) { if (v.x >= u && v.x <= p && v.y >= d && v.y <= m && hf(i, a, o, l, s, c, v.x, v.y) && Bn(v.prev, v, v.next) >= 0) return !1; v = v.next } return !0 } function h6(n, e, t, r) { const i = n.prev, o = n, s = n.next; if (Bn(i, o, s) >= 0) return !1; const a = i.x, l = o.x, c = s.x, u = i.y, d = o.y, p = s.y, m = a < l ? a < c ? a : c : l < c ? l : c, v = u < d ? u < p ? u : p : d < p ? d : p, y = a > l ? a > c ? a : c : l > c ? l : c, _ = u > d ? u > p ? u : p : d > p ? d : p, g = DA(m, v, e, t, r), x = DA(y, _, e, t, r); let A = n.prevZ, E = n.nextZ; for (; A && A.z >= g && E && E.z <= x;) { if (A.x >= m && A.x <= y && A.y >= v && A.y <= _ && A !== i && A !== s && hf(a, u, l, d, c, p, A.x, A.y) && Bn(A.prev, A, A.next) >= 0 || (A = A.prevZ, E.x >= m && E.x <= y && E.y >= v && E.y <= _ && E !== i && E !== s && hf(a, u, l, d, c, p, E.x, E.y) && Bn(E.prev, E, E.next) >= 0)) return !1; E = E.nextZ } for (; A && A.z >= g;) { if (A.x >= m && A.x <= y && A.y >= v && A.y <= _ && A !== i && A !== s && hf(a, u, l, d, c, p, A.x, A.y) && Bn(A.prev, A, A.next) >= 0) return !1; A = A.prevZ } for (; E && E.z <= x;) { if (E.x >= m && E.x <= y && E.y >= v && E.y <= _ && E !== i && E !== s && hf(a, u, l, d, c, p, E.x, E.y) && Bn(E.prev, E, E.next) >= 0) return !1; E = E.nextZ } return !0 } function p6(n, e, t) { let r = n; do { const i = r.prev, o = r.next.next; !by(i, o) && cO(i, r, r.next, o) && mp(i, o) && mp(o, i) && (e.push(i.i / t | 0), e.push(r.i / t | 0), e.push(o.i / t | 0), gp(r), gp(r.next), r = n = o), r = r.next } while (r !== n); return Wc(r) } function m6(n, e, t, r, i, o) { let s = n; do { let a = s.next.next; for (; a !== s.prev;) { if (s.i !== a.i && M6(s, a)) { let l = uO(s, a); s = Wc(s, s.next), l = Wc(l, l.next), pp(s, e, t, r, i, o, 0), pp(l, e, t, r, i, o, 0); return } a = a.next } s = s.next } while (s !== n) } function g6(n, e, t, r) { const i = []; let o, s, a, l, c; for (o = 0, s = e.length; o < s; o++)a = e[o] * r, l = o < s - 1 ? e[o + 1] * r : n.length, c = lO(n, a, l, r, !1), c === c.next && (c.steiner = !0), i.push(E6(c)); for (i.sort(v6), o = 0; o < i.length; o++)t = y6(i[o], t); return t } function v6(n, e) { return n.x - e.x } function y6(n, e) { const t = _6(n, e); if (!t) return e; const r = uO(t, n); return Wc(r, r.next), Wc(t, t.next) } function _6(n, e) { let t = e, r = -1 / 0, i; const o = n.x, s = n.y; do { if (s <= t.y && s >= t.next.y && t.next.y !== t.y) { const p = t.x + (s - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (p <= o && p > r && (r = p, i = t.x < t.next.x ? t : t.next, p === o)) return i } t = t.next } while (t !== e); if (!i) return null; const a = i, l = i.x, c = i.y; let u = 1 / 0, d; t = i; do o >= t.x && t.x >= l && o !== t.x && hf(s < c ? o : r, s, l, c, s < c ? r : o, s, t.x, t.y) && (d = Math.abs(s - t.y) / (o - t.x), mp(t, n) && (d < u || d === u && (t.x > i.x || t.x === i.x && x6(i, t))) && (i = t, u = d)), t = t.next; while (t !== a); return i } function x6(n, e) { return Bn(n.prev, n, e.prev) < 0 && Bn(e.next, n, n.next) < 0 } function S6(n, e, t, r) { let i = n; do i.z === 0 && (i.z = DA(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== n); i.prevZ.nextZ = null, i.prevZ = null, A6(i) } function A6(n) { let e, t, r, i, o, s, a, l, c = 1; do { for (t = n, n = null, o = null, s = 0; t;) { for (s++, r = t, a = 0, e = 0; e < c && (a++, r = r.nextZ, !!r); e++); for (l = c; a > 0 || l > 0 && r;)a !== 0 && (l === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, a--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : n = i, i.prevZ = o, o = i; t = r } o.nextZ = null, c *= 2 } while (s > 1); return n } function DA(n, e, t, r, i) { return n = (n - t) * i | 0, e = (e - r) * i | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1 } function E6(n) { let e = n, t = n; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n); return t } function hf(n, e, t, r, i, o, s, a) { return (i - s) * (e - a) >= (n - s) * (o - a) && (n - s) * (r - a) >= (t - s) * (e - a) && (t - s) * (o - a) >= (i - s) * (r - a) } function M6(n, e) { return n.next.i !== e.i && n.prev.i !== e.i && !w6(n, e) && (mp(n, e) && mp(e, n) && b6(n, e) && (Bn(n.prev, n, e.prev) || Bn(n, e.prev, e)) || by(n, e) && Bn(n.prev, n, n.next) > 0 && Bn(e.prev, e, e.next) > 0) } function Bn(n, e, t) { return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y) } function by(n, e) { return n.x === e.x && n.y === e.y } function cO(n, e, t, r) { const i = Jg(Bn(n, e, t)), o = Jg(Bn(n, e, r)), s = Jg(Bn(t, r, n)), a = Jg(Bn(t, r, e)); return !!(i !== o && s !== a || i === 0 && Xg(n, t, e) || o === 0 && Xg(n, r, e) || s === 0 && Xg(t, n, r) || a === 0 && Xg(t, e, r)) } function Xg(n, e, t) { return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y) } function Jg(n) { return n > 0 ? 1 : n < 0 ? -1 : 0 } function w6(n, e) { let t = n; do { if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && cO(t, t.next, n, e)) return !0; t = t.next } while (t !== n); return !1 } function mp(n, e) { return Bn(n.prev, n, n.next) < 0 ? Bn(n, e, n.next) >= 0 && Bn(n, n.prev, e) >= 0 : Bn(n, e, n.prev) < 0 || Bn(n, n.next, e) < 0 } function b6(n, e) { let t = n, r = !1; const i = (n.x + e.x) / 2, o = (n.y + e.y) / 2; do t.y > o != t.next.y > o && t.next.y !== t.y && i < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next; while (t !== n); return r } function uO(n, e) { const t = new OA(n.i, n.x, n.y), r = new OA(e.i, e.x, e.y), i = n.next, o = e.prev; return n.next = e, e.prev = n, t.next = i, i.prev = t, r.next = t, t.prev = r, o.next = r, r.prev = o, r } function Q2(n, e, t, r) { const i = new OA(n, e, t); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function gp(n) { n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ) } function OA(n, e, t) { this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function C6(n, e, t, r) { let i = 0; for (let o = e, s = t - r; o < t; o += r)i += (n[s] - n[o]) * (n[o + 1] + n[s + 1]), s = o; return i } class Rs { static area(e) { const t = e.length; let r = 0; for (let i = t - 1, o = 0; o < t; i = o++)r += e[i].x * e[o].y - e[o].x * e[i].y; return r * .5 } static isClockWise(e) { return Rs.area(e) < 0 } static triangulateShape(e, t) { const r = [], i = [], o = []; Z2(e), q2(r, e); let s = e.length; t.forEach(Z2); for (let l = 0; l < t.length; l++)i.push(s), s += t[l].length, q2(r, t[l]); const a = f6.triangulate(r, i); for (let l = 0; l < a.length; l += 3)o.push(a.slice(l, l + 3)); return o } } function Z2(n) { const e = n.length; e > 2 && n[e - 1].equals(n[0]) && n.pop() } function q2(n, e) { for (let t = 0; t < e.length; t++)n.push(e[t].x), n.push(e[t].y) } class Cy extends bt { constructor(e = new Ic([new Be(.5, .5), new Be(-.5, .5), new Be(-.5, -.5), new Be(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const r = this, i = [], o = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a]; s(c) } this.setAttribute("position", new ut(i, 3)), this.setAttribute("uv", new ut(o, 2)), this.computeVertexNormals(); function s(a) { const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1; let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, v = t.bevelSize !== void 0 ? t.bevelSize : m - .1, y = t.bevelOffset !== void 0 ? t.bevelOffset : 0, _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const g = t.extrudePath, x = t.UVGenerator !== void 0 ? t.UVGenerator : T6; let A, E = !1, w, b, T, B; g && (A = g.getSpacedPoints(u), E = !0, p = !1, w = g.computeFrenetFrames(u, !1), b = new X, T = new X, B = new X), p || (_ = 0, m = 0, v = 0, y = 0); const R = a.extractPoints(c); let P = R.shape; const U = R.holes; if (!Rs.isClockWise(P)) { P = P.reverse(); for (let F = 0, me = U.length; F < me; F++) { const he = U[F]; Rs.isClockWise(he) && (U[F] = he.reverse()) } } const $ = Rs.triangulateShape(P, U), z = P; for (let F = 0, me = U.length; F < me; F++) { const he = U[F]; P = P.concat(he) } function j(F, me, he) { return me || console.error("THREE.ExtrudeGeometry: vec does not exist"), F.clone().addScaledVector(me, he) } const q = P.length, se = $.length; function W(F, me, he) { let ce, fe, Re; const de = F.x - me.x, Ie = F.y - me.y, we = he.x - F.x, ge = he.y - F.y, Ve = de * de + Ie * Ie, H = de * ge - Ie * we; if (Math.abs(H) > Number.EPSILON) { const L = Math.sqrt(Ve), oe = Math.sqrt(we * we + ge * ge), Pe = me.x - Ie / L, Ae = me.y + de / L, ye = he.x - ge / oe, be = he.y + we / oe, ke = ((ye - Pe) * ge - (be - Ae) * we) / (de * ge - Ie * we); ce = Pe + de * ke - F.x, fe = Ae + Ie * ke - F.y; const He = ce * ce + fe * fe; if (He <= 2) return new Be(ce, fe); Re = Math.sqrt(He / 2) } else { let L = !1; de > Number.EPSILON ? we > Number.EPSILON && (L = !0) : de < -Number.EPSILON ? we < -Number.EPSILON && (L = !0) : Math.sign(Ie) === Math.sign(ge) && (L = !0), L ? (ce = -Ie, fe = de, Re = Math.sqrt(Ve)) : (ce = de, fe = Ie, Re = Math.sqrt(Ve / 2)) } return new Be(ce / Re, fe / Re) } const V = []; for (let F = 0, me = z.length, he = me - 1, ce = F + 1; F < me; F++, he++, ce++)he === me && (he = 0), ce === me && (ce = 0), V[F] = W(z[F], z[he], z[ce]); const J = []; let O, k = V.concat(); for (let F = 0, me = U.length; F < me; F++) { const he = U[F]; O = []; for (let ce = 0, fe = he.length, Re = fe - 1, de = ce + 1; ce < fe; ce++, Re++, de++)Re === fe && (Re = 0), de === fe && (de = 0), O[ce] = W(he[ce], he[Re], he[de]); J.push(O), k = k.concat(O) } for (let F = 0; F < _; F++) { const me = F / _, he = m * Math.cos(me * Math.PI / 2), ce = v * Math.sin(me * Math.PI / 2) + y; for (let fe = 0, Re = z.length; fe < Re; fe++) { const de = j(z[fe], V[fe], ce); ae(de.x, de.y, -he) } for (let fe = 0, Re = U.length; fe < Re; fe++) { const de = U[fe]; O = J[fe]; for (let Ie = 0, we = de.length; Ie < we; Ie++) { const ge = j(de[Ie], O[Ie], ce); ae(ge.x, ge.y, -he) } } } const Z = v + y; for (let F = 0; F < q; F++) { const me = p ? j(P[F], k[F], Z) : P[F]; E ? (T.copy(w.normals[0]).multiplyScalar(me.x), b.copy(w.binormals[0]).multiplyScalar(me.y), B.copy(A[0]).add(T).add(b), ae(B.x, B.y, B.z)) : ae(me.x, me.y, 0) } for (let F = 1; F <= u; F++)for (let me = 0; me < q; me++) { const he = p ? j(P[me], k[me], Z) : P[me]; E ? (T.copy(w.normals[F]).multiplyScalar(he.x), b.copy(w.binormals[F]).multiplyScalar(he.y), B.copy(A[F]).add(T).add(b), ae(B.x, B.y, B.z)) : ae(he.x, he.y, d / u * F) } for (let F = _ - 1; F >= 0; F--) { const me = F / _, he = m * Math.cos(me * Math.PI / 2), ce = v * Math.sin(me * Math.PI / 2) + y; for (let fe = 0, Re = z.length; fe < Re; fe++) { const de = j(z[fe], V[fe], ce); ae(de.x, de.y, d + he) } for (let fe = 0, Re = U.length; fe < Re; fe++) { const de = U[fe]; O = J[fe]; for (let Ie = 0, we = de.length; Ie < we; Ie++) { const ge = j(de[Ie], O[Ie], ce); E ? ae(ge.x, ge.y + A[u - 1].y, A[u - 1].x + he) : ae(ge.x, ge.y, d + he) } } } ee(), ne(); function ee() { const F = i.length / 3; if (p) { let me = 0, he = q * me; for (let ce = 0; ce < se; ce++) { const fe = $[ce]; ie(fe[2] + he, fe[1] + he, fe[0] + he) } me = u + _ * 2, he = q * me; for (let ce = 0; ce < se; ce++) { const fe = $[ce]; ie(fe[0] + he, fe[1] + he, fe[2] + he) } } else { for (let me = 0; me < se; me++) { const he = $[me]; ie(he[2], he[1], he[0]) } for (let me = 0; me < se; me++) { const he = $[me]; ie(he[0] + q * u, he[1] + q * u, he[2] + q * u) } } r.addGroup(F, i.length / 3 - F, 0) } function ne() { const F = i.length / 3; let me = 0; K(z, me), me += z.length; for (let he = 0, ce = U.length; he < ce; he++) { const fe = U[he]; K(fe, me), me += fe.length } r.addGroup(F, i.length / 3 - F, 1) } function K(F, me) { let he = F.length; for (; --he >= 0;) { const ce = he; let fe = he - 1; fe < 0 && (fe = F.length - 1); for (let Re = 0, de = u + _ * 2; Re < de; Re++) { const Ie = q * Re, we = q * (Re + 1), ge = me + ce + Ie, Ve = me + fe + Ie, H = me + fe + we, L = me + ce + we; Se(ge, Ve, H, L) } } } function ae(F, me, he) { l.push(F), l.push(me), l.push(he) } function ie(F, me, he) { Ce(F), Ce(me), Ce(he); const ce = i.length / 3, fe = x.generateTopUV(r, i, ce - 3, ce - 2, ce - 1); le(fe[0]), le(fe[1]), le(fe[2]) } function Se(F, me, he, ce) { Ce(F), Ce(me), Ce(ce), Ce(me), Ce(he), Ce(ce); const fe = i.length / 3, Re = x.generateSideWallUV(r, i, fe - 6, fe - 3, fe - 2, fe - 1); le(Re[0]), le(Re[1]), le(Re[3]), le(Re[1]), le(Re[2]), le(Re[3]) } function Ce(F) { i.push(l[F * 3 + 0]), i.push(l[F * 3 + 1]), i.push(l[F * 3 + 2]) } function le(F) { o.push(F.x), o.push(F.y) } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options; return R6(t, r, e) } static fromJSON(e, t) { const r = []; for (let o = 0, s = e.shapes.length; o < s; o++) { const a = t[e.shapes[o]]; r.push(a) } const i = e.options.extrudePath; return i !== void 0 && (e.options.extrudePath = new Mv[i.type]().fromJSON(i)), new Cy(r, e.options) } } const T6 = { generateTopUV: function (n, e, t, r, i) { const o = e[t * 3], s = e[t * 3 + 1], a = e[r * 3], l = e[r * 3 + 1], c = e[i * 3], u = e[i * 3 + 1]; return [new Be(o, s), new Be(a, l), new Be(c, u)] }, generateSideWallUV: function (n, e, t, r, i, o) { const s = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[r * 3], u = e[r * 3 + 1], d = e[r * 3 + 2], p = e[i * 3], m = e[i * 3 + 1], v = e[i * 3 + 2], y = e[o * 3], _ = e[o * 3 + 1], g = e[o * 3 + 2]; return Math.abs(a - u) < Math.abs(s - c) ? [new Be(s, 1 - l), new Be(c, 1 - d), new Be(p, 1 - v), new Be(y, 1 - g)] : [new Be(a, 1 - l), new Be(u, 1 - d), new Be(m, 1 - v), new Be(_, 1 - g)] } }; function R6(n, e, t) { if (t.shapes = [], Array.isArray(n)) for (let r = 0, i = n.length; r < i; r++) { const o = n[r]; t.shapes.push(o.uuid) } else t.shapes.push(n.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class Ty extends Pl { constructor(e = 1, t = 0) { const r = (1 + Math.sqrt(5)) / 2, i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(i, o, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Ty(e.radius, e.detail) } } class Wp extends Pl { constructor(e = 1, t = 0) { const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Wp(e.radius, e.detail) } } class Ry extends bt { constructor(e = .5, t = 1, r = 32, i = 1, o = 0, s = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: r, phiSegments: i, thetaStart: o, thetaLength: s }, r = Math.max(3, r), i = Math.max(1, i); const a = [], l = [], c = [], u = []; let d = e; const p = (t - e) / i, m = new X, v = new Be; for (let y = 0; y <= i; y++) { for (let _ = 0; _ <= r; _++) { const g = o + _ / r * s; m.x = d * Math.cos(g), m.y = d * Math.sin(g), l.push(m.x, m.y, m.z), c.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, u.push(v.x, v.y) } d += p } for (let y = 0; y < i; y++) { const _ = y * (r + 1); for (let g = 0; g < r; g++) { const x = g + _, A = x, E = x + r + 1, w = x + r + 2, b = x + 1; a.push(A, E, b), a.push(E, w, b) } } this.setIndex(a), this.setAttribute("position", new ut(l, 3)), this.setAttribute("normal", new ut(c, 3)), this.setAttribute("uv", new ut(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ry(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class Py extends bt { constructor(e = new Ic([new Be(0, .5), new Be(-.5, -.5), new Be(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const r = [], i = [], o = [], s = []; let a = 0, l = 0; if (Array.isArray(e) === !1) c(e); else for (let u = 0; u < e.length; u++)c(e[u]), this.addGroup(a, l, u), a += l, l = 0; this.setIndex(r), this.setAttribute("position", new ut(i, 3)), this.setAttribute("normal", new ut(o, 3)), this.setAttribute("uv", new ut(s, 2)); function c(u) { const d = i.length / 3, p = u.extractPoints(t); let m = p.shape; const v = p.holes; Rs.isClockWise(m) === !1 && (m = m.reverse()); for (let _ = 0, g = v.length; _ < g; _++) { const x = v[_]; Rs.isClockWise(x) === !0 && (v[_] = x.reverse()) } const y = Rs.triangulateShape(m, v); for (let _ = 0, g = v.length; _ < g; _++) { const x = v[_]; m = m.concat(x) } for (let _ = 0, g = m.length; _ < g; _++) { const x = m[_]; i.push(x.x, x.y, 0), o.push(0, 0, 1), s.push(x.x, x.y) } for (let _ = 0, g = y.length; _ < g; _++) { const x = y[_], A = x[0] + d, E = x[1] + d, w = x[2] + d; r.push(A, E, w), l += 3 } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return P6(t, e) } static fromJSON(e, t) { const r = []; for (let i = 0, o = e.shapes.length; i < o; i++) { const s = t[e.shapes[i]]; r.push(s) } return new Py(r, e.curveSegments) } } function P6(n, e) { if (e.shapes = [], Array.isArray(n)) for (let t = 0, r = n.length; t < r; t++) { const i = n[t]; e.shapes.push(i.uuid) } else e.shapes.push(n.uuid); return e } class jp extends bt { constructor(e = 1, t = 32, r = 16, i = 0, o = Math.PI * 2, s = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: r, phiStart: i, phiLength: o, thetaStart: s, thetaLength: a }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r)); const l = Math.min(s + a, Math.PI); let c = 0; const u = [], d = new X, p = new X, m = [], v = [], y = [], _ = []; for (let g = 0; g <= r; g++) { const x = [], A = g / r; let E = 0; g === 0 && s === 0 ? E = .5 / t : g === r && l === Math.PI && (E = -.5 / t); for (let w = 0; w <= t; w++) { const b = w / t; d.x = -e * Math.cos(i + b * o) * Math.sin(s + A * a), d.y = e * Math.cos(s + A * a), d.z = e * Math.sin(i + b * o) * Math.sin(s + A * a), v.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), _.push(b + E, 1 - A), x.push(c++) } u.push(x) } for (let g = 0; g < r; g++)for (let x = 0; x < t; x++) { const A = u[g][x + 1], E = u[g][x], w = u[g + 1][x], b = u[g + 1][x + 1]; (g !== 0 || s > 0) && m.push(A, E, b), (g !== r - 1 || l < Math.PI) && m.push(E, w, b) } this.setIndex(m), this.setAttribute("position", new ut(v, 3)), this.setAttribute("normal", new ut(y, 3)), this.setAttribute("uv", new ut(_, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new jp(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class By extends Pl { constructor(e = 1, t = 0) { const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new By(e.radius, e.detail) } } class Iy extends bt { constructor(e = 1, t = .4, r = 12, i = 48, o = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: r, tubularSegments: i, arc: o }, r = Math.floor(r), i = Math.floor(i); const s = [], a = [], l = [], c = [], u = new X, d = new X, p = new X; for (let m = 0; m <= r; m++)for (let v = 0; v <= i; v++) { const y = v / i * o, _ = m / r * Math.PI * 2; d.x = (e + t * Math.cos(_)) * Math.cos(y), d.y = (e + t * Math.cos(_)) * Math.sin(y), d.z = t * Math.sin(_), a.push(d.x, d.y, d.z), u.x = e * Math.cos(y), u.y = e * Math.sin(y), p.subVectors(d, u).normalize(), l.push(p.x, p.y, p.z), c.push(v / i), c.push(m / r) } for (let m = 1; m <= r; m++)for (let v = 1; v <= i; v++) { const y = (i + 1) * m + v - 1, _ = (i + 1) * (m - 1) + v - 1, g = (i + 1) * (m - 1) + v, x = (i + 1) * m + v; s.push(y, _, x), s.push(_, g, x) } this.setIndex(s), this.setAttribute("position", new ut(a, 3)), this.setAttribute("normal", new ut(l, 3)), this.setAttribute("uv", new ut(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Iy(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class Ly extends bt { constructor(e = 1, t = .4, r = 64, i = 8, o = 2, s = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: r, radialSegments: i, p: o, q: s }, r = Math.floor(r), i = Math.floor(i); const a = [], l = [], c = [], u = [], d = new X, p = new X, m = new X, v = new X, y = new X, _ = new X, g = new X; for (let A = 0; A <= r; ++A) { const E = A / r * o * Math.PI * 2; x(E, o, s, e, m), x(E + .01, o, s, e, v), _.subVectors(v, m), g.addVectors(v, m), y.crossVectors(_, g), g.crossVectors(y, _), y.normalize(), g.normalize(); for (let w = 0; w <= i; ++w) { const b = w / i * Math.PI * 2, T = -t * Math.cos(b), B = t * Math.sin(b); d.x = m.x + (T * g.x + B * y.x), d.y = m.y + (T * g.y + B * y.y), d.z = m.z + (T * g.z + B * y.z), l.push(d.x, d.y, d.z), p.subVectors(d, m).normalize(), c.push(p.x, p.y, p.z), u.push(A / r), u.push(w / i) } } for (let A = 1; A <= r; A++)for (let E = 1; E <= i; E++) { const w = (i + 1) * (A - 1) + (E - 1), b = (i + 1) * A + (E - 1), T = (i + 1) * A + E, B = (i + 1) * (A - 1) + E; a.push(w, b, B), a.push(b, T, B) } this.setIndex(a), this.setAttribute("position", new ut(l, 3)), this.setAttribute("normal", new ut(c, 3)), this.setAttribute("uv", new ut(u, 2)); function x(A, E, w, b, T) { const B = Math.cos(A), R = Math.sin(A), P = w / E * A, U = Math.cos(P); T.x = b * (2 + U) * .5 * B, T.y = b * (2 + U) * R * .5, T.z = b * Math.sin(P) * .5 } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ly(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Dy extends bt { constructor(e = new $M(new X(-1, -1, 0), new X(-1, 1, 0), new X(1, 1, 0)), t = 64, r = 1, i = 8, o = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: r, radialSegments: i, closed: o }; const s = e.computeFrenetFrames(t, o); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; const a = new X, l = new X, c = new Be; let u = new X; const d = [], p = [], m = [], v = []; y(), this.setIndex(v), this.setAttribute("position", new ut(d, 3)), this.setAttribute("normal", new ut(p, 3)), this.setAttribute("uv", new ut(m, 2)); function y() { for (let A = 0; A < t; A++)_(A); _(o === !1 ? t : 0), x(), g() } function _(A) { u = e.getPointAt(A / t, u); const E = s.normals[A], w = s.binormals[A]; for (let b = 0; b <= i; b++) { const T = b / i * Math.PI * 2, B = Math.sin(T), R = -Math.cos(T); l.x = R * E.x + B * w.x, l.y = R * E.y + B * w.y, l.z = R * E.z + B * w.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = u.x + r * l.x, a.y = u.y + r * l.y, a.z = u.z + r * l.z, d.push(a.x, a.y, a.z) } } function g() { for (let A = 1; A <= t; A++)for (let E = 1; E <= i; E++) { const w = (i + 1) * (A - 1) + (E - 1), b = (i + 1) * A + (E - 1), T = (i + 1) * A + E, B = (i + 1) * (A - 1) + E; v.push(w, b, B), v.push(b, T, B) } } function x() { for (let A = 0; A <= t; A++)for (let E = 0; E <= i; E++)c.x = A / t, c.y = E / i, m.push(c.x, c.y) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Dy(new Mv[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class ZM extends bt { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], r = new Set, i = new X, o = new X; if (e.index !== null) { const s = e.attributes.position, a = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let c = 0, u = l.length; c < u; ++c) { const d = l[c], p = d.start, m = d.count; for (let v = p, y = p + m; v < y; v += 3)for (let _ = 0; _ < 3; _++) { const g = a.getX(v + _), x = a.getX(v + (_ + 1) % 3); i.fromBufferAttribute(s, g), o.fromBufferAttribute(s, x), eR(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z)) } } } else { const s = e.attributes.position; for (let a = 0, l = s.count / 3; a < l; a++)for (let c = 0; c < 3; c++) { const u = 3 * a + c, d = 3 * a + (c + 1) % 3; i.fromBufferAttribute(s, u), o.fromBufferAttribute(s, d), eR(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z)) } } this.setAttribute("position", new ut(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function eR(n, e, t) { const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`; return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0) } var tR = Object.freeze({ __proto__: null, BoxGeometry: qc, CapsuleGeometry: Ay, CircleGeometry: Ey, ConeGeometry: My, CylinderGeometry: ld, DodecahedronGeometry: wy, EdgesGeometry: aO, ExtrudeGeometry: Cy, IcosahedronGeometry: Ty, LatheGeometry: Vp, OctahedronGeometry: Wp, PlaneGeometry: ba, PolyhedronGeometry: Pl, RingGeometry: Ry, ShapeGeometry: Py, SphereGeometry: jp, TetrahedronGeometry: By, TorusGeometry: Iy, TorusKnotGeometry: Ly, TubeGeometry: Dy, WireframeGeometry: ZM }); class fO extends rr { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new qe(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class dO extends _r { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class Xp extends rr { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new qe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class ks extends Xp { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Be(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return Hn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new qe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new qe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new qe(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class hO extends rr { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new qe(16777215), this.specular = new qe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Op, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class pO extends rr { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new qe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class mO extends rr { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class gO extends rr { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Op, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class vO extends rr { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new qe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rl, this.normalScale = new Be(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class yO extends qr { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function Ec(n, e, t) { return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n) } function _O(n) { return ArrayBuffer.isView(n) && !(n instanceof DataView) } function xO(n) { function e(i, o) { return n[i] - n[o] } const t = n.length, r = new Array(t); for (let i = 0; i !== t; ++i)r[i] = i; return r.sort(e), r } function FA(n, e, t) { const r = n.length, i = new n.constructor(r); for (let o = 0, s = 0; s !== r; ++o) { const a = t[o] * e; for (let l = 0; l !== e; ++l)i[s++] = n[a + l] } return i } function qM(n, e, t, r) { let i = 1, o = n[0]; for (; o !== void 0 && o[r] === void 0;)o = n[i++]; if (o === void 0) return; let s = o[r]; if (s !== void 0) if (Array.isArray(s)) do s = o[r], s !== void 0 && (e.push(o.time), t.push.apply(t, s)), o = n[i++]; while (o !== void 0); else if (s.toArray !== void 0) do s = o[r], s !== void 0 && (e.push(o.time), s.toArray(t, t.length)), o = n[i++]; while (o !== void 0); else do s = o[r], s !== void 0 && (e.push(o.time), t.push(s)), o = n[i++]; while (o !== void 0) } function B6(n, e, t, r, i = 30) { const o = n.clone(); o.name = e; const s = []; for (let l = 0; l < o.tracks.length; ++l) { const c = o.tracks[l], u = c.getValueSize(), d = [], p = []; for (let m = 0; m < c.times.length; ++m) { const v = c.times[m] * i; if (!(v < t || v >= r)) { d.push(c.times[m]); for (let y = 0; y < u; ++y)p.push(c.values[m * u + y]) } } d.length !== 0 && (c.times = Ec(d, c.times.constructor), c.values = Ec(p, c.values.constructor), s.push(c)) } o.tracks = s; let a = 1 / 0; for (let l = 0; l < o.tracks.length; ++l)a > o.tracks[l].times[0] && (a = o.tracks[l].times[0]); for (let l = 0; l < o.tracks.length; ++l)o.tracks[l].shift(-1 * a); return o.resetDuration(), o } function I6(n, e = 0, t = n, r = 30) { r <= 0 && (r = 30); const i = t.tracks.length, o = e / r; for (let s = 0; s < i; ++s) { const a = t.tracks[s], l = a.ValueTypeName; if (l === "bool" || l === "string") continue; const c = n.tracks.find(function (g) { return g.name === a.name && g.ValueTypeName === l }); if (c === void 0) continue; let u = 0; const d = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = d / 3); let p = 0; const m = c.getValueSize(); c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3); const v = a.times.length - 1; let y; if (o <= a.times[0]) { const g = u, x = d - u; y = a.values.slice(g, x) } else if (o >= a.times[v]) { const g = v * d + u, x = g + d - u; y = a.values.slice(g, x) } else { const g = a.createInterpolant(), x = u, A = d - u; g.evaluate(o), y = g.resultBuffer.slice(x, A) } l === "quaternion" && new Sr().fromArray(y).normalize().conjugate().toArray(y); const _ = c.times.length; for (let g = 0; g < _; ++g) { const x = g * m + p; if (l === "quaternion") Sr.multiplyQuaternionsFlat(c.values, x, y, 0, c.values, x); else { const A = m - p * 2; for (let E = 0; E < A; ++E)c.values[x + E] -= y[E] } } } return n.blendMode = PM, n } const L6 = { convertArray: Ec, isTypedArray: _O, getKeyframeOrder: xO, sortedArray: FA, flattenJSON: qM, subclip: B6, makeClipAdditive: I6 }; class cd { constructor(e, t, r, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let r = this._cachedIndex, i = t[r], o = t[r - 1]; e: { t: { let s; n: { r: if (!(e < i)) { for (let a = r + 2; ;) { if (i === void 0) { if (e < o) break r; return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } if (r === a) break; if (o = i, i = t[++r], e < i) break t } s = t.length; break n } if (!(e >= o)) { const a = t[1]; e < a && (r = 2, o = a); for (let l = r - 2; ;) { if (o === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === l) break; if (i = o, o = t[--r - 1], e >= o) break t } s = r, r = 0; break n } break e } for (; r < s;) { const a = r + s >>> 1; e < t[a] ? s = a : r = a + 1 } if (i = t[r], o = t[r - 1], o === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === void 0) return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } this._cachedIndex = r, this.intervalChanged_(r, o, i) } return this.interpolate_(r, o, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, o = e * i; for (let s = 0; s !== i; ++s)t[s] = r[o + s]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class SO extends cd { constructor(e, t, r, i) { super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: xc, endingEnd: xc } } intervalChanged_(e, t, r) { const i = this.parameterPositions; let o = e - 2, s = e + 1, a = i[o], l = i[s]; if (a === void 0) switch (this.getSettings_().endingStart) { case Sc: o = e, a = 2 * t - r; break; case sp: o = i.length - 2, a = t + i[o] - i[o + 1]; break; default: o = e, a = r }if (l === void 0) switch (this.getSettings_().endingEnd) { case Sc: s = e, l = 2 * r - t; break; case sp: s = 1, l = r + i[1] - i[0]; break; default: s = e - 1, l = t }const c = (r - t) * .5, u = this.valueSize; this._weightPrev = c / (t - a), this._weightNext = c / (l - r), this._offsetPrev = o * u, this._offsetNext = s * u } interpolate_(e, t, r, i) { const o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, m = this._weightNext, v = (r - t) / (i - t), y = v * v, _ = y * v, g = -p * _ + 2 * p * y - p * v, x = (1 + p) * _ + (-1.5 - 2 * p) * y + (-.5 + p) * v + 1, A = (-1 - m) * _ + (1.5 + m) * y + .5 * v, E = m * _ - m * y; for (let w = 0; w !== a; ++w)o[w] = g * s[u + w] + x * s[c + w] + A * s[l + w] + E * s[d + w]; return o } } class ew extends cd { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e, t, r, i) { const o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = (r - t) / (i - t), d = 1 - u; for (let p = 0; p !== a; ++p)o[p] = s[c + p] * d + s[l + p] * u; return o } } class AO extends cd { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class ns { constructor(e, t, r, i) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Ec(t, this.TimeBufferType), this.values = Ec(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let r; if (t.toJSON !== this.toJSON) r = t.toJSON(e); else { r = { name: e.name, times: Ec(e.times, Array), values: Ec(e.values, Array) }; const i = e.getInterpolation(); i !== e.DefaultInterpolation && (r.interpolation = i) } return r.type = e.ValueTypeName, r } InterpolantFactoryMethodDiscrete(e) { return new AO(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new ew(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new SO(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case zf: t = this.InterpolantFactoryMethodDiscrete; break; case Hc: t = this.InterpolantFactoryMethodLinear; break; case F0: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(r); return console.warn("THREE.KeyframeTrack:", r), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return zf; case this.InterpolantFactoryMethodLinear: return Hc; case this.InterpolantFactoryMethodSmooth: return F0 } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let r = 0, i = t.length; r !== i; ++r)t[r] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let r = 0, i = t.length; r !== i; ++r)t[r] *= e } return this } trim(e, t) { const r = this.times, i = r.length; let o = 0, s = i - 1; for (; o !== i && r[o] < e;)++o; for (; s !== -1 && r[s] > t;)--s; if (++s, o !== 0 || s !== i) { o >= s && (s = Math.max(s, 1), o = s - 1); const a = this.getValueSize(); this.times = r.slice(o, s), this.values = this.values.slice(o * a, s * a) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const r = this.times, i = this.values, o = r.length; o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let a = 0; a !== o; a++) { const l = r[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1; break } if (s !== null && s > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, s), e = !1; break } s = l } if (i !== void 0 && _O(i)) for (let a = 0, l = i.length; a !== l; ++a) { const c = i[a]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1; break } } return e } optimize() { const e = this.times.slice(), t = this.values.slice(), r = this.getValueSize(), i = this.getInterpolation() === F0, o = e.length - 1; let s = 1; for (let a = 1; a < o; ++a) { let l = !1; const c = e[a], u = e[a + 1]; if (c !== u && (a !== 1 || c !== e[0])) if (i) l = !0; else { const d = a * r, p = d - r, m = d + r; for (let v = 0; v !== r; ++v) { const y = t[d + v]; if (y !== t[p + v] || y !== t[m + v]) { l = !0; break } } } if (l) { if (a !== s) { e[s] = e[a]; const d = a * r, p = s * r; for (let m = 0; m !== r; ++m)t[p + m] = t[d + m] } ++s } } if (o > 0) { e[s] = e[o]; for (let a = o * r, l = s * r, c = 0; c !== r; ++c)t[l + c] = t[a + c]; ++s } return s !== e.length ? (this.times = e.slice(0, s), this.values = t.slice(0, s * r)) : (this.times = e, this.values = t), this } clone() { const e = this.times.slice(), t = this.values.slice(), r = this.constructor, i = new r(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } ns.prototype.TimeBufferType = Float32Array; ns.prototype.ValueBufferType = Float32Array; ns.prototype.DefaultInterpolation = Hc; class eu extends ns { } eu.prototype.ValueTypeName = "bool"; eu.prototype.ValueBufferType = Array; eu.prototype.DefaultInterpolation = zf; eu.prototype.InterpolantFactoryMethodLinear = void 0; eu.prototype.InterpolantFactoryMethodSmooth = void 0; class tw extends ns { } tw.prototype.ValueTypeName = "color"; class Vf extends ns { } Vf.prototype.ValueTypeName = "number"; class EO extends cd { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e, t, r, i) { const o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = (r - t) / (i - t); let c = e * a; for (let u = c + a; c !== u; c += 4)Sr.slerpFlat(o, 0, s, c - a, s, c, l); return o } } class El extends ns { InterpolantFactoryMethodLinear(e) { return new EO(this.times, this.values, this.getValueSize(), e) } } El.prototype.ValueTypeName = "quaternion"; El.prototype.DefaultInterpolation = Hc; El.prototype.InterpolantFactoryMethodSmooth = void 0; class tu extends ns { } tu.prototype.ValueTypeName = "string"; tu.prototype.ValueBufferType = Array; tu.prototype.DefaultInterpolation = zf; tu.prototype.InterpolantFactoryMethodLinear = void 0; tu.prototype.InterpolantFactoryMethodSmooth = void 0; class Wf extends ns { } Wf.prototype.ValueTypeName = "vector"; class jf { constructor(e, t = -1, r, i = cy) { this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = to(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], r = e.tracks, i = 1 / (e.fps || 1); for (let s = 0, a = r.length; s !== a; ++s)t.push(O6(r[s]).scale(i)); const o = new this(e.name, e.duration, t, e.blendMode); return o.uuid = e.uuid, o } static toJSON(e) { const t = [], r = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let o = 0, s = r.length; o !== s; ++o)t.push(ns.toJSON(r[o])); return i } static CreateFromMorphTargetSequence(e, t, r, i) { const o = t.length, s = []; for (let a = 0; a < o; a++) { let l = [], c = []; l.push((a + o - 1) % o, a, (a + 1) % o), c.push(0, 1, 0); const u = xO(l); l = FA(l, 1, u), c = FA(c, 1, u), !i && l[0] === 0 && (l.push(o), c.push(c[0])), s.push(new Vf(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / r)) } return new this(e, -1, s) } static findByName(e, t) { let r = e; if (!Array.isArray(e)) { const i = e; r = i.geometry && i.geometry.animations || i.animations } for (let i = 0; i < r.length; i++)if (r[i].name === t) return r[i]; return null } static CreateClipsFromMorphTargetSequences(e, t, r) { const i = {}, o = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], u = c.name.match(o); if (u && u.length > 1) { const d = u[1]; let p = i[d]; p || (i[d] = p = []), p.push(c) } } const s = []; for (const a in i) s.push(this.CreateFromMorphTargetSequence(a, i[a], t, r)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (d, p, m, v, y) { if (m.length !== 0) { const _ = [], g = []; qM(m, _, g, v), _.length !== 0 && y.push(new d(p, _, g)) } }, i = [], o = e.name || "default", s = e.fps || 30, a = e.blendMode; let l = e.length || -1; const c = e.hierarchy || []; for (let d = 0; d < c.length; d++) { const p = c[d].keys; if (!(!p || p.length === 0)) if (p[0].morphTargets) { const m = {}; let v; for (v = 0; v < p.length; v++)if (p[v].morphTargets) for (let y = 0; y < p[v].morphTargets.length; y++)m[p[v].morphTargets[y]] = -1; for (const y in m) { const _ = [], g = []; for (let x = 0; x !== p[v].morphTargets.length; ++x) { const A = p[v]; _.push(A.time), g.push(A.morphTarget === y ? 1 : 0) } i.push(new Vf(".morphTargetInfluence[" + y + "]", _, g)) } l = m.length * s } else { const m = ".bones[" + t[d].name + "]"; r(Wf, m + ".position", p, "pos", i), r(El, m + ".quaternion", p, "rot", i), r(Wf, m + ".scale", p, "scl", i) } } return i.length === 0 ? null : new this(o, l, i, a) } resetDuration() { const e = this.tracks; let t = 0; for (let r = 0, i = e.length; r !== i; ++r) { const o = this.tracks[r]; t = Math.max(t, o.times[o.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function D6(n) { switch (n.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Vf; case "vector": case "vector2": case "vector3": case "vector4": return Wf; case "color": return tw; case "quaternion": return El; case "bool": case "boolean": return eu; case "string": return tu }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n) } function O6(n) { if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = D6(n.type); if (n.times === void 0) { const t = [], r = []; qM(n.keys, t, r, "value"), n.times = t, n.values = r } return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation) } const jc = { enabled: !1, files: {}, add: function (n, e) { this.enabled !== !1 && (this.files[n] = e) }, get: function (n) { if (this.enabled !== !1) return this.files[n] }, remove: function (n) { delete this.files[n] }, clear: function () { this.files = {} } }; class nw { constructor(e, t, r) { const i = this; let o = !1, s = 0, a = 0, l; const c = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function (u) { a++, o === !1 && i.onStart !== void 0 && i.onStart(u, s, a), o = !0 }, this.itemEnd = function (u) { s++, i.onProgress !== void 0 && i.onProgress(u, s, a), s === a && (o = !1, i.onLoad !== void 0 && i.onLoad()) }, this.itemError = function (u) { i.onError !== void 0 && i.onError(u) }, this.resolveURL = function (u) { return l ? l(u) : u }, this.setURLModifier = function (u) { return l = u, this }, this.addHandler = function (u, d) { return c.push(u, d), this }, this.removeHandler = function (u) { const d = c.indexOf(u); return d !== -1 && c.splice(d, 2), this }, this.getHandler = function (u) { for (let d = 0, p = c.length; d < p; d += 2) { const m = c[d], v = c[d + 1]; if (m.global && (m.lastIndex = 0), m.test(u)) return v } return null } } } const MO = new nw; class ei { constructor(e) { this.manager = e !== void 0 ? e : MO, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const r = this; return new Promise(function (i, o) { r.load(e, i, t, o) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } ei.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const na = {}; class F6 extends Error { constructor(e, t) { super(e), this.response = t } } class io extends ei { constructor(e) { super(e) } load(e, t, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = jc.get(e); if (o !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(o), this.manager.itemEnd(e) }, 0), o; if (na[e] !== void 0) { na[e].push({ onLoad: t, onProgress: r, onError: i }); return } na[e] = [], na[e].push({ onLoad: t, onProgress: r, onError: i }); const s = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(s).then(c => { if (c.status === 200 || c.status === 0) { if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c; const u = na[e], d = c.body.getReader(), p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), m = p ? parseInt(p) : 0, v = m !== 0; let y = 0; const _ = new ReadableStream({ start(g) { x(); function x() { d.read().then(({ done: A, value: E }) => { if (A) g.close(); else { y += E.byteLength; const w = new ProgressEvent("progress", { lengthComputable: v, loaded: y, total: m }); for (let b = 0, T = u.length; b < T; b++) { const B = u[b]; B.onProgress && B.onProgress(w) } g.enqueue(E), x() } }) } } }); return new Response(_) } else throw new F6(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c) }).then(c => { switch (l) { case "arraybuffer": return c.arrayBuffer(); case "blob": return c.blob(); case "document": return c.text().then(u => new DOMParser().parseFromString(u, a)); case "json": return c.json(); default: if (a === void 0) return c.text(); { const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, m = new TextDecoder(p); return c.arrayBuffer().then(v => m.decode(v)) } } }).then(c => { jc.add(e, c); const u = na[e]; delete na[e]; for (let d = 0, p = u.length; d < p; d++) { const m = u[d]; m.onLoad && m.onLoad(c) } }).catch(c => { const u = na[e]; if (u === void 0) throw this.manager.itemError(e), c; delete na[e]; for (let d = 0, p = u.length; d < p; d++) { const m = u[d]; m.onError && m.onError(c) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class U6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = new io(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (a) { try { t(o.parse(JSON.parse(a))) } catch (l) { i ? i(l) : console.error(l), o.manager.itemError(e) } }, r, i) } parse(e) { const t = []; for (let r = 0; r < e.length; r++) { const i = jf.parse(e[r]); t.push(i) } return t } } class k6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = [], a = new xy, l = new io(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(o.withCredentials); let c = 0; function u(d) { l.load(e[d], function (p) { const m = o.parse(p, !0); s[d] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, c += 1, c === 6 && (m.mipmapCount === 1 && (a.minFilter = fn), a.image = s, a.format = m.format, a.needsUpdate = !0, t && t(a)) }, r, i) } if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d)u(d); else l.load(e, function (d) { const p = o.parse(d, !0); if (p.isCubemap) { const m = p.mipmaps.length / p.mipmapCount; for (let v = 0; v < m; v++) { s[v] = { mipmaps: [] }; for (let y = 0; y < p.mipmapCount; y++)s[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + y]), s[v].format = p.format, s[v].width = p.width, s[v].height = p.height } a.image = s } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps; p.mipmapCount === 1 && (a.minFilter = fn), a.format = p.format, a.needsUpdate = !0, t && t(a) }, r, i); return a } } class vp extends ei { constructor(e) { super(e) } load(e, t, r, i) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = this, s = jc.get(e); if (s !== void 0) return o.manager.itemStart(e), setTimeout(function () { t && t(s), o.manager.itemEnd(e) }, 0), s; const a = dp("img"); function l() { u(), jc.add(e, this), t && t(this), o.manager.itemEnd(e) } function c(d) { u(), i && i(d), o.manager.itemError(e), o.manager.itemEnd(e) } function u() { a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1) } return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), o.manager.itemStart(e), a.src = e, a } } class N6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = new zp; o.colorSpace = ar; const s = new vp(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let a = 0; function l(c) { s.load(e[c], function (u) { o.images[c] = u, a++, a === 6 && (o.needsUpdate = !0, t && t(o)) }, void 0, i) } for (let c = 0; c < e.length; ++c)l(c); return o } } class z6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = new bf, a = new io(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(o.withCredentials), a.load(e, function (l) { let c; try { c = o.parse(l) } catch (u) { if (i !== void 0) i(u); else { console.error(u); return } } c.image !== void 0 ? s.image = c.image : c.data !== void 0 && (s.image.width = c.width, s.image.height = c.height, s.image.data = c.data), s.wrapS = c.wrapS !== void 0 ? c.wrapS : Rr, s.wrapT = c.wrapT !== void 0 ? c.wrapT : Rr, s.magFilter = c.magFilter !== void 0 ? c.magFilter : fn, s.minFilter = c.minFilter !== void 0 ? c.minFilter : fn, s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 ? s.colorSpace = c.colorSpace : c.encoding !== void 0 && (s.encoding = c.encoding), c.flipY !== void 0 && (s.flipY = c.flipY), c.format !== void 0 && (s.format = c.format), c.type !== void 0 && (s.type = c.type), c.mipmaps !== void 0 && (s.mipmaps = c.mipmaps, s.minFilter = Ds), c.mipmapCount === 1 && (s.minFilter = fn), c.generateMipmaps !== void 0 && (s.generateMipmaps = c.generateMipmaps), s.needsUpdate = !0, t && t(s, c) }, r, i), s } } class Ca extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = new An, s = new vp(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (a) { o.image = a, o.needsUpdate = !0, t !== void 0 && t(o) }, r, i), o } } class Bl extends Ut { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new qe(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t } } class wO extends Bl { constructor(e, t, r) { super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ut.DEFAULT_UP), this.updateMatrix(), this.groundColor = new qe(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const vx = new _t, nR = new X, rR = new X; class rw { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Be(512, 512), this.map = null, this.mapPass = null, this.matrix = new _t, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new dy, this._frameExtents = new Be(1, 1), this._viewportCount = 1, this._viewports = [new Ft(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, r = this.matrix; nR.setFromMatrixPosition(e.matrixWorld), t.position.copy(nR), rR.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(rR), t.updateMatrixWorld(), vx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vx), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(vx) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class G6 extends rw { constructor() { super(new xn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, r = Gf * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, o = e.distance || t.far; (r !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = r, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class iw extends Bl { constructor(e, t, r = 0, i = Math.PI / 3, o = 0, s = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ut.DEFAULT_UP), this.updateMatrix(), this.target = new Ut, this.distance = r, this.angle = i, this.penumbra = o, this.decay = s, this.map = null, this.shadow = new G6 } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const iR = new _t, qd = new X, yx = new X; class H6 extends rw { constructor() { super(new xn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Be(4, 2), this._viewportCount = 6, this._viewports = [new Ft(2, 1, 1, 1), new Ft(0, 1, 1, 1), new Ft(3, 1, 1, 1), new Ft(1, 1, 1, 1), new Ft(3, 0, 1, 1), new Ft(1, 0, 1, 1)], this._cubeDirections = [new X(1, 0, 0), new X(-1, 0, 0), new X(0, 0, 1), new X(0, 0, -1), new X(0, 1, 0), new X(0, -1, 0)], this._cubeUps = [new X(0, 1, 0), new X(0, 1, 0), new X(0, 1, 0), new X(0, 1, 0), new X(0, 0, 1), new X(0, 0, -1)] } updateMatrices(e, t = 0) { const r = this.camera, i = this.matrix, o = e.distance || r.far; o !== r.far && (r.far = o, r.updateProjectionMatrix()), qd.setFromMatrixPosition(e.matrixWorld), r.position.copy(qd), yx.copy(r.position), yx.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(yx), r.updateMatrixWorld(), i.makeTranslation(-qd.x, -qd.y, -qd.z), iR.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(iR) } } class ow extends Bl { constructor(e, t, r = 0, i = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new H6 } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class V6 extends rw { constructor() { super(new qi(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class sw extends Bl { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ut.DEFAULT_UP), this.updateMatrix(), this.target = new Ut, this.shadow = new V6 } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class bO extends Bl { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class CO extends Bl { constructor(e, t, r = 10, i = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class TO { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new X) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const r = e.x, i = e.y, o = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * i), t.addScaledVector(s[2], .488603 * o), t.addScaledVector(s[3], .488603 * r), t.addScaledVector(s[4], 1.092548 * (r * i)), t.addScaledVector(s[5], 1.092548 * (i * o)), t.addScaledVector(s[6], .315392 * (3 * o * o - 1)), t.addScaledVector(s[7], 1.092548 * (r * o)), t.addScaledVector(s[8], .546274 * (r * r - i * i)), t } getIrradianceAt(e, t) { const r = e.x, i = e.y, o = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 2 * .511664 * i), t.addScaledVector(s[2], 2 * .511664 * o), t.addScaledVector(s[3], 2 * .511664 * r), t.addScaledVector(s[4], 2 * .429043 * r * i), t.addScaledVector(s[5], 2 * .429043 * i * o), t.addScaledVector(s[6], .743125 * o * o - .247708), t.addScaledVector(s[7], 2 * .429043 * r * o), t.addScaledVector(s[8], .429043 * (r * r - i * i)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let r = 0; r < 9; r++)this.coefficients[r].addScaledVector(e.coefficients[r], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let r = 0; r < 9; r++)this.coefficients[r].lerp(e.coefficients[r], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].fromArray(e, t + i * 3); return this } toArray(e = [], t = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].toArray(e, t + i * 3); return e } static getBasisAt(e, t) { const r = e.x, i = e.y, o = e.z; t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * o, t[3] = .488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * o, t[6] = .315392 * (3 * o * o - 1), t[7] = 1.092548 * r * o, t[8] = .546274 * (r * r - i * i) } } class RO extends Bl { constructor(e = new TO, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class Oy extends ei { constructor(e) { super(e), this.textures = {} } load(e, t, r, i) { const o = this, s = new io(o.manager); s.setPath(o.path), s.setRequestHeader(o.requestHeader), s.setWithCredentials(o.withCredentials), s.load(e, function (a) { try { t(o.parse(JSON.parse(a))) } catch (l) { i ? i(l) : console.error(l), o.manager.itemError(e) } }, r, i) } parse(e) { const t = this.textures; function r(o) { return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o] } const i = Oy.createMaterialFromType(e.type); if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new qe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const o in e.uniforms) { const s = e.uniforms[o]; switch (i.uniforms[o] = {}, s.type) { case "t": i.uniforms[o].value = r(s.value); break; case "c": i.uniforms[o].value = new qe().setHex(s.value); break; case "v2": i.uniforms[o].value = new Be().fromArray(s.value); break; case "v3": i.uniforms[o].value = new X().fromArray(s.value); break; case "v4": i.uniforms[o].value = new Ft().fromArray(s.value); break; case "m3": i.uniforms[o].value = new Rt().fromArray(s.value); break; case "m4": i.uniforms[o].value = new _t().fromArray(s.value); break; default: i.uniforms[o].value = s.value } } if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for (const o in e.extensions) i.extensions[o] = e.extensions[o]; if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) { let o = e.normalScale; Array.isArray(o) === !1 && (o = [o, o]), i.normalScale = new Be().fromArray(o) } return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Be().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: fO, SpriteMaterial: GM, RawShaderMaterial: dO, ShaderMaterial: _r, PointsMaterial: _y, MeshPhysicalMaterial: ks, MeshStandardMaterial: Xp, MeshPhongMaterial: hO, MeshToonMaterial: pO, MeshNormalMaterial: mO, MeshLambertMaterial: gO, MeshDepthMaterial: py, MeshDistanceMaterial: my, MeshBasicMaterial: hi, MeshMatcapMaterial: vO, LineDashedMaterial: yO, LineBasicMaterial: qr, Material: rr }; return new t[e] } } class Ps { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let r = 0, i = e.length; r < i; r++)t += String.fromCharCode(e[r]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class Fy extends bt { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class PO extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = new io(o.manager); s.setPath(o.path), s.setRequestHeader(o.requestHeader), s.setWithCredentials(o.withCredentials), s.load(e, function (a) { try { t(o.parse(JSON.parse(a))) } catch (l) { i ? i(l) : console.error(l), o.manager.itemError(e) } }, r, i) } parse(e) { const t = {}, r = {}; function i(m, v) { if (t[v] !== void 0) return t[v]; const _ = m.interleavedBuffers[v], g = o(m, _.buffer), x = ff(_.type, g), A = new Gp(x, _.stride); return A.uuid = _.uuid, t[v] = A, A } function o(m, v) { if (r[v] !== void 0) return r[v]; const _ = m.arrayBuffers[v], g = new Uint32Array(_).buffer; return r[v] = g, g } const s = e.isInstancedBufferGeometry ? new Fy : new bt, a = e.data.index; if (a !== void 0) { const m = ff(a.type, a.array); s.setIndex(new Kt(m, 1)) } const l = e.data.attributes; for (const m in l) { const v = l[m]; let y; if (v.isInterleavedBufferAttribute) { const _ = i(e.data, v.data); y = new Bi(_, v.itemSize, v.offset, v.normalized) } else { const _ = ff(v.type, v.array), g = v.isInstancedBufferAttribute ? Vc : Kt; y = new g(_, v.itemSize, v.normalized) } v.name !== void 0 && (y.name = v.name), v.usage !== void 0 && y.setUsage(v.usage), v.updateRange !== void 0 && (y.updateRange.offset = v.updateRange.offset, y.updateRange.count = v.updateRange.count), s.setAttribute(m, y) } const c = e.data.morphAttributes; if (c) for (const m in c) { const v = c[m], y = []; for (let _ = 0, g = v.length; _ < g; _++) { const x = v[_]; let A; if (x.isInterleavedBufferAttribute) { const E = i(e.data, x.data); A = new Bi(E, x.itemSize, x.offset, x.normalized) } else { const E = ff(x.type, x.array); A = new Kt(E, x.itemSize, x.normalized) } x.name !== void 0 && (A.name = x.name), y.push(A) } s.morphAttributes[m] = y } e.data.morphTargetsRelative && (s.morphTargetsRelative = !0); const d = e.data.groups || e.data.drawcalls || e.data.offsets; if (d !== void 0) for (let m = 0, v = d.length; m !== v; ++m) { const y = d[m]; s.addGroup(y.start, y.count, y.materialIndex) } const p = e.data.boundingSphere; if (p !== void 0) { const m = new X; p.center !== void 0 && m.fromArray(p.center), s.boundingSphere = new _i(m, p.radius) } return e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s } } class W6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = this.path === "" ? Ps.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || s; const a = new io(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { let c = null; try { c = JSON.parse(l) } catch (d) { i !== void 0 && i(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message); return } const u = c.metadata; if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") { i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } o.parse(c, t) }, r, i) } async loadAsync(e, t) { const r = this, i = this.path === "" ? Ps.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || i; const o = new io(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials); const s = await o.loadAsync(e, t), a = JSON.parse(s), l = a.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await r.parseAsync(a) } parse(e, t) { const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, i), s = this.parseImages(e.images, function () { t !== void 0 && t(c) }), a = this.parseTextures(e.textures, s), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, o, l, a, r), u = this.parseSkeletons(e.skeletons, c); if (this.bindSkeletons(c, u), t !== void 0) { let d = !1; for (const p in s) if (s[p].data instanceof HTMLImageElement) { d = !0; break } d === !1 && t(c) } return c } async parseAsync(e) { const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), o = await this.parseImagesAsync(e.images), s = this.parseTextures(e.textures, o), a = this.parseMaterials(e.materials, s), l = this.parseObject(e.object, i, a, s, t), c = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, c), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let r = 0, i = e.length; r < i; r++) { const o = new Ic().fromJSON(e[r]); t[o.uuid] = o } return t } parseSkeletons(e, t) { const r = {}, i = {}; if (t.traverse(function (o) { o.isBone && (i[o.uuid] = o) }), e !== void 0) for (let o = 0, s = e.length; o < s; o++) { const a = new Hp().fromJSON(e[o], i); r[a.uuid] = a } return r } parseGeometries(e, t) { const r = {}; if (e !== void 0) { const i = new PO; for (let o = 0, s = e.length; o < s; o++) { let a; const l = e[o]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = i.parse(l); break; default: l.type in tR ? a = tR[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), r[l.uuid] = a } } return r } parseMaterials(e, t) { const r = {}, i = {}; if (e !== void 0) { const o = new Oy; o.setTextures(t); for (let s = 0, a = e.length; s < a; s++) { const l = e[s]; r[l.uuid] === void 0 && (r[l.uuid] = o.parse(l)), i[l.uuid] = r[l.uuid] } } return i } parseAnimations(e) { const t = {}; if (e !== void 0) for (let r = 0; r < e.length; r++) { const i = e[r], o = jf.parse(i); t[o.uuid] = o } return t } parseImages(e, t) { const r = this, i = {}; let o; function s(l) { return r.manager.itemStart(l), o.load(l, function () { r.manager.itemEnd(l) }, void 0, function () { r.manager.itemError(l), r.manager.itemEnd(l) }) } function a(l) { if (typeof l == "string") { const c = l, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c; return s(u) } else return l.data ? { data: ff(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new nw(t); o = new vp(l), o.setCrossOrigin(this.crossOrigin); for (let c = 0, u = e.length; c < u; c++) { const d = e[c], p = d.url; if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const _ = p[v], g = a(_); g !== null && (g instanceof HTMLImageElement ? m.push(g) : m.push(new bf(g.data, g.width, g.height))) } i[d.uuid] = new Ac(m) } else { const m = a(d.url); i[d.uuid] = new Ac(m) } } } return i } async parseImagesAsync(e) { const t = this, r = {}; let i; async function o(s) { if (typeof s == "string") { const a = s, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a; return await i.loadAsync(l) } else return s.data ? { data: ff(s.type, s.data), width: s.width, height: s.height } : null } if (e !== void 0 && e.length > 0) { i = new vp(this.manager), i.setCrossOrigin(this.crossOrigin); for (let s = 0, a = e.length; s < a; s++) { const l = e[s], c = l.url; if (Array.isArray(c)) { const u = []; for (let d = 0, p = c.length; d < p; d++) { const m = c[d], v = await o(m); v !== null && (v instanceof HTMLImageElement ? u.push(v) : u.push(new bf(v.data, v.width, v.height))) } r[l.uuid] = new Ac(u) } else { const u = await o(l.url); r[l.uuid] = new Ac(u) } } } return r } parseTextures(e, t) { function r(o, s) { return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), s[o]) } const i = {}; if (e !== void 0) for (let o = 0, s = e.length; o < s; o++) { const a = e[o]; a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image); const l = t[a.image], c = l.data; let u; Array.isArray(c) ? (u = new zp, c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new bf : u = new An, c && (u.needsUpdate = !0)), u.source = l, u.uuid = a.uuid, a.name !== void 0 && (u.name = a.name), a.mapping !== void 0 && (u.mapping = r(a.mapping, j6)), a.channel !== void 0 && (u.channel = a.channel), a.offset !== void 0 && u.offset.fromArray(a.offset), a.repeat !== void 0 && u.repeat.fromArray(a.repeat), a.center !== void 0 && u.center.fromArray(a.center), a.rotation !== void 0 && (u.rotation = a.rotation), a.wrap !== void 0 && (u.wrapS = r(a.wrap[0], oR), u.wrapT = r(a.wrap[1], oR)), a.format !== void 0 && (u.format = a.format), a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat), a.type !== void 0 && (u.type = a.type), a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace), a.encoding !== void 0 && (u.encoding = a.encoding), a.minFilter !== void 0 && (u.minFilter = r(a.minFilter, sR)), a.magFilter !== void 0 && (u.magFilter = r(a.magFilter, sR)), a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy), a.flipY !== void 0 && (u.flipY = a.flipY), a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction), a.userData !== void 0 && (u.userData = a.userData), i[a.uuid] = u } return i } parseObject(e, t, r, i, o) { let s; function a(p) { return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p] } function l(p) { if (p !== void 0) { if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const _ = p[v]; r[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", _), m.push(r[_]) } return m } return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), r[p] } } function c(p) { return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), i[p] } let u, d; switch (e.type) { case "Scene": s = new Ev, e.background !== void 0 && (Number.isInteger(e.background) ? s.background = new qe(e.background) : s.background = c(e.background)), e.environment !== void 0 && (s.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? s.fog = new vy(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (s.fog = new gy(e.fog.color, e.fog.density)), e.fog.name !== "" && (s.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (s.backgroundIntensity = e.backgroundIntensity); break; case "PerspectiveCamera": s = new xn(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (s.focus = e.focus), e.zoom !== void 0 && (s.zoom = e.zoom), e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset), e.view !== void 0 && (s.view = Object.assign({}, e.view)); break; case "OrthographicCamera": s = new qi(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (s.zoom = e.zoom), e.view !== void 0 && (s.view = Object.assign({}, e.view)); break; case "AmbientLight": s = new bO(e.color, e.intensity); break; case "DirectionalLight": s = new sw(e.color, e.intensity); break; case "PointLight": s = new ow(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": s = new CO(e.color, e.intensity, e.width, e.height); break; case "SpotLight": s = new iw(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": s = new wO(e.color, e.groundColor, e.intensity); break; case "LightProbe": s = new RO().fromJSON(e); break; case "SkinnedMesh": u = a(e.geometry), d = l(e.material), s = new HM(u, d), e.bindMode !== void 0 && (s.bindMode = e.bindMode), e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (s.skeleton = e.skeleton); break; case "Mesh": u = a(e.geometry), d = l(e.material), s = new In(u, d); break; case "InstancedMesh": u = a(e.geometry), d = l(e.material); const p = e.count, m = e.instanceMatrix, v = e.instanceColor; s = new VM(u, d, p), s.instanceMatrix = new Vc(new Float32Array(m.array), 16), v !== void 0 && (s.instanceColor = new Vc(new Float32Array(v.array), v.itemSize)); break; case "LOD": s = new tO; break; case "Line": s = new xa(a(e.geometry), l(e.material)); break; case "LineLoop": s = new WM(a(e.geometry), l(e.material)); break; case "LineSegments": s = new es(a(e.geometry), l(e.material)); break; case "PointCloud": case "Points": s = new jM(a(e.geometry), l(e.material)); break; case "Sprite": s = new eO(l(e.material)); break; case "Group": s = new fa; break; case "Bone": s = new yy; break; default: s = new Ut }if (s.uuid = e.uuid, e.name !== void 0 && (s.name = e.name), e.matrix !== void 0 ? (s.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (e.position !== void 0 && s.position.fromArray(e.position), e.rotation !== void 0 && s.rotation.fromArray(e.rotation), e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion), e.scale !== void 0 && s.scale.fromArray(e.scale)), e.up !== void 0 && s.up.fromArray(e.up), e.castShadow !== void 0 && (s.castShadow = e.castShadow), e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (s.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (s.visible = e.visible), e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder), e.userData !== void 0 && (s.userData = e.userData), e.layers !== void 0 && (s.layers.mask = e.layers), e.children !== void 0) { const p = e.children; for (let m = 0; m < p.length; m++)s.add(this.parseObject(p[m], t, r, i, o)) } if (e.animations !== void 0) { const p = e.animations; for (let m = 0; m < p.length; m++) { const v = p[m]; s.animations.push(o[v]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate); const p = e.levels; for (let m = 0; m < p.length; m++) { const v = p[m], y = s.getObjectByProperty("uuid", v.object); y !== void 0 && s.addLevel(y, v.distance, v.hysteresis) } } return s } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (r) { if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) { const i = t[r.skeleton]; i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix) } }) } } const j6 = { UVMapping: sy, CubeReflectionMapping: ya, CubeRefractionMapping: Sl, EquirectangularReflectionMapping: rp, EquirectangularRefractionMapping: ip, CubeUVReflectionMapping: sd }, oR = { RepeatWrapping: Al, ClampToEdgeWrapping: Rr, MirroredRepeatWrapping: Nf }, sR = { NearestFilter: Gn, NearestMipmapNearestFilter: op, NearestMipmapLinearFilter: Mf, LinearFilter: fn, LinearMipmapNearestFilter: ay, LinearMipmapLinearFilter: Ds }; class BO extends ei { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = this, s = jc.get(e); if (s !== void 0) return o.manager.itemStart(e), setTimeout(function () { t && t(s), o.manager.itemEnd(e) }, 0), s; const a = {}; a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(o.options, { colorSpaceConversion: "none" })) }).then(function (l) { jc.add(e, l), t && t(l), o.manager.itemEnd(e) }).catch(function (l) { i && i(l), o.manager.itemError(e), o.manager.itemEnd(e) }), o.manager.itemStart(e) } } let Kg; class aw { static getContext() { return Kg === void 0 && (Kg = new (window.AudioContext || window.webkitAudioContext)), Kg } static setContext(e) { Kg = e } } class X6 extends ei { constructor(e) { super(e) } load(e, t, r, i) { const o = this, s = new io(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (l) { try { const c = l.slice(0); aw.getContext().decodeAudioData(c, function (d) { t(d) }, a) } catch (c) { a(c) } }, r, i); function a(l) { i ? i(l) : console.error(l), o.manager.itemError(e) } } } const aR = new _t, lR = new _t, ql = new _t; class J6 { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new xn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new xn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ql.copy(e.projectionMatrix); const i = t.eyeSep / 2, o = i * t.near / t.focus, s = t.near * Math.tan(Pc * t.fov * .5) / t.zoom; let a, l; lR.elements[12] = -i, aR.elements[12] = i, a = -s * t.aspect + o, l = s * t.aspect + o, ql.elements[0] = 2 * t.near / (l - a), ql.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ql), a = -s * t.aspect - o, l = s * t.aspect - o, ql.elements[0] = 2 * t.near / (l - a), ql.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ql) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(lR), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(aR) } } class Uy { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = cR(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = cR(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function cR() { return (typeof performance > "u" ? Date : performance).now() } const ec = new X, uR = new Sr, K6 = new X, tc = new X; class Y6 extends Ut { constructor() { super(), this.type = "AudioListener", this.context = aw.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Uy } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, r = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ec, uR, K6), tc.set(0, 0, -1).applyQuaternion(uR), t.positionX) { const i = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(ec.x, i), t.positionY.linearRampToValueAtTime(ec.y, i), t.positionZ.linearRampToValueAtTime(ec.z, i), t.forwardX.linearRampToValueAtTime(tc.x, i), t.forwardY.linearRampToValueAtTime(tc.y, i), t.forwardZ.linearRampToValueAtTime(tc.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i) } else t.setPosition(ec.x, ec.y, ec.z), t.setOrientation(tc.x, tc.y, tc.z, r.x, r.y, r.z) } } class IO extends Ut { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this._connected !== !1) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const nc = new X, fR = new Sr, $6 = new X, rc = new X; class Q6 extends IO { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { super.connect(), this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, r) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(nc, fR, $6), rc.set(0, 0, 1).applyQuaternion(fR); const t = this.panner; if (t.positionX) { const r = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(nc.x, r), t.positionY.linearRampToValueAtTime(nc.y, r), t.positionZ.linearRampToValueAtTime(nc.z, r), t.orientationX.linearRampToValueAtTime(rc.x, r), t.orientationY.linearRampToValueAtTime(rc.y, r), t.orientationZ.linearRampToValueAtTime(rc.z, r) } else t.setPosition(nc.x, nc.y, nc.z), t.setOrientation(rc.x, rc.y, rc.z) } } class Z6 { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let r = 0; r < t.length; r++)e += t[r]; return e / t.length } } class LO { constructor(e, t, r) { this.binding = e, this.valueSize = r; let i, o, s; switch (t) { case "quaternion": i = this._slerp, o = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5; break; case "string": case "bool": i = this._select, o = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5); break; default: i = this._lerp, o = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = o, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const r = this.buffer, i = this.valueSize, o = e * i + i; let s = this.cumulativeWeight; if (s === 0) { for (let a = 0; a !== i; ++a)r[o + a] = r[a]; s = t } else { s += t; const a = t / s; this._mixBufferRegion(r, o, 0, a, i) } this.cumulativeWeight = s } accumulateAdditive(e) { const t = this.buffer, r = this.valueSize, i = r * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, r = this.buffer, i = e * t + t, o = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) { const l = t * this._origIndex; this._mixBufferRegion(r, i, l, 1 - o, t) } s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t); for (let l = t, c = t + t; l !== c; ++l)if (r[l] !== r[l + t]) { a.setValue(r, i); break } } saveOriginalState() { const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex; e.getValue(t, i); for (let o = r, s = i; o !== s; ++o)t[o] = t[i + o % r]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let r = e; r < t; r++)this.buffer[r] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let r = 0; r < this.valueSize; r++)this.buffer[t + r] = this.buffer[e + r] } _select(e, t, r, i, o) { if (i >= .5) for (let s = 0; s !== o; ++s)e[t + s] = e[r + s] } _slerp(e, t, r, i) { Sr.slerpFlat(e, t, e, t, e, r, i) } _slerpAdditive(e, t, r, i, o) { const s = this._workIndex * o; Sr.multiplyQuaternionsFlat(e, s, e, t, e, r), Sr.slerpFlat(e, t, e, t, e, s, i) } _lerp(e, t, r, i, o) { const s = 1 - i; for (let a = 0; a !== o; ++a) { const l = t + a; e[l] = e[l] * s + e[r + a] * i } } _lerpAdditive(e, t, r, i, o) { for (let s = 0; s !== o; ++s) { const a = t + s; e[a] = e[a] + e[r + s] * i } } } const lw = "\\[\\]\\.:\\/", q6 = new RegExp("[" + lw + "]", "g"), cw = "[^" + lw + "]", eV = "[^" + lw.replace("\\.", "") + "]", tV = /((?:WC+[\/:])*)/.source.replace("WC", cw), nV = /(WCOD+)?/.source.replace("WCOD", eV), rV = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", cw), iV = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", cw), oV = new RegExp("^" + tV + nV + rV + iV + "$"), sV = ["material", "materials", "bones", "map"]; class aV { constructor(e, t, r) { const i = r || Gt.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const r = this._targetGroup.nCachedObjects_, i = this._bindings[r]; i !== void 0 && i.getValue(e, t) } setValue(e, t) { const r = this._bindings; for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)r[i].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].unbind() } } class Gt { constructor(e, t, r) { this.path = t, this.parsedPath = r || Gt.parseTrackName(t), this.node = Gt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, r) { return e && e.isAnimationObjectGroup ? new Gt.Composite(e, t, r) : new Gt(e, t, r) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(q6, "") } static parseTrackName(e) { const t = oV.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const r = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, i = r.nodeName && r.nodeName.lastIndexOf("."); if (i !== void 0 && i !== -1) { const o = r.nodeName.substring(i + 1); sV.indexOf(o) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = o) } if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return r } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const r = e.skeleton.getBoneByName(t); if (r !== void 0) return r } if (e.children) { const r = function (o) { for (let s = 0; s < o.length; s++) { const a = o[s]; if (a.name === t || a.uuid === t) return a; const l = r(a.children); if (l) return l } return null }, i = r(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const r = this.resolvedProperty; for (let i = 0, o = r.length; i !== o; ++i)e[t++] = r[i] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const r = this.resolvedProperty; for (let i = 0, o = r.length; i !== o; ++i)r[i] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const r = this.resolvedProperty; for (let i = 0, o = r.length; i !== o; ++i)r[i] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const r = this.resolvedProperty; for (let i = 0, o = r.length; i !== o; ++i)r[i] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, r = t.objectName, i = t.propertyName; let o = t.propertyIndex; if (e || (e = Gt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (r) { let c = t.objectIndex; switch (r) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let u = 0; u < e.length; u++)if (e[u].name === c) { c = u; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[r] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[r] }if (c !== void 0) { if (e[c] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[c] } } const s = e[i]; if (s === void 0) { const c = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (o !== void 0) { if (i === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]) } l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = o } else s.fromArray !== void 0 && s.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Gt.Composite = aV; Gt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Gt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Gt.prototype.GetterByBindingType = [Gt.prototype._getValue_direct, Gt.prototype._getValue_array, Gt.prototype._getValue_arrayElement, Gt.prototype._getValue_toArray]; Gt.prototype.SetterByBindingTypeAndVersioning = [[Gt.prototype._setValue_direct, Gt.prototype._setValue_direct_setNeedsUpdate, Gt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Gt.prototype._setValue_array, Gt.prototype._setValue_array_setNeedsUpdate, Gt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Gt.prototype._setValue_arrayElement, Gt.prototype._setValue_arrayElement_setNeedsUpdate, Gt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Gt.prototype._setValue_fromArray, Gt.prototype._setValue_fromArray_setNeedsUpdate, Gt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class lV { constructor() { this.isAnimationObjectGroup = !0, this.uuid = to(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let r = 0, i = arguments.length; r !== i; ++r)e[arguments[r].uuid] = r; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, o = this._bindings, s = o.length; let a, l = e.length, c = this.nCachedObjects_; for (let u = 0, d = arguments.length; u !== d; ++u) { const p = arguments[u], m = p.uuid; let v = t[m]; if (v === void 0) { v = l++, t[m] = v, e.push(p); for (let y = 0, _ = s; y !== _; ++y)o[y].push(new Gt(p, r[y], i[y])) } else if (v < c) { a = e[v]; const y = --c, _ = e[y]; t[_.uuid] = v, e[v] = _, t[m] = y, e[y] = p; for (let g = 0, x = s; g !== x; ++g) { const A = o[g], E = A[y]; let w = A[v]; A[v] = E, w === void 0 && (w = new Gt(p, r[g], i[g])), A[y] = w } } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c } remove() { const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length; let o = this.nCachedObjects_; for (let s = 0, a = arguments.length; s !== a; ++s) { const l = arguments[s], c = l.uuid, u = t[c]; if (u !== void 0 && u >= o) { const d = o++, p = e[d]; t[p.uuid] = u, e[u] = p, t[c] = d, e[d] = l; for (let m = 0, v = i; m !== v; ++m) { const y = r[m], _ = y[d], g = y[u]; y[u] = _, y[d] = g } } } this.nCachedObjects_ = o } uncache() { const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length; let o = this.nCachedObjects_, s = e.length; for (let a = 0, l = arguments.length; a !== l; ++a) { const c = arguments[a], u = c.uuid, d = t[u]; if (d !== void 0) if (delete t[u], d < o) { const p = --o, m = e[p], v = --s, y = e[v]; t[m.uuid] = d, e[d] = m, t[y.uuid] = p, e[p] = y, e.pop(); for (let _ = 0, g = i; _ !== g; ++_) { const x = r[_], A = x[p], E = x[v]; x[d] = A, x[p] = E, x.pop() } } else { const p = --s, m = e[p]; p > 0 && (t[m.uuid] = d), e[d] = m, e.pop(); for (let v = 0, y = i; v !== y; ++v) { const _ = r[v]; _[d] = _[p], _.pop() } } } this.nCachedObjects_ = o } subscribe_(e, t) { const r = this._bindingsIndicesByPath; let i = r[e]; const o = this._bindings; if (i !== void 0) return o[i]; const s = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, d = new Array(c); i = o.length, r[e] = i, s.push(e), a.push(t), o.push(d); for (let p = u, m = l.length; p !== m; ++p) { const v = l[p]; d[p] = new Gt(v, e, t) } return d } unsubscribe_(e) { const t = this._bindingsIndicesByPath, r = t[e]; if (r !== void 0) { const i = this._paths, o = this._parsedPaths, s = this._bindings, a = s.length - 1, l = s[a], c = e[a]; t[c] = r, s[r] = l, s.pop(), o[r] = o[a], o.pop(), i[r] = i[a], i.pop() } } } class DO { constructor(e, t, r = null, i = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i; const o = t.tracks, s = o.length, a = new Array(s), l = { endingStart: xc, endingEnd: xc }; for (let c = 0; c !== s; ++c) { const u = o[c].createInterpolant(null); a[c] = u, u.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = AD, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, r) { if (e.fadeOut(t), this.fadeIn(t), r) { const i = this._clip.duration, o = e._clip.duration, s = o / i, a = i / o; e.warp(1, s, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, r) { return e.crossFadeFrom(this, t, r) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, r) { const i = this._mixer, o = i.time, s = this.timeScale; let a = this._timeScaleInterpolant; a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a); const l = a.parameterPositions, c = a.sampleValues; return l[0] = o, l[1] = o + r, c[0] = e / s, c[1] = t / s, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, r, i) { if (!this.enabled) { this._updateWeight(e); return } const o = this._startTime; if (o !== null) { const l = (e - o) * r; l < 0 || r === 0 ? t = 0 : (this._startTime = null, t = r * l) } t *= this._updateTimeScale(e); const s = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const l = this._interpolants, c = this._propertyBindings; switch (this.blendMode) { case PM: for (let u = 0, d = l.length; u !== d; ++u)l[u].evaluate(s), c[u].accumulateAdditive(a); break; case cy: default: for (let u = 0, d = l.length; u !== d; ++u)l[u].evaluate(s), c[u].accumulate(i, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const r = this._weightInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const r = this._timeScaleInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; t *= i, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, r = this.loop; let i = this.time + e, o = this._loopCount; const s = r === ED; if (e === 0) return o === -1 ? i : s && (o & 1) === 1 ? t - i : i; if (r === SD) { o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (i >= t) i = t; else if (i < 0) i = 0; else { this.time = i; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), i >= t || i < 0) { const a = Math.floor(i / t); i -= t * a, o += Math.abs(a); const l = this.repetitions - o; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const c = e < 0; this._setEndings(c, !c, s) } else this._setEndings(!1, !1, s); this._loopCount = o, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = i; if (s && (o & 1) === 1) return t - i } return i } _setEndings(e, t, r) { const i = this._interpolantSettings; r ? (i.endingStart = Sc, i.endingEnd = Sc) : (e ? i.endingStart = this.zeroSlopeAtStart ? Sc : xc : i.endingStart = sp, t ? i.endingEnd = this.zeroSlopeAtEnd ? Sc : xc : i.endingEnd = sp) } _scheduleFading(e, t, r) { const i = this._mixer, o = i.time; let s = this._weightInterpolant; s === null && (s = i._lendControlInterpolant(), this._weightInterpolant = s); const a = s.parameterPositions, l = s.sampleValues; return a[0] = o, l[0] = t, a[1] = o + e, l[1] = r, this } } const cV = new Float32Array(1); class OO extends Us { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const r = e._localRoot || this._root, i = e._clip.tracks, o = i.length, s = e._propertyBindings, a = e._interpolants, l = r.uuid, c = this._bindingsByRootAndName; let u = c[l]; u === void 0 && (u = {}, c[l] = u); for (let d = 0; d !== o; ++d) { const p = i[d], m = p.name; let v = u[m]; if (v !== void 0) ++v.referenceCount, s[d] = v; else { if (v = s[d], v !== void 0) { v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, m)); continue } const y = t && t._propertyBindings[d].binding.parsedPath; v = new LO(Gt.create(r, m, y), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, m), s[d] = v } a[d].resultBuffer = v.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, o = this._actionsByClip[i]; this._bindAction(e, o && o.knownActions[0]), this._addInactiveAction(e, i, r) } const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const o = t[r]; o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const o = t[r]; --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, r) { const i = this._actions, o = this._actionsByClip; let s = o[t]; if (s === void 0) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, o[t] = s; else { const a = s.knownActions; e._byClipCacheIndex = a.length, a.push(e) } e._cacheIndex = i.length, i.push(e), s.actionByRoot[r] = e } _removeInactiveAction(e) { const t = this._actions, r = t[t.length - 1], i = e._cacheIndex; r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null; const o = e._clip.uuid, s = this._actionsByClip, a = s[o], l = a.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex; c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null; const d = a.actionByRoot, p = (e._localRoot || this._root).uuid; delete d[p], l.length === 0 && delete s[o], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const o = t[r]; --o.referenceCount === 0 && this._removeInactiveBinding(o) } } _lendAction(e) { const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, o = t[i]; e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o } _takeBackAction(e) { const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, o = t[i]; e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o } _addInactiveBinding(e, t, r) { const i = this._bindingsByRootAndName, o = this._bindings; let s = i[t]; s === void 0 && (s = {}, i[t] = s), s[r] = e, e._cacheIndex = o.length, o.push(e) } _removeInactiveBinding(e) { const t = this._bindings, r = e.binding, i = r.rootNode.uuid, o = r.path, s = this._bindingsByRootAndName, a = s[i], l = t[t.length - 1], c = e._cacheIndex; l._cacheIndex = c, t[c] = l, t.pop(), delete a[o], Object.keys(a).length === 0 && delete s[i] } _lendBinding(e) { const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, o = t[i]; e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o } _takeBackBinding(e) { const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, o = t[i]; e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let r = e[t]; return r === void 0 && (r = new ew(new Float32Array(2), new Float32Array(2), 1, cV), r.__cacheIndex = t, e[t] = r), r } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, o = t[i]; e.__cacheIndex = i, t[i] = e, o.__cacheIndex = r, t[r] = o } clipAction(e, t, r) { const i = t || this._root, o = i.uuid; let s = typeof e == "string" ? jf.findByName(i, e) : e; const a = s !== null ? s.uuid : e, l = this._actionsByClip[a]; let c = null; if (r === void 0 && (s !== null ? r = s.blendMode : r = cy), l !== void 0) { const d = l.actionByRoot[o]; if (d !== void 0 && d.blendMode === r) return d; c = l.knownActions[0], s === null && (s = c._clip) } if (s === null) return null; const u = new DO(this, s, t, r); return this._bindAction(u, c), this._addInactiveAction(u, a, o), u } existingAction(e, t) { const r = t || this._root, i = r.uuid, o = typeof e == "string" ? jf.findByName(r, e) : e, s = o ? o.uuid : e, a = this._actionsByClip[s]; return a !== void 0 && a.actionByRoot[i] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let r = t - 1; r >= 0; --r)e[r].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, r = this._nActiveActions, i = this.time += e, o = Math.sign(e), s = this._accuIndex ^= 1; for (let c = 0; c !== r; ++c)t[c]._update(i, e, o, s); const a = this._bindings, l = this._nActiveBindings; for (let c = 0; c !== l; ++c)a[c].apply(s); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, r = e.uuid, i = this._actionsByClip, o = i[r]; if (o !== void 0) { const s = o.knownActions; for (let a = 0, l = s.length; a !== l; ++a) { const c = s[a]; this._deactivateAction(c); const u = c._cacheIndex, d = t[t.length - 1]; c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = u, t[u] = d, t.pop(), this._removeInactiveBindingsForAction(c) } delete i[r] } } uncacheRoot(e) { const t = e.uuid, r = this._actionsByClip; for (const s in r) { const a = r[s].actionByRoot, l = a[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const i = this._bindingsByRootAndName, o = i[t]; if (o !== void 0) for (const s in o) { const a = o[s]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction(e, t) { const r = this.existingAction(e, t); r !== null && (this._deactivateAction(r), this._removeInactiveAction(r)) } } class uw { constructor(e) { this.value = e } clone() { return new uw(this.value.clone === void 0 ? this.value : this.value.clone()) } } let uV = 0; class fV extends Us { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: uV++ }), this.name = "", this.usage = up, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let r = 0, i = t.length; r < i; r++)this.uniforms.push(t[r].clone()); return this } clone() { return new this.constructor().copy(this) } } class wv extends Gp { constructor(e, t, r = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class dV { constructor(e, t, r, i, o) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = o, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } class FO { constructor(e, t, r = 0, i = 1 / 0) { this.ray = new Zc(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new Bc, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, r = []) { return UA(e, this, r, t), r.sort(dR), r } intersectObjects(e, t = !0, r = []) { for (let i = 0, o = e.length; i < o; i++)UA(e[i], this, r, t); return r.sort(dR), r } } function dR(n, e) { return n.distance - e.distance } function UA(n, e, t, r) { if (n.layers.test(e.layers) && n.raycast(e, t), r === !0) { const i = n.children; for (let o = 0, s = i.length; o < s; o++)UA(i[o], e, t, !0) } } class kA { constructor(e = 1, t = 0, r = 0) { return this.radius = e, this.phi = t, this.theta = r, this } set(e, t, r) { return this.radius = e, this.phi = t, this.theta = r, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, r) { return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Hn(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class hV { constructor(e = 1, t = 0, r = 0) { return this.radius = e, this.theta = t, this.y = r, this } set(e, t, r) { return this.radius = e, this.theta = t, this.y = r, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, r) { return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this } clone() { return new this.constructor().copy(this) } } const hR = new Be; class pV { constructor(e = new Be(1 / 0, 1 / 0), t = new Be(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const r = hR.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, hR).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const pR = new X, Yg = new X; class UO { constructor(e = new X, t = new X) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { pR.subVectors(e, this.start), Yg.subVectors(this.end, this.start); const r = Yg.dot(Yg); let o = Yg.dot(pR) / r; return t && (o = Hn(o, 0, 1)), o } closestPointToPoint(e, t, r) { const i = this.closestPointToPointParameter(e, t); return this.delta(r).multiplyScalar(i).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const mR = new X; class mV extends Ut { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const r = new bt, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let s = 0, a = 1, l = 32; s < l; s++, a++) { const c = s / l * Math.PI * 2, u = a / l * Math.PI * 2; i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1) } r.setAttribute("position", new ut(i, 3)); const o = new qr({ fog: !1, toneMapped: !1 }); this.cone = new es(r, o), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), mR.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(mR), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const Xa = new X, $g = new _t, _x = new _t; class gV extends es { constructor(e) { const t = kO(e), r = new bt, i = [], o = [], s = new qe(0, 0, 1), a = new qe(0, 1, 0); for (let c = 0; c < t.length; c++) { const u = t[c]; u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(a.r, a.g, a.b)) } r.setAttribute("position", new ut(i, 3)), r.setAttribute("color", new ut(o, 3)); const l = new qr({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(r, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, r = this.geometry, i = r.getAttribute("position"); _x.copy(this.root.matrixWorld).invert(); for (let o = 0, s = 0; o < t.length; o++) { const a = t[o]; a.parent && a.parent.isBone && ($g.multiplyMatrices(_x, a.matrixWorld), Xa.setFromMatrixPosition($g), i.setXYZ(s, Xa.x, Xa.y, Xa.z), $g.multiplyMatrices(_x, a.parent.matrixWorld), Xa.setFromMatrixPosition($g), i.setXYZ(s + 1, Xa.x, Xa.y, Xa.z), s += 2) } r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function kO(n) { const e = []; n.isBone === !0 && e.push(n); for (let t = 0; t < n.children.length; t++)e.push.apply(e, kO(n.children[t])); return e } class vV extends In { constructor(e, t, r) { const i = new jp(t, 4, 2), o = new hi({ wireframe: !0, fog: !1, toneMapped: !1 }); super(i, o), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const yV = new X, gR = new qe, vR = new qe; class _V extends Ut { constructor(e, t, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper"; const i = new Wp(t); i.rotateY(Math.PI * .5), this.material = new hi({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const o = i.getAttribute("position"), s = new Float32Array(o.count * 3); i.setAttribute("color", new Kt(s, 3)), this.add(new In(i, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); gR.copy(this.light.color), vR.copy(this.light.groundColor); for (let r = 0, i = t.count; r < i; r++) { const o = r < i / 2 ? gR : vR; t.setXYZ(r, o.r, o.g, o.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(yV.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class xV extends es { constructor(e = 10, t = 10, r = 4473924, i = 8947848) { r = new qe(r), i = new qe(i); const o = t / 2, s = e / t, a = e / 2, l = [], c = []; for (let p = 0, m = 0, v = -a; p <= t; p++, v += s) { l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a); const y = p === o ? r : i; y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3 } const u = new bt; u.setAttribute("position", new ut(l, 3)), u.setAttribute("color", new ut(c, 3)); const d = new qr({ vertexColors: !0, toneMapped: !1 }); super(u, d), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class SV extends es { constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, s = 8947848) { o = new qe(o), s = new qe(s); const a = [], l = []; if (t > 1) for (let d = 0; d < t; d++) { const p = d / t * (Math.PI * 2), m = Math.sin(p) * e, v = Math.cos(p) * e; a.push(0, 0, 0), a.push(m, 0, v); const y = d & 1 ? o : s; l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b) } for (let d = 0; d < r; d++) { const p = d & 1 ? o : s, m = e - e / r * d; for (let v = 0; v < i; v++) { let y = v / i * (Math.PI * 2), _ = Math.sin(y) * m, g = Math.cos(y) * m; a.push(_, 0, g), l.push(p.r, p.g, p.b), y = (v + 1) / i * (Math.PI * 2), _ = Math.sin(y) * m, g = Math.cos(y) * m, a.push(_, 0, g), l.push(p.r, p.g, p.b) } } const c = new bt; c.setAttribute("position", new ut(a, 3)), c.setAttribute("color", new ut(l, 3)); const u = new qr({ vertexColors: !0, toneMapped: !1 }); super(c, u), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const yR = new X, Qg = new X, _R = new X; class AV extends Ut { constructor(e, t, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let i = new bt; i.setAttribute("position", new ut([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const o = new qr({ fog: !1, toneMapped: !1 }); this.lightPlane = new xa(i, o), this.add(this.lightPlane), i = new bt, i.setAttribute("position", new ut([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new xa(i, o), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), yR.setFromMatrixPosition(this.light.matrixWorld), Qg.setFromMatrixPosition(this.light.target.matrixWorld), _R.subVectors(Qg, yR), this.lightPlane.lookAt(Qg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Qg), this.targetLine.scale.z = _R.length() } } const Zg = new X, Un = new Np; class EV extends es { constructor(e) { const t = new bt, r = new qr({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], o = [], s = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a(v, y) { l(v), l(y) } function l(v) { i.push(0, 0, 0), o.push(0, 0, 0), s[v] === void 0 && (s[v] = []), s[v].push(i.length / 3 - 1) } t.setAttribute("position", new ut(i, 3)), t.setAttribute("color", new ut(o, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update(); const c = new qe(16755200), u = new qe(16711680), d = new qe(43775), p = new qe(16777215), m = new qe(3355443); this.setColors(c, u, d, p, m) } setColors(e, t, r, i, o) { const a = this.geometry.getAttribute("color"); a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, r.r, r.g, r.b), a.setXYZ(33, r.r, r.g, r.b), a.setXYZ(34, r.r, r.g, r.b), a.setXYZ(35, r.r, r.g, r.b), a.setXYZ(36, r.r, r.g, r.b), a.setXYZ(37, r.r, r.g, r.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, o.r, o.g, o.b), a.setXYZ(41, o.r, o.g, o.b), a.setXYZ(42, o.r, o.g, o.b), a.setXYZ(43, o.r, o.g, o.b), a.setXYZ(44, o.r, o.g, o.b), a.setXYZ(45, o.r, o.g, o.b), a.setXYZ(46, o.r, o.g, o.b), a.setXYZ(47, o.r, o.g, o.b), a.setXYZ(48, o.r, o.g, o.b), a.setXYZ(49, o.r, o.g, o.b), a.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, r = 1, i = 1; Un.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Jn("c", t, e, Un, 0, 0, -1), Jn("t", t, e, Un, 0, 0, 1), Jn("n1", t, e, Un, -r, -i, -1), Jn("n2", t, e, Un, r, -i, -1), Jn("n3", t, e, Un, -r, i, -1), Jn("n4", t, e, Un, r, i, -1), Jn("f1", t, e, Un, -r, -i, 1), Jn("f2", t, e, Un, r, -i, 1), Jn("f3", t, e, Un, -r, i, 1), Jn("f4", t, e, Un, r, i, 1), Jn("u1", t, e, Un, r * .7, i * 1.1, -1), Jn("u2", t, e, Un, -r * .7, i * 1.1, -1), Jn("u3", t, e, Un, 0, i * 2, -1), Jn("cf1", t, e, Un, -r, 0, 1), Jn("cf2", t, e, Un, r, 0, 1), Jn("cf3", t, e, Un, 0, -i, 1), Jn("cf4", t, e, Un, 0, i, 1), Jn("cn1", t, e, Un, -r, 0, -1), Jn("cn2", t, e, Un, r, 0, -1), Jn("cn3", t, e, Un, 0, -i, -1), Jn("cn4", t, e, Un, 0, i, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function Jn(n, e, t, r, i, o, s) { Zg.set(i, o, s).unproject(r); const a = e[n]; if (a !== void 0) { const l = t.getAttribute("position"); for (let c = 0, u = a.length; c < u; c++)l.setXYZ(a[c], Zg.x, Zg.y, Zg.z) } } const qg = new yi; class MV extends es { constructor(e, t = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), o = new bt; o.setIndex(new Kt(r, 1)), o.setAttribute("position", new Kt(i, 3)), super(o, new qr({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && qg.setFromObject(this.object), qg.isEmpty()) return; const t = qg.min, r = qg.max, i = this.geometry.attributes.position, o = i.array; o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = t.x, o[4] = r.y, o[5] = r.z, o[6] = t.x, o[7] = t.y, o[8] = r.z, o[9] = r.x, o[10] = t.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = t.z, o[15] = t.x, o[16] = r.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = r.x, o[22] = t.y, o[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class wV extends es { constructor(e, t = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new bt; o.setIndex(new Kt(r, 1)), o.setAttribute("position", new ut(i, 3)), super(o, new qr({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class bV extends xa { constructor(e, t = 1, r = 16776960) { const i = r, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new bt; s.setAttribute("position", new ut(o, 3)), s.computeBoundingSphere(), super(s, new qr({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new bt; l.setAttribute("position", new ut(a, 3)), l.computeBoundingSphere(), this.add(new In(l, new hi({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const xR = new X; let e0, xx; class CV extends Ut { constructor(e = new X(0, 0, 1), t = new X(0, 0, 0), r = 1, i = 16776960, o = r * .2, s = o * .2) { super(), this.type = "ArrowHelper", e0 === void 0 && (e0 = new bt, e0.setAttribute("position", new ut([0, 0, 0, 0, 1, 0], 3)), xx = new ld(0, .5, 1, 5, 1), xx.translate(0, -.5, 0)), this.position.copy(t), this.line = new xa(e0, new qr({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new In(xx, new hi({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, o, s) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { xR.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(xR, t) } } setLength(e, t = e * .2, r = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class TV extends es { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], i = new bt; i.setAttribute("position", new ut(t, 3)), i.setAttribute("color", new ut(r, 3)); const o = new qr({ vertexColors: !0, toneMapped: !1 }); super(i, o), this.type = "AxesHelper" } setColors(e, t, r) { const i = new qe, o = this.geometry.attributes.color.array; return i.set(e), i.toArray(o, 0), i.toArray(o, 3), i.set(t), i.toArray(o, 6), i.toArray(o, 9), i.set(r), i.toArray(o, 12), i.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class RV { constructor() { this.type = "ShapePath", this.color = new qe, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new hp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, r, i) { return this.currentPath.quadraticCurveTo(e, t, r, i), this } bezierCurveTo(e, t, r, i, o, s) { return this.currentPath.bezierCurveTo(e, t, r, i, o, s), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(g) { const x = []; for (let A = 0, E = g.length; A < E; A++) { const w = g[A], b = new Ic; b.curves = w.curves, x.push(b) } return x } function r(g, x) { const A = x.length; let E = !1; for (let w = A - 1, b = 0; b < A; w = b++) { let T = x[w], B = x[b], R = B.x - T.x, P = B.y - T.y; if (Math.abs(P) > Number.EPSILON) { if (P < 0 && (T = x[b], R = -R, B = x[w], P = -P), g.y < T.y || g.y > B.y) continue; if (g.y === T.y) { if (g.x === T.x) return !0 } else { const U = P * (g.x - T.x) - R * (g.y - T.y); if (U === 0) return !0; if (U < 0) continue; E = !E } } else { if (g.y !== T.y) continue; if (B.x <= g.x && g.x <= T.x || T.x <= g.x && g.x <= B.x) return !0 } } return E } const i = Rs.isClockWise, o = this.subPaths; if (o.length === 0) return []; let s, a, l; const c = []; if (o.length === 1) return a = o[0], l = new Ic, l.curves = a.curves, c.push(l), c; let u = !i(o[0].getPoints()); u = e ? !u : u; const d = [], p = []; let m = [], v = 0, y; p[v] = void 0, m[v] = []; for (let g = 0, x = o.length; g < x; g++)a = o[g], y = a.getPoints(), s = i(y), s = e ? !s : s, s ? (!u && p[v] && v++, p[v] = { s: new Ic, p: y }, p[v].s.curves = a.curves, u && v++, m[v] = []) : m[v].push({ h: a, p: y[0] }); if (!p[0]) return t(o); if (p.length > 1) { let g = !1, x = 0; for (let A = 0, E = p.length; A < E; A++)d[A] = []; for (let A = 0, E = p.length; A < E; A++) { const w = m[A]; for (let b = 0; b < w.length; b++) { const T = w[b]; let B = !0; for (let R = 0; R < p.length; R++)r(T.p, p[R].p) && (A !== R && x++, B ? (B = !1, d[R].push(T)) : g = !0); B && d[A].push(T) } } x > 0 && g === !1 && (m = d) } let _; for (let g = 0, x = p.length; g < x; g++) { l = p[g].s, c.push(l), _ = m[g]; for (let A = 0, E = _.length; A < E; A++)l.holes.push(_[A].h) } return c } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Qc } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Qc); const PV = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: EM, AddEquation: mc, AddOperation: aD, AdditiveAnimationBlendMode: PM, AdditiveBlending: yv, AlphaFormat: pD, AlwaysCompare: OD, AlwaysDepth: eD, AlwaysStencilFunc: CD, AmbientLight: bO, AnimationAction: DO, AnimationClip: jf, AnimationLoader: U6, AnimationMixer: OO, AnimationObjectGroup: lV, AnimationUtils: L6, ArcCurve: nO, ArrayCamera: $D, ArrowHelper: CV, Audio: IO, AudioAnalyser: Z6, AudioContext: aw, AudioListener: Y6, AudioLoader: X6, AxesHelper: TV, BackSide: $r, BasicDepthPacking: wD, BasicShadowMap: zL, Bone: yy, BooleanKeyframeTrack: eu, Box2: pV, Box3: yi, Box3Helper: wV, BoxGeometry: qc, BoxHelper: MV, BufferAttribute: Kt, BufferGeometry: bt, BufferGeometryLoader: PO, ByteType: dD, Cache: jc, Camera: Np, CameraHelper: EV, CanvasTexture: r6, CapsuleGeometry: Ay, CatmullRomCurve3: rO, CineonToneMapping: uD, CircleGeometry: Ey, ClampToEdgeWrapping: Rr, Clock: Uy, Color: qe, ColorKeyframeTrack: tw, ColorManagement: nn, CompressedArrayTexture: t6, CompressedCubeTexture: n6, CompressedTexture: xy, CompressedTextureLoader: k6, ConeGeometry: My, CubeCamera: HD, CubeReflectionMapping: ya, CubeRefractionMapping: Sl, CubeTexture: zp, CubeTextureLoader: N6, CubeUVReflectionMapping: sd, CubicBezierCurve: JM, CubicBezierCurve3: iO, CubicInterpolant: SO, CullFaceBack: qS, CullFaceFront: NL, CullFaceFrontBack: i5, CullFaceNone: kL, Curve: ts, CurvePath: sO, CustomBlending: GL, CustomToneMapping: fD, CylinderGeometry: ld, Cylindrical: hV, Data3DTexture: FM, DataArrayTexture: fy, DataTexture: bf, DataTextureLoader: z6, DataUtils: cz, DecrementStencilOp: h5, DecrementWrapStencilOp: m5, DefaultLoadingManager: MO, DepthFormat: pl, DepthStencilFormat: Gc, DepthTexture: QD, DirectionalLight: sw, DirectionalLightHelper: AV, DiscreteInterpolant: AO, DisplayP3ColorSpace: uy, DodecahedronGeometry: wy, DoubleSide: Ti, DstAlphaFactor: KL, DstColorFactor: $L, DynamicCopyUsage: P5, DynamicDrawUsage: M5, DynamicReadUsage: C5, EdgesGeometry: aO, EllipseCurve: Sy, EqualCompare: PD, EqualDepth: nD, EqualStencilFunc: _5, EquirectangularReflectionMapping: rp, EquirectangularRefractionMapping: ip, Euler: kp, EventDispatcher: Us, ExtrudeGeometry: Cy, FileLoader: io, Float16BufferAttribute: mz, Float32BufferAttribute: ut, Float64BufferAttribute: gz, FloatType: As, Fog: vy, FogExp2: gy, FramebufferTexture: e6, FrontSide: qo, Frustum: dy, GLBufferAttribute: dV, GLSL1: I5, GLSL3: RA, GreaterCompare: ID, GreaterDepth: iD, GreaterEqualCompare: DD, GreaterEqualDepth: rD, GreaterEqualStencilFunc: E5, GreaterStencilFunc: S5, GridHelper: xV, Group: fa, HalfFloatType: Ts, HemisphereLight: wO, HemisphereLightHelper: _V, IcosahedronGeometry: Ty, ImageBitmapLoader: BO, ImageLoader: vp, ImageUtils: OM, IncrementStencilOp: d5, IncrementWrapStencilOp: p5, InstancedBufferAttribute: Vc, InstancedBufferGeometry: Fy, InstancedInterleavedBuffer: wv, InstancedMesh: VM, Int16BufferAttribute: hz, Int32BufferAttribute: pz, Int8BufferAttribute: uz, IntType: MM, InterleavedBuffer: Gp, InterleavedBufferAttribute: Bi, Interpolant: cd, InterpolateDiscrete: zf, InterpolateLinear: Hc, InterpolateSmooth: F0, InvertStencilOp: g5, KeepStencilOp: U0, KeyframeTrack: ns, LOD: tO, LatheGeometry: Vp, Layers: Bc, LessCompare: RD, LessDepth: tD, LessEqualCompare: BD, LessEqualDepth: _v, LessEqualStencilFunc: x5, LessStencilFunc: y5, Light: Bl, LightProbe: RO, Line: xa, Line3: UO, LineBasicMaterial: qr, LineCurve: KM, LineCurve3: oO, LineDashedMaterial: yO, LineLoop: WM, LineSegments: es, LinearDisplayP3ColorSpace: Fp, LinearEncoding: IM, LinearFilter: fn, LinearInterpolant: ew, LinearMipMapLinearFilter: c5, LinearMipMapNearestFilter: l5, LinearMipmapLinearFilter: Ds, LinearMipmapNearestFilter: ay, LinearSRGBColorSpace: Os, LinearToneMapping: lD, LinearTransfer: ap, Loader: ei, LoaderUtils: Ps, LoadingManager: nw, LoopOnce: SD, LoopPingPong: ED, LoopRepeat: AD, LuminanceAlphaFormat: gD, LuminanceFormat: mD, MOUSE: cc, Material: rr, MaterialLoader: Oy, MathUtils: Up, Matrix3: Rt, Matrix4: _t, MaxEquation: rA, Mesh: In, MeshBasicMaterial: hi, MeshDepthMaterial: py, MeshDistanceMaterial: my, MeshLambertMaterial: gO, MeshMatcapMaterial: vO, MeshNormalMaterial: mO, MeshPhongMaterial: hO, MeshPhysicalMaterial: ks, MeshStandardMaterial: Xp, MeshToonMaterial: pO, MinEquation: nA, MirroredRepeatWrapping: Nf, MixOperation: sD, MultiplyBlending: tA, MultiplyOperation: Op, NearestFilter: Gn, NearestMipMapLinearFilter: a5, NearestMipMapNearestFilter: s5, NearestMipmapLinearFilter: Mf, NearestMipmapNearestFilter: op, NeverCompare: TD, NeverDepth: qL, NeverStencilFunc: v5, NoBlending: bs, NoColorSpace: $i, NoToneMapping: Cs, NormalAnimationBlendMode: cy, NormalBlending: Rc, NotEqualCompare: LD, NotEqualDepth: oD, NotEqualStencilFunc: A5, NumberKeyframeTrack: Vf, Object3D: Ut, ObjectLoader: W6, ObjectSpaceNormalMap: bD, OctahedronGeometry: Wp, OneFactor: jL, OneMinusDstAlphaFactor: YL, OneMinusDstColorFactor: QL, OneMinusSrcAlphaFactor: AM, OneMinusSrcColorFactor: JL, OrthographicCamera: qi, P3Primaries: cp, PCFShadowMap: oy, PCFSoftShadowMap: Ch, PMREMGenerator: BA, Path: hp, PerspectiveCamera: xn, Plane: oa, PlaneGeometry: ba, PlaneHelper: bV, PointLight: ow, PointLightHelper: vV, Points: jM, PointsMaterial: _y, PolarGridHelper: SV, PolyhedronGeometry: Pl, PositionalAudio: Q6, PropertyBinding: Gt, PropertyMixer: LO, QuadraticBezierCurve: YM, QuadraticBezierCurve3: $M, Quaternion: Sr, QuaternionKeyframeTrack: El, QuaternionLinearInterpolant: EO, RED_GREEN_RGTC2_Format: CA, RED_RGTC1_Format: xD, REVISION: Qc, RGBADepthPacking: LM, RGBAFormat: Yr, RGBAIntegerFormat: RM, RGBA_ASTC_10x10_Format: SA, RGBA_ASTC_10x5_Format: yA, RGBA_ASTC_10x6_Format: _A, RGBA_ASTC_10x8_Format: xA, RGBA_ASTC_12x10_Format: AA, RGBA_ASTC_12x12_Format: EA, RGBA_ASTC_4x4_Format: uA, RGBA_ASTC_5x4_Format: fA, RGBA_ASTC_5x5_Format: dA, RGBA_ASTC_6x5_Format: hA, RGBA_ASTC_6x6_Format: pA, RGBA_ASTC_8x5_Format: mA, RGBA_ASTC_8x6_Format: gA, RGBA_ASTC_8x8_Format: vA, RGBA_BPTC_Format: O0, RGBA_ETC2_EAC_Format: cA, RGBA_PVRTC_2BPPV1_Format: aA, RGBA_PVRTC_4BPPV1_Format: sA, RGBA_S3TC_DXT1_Format: I0, RGBA_S3TC_DXT3_Format: L0, RGBA_S3TC_DXT5_Format: D0, RGB_BPTC_SIGNED_Format: MA, RGB_BPTC_UNSIGNED_Format: wA, RGB_ETC1_Format: _D, RGB_ETC2_Format: lA, RGB_PVRTC_2BPPV1_Format: oA, RGB_PVRTC_4BPPV1_Format: iA, RGB_S3TC_DXT1_Format: B0, RGFormat: yD, RGIntegerFormat: TM, RawShaderMaterial: dO, Ray: Zc, Raycaster: FO, Rec709Primaries: lp, RectAreaLight: CO, RedFormat: vD, RedIntegerFormat: CM, ReinhardToneMapping: cD, RenderTarget: ND, RepeatWrapping: Al, ReplaceStencilOp: f5, ReverseSubtractEquation: VL, RingGeometry: Ry, SIGNED_RED_GREEN_RGTC2_Format: TA, SIGNED_RED_RGTC1_Format: bA, SRGBColorSpace: ar, SRGBTransfer: hn, Scene: Ev, ShaderChunk: Tt, ShaderLib: jo, ShaderMaterial: _r, ShadowMaterial: fO, Shape: Ic, ShapeGeometry: Py, ShapePath: RV, ShapeUtils: Rs, ShortType: hD, Skeleton: Hp, SkeletonHelper: gV, SkinnedMesh: HM, Source: Ac, Sphere: _i, SphereGeometry: jp, Spherical: kA, SphericalHarmonics3: TO, SplineCurve: QM, SpotLight: iw, SpotLightHelper: mV, Sprite: eO, SpriteMaterial: GM, SrcAlphaFactor: SM, SrcAlphaSaturateFactor: ZL, SrcColorFactor: XL, StaticCopyUsage: R5, StaticDrawUsage: up, StaticReadUsage: b5, StereoCamera: J6, StreamCopyUsage: B5, StreamDrawUsage: w5, StreamReadUsage: T5, StringKeyframeTrack: tu, SubtractEquation: HL, SubtractiveBlending: eA, TOUCH: uc, TangentSpaceNormalMap: Rl, TetrahedronGeometry: By, Texture: An, TextureLoader: Ca, TorusGeometry: Iy, TorusKnotGeometry: Ly, Triangle: Ci, TriangleFanDrawMode: xv, TriangleStripDrawMode: BM, TrianglesDrawMode: MD, TubeGeometry: Dy, TwoPassDoubleSide: o5, UVMapping: sy, Uint16BufferAttribute: UM, Uint32BufferAttribute: kM, Uint8BufferAttribute: fz, Uint8ClampedBufferAttribute: dz, Uniform: uw, UniformsGroup: fV, UniformsLib: et, UniformsUtils: _a, UnsignedByteType: $o, UnsignedInt248Type: hl, UnsignedIntType: ua, UnsignedShort4444Type: wM, UnsignedShort5551Type: bM, UnsignedShortType: ly, VSMShadowMap: Ho, Vector2: Be, Vector3: X, Vector4: Ft, VectorKeyframeTrack: Wf, VideoTexture: q9, WebGL1Renderer: ZD, WebGL3DRenderTarget: Q5, WebGLArrayRenderTarget: $5, WebGLCoordinateSystem: Es, WebGLCubeRenderTarget: VD, WebGLMultipleRenderTargets: Z5, WebGLRenderTarget: Qr, WebGLRenderer: zM, WebGLUtils: YD, WebGPUCoordinateSystem: fp, WireframeGeometry: ZM, WrapAroundEnding: sp, ZeroCurvatureEnding: xc, ZeroFactor: WL, ZeroSlopeEnding: Sc, ZeroStencilOp: u5, _SRGBAFormat: Sv, createCanvasElement: kD, sRGBEncoding: ml }, Symbol.toStringTag, { value: "Module" })); var NO = { exports: {} }, nu = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */nu.ConcurrentRoot = 1; nu.ContinuousEventPriority = 4; nu.DefaultEventPriority = 16; nu.DiscreteEventPriority = 1; nu.IdleEventPriority = 536870912; nu.LegacyRoot = 0; NO.exports = nu; var pf = NO.exports; function BV(n) { let e; const t = new Set, r = (c, u) => { const d = typeof c == "function" ? c(e) : c; if (d !== e) { const p = e; e = u ? d : Object.assign({}, e, d), t.forEach(m => m(e, p)) } }, i = () => e, o = (c, u = i, d = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let p = u(e); function m() { const v = u(e); if (!d(p, v)) { const y = p; c(p = v, y) } } return t.add(m), () => t.delete(m) }, l = { setState: r, getState: i, subscribe: (c, u, d) => u || d ? o(c, u, d) : (t.add(c), () => t.delete(c)), destroy: () => t.clear() }; return e = n(r, i, l), l } const IV = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), SR = IV ? N.useEffect : N.useLayoutEffect; function LV(n) { const e = typeof n == "function" ? BV(n) : n, t = (r = e.getState, i = Object.is) => { const [, o] = N.useReducer(_ => _ + 1, 0), s = e.getState(), a = N.useRef(s), l = N.useRef(r), c = N.useRef(i), u = N.useRef(!1), d = N.useRef(); d.current === void 0 && (d.current = r(s)); let p, m = !1; (a.current !== s || l.current !== r || c.current !== i || u.current) && (p = r(s), m = !i(d.current, p)), SR(() => { m && (d.current = p), a.current = s, l.current = r, c.current = i, u.current = !1 }); const v = N.useRef(s); SR(() => { const _ = () => { try { const x = e.getState(), A = l.current(x); c.current(d.current, A) || (a.current = x, d.current = A, o()) } catch { u.current = !0, o() } }, g = e.subscribe(_); return e.getState() !== v.current && _(), g }, []); const y = m ? p : d.current; return N.useDebugValue(y), y }; return Object.assign(t, e), t[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const r = [t, e]; return { next() { const i = r.length <= 0; return { value: r.shift(), done: i } } } }, t } var zO = { exports: {} }, GO = { exports: {} }, HO = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(W, V) { var J = W.length; W.push(V); e: for (; 0 < J;) { var O = J - 1 >>> 1, k = W[O]; if (0 < i(k, V)) W[O] = V, W[J] = k, J = O; else break e } } function t(W) { return W.length === 0 ? null : W[0] } function r(W) { if (W.length === 0) return null; var V = W[0], J = W.pop(); if (J !== V) { W[0] = J; e: for (var O = 0, k = W.length, Z = k >>> 1; O < Z;) { var ee = 2 * (O + 1) - 1, ne = W[ee], K = ee + 1, ae = W[K]; if (0 > i(ne, J)) K < k && 0 > i(ae, ne) ? (W[O] = ae, W[K] = J, O = K) : (W[O] = ne, W[ee] = J, O = ee); else if (K < k && 0 > i(ae, J)) W[O] = ae, W[K] = J, O = K; else break e } } return V } function i(W, V) { var J = W.sortIndex - V.sortIndex; return J !== 0 ? J : W.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; n.unstable_now = function () { return o.now() } } else { var s = Date, a = s.now(); n.unstable_now = function () { return s.now() - a } } var l = [], c = [], u = 1, d = null, p = 3, m = !1, v = !1, y = !1, _ = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, x = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function A(W) { for (var V = t(c); V !== null;) { if (V.callback === null) r(c); else if (V.startTime <= W) r(c), V.sortIndex = V.expirationTime, e(l, V); else break; V = t(c) } } function E(W) { if (y = !1, A(W), !v) if (t(l) !== null) v = !0, q(w); else { var V = t(c); V !== null && se(E, V.startTime - W) } } function w(W, V) { v = !1, y && (y = !1, g(B), B = -1), m = !0; var J = p; try { for (A(V), d = t(l); d !== null && (!(d.expirationTime > V) || W && !U());) { var O = d.callback; if (typeof O == "function") { d.callback = null, p = d.priorityLevel; var k = O(d.expirationTime <= V); V = n.unstable_now(), typeof k == "function" ? d.callback = k : d === t(l) && r(l), A(V) } else r(l); d = t(l) } if (d !== null) var Z = !0; else { var ee = t(c); ee !== null && se(E, ee.startTime - V), Z = !1 } return Z } finally { d = null, p = J, m = !1 } } var b = !1, T = null, B = -1, R = 5, P = -1; function U() { return !(n.unstable_now() - P < R) } function G() { if (T !== null) { var W = n.unstable_now(); P = W; var V = !0; try { V = T(!0, W) } finally { V ? $() : (b = !1, T = null) } } else b = !1 } var $; if (typeof x == "function") $ = function () { x(G) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, j = z.port2; z.port1.onmessage = G, $ = function () { j.postMessage(null) } } else $ = function () { _(G, 0) }; function q(W) { T = W, b || (b = !0, $()) } function se(W, V) { B = _(function () { W(n.unstable_now()) }, V) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (W) { W.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, q(w)) }, n.unstable_forceFrameRate = function (W) { 0 > W || 125 < W ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < W ? Math.floor(1e3 / W) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (W) { switch (p) { case 1: case 2: case 3: var V = 3; break; default: V = p }var J = p; p = V; try { return W() } finally { p = J } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (W, V) { switch (W) { case 1: case 2: case 3: case 4: case 5: break; default: W = 3 }var J = p; p = W; try { return V() } finally { p = J } }, n.unstable_scheduleCallback = function (W, V, J) { var O = n.unstable_now(); switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? O + J : O) : J = O, W) { case 1: var k = -1; break; case 2: k = 250; break; case 5: k = 1073741823; break; case 4: k = 1e4; break; default: k = 5e3 }return k = J + k, W = { id: u++, callback: V, priorityLevel: W, startTime: J, expirationTime: k, sortIndex: -1 }, J > O ? (W.sortIndex = J, e(c, W), t(l) === null && W === t(c) && (y ? (g(B), B = -1) : y = !0, se(E, J - O))) : (W.sortIndex = k, e(l, W), v || m || (v = !0, q(w))), W }, n.unstable_shouldYield = U, n.unstable_wrapCallback = function (W) { var V = p; return function () { var J = p; p = V; try { return W.apply(this, arguments) } finally { p = J } } } })(HO); GO.exports = HO; var NA = GO.exports;/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DV = function (e) {
	var t = {}, r = N, i = NA, o = Object.assign; function s(f) { for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + f, S = 1; S < arguments.length; S++)h += "&args[]=" + encodeURIComponent(arguments[S]); return "Minified React error #" + f + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), c = Symbol.for("react.portal"), u = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), v = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), _ = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), w = Symbol.iterator; function b(f) { return f === null || typeof f != "object" ? null : (f = w && f[w] || f["@@iterator"], typeof f == "function" ? f : null) } function T(f) { if (f == null) return null; if (typeof f == "function") return f.displayName || f.name || null; if (typeof f == "string") return f; switch (f) { case u: return "Fragment"; case c: return "Portal"; case p: return "Profiler"; case d: return "StrictMode"; case _: return "Suspense"; case g: return "SuspenseList" }if (typeof f == "object") switch (f.$$typeof) { case v: return (f.displayName || "Context") + ".Consumer"; case m: return (f._context.displayName || "Context") + ".Provider"; case y: var h = f.render; return f = f.displayName, f || (f = h.displayName || h.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f; case x: return h = f.displayName || null, h !== null ? h : T(f.type) || "Memo"; case A: h = f._payload, f = f._init; try { return T(f(h)) } catch { } }return null } function B(f) { var h = f.type; switch (f.tag) { case 24: return "Cache"; case 9: return (h.displayName || "Context") + ".Consumer"; case 10: return (h._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return f = h.render, f = f.displayName || f.name || "", h.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return h; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return T(h); case 8: return h === d ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof h == "function") return h.displayName || h.name || null; if (typeof h == "string") return h }return null } function R(f) { var h = f, S = f; if (f.alternate) for (; h.return;)h = h.return; else { f = h; do h = f, h.flags & 4098 && (S = h.return), f = h.return; while (f) } return h.tag === 3 ? S : null } function P(f) { if (R(f) !== f) throw Error(s(188)) } function U(f) { var h = f.alternate; if (!h) { if (h = R(f), h === null) throw Error(s(188)); return h !== f ? null : f } for (var S = f, M = h; ;) { var C = S.return; if (C === null) break; var I = C.alternate; if (I === null) { if (M = C.return, M !== null) { S = M; continue } break } if (C.child === I.child) { for (I = C.child; I;) { if (I === S) return P(C), f; if (I === M) return P(C), h; I = I.sibling } throw Error(s(188)) } if (S.return !== M.return) S = C, M = I; else { for (var te = !1, ue = C.child; ue;) { if (ue === S) { te = !0, S = C, M = I; break } if (ue === M) { te = !0, M = C, S = I; break } ue = ue.sibling } if (!te) { for (ue = I.child; ue;) { if (ue === S) { te = !0, S = I, M = C; break } if (ue === M) { te = !0, M = I, S = C; break } ue = ue.sibling } if (!te) throw Error(s(189)) } } if (S.alternate !== M) throw Error(s(190)) } if (S.tag !== 3) throw Error(s(188)); return S.stateNode.current === S ? f : h } function G(f) { return f = U(f), f !== null ? $(f) : null } function $(f) { if (f.tag === 5 || f.tag === 6) return f; for (f = f.child; f !== null;) { var h = $(f); if (h !== null) return h; f = f.sibling } return null } function z(f) { if (f.tag === 5 || f.tag === 6) return f; for (f = f.child; f !== null;) { if (f.tag !== 4) { var h = z(f); if (h !== null) return h } f = f.sibling } return null } var j = Array.isArray, q = e.getPublicInstance, se = e.getRootHostContext, W = e.getChildHostContext, V = e.prepareForCommit, J = e.resetAfterCommit, O = e.createInstance, k = e.appendInitialChild, Z = e.finalizeInitialChildren, ee = e.prepareUpdate, ne = e.shouldSetTextContent, K = e.createTextInstance, ae = e.scheduleTimeout, ie = e.cancelTimeout, Se = e.noTimeout, Ce = e.isPrimaryRenderer, le = e.supportsMutation, F = e.supportsPersistence, me = e.supportsHydration, he = e.getInstanceFromNode, ce = e.preparePortalMount, fe = e.getCurrentEventPriority, Re = e.detachDeletedInstance, de = e.supportsMicrotasks, Ie = e.scheduleMicrotask, we = e.supportsTestSelectors, ge = e.findFiberRoot, Ve = e.getBoundingRect, H = e.getTextContent, L = e.isHiddenSubtree, oe = e.matchAccessibilityRole, Pe = e.setFocusIfFocusable, Ae = e.setupIntersectionObserver, ye = e.appendChild, be = e.appendChildToContainer, ke = e.commitTextUpdate, He = e.commitMount, je = e.commitUpdate, nt = e.insertBefore, Te = e.insertInContainerBefore, Je = e.removeChild, re = e.removeChildFromContainer, _e = e.resetTextContent, Ne = e.hideInstance, Y = e.hideTextInstance, Ue = e.unhideInstance, Ge = e.unhideTextInstance, Ke = e.clearContainer, Qe = e.cloneInstance, ze = e.createContainerChildSet, Ze = e.appendChildToContainerChildSet, it = e.finalizeContainerChildren, yt = e.replaceContainerChildren, Ct = e.cloneHiddenInstance, At = e.cloneHiddenTextInstance, xt = e.canHydrateInstance, Yn = e.canHydrateTextInstance, $n = e.canHydrateSuspenseInstance, Dt = e.isSuspenseInstancePending, qt = e.isSuspenseInstanceFallback, tn = e.registerSuspenseInstanceRetry, Ht = e.getNextHydratableSibling, mn = e.getFirstHydratableChild, gn = e.getFirstHydratableChildWithinContainer, Dr = e.getFirstHydratableChildWithinSuspenseInstance, dr = e.hydrateInstance, Q = e.hydrateTextInstance, ve = e.hydrateSuspenseInstance, De = e.getNextHydratableInstanceAfterSuspenseInstance, xe = e.commitHydratedContainer, Oe = e.commitHydratedSuspenseInstance, ot = e.clearSuspenseBoundary, dt = e.clearSuspenseBoundaryFromContainer, Ye = e.shouldDeleteUnhydratedTailInstances, lt = e.didNotMatchHydratedContainerTextInstance, Et = e.didNotMatchHydratedTextInstance, We; function pt(f) {
		if (We === void 0) try { throw Error() } catch (S) { var h = S.stack.trim().match(/\n( *(at )?)/); We = h && h[1] || "" } return `
`+ We + f
	} var ln = !1; function jt(f, h) {
		if (!f || ln) return ""; ln = !0; var S = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (h) if (h = function () { throw Error() }, Object.defineProperty(h.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(h, []) } catch ($e) { var M = $e } Reflect.construct(f, [], h) } else { try { h.call() } catch ($e) { M = $e } f.call(h.prototype) } else { try { throw Error() } catch ($e) { M = $e } f() } } catch ($e) {
			if ($e && M && typeof $e.stack == "string") {
				for (var C = $e.stack.split(`
`), I = M.stack.split(`
`), te = C.length - 1, ue = I.length - 1; 1 <= te && 0 <= ue && C[te] !== I[ue];)ue--; for (; 1 <= te && 0 <= ue; te--, ue--)if (C[te] !== I[ue]) {
					if (te !== 1 || ue !== 1) do if (te--, ue--, 0 > ue || C[te] !== I[ue]) {
						var Fe = `
`+ C[te].replace(" at new ", " at "); return f.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", f.displayName)), Fe
					} while (1 <= te && 0 <= ue); break
				}
			}
		} finally { ln = !1, Error.prepareStackTrace = S } return (f = f ? f.displayName || f.name : "") ? pt(f) : ""
	} var ir = Object.prototype.hasOwnProperty, Or = [], Yt = -1; function gt(f) { return { current: f } } function zt(f) { 0 > Yt || (f.current = Or[Yt], Or[Yt] = null, Yt--) } function vt(f, h) { Yt++, Or[Yt] = f.current, f.current = h } var Vn = {}, On = gt(Vn), En = gt(!1), xi = Vn; function cn(f, h) { var S = f.type.contextTypes; if (!S) return Vn; var M = f.stateNode; if (M && M.__reactInternalMemoizedUnmaskedChildContext === h) return M.__reactInternalMemoizedMaskedChildContext; var C = {}, I; for (I in S) C[I] = h[I]; return M && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = h, f.__reactInternalMemoizedMaskedChildContext = C), C } function dn(f) { return f = f.childContextTypes, f != null } function ri() { zt(En), zt(On) } function Qn(f, h, S) { if (On.current !== Vn) throw Error(s(168)); vt(On, h), vt(En, S) } function is(f, h, S) { var M = f.stateNode; if (h = h.childContextTypes, typeof M.getChildContext != "function") return S; M = M.getChildContext(); for (var C in M) if (!(C in h)) throw Error(s(108, B(f) || "Unknown", C)); return o({}, S, M) } function os(f) { return f = (f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext || Vn, xi = On.current, vt(On, f), vt(En, En.current), !0 } function Fr(f, h, S) { var M = f.stateNode; if (!M) throw Error(s(169)); S ? (f = is(f, h, xi), M.__reactInternalMemoizedMergedChildContext = f, zt(En), zt(On), vt(On, f)) : zt(En), vt(En, S) } var ki = Math.clz32 ? Math.clz32 : om, ru = Math.log, Ll = Math.LN2; function om(f) { return f >>>= 0, f === 0 ? 32 : 31 - (ru(f) / Ll | 0) | 0 } var zs = 64, Gs = 4194304; function Hs(f) { switch (f & -f) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return f & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return f & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return f } } function Dl(f, h) { var S = f.pendingLanes; if (S === 0) return 0; var M = 0, C = f.suspendedLanes, I = f.pingedLanes, te = S & 268435455; if (te !== 0) { var ue = te & ~C; ue !== 0 ? M = Hs(ue) : (I &= te, I !== 0 && (M = Hs(I))) } else te = S & ~C, te !== 0 ? M = Hs(te) : I !== 0 && (M = Hs(I)); if (M === 0) return 0; if (h !== 0 && h !== M && !(h & C) && (C = M & -M, I = h & -h, C >= I || C === 16 && (I & 4194240) !== 0)) return h; if (M & 4 && (M |= S & 16), h = f.entangledLanes, h !== 0) for (f = f.entanglements, h &= M; 0 < h;)S = 31 - ki(h), C = 1 << S, M |= f[S], h &= ~C; return M } function sm(f, h) { switch (f) { case 1: case 2: case 4: return h + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return h + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function dd(f, h) { for (var S = f.suspendedLanes, M = f.pingedLanes, C = f.expirationTimes, I = f.pendingLanes; 0 < I;) { var te = 31 - ki(I), ue = 1 << te, Fe = C[te]; Fe === -1 ? (!(ue & S) || ue & M) && (C[te] = sm(ue, h)) : Fe <= h && (f.expiredLanes |= ue), I &= ~ue } } function Vs(f) { return f = f.pendingLanes & -1073741825, f !== 0 ? f : f & 1073741824 ? 1073741824 : 0 } function iu(f) { for (var h = [], S = 0; 31 > S; S++)h.push(f); return h } function ss(f, h, S) { f.pendingLanes |= h, h !== 536870912 && (f.suspendedLanes = 0, f.pingedLanes = 0), f = f.eventTimes, h = 31 - ki(h), f[h] = S } function Pa(f, h) { var S = f.pendingLanes & ~h; f.pendingLanes = h, f.suspendedLanes = 0, f.pingedLanes = 0, f.expiredLanes &= h, f.mutableReadLanes &= h, f.entangledLanes &= h, h = f.entanglements; var M = f.eventTimes; for (f = f.expirationTimes; 0 < S;) { var C = 31 - ki(S), I = 1 << C; h[C] = 0, M[C] = -1, f[C] = -1, S &= ~I } } function as(f, h) { var S = f.entangledLanes |= h; for (f = f.entanglements; S;) { var M = 31 - ki(S), C = 1 << M; C & h | f[M] & h && (f[M] |= h), S &= ~C } } var Ot = 0; function hd(f) { return f &= -f, 1 < f ? 4 < f ? f & 268435455 ? 16 : 536870912 : 4 : 1 } var Ws = i.unstable_scheduleCallback, ou = i.unstable_cancelCallback, pd = i.unstable_shouldYield, am = i.unstable_requestPaint, Tn = i.unstable_now, Ol = i.unstable_ImmediatePriority, lm = i.unstable_UserBlockingPriority, ii = i.unstable_NormalPriority, md = i.unstable_IdlePriority, Fl = null, Ni = null; function gd(f) { if (Ni && typeof Ni.onCommitFiberRoot == "function") try { Ni.onCommitFiberRoot(Fl, f, void 0, (f.current.flags & 128) === 128) } catch { } } function cm(f, h) { return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h } var zi = typeof Object.is == "function" ? Object.is : cm, oi = null, ls = !1, fo = !1; function vd(f) { oi === null ? oi = [f] : oi.push(f) } function yd(f) { ls = !0, vd(f) } function Si() { if (!fo && oi !== null) { fo = !0; var f = 0, h = Ot; try { var S = oi; for (Ot = 1; f < S.length; f++) { var M = S[f]; do M = M(!0); while (M !== null) } oi = null, ls = !1 } catch (C) { throw oi !== null && (oi = oi.slice(f + 1)), Ws(Ol, Si), C } finally { Ot = h, fo = !1 } } return null } var Ul = a.ReactCurrentBatchConfig; function kl(f, h) { if (zi(f, h)) return !0; if (typeof f != "object" || f === null || typeof h != "object" || h === null) return !1; var S = Object.keys(f), M = Object.keys(h); if (S.length !== M.length) return !1; for (M = 0; M < S.length; M++) { var C = S[M]; if (!ir.call(h, C) || !zi(f[C], h[C])) return !1 } return !0 } function Nl(f) { switch (f.tag) { case 5: return pt(f.type); case 16: return pt("Lazy"); case 13: return pt("Suspense"); case 19: return pt("SuspenseList"); case 0: case 2: case 15: return f = jt(f.type, !1), f; case 11: return f = jt(f.type.render, !1), f; case 1: return f = jt(f.type, !0), f; default: return "" } } function si(f, h) { if (f && f.defaultProps) { h = o({}, h), f = f.defaultProps; for (var S in f) h[S] === void 0 && (h[S] = f[S]); return h } return h } var hr = gt(null), su = null, Oo = null, Ba = null; function au() { Ba = Oo = su = null } function um(f, h, S) { Ce ? (vt(hr, h._currentValue), h._currentValue = S) : (vt(hr, h._currentValue2), h._currentValue2 = S) } function pr(f) { var h = hr.current; zt(hr), Ce ? f._currentValue = h : f._currentValue2 = h } function ai(f, h, S) { for (; f !== null;) { var M = f.alternate; if ((f.childLanes & h) !== h ? (f.childLanes |= h, M !== null && (M.childLanes |= h)) : M !== null && (M.childLanes & h) !== h && (M.childLanes |= h), f === S) break; f = f.return } } function Wn(f, h) { su = f, Ba = Oo = null, f = f.dependencies, f !== null && f.firstContext !== null && (f.lanes & h && (Wi = !0), f.firstContext = null) } function jn(f) { var h = Ce ? f._currentValue : f._currentValue2; if (Ba !== f) if (f = { context: f, memoizedValue: h, next: null }, Oo === null) { if (su === null) throw Error(s(308)); Oo = f, su.dependencies = { lanes: 0, firstContext: f } } else Oo = Oo.next = f; return h } var Gi = null, Ia = !1; function E1(f) { f.updateQueue = { baseState: f.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function db(f, h) { f = f.updateQueue, h.updateQueue === f && (h.updateQueue = { baseState: f.baseState, firstBaseUpdate: f.firstBaseUpdate, lastBaseUpdate: f.lastBaseUpdate, shared: f.shared, effects: f.effects }) } function js(f, h) { return { eventTime: f, lane: h, tag: 0, payload: null, callback: null, next: null } } function La(f, h) { var S = f.updateQueue; S !== null && (S = S.shared, Zn !== null && f.mode & 1 && !(Lt & 2) ? (f = S.interleaved, f === null ? (h.next = h, Gi === null ? Gi = [S] : Gi.push(S)) : (h.next = f.next, f.next = h), S.interleaved = h) : (f = S.pending, f === null ? h.next = h : (h.next = f.next, f.next = h), S.pending = h)) } function fm(f, h, S) { if (h = h.updateQueue, h !== null && (h = h.shared, (S & 4194240) !== 0)) { var M = h.lanes; M &= f.pendingLanes, S |= M, h.lanes = S, as(f, S) } } function hb(f, h) { var S = f.updateQueue, M = f.alternate; if (M !== null && (M = M.updateQueue, S === M)) { var C = null, I = null; if (S = S.firstBaseUpdate, S !== null) { do { var te = { eventTime: S.eventTime, lane: S.lane, tag: S.tag, payload: S.payload, callback: S.callback, next: null }; I === null ? C = I = te : I = I.next = te, S = S.next } while (S !== null); I === null ? C = I = h : I = I.next = h } else C = I = h; S = { baseState: M.baseState, firstBaseUpdate: C, lastBaseUpdate: I, shared: M.shared, effects: M.effects }, f.updateQueue = S; return } f = S.lastBaseUpdate, f === null ? S.firstBaseUpdate = h : f.next = h, S.lastBaseUpdate = h } function dm(f, h, S, M) { var C = f.updateQueue; Ia = !1; var I = C.firstBaseUpdate, te = C.lastBaseUpdate, ue = C.shared.pending; if (ue !== null) { C.shared.pending = null; var Fe = ue, $e = Fe.next; Fe.next = null, te === null ? I = $e : te.next = $e, te = Fe; var ct = f.alternate; ct !== null && (ct = ct.updateQueue, ue = ct.lastBaseUpdate, ue !== te && (ue === null ? ct.firstBaseUpdate = $e : ue.next = $e, ct.lastBaseUpdate = Fe)) } if (I !== null) { var Mt = C.baseState; te = 0, ct = $e = Fe = null, ue = I; do { var mt = ue.lane, un = ue.eventTime; if ((M & mt) === mt) { ct !== null && (ct = ct.next = { eventTime: un, lane: 0, tag: ue.tag, payload: ue.payload, callback: ue.callback, next: null }); e: { var ht = f, zr = ue; switch (mt = h, un = S, zr.tag) { case 1: if (ht = zr.payload, typeof ht == "function") { Mt = ht.call(un, Mt, mt); break e } Mt = ht; break e; case 3: ht.flags = ht.flags & -65537 | 128; case 0: if (ht = zr.payload, mt = typeof ht == "function" ? ht.call(un, Mt, mt) : ht, mt == null) break e; Mt = o({}, Mt, mt); break e; case 2: Ia = !0 } } ue.callback !== null && ue.lane !== 0 && (f.flags |= 64, mt = C.effects, mt === null ? C.effects = [ue] : mt.push(ue)) } else un = { eventTime: un, lane: mt, tag: ue.tag, payload: ue.payload, callback: ue.callback, next: null }, ct === null ? ($e = ct = un, Fe = Mt) : ct = ct.next = un, te |= mt; if (ue = ue.next, ue === null) { if (ue = C.shared.pending, ue === null) break; mt = ue, ue = mt.next, mt.next = null, C.lastBaseUpdate = mt, C.shared.pending = null } } while (1); if (ct === null && (Fe = Mt), C.baseState = Fe, C.firstBaseUpdate = $e, C.lastBaseUpdate = ct, h = C.shared.interleaved, h !== null) { C = h; do te |= C.lane, C = C.next; while (C !== h) } else I === null && (C.shared.lanes = 0); gu |= te, f.lanes = te, f.memoizedState = Mt } } function pb(f, h, S) { if (f = h.effects, h.effects = null, f !== null) for (h = 0; h < f.length; h++) { var M = f[h], C = M.callback; if (C !== null) { if (M.callback = null, M = S, typeof C != "function") throw Error(s(191, C)); C.call(M) } } } var mb = new r.Component().refs; function M1(f, h, S, M) { h = f.memoizedState, S = S(M, h), S = S == null ? h : o({}, h, S), f.memoizedState = S, f.lanes === 0 && (f.updateQueue.baseState = S) } var hm = { isMounted: function (f) { return (f = f._reactInternals) ? R(f) === f : !1 }, enqueueSetState: function (f, h, S) { f = f._reactInternals; var M = ci(), C = Fa(f), I = js(M, C); I.payload = h, S != null && (I.callback = S), La(f, I), h = vo(f, C, M), h !== null && fm(h, f, C) }, enqueueReplaceState: function (f, h, S) { f = f._reactInternals; var M = ci(), C = Fa(f), I = js(M, C); I.tag = 1, I.payload = h, S != null && (I.callback = S), La(f, I), h = vo(f, C, M), h !== null && fm(h, f, C) }, enqueueForceUpdate: function (f, h) { f = f._reactInternals; var S = ci(), M = Fa(f), C = js(S, M); C.tag = 2, h != null && (C.callback = h), La(f, C), h = vo(f, M, S), h !== null && fm(h, f, M) } }; function gb(f, h, S, M, C, I, te) { return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(M, I, te) : h.prototype && h.prototype.isPureReactComponent ? !kl(S, M) || !kl(C, I) : !0 } function vb(f, h, S) { var M = !1, C = Vn, I = h.contextType; return typeof I == "object" && I !== null ? I = jn(I) : (C = dn(h) ? xi : On.current, M = h.contextTypes, I = (M = M != null) ? cn(f, C) : Vn), h = new h(S, I), f.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = hm, f.stateNode = h, h._reactInternals = f, M && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = C, f.__reactInternalMemoizedMaskedChildContext = I), h } function yb(f, h, S, M) { f = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(S, M), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(S, M), h.state !== f && hm.enqueueReplaceState(h, h.state, null) } function w1(f, h, S, M) { var C = f.stateNode; C.props = S, C.state = f.memoizedState, C.refs = mb, E1(f); var I = h.contextType; typeof I == "object" && I !== null ? C.context = jn(I) : (I = dn(h) ? xi : On.current, C.context = cn(f, I)), C.state = f.memoizedState, I = h.getDerivedStateFromProps, typeof I == "function" && (M1(f, h, I, S), C.state = f.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (h = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), h !== C.state && hm.enqueueReplaceState(C, C.state, null), dm(f, S, C, M), C.state = f.memoizedState), typeof C.componentDidMount == "function" && (f.flags |= 4194308) } var lu = [], cu = 0, pm = null, mm = 0, ho = [], po = 0, zl = null, Xs = 1, Js = ""; function Gl(f, h) { lu[cu++] = mm, lu[cu++] = pm, pm = f, mm = h } function _b(f, h, S) { ho[po++] = Xs, ho[po++] = Js, ho[po++] = zl, zl = f; var M = Xs; f = Js; var C = 32 - ki(M) - 1; M &= ~(1 << C), S += 1; var I = 32 - ki(h) + C; if (30 < I) { var te = C - C % 5; I = (M & (1 << te) - 1).toString(32), M >>= te, C -= te, Xs = 1 << 32 - ki(h) + C | S << C | M, Js = I + f } else Xs = 1 << I | S << C | M, Js = f } function b1(f) { f.return !== null && (Gl(f, 1), _b(f, 1, 0)) } function C1(f) { for (; f === pm;)pm = lu[--cu], lu[cu] = null, mm = lu[--cu], lu[cu] = null; for (; f === zl;)zl = ho[--po], ho[po] = null, Js = ho[--po], ho[po] = null, Xs = ho[--po], ho[po] = null } var Hi = null, Vi = null, Mn = !1, _d = !1, Fo = null; function xb(f, h) { var S = yo(5, null, null, 0); S.elementType = "DELETED", S.stateNode = h, S.return = f, h = f.deletions, h === null ? (f.deletions = [S], f.flags |= 16) : h.push(S) } function Sb(f, h) { switch (f.tag) { case 5: return h = xt(h, f.type, f.pendingProps), h !== null ? (f.stateNode = h, Hi = f, Vi = mn(h), !0) : !1; case 6: return h = Yn(h, f.pendingProps), h !== null ? (f.stateNode = h, Hi = f, Vi = null, !0) : !1; case 13: if (h = $n(h), h !== null) { var S = zl !== null ? { id: Xs, overflow: Js } : null; return f.memoizedState = { dehydrated: h, treeContext: S, retryLane: 1073741824 }, S = yo(18, null, null, 0), S.stateNode = h, S.return = f, f.child = S, Hi = f, Vi = null, !0 } return !1; default: return !1 } } function T1(f) { return (f.mode & 1) !== 0 && (f.flags & 128) === 0 } function R1(f) { if (Mn) { var h = Vi; if (h) { var S = h; if (!Sb(f, h)) { if (T1(f)) throw Error(s(418)); h = Ht(S); var M = Hi; h && Sb(f, h) ? xb(M, S) : (f.flags = f.flags & -4097 | 2, Mn = !1, Hi = f) } } else { if (T1(f)) throw Error(s(418)); f.flags = f.flags & -4097 | 2, Mn = !1, Hi = f } } } function Ab(f) { for (f = f.return; f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;)f = f.return; Hi = f } function xd(f) { if (!me || f !== Hi) return !1; if (!Mn) return Ab(f), Mn = !0, !1; if (f.tag !== 3 && (f.tag !== 5 || Ye(f.type) && !ne(f.type, f.memoizedProps))) { var h = Vi; if (h) { if (T1(f)) { for (f = Vi; f;)f = Ht(f); throw Error(s(418)) } for (; h;)xb(f, h), h = Ht(h) } } if (Ab(f), f.tag === 13) { if (!me) throw Error(s(316)); if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(s(317)); Vi = De(f) } else Vi = Hi ? Ht(f.stateNode) : null; return !0 } function uu() { me && (Vi = Hi = null, _d = Mn = !1) } function P1(f) { Fo === null ? Fo = [f] : Fo.push(f) } function Sd(f, h, S) { if (f = S.ref, f !== null && typeof f != "function" && typeof f != "object") { if (S._owner) { if (S = S._owner, S) { if (S.tag !== 1) throw Error(s(309)); var M = S.stateNode } if (!M) throw Error(s(147, f)); var C = M, I = "" + f; return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === I ? h.ref : (h = function (te) { var ue = C.refs; ue === mb && (ue = C.refs = {}), te === null ? delete ue[I] : ue[I] = te }, h._stringRef = I, h) } if (typeof f != "string") throw Error(s(284)); if (!S._owner) throw Error(s(290, f)) } return f } function gm(f, h) { throw f = Object.prototype.toString.call(h), Error(s(31, f === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : f)) } function Eb(f) { var h = f._init; return h(f._payload) } function Mb(f) { function h(Me, pe) { if (f) { var Le = Me.deletions; Le === null ? (Me.deletions = [pe], Me.flags |= 16) : Le.push(pe) } } function S(Me, pe) { if (!f) return null; for (; pe !== null;)h(Me, pe), pe = pe.sibling; return null } function M(Me, pe) { for (Me = new Map; pe !== null;)pe.key !== null ? Me.set(pe.key, pe) : Me.set(pe.index, pe), pe = pe.sibling; return Me } function C(Me, pe) { return Me = ka(Me, pe), Me.index = 0, Me.sibling = null, Me } function I(Me, pe, Le) { return Me.index = Le, f ? (Le = Me.alternate, Le !== null ? (Le = Le.index, Le < pe ? (Me.flags |= 2, pe) : Le) : (Me.flags |= 2, pe)) : (Me.flags |= 1048576, pe) } function te(Me) { return f && Me.alternate === null && (Me.flags |= 2), Me } function ue(Me, pe, Le, rt) { return pe === null || pe.tag !== 6 ? (pe = h_(Le, Me.mode, rt), pe.return = Me, pe) : (pe = C(pe, Le), pe.return = Me, pe) } function Fe(Me, pe, Le, rt) { var ft = Le.type; return ft === u ? ct(Me, pe, Le.props.children, rt, Le.key) : pe !== null && (pe.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === A && Eb(ft) === pe.type) ? (rt = C(pe, Le.props), rt.ref = Sd(Me, pe, Le), rt.return = Me, rt) : (rt = Jm(Le.type, Le.key, Le.props, null, Me.mode, rt), rt.ref = Sd(Me, pe, Le), rt.return = Me, rt) } function $e(Me, pe, Le, rt) { return pe === null || pe.tag !== 4 || pe.stateNode.containerInfo !== Le.containerInfo || pe.stateNode.implementation !== Le.implementation ? (pe = p_(Le, Me.mode, rt), pe.return = Me, pe) : (pe = C(pe, Le.children || []), pe.return = Me, pe) } function ct(Me, pe, Le, rt, ft) { return pe === null || pe.tag !== 7 ? (pe = Kl(Le, Me.mode, rt, ft), pe.return = Me, pe) : (pe = C(pe, Le), pe.return = Me, pe) } function Mt(Me, pe, Le) { if (typeof pe == "string" && pe !== "" || typeof pe == "number") return pe = h_("" + pe, Me.mode, Le), pe.return = Me, pe; if (typeof pe == "object" && pe !== null) { switch (pe.$$typeof) { case l: return Le = Jm(pe.type, pe.key, pe.props, null, Me.mode, Le), Le.ref = Sd(Me, null, pe), Le.return = Me, Le; case c: return pe = p_(pe, Me.mode, Le), pe.return = Me, pe; case A: var rt = pe._init; return Mt(Me, rt(pe._payload), Le) }if (j(pe) || b(pe)) return pe = Kl(pe, Me.mode, Le, null), pe.return = Me, pe; gm(Me, pe) } return null } function mt(Me, pe, Le, rt) { var ft = pe !== null ? pe.key : null; if (typeof Le == "string" && Le !== "" || typeof Le == "number") return ft !== null ? null : ue(Me, pe, "" + Le, rt); if (typeof Le == "object" && Le !== null) { switch (Le.$$typeof) { case l: return Le.key === ft ? Fe(Me, pe, Le, rt) : null; case c: return Le.key === ft ? $e(Me, pe, Le, rt) : null; case A: return ft = Le._init, mt(Me, pe, ft(Le._payload), rt) }if (j(Le) || b(Le)) return ft !== null ? null : ct(Me, pe, Le, rt, null); gm(Me, Le) } return null } function un(Me, pe, Le, rt, ft) { if (typeof rt == "string" && rt !== "" || typeof rt == "number") return Me = Me.get(Le) || null, ue(pe, Me, "" + rt, ft); if (typeof rt == "object" && rt !== null) { switch (rt.$$typeof) { case l: return Me = Me.get(rt.key === null ? Le : rt.key) || null, Fe(pe, Me, rt, ft); case c: return Me = Me.get(rt.key === null ? Le : rt.key) || null, $e(pe, Me, rt, ft); case A: var Bt = rt._init; return un(Me, pe, Le, Bt(rt._payload), ft) }if (j(rt) || b(rt)) return Me = Me.get(Le) || null, ct(pe, Me, rt, ft, null); gm(pe, rt) } return null } function ht(Me, pe, Le, rt) { for (var ft = null, Bt = null, wt = pe, Xt = pe = 0, gr = null; wt !== null && Xt < Le.length; Xt++) { wt.index > Xt ? (gr = wt, wt = null) : gr = wt.sibling; var Jt = mt(Me, wt, Le[Xt], rt); if (Jt === null) { wt === null && (wt = gr); break } f && wt && Jt.alternate === null && h(Me, wt), pe = I(Jt, pe, Xt), Bt === null ? ft = Jt : Bt.sibling = Jt, Bt = Jt, wt = gr } if (Xt === Le.length) return S(Me, wt), Mn && Gl(Me, Xt), ft; if (wt === null) { for (; Xt < Le.length; Xt++)wt = Mt(Me, Le[Xt], rt), wt !== null && (pe = I(wt, pe, Xt), Bt === null ? ft = wt : Bt.sibling = wt, Bt = wt); return Mn && Gl(Me, Xt), ft } for (wt = M(Me, wt); Xt < Le.length; Xt++)gr = un(wt, Me, Xt, Le[Xt], rt), gr !== null && (f && gr.alternate !== null && wt.delete(gr.key === null ? Xt : gr.key), pe = I(gr, pe, Xt), Bt === null ? ft = gr : Bt.sibling = gr, Bt = gr); return f && wt.forEach(function (Na) { return h(Me, Na) }), Mn && Gl(Me, Xt), ft } function zr(Me, pe, Le, rt) { var ft = b(Le); if (typeof ft != "function") throw Error(s(150)); if (Le = ft.call(Le), Le == null) throw Error(s(151)); for (var Bt = ft = null, wt = pe, Xt = pe = 0, gr = null, Jt = Le.next(); wt !== null && !Jt.done; Xt++, Jt = Le.next()) { wt.index > Xt ? (gr = wt, wt = null) : gr = wt.sibling; var Na = mt(Me, wt, Jt.value, rt); if (Na === null) { wt === null && (wt = gr); break } f && wt && Na.alternate === null && h(Me, wt), pe = I(Na, pe, Xt), Bt === null ? ft = Na : Bt.sibling = Na, Bt = Na, wt = gr } if (Jt.done) return S(Me, wt), Mn && Gl(Me, Xt), ft; if (wt === null) { for (; !Jt.done; Xt++, Jt = Le.next())Jt = Mt(Me, Jt.value, rt), Jt !== null && (pe = I(Jt, pe, Xt), Bt === null ? ft = Jt : Bt.sibling = Jt, Bt = Jt); return Mn && Gl(Me, Xt), ft } for (wt = M(Me, wt); !Jt.done; Xt++, Jt = Le.next())Jt = un(wt, Me, Xt, Jt.value, rt), Jt !== null && (f && Jt.alternate !== null && wt.delete(Jt.key === null ? Xt : Jt.key), pe = I(Jt, pe, Xt), Bt === null ? ft = Jt : Bt.sibling = Jt, Bt = Jt); return f && wt.forEach(function (kk) { return h(Me, kk) }), Mn && Gl(Me, Xt), ft } function _o(Me, pe, Le, rt) { if (typeof Le == "object" && Le !== null && Le.type === u && Le.key === null && (Le = Le.props.children), typeof Le == "object" && Le !== null) { switch (Le.$$typeof) { case l: e: { for (var ft = Le.key, Bt = pe; Bt !== null;) { if (Bt.key === ft) { if (ft = Le.type, ft === u) { if (Bt.tag === 7) { S(Me, Bt.sibling), pe = C(Bt, Le.props.children), pe.return = Me, Me = pe; break e } } else if (Bt.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === A && Eb(ft) === Bt.type) { S(Me, Bt.sibling), pe = C(Bt, Le.props), pe.ref = Sd(Me, Bt, Le), pe.return = Me, Me = pe; break e } S(Me, Bt); break } else h(Me, Bt); Bt = Bt.sibling } Le.type === u ? (pe = Kl(Le.props.children, Me.mode, rt, Le.key), pe.return = Me, Me = pe) : (rt = Jm(Le.type, Le.key, Le.props, null, Me.mode, rt), rt.ref = Sd(Me, pe, Le), rt.return = Me, Me = rt) } return te(Me); case c: e: { for (Bt = Le.key; pe !== null;) { if (pe.key === Bt) if (pe.tag === 4 && pe.stateNode.containerInfo === Le.containerInfo && pe.stateNode.implementation === Le.implementation) { S(Me, pe.sibling), pe = C(pe, Le.children || []), pe.return = Me, Me = pe; break e } else { S(Me, pe); break } else h(Me, pe); pe = pe.sibling } pe = p_(Le, Me.mode, rt), pe.return = Me, Me = pe } return te(Me); case A: return Bt = Le._init, _o(Me, pe, Bt(Le._payload), rt) }if (j(Le)) return ht(Me, pe, Le, rt); if (b(Le)) return zr(Me, pe, Le, rt); gm(Me, Le) } return typeof Le == "string" && Le !== "" || typeof Le == "number" ? (Le = "" + Le, pe !== null && pe.tag === 6 ? (S(Me, pe.sibling), pe = C(pe, Le), pe.return = Me, Me = pe) : (S(Me, pe), pe = h_(Le, Me.mode, rt), pe.return = Me, Me = pe), te(Me)) : S(Me, pe) } return _o } var fu = Mb(!0), wb = Mb(!1), Ad = {}, mo = gt(Ad), Ed = gt(Ad), du = gt(Ad); function cs(f) { if (f === Ad) throw Error(s(174)); return f } function B1(f, h) { vt(du, h), vt(Ed, f), vt(mo, Ad), f = se(h), zt(mo), vt(mo, f) } function hu() { zt(mo), zt(Ed), zt(du) } function bb(f) { var h = cs(du.current), S = cs(mo.current); h = W(S, f.type, h), S !== h && (vt(Ed, f), vt(mo, h)) } function I1(f) { Ed.current === f && (zt(mo), zt(Ed)) } var Rn = gt(0); function vm(f) { for (var h = f; h !== null;) { if (h.tag === 13) { var S = h.memoizedState; if (S !== null && (S = S.dehydrated, S === null || Dt(S) || qt(S))) return h } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) { if (h.flags & 128) return h } else if (h.child !== null) { h.child.return = h, h = h.child; continue } if (h === f) break; for (; h.sibling === null;) { if (h.return === null || h.return === f) return null; h = h.return } h.sibling.return = h.return, h = h.sibling } return null } var L1 = []; function D1() { for (var f = 0; f < L1.length; f++) { var h = L1[f]; Ce ? h._workInProgressVersionPrimary = null : h._workInProgressVersionSecondary = null } L1.length = 0 } var ym = a.ReactCurrentDispatcher, go = a.ReactCurrentBatchConfig, pu = 0, Fn = null, Ur = null, mr = null, _m = !1, Md = !1, wd = 0, ck = 0; function kr() { throw Error(s(321)) } function O1(f, h) { if (h === null) return !1; for (var S = 0; S < h.length && S < f.length; S++)if (!zi(f[S], h[S])) return !1; return !0 } function F1(f, h, S, M, C, I) { if (pu = I, Fn = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, ym.current = f === null || f.memoizedState === null ? hk : pk, f = S(M, C), Md) { I = 0; do { if (Md = !1, wd = 0, 25 <= I) throw Error(s(301)); I += 1, mr = Ur = null, h.updateQueue = null, ym.current = mk, f = S(M, C) } while (Md) } if (ym.current = Mm, h = Ur !== null && Ur.next !== null, pu = 0, mr = Ur = Fn = null, _m = !1, h) throw Error(s(300)); return f } function U1() { var f = wd !== 0; return wd = 0, f } function Ks() { var f = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return mr === null ? Fn.memoizedState = mr = f : mr = mr.next = f, mr } function us() { if (Ur === null) { var f = Fn.alternate; f = f !== null ? f.memoizedState : null } else f = Ur.next; var h = mr === null ? Fn.memoizedState : mr.next; if (h !== null) mr = h, Ur = f; else { if (f === null) throw Error(s(310)); Ur = f, f = { memoizedState: Ur.memoizedState, baseState: Ur.baseState, baseQueue: Ur.baseQueue, queue: Ur.queue, next: null }, mr === null ? Fn.memoizedState = mr = f : mr = mr.next = f } return mr } function Hl(f, h) { return typeof h == "function" ? h(f) : h } function xm(f) { var h = us(), S = h.queue; if (S === null) throw Error(s(311)); S.lastRenderedReducer = f; var M = Ur, C = M.baseQueue, I = S.pending; if (I !== null) { if (C !== null) { var te = C.next; C.next = I.next, I.next = te } M.baseQueue = C = I, S.pending = null } if (C !== null) { I = C.next, M = M.baseState; var ue = te = null, Fe = null, $e = I; do { var ct = $e.lane; if ((pu & ct) === ct) Fe !== null && (Fe = Fe.next = { lane: 0, action: $e.action, hasEagerState: $e.hasEagerState, eagerState: $e.eagerState, next: null }), M = $e.hasEagerState ? $e.eagerState : f(M, $e.action); else { var Mt = { lane: ct, action: $e.action, hasEagerState: $e.hasEagerState, eagerState: $e.eagerState, next: null }; Fe === null ? (ue = Fe = Mt, te = M) : Fe = Fe.next = Mt, Fn.lanes |= ct, gu |= ct } $e = $e.next } while ($e !== null && $e !== I); Fe === null ? te = M : Fe.next = ue, zi(M, h.memoizedState) || (Wi = !0), h.memoizedState = M, h.baseState = te, h.baseQueue = Fe, S.lastRenderedState = M } if (f = S.interleaved, f !== null) { C = f; do I = C.lane, Fn.lanes |= I, gu |= I, C = C.next; while (C !== f) } else C === null && (S.lanes = 0); return [h.memoizedState, S.dispatch] } function Sm(f) { var h = us(), S = h.queue; if (S === null) throw Error(s(311)); S.lastRenderedReducer = f; var M = S.dispatch, C = S.pending, I = h.memoizedState; if (C !== null) { S.pending = null; var te = C = C.next; do I = f(I, te.action), te = te.next; while (te !== C); zi(I, h.memoizedState) || (Wi = !0), h.memoizedState = I, h.baseQueue === null && (h.baseState = I), S.lastRenderedState = I } return [I, M] } function Cb() { } function Tb(f, h) { var S = Fn, M = us(), C = h(), I = !zi(M.memoizedState, C); if (I && (M.memoizedState = C, Wi = !0), M = M.queue, Cd(Bb.bind(null, S, M, f), [f]), M.getSnapshot !== h || I || mr !== null && mr.memoizedState.tag & 1) { if (S.flags |= 2048, bd(9, Pb.bind(null, S, M, C, h), void 0, null), Zn === null) throw Error(s(349)); pu & 30 || Rb(S, h, C) } return C } function Rb(f, h, S) { f.flags |= 16384, f = { getSnapshot: h, value: S }, h = Fn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Fn.updateQueue = h, h.stores = [f]) : (S = h.stores, S === null ? h.stores = [f] : S.push(f)) } function Pb(f, h, S, M) { h.value = S, h.getSnapshot = M, Ib(h) && vo(f, 1, -1) } function Bb(f, h, S) { return S(function () { Ib(h) && vo(f, 1, -1) }) } function Ib(f) { var h = f.getSnapshot; f = f.value; try { var S = h(); return !zi(f, S) } catch { return !0 } } function k1(f) { var h = Ks(); return typeof f == "function" && (f = f()), h.memoizedState = h.baseState = f, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Hl, lastRenderedState: f }, h.queue = f, f = f.dispatch = dk.bind(null, Fn, f), [h.memoizedState, f] } function bd(f, h, S, M) { return f = { tag: f, create: h, destroy: S, deps: M, next: null }, h = Fn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Fn.updateQueue = h, h.lastEffect = f.next = f) : (S = h.lastEffect, S === null ? h.lastEffect = f.next = f : (M = S.next, S.next = f, f.next = M, h.lastEffect = f)), f } function Lb() { return us().memoizedState } function Am(f, h, S, M) { var C = Ks(); Fn.flags |= f, C.memoizedState = bd(1 | h, S, void 0, M === void 0 ? null : M) } function Em(f, h, S, M) { var C = us(); M = M === void 0 ? null : M; var I = void 0; if (Ur !== null) { var te = Ur.memoizedState; if (I = te.destroy, M !== null && O1(M, te.deps)) { C.memoizedState = bd(h, S, I, M); return } } Fn.flags |= f, C.memoizedState = bd(1 | h, S, I, M) } function N1(f, h) { return Am(8390656, 8, f, h) } function Cd(f, h) { return Em(2048, 8, f, h) } function Db(f, h) { return Em(4, 2, f, h) } function Ob(f, h) { return Em(4, 4, f, h) } function Fb(f, h) { if (typeof h == "function") return f = f(), h(f), function () { h(null) }; if (h != null) return f = f(), h.current = f, function () { h.current = null } } function Ub(f, h, S) { return S = S != null ? S.concat([f]) : null, Em(4, 4, Fb.bind(null, h, f), S) } function z1() { } function kb(f, h) { var S = us(); h = h === void 0 ? null : h; var M = S.memoizedState; return M !== null && h !== null && O1(h, M[1]) ? M[0] : (S.memoizedState = [f, h], f) } function Nb(f, h) { var S = us(); h = h === void 0 ? null : h; var M = S.memoizedState; return M !== null && h !== null && O1(h, M[1]) ? M[0] : (f = f(), S.memoizedState = [f, h], f) } function uk(f, h) { var S = Ot; Ot = S !== 0 && 4 > S ? S : 4, f(!0); var M = go.transition; go.transition = {}; try { f(!1), h() } finally { Ot = S, go.transition = M } } function zb() { return us().memoizedState } function fk(f, h, S) { var M = Fa(f); S = { lane: M, action: S, hasEagerState: !1, eagerState: null, next: null }, Gb(f) ? Hb(h, S) : (Vb(f, h, S), S = ci(), f = vo(f, M, S), f !== null && Wb(f, h, M)) } function dk(f, h, S) { var M = Fa(f), C = { lane: M, action: S, hasEagerState: !1, eagerState: null, next: null }; if (Gb(f)) Hb(h, C); else { Vb(f, h, C); var I = f.alternate; if (f.lanes === 0 && (I === null || I.lanes === 0) && (I = h.lastRenderedReducer, I !== null)) try { var te = h.lastRenderedState, ue = I(te, S); if (C.hasEagerState = !0, C.eagerState = ue, zi(ue, te)) return } catch { } finally { } S = ci(), f = vo(f, M, S), f !== null && Wb(f, h, M) } } function Gb(f) { var h = f.alternate; return f === Fn || h !== null && h === Fn } function Hb(f, h) { Md = _m = !0; var S = f.pending; S === null ? h.next = h : (h.next = S.next, S.next = h), f.pending = h } function Vb(f, h, S) { Zn !== null && f.mode & 1 && !(Lt & 2) ? (f = h.interleaved, f === null ? (S.next = S, Gi === null ? Gi = [h] : Gi.push(h)) : (S.next = f.next, f.next = S), h.interleaved = S) : (f = h.pending, f === null ? S.next = S : (S.next = f.next, f.next = S), h.pending = S) } function Wb(f, h, S) { if (S & 4194240) { var M = h.lanes; M &= f.pendingLanes, S |= M, h.lanes = S, as(f, S) } } var Mm = { readContext: jn, useCallback: kr, useContext: kr, useEffect: kr, useImperativeHandle: kr, useInsertionEffect: kr, useLayoutEffect: kr, useMemo: kr, useReducer: kr, useRef: kr, useState: kr, useDebugValue: kr, useDeferredValue: kr, useTransition: kr, useMutableSource: kr, useSyncExternalStore: kr, useId: kr, unstable_isNewReconciler: !1 }, hk = { readContext: jn, useCallback: function (f, h) { return Ks().memoizedState = [f, h === void 0 ? null : h], f }, useContext: jn, useEffect: N1, useImperativeHandle: function (f, h, S) { return S = S != null ? S.concat([f]) : null, Am(4194308, 4, Fb.bind(null, h, f), S) }, useLayoutEffect: function (f, h) { return Am(4194308, 4, f, h) }, useInsertionEffect: function (f, h) { return Am(4, 2, f, h) }, useMemo: function (f, h) { var S = Ks(); return h = h === void 0 ? null : h, f = f(), S.memoizedState = [f, h], f }, useReducer: function (f, h, S) { var M = Ks(); return h = S !== void 0 ? S(h) : h, M.memoizedState = M.baseState = h, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: f, lastRenderedState: h }, M.queue = f, f = f.dispatch = fk.bind(null, Fn, f), [M.memoizedState, f] }, useRef: function (f) { var h = Ks(); return f = { current: f }, h.memoizedState = f }, useState: k1, useDebugValue: z1, useDeferredValue: function (f) { var h = k1(f), S = h[0], M = h[1]; return N1(function () { var C = go.transition; go.transition = {}; try { M(f) } finally { go.transition = C } }, [f]), S }, useTransition: function () { var f = k1(!1), h = f[0]; return f = uk.bind(null, f[1]), Ks().memoizedState = f, [h, f] }, useMutableSource: function () { }, useSyncExternalStore: function (f, h, S) { var M = Fn, C = Ks(); if (Mn) { if (S === void 0) throw Error(s(407)); S = S() } else { if (S = h(), Zn === null) throw Error(s(349)); pu & 30 || Rb(M, h, S) } C.memoizedState = S; var I = { value: S, getSnapshot: h }; return C.queue = I, N1(Bb.bind(null, M, I, f), [f]), M.flags |= 2048, bd(9, Pb.bind(null, M, I, S, h), void 0, null), S }, useId: function () { var f = Ks(), h = Zn.identifierPrefix; if (Mn) { var S = Js, M = Xs; S = (M & ~(1 << 32 - ki(M) - 1)).toString(32) + S, h = ":" + h + "R" + S, S = wd++, 0 < S && (h += "H" + S.toString(32)), h += ":" } else S = ck++, h = ":" + h + "r" + S.toString(32) + ":"; return f.memoizedState = h }, unstable_isNewReconciler: !1 }, pk = { readContext: jn, useCallback: kb, useContext: jn, useEffect: Cd, useImperativeHandle: Ub, useInsertionEffect: Db, useLayoutEffect: Ob, useMemo: Nb, useReducer: xm, useRef: Lb, useState: function () { return xm(Hl) }, useDebugValue: z1, useDeferredValue: function (f) { var h = xm(Hl), S = h[0], M = h[1]; return Cd(function () { var C = go.transition; go.transition = {}; try { M(f) } finally { go.transition = C } }, [f]), S }, useTransition: function () { var f = xm(Hl)[0], h = us().memoizedState; return [f, h] }, useMutableSource: Cb, useSyncExternalStore: Tb, useId: zb, unstable_isNewReconciler: !1 }, mk = { readContext: jn, useCallback: kb, useContext: jn, useEffect: Cd, useImperativeHandle: Ub, useInsertionEffect: Db, useLayoutEffect: Ob, useMemo: Nb, useReducer: Sm, useRef: Lb, useState: function () { return Sm(Hl) }, useDebugValue: z1, useDeferredValue: function (f) { var h = Sm(Hl), S = h[0], M = h[1]; return Cd(function () { var C = go.transition; go.transition = {}; try { M(f) } finally { go.transition = C } }, [f]), S }, useTransition: function () { var f = Sm(Hl)[0], h = us().memoizedState; return [f, h] }, useMutableSource: Cb, useSyncExternalStore: Tb, useId: zb, unstable_isNewReconciler: !1 }; function G1(f, h) {
		try { var S = "", M = h; do S += Nl(M), M = M.return; while (M); var C = S } catch (I) {
			C = `
Error generating stack: `+ I.message + `
`+ I.stack
		} return { value: f, source: h, stack: C }
	} function H1(f, h) { try { console.error(h.value) } catch (S) { setTimeout(function () { throw S }) } } var gk = typeof WeakMap == "function" ? WeakMap : Map; function jb(f, h, S) { S = js(-1, S), S.tag = 3, S.payload = { element: null }; var M = h.value; return S.callback = function () { zm || (zm = !0, s_ = M), H1(f, h) }, S } function Xb(f, h, S) { S = js(-1, S), S.tag = 3; var M = f.type.getDerivedStateFromError; if (typeof M == "function") { var C = h.value; S.payload = function () { return M(C) }, S.callback = function () { H1(f, h) } } var I = f.stateNode; return I !== null && typeof I.componentDidCatch == "function" && (S.callback = function () { H1(f, h), typeof M != "function" && (Da === null ? Da = new Set([this]) : Da.add(this)); var te = h.stack; this.componentDidCatch(h.value, { componentStack: te !== null ? te : "" }) }), S } function Jb(f, h, S) { var M = f.pingCache; if (M === null) { M = f.pingCache = new gk; var C = new Set; M.set(h, C) } else C = M.get(h), C === void 0 && (C = new Set, M.set(h, C)); C.has(S) || (C.add(S), f = Pk.bind(null, f, h, S), h.then(f, f)) } function Kb(f) { do { var h; if ((h = f.tag === 13) && (h = f.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return f; f = f.return } while (f !== null); return null } function Yb(f, h, S, M, C) { return f.mode & 1 ? (f.flags |= 65536, f.lanes = C, f) : (f === h ? f.flags |= 65536 : (f.flags |= 128, S.flags |= 131072, S.flags &= -52805, S.tag === 1 && (S.alternate === null ? S.tag = 17 : (h = js(-1, 1), h.tag = 2, La(S, h))), S.lanes |= 1), f) } function fs(f) { f.flags |= 4 } function $b(f, h) { if (f !== null && f.child === h.child) return !0; if (h.flags & 16) return !1; for (f = h.child; f !== null;) { if (f.flags & 12854 || f.subtreeFlags & 12854) return !1; f = f.sibling } return !0 } var Td, Rd, wm, bm; if (le) Td = function (f, h) { for (var S = h.child; S !== null;) { if (S.tag === 5 || S.tag === 6) k(f, S.stateNode); else if (S.tag !== 4 && S.child !== null) { S.child.return = S, S = S.child; continue } if (S === h) break; for (; S.sibling === null;) { if (S.return === null || S.return === h) return; S = S.return } S.sibling.return = S.return, S = S.sibling } }, Rd = function () { }, wm = function (f, h, S, M, C) { if (f = f.memoizedProps, f !== M) { var I = h.stateNode, te = cs(mo.current); S = ee(I, S, f, M, C, te), (h.updateQueue = S) && fs(h) } }, bm = function (f, h, S, M) { S !== M && fs(h) }; else if (F) { Td = function (f, h, S, M) { for (var C = h.child; C !== null;) { if (C.tag === 5) { var I = C.stateNode; S && M && (I = Ct(I, C.type, C.memoizedProps, C)), k(f, I) } else if (C.tag === 6) I = C.stateNode, S && M && (I = At(I, C.memoizedProps, C)), k(f, I); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) I = C.child, I !== null && (I.return = C), Td(f, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === h) break; for (; C.sibling === null;) { if (C.return === null || C.return === h) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; var Qb = function (f, h, S, M) { for (var C = h.child; C !== null;) { if (C.tag === 5) { var I = C.stateNode; S && M && (I = Ct(I, C.type, C.memoizedProps, C)), Ze(f, I) } else if (C.tag === 6) I = C.stateNode, S && M && (I = At(I, C.memoizedProps, C)), Ze(f, I); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) I = C.child, I !== null && (I.return = C), Qb(f, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === h) break; for (; C.sibling === null;) { if (C.return === null || C.return === h) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; Rd = function (f, h) { var S = h.stateNode; if (!$b(f, h)) { f = S.containerInfo; var M = ze(f); Qb(M, h, !1, !1), S.pendingChildren = M, fs(h), it(f, M) } }, wm = function (f, h, S, M, C) { var I = f.stateNode, te = f.memoizedProps; if ((f = $b(f, h)) && te === M) h.stateNode = I; else { var ue = h.stateNode, Fe = cs(mo.current), $e = null; te !== M && ($e = ee(ue, S, te, M, C, Fe)), f && $e === null ? h.stateNode = I : (I = Qe(I, $e, S, te, M, h, f, ue), Z(I, S, M, C, Fe) && fs(h), h.stateNode = I, f ? fs(h) : Td(I, h, !1, !1)) } }, bm = function (f, h, S, M) { S !== M ? (f = cs(du.current), S = cs(mo.current), h.stateNode = K(M, f, S, h), fs(h)) : h.stateNode = f.stateNode } } else Rd = function () { }, wm = function () { }, bm = function () { }; function Pd(f, h) { if (!Mn) switch (f.tailMode) { case "hidden": h = f.tail; for (var S = null; h !== null;)h.alternate !== null && (S = h), h = h.sibling; S === null ? f.tail = null : S.sibling = null; break; case "collapsed": S = f.tail; for (var M = null; S !== null;)S.alternate !== null && (M = S), S = S.sibling; M === null ? h || f.tail === null ? f.tail = null : f.tail.sibling = null : M.sibling = null } } function Nr(f) { var h = f.alternate !== null && f.alternate.child === f.child, S = 0, M = 0; if (h) for (var C = f.child; C !== null;)S |= C.lanes | C.childLanes, M |= C.subtreeFlags & 14680064, M |= C.flags & 14680064, C.return = f, C = C.sibling; else for (C = f.child; C !== null;)S |= C.lanes | C.childLanes, M |= C.subtreeFlags, M |= C.flags, C.return = f, C = C.sibling; return f.subtreeFlags |= M, f.childLanes = S, h } function vk(f, h, S) { var M = h.pendingProps; switch (C1(h), h.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Nr(h), null; case 1: return dn(h.type) && ri(), Nr(h), null; case 3: return M = h.stateNode, hu(), zt(En), zt(On), D1(), M.pendingContext && (M.context = M.pendingContext, M.pendingContext = null), (f === null || f.child === null) && (xd(h) ? fs(h) : f === null || f.memoizedState.isDehydrated && !(h.flags & 256) || (h.flags |= 1024, Fo !== null && (c_(Fo), Fo = null))), Rd(f, h), Nr(h), null; case 5: I1(h), S = cs(du.current); var C = h.type; if (f !== null && h.stateNode != null) wm(f, h, C, M, S), f.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152); else { if (!M) { if (h.stateNode === null) throw Error(s(166)); return Nr(h), null } if (f = cs(mo.current), xd(h)) { if (!me) throw Error(s(175)); f = dr(h.stateNode, h.type, h.memoizedProps, S, f, h, !_d), h.updateQueue = f, f !== null && fs(h) } else { var I = O(C, M, S, f, h); Td(I, h, !1, !1), h.stateNode = I, Z(I, C, M, S, f) && fs(h) } h.ref !== null && (h.flags |= 512, h.flags |= 2097152) } return Nr(h), null; case 6: if (f && h.stateNode != null) bm(f, h, f.memoizedProps, M); else { if (typeof M != "string" && h.stateNode === null) throw Error(s(166)); if (f = cs(du.current), S = cs(mo.current), xd(h)) { if (!me) throw Error(s(176)); if (f = h.stateNode, M = h.memoizedProps, (S = Q(f, M, h, !_d)) && (C = Hi, C !== null)) switch (I = (C.mode & 1) !== 0, C.tag) { case 3: lt(C.stateNode.containerInfo, f, M, I); break; case 5: Et(C.type, C.memoizedProps, C.stateNode, f, M, I) }S && fs(h) } else h.stateNode = K(M, f, S, h) } return Nr(h), null; case 13: if (zt(Rn), M = h.memoizedState, Mn && Vi !== null && h.mode & 1 && !(h.flags & 128)) { for (f = Vi; f;)f = Ht(f); return uu(), h.flags |= 98560, h } if (M !== null && M.dehydrated !== null) { if (M = xd(h), f === null) { if (!M) throw Error(s(318)); if (!me) throw Error(s(344)); if (f = h.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(s(317)); ve(f, h) } else uu(), !(h.flags & 128) && (h.memoizedState = null), h.flags |= 4; return Nr(h), null } return Fo !== null && (c_(Fo), Fo = null), h.flags & 128 ? (h.lanes = S, h) : (M = M !== null, S = !1, f === null ? xd(h) : S = f.memoizedState !== null, M && !S && (h.child.flags |= 8192, h.mode & 1 && (f === null || Rn.current & 1 ? or === 0 && (or = 3) : f_())), h.updateQueue !== null && (h.flags |= 4), Nr(h), null); case 4: return hu(), Rd(f, h), f === null && ce(h.stateNode.containerInfo), Nr(h), null; case 10: return pr(h.type._context), Nr(h), null; case 17: return dn(h.type) && ri(), Nr(h), null; case 19: if (zt(Rn), C = h.memoizedState, C === null) return Nr(h), null; if (M = (h.flags & 128) !== 0, I = C.rendering, I === null) if (M) Pd(C, !1); else { if (or !== 0 || f !== null && f.flags & 128) for (f = h.child; f !== null;) { if (I = vm(f), I !== null) { for (h.flags |= 128, Pd(C, !1), f = I.updateQueue, f !== null && (h.updateQueue = f, h.flags |= 4), h.subtreeFlags = 0, f = S, M = h.child; M !== null;)S = M, C = f, S.flags &= 14680066, I = S.alternate, I === null ? (S.childLanes = 0, S.lanes = C, S.child = null, S.subtreeFlags = 0, S.memoizedProps = null, S.memoizedState = null, S.updateQueue = null, S.dependencies = null, S.stateNode = null) : (S.childLanes = I.childLanes, S.lanes = I.lanes, S.child = I.child, S.subtreeFlags = 0, S.deletions = null, S.memoizedProps = I.memoizedProps, S.memoizedState = I.memoizedState, S.updateQueue = I.updateQueue, S.type = I.type, C = I.dependencies, S.dependencies = C === null ? null : { lanes: C.lanes, firstContext: C.firstContext }), M = M.sibling; return vt(Rn, Rn.current & 1 | 2), h.child } f = f.sibling } C.tail !== null && Tn() > o_ && (h.flags |= 128, M = !0, Pd(C, !1), h.lanes = 4194304) } else { if (!M) if (f = vm(I), f !== null) { if (h.flags |= 128, M = !0, f = f.updateQueue, f !== null && (h.updateQueue = f, h.flags |= 4), Pd(C, !0), C.tail === null && C.tailMode === "hidden" && !I.alternate && !Mn) return Nr(h), null } else 2 * Tn() - C.renderingStartTime > o_ && S !== 1073741824 && (h.flags |= 128, M = !0, Pd(C, !1), h.lanes = 4194304); C.isBackwards ? (I.sibling = h.child, h.child = I) : (f = C.last, f !== null ? f.sibling = I : h.child = I, C.last = I) } return C.tail !== null ? (h = C.tail, C.rendering = h, C.tail = h.sibling, C.renderingStartTime = Tn(), h.sibling = null, f = Rn.current, vt(Rn, M ? f & 1 | 2 : f & 1), h) : (Nr(h), null); case 22: case 23: return u_(), M = h.memoizedState !== null, f !== null && f.memoizedState !== null !== M && (h.flags |= 8192), M && h.mode & 1 ? ji & 1073741824 && (Nr(h), le && h.subtreeFlags & 6 && (h.flags |= 8192)) : Nr(h), null; case 24: return null; case 25: return null }throw Error(s(156, h.tag)) } var yk = a.ReactCurrentOwner, Wi = !1; function li(f, h, S, M) { h.child = f === null ? wb(h, null, S, M) : fu(h, f.child, S, M) } function Zb(f, h, S, M, C) { S = S.render; var I = h.ref; return Wn(h, C), M = F1(f, h, S, M, I, C), S = U1(), f !== null && !Wi ? (h.updateQueue = f.updateQueue, h.flags &= -2053, f.lanes &= ~C, Ys(f, h, C)) : (Mn && S && b1(h), h.flags |= 1, li(f, h, M, C), h.child) } function qb(f, h, S, M, C) { if (f === null) { var I = S.type; return typeof I == "function" && !d_(I) && I.defaultProps === void 0 && S.compare === null && S.defaultProps === void 0 ? (h.tag = 15, h.type = I, eC(f, h, I, M, C)) : (f = Jm(S.type, null, M, h, h.mode, C), f.ref = h.ref, f.return = h, h.child = f) } if (I = f.child, !(f.lanes & C)) { var te = I.memoizedProps; if (S = S.compare, S = S !== null ? S : kl, S(te, M) && f.ref === h.ref) return Ys(f, h, C) } return h.flags |= 1, f = ka(I, M), f.ref = h.ref, f.return = h, h.child = f } function eC(f, h, S, M, C) { if (f !== null && kl(f.memoizedProps, M) && f.ref === h.ref) if (Wi = !1, (f.lanes & C) !== 0) f.flags & 131072 && (Wi = !0); else return h.lanes = f.lanes, Ys(f, h, C); return V1(f, h, S, M, C) } function tC(f, h, S) { var M = h.pendingProps, C = M.children, I = f !== null ? f.memoizedState : null; if (M.mode === "hidden") if (!(h.mode & 1)) h.memoizedState = { baseLanes: 0, cachePool: null }, vt(mu, ji), ji |= S; else if (S & 1073741824) h.memoizedState = { baseLanes: 0, cachePool: null }, M = I !== null ? I.baseLanes : S, vt(mu, ji), ji |= M; else return f = I !== null ? I.baseLanes | S : S, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: f, cachePool: null }, h.updateQueue = null, vt(mu, ji), ji |= f, null; else I !== null ? (M = I.baseLanes | S, h.memoizedState = null) : M = S, vt(mu, ji), ji |= M; return li(f, h, C, S), h.child } function nC(f, h) { var S = h.ref; (f === null && S !== null || f !== null && f.ref !== S) && (h.flags |= 512, h.flags |= 2097152) } function V1(f, h, S, M, C) { var I = dn(S) ? xi : On.current; return I = cn(h, I), Wn(h, C), S = F1(f, h, S, M, I, C), M = U1(), f !== null && !Wi ? (h.updateQueue = f.updateQueue, h.flags &= -2053, f.lanes &= ~C, Ys(f, h, C)) : (Mn && M && b1(h), h.flags |= 1, li(f, h, S, C), h.child) } function rC(f, h, S, M, C) { if (dn(S)) { var I = !0; os(h) } else I = !1; if (Wn(h, C), h.stateNode === null) f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), vb(h, S, M), w1(h, S, M, C), M = !0; else if (f === null) { var te = h.stateNode, ue = h.memoizedProps; te.props = ue; var Fe = te.context, $e = S.contextType; typeof $e == "object" && $e !== null ? $e = jn($e) : ($e = dn(S) ? xi : On.current, $e = cn(h, $e)); var ct = S.getDerivedStateFromProps, Mt = typeof ct == "function" || typeof te.getSnapshotBeforeUpdate == "function"; Mt || typeof te.UNSAFE_componentWillReceiveProps != "function" && typeof te.componentWillReceiveProps != "function" || (ue !== M || Fe !== $e) && yb(h, te, M, $e), Ia = !1; var mt = h.memoizedState; te.state = mt, dm(h, M, te, C), Fe = h.memoizedState, ue !== M || mt !== Fe || En.current || Ia ? (typeof ct == "function" && (M1(h, S, ct, M), Fe = h.memoizedState), (ue = Ia || gb(h, S, ue, M, mt, Fe, $e)) ? (Mt || typeof te.UNSAFE_componentWillMount != "function" && typeof te.componentWillMount != "function" || (typeof te.componentWillMount == "function" && te.componentWillMount(), typeof te.UNSAFE_componentWillMount == "function" && te.UNSAFE_componentWillMount()), typeof te.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof te.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = M, h.memoizedState = Fe), te.props = M, te.state = Fe, te.context = $e, M = ue) : (typeof te.componentDidMount == "function" && (h.flags |= 4194308), M = !1) } else { te = h.stateNode, db(f, h), ue = h.memoizedProps, $e = h.type === h.elementType ? ue : si(h.type, ue), te.props = $e, Mt = h.pendingProps, mt = te.context, Fe = S.contextType, typeof Fe == "object" && Fe !== null ? Fe = jn(Fe) : (Fe = dn(S) ? xi : On.current, Fe = cn(h, Fe)); var un = S.getDerivedStateFromProps; (ct = typeof un == "function" || typeof te.getSnapshotBeforeUpdate == "function") || typeof te.UNSAFE_componentWillReceiveProps != "function" && typeof te.componentWillReceiveProps != "function" || (ue !== Mt || mt !== Fe) && yb(h, te, M, Fe), Ia = !1, mt = h.memoizedState, te.state = mt, dm(h, M, te, C); var ht = h.memoizedState; ue !== Mt || mt !== ht || En.current || Ia ? (typeof un == "function" && (M1(h, S, un, M), ht = h.memoizedState), ($e = Ia || gb(h, S, $e, M, mt, ht, Fe) || !1) ? (ct || typeof te.UNSAFE_componentWillUpdate != "function" && typeof te.componentWillUpdate != "function" || (typeof te.componentWillUpdate == "function" && te.componentWillUpdate(M, ht, Fe), typeof te.UNSAFE_componentWillUpdate == "function" && te.UNSAFE_componentWillUpdate(M, ht, Fe)), typeof te.componentDidUpdate == "function" && (h.flags |= 4), typeof te.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof te.componentDidUpdate != "function" || ue === f.memoizedProps && mt === f.memoizedState || (h.flags |= 4), typeof te.getSnapshotBeforeUpdate != "function" || ue === f.memoizedProps && mt === f.memoizedState || (h.flags |= 1024), h.memoizedProps = M, h.memoizedState = ht), te.props = M, te.state = ht, te.context = Fe, M = $e) : (typeof te.componentDidUpdate != "function" || ue === f.memoizedProps && mt === f.memoizedState || (h.flags |= 4), typeof te.getSnapshotBeforeUpdate != "function" || ue === f.memoizedProps && mt === f.memoizedState || (h.flags |= 1024), M = !1) } return W1(f, h, S, M, I, C) } function W1(f, h, S, M, C, I) { nC(f, h); var te = (h.flags & 128) !== 0; if (!M && !te) return C && Fr(h, S, !1), Ys(f, h, I); M = h.stateNode, yk.current = h; var ue = te && typeof S.getDerivedStateFromError != "function" ? null : M.render(); return h.flags |= 1, f !== null && te ? (h.child = fu(h, f.child, null, I), h.child = fu(h, null, ue, I)) : li(f, h, ue, I), h.memoizedState = M.state, C && Fr(h, S, !0), h.child } function iC(f) { var h = f.stateNode; h.pendingContext ? Qn(f, h.pendingContext, h.pendingContext !== h.context) : h.context && Qn(f, h.context, !1), B1(f, h.containerInfo) } function oC(f, h, S, M, C) { return uu(), P1(C), h.flags |= 256, li(f, h, S, M), h.child } var Cm = { dehydrated: null, treeContext: null, retryLane: 0 }; function Tm(f) { return { baseLanes: f, cachePool: null } } function sC(f, h, S) { var M = h.pendingProps, C = Rn.current, I = !1, te = (h.flags & 128) !== 0, ue; if ((ue = te) || (ue = f !== null && f.memoizedState === null ? !1 : (C & 2) !== 0), ue ? (I = !0, h.flags &= -129) : (f === null || f.memoizedState !== null) && (C |= 1), vt(Rn, C & 1), f === null) return R1(h), f = h.memoizedState, f !== null && (f = f.dehydrated, f !== null) ? (h.mode & 1 ? qt(f) ? h.lanes = 8 : h.lanes = 1073741824 : h.lanes = 1, null) : (C = M.children, f = M.fallback, I ? (M = h.mode, I = h.child, C = { mode: "hidden", children: C }, !(M & 1) && I !== null ? (I.childLanes = 0, I.pendingProps = C) : I = Km(C, M, 0, null), f = Kl(f, M, S, null), I.return = h, f.return = h, I.sibling = f, h.child = I, h.child.memoizedState = Tm(S), h.memoizedState = Cm, f) : j1(h, C)); if (C = f.memoizedState, C !== null) { if (ue = C.dehydrated, ue !== null) { if (te) return h.flags & 256 ? (h.flags &= -257, Rm(f, h, S, Error(s(422)))) : h.memoizedState !== null ? (h.child = f.child, h.flags |= 128, null) : (I = M.fallback, C = h.mode, M = Km({ mode: "visible", children: M.children }, C, 0, null), I = Kl(I, C, S, null), I.flags |= 2, M.return = h, I.return = h, M.sibling = I, h.child = M, h.mode & 1 && fu(h, f.child, null, S), h.child.memoizedState = Tm(S), h.memoizedState = Cm, I); if (!(h.mode & 1)) h = Rm(f, h, S, null); else if (qt(ue)) h = Rm(f, h, S, Error(s(419))); else if (M = (S & f.childLanes) !== 0, Wi || M) { if (M = Zn, M !== null) { switch (S & -S) { case 4: I = 2; break; case 16: I = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: I = 32; break; case 536870912: I = 268435456; break; default: I = 0 }M = I & (M.suspendedLanes | S) ? 0 : I, M !== 0 && M !== C.retryLane && (C.retryLane = M, vo(f, M, -1)) } f_(), h = Rm(f, h, S, Error(s(421))) } else Dt(ue) ? (h.flags |= 128, h.child = f.child, h = Bk.bind(null, f), tn(ue, h), h = null) : (S = C.treeContext, me && (Vi = Dr(ue), Hi = h, Mn = !0, Fo = null, _d = !1, S !== null && (ho[po++] = Xs, ho[po++] = Js, ho[po++] = zl, Xs = S.id, Js = S.overflow, zl = h)), h = j1(h, h.pendingProps.children), h.flags |= 4096); return h } return I ? (M = lC(f, h, M.children, M.fallback, S), I = h.child, C = f.child.memoizedState, I.memoizedState = C === null ? Tm(S) : { baseLanes: C.baseLanes | S, cachePool: null }, I.childLanes = f.childLanes & ~S, h.memoizedState = Cm, M) : (S = aC(f, h, M.children, S), h.memoizedState = null, S) } return I ? (M = lC(f, h, M.children, M.fallback, S), I = h.child, C = f.child.memoizedState, I.memoizedState = C === null ? Tm(S) : { baseLanes: C.baseLanes | S, cachePool: null }, I.childLanes = f.childLanes & ~S, h.memoizedState = Cm, M) : (S = aC(f, h, M.children, S), h.memoizedState = null, S) } function j1(f, h) { return h = Km({ mode: "visible", children: h }, f.mode, 0, null), h.return = f, f.child = h } function aC(f, h, S, M) { var C = f.child; return f = C.sibling, S = ka(C, { mode: "visible", children: S }), !(h.mode & 1) && (S.lanes = M), S.return = h, S.sibling = null, f !== null && (M = h.deletions, M === null ? (h.deletions = [f], h.flags |= 16) : M.push(f)), h.child = S } function lC(f, h, S, M, C) { var I = h.mode; f = f.child; var te = f.sibling, ue = { mode: "hidden", children: S }; return !(I & 1) && h.child !== f ? (S = h.child, S.childLanes = 0, S.pendingProps = ue, h.deletions = null) : (S = ka(f, ue), S.subtreeFlags = f.subtreeFlags & 14680064), te !== null ? M = ka(te, M) : (M = Kl(M, I, C, null), M.flags |= 2), M.return = h, S.return = h, S.sibling = M, h.child = S, M } function Rm(f, h, S, M) { return M !== null && P1(M), fu(h, f.child, null, S), f = j1(h, h.pendingProps.children), f.flags |= 2, h.memoizedState = null, f } function cC(f, h, S) { f.lanes |= h; var M = f.alternate; M !== null && (M.lanes |= h), ai(f.return, h, S) } function X1(f, h, S, M, C) { var I = f.memoizedState; I === null ? f.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: M, tail: S, tailMode: C } : (I.isBackwards = h, I.rendering = null, I.renderingStartTime = 0, I.last = M, I.tail = S, I.tailMode = C) } function uC(f, h, S) { var M = h.pendingProps, C = M.revealOrder, I = M.tail; if (li(f, h, M.children, S), M = Rn.current, M & 2) M = M & 1 | 2, h.flags |= 128; else { if (f !== null && f.flags & 128) e: for (f = h.child; f !== null;) { if (f.tag === 13) f.memoizedState !== null && cC(f, S, h); else if (f.tag === 19) cC(f, S, h); else if (f.child !== null) { f.child.return = f, f = f.child; continue } if (f === h) break e; for (; f.sibling === null;) { if (f.return === null || f.return === h) break e; f = f.return } f.sibling.return = f.return, f = f.sibling } M &= 1 } if (vt(Rn, M), !(h.mode & 1)) h.memoizedState = null; else switch (C) { case "forwards": for (S = h.child, C = null; S !== null;)f = S.alternate, f !== null && vm(f) === null && (C = S), S = S.sibling; S = C, S === null ? (C = h.child, h.child = null) : (C = S.sibling, S.sibling = null), X1(h, !1, C, S, I); break; case "backwards": for (S = null, C = h.child, h.child = null; C !== null;) { if (f = C.alternate, f !== null && vm(f) === null) { h.child = C; break } f = C.sibling, C.sibling = S, S = C, C = f } X1(h, !0, S, null, I); break; case "together": X1(h, !1, null, null, void 0); break; default: h.memoizedState = null }return h.child } function Ys(f, h, S) { if (f !== null && (h.dependencies = f.dependencies), gu |= h.lanes, !(S & h.childLanes)) return null; if (f !== null && h.child !== f.child) throw Error(s(153)); if (h.child !== null) { for (f = h.child, S = ka(f, f.pendingProps), h.child = S, S.return = h; f.sibling !== null;)f = f.sibling, S = S.sibling = ka(f, f.pendingProps), S.return = h; S.sibling = null } return h.child } function _k(f, h, S) { switch (h.tag) { case 3: iC(h), uu(); break; case 5: bb(h); break; case 1: dn(h.type) && os(h); break; case 4: B1(h, h.stateNode.containerInfo); break; case 10: um(h, h.type._context, h.memoizedProps.value); break; case 13: var M = h.memoizedState; if (M !== null) return M.dehydrated !== null ? (vt(Rn, Rn.current & 1), h.flags |= 128, null) : S & h.child.childLanes ? sC(f, h, S) : (vt(Rn, Rn.current & 1), f = Ys(f, h, S), f !== null ? f.sibling : null); vt(Rn, Rn.current & 1); break; case 19: if (M = (S & h.childLanes) !== 0, f.flags & 128) { if (M) return uC(f, h, S); h.flags |= 128 } var C = h.memoizedState; if (C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), vt(Rn, Rn.current), M) break; return null; case 22: case 23: return h.lanes = 0, tC(f, h, S) }return Ys(f, h, S) } function xk(f, h) { switch (C1(h), h.tag) { case 1: return dn(h.type) && ri(), f = h.flags, f & 65536 ? (h.flags = f & -65537 | 128, h) : null; case 3: return hu(), zt(En), zt(On), D1(), f = h.flags, f & 65536 && !(f & 128) ? (h.flags = f & -65537 | 128, h) : null; case 5: return I1(h), null; case 13: if (zt(Rn), f = h.memoizedState, f !== null && f.dehydrated !== null) { if (h.alternate === null) throw Error(s(340)); uu() } return f = h.flags, f & 65536 ? (h.flags = f & -65537 | 128, h) : null; case 19: return zt(Rn), null; case 4: return hu(), null; case 10: return pr(h.type._context), null; case 22: case 23: return u_(), null; case 24: return null; default: return null } } var Pm = !1, Vl = !1, Sk = typeof WeakSet == "function" ? WeakSet : Set, tt = null; function Bm(f, h) { var S = f.ref; if (S !== null) if (typeof S == "function") try { S(null) } catch (M) { Mi(f, h, M) } else S.current = null } function J1(f, h, S) { try { S() } catch (M) { Mi(f, h, M) } } var fC = !1; function Ak(f, h) { for (V(f.containerInfo), tt = h; tt !== null;)if (f = tt, h = f.child, (f.subtreeFlags & 1028) !== 0 && h !== null) h.return = f, tt = h; else for (; tt !== null;) { f = tt; try { var S = f.alternate; if (f.flags & 1024) switch (f.tag) { case 0: case 11: case 15: break; case 1: if (S !== null) { var M = S.memoizedProps, C = S.memoizedState, I = f.stateNode, te = I.getSnapshotBeforeUpdate(f.elementType === f.type ? M : si(f.type, M), C); I.__reactInternalSnapshotBeforeUpdate = te } break; case 3: le && Ke(f.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(s(163)) } } catch (ue) { Mi(f, f.return, ue) } if (h = f.sibling, h !== null) { h.return = f.return, tt = h; break } tt = f.return } return S = fC, fC = !1, S } function Wl(f, h, S) { var M = h.updateQueue; if (M = M !== null ? M.lastEffect : null, M !== null) { var C = M = M.next; do { if ((C.tag & f) === f) { var I = C.destroy; C.destroy = void 0, I !== void 0 && J1(h, S, I) } C = C.next } while (C !== M) } } function Bd(f, h) { if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) { var S = h = h.next; do { if ((S.tag & f) === f) { var M = S.create; S.destroy = M() } S = S.next } while (S !== h) } } function K1(f) { var h = f.ref; if (h !== null) { var S = f.stateNode; switch (f.tag) { case 5: f = q(S); break; default: f = S }typeof h == "function" ? h(f) : h.current = f } } function dC(f, h, S) { if (Ni && typeof Ni.onCommitFiberUnmount == "function") try { Ni.onCommitFiberUnmount(Fl, h) } catch { } switch (h.tag) { case 0: case 11: case 14: case 15: if (f = h.updateQueue, f !== null && (f = f.lastEffect, f !== null)) { var M = f = f.next; do { var C = M, I = C.destroy; C = C.tag, I !== void 0 && (C & 2 || C & 4) && J1(h, S, I), M = M.next } while (M !== f) } break; case 1: if (Bm(h, S), f = h.stateNode, typeof f.componentWillUnmount == "function") try { f.props = h.memoizedProps, f.state = h.memoizedState, f.componentWillUnmount() } catch (te) { Mi(h, S, te) } break; case 5: Bm(h, S); break; case 4: le ? yC(f, h, S) : F && F && (h = h.stateNode.containerInfo, S = ze(h), yt(h, S)) } } function hC(f, h, S) { for (var M = h; ;)if (dC(f, M, S), M.child === null || le && M.tag === 4) { if (M === h) break; for (; M.sibling === null;) { if (M.return === null || M.return === h) return; M = M.return } M.sibling.return = M.return, M = M.sibling } else M.child.return = M, M = M.child } function pC(f) { var h = f.alternate; h !== null && (f.alternate = null, pC(h)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (h = f.stateNode, h !== null && Re(h)), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null } function mC(f) { return f.tag === 5 || f.tag === 3 || f.tag === 4 } function gC(f) { e: for (; ;) { for (; f.sibling === null;) { if (f.return === null || mC(f.return)) return null; f = f.return } for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && f.tag !== 18;) { if (f.flags & 2 || f.child === null || f.tag === 4) continue e; f.child.return = f, f = f.child } if (!(f.flags & 2)) return f.stateNode } } function vC(f) { if (le) { e: { for (var h = f.return; h !== null;) { if (mC(h)) break e; h = h.return } throw Error(s(160)) } var S = h; switch (S.tag) { case 5: h = S.stateNode, S.flags & 32 && (_e(h), S.flags &= -33), S = gC(f), $1(f, S, h); break; case 3: case 4: h = S.stateNode.containerInfo, S = gC(f), Y1(f, S, h); break; default: throw Error(s(161)) } } } function Y1(f, h, S) { var M = f.tag; if (M === 5 || M === 6) f = f.stateNode, h ? Te(S, f, h) : be(S, f); else if (M !== 4 && (f = f.child, f !== null)) for (Y1(f, h, S), f = f.sibling; f !== null;)Y1(f, h, S), f = f.sibling } function $1(f, h, S) { var M = f.tag; if (M === 5 || M === 6) f = f.stateNode, h ? nt(S, f, h) : ye(S, f); else if (M !== 4 && (f = f.child, f !== null)) for ($1(f, h, S), f = f.sibling; f !== null;)$1(f, h, S), f = f.sibling } function yC(f, h, S) { for (var M = h, C = !1, I, te; ;) { if (!C) { C = M.return; e: for (; ;) { if (C === null) throw Error(s(160)); switch (I = C.stateNode, C.tag) { case 5: te = !1; break e; case 3: I = I.containerInfo, te = !0; break e; case 4: I = I.containerInfo, te = !0; break e }C = C.return } C = !0 } if (M.tag === 5 || M.tag === 6) hC(f, M, S), te ? re(I, M.stateNode) : Je(I, M.stateNode); else if (M.tag === 18) te ? dt(I, M.stateNode) : ot(I, M.stateNode); else if (M.tag === 4) { if (M.child !== null) { I = M.stateNode.containerInfo, te = !0, M.child.return = M, M = M.child; continue } } else if (dC(f, M, S), M.child !== null) { M.child.return = M, M = M.child; continue } if (M === h) break; for (; M.sibling === null;) { if (M.return === null || M.return === h) return; M = M.return, M.tag === 4 && (C = !1) } M.sibling.return = M.return, M = M.sibling } } function Q1(f, h) { if (le) { switch (h.tag) { case 0: case 11: case 14: case 15: Wl(3, h, h.return), Bd(3, h), Wl(5, h, h.return); return; case 1: return; case 5: var S = h.stateNode; if (S != null) { var M = h.memoizedProps; f = f !== null ? f.memoizedProps : M; var C = h.type, I = h.updateQueue; h.updateQueue = null, I !== null && je(S, I, C, f, M, h) } return; case 6: if (h.stateNode === null) throw Error(s(162)); S = h.memoizedProps, ke(h.stateNode, f !== null ? f.memoizedProps : S, S); return; case 3: me && f !== null && f.memoizedState.isDehydrated && xe(h.stateNode.containerInfo); return; case 12: return; case 13: Im(h); return; case 19: Im(h); return; case 17: return }throw Error(s(163)) } switch (h.tag) { case 0: case 11: case 14: case 15: Wl(3, h, h.return), Bd(3, h), Wl(5, h, h.return); return; case 12: return; case 13: Im(h); return; case 19: Im(h); return; case 3: me && f !== null && f.memoizedState.isDehydrated && xe(h.stateNode.containerInfo); break; case 22: case 23: return }e: if (F) { switch (h.tag) { case 1: case 5: case 6: break e; case 3: case 4: h = h.stateNode, yt(h.containerInfo, h.pendingChildren); break e }throw Error(s(163)) } } function Im(f) { var h = f.updateQueue; if (h !== null) { f.updateQueue = null; var S = f.stateNode; S === null && (S = f.stateNode = new Sk), h.forEach(function (M) { var C = Ik.bind(null, f, M); S.has(M) || (S.add(M), M.then(C, C)) }) } } function Ek(f, h) { for (tt = h; tt !== null;) { h = tt; var S = h.deletions; if (S !== null) for (var M = 0; M < S.length; M++) { var C = S[M]; try { var I = f; le ? yC(I, C, h) : hC(I, C, h); var te = C.alternate; te !== null && (te.return = null), C.return = null } catch (ft) { Mi(C, h, ft) } } if (S = h.child, h.subtreeFlags & 12854 && S !== null) S.return = h, tt = S; else for (; tt !== null;) { h = tt; try { var ue = h.flags; if (ue & 32 && le && _e(h.stateNode), ue & 512) { var Fe = h.alternate; if (Fe !== null) { var $e = Fe.ref; $e !== null && (typeof $e == "function" ? $e(null) : $e.current = null) } } if (ue & 8192) switch (h.tag) { case 13: if (h.memoizedState !== null) { var ct = h.alternate; (ct === null || ct.memoizedState === null) && (i_ = Tn()) } break; case 22: var Mt = h.memoizedState !== null, mt = h.alternate, un = mt !== null && mt.memoizedState !== null; if (S = h, le) { e: if (M = S, C = Mt, I = null, le) for (var ht = M; ;) { if (ht.tag === 5) { if (I === null) { I = ht; var zr = ht.stateNode; C ? Ne(zr) : Ue(ht.stateNode, ht.memoizedProps) } } else if (ht.tag === 6) { if (I === null) { var _o = ht.stateNode; C ? Y(_o) : Ge(_o, ht.memoizedProps) } } else if ((ht.tag !== 22 && ht.tag !== 23 || ht.memoizedState === null || ht === M) && ht.child !== null) { ht.child.return = ht, ht = ht.child; continue } if (ht === M) break; for (; ht.sibling === null;) { if (ht.return === null || ht.return === M) break e; I === ht && (I = null), ht = ht.return } I === ht && (I = null), ht.sibling.return = ht.return, ht = ht.sibling } } if (Mt && !un && S.mode & 1) { tt = S; for (var Me = S.child; Me !== null;) { for (S = tt = Me; tt !== null;) { M = tt; var pe = M.child; switch (M.tag) { case 0: case 11: case 14: case 15: Wl(4, M, M.return); break; case 1: Bm(M, M.return); var Le = M.stateNode; if (typeof Le.componentWillUnmount == "function") { var rt = M.return; try { Le.props = M.memoizedProps, Le.state = M.memoizedState, Le.componentWillUnmount() } catch (ft) { Mi(M, rt, ft) } } break; case 5: Bm(M, M.return); break; case 22: if (M.memoizedState !== null) { SC(S); continue } }pe !== null ? (pe.return = M, tt = pe) : SC(S) } Me = Me.sibling } } }switch (ue & 4102) { case 2: vC(h), h.flags &= -3; break; case 6: vC(h), h.flags &= -3, Q1(h.alternate, h); break; case 4096: h.flags &= -4097; break; case 4100: h.flags &= -4097, Q1(h.alternate, h); break; case 4: Q1(h.alternate, h) } } catch (ft) { Mi(h, h.return, ft) } if (S = h.sibling, S !== null) { S.return = h.return, tt = S; break } tt = h.return } } } function Mk(f, h, S) { tt = f, _C(f) } function _C(f, h, S) { for (var M = (f.mode & 1) !== 0; tt !== null;) { var C = tt, I = C.child; if (C.tag === 22 && M) { var te = C.memoizedState !== null || Pm; if (!te) { var ue = C.alternate, Fe = ue !== null && ue.memoizedState !== null || Vl; ue = Pm; var $e = Vl; if (Pm = te, (Vl = Fe) && !$e) for (tt = C; tt !== null;)te = tt, Fe = te.child, te.tag === 22 && te.memoizedState !== null ? AC(C) : Fe !== null ? (Fe.return = te, tt = Fe) : AC(C); for (; I !== null;)tt = I, _C(I), I = I.sibling; tt = C, Pm = ue, Vl = $e } xC(f) } else C.subtreeFlags & 8772 && I !== null ? (I.return = C, tt = I) : xC(f) } } function xC(f) { for (; tt !== null;) { var h = tt; if (h.flags & 8772) { var S = h.alternate; try { if (h.flags & 8772) switch (h.tag) { case 0: case 11: case 15: Vl || Bd(5, h); break; case 1: var M = h.stateNode; if (h.flags & 4 && !Vl) if (S === null) M.componentDidMount(); else { var C = h.elementType === h.type ? S.memoizedProps : si(h.type, S.memoizedProps); M.componentDidUpdate(C, S.memoizedState, M.__reactInternalSnapshotBeforeUpdate) } var I = h.updateQueue; I !== null && pb(h, I, M); break; case 3: var te = h.updateQueue; if (te !== null) { if (S = null, h.child !== null) switch (h.child.tag) { case 5: S = q(h.child.stateNode); break; case 1: S = h.child.stateNode }pb(h, te, S) } break; case 5: var ue = h.stateNode; S === null && h.flags & 4 && He(ue, h.type, h.memoizedProps, h); break; case 6: break; case 4: break; case 12: break; case 13: if (me && h.memoizedState === null) { var Fe = h.alternate; if (Fe !== null) { var $e = Fe.memoizedState; if ($e !== null) { var ct = $e.dehydrated; ct !== null && Oe(ct) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(s(163)) }Vl || h.flags & 512 && K1(h) } catch (Mt) { Mi(h, h.return, Mt) } } if (h === f) { tt = null; break } if (S = h.sibling, S !== null) { S.return = h.return, tt = S; break } tt = h.return } } function SC(f) { for (; tt !== null;) { var h = tt; if (h === f) { tt = null; break } var S = h.sibling; if (S !== null) { S.return = h.return, tt = S; break } tt = h.return } } function AC(f) { for (; tt !== null;) { var h = tt; try { switch (h.tag) { case 0: case 11: case 15: var S = h.return; try { Bd(4, h) } catch (Fe) { Mi(h, S, Fe) } break; case 1: var M = h.stateNode; if (typeof M.componentDidMount == "function") { var C = h.return; try { M.componentDidMount() } catch (Fe) { Mi(h, C, Fe) } } var I = h.return; try { K1(h) } catch (Fe) { Mi(h, I, Fe) } break; case 5: var te = h.return; try { K1(h) } catch (Fe) { Mi(h, te, Fe) } } } catch (Fe) { Mi(h, h.return, Fe) } if (h === f) { tt = null; break } var ue = h.sibling; if (ue !== null) { ue.return = h.return, tt = ue; break } tt = h.return } } var Lm = 0, Dm = 1, Om = 2, Fm = 3, Um = 4; if (typeof Symbol == "function" && Symbol.for) { var Id = Symbol.for; Lm = Id("selector.component"), Dm = Id("selector.has_pseudo_class"), Om = Id("selector.role"), Fm = Id("selector.test_id"), Um = Id("selector.text") } function Z1(f) { var h = he(f); if (h != null) { if (typeof h.memoizedProps["data-testname"] != "string") throw Error(s(364)); return h } if (f = ge(f), f === null) throw Error(s(362)); return f.stateNode.current } function q1(f, h) { switch (h.$$typeof) { case Lm: if (f.type === h.value) return !0; break; case Dm: e: { h = h.value, f = [f, 0]; for (var S = 0; S < f.length;) { var M = f[S++], C = f[S++], I = h[C]; if (M.tag !== 5 || !L(M)) { for (; I != null && q1(M, I);)C++, I = h[C]; if (C === h.length) { h = !0; break e } else for (M = M.child; M !== null;)f.push(M, C), M = M.sibling } } h = !1 } return h; case Om: if (f.tag === 5 && oe(f.stateNode, h.value)) return !0; break; case Um: if ((f.tag === 5 || f.tag === 6) && (f = H(f), f !== null && 0 <= f.indexOf(h.value))) return !0; break; case Fm: if (f.tag === 5 && (f = f.memoizedProps["data-testname"], typeof f == "string" && f.toLowerCase() === h.value.toLowerCase())) return !0; break; default: throw Error(s(365)) }return !1 } function e_(f) { switch (f.$$typeof) { case Lm: return "<" + (T(f.value) || "Unknown") + ">"; case Dm: return ":has(" + (e_(f) || "") + ")"; case Om: return '[role="' + f.value + '"]'; case Um: return '"' + f.value + '"'; case Fm: return '[data-testname="' + f.value + '"]'; default: throw Error(s(365)) } } function EC(f, h) { var S = []; f = [f, 0]; for (var M = 0; M < f.length;) { var C = f[M++], I = f[M++], te = h[I]; if (C.tag !== 5 || !L(C)) { for (; te != null && q1(C, te);)I++, te = h[I]; if (I === h.length) S.push(C); else for (C = C.child; C !== null;)f.push(C, I), C = C.sibling } } return S } function t_(f, h) { if (!we) throw Error(s(363)); f = Z1(f), f = EC(f, h), h = [], f = Array.from(f); for (var S = 0; S < f.length;) { var M = f[S++]; if (M.tag === 5) L(M) || h.push(M.stateNode); else for (M = M.child; M !== null;)f.push(M), M = M.sibling } return h } var wk = Math.ceil, km = a.ReactCurrentDispatcher, n_ = a.ReactCurrentOwner, Xn = a.ReactCurrentBatchConfig, Lt = 0, Zn = null, qn = null, Er = 0, ji = 0, mu = gt(0), or = 0, Ld = null, gu = 0, Nm = 0, r_ = 0, Dd = null, Ai = null, i_ = 0, o_ = 1 / 0; function vu() { o_ = Tn() + 500 } var zm = !1, s_ = null, Da = null, Gm = !1, Oa = null, Hm = 0, Od = 0, a_ = null, Vm = -1, Wm = 0; function ci() { return Lt & 6 ? Tn() : Vm !== -1 ? Vm : Vm = Tn() } function Fa(f) { return f.mode & 1 ? Lt & 2 && Er !== 0 ? Er & -Er : Ul.transition !== null ? (Wm === 0 && (f = zs, zs <<= 1, !(zs & 4194240) && (zs = 64), Wm = f), Wm) : (f = Ot, f !== 0 ? f : fe()) : 1 } function vo(f, h, S) { if (50 < Od) throw Od = 0, a_ = null, Error(s(185)); var M = jm(f, h); return M === null ? null : (ss(M, h, S), (!(Lt & 2) || M !== Zn) && (M === Zn && (!(Lt & 2) && (Nm |= h), or === 4 && Ua(M, Er)), Ei(M, S), h === 1 && Lt === 0 && !(f.mode & 1) && (vu(), ls && Si())), M) } function jm(f, h) { f.lanes |= h; var S = f.alternate; for (S !== null && (S.lanes |= h), S = f, f = f.return; f !== null;)f.childLanes |= h, S = f.alternate, S !== null && (S.childLanes |= h), S = f, f = f.return; return S.tag === 3 ? S.stateNode : null } function Ei(f, h) { var S = f.callbackNode; dd(f, h); var M = Dl(f, f === Zn ? Er : 0); if (M === 0) S !== null && ou(S), f.callbackNode = null, f.callbackPriority = 0; else if (h = M & -M, f.callbackPriority !== h) { if (S != null && ou(S), h === 1) f.tag === 0 ? yd(wC.bind(null, f)) : vd(wC.bind(null, f)), de ? Ie(function () { Lt === 0 && Si() }) : Ws(Ol, Si), S = null; else { switch (hd(M)) { case 1: S = Ol; break; case 4: S = lm; break; case 16: S = ii; break; case 536870912: S = md; break; default: S = ii }S = DC(S, MC.bind(null, f)) } f.callbackPriority = h, f.callbackNode = S } } function MC(f, h) { if (Vm = -1, Wm = 0, Lt & 6) throw Error(s(327)); var S = f.callbackNode; if (Jl() && f.callbackNode !== S) return null; var M = Dl(f, f === Zn ? Er : 0); if (M === 0) return null; if (M & 30 || M & f.expiredLanes || h) h = Xm(f, M); else { h = M; var C = Lt; Lt |= 2; var I = TC(); (Zn !== f || Er !== h) && (vu(), jl(f, h)); do try { Tk(); break } catch (ue) { CC(f, ue) } while (1); au(), km.current = I, Lt = C, qn !== null ? h = 0 : (Zn = null, Er = 0, h = or) } if (h !== 0) { if (h === 2 && (C = Vs(f), C !== 0 && (M = C, h = l_(f, C))), h === 1) throw S = Ld, jl(f, 0), Ua(f, M), Ei(f, Tn()), S; if (h === 6) Ua(f, M); else { if (C = f.current.alternate, !(M & 30) && !bk(C) && (h = Xm(f, M), h === 2 && (I = Vs(f), I !== 0 && (M = I, h = l_(f, I))), h === 1)) throw S = Ld, jl(f, 0), Ua(f, M), Ei(f, Tn()), S; switch (f.finishedWork = C, f.finishedLanes = M, h) { case 0: case 1: throw Error(s(345)); case 2: Xl(f, Ai); break; case 3: if (Ua(f, M), (M & 130023424) === M && (h = i_ + 500 - Tn(), 10 < h)) { if (Dl(f, 0) !== 0) break; if (C = f.suspendedLanes, (C & M) !== M) { ci(), f.pingedLanes |= f.suspendedLanes & C; break } f.timeoutHandle = ae(Xl.bind(null, f, Ai), h); break } Xl(f, Ai); break; case 4: if (Ua(f, M), (M & 4194240) === M) break; for (h = f.eventTimes, C = -1; 0 < M;) { var te = 31 - ki(M); I = 1 << te, te = h[te], te > C && (C = te), M &= ~I } if (M = C, M = Tn() - M, M = (120 > M ? 120 : 480 > M ? 480 : 1080 > M ? 1080 : 1920 > M ? 1920 : 3e3 > M ? 3e3 : 4320 > M ? 4320 : 1960 * wk(M / 1960)) - M, 10 < M) { f.timeoutHandle = ae(Xl.bind(null, f, Ai), M); break } Xl(f, Ai); break; case 5: Xl(f, Ai); break; default: throw Error(s(329)) } } } return Ei(f, Tn()), f.callbackNode === S ? MC.bind(null, f) : null } function l_(f, h) { var S = Dd; return f.current.memoizedState.isDehydrated && (jl(f, h).flags |= 256), f = Xm(f, h), f !== 2 && (h = Ai, Ai = S, h !== null && c_(h)), f } function c_(f) { Ai === null ? Ai = f : Ai.push.apply(Ai, f) } function bk(f) { for (var h = f; ;) { if (h.flags & 16384) { var S = h.updateQueue; if (S !== null && (S = S.stores, S !== null)) for (var M = 0; M < S.length; M++) { var C = S[M], I = C.getSnapshot; C = C.value; try { if (!zi(I(), C)) return !1 } catch { return !1 } } } if (S = h.child, h.subtreeFlags & 16384 && S !== null) S.return = h, h = S; else { if (h === f) break; for (; h.sibling === null;) { if (h.return === null || h.return === f) return !0; h = h.return } h.sibling.return = h.return, h = h.sibling } } return !0 } function Ua(f, h) { for (h &= ~r_, h &= ~Nm, f.suspendedLanes |= h, f.pingedLanes &= ~h, f = f.expirationTimes; 0 < h;) { var S = 31 - ki(h), M = 1 << S; f[S] = -1, h &= ~M } } function wC(f) { if (Lt & 6) throw Error(s(327)); Jl(); var h = Dl(f, 0); if (!(h & 1)) return Ei(f, Tn()), null; var S = Xm(f, h); if (f.tag !== 0 && S === 2) { var M = Vs(f); M !== 0 && (h = M, S = l_(f, M)) } if (S === 1) throw S = Ld, jl(f, 0), Ua(f, h), Ei(f, Tn()), S; if (S === 6) throw Error(s(345)); return f.finishedWork = f.current.alternate, f.finishedLanes = h, Xl(f, Ai), Ei(f, Tn()), null } function bC(f) { Oa !== null && Oa.tag === 0 && !(Lt & 6) && Jl(); var h = Lt; Lt |= 1; var S = Xn.transition, M = Ot; try { if (Xn.transition = null, Ot = 1, f) return f() } finally { Ot = M, Xn.transition = S, Lt = h, !(Lt & 6) && Si() } } function u_() { ji = mu.current, zt(mu) } function jl(f, h) { f.finishedWork = null, f.finishedLanes = 0; var S = f.timeoutHandle; if (S !== Se && (f.timeoutHandle = Se, ie(S)), qn !== null) for (S = qn.return; S !== null;) { var M = S; switch (C1(M), M.tag) { case 1: M = M.type.childContextTypes, M != null && ri(); break; case 3: hu(), zt(En), zt(On), D1(); break; case 5: I1(M); break; case 4: hu(); break; case 13: zt(Rn); break; case 19: zt(Rn); break; case 10: pr(M.type._context); break; case 22: case 23: u_() }S = S.return } if (Zn = f, qn = f = ka(f.current, null), Er = ji = h, or = 0, Ld = null, r_ = Nm = gu = 0, Ai = Dd = null, Gi !== null) { for (h = 0; h < Gi.length; h++)if (S = Gi[h], M = S.interleaved, M !== null) { S.interleaved = null; var C = M.next, I = S.pending; if (I !== null) { var te = I.next; I.next = C, M.next = te } S.pending = M } Gi = null } return f } function CC(f, h) { do { var S = qn; try { if (au(), ym.current = Mm, _m) { for (var M = Fn.memoizedState; M !== null;) { var C = M.queue; C !== null && (C.pending = null), M = M.next } _m = !1 } if (pu = 0, mr = Ur = Fn = null, Md = !1, wd = 0, n_.current = null, S === null || S.return === null) { or = 1, Ld = h, qn = null; break } e: { var I = f, te = S.return, ue = S, Fe = h; if (h = Er, ue.flags |= 32768, Fe !== null && typeof Fe == "object" && typeof Fe.then == "function") { var $e = Fe, ct = ue, Mt = ct.tag; if (!(ct.mode & 1) && (Mt === 0 || Mt === 11 || Mt === 15)) { var mt = ct.alternate; mt ? (ct.updateQueue = mt.updateQueue, ct.memoizedState = mt.memoizedState, ct.lanes = mt.lanes) : (ct.updateQueue = null, ct.memoizedState = null) } var un = Kb(te); if (un !== null) { un.flags &= -257, Yb(un, te, ue, I, h), un.mode & 1 && Jb(I, $e, h), h = un, Fe = $e; var ht = h.updateQueue; if (ht === null) { var zr = new Set; zr.add(Fe), h.updateQueue = zr } else ht.add(Fe); break e } else { if (!(h & 1)) { Jb(I, $e, h), f_(); break e } Fe = Error(s(426)) } } else if (Mn && ue.mode & 1) { var _o = Kb(te); if (_o !== null) { !(_o.flags & 65536) && (_o.flags |= 256), Yb(_o, te, ue, I, h), P1(Fe); break e } } I = Fe, or !== 4 && (or = 2), Dd === null ? Dd = [I] : Dd.push(I), Fe = G1(Fe, ue), ue = te; do { switch (ue.tag) { case 3: ue.flags |= 65536, h &= -h, ue.lanes |= h; var Me = jb(ue, Fe, h); hb(ue, Me); break e; case 1: I = Fe; var pe = ue.type, Le = ue.stateNode; if (!(ue.flags & 128) && (typeof pe.getDerivedStateFromError == "function" || Le !== null && typeof Le.componentDidCatch == "function" && (Da === null || !Da.has(Le)))) { ue.flags |= 65536, h &= -h, ue.lanes |= h; var rt = Xb(ue, I, h); hb(ue, rt); break e } }ue = ue.return } while (ue !== null) } PC(S) } catch (ft) { h = ft, qn === S && S !== null && (qn = S = S.return); continue } break } while (1) } function TC() { var f = km.current; return km.current = Mm, f === null ? Mm : f } function f_() { (or === 0 || or === 3 || or === 2) && (or = 4), Zn === null || !(gu & 268435455) && !(Nm & 268435455) || Ua(Zn, Er) } function Xm(f, h) { var S = Lt; Lt |= 2; var M = TC(); Zn === f && Er === h || jl(f, h); do try { Ck(); break } catch (C) { CC(f, C) } while (1); if (au(), Lt = S, km.current = M, qn !== null) throw Error(s(261)); return Zn = null, Er = 0, or } function Ck() { for (; qn !== null;)RC(qn) } function Tk() { for (; qn !== null && !pd();)RC(qn) } function RC(f) { var h = LC(f.alternate, f, ji); f.memoizedProps = f.pendingProps, h === null ? PC(f) : qn = h, n_.current = null } function PC(f) { var h = f; do { var S = h.alternate; if (f = h.return, h.flags & 32768) { if (S = xk(S, h), S !== null) { S.flags &= 32767, qn = S; return } if (f !== null) f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null; else { or = 6, qn = null; return } } else if (S = vk(S, h, ji), S !== null) { qn = S; return } if (h = h.sibling, h !== null) { qn = h; return } qn = h = f } while (h !== null); or === 0 && (or = 5) } function Xl(f, h) { var S = Ot, M = Xn.transition; try { Xn.transition = null, Ot = 1, Rk(f, h, S) } finally { Xn.transition = M, Ot = S } return null } function Rk(f, h, S) { do Jl(); while (Oa !== null); if (Lt & 6) throw Error(s(327)); var M = f.finishedWork, C = f.finishedLanes; if (M === null) return null; if (f.finishedWork = null, f.finishedLanes = 0, M === f.current) throw Error(s(177)); f.callbackNode = null, f.callbackPriority = 0; var I = M.lanes | M.childLanes; if (Pa(f, I), f === Zn && (qn = Zn = null, Er = 0), !(M.subtreeFlags & 2064) && !(M.flags & 2064) || Gm || (Gm = !0, DC(ii, function () { return Jl(), null })), I = (M.flags & 15990) !== 0, M.subtreeFlags & 15990 || I) { I = Xn.transition, Xn.transition = null; var te = Ot; Ot = 1; var ue = Lt; Lt |= 4, n_.current = null, Ak(f, M), Ek(f, M), J(f.containerInfo), f.current = M, Mk(M), am(), Lt = ue, Ot = te, Xn.transition = I } else f.current = M; if (Gm && (Gm = !1, Oa = f, Hm = C), I = f.pendingLanes, I === 0 && (Da = null), gd(M.stateNode), Ei(f, Tn()), h !== null) for (S = f.onRecoverableError, M = 0; M < h.length; M++)S(h[M]); if (zm) throw zm = !1, f = s_, s_ = null, f; return Hm & 1 && f.tag !== 0 && Jl(), I = f.pendingLanes, I & 1 ? f === a_ ? Od++ : (Od = 0, a_ = f) : Od = 0, Si(), null } function Jl() { if (Oa !== null) { var f = hd(Hm), h = Xn.transition, S = Ot; try { if (Xn.transition = null, Ot = 16 > f ? 16 : f, Oa === null) var M = !1; else { if (f = Oa, Oa = null, Hm = 0, Lt & 6) throw Error(s(331)); var C = Lt; for (Lt |= 4, tt = f.current; tt !== null;) { var I = tt, te = I.child; if (tt.flags & 16) { var ue = I.deletions; if (ue !== null) { for (var Fe = 0; Fe < ue.length; Fe++) { var $e = ue[Fe]; for (tt = $e; tt !== null;) { var ct = tt; switch (ct.tag) { case 0: case 11: case 15: Wl(8, ct, I) }var Mt = ct.child; if (Mt !== null) Mt.return = ct, tt = Mt; else for (; tt !== null;) { ct = tt; var mt = ct.sibling, un = ct.return; if (pC(ct), ct === $e) { tt = null; break } if (mt !== null) { mt.return = un, tt = mt; break } tt = un } } } var ht = I.alternate; if (ht !== null) { var zr = ht.child; if (zr !== null) { ht.child = null; do { var _o = zr.sibling; zr.sibling = null, zr = _o } while (zr !== null) } } tt = I } } if (I.subtreeFlags & 2064 && te !== null) te.return = I, tt = te; else e: for (; tt !== null;) { if (I = tt, I.flags & 2048) switch (I.tag) { case 0: case 11: case 15: Wl(9, I, I.return) }var Me = I.sibling; if (Me !== null) { Me.return = I.return, tt = Me; break e } tt = I.return } } var pe = f.current; for (tt = pe; tt !== null;) { te = tt; var Le = te.child; if (te.subtreeFlags & 2064 && Le !== null) Le.return = te, tt = Le; else e: for (te = pe; tt !== null;) { if (ue = tt, ue.flags & 2048) try { switch (ue.tag) { case 0: case 11: case 15: Bd(9, ue) } } catch (ft) { Mi(ue, ue.return, ft) } if (ue === te) { tt = null; break e } var rt = ue.sibling; if (rt !== null) { rt.return = ue.return, tt = rt; break e } tt = ue.return } } if (Lt = C, Si(), Ni && typeof Ni.onPostCommitFiberRoot == "function") try { Ni.onPostCommitFiberRoot(Fl, f) } catch { } M = !0 } return M } finally { Ot = S, Xn.transition = h } } return !1 } function BC(f, h, S) { h = G1(S, h), h = jb(f, h, 1), La(f, h), h = ci(), f = jm(f, 1), f !== null && (ss(f, 1, h), Ei(f, h)) } function Mi(f, h, S) { if (f.tag === 3) BC(f, f, S); else for (; h !== null;) { if (h.tag === 3) { BC(h, f, S); break } else if (h.tag === 1) { var M = h.stateNode; if (typeof h.type.getDerivedStateFromError == "function" || typeof M.componentDidCatch == "function" && (Da === null || !Da.has(M))) { f = G1(S, f), f = Xb(h, f, 1), La(h, f), f = ci(), h = jm(h, 1), h !== null && (ss(h, 1, f), Ei(h, f)); break } } h = h.return } } function Pk(f, h, S) { var M = f.pingCache; M !== null && M.delete(h), h = ci(), f.pingedLanes |= f.suspendedLanes & S, Zn === f && (Er & S) === S && (or === 4 || or === 3 && (Er & 130023424) === Er && 500 > Tn() - i_ ? jl(f, 0) : r_ |= S), Ei(f, h) } function IC(f, h) { h === 0 && (f.mode & 1 ? (h = Gs, Gs <<= 1, !(Gs & 130023424) && (Gs = 4194304)) : h = 1); var S = ci(); f = jm(f, h), f !== null && (ss(f, h, S), Ei(f, S)) } function Bk(f) { var h = f.memoizedState, S = 0; h !== null && (S = h.retryLane), IC(f, S) } function Ik(f, h) { var S = 0; switch (f.tag) { case 13: var M = f.stateNode, C = f.memoizedState; C !== null && (S = C.retryLane); break; case 19: M = f.stateNode; break; default: throw Error(s(314)) }M !== null && M.delete(h), IC(f, S) } var LC; LC = function (f, h, S) { if (f !== null) if (f.memoizedProps !== h.pendingProps || En.current) Wi = !0; else { if (!(f.lanes & S) && !(h.flags & 128)) return Wi = !1, _k(f, h, S); Wi = !!(f.flags & 131072) } else Wi = !1, Mn && h.flags & 1048576 && _b(h, mm, h.index); switch (h.lanes = 0, h.tag) { case 2: var M = h.type; f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), f = h.pendingProps; var C = cn(h, On.current); Wn(h, S), C = F1(null, h, M, f, C, S); var I = U1(); return h.flags |= 1, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, dn(M) ? (I = !0, os(h)) : I = !1, h.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, E1(h), C.updater = hm, h.stateNode = C, C._reactInternals = h, w1(h, M, f, S), h = W1(null, h, M, !0, I, S)) : (h.tag = 0, Mn && I && b1(h), li(null, h, C, S), h = h.child), h; case 16: M = h.elementType; e: { switch (f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), f = h.pendingProps, C = M._init, M = C(M._payload), h.type = M, C = h.tag = Dk(M), f = si(M, f), C) { case 0: h = V1(null, h, M, f, S); break e; case 1: h = rC(null, h, M, f, S); break e; case 11: h = Zb(null, h, M, f, S); break e; case 14: h = qb(null, h, M, si(M.type, f), S); break e }throw Error(s(306, M, "")) } return h; case 0: return M = h.type, C = h.pendingProps, C = h.elementType === M ? C : si(M, C), V1(f, h, M, C, S); case 1: return M = h.type, C = h.pendingProps, C = h.elementType === M ? C : si(M, C), rC(f, h, M, C, S); case 3: e: { if (iC(h), f === null) throw Error(s(387)); M = h.pendingProps, I = h.memoizedState, C = I.element, db(f, h), dm(h, M, null, S); var te = h.memoizedState; if (M = te.element, me && I.isDehydrated) if (I = { element: M, isDehydrated: !1, cache: te.cache, transitions: te.transitions }, h.updateQueue.baseState = I, h.memoizedState = I, h.flags & 256) { C = Error(s(423)), h = oC(f, h, M, S, C); break e } else if (M !== C) { C = Error(s(424)), h = oC(f, h, M, S, C); break e } else for (me && (Vi = gn(h.stateNode.containerInfo), Hi = h, Mn = !0, Fo = null, _d = !1), S = wb(h, null, M, S), h.child = S; S;)S.flags = S.flags & -3 | 4096, S = S.sibling; else { if (uu(), M === C) { h = Ys(f, h, S); break e } li(f, h, M, S) } h = h.child } return h; case 5: return bb(h), f === null && R1(h), M = h.type, C = h.pendingProps, I = f !== null ? f.memoizedProps : null, te = C.children, ne(M, C) ? te = null : I !== null && ne(M, I) && (h.flags |= 32), nC(f, h), li(f, h, te, S), h.child; case 6: return f === null && R1(h), null; case 13: return sC(f, h, S); case 4: return B1(h, h.stateNode.containerInfo), M = h.pendingProps, f === null ? h.child = fu(h, null, M, S) : li(f, h, M, S), h.child; case 11: return M = h.type, C = h.pendingProps, C = h.elementType === M ? C : si(M, C), Zb(f, h, M, C, S); case 7: return li(f, h, h.pendingProps, S), h.child; case 8: return li(f, h, h.pendingProps.children, S), h.child; case 12: return li(f, h, h.pendingProps.children, S), h.child; case 10: e: { if (M = h.type._context, C = h.pendingProps, I = h.memoizedProps, te = C.value, um(h, M, te), I !== null) if (zi(I.value, te)) { if (I.children === C.children && !En.current) { h = Ys(f, h, S); break e } } else for (I = h.child, I !== null && (I.return = h); I !== null;) { var ue = I.dependencies; if (ue !== null) { te = I.child; for (var Fe = ue.firstContext; Fe !== null;) { if (Fe.context === M) { if (I.tag === 1) { Fe = js(-1, S & -S), Fe.tag = 2; var $e = I.updateQueue; if ($e !== null) { $e = $e.shared; var ct = $e.pending; ct === null ? Fe.next = Fe : (Fe.next = ct.next, ct.next = Fe), $e.pending = Fe } } I.lanes |= S, Fe = I.alternate, Fe !== null && (Fe.lanes |= S), ai(I.return, S, h), ue.lanes |= S; break } Fe = Fe.next } } else if (I.tag === 10) te = I.type === h.type ? null : I.child; else if (I.tag === 18) { if (te = I.return, te === null) throw Error(s(341)); te.lanes |= S, ue = te.alternate, ue !== null && (ue.lanes |= S), ai(te, S, h), te = I.sibling } else te = I.child; if (te !== null) te.return = I; else for (te = I; te !== null;) { if (te === h) { te = null; break } if (I = te.sibling, I !== null) { I.return = te.return, te = I; break } te = te.return } I = te } li(f, h, C.children, S), h = h.child } return h; case 9: return C = h.type, M = h.pendingProps.children, Wn(h, S), C = jn(C), M = M(C), h.flags |= 1, li(f, h, M, S), h.child; case 14: return M = h.type, C = si(M, h.pendingProps), C = si(M.type, C), qb(f, h, M, C, S); case 15: return eC(f, h, h.type, h.pendingProps, S); case 17: return M = h.type, C = h.pendingProps, C = h.elementType === M ? C : si(M, C), f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), h.tag = 1, dn(M) ? (f = !0, os(h)) : f = !1, Wn(h, S), vb(h, M, C), w1(h, M, C, S), W1(null, h, M, !0, f, S); case 19: return uC(f, h, S); case 22: return tC(f, h, S) }throw Error(s(156, h.tag)) }; function DC(f, h) { return Ws(f, h) } function Lk(f, h, S, M) { this.tag = f, this.key = S, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = M, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function yo(f, h, S, M) { return new Lk(f, h, S, M) } function d_(f) { return f = f.prototype, !(!f || !f.isReactComponent) } function Dk(f) { if (typeof f == "function") return d_(f) ? 1 : 0; if (f != null) { if (f = f.$$typeof, f === y) return 11; if (f === x) return 14 } return 2 } function ka(f, h) { var S = f.alternate; return S === null ? (S = yo(f.tag, h, f.key, f.mode), S.elementType = f.elementType, S.type = f.type, S.stateNode = f.stateNode, S.alternate = f, f.alternate = S) : (S.pendingProps = h, S.type = f.type, S.flags = 0, S.subtreeFlags = 0, S.deletions = null), S.flags = f.flags & 14680064, S.childLanes = f.childLanes, S.lanes = f.lanes, S.child = f.child, S.memoizedProps = f.memoizedProps, S.memoizedState = f.memoizedState, S.updateQueue = f.updateQueue, h = f.dependencies, S.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, S.sibling = f.sibling, S.index = f.index, S.ref = f.ref, S } function Jm(f, h, S, M, C, I) { var te = 2; if (M = f, typeof f == "function") d_(f) && (te = 1); else if (typeof f == "string") te = 5; else e: switch (f) { case u: return Kl(S.children, C, I, h); case d: te = 8, C |= 8; break; case p: return f = yo(12, S, h, C | 2), f.elementType = p, f.lanes = I, f; case _: return f = yo(13, S, h, C), f.elementType = _, f.lanes = I, f; case g: return f = yo(19, S, h, C), f.elementType = g, f.lanes = I, f; case E: return Km(S, C, I, h); default: if (typeof f == "object" && f !== null) switch (f.$$typeof) { case m: te = 10; break e; case v: te = 9; break e; case y: te = 11; break e; case x: te = 14; break e; case A: te = 16, M = null; break e }throw Error(s(130, f == null ? f : typeof f, "")) }return h = yo(te, S, h, C), h.elementType = f, h.type = M, h.lanes = I, h } function Kl(f, h, S, M) { return f = yo(7, f, M, h), f.lanes = S, f } function Km(f, h, S, M) { return f = yo(22, f, M, h), f.elementType = E, f.lanes = S, f.stateNode = {}, f } function h_(f, h, S) { return f = yo(6, f, null, h), f.lanes = S, f } function p_(f, h, S) { return h = yo(4, f.children !== null ? f.children : [], f.key, h), h.lanes = S, h.stateNode = { containerInfo: f.containerInfo, pendingChildren: null, implementation: f.implementation }, h } function Ok(f, h, S, M, C) { this.tag = h, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Se, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = iu(0), this.expirationTimes = iu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = iu(0), this.identifierPrefix = M, this.onRecoverableError = C, me && (this.mutableSourceEagerHydrationData = null) } function OC(f, h, S, M, C, I, te, ue, Fe) { return f = new Ok(f, h, S, ue, Fe), h === 1 ? (h = 1, I === !0 && (h |= 8)) : h = 0, I = yo(3, null, null, h), f.current = I, I.stateNode = f, I.memoizedState = { element: M, isDehydrated: S, cache: null, transitions: null }, E1(I), f } function FC(f) { if (!f) return Vn; f = f._reactInternals; e: { if (R(f) !== f || f.tag !== 1) throw Error(s(170)); var h = f; do { switch (h.tag) { case 3: h = h.stateNode.context; break e; case 1: if (dn(h.type)) { h = h.stateNode.__reactInternalMemoizedMergedChildContext; break e } }h = h.return } while (h !== null); throw Error(s(171)) } if (f.tag === 1) { var S = f.type; if (dn(S)) return is(f, S, h) } return h } function UC(f) { var h = f._reactInternals; if (h === void 0) throw typeof f.render == "function" ? Error(s(188)) : (f = Object.keys(f).join(","), Error(s(268, f))); return f = G(h), f === null ? null : f.stateNode } function kC(f, h) { if (f = f.memoizedState, f !== null && f.dehydrated !== null) { var S = f.retryLane; f.retryLane = S !== 0 && S < h ? S : h } } function m_(f, h) { kC(f, h), (f = f.alternate) && kC(f, h) } function Fk(f) { return f = G(f), f === null ? null : f.stateNode } function Uk() { return null } return t.attemptContinuousHydration = function (f) { if (f.tag === 13) { var h = ci(); vo(f, 134217728, h), m_(f, 134217728) } }, t.attemptHydrationAtCurrentPriority = function (f) { if (f.tag === 13) { var h = ci(), S = Fa(f); vo(f, S, h), m_(f, S) } }, t.attemptSynchronousHydration = function (f) { switch (f.tag) { case 3: var h = f.stateNode; if (h.current.memoizedState.isDehydrated) { var S = Hs(h.pendingLanes); S !== 0 && (as(h, S | 1), Ei(h, Tn()), !(Lt & 6) && (vu(), Si())) } break; case 13: var M = ci(); bC(function () { return vo(f, 1, M) }), m_(f, 1) } }, t.batchedUpdates = function (f, h) { var S = Lt; Lt |= 1; try { return f(h) } finally { Lt = S, Lt === 0 && (vu(), ls && Si()) } }, t.createComponentSelector = function (f) { return { $$typeof: Lm, value: f } }, t.createContainer = function (f, h, S, M, C, I, te) { return OC(f, h, !1, null, S, M, C, I, te) }, t.createHasPseudoClassSelector = function (f) { return { $$typeof: Dm, value: f } }, t.createHydrationContainer = function (f, h, S, M, C, I, te, ue, Fe) { return f = OC(S, M, !0, f, C, I, te, ue, Fe), f.context = FC(null), S = f.current, M = ci(), C = Fa(S), I = js(M, C), I.callback = h ?? null, La(S, I), f.current.lanes = C, ss(f, C, M), Ei(f, M), f }, t.createPortal = function (f, h, S) { var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: c, key: M == null ? null : "" + M, children: f, containerInfo: h, implementation: S } }, t.createRoleSelector = function (f) { return { $$typeof: Om, value: f } }, t.createTestNameSelector = function (f) { return { $$typeof: Fm, value: f } }, t.createTextSelector = function (f) { return { $$typeof: Um, value: f } }, t.deferredUpdates = function (f) { var h = Ot, S = Xn.transition; try { return Xn.transition = null, Ot = 16, f() } finally { Ot = h, Xn.transition = S } }, t.discreteUpdates = function (f, h, S, M, C) { var I = Ot, te = Xn.transition; try { return Xn.transition = null, Ot = 1, f(h, S, M, C) } finally { Ot = I, Xn.transition = te, Lt === 0 && vu() } }, t.findAllNodes = t_, t.findBoundingRects = function (f, h) { if (!we) throw Error(s(363)); h = t_(f, h), f = []; for (var S = 0; S < h.length; S++)f.push(Ve(h[S])); for (h = f.length - 1; 0 < h; h--) { S = f[h]; for (var M = S.x, C = M + S.width, I = S.y, te = I + S.height, ue = h - 1; 0 <= ue; ue--)if (h !== ue) { var Fe = f[ue], $e = Fe.x, ct = $e + Fe.width, Mt = Fe.y, mt = Mt + Fe.height; if (M >= $e && I >= Mt && C <= ct && te <= mt) { f.splice(h, 1); break } else if (M !== $e || S.width !== Fe.width || mt < I || Mt > te) { if (!(I !== Mt || S.height !== Fe.height || ct < M || $e > C)) { $e > M && (Fe.width += $e - M, Fe.x = M), ct < C && (Fe.width = C - $e), f.splice(h, 1); break } } else { Mt > I && (Fe.height += Mt - I, Fe.y = I), mt < te && (Fe.height = te - Mt), f.splice(h, 1); break } } } return f }, t.findHostInstance = UC, t.findHostInstanceWithNoPortals = function (f) { return f = U(f), f = f !== null ? z(f) : null, f === null ? null : f.stateNode }, t.findHostInstanceWithWarning = function (f) { return UC(f) }, t.flushControlled = function (f) { var h = Lt; Lt |= 1; var S = Xn.transition, M = Ot; try { Xn.transition = null, Ot = 1, f() } finally { Ot = M, Xn.transition = S, Lt = h, Lt === 0 && (vu(), Si()) } }, t.flushPassiveEffects = Jl, t.flushSync = bC, t.focusWithin = function (f, h) { if (!we) throw Error(s(363)); for (f = Z1(f), h = EC(f, h), h = Array.from(h), f = 0; f < h.length;) { var S = h[f++]; if (!L(S)) { if (S.tag === 5 && Pe(S.stateNode)) return !0; for (S = S.child; S !== null;)h.push(S), S = S.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return Ot }, t.getFindAllNodesFailureDescription = function (f, h) {
		if (!we) throw Error(s(363)); var S = 0, M = []; f = [Z1(f), 0]; for (var C = 0; C < f.length;) { var I = f[C++], te = f[C++], ue = h[te]; if ((I.tag !== 5 || !L(I)) && (q1(I, ue) && (M.push(e_(ue)), te++, te > S && (S = te)), te < h.length)) for (I = I.child; I !== null;)f.push(I, te), I = I.sibling } if (S < h.length) {
			for (f = []; S < h.length; S++)f.push(e_(h[S])); return `findAllNodes was able to match part of the selector:
  `+ (M.join(" > ") + `

No matching component was found for:
  `) + f.join(" > ")
		} return null
	}, t.getPublicRootInstance = function (f) { if (f = f.current, !f.child) return null; switch (f.child.tag) { case 5: return q(f.child.stateNode); default: return f.child.stateNode } }, t.injectIntoDevTools = function (f) { if (f = { bundleType: f.bundleType, version: f.version, rendererPackageName: f.rendererPackageName, rendererConfig: f.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: Fk, findFiberByHostInstance: f.findFiberByHostInstance || Uk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") f = !1; else { var h = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (h.isDisabled || !h.supportsFiber) f = !0; else { try { Fl = h.inject(f), Ni = h } catch { } f = !!h.checkDCE } } return f }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (f, h, S, M) { if (!we) throw Error(s(363)); f = t_(f, h); var C = Ae(f, S, M).disconnect; return { disconnect: function () { C() } } }, t.registerMutableSourceForHydration = function (f, h) { var S = h._getVersion; S = S(h._source), f.mutableSourceEagerHydrationData == null ? f.mutableSourceEagerHydrationData = [h, S] : f.mutableSourceEagerHydrationData.push(h, S) }, t.runWithPriority = function (f, h) { var S = Ot; try { return Ot = f, h() } finally { Ot = S } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (f, h, S, M) { var C = h.current, I = ci(), te = Fa(C); return S = FC(S), h.context === null ? h.context = S : h.pendingContext = S, h = js(I, te), h.payload = { element: f }, M = M === void 0 ? null : M, M !== null && (h.callback = M), La(C, h), f = vo(C, te, I), f !== null && fm(f, C, te), te }, t
}; zO.exports = DV; var OV = zO.exports; const FV = Rp(OV), UV = n => typeof n == "object" && typeof n.then == "function", Mc = []; function VO(n, e, t = (r, i) => r === i) { if (n === e) return !0; if (!n || !e) return !1; const r = n.length; if (e.length !== r) return !1; for (let i = 0; i < r; i++)if (!t(n[i], e[i])) return !1; return !0 } function WO(n, e = null, t = !1, r = {}) { e === null && (e = [n]); for (const o of Mc) if (VO(e, o.keys, o.equal)) { if (t) return; if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error; if (Object.prototype.hasOwnProperty.call(o, "response")) return r.lifespan && r.lifespan > 0 && (o.timeout && clearTimeout(o.timeout), o.timeout = setTimeout(o.remove, r.lifespan)), o.response; if (!t) throw o.promise } const i = { keys: e, equal: r.equal, remove: () => { const o = Mc.indexOf(i); o !== -1 && Mc.splice(o, 1) }, promise: (UV(n) ? n : n(...e)).then(o => { i.response = o, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan)) }).catch(o => i.error = o) }; if (Mc.push(i), !t) throw i.promise } const jO = (n, e, t) => WO(n, e, !1, t), kV = (n, e, t) => void WO(n, e, !0, t), NV = n => { if (n === void 0 || n.length === 0) Mc.splice(0, Mc.length); else { const e = Mc.find(t => VO(n, t.keys, t.equal)); e && e.remove() } }, fw = {}, ky = n => void Object.assign(fw, n); function zV(n, e) { function t(u, { args: d = [], attach: p, ...m }, v) { let y = `${u[0].toUpperCase()}${u.slice(1)}`, _; if (u === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const g = m.object; _ = Yu(g, { type: u, root: v, attach: p, primitive: !0 }) } else { const g = fw[y]; if (!g) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!"); _ = Yu(new g(...d), { type: u, root: v, attach: p, memoizedProps: { args: d } }) } return _.__r3f.attach === void 0 && (_ instanceof bt ? _.__r3f.attach = "geometry" : _ instanceof rr && (_.__r3f.attach = "material")), y !== "inject" && Ex(_, m), _ } function r(u, d) { let p = !1; if (d) { var m, v; (m = d.__r3f) != null && m.attach ? Ax(u, d, d.__r3f.attach) : d.isObject3D && u.isObject3D && (u.add(d), p = !0), p || (v = u.__r3f) == null || v.objects.push(d), d.__r3f || Yu(d, {}), d.__r3f.parent = u, GA(d), $u(d) } } function i(u, d, p) { let m = !1; if (d) { var v, y; if ((v = d.__r3f) != null && v.attach) Ax(u, d, d.__r3f.attach); else if (d.isObject3D && u.isObject3D) { d.parent = u, d.dispatchEvent({ type: "added" }); const _ = u.children.filter(x => x !== d), g = _.indexOf(p); u.children = [..._.slice(0, g), d, ..._.slice(g)], m = !0 } m || (y = u.__r3f) == null || y.objects.push(d), d.__r3f || Yu(d, {}), d.__r3f.parent = u, GA(d), $u(d) } } function o(u, d, p = !1) { u && [...u].forEach(m => s(d, m, p)) } function s(u, d, p) { if (d) { var m, v, y; if (d.__r3f && (d.__r3f.parent = null), (m = u.__r3f) != null && m.objects && (u.__r3f.objects = u.__r3f.objects.filter(E => E !== d)), (v = d.__r3f) != null && v.attach) bR(u, d, d.__r3f.attach); else if (d.isObject3D && u.isObject3D) { var _; u.remove(d), (_ = d.__r3f) != null && _.root && YV(d.__r3f.root, d) } const x = (y = d.__r3f) == null ? void 0 : y.primitive, A = p === void 0 ? d.dispose !== null && !x : p; if (!x) { var g; o((g = d.__r3f) == null ? void 0 : g.objects, d, A), o(d.children, d, A) } delete d.__r3f, A && d.dispose && d.type !== "Scene" && NA.unstable_scheduleCallback(NA.unstable_IdlePriority, () => { try { d.dispose() } catch { } }), $u(u) } } function a(u, d, p, m) { var v; const y = (v = u.__r3f) == null ? void 0 : v.parent; if (!y) return; const _ = t(d, p, u.__r3f.root); if (u.children) { for (const g of u.children) g.__r3f && r(_, g); u.children = u.children.filter(g => !g.__r3f) } u.__r3f.objects.forEach(g => r(_, g)), u.__r3f.objects = [], u.__r3f.autoRemovedBeforeAppend || s(y, u), _.parent && (_.__r3f.autoRemovedBeforeAppend = !0), r(y, _), _.raycast && _.__r3f.eventCount && _.__r3f.root.getState().internal.interaction.push(_), [m, m.alternate].forEach(g => { g !== null && (g.stateNode = _, g.ref && (typeof g.ref == "function" ? g.ref(_) : g.ref.current = _)) }) } const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."); return { reconciler: FV({ createInstance: t, removeChild: s, appendChild: r, appendInitialChild: r, insertBefore: i, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (u, d) => { if (!d) return; const p = u.getState().scene; p.__r3f && (p.__r3f.root = u, r(p, d)) }, removeChildFromContainer: (u, d) => { d && s(u.getState().scene, d) }, insertInContainerBefore: (u, d, p) => { if (!d || !p) return; const m = u.getState().scene; m.__r3f && i(m, d, p) }, getRootHostContext: () => null, getChildHostContext: u => u, finalizeInitialChildren(u) { var d; return !!((d = u == null ? void 0 : u.__r3f) != null ? d : {}).handlers }, prepareUpdate(u, d, p, m) { var v; if (((v = u == null ? void 0 : u.__r3f) != null ? v : {}).primitive && m.object && m.object !== u) return [!0]; { const { args: _ = [], children: g, ...x } = m, { args: A = [], children: E, ...w } = p; if (!Array.isArray(_)) throw new Error("R3F: the args prop must be an array!"); if (_.some((T, B) => T !== A[B])) return [!0]; const b = ZO(u, x, w, !0); return b.changes.length ? [!1, b] : null } }, commitUpdate(u, [d, p], m, v, y, _) { d ? a(u, m, y, _) : Ex(u, p) }, commitMount(u, d, p, m) { var v; const y = (v = u.__r3f) != null ? v : {}; u.raycast && y.handlers && y.eventCount && u.__r3f.root.getState().internal.interaction.push(u) }, getPublicInstance: u => u, prepareForCommit: () => null, preparePortalMount: u => Yu(u.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(u) { var d; const { attach: p, parent: m } = (d = u.__r3f) != null ? d : {}; p && m && bR(m, u, p), u.isObject3D && (u.visible = !1), $u(u) }, unhideInstance(u, d) { var p; const { attach: m, parent: v } = (p = u.__r3f) != null ? p : {}; m && v && Ax(v, u, m), (u.isObject3D && d.visible == null || d.visible) && (u.visible = !0), $u(u) }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : pf.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && yn.fun(performance.now) ? performance.now : yn.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: yn.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: yn.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: Ex } } var AR, ER; const Sx = n => "colorSpace" in n || "outputColorSpace" in n, XO = () => { var n; return (n = fw.ColorManagement) != null ? n : null }, JO = n => n && n.isOrthographicCamera, GV = n => n && n.hasOwnProperty("current"), Jp = typeof window < "u" && ((AR = window.document) != null && AR.createElement || ((ER = window.navigator) == null ? void 0 : ER.product) === "ReactNative") ? N.useLayoutEffect : N.useEffect; function KO(n) { const e = N.useRef(n); return Jp(() => void (e.current = n), [n]), e } function HV({ set: n }) { return Jp(() => (n(new Promise(() => null)), () => n(!1)), [n]), null } class YO extends N.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } YO.getDerivedStateFromError = () => ({ error: !0 }); const $O = "__default", MR = new Map, VV = n => n && !!n.memoized && !!n.changes; function QO(n) { var e; const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1; return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n } const eh = n => { var e; return (e = n.__r3f) == null ? void 0 : e.root.getState() }, yn = { obj: n => n === Object(n) && !yn.arr(n) && typeof n != "function", fun: n => typeof n == "function", str: n => typeof n == "string", num: n => typeof n == "number", boo: n => typeof n == "boolean", und: n => n === void 0, arr: n => Array.isArray(n), equ(n, e, { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}) { if (typeof n != typeof e || !!n != !!e) return !1; if (yn.str(n) || yn.num(n)) return n === e; const o = yn.obj(n); if (o && r === "reference") return n === e; const s = yn.arr(n); if (s && t === "reference") return n === e; if ((s || o) && n === e) return !0; let a; for (a in n) if (!(a in e)) return !1; if (o && t === "shallow" && r === "shallow") { for (a in i ? e : n) if (!yn.equ(n[a], e[a], { strict: i, objects: "reference" })) return !1 } else for (a in i ? e : n) if (n[a] !== e[a]) return !1; if (yn.und(a)) { if (s && n.length === 0 && e.length === 0 || o && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0; if (n !== e) return !1 } return !0 } }; function WV(n) { const e = { nodes: {}, materials: {} }; return n && n.traverse(t => { t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material) }), e } function jV(n) { n.dispose && n.type !== "Scene" && n.dispose(); for (const e in n) e.dispose == null || e.dispose(), delete n[e] } function Yu(n, e) { const t = n; return t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, n } function zA(n, e) { let t = n; if (e.includes("-")) { const r = e.split("-"), i = r.pop(); return t = r.reduce((o, s) => o[s], n), { target: t, key: i } } else return { target: t, key: e } } const wR = /-\d+$/; function Ax(n, e, t) { if (yn.str(t)) { if (wR.test(t)) { const o = t.replace(wR, ""), { target: s, key: a } = zA(n, o); Array.isArray(s[a]) || (s[a] = []) } const { target: r, key: i } = zA(n, t); e.__r3f.previousAttach = r[i], r[i] = e } else e.__r3f.previousAttach = t(n, e) } function bR(n, e, t) { var r, i; if (yn.str(t)) { const { target: o, key: s } = zA(n, t), a = e.__r3f.previousAttach; a === void 0 ? delete o[s] : o[s] = a } else (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e); (i = e.__r3f) == null || delete i.previousAttach } function ZO(n, { children: e, key: t, ref: r, ...i }, { children: o, key: s, ref: a, ...l } = {}, c = !1) { var u; const d = (u = n == null ? void 0 : n.__r3f) != null ? u : {}, p = Object.entries(i), m = []; if (c) { const y = Object.keys(l); for (let _ = 0; _ < y.length; _++)i.hasOwnProperty(y[_]) || p.unshift([y[_], $O + "remove"]) } p.forEach(([y, _]) => { var g; if ((g = n.__r3f) != null && g.primitive && y === "object" || yn.equ(_, l[y])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y)) return m.push([y, _, !0, []]); let x = []; y.includes("-") && (x = y.split("-")), m.push([y, _, !1, x]); for (const A in i) { const E = i[A]; A.startsWith(`${y}-`) && m.push([A, E, !1, A.split("-")]) } }); const v = { ...i }; return d.memoizedProps && d.memoizedProps.args && (v.args = d.memoizedProps.args), d.memoizedProps && d.memoizedProps.attach && (v.attach = d.memoizedProps.attach), { memoized: v, changes: m } } const XV = typeof process < "u" && !1; function Ex(n, e) { var t, r, i; const o = (t = n.__r3f) != null ? t : {}, s = o.root, a = (r = s == null || s.getState == null ? void 0 : s.getState()) != null ? r : {}, { memoized: l, changes: c } = VV(e) ? e : ZO(n, e), u = o.eventCount; n.__r3f && (n.__r3f.memoizedProps = l); for (let p = 0; p < c.length; p++) { let [m, v, y, _] = c[p]; if (Sx(n)) { const E = "srgb", w = "srgb-linear"; m === "encoding" ? (m = "colorSpace", v = v === 3001 ? E : w) : m === "outputEncoding" && (m = "outputColorSpace", v = v === 3001 ? E : w) } let g = n, x = g[m]; if (_.length && (x = _.reduce((A, E) => A[E], n), !(x && x.set))) { const [A, ...E] = _.reverse(); g = E.reverse().reduce((w, b) => w[b], n), m = A } if (v === $O + "remove") if (g.constructor) { let A = MR.get(g.constructor); A || (A = new g.constructor, MR.set(g.constructor, A)), v = A[m] } else v = 0; if (y) v ? o.handlers[m] = v : delete o.handlers[m], o.eventCount = Object.keys(o.handlers).length; else if (x && x.set && (x.copy || x instanceof Bc)) { if (Array.isArray(v)) x.fromArray ? x.fromArray(v) : x.set(...v); else if (x.copy && v && v.constructor && (XV ? x.constructor.name === v.constructor.name : x.constructor === v.constructor)) x.copy(v); else if (v !== void 0) { const A = x instanceof qe; !A && x.setScalar ? x.setScalar(v) : x instanceof Bc && v instanceof Bc ? x.mask = v.mask : x.set(v), !XO() && !a.linear && A && x.convertSRGBToLinear() } } else if (g[m] = v, g[m] instanceof An && g[m].format === Yr && g[m].type === $o) { const A = g[m]; Sx(A) && Sx(a.gl) ? A.colorSpace = a.gl.outputColorSpace : A.encoding = a.gl.outputEncoding } $u(n) } if (o.parent && a.internal && n.raycast && u !== o.eventCount) { const p = a.internal.interaction.indexOf(n); p > -1 && a.internal.interaction.splice(p, 1), o.eventCount && a.internal.interaction.push(n) } return !(c.length === 1 && c[0][0] === "onUpdate") && c.length && (i = n.__r3f) != null && i.parent && GA(n), n } function $u(n) { var e, t; const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState(); r && r.internal.frames === 0 && r.invalidate() } function GA(n) { n.onUpdate == null || n.onUpdate(n) } function JV(n, e) { n.manual || (JO(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld()) } function t0(n) { return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId } function KV() { var n; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return pf.DefaultEventPriority; switch ((n = e.event) == null ? void 0 : n.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return pf.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return pf.ContinuousEventPriority; default: return pf.DefaultEventPriority } } function qO(n, e, t, r) { const i = t.get(e); i && (t.delete(e), t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r))) } function YV(n, e) { const { internal: t } = n.getState(); t.interaction = t.interaction.filter(r => r !== e), t.initialHits = t.initialHits.filter(r => r !== e), t.hovered.forEach((r, i) => { (r.eventObject === e || r.object === e) && t.hovered.delete(i) }), t.capturedMap.forEach((r, i) => { qO(t.capturedMap, e, r, i) }) } function $V(n) { function e(l) { const { internal: c } = n.getState(), u = l.offsetX - c.initialClick[0], d = l.offsetY - c.initialClick[1]; return Math.round(Math.sqrt(u * u + d * d)) } function t(l) { return l.filter(c => ["Move", "Over", "Enter", "Out", "Leave"].some(u => { var d; return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + u] })) } function r(l, c) { const u = n.getState(), d = new Set, p = [], m = c ? c(u.internal.interaction) : u.internal.interaction; for (let g = 0; g < m.length; g++) { const x = eh(m[g]); x && (x.raycaster.camera = void 0) } u.previousRoot || u.events.compute == null || u.events.compute(l, u); function v(g) { const x = eh(g); if (!x || !x.events.enabled || x.raycaster.camera === null) return []; if (x.raycaster.camera === void 0) { var A; x.events.compute == null || x.events.compute(l, x, (A = x.previousRoot) == null ? void 0 : A.getState()), x.raycaster.camera === void 0 && (x.raycaster.camera = null) } return x.raycaster.camera ? x.raycaster.intersectObject(g, !0) : [] } let y = m.flatMap(v).sort((g, x) => { const A = eh(g.object), E = eh(x.object); return !A || !E ? g.distance - x.distance : E.events.priority - A.events.priority || g.distance - x.distance }).filter(g => { const x = t0(g); return d.has(x) ? !1 : (d.add(x), !0) }); u.events.filter && (y = u.events.filter(y, u)); for (const g of y) { let x = g.object; for (; x;) { var _; (_ = x.__r3f) != null && _.eventCount && p.push({ ...g, eventObject: x }), x = x.parent } } if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId)) for (let g of u.internal.capturedMap.get(l.pointerId).values()) d.has(t0(g.intersection)) || p.push(g.intersection); return p } function i(l, c, u, d) { const p = n.getState(); if (l.length) { const m = { stopped: !1 }; for (const v of l) { const y = eh(v.object) || p, { raycaster: _, pointer: g, camera: x, internal: A } = y, E = new X(g.x, g.y, 0).unproject(x), w = P => { var U, G; return (U = (G = A.capturedMap.get(P)) == null ? void 0 : G.has(v.eventObject)) != null ? U : !1 }, b = P => { const U = { intersection: v, target: c.target }; A.capturedMap.has(P) ? A.capturedMap.get(P).set(v.eventObject, U) : A.capturedMap.set(P, new Map([[v.eventObject, U]])), c.target.setPointerCapture(P) }, T = P => { const U = A.capturedMap.get(P); U && qO(A.capturedMap, v.eventObject, U, P) }; let B = {}; for (let P in c) { let U = c[P]; typeof U != "function" && (B[P] = U) } let R = { ...v, ...B, pointer: g, intersections: l, stopped: m.stopped, delta: u, unprojectedPoint: E, ray: _.ray, camera: x, stopPropagation() { const P = "pointerId" in c && A.capturedMap.get(c.pointerId); if ((!P || P.has(v.eventObject)) && (R.stopped = m.stopped = !0, A.hovered.size && Array.from(A.hovered.values()).find(U => U.eventObject === v.eventObject))) { const U = l.slice(0, l.indexOf(v)); o([...U, v]) } }, target: { hasPointerCapture: w, setPointerCapture: b, releasePointerCapture: T }, currentTarget: { hasPointerCapture: w, setPointerCapture: b, releasePointerCapture: T }, nativeEvent: c }; if (d(R), m.stopped === !0) break } } return l } function o(l) { const { internal: c } = n.getState(); for (const u of c.hovered.values()) if (!l.length || !l.find(d => d.object === u.object && d.index === u.index && d.instanceId === u.instanceId)) { const p = u.eventObject.__r3f, m = p == null ? void 0 : p.handlers; if (c.hovered.delete(t0(u)), p != null && p.eventCount) { const v = { ...u, intersections: l }; m.onPointerOut == null || m.onPointerOut(v), m.onPointerLeave == null || m.onPointerLeave(v) } } } function s(l, c) { for (let u = 0; u < c.length; u++) { const d = c[u].__r3f; d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l) } } function a(l) { switch (l) { case "onPointerLeave": case "onPointerCancel": return () => o([]); case "onLostPointerCapture": return c => { const { internal: u } = n.getState(); "pointerId" in c && u.capturedMap.has(c.pointerId) && requestAnimationFrame(() => { u.capturedMap.has(c.pointerId) && (u.capturedMap.delete(c.pointerId), o([])) }) } }return function (u) { const { onPointerMissed: d, internal: p } = n.getState(); p.lastEvent.current = u; const m = l === "onPointerMove", v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", _ = r(u, m ? t : void 0), g = v ? e(u) : 0; l === "onPointerDown" && (p.initialClick = [u.offsetX, u.offsetY], p.initialHits = _.map(A => A.eventObject)), v && !_.length && g <= 2 && (s(u, p.interaction), d && d(u)), m && o(_); function x(A) { const E = A.eventObject, w = E.__r3f, b = w == null ? void 0 : w.handlers; if (w != null && w.eventCount) if (m) { if (b.onPointerOver || b.onPointerEnter || b.onPointerOut || b.onPointerLeave) { const T = t0(A), B = p.hovered.get(T); B ? B.stopped && A.stopPropagation() : (p.hovered.set(T, A), b.onPointerOver == null || b.onPointerOver(A), b.onPointerEnter == null || b.onPointerEnter(A)) } b.onPointerMove == null || b.onPointerMove(A) } else { const T = b[l]; T ? (!v || p.initialHits.includes(E)) && (s(u, p.interaction.filter(B => !p.initialHits.includes(B))), T(A)) : v && p.initialHits.includes(E) && s(u, p.interaction.filter(B => !p.initialHits.includes(B))) } } i(_, u, g, x) } } return { handlePointer: a } } const eF = n => !!(n != null && n.render), tF = N.createContext(null), QV = (n, e) => { const t = LV((a, l) => { const c = new X, u = new X, d = new X; function p(g = l().camera, x = u, A = l().size) { const { width: E, height: w, top: b, left: T } = A, B = E / w; x instanceof X ? d.copy(x) : d.set(...x); const R = g.getWorldPosition(c).distanceTo(d); if (JO(g)) return { width: E / g.zoom, height: w / g.zoom, top: b, left: T, factor: 1, distance: R, aspect: B }; { const P = g.fov * Math.PI / 180, U = 2 * Math.tan(P / 2) * R, G = U * (E / w); return { width: G, height: U, top: b, left: T, factor: E / G, distance: R, aspect: B } } } let m; const v = g => a(x => ({ performance: { ...x.performance, current: g } })), y = new Be; return { set: a, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, scene: null, invalidate: (g = 1) => n(l(), g), advance: (g, x) => e(g, x, l()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new Uy, pointer: y, mouse: y, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const g = l(); m && clearTimeout(m), g.performance.current !== g.performance.min && v(g.performance.min), m = setTimeout(() => v(l().performance.max), g.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: g => a(x => ({ ...x, events: { ...x.events, ...g } })), setSize: (g, x, A, E, w) => { const b = l().camera, T = { width: g, height: x, top: E || 0, left: w || 0, updateStyle: A }; a(B => ({ size: T, viewport: { ...B.viewport, ...p(b, u, T) } })) }, setDpr: g => a(x => { const A = QO(g); return { viewport: { ...x.viewport, dpr: A, initialDpr: x.viewport.initialDpr || A } } }), setFrameloop: (g = "always") => { const x = l().clock; x.stop(), x.elapsedTime = 0, g !== "never" && (x.start(), x.elapsedTime = 0), a(() => ({ frameloop: g })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: N.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (g, x, A) => { const E = l().internal; return E.priority = E.priority + (x > 0 ? 1 : 0), E.subscribers.push({ ref: g, priority: x, store: A }), E.subscribers = E.subscribers.sort((w, b) => w.priority - b.priority), () => { const w = l().internal; w != null && w.subscribers && (w.priority = w.priority - (x > 0 ? 1 : 0), w.subscribers = w.subscribers.filter(b => b.ref !== g)) } } } } }), r = t.getState(); let i = r.size, o = r.viewport.dpr, s = r.camera; return t.subscribe(() => { const { camera: a, size: l, viewport: c, gl: u, set: d } = t.getState(); if (l.width !== i.width || l.height !== i.height || c.dpr !== o) { var p; i = l, o = c.dpr, JV(a, l), u.setPixelRatio(c.dpr); const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && u.domElement instanceof HTMLCanvasElement; u.setSize(l.width, l.height, m) } a !== s && (s = a, d(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) } }))) }), t.subscribe(a => n(a)), t }; let n0, ZV = new Set, qV = new Set, eW = new Set; function Mx(n, e) { if (n.size) for (const { callback: t } of n.values()) t(e) } function th(n, e) { switch (n) { case "before": return Mx(ZV, e); case "after": return Mx(qV, e); case "tail": return Mx(eW, e) } } let wx, bx; function Cx(n, e, t) { let r = e.clock.getDelta(); for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), wx = e.internal.subscribers, n0 = 0; n0 < wx.length; n0++)bx = wx[n0], bx.ref.current(bx.store.getState(), r, t); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function tW(n) { let e = !1, t, r, i; function o(l) { r = requestAnimationFrame(o), e = !0, t = 0, th("before", l); for (const u of n.values()) { var c; i = u.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((c = i.gl.xr) != null && c.isPresenting) && (t += Cx(l, i)) } if (th("after", l), t === 0) return th("tail", l), e = !1, cancelAnimationFrame(r) } function s(l, c = 1) { var u; if (!l) return n.forEach(d => s(d.store.getState()), c); (u = l.gl.xr) != null && u.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + c), e || (e = !0, requestAnimationFrame(o))) } function a(l, c = !0, u, d) { if (c && th("before", l), u) Cx(l, u, d); else for (const p of n.values()) Cx(l, p.store.getState()); c && th("after", l) } return { loop: o, invalidate: s, advance: a } } function nF() { const n = N.useContext(tF); if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return n } function Yi(n = t => t, e) { return nF()(n, e) } function rs(n, e = 0) { const t = nF(), r = t.getState().internal.subscribe, i = KO(n); return Jp(() => r(i, e, t), [e, r, t]), null } const CR = new WeakMap; function rF(n, e) { return function (t, ...r) { let i = CR.get(t); return i || (i = new t, CR.set(t, i)), n && n(i), Promise.all(r.map(o => new Promise((s, a) => i.load(o, l => { l.scene && Object.assign(l, WV(l.scene)), s(l) }, e, l => a(new Error(`Could not load ${o}: ${l == null ? void 0 : l.message}`)))))).finally(() => i.dispose == null ? void 0 : i.dispose()) } } function Lo(n, e, t, r) { const i = Array.isArray(e) ? e : [e], o = jO(rF(t, r), [n, ...i], { equal: yn.equ }); return Array.isArray(e) ? o : o[0] } Lo.preload = function (n, e, t) { const r = Array.isArray(e) ? e : [e]; return kV(rF(t), [n, ...r]) }; Lo.clear = function (n, e) { const t = Array.isArray(e) ? e : [e]; return NV([n, ...t]) }; const Xf = new Map, { invalidate: TR, advance: RR } = tW(Xf), { reconciler: bv, applyProps: Gu } = zV(Xf, KV), Hu = { objects: "shallow", strict: !1 }, nW = (n, e) => { const t = typeof n == "function" ? n(e) : n; return eF(t) ? t : new zM({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...n }) }; function rW(n, e) { const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement; if (e) { const { width: r, height: i, top: o, left: s, updateStyle: a = t } = e; return { width: r, height: i, top: o, left: s, updateStyle: a } } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) { const { width: r, height: i, top: o, left: s } = n.parentElement.getBoundingClientRect(); return { width: r, height: i, top: o, left: s, updateStyle: t } } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return { width: n.width, height: n.height, top: 0, left: 0, updateStyle: t }; return { width: 0, height: 0, top: 0, left: 0 } } function iW(n) { const e = Xf.get(n), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store; e && console.warn("R3F.createRoot should only be called once!"); const i = typeof reportError == "function" ? reportError : console.error, o = r || QV(TR, RR), s = t || bv.createContainer(o, pf.ConcurrentRoot, null, !1, null, "", i, null); e || Xf.set(n, { fiber: s, store: o }); let a, l = !1, c; return { configure(u = {}) { let { gl: d, size: p, scene: m, events: v, onCreated: y, shadows: _ = !1, linear: g = !1, flat: x = !1, legacy: A = !1, orthographic: E = !1, frameloop: w = "always", dpr: b = [1, 2], performance: T, raycaster: B, camera: R, onPointerMissed: P } = u, U = o.getState(), G = U.gl; U.gl || U.set({ gl: G = nW(d, n) }); let $ = U.raycaster; $ || U.set({ raycaster: $ = new FO }); const { params: z, ...j } = B || {}; if (yn.equ(j, $, Hu) || Gu($, { ...j }), yn.equ(z, $.params, Hu) || Gu($, { params: { ...$.params, ...z } }), !U.camera || U.camera === c && !yn.equ(c, R, Hu)) { c = R; const k = R instanceof Np, Z = k ? R : E ? new qi(0, 0, 0, 0, .1, 1e3) : new xn(75, 0, .1, 1e3); k || (Z.position.z = 5, R && Gu(Z, R), !U.camera && !(R != null && R.rotation) && Z.lookAt(0, 0, 0)), U.set({ camera: Z }), $.camera = Z } if (!U.scene) { let k; m instanceof Ev ? k = m : (k = new Ev, m && Gu(k, m)), U.set({ scene: Yu(k) }) } if (!U.xr) { var q; const k = (ne, K) => { const ae = o.getState(); ae.frameloop !== "never" && RR(ne, !0, ae, K) }, Z = () => { const ne = o.getState(); ne.gl.xr.enabled = ne.gl.xr.isPresenting, ne.gl.xr.setAnimationLoop(ne.gl.xr.isPresenting ? k : null), ne.gl.xr.isPresenting || TR(ne) }, ee = { connect() { const ne = o.getState().gl; ne.xr.addEventListener("sessionstart", Z), ne.xr.addEventListener("sessionend", Z) }, disconnect() { const ne = o.getState().gl; ne.xr.removeEventListener("sessionstart", Z), ne.xr.removeEventListener("sessionend", Z) } }; typeof ((q = G.xr) == null ? void 0 : q.addEventListener) == "function" && ee.connect(), U.set({ xr: ee }) } if (G.shadowMap) { const k = G.shadowMap.enabled, Z = G.shadowMap.type; if (G.shadowMap.enabled = !!_, yn.boo(_)) G.shadowMap.type = Ch; else if (yn.str(_)) { var se; const ee = { basic: zL, percentage: oy, soft: Ch, variance: Ho }; G.shadowMap.type = (se = ee[_]) != null ? se : Ch } else yn.obj(_) && Object.assign(G.shadowMap, _); (k !== G.shadowMap.enabled || Z !== G.shadowMap.type) && (G.shadowMap.needsUpdate = !0) } const W = XO(); W && ("enabled" in W ? W.enabled = !A : "legacyMode" in W && (W.legacyMode = A)), Gu(G, { outputEncoding: g ? 3e3 : 3001, toneMapping: x ? Cs : EM }), U.legacy !== A && U.set(() => ({ legacy: A })), U.linear !== g && U.set(() => ({ linear: g })), U.flat !== x && U.set(() => ({ flat: x })), d && !yn.fun(d) && !eF(d) && !yn.equ(d, G, Hu) && Gu(G, d), v && !U.events.handlers && U.set({ events: v(o) }); const O = rW(n, p); return yn.equ(O, U.size, Hu) || U.setSize(O.width, O.height, O.updateStyle, O.top, O.left), b && U.viewport.dpr !== QO(b) && U.setDpr(b), U.frameloop !== w && U.setFrameloop(w), U.onPointerMissed || U.set({ onPointerMissed: P }), T && !yn.equ(T, U.performance, Hu) && U.set(k => ({ performance: { ...k.performance, ...T } })), a = y, l = !0, this }, render(u) { return l || this.configure(), bv.updateContainer(N.createElement(oW, { store: o, children: u, onCreated: a, rootElement: n }), s, null, () => { }), o }, unmount() { iF(n) } } } function oW({ store: n, children: e, onCreated: t, rootElement: r }) { return Jp(() => { const i = n.getState(); i.set(o => ({ internal: { ...o.internal, active: !0 } })), t && t(i), n.getState().events.connected || i.events.connect == null || i.events.connect(r) }, []), N.createElement(tF.Provider, { value: n }, e) } function iF(n, e) { const t = Xf.get(n), r = t == null ? void 0 : t.fiber; if (r) { const i = t == null ? void 0 : t.store.getState(); i && (i.internal.active = !1), bv.updateContainer(null, r, null, () => { i && setTimeout(() => { try { var o, s, a, l; i.events.disconnect == null || i.events.disconnect(), (o = i.gl) == null || (s = o.renderLists) == null || s.dispose == null || s.dispose(), (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), jV(i), Xf.delete(n), e && e(n) } catch { } }, 500) }) } } bv.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: N.version }); function Ee() { return Ee = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, Ee.apply(this, arguments) } function HA(n, e, t) { var r, i, o, s, a; e == null && (e = 100); function l() { var u = Date.now() - s; u < e && u >= 0 ? r = setTimeout(l, e - u) : (r = null, t || (a = n.apply(o, i), o = i = null)) } var c = function () { o = this, i = arguments, s = Date.now(); var u = t && !r; return r || (r = setTimeout(l, e)), u && (a = n.apply(o, i), o = i = null), a }; return c.clear = function () { r && (clearTimeout(r), r = null) }, c.flush = function () { r && (a = n.apply(o, i), o = i = null, clearTimeout(r), r = null) }, c } HA.debounce = HA; var sW = HA; const PR = Rp(sW); function aW(n) { let { debounce: e, scroll: t, polyfill: r, offsetSize: i } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n; const o = r || (typeof window > "u" ? class { } : window.ResizeObserver); if (!o) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [s, a] = N.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = N.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: s }), c = e ? typeof e == "number" ? e : e.scroll : null, u = e ? typeof e == "number" ? e : e.resize : null, d = N.useRef(!1); N.useEffect(() => (d.current = !0, () => void (d.current = !1))); const [p, m, v] = N.useMemo(() => { const x = () => { if (!l.current.element) return; const { left: A, top: E, width: w, height: b, bottom: T, right: B, x: R, y: P } = l.current.element.getBoundingClientRect(), U = { left: A, top: E, width: w, height: b, bottom: T, right: B, x: R, y: P }; l.current.element instanceof HTMLElement && i && (U.height = l.current.element.offsetHeight, U.width = l.current.element.offsetWidth), Object.freeze(U), d.current && !fW(l.current.lastBounds, U) && a(l.current.lastBounds = U) }; return [x, u ? PR(x, u) : x, c ? PR(x, c) : x] }, [a, i, c, u]); function y() { l.current.scrollContainers && (l.current.scrollContainers.forEach(x => x.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null) } function _() { l.current.element && (l.current.resizeObserver = new o(v), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(x => x.addEventListener("scroll", v, { capture: !0, passive: !0 }))) } const g = x => { !x || x === l.current.element || (y(), l.current.element = x, l.current.scrollContainers = oF(x), _()) }; return cW(v, !!t), lW(m), N.useEffect(() => { y(), _() }, [t, v, m]), N.useEffect(() => y, []), [g, s, p] } function lW(n) { N.useEffect(() => { const e = n; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [n]) } function cW(n, e) { N.useEffect(() => { if (e) { const t = n; return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0) } }, [n, e]) } function oF(n) { const e = []; if (!n || n === document.body) return e; const { overflow: t, overflowX: r, overflowY: i } = window.getComputedStyle(n); return [t, r, i].some(o => o === "auto" || o === "scroll") && e.push(n), [...e, ...oF(n.parentElement)] } const uW = ["x", "y", "top", "bottom", "left", "right", "width", "height"], fW = (n, e) => uW.every(t => n[t] === e[t]); var dW = Object.defineProperty, hW = Object.defineProperties, pW = Object.getOwnPropertyDescriptors, BR = Object.getOwnPropertySymbols, mW = Object.prototype.hasOwnProperty, gW = Object.prototype.propertyIsEnumerable, IR = (n, e, t) => e in n ? dW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, LR = (n, e) => { for (var t in e || (e = {})) mW.call(e, t) && IR(n, t, e[t]); if (BR) for (var t of BR(e)) gW.call(e, t) && IR(n, t, e[t]); return n }, vW = (n, e) => hW(n, pW(e)); function sF(n, e, t) { if (!n) return; if (t(n) === !0) return n; let r = e ? n.return : n.child; for (; r;) { const i = sF(r, e, t); if (i) return i; r = e ? null : r.sibling } } function aF(n) { try { return Object.defineProperties(n, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return n } } const dw = aF(N.createContext(null)); class lF extends N.Component { render() { return N.createElement(dw.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: DR, ReactCurrentDispatcher: OR } = N.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; function yW() { const n = N.useContext(dw); if (n === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const e = N.useId(); return N.useMemo(() => { for (const r of [DR == null ? void 0 : DR.current, n, n == null ? void 0 : n.alternate]) { if (!r) continue; const i = sF(r, !1, o => { let s = o.memoizedState; for (; s;) { if (s.memoizedState === e) return !0; s = s.next } }); if (i) return i } }, [n, e]) } function _W() { var n, e; const t = yW(), [r] = N.useState(() => new Map); r.clear(); let i = t; for (; i;) { const o = (n = i.type) == null ? void 0 : n._context; o && o !== dw && !r.has(o) && r.set(o, (e = OR == null ? void 0 : OR.current) == null ? void 0 : e.readContext(aF(o))), i = i.return } return r } function xW() { const n = _W(); return N.useMemo(() => Array.from(n.keys()).reduce((e, t) => r => N.createElement(e, null, N.createElement(t.Provider, vW(LR({}, r), { value: n.get(t) }))), e => N.createElement(lF, LR({}, e))), [n]) } const Tx = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function SW(n) { const { handlePointer: e } = $V(n); return { priority: 1, enabled: !0, compute(t, r, i) { r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera) }, connected: void 0, handlers: Object.keys(Tx).reduce((t, r) => ({ ...t, [r]: e(r) }), {}), update: () => { var t; const { events: r, internal: i } = n.getState(); (t = i.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current) }, connect: t => { var r; const { set: i, events: o } = n.getState(); o.disconnect == null || o.disconnect(), i(s => ({ events: { ...s.events, connected: t } })), Object.entries((r = o.handlers) != null ? r : []).forEach(([s, a]) => { const [l, c] = Tx[s]; t.addEventListener(l, a, { passive: c }) }) }, disconnect: () => { const { set: t, events: r } = n.getState(); if (r.connected) { var i; Object.entries((i = r.handlers) != null ? i : []).forEach(([o, s]) => { if (r && r.connected instanceof HTMLElement) { const [a] = Tx[o]; r.connected.removeEventListener(a, s) } }), t(o => ({ events: { ...o.events, connected: void 0 } })) } } } } const AW = N.forwardRef(function ({ children: e, fallback: t, resize: r, style: i, gl: o, events: s = SW, eventSource: a, eventPrefix: l, shadows: c, linear: u, flat: d, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: _, raycaster: g, camera: x, scene: A, onPointerMissed: E, onCreated: w, ...b }, T) { N.useMemo(() => ky(PV), []); const B = xW(), [R, P] = aW({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }), U = N.useRef(null), G = N.useRef(null); N.useImperativeHandle(T, () => U.current); const $ = KO(E), [z, j] = N.useState(!1), [q, se] = N.useState(!1); if (z) throw z; if (q) throw q; const W = N.useRef(null); Jp(() => { const J = U.current; P.width > 0 && P.height > 0 && J && (W.current || (W.current = iW(J)), W.current.configure({ gl: o, events: s, shadows: c, linear: u, flat: d, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: _, raycaster: g, camera: x, scene: A, size: P, onPointerMissed: (...O) => $.current == null ? void 0 : $.current(...O), onCreated: O => { O.events.connect == null || O.events.connect(a ? GV(a) ? a.current : a : G.current), l && O.setEvents({ compute: (k, Z) => { const ee = k[l + "X"], ne = k[l + "Y"]; Z.pointer.set(ee / Z.size.width * 2 - 1, -(ne / Z.size.height) * 2 + 1), Z.raycaster.setFromCamera(Z.pointer, Z.camera) } }), w == null || w(O) } }), W.current.render(N.createElement(B, null, N.createElement(YO, { set: se }, N.createElement(N.Suspense, { fallback: N.createElement(HV, { set: j }) }, e))))) }), N.useEffect(() => { const J = U.current; if (J) return () => iF(J) }, []); const V = a ? "none" : "auto"; return N.createElement("div", Ee({ ref: G, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: V, ...i } }, b), N.createElement("div", { ref: R, style: { width: "100%", height: "100%" } }, N.createElement("canvas", { ref: U, style: { display: "block" } }, t))) }), EW = N.forwardRef(function (e, t) { return N.createElement(lF, null, N.createElement(AW, Ee({}, e, { ref: t }))) }), Kp = new X, hw = new X, MW = new X; function wW(n, e, t) { const r = Kp.setFromMatrixPosition(n.matrixWorld); r.project(e); const i = t.width / 2, o = t.height / 2; return [r.x * i + i, -(r.y * o) + o] } function bW(n, e) { const t = Kp.setFromMatrixPosition(n.matrixWorld), r = hw.setFromMatrixPosition(e.matrixWorld), i = t.sub(r), o = e.getWorldDirection(MW); return i.angleTo(o) > Math.PI / 2 } function CW(n, e, t, r) { const i = Kp.setFromMatrixPosition(n.matrixWorld), o = i.clone(); o.project(e), t.setFromCamera(o, e); const s = t.intersectObjects(r, !0); if (s.length) { const a = s[0].distance; return i.distanceTo(t.ray.origin) < a } return !0 } function TW(n, e) { if (e instanceof qi) return e.zoom; if (e instanceof xn) { const t = Kp.setFromMatrixPosition(n.matrixWorld), r = hw.setFromMatrixPosition(e.matrixWorld), i = e.fov * Math.PI / 180, o = t.distanceTo(r); return 1 / (2 * Math.tan(i / 2) * o) } else return 1 } function RW(n, e, t) { if (e instanceof xn || e instanceof qi) { const r = Kp.setFromMatrixPosition(n.matrixWorld), i = hw.setFromMatrixPosition(e.matrixWorld), o = r.distanceTo(i), s = (t[1] - t[0]) / (e.far - e.near), a = t[1] - s * e.far; return Math.round(s * o + a) } } const VA = n => Math.abs(n) < 1e-10 ? 0 : n; function cF(n, e, t = "") { let r = "matrix3d("; for (let i = 0; i !== 16; i++)r += VA(e[i] * n.elements[i]) + (i !== 15 ? "," : ")"); return t + r } const PW = (n => e => cF(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), BW = (n => (e, t) => cF(e, n(t), "translate(-50%,-50%)"))(n => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]); function IW(n) { return n && typeof n == "object" && "current" in n } const LW = N.forwardRef(({ children: n, eps: e = .001, style: t, className: r, prepend: i, center: o, fullscreen: s, portal: a, distanceFactor: l, sprite: c = !1, transform: u = !1, occlude: d, onOcclude: p, castShadow: m, receiveShadow: v, material: y, geometry: _, zIndexRange: g = [16777271, 0], calculatePosition: x = wW, as: A = "div", wrapperClass: E, pointerEvents: w = "auto", ...b }, T) => {
	const { gl: B, camera: R, scene: P, size: U, raycaster: G, events: $, viewport: z } = Yi(), [j] = N.useState(() => document.createElement(A)), q = N.useRef(), se = N.useRef(null), W = N.useRef(0), V = N.useRef([0, 0]), J = N.useRef(null), O = N.useRef(null), k = (a == null ? void 0 : a.current) || $.connected || B.domElement.parentNode, Z = N.useRef(null), ee = N.useRef(!1), ne = N.useMemo(() => d && d !== "blending" || Array.isArray(d) && d.length && IW(d[0]), [d]); N.useLayoutEffect(() => { const Ce = B.domElement; d && d === "blending" ? (Ce.style.zIndex = `${Math.floor(g[0] / 2)}`, Ce.style.position = "absolute", Ce.style.pointerEvents = "none") : (Ce.style.zIndex = null, Ce.style.position = null, Ce.style.pointerEvents = null) }, [d]), N.useLayoutEffect(() => { if (se.current) { const Ce = q.current = UL(j); if (P.updateMatrixWorld(), u) j.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"; else { const le = x(se.current, R, U); j.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${le[0]}px,${le[1]}px,0);transform-origin:0 0;` } return k && (i ? k.prepend(j) : k.appendChild(j)), () => { k && k.removeChild(j), Ce.unmount() } } }, [k, u]), N.useLayoutEffect(() => { E && (j.className = E) }, [E]); const K = N.useMemo(() => u ? { position: "absolute", top: 0, left: 0, width: U.width, height: U.height, transformStyle: "preserve-3d", pointerEvents: "none" } : { position: "absolute", transform: o ? "translate3d(-50%,-50%,0)" : "none", ...s && { top: -U.height / 2, left: -U.width / 2, width: U.width, height: U.height }, ...t }, [t, o, s, U, u]), ae = N.useMemo(() => ({ position: "absolute", pointerEvents: w }), [w]); N.useLayoutEffect(() => { if (ee.current = !1, u) { var Ce; (Ce = q.current) == null || Ce.render(N.createElement("div", { ref: J, style: K }, N.createElement("div", { ref: O, style: ae }, N.createElement("div", { ref: T, className: r, style: t, children: n })))) } else { var le; (le = q.current) == null || le.render(N.createElement("div", { ref: T, style: K, className: r, children: n })) } }); const ie = N.useRef(!0); rs(Ce => { if (se.current) { R.updateMatrixWorld(), se.current.updateWorldMatrix(!0, !1); const le = u ? V.current : x(se.current, R, U); if (u || Math.abs(W.current - R.zoom) > e || Math.abs(V.current[0] - le[0]) > e || Math.abs(V.current[1] - le[1]) > e) { const F = bW(se.current, R); let me = !1; ne && (Array.isArray(d) ? me = d.map(Re => Re.current) : d !== "blending" && (me = [P])); const he = ie.current; if (me) { const Re = CW(se.current, R, G, me); ie.current = Re && !F } else ie.current = !F; he !== ie.current && (p ? p(!ie.current) : j.style.display = ie.current ? "block" : "none"); const ce = Math.floor(g[0] / 2), fe = d ? ne ? [g[0], ce] : [ce - 1, 0] : g; if (j.style.zIndex = `${RW(se.current, R, fe)}`, u) { const [Re, de] = [U.width / 2, U.height / 2], Ie = R.projectionMatrix.elements[5] * de, { isOrthographicCamera: we, top: ge, left: Ve, bottom: H, right: L } = R, oe = PW(R.matrixWorldInverse), Pe = we ? `scale(${Ie})translate(${VA(-(L + Ve) / 2)}px,${VA((ge + H) / 2)}px)` : `translateZ(${Ie}px)`; let Ae = se.current.matrixWorld; c && (Ae = R.matrixWorldInverse.clone().transpose().copyPosition(Ae).scale(se.current.scale), Ae.elements[3] = Ae.elements[7] = Ae.elements[11] = 0, Ae.elements[15] = 1), j.style.width = U.width + "px", j.style.height = U.height + "px", j.style.perspective = we ? "" : `${Ie}px`, J.current && O.current && (J.current.style.transform = `${Pe}${oe}translate(${Re}px,${de}px)`, O.current.style.transform = BW(Ae, 1 / ((l || 10) / 400))) } else { const Re = l === void 0 ? 1 : TW(se.current, R) * l; j.style.transform = `translate3d(${le[0]}px,${le[1]}px,0) scale(${Re})` } V.current = le, W.current = R.zoom } } if (!ne && Z.current && !ee.current) if (u) { if (J.current) { const le = J.current.children[0]; if (le != null && le.clientWidth && le != null && le.clientHeight) { const { isOrthographicCamera: F } = R; if (F || _) b.scale && (Array.isArray(b.scale) ? b.scale instanceof X ? Z.current.scale.copy(b.scale.clone().divideScalar(1)) : Z.current.scale.set(1 / b.scale[0], 1 / b.scale[1], 1 / b.scale[2]) : Z.current.scale.setScalar(1 / b.scale)); else { const me = (l || 10) / 400, he = le.clientWidth * me, ce = le.clientHeight * me; Z.current.scale.set(he, ce, 1) } ee.current = !0 } } } else { const le = j.children[0]; if (le != null && le.clientWidth && le != null && le.clientHeight) { const F = 1 / z.factor, me = le.clientWidth * F, he = le.clientHeight * F; Z.current.scale.set(me, he, 1), ee.current = !0 } Z.current.lookAt(Ce.camera.position) } }); const Se = N.useMemo(() => ({
		vertexShader: u ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `, fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}), [u]); return N.createElement("group", Ee({}, b, { ref: se }), d && !ne && N.createElement("mesh", { castShadow: m, receiveShadow: v, ref: Z }, _ || N.createElement("planeGeometry", null), y || N.createElement("shaderMaterial", { side: Ti, vertexShader: Se.vertexShader, fragmentShader: Se.fragmentShader })))
}); function DW(n) { return function (e) { n.forEach(function (t) { typeof t == "function" ? t(e) : t != null && (t.current = e) }) } } function FR(n, e) { if (e === MD) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n; if (e === xv || e === BM) { let t = n.getIndex(); if (t === null) { const s = [], a = n.getAttribute("position"); if (a !== void 0) { for (let l = 0; l < a.count; l++)s.push(l); n.setIndex(s), t = n.getIndex() } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n } const r = t.count - 2, i = []; if (t) if (e === xv) for (let s = 1; s <= r; s++)i.push(t.getX(0)), i.push(t.getX(s)), i.push(t.getX(s + 1)); else for (let s = 0; s < r; s++)s % 2 === 0 ? (i.push(t.getX(s)), i.push(t.getX(s + 1)), i.push(t.getX(s + 2))) : (i.push(t.getX(s + 2)), i.push(t.getX(s + 1)), i.push(t.getX(s))); i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const o = n.clone(); return o.setIndex(i), o.clearGroups(), o } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n } const OW = parseInt(Qc.replace(/\D+/g, "")); var FW = Object.defineProperty, UW = (n, e, t) => e in n ? FW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, St = (n, e, t) => (UW(n, typeof e != "symbol" ? e + "" : e, t), t); const r0 = new Zc, UR = new oa, kW = Math.cos(70 * (Math.PI / 180)), kR = (n, e) => (n % e + e) % e; let NW = class extends Us { constructor(e, t) { super(), St(this, "object"), St(this, "domElement"), St(this, "enabled", !0), St(this, "target", new X), St(this, "minDistance", 0), St(this, "maxDistance", 1 / 0), St(this, "minZoom", 0), St(this, "maxZoom", 1 / 0), St(this, "minPolarAngle", 0), St(this, "maxPolarAngle", Math.PI), St(this, "minAzimuthAngle", -1 / 0), St(this, "maxAzimuthAngle", 1 / 0), St(this, "enableDamping", !1), St(this, "dampingFactor", .05), St(this, "enableZoom", !0), St(this, "zoomSpeed", 1), St(this, "enableRotate", !0), St(this, "rotateSpeed", 1), St(this, "enablePan", !0), St(this, "panSpeed", 1), St(this, "screenSpacePanning", !0), St(this, "keyPanSpeed", 7), St(this, "zoomToCursor", !1), St(this, "autoRotate", !1), St(this, "autoRotateSpeed", 2), St(this, "reverseOrbit", !1), St(this, "reverseHorizontalOrbit", !1), St(this, "reverseVerticalOrbit", !1), St(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), St(this, "mouseButtons", { LEFT: cc.ROTATE, MIDDLE: cc.DOLLY, RIGHT: cc.PAN }), St(this, "touches", { ONE: uc.ROTATE, TWO: uc.DOLLY_PAN }), St(this, "target0"), St(this, "position0"), St(this, "zoom0"), St(this, "_domElementKeyEvents", null), St(this, "getPolarAngle"), St(this, "getAzimuthalAngle"), St(this, "setPolarAngle"), St(this, "setAzimuthalAngle"), St(this, "getDistance"), St(this, "listenToKeyEvents"), St(this, "stopListenToKeyEvents"), St(this, "saveState"), St(this, "reset"), St(this, "update"), St(this, "connect"), St(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = re => { let _e = kR(re, 2 * Math.PI), Ne = u.phi; Ne < 0 && (Ne += 2 * Math.PI), _e < 0 && (_e += 2 * Math.PI); let Y = Math.abs(_e - Ne); 2 * Math.PI - Y < Y && (_e < Ne ? _e += 2 * Math.PI : Ne += 2 * Math.PI), d.phi = _e - Ne, r.update() }, this.setAzimuthalAngle = re => { let _e = kR(re, 2 * Math.PI), Ne = u.theta; Ne < 0 && (Ne += 2 * Math.PI), _e < 0 && (_e += 2 * Math.PI); let Y = Math.abs(_e - Ne); 2 * Math.PI - Y < Y && (_e < Ne ? _e += 2 * Math.PI : Ne += 2 * Math.PI), d.theta = _e - Ne, r.update() }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = re => { re.addEventListener("keydown", ye), this._domElementKeyEvents = re }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", ye), this._domElementKeyEvents = null }, this.saveState = () => { r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom }, this.reset = () => { r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(i), r.update(), l = a.NONE }, this.update = (() => { const re = new X, _e = new X(0, 1, 0), Ne = new Sr().setFromUnitVectors(e.up, _e), Y = Ne.clone().invert(), Ue = new X, Ge = new Sr, Ke = 2 * Math.PI; return function () { const ze = r.object.position; Ne.setFromUnitVectors(e.up, _e), Y.copy(Ne).invert(), re.copy(ze).sub(r.target), re.applyQuaternion(Ne), u.setFromVector3(re), r.autoRotate && l === a.NONE && z(G()), r.enableDamping ? (u.theta += d.theta * r.dampingFactor, u.phi += d.phi * r.dampingFactor) : (u.theta += d.theta, u.phi += d.phi); let Ze = r.minAzimuthAngle, it = r.maxAzimuthAngle; isFinite(Ze) && isFinite(it) && (Ze < -Math.PI ? Ze += Ke : Ze > Math.PI && (Ze -= Ke), it < -Math.PI ? it += Ke : it > Math.PI && (it -= Ke), Ze <= it ? u.theta = Math.max(Ze, Math.min(it, u.theta)) : u.theta = u.theta > (Ze + it) / 2 ? Math.max(Ze, u.theta) : Math.min(it, u.theta)), u.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, u.phi)), u.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(m, r.dampingFactor) : r.target.add(m), r.zoomToCursor && R || r.object.isOrthographicCamera ? u.radius = k(u.radius) : u.radius = k(u.radius * p), re.setFromSpherical(u), re.applyQuaternion(Y), ze.copy(r.target).add(re), r.object.lookAt(r.target), r.enableDamping === !0 ? (d.theta *= 1 - r.dampingFactor, d.phi *= 1 - r.dampingFactor, m.multiplyScalar(1 - r.dampingFactor)) : (d.set(0, 0, 0), m.set(0, 0, 0)); let yt = !1; if (r.zoomToCursor && R) { let Ct = null; if (r.object instanceof xn && r.object.isPerspectiveCamera) { const At = re.length(); Ct = k(At * p); const xt = At - Ct; r.object.position.addScaledVector(T, xt), r.object.updateMatrixWorld() } else if (r.object.isOrthographicCamera) { const At = new X(B.x, B.y, 0); At.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / p)), r.object.updateProjectionMatrix(), yt = !0; const xt = new X(B.x, B.y, 0); xt.unproject(r.object), r.object.position.sub(xt).add(At), r.object.updateMatrixWorld(), Ct = re.length() } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1; Ct !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar(Ct).add(r.object.position) : (r0.origin.copy(r.object.position), r0.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(r0.direction)) < kW ? e.lookAt(r.target) : (UR.setFromNormalAndCoplanarPoint(r.object.up, r.target), r0.intersectPlane(UR, r.target)))) } else r.object instanceof qi && r.object.isOrthographicCamera && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / p)), r.object.updateProjectionMatrix(), yt = !0); return p = 1, R = !1, yt || Ue.distanceToSquared(r.object.position) > c || 8 * (1 - Ge.dot(r.object.quaternion)) > c ? (r.dispatchEvent(i), Ue.copy(r.object.position), Ge.copy(r.object.quaternion), yt = !1, !0) : !1 } })(), this.connect = re => { re === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), r.domElement = re, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", He), r.domElement.addEventListener("pointerdown", ge), r.domElement.addEventListener("pointercancel", L), r.domElement.addEventListener("wheel", Ae) }, this.dispose = () => { var re, _e, Ne, Y, Ue, Ge; (re = r.domElement) == null || re.removeEventListener("contextmenu", He), (_e = r.domElement) == null || _e.removeEventListener("pointerdown", ge), (Ne = r.domElement) == null || Ne.removeEventListener("pointercancel", L), (Y = r.domElement) == null || Y.removeEventListener("wheel", Ae), (Ue = r.domElement) == null || Ue.ownerDocument.removeEventListener("pointermove", Ve), (Ge = r.domElement) == null || Ge.ownerDocument.removeEventListener("pointerup", H), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", ye) }; const r = this, i = { type: "change" }, o = { type: "start" }, s = { type: "end" }, a = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let l = a.NONE; const c = 1e-6, u = new kA, d = new kA; let p = 1; const m = new X, v = new Be, y = new Be, _ = new Be, g = new Be, x = new Be, A = new Be, E = new Be, w = new Be, b = new Be, T = new X, B = new Be; let R = !1; const P = [], U = {}; function G() { return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed } function $() { return Math.pow(.95, r.zoomSpeed) } function z(re) { r.reverseOrbit || r.reverseHorizontalOrbit ? d.theta += re : d.theta -= re } function j(re) { r.reverseOrbit || r.reverseVerticalOrbit ? d.phi += re : d.phi -= re } const q = (() => { const re = new X; return function (Ne, Y) { re.setFromMatrixColumn(Y, 0), re.multiplyScalar(-Ne), m.add(re) } })(), se = (() => { const re = new X; return function (Ne, Y) { r.screenSpacePanning === !0 ? re.setFromMatrixColumn(Y, 1) : (re.setFromMatrixColumn(Y, 0), re.crossVectors(r.object.up, re)), re.multiplyScalar(Ne), m.add(re) } })(), W = (() => { const re = new X; return function (Ne, Y) { const Ue = r.domElement; if (Ue && r.object instanceof xn && r.object.isPerspectiveCamera) { const Ge = r.object.position; re.copy(Ge).sub(r.target); let Ke = re.length(); Ke *= Math.tan(r.object.fov / 2 * Math.PI / 180), q(2 * Ne * Ke / Ue.clientHeight, r.object.matrix), se(2 * Y * Ke / Ue.clientHeight, r.object.matrix) } else Ue && r.object instanceof qi && r.object.isOrthographicCamera ? (q(Ne * (r.object.right - r.object.left) / r.object.zoom / Ue.clientWidth, r.object.matrix), se(Y * (r.object.top - r.object.bottom) / r.object.zoom / Ue.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1) } })(); function V(re) { r.object instanceof xn && r.object.isPerspectiveCamera || r.object instanceof qi && r.object.isOrthographicCamera ? p /= re : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function J(re) { r.object instanceof xn && r.object.isPerspectiveCamera || r.object instanceof qi && r.object.isOrthographicCamera ? p *= re : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function O(re) { if (!r.zoomToCursor || !r.domElement) return; R = !0; const _e = r.domElement.getBoundingClientRect(), Ne = re.clientX - _e.left, Y = re.clientY - _e.top, Ue = _e.width, Ge = _e.height; B.x = Ne / Ue * 2 - 1, B.y = -(Y / Ge) * 2 + 1, T.set(B.x, B.y, 1).unproject(r.object).sub(r.object.position).normalize() } function k(re) { return Math.max(r.minDistance, Math.min(r.maxDistance, re)) } function Z(re) { v.set(re.clientX, re.clientY) } function ee(re) { O(re), E.set(re.clientX, re.clientY) } function ne(re) { g.set(re.clientX, re.clientY) } function K(re) { y.set(re.clientX, re.clientY), _.subVectors(y, v).multiplyScalar(r.rotateSpeed); const _e = r.domElement; _e && (z(2 * Math.PI * _.x / _e.clientHeight), j(2 * Math.PI * _.y / _e.clientHeight)), v.copy(y), r.update() } function ae(re) { w.set(re.clientX, re.clientY), b.subVectors(w, E), b.y > 0 ? V($()) : b.y < 0 && J($()), E.copy(w), r.update() } function ie(re) { x.set(re.clientX, re.clientY), A.subVectors(x, g).multiplyScalar(r.panSpeed), W(A.x, A.y), g.copy(x), r.update() } function Se(re) { O(re), re.deltaY < 0 ? J($()) : re.deltaY > 0 && V($()), r.update() } function Ce(re) { let _e = !1; switch (re.code) { case r.keys.UP: W(0, r.keyPanSpeed), _e = !0; break; case r.keys.BOTTOM: W(0, -r.keyPanSpeed), _e = !0; break; case r.keys.LEFT: W(r.keyPanSpeed, 0), _e = !0; break; case r.keys.RIGHT: W(-r.keyPanSpeed, 0), _e = !0; break }_e && (re.preventDefault(), r.update()) } function le() { if (P.length == 1) v.set(P[0].pageX, P[0].pageY); else { const re = .5 * (P[0].pageX + P[1].pageX), _e = .5 * (P[0].pageY + P[1].pageY); v.set(re, _e) } } function F() { if (P.length == 1) g.set(P[0].pageX, P[0].pageY); else { const re = .5 * (P[0].pageX + P[1].pageX), _e = .5 * (P[0].pageY + P[1].pageY); g.set(re, _e) } } function me() { const re = P[0].pageX - P[1].pageX, _e = P[0].pageY - P[1].pageY, Ne = Math.sqrt(re * re + _e * _e); E.set(0, Ne) } function he() { r.enableZoom && me(), r.enablePan && F() } function ce() { r.enableZoom && me(), r.enableRotate && le() } function fe(re) { if (P.length == 1) y.set(re.pageX, re.pageY); else { const Ne = Je(re), Y = .5 * (re.pageX + Ne.x), Ue = .5 * (re.pageY + Ne.y); y.set(Y, Ue) } _.subVectors(y, v).multiplyScalar(r.rotateSpeed); const _e = r.domElement; _e && (z(2 * Math.PI * _.x / _e.clientHeight), j(2 * Math.PI * _.y / _e.clientHeight)), v.copy(y) } function Re(re) { if (P.length == 1) x.set(re.pageX, re.pageY); else { const _e = Je(re), Ne = .5 * (re.pageX + _e.x), Y = .5 * (re.pageY + _e.y); x.set(Ne, Y) } A.subVectors(x, g).multiplyScalar(r.panSpeed), W(A.x, A.y), g.copy(x) } function de(re) { const _e = Je(re), Ne = re.pageX - _e.x, Y = re.pageY - _e.y, Ue = Math.sqrt(Ne * Ne + Y * Y); w.set(0, Ue), b.set(0, Math.pow(w.y / E.y, r.zoomSpeed)), V(b.y), E.copy(w) } function Ie(re) { r.enableZoom && de(re), r.enablePan && Re(re) } function we(re) { r.enableZoom && de(re), r.enableRotate && fe(re) } function ge(re) { var _e, Ne; r.enabled !== !1 && (P.length === 0 && ((_e = r.domElement) == null || _e.ownerDocument.addEventListener("pointermove", Ve), (Ne = r.domElement) == null || Ne.ownerDocument.addEventListener("pointerup", H)), je(re), re.pointerType === "touch" ? be(re) : oe(re)) } function Ve(re) { r.enabled !== !1 && (re.pointerType === "touch" ? ke(re) : Pe(re)) } function H(re) { var _e, Ne, Y; nt(re), P.length === 0 && ((_e = r.domElement) == null || _e.releasePointerCapture(re.pointerId), (Ne = r.domElement) == null || Ne.ownerDocument.removeEventListener("pointermove", Ve), (Y = r.domElement) == null || Y.ownerDocument.removeEventListener("pointerup", H)), r.dispatchEvent(s), l = a.NONE } function L(re) { nt(re) } function oe(re) { let _e; switch (re.button) { case 0: _e = r.mouseButtons.LEFT; break; case 1: _e = r.mouseButtons.MIDDLE; break; case 2: _e = r.mouseButtons.RIGHT; break; default: _e = -1 }switch (_e) { case cc.DOLLY: if (r.enableZoom === !1) return; ee(re), l = a.DOLLY; break; case cc.ROTATE: if (re.ctrlKey || re.metaKey || re.shiftKey) { if (r.enablePan === !1) return; ne(re), l = a.PAN } else { if (r.enableRotate === !1) return; Z(re), l = a.ROTATE } break; case cc.PAN: if (re.ctrlKey || re.metaKey || re.shiftKey) { if (r.enableRotate === !1) return; Z(re), l = a.ROTATE } else { if (r.enablePan === !1) return; ne(re), l = a.PAN } break; default: l = a.NONE }l !== a.NONE && r.dispatchEvent(o) } function Pe(re) { if (r.enabled !== !1) switch (l) { case a.ROTATE: if (r.enableRotate === !1) return; K(re); break; case a.DOLLY: if (r.enableZoom === !1) return; ae(re); break; case a.PAN: if (r.enablePan === !1) return; ie(re); break } } function Ae(re) { r.enabled === !1 || r.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (re.preventDefault(), r.dispatchEvent(o), Se(re), r.dispatchEvent(s)) } function ye(re) { r.enabled === !1 || r.enablePan === !1 || Ce(re) } function be(re) { switch (Te(re), P.length) { case 1: switch (r.touches.ONE) { case uc.ROTATE: if (r.enableRotate === !1) return; le(), l = a.TOUCH_ROTATE; break; case uc.PAN: if (r.enablePan === !1) return; F(), l = a.TOUCH_PAN; break; default: l = a.NONE }break; case 2: switch (r.touches.TWO) { case uc.DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; he(), l = a.TOUCH_DOLLY_PAN; break; case uc.DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; ce(), l = a.TOUCH_DOLLY_ROTATE; break; default: l = a.NONE }break; default: l = a.NONE }l !== a.NONE && r.dispatchEvent(o) } function ke(re) { switch (Te(re), l) { case a.TOUCH_ROTATE: if (r.enableRotate === !1) return; fe(re), r.update(); break; case a.TOUCH_PAN: if (r.enablePan === !1) return; Re(re), r.update(); break; case a.TOUCH_DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; Ie(re), r.update(); break; case a.TOUCH_DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; we(re), r.update(); break; default: l = a.NONE } } function He(re) { r.enabled !== !1 && re.preventDefault() } function je(re) { P.push(re) } function nt(re) { delete U[re.pointerId]; for (let _e = 0; _e < P.length; _e++)if (P[_e].pointerId == re.pointerId) { P.splice(_e, 1); return } } function Te(re) { let _e = U[re.pointerId]; _e === void 0 && (_e = new Be, U[re.pointerId] = _e), _e.set(re.pageX, re.pageY) } function Je(re) { const _e = re.pointerId === P[0].pointerId ? P[1] : P[0]; return U[_e.pointerId] } t !== void 0 && this.connect(t), this.update() } }; var zW = Object.defineProperty, GW = (n, e, t) => e in n ? zW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, wc = (n, e, t) => (GW(n, typeof e != "symbol" ? e + "" : e, t), t); class Yp { constructor() { wc(this, "enabled", !0), wc(this, "needsSwap", !0), wc(this, "clear", !1), wc(this, "renderToScreen", !1) } setSize(e, t) { } render(e, t, r, i, o) { console.error("THREE.Pass: .render() must be implemented in derived pass.") } } class uF { constructor(e) { wc(this, "camera", new qi(-1, 1, 1, -1, 0, 1)), wc(this, "geometry", new ba(2, 2)), wc(this, "mesh"), this.mesh = new In(this.geometry, e) } get material() { return this.mesh.material } set material(e) { this.mesh.material = e } dispose() { this.mesh.geometry.dispose() } render(e) { e.render(this.mesh, this.camera) } } var HW = Object.defineProperty, VW = (n, e, t) => e in n ? HW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, i0 = (n, e, t) => (VW(n, typeof e != "symbol" ? e + "" : e, t), t); class WA extends Yp { constructor(e, t = "tDiffuse") { super(), i0(this, "textureID"), i0(this, "uniforms"), i0(this, "material"), i0(this, "fsQuad"), this.textureID = t, e instanceof _r ? (this.uniforms = e.uniforms, this.material = e) : (this.uniforms = _a.clone(e.uniforms), this.material = new _r({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new uF(this.material) } render(e, t, r) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e)) } } const jA = {
	uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	gl_FragColor = opacity * texel;", "}"].join(`
`)
}, WW = {
	shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new qe(0) }, defaultOpacity: { value: 0 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "	gl_FragColor = mix( outputColor, texel, alpha );", "}"].join(`
`)
}; var jW = Object.defineProperty, XW = (n, e, t) => e in n ? jW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, fF = (n, e, t) => (XW(n, typeof e != "symbol" ? e + "" : e, t), t); const XA = class extends Yp {
	constructor(n, e, t, r) { super(), this.strength = e !== void 0 ? e : 1, this.radius = t, this.threshold = r, this.resolution = n !== void 0 ? new Be(n.x, n.y) : new Be(256, 256), this.clearColor = new qe(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; let i = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2); this.renderTargetBright = new Qr(i, o, { type: Ts }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1; for (let u = 0; u < this.nMips; u++) { const d = new Qr(i, o, { type: Ts }); d.texture.name = "UnrealBloomPass.h" + u, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d); const p = new Qr(i, o, { type: Ts }); p.texture.name = "UnrealBloomPass.v" + u, p.texture.generateMipmaps = !1, this.renderTargetsVertical.push(p), i = Math.round(i / 2), o = Math.round(o / 2) } const s = WW; this.highPassUniforms = _a.clone(s.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new _r({ uniforms: this.highPassUniforms, vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, defines: {} }), this.separableBlurMaterials = []; const a = [3, 5, 7, 9, 11]; i = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2); for (let u = 0; u < this.nMips; u++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(a[u])), this.separableBlurMaterials[u].uniforms.texSize.value = new Be(i, o), i = Math.round(i / 2), o = Math.round(o / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0; const l = [1, .8, .6, .4, .2]; this.compositeMaterial.uniforms.bloomFactors.value = l, this.bloomTintColors = [new X(1, 1, 1), new X(1, 1, 1), new X(1, 1, 1), new X(1, 1, 1), new X(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors; const c = jA; this.copyUniforms = _a.clone(c.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new _r({ uniforms: this.copyUniforms, vertexShader: c.vertexShader, fragmentShader: c.fragmentShader, blending: yv, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new qe, this.oldClearAlpha = 1, this.basic = new hi, this.fsQuad = new uF(null) } dispose() { for (let n = 0; n < this.renderTargetsHorizontal.length; n++)this.renderTargetsHorizontal[n].dispose(); for (let n = 0; n < this.renderTargetsVertical.length; n++)this.renderTargetsVertical[n].dispose(); this.renderTargetBright.dispose(); for (let n = 0; n < this.separableBlurMaterials.length; n++)this.separableBlurMaterials[n].dispose(); this.compositeMaterial.dispose(), this.materialCopy.dispose(), this.basic.dispose(), this.fsQuad.dispose() } setSize(n, e) { let t = Math.round(n / 2), r = Math.round(e / 2); this.renderTargetBright.setSize(t, r); for (let i = 0; i < this.nMips; i++)this.renderTargetsHorizontal[i].setSize(t, r), this.renderTargetsVertical[i].setSize(t, r), this.separableBlurMaterials[i].uniforms.texSize.value = new Be(t, r), t = Math.round(t / 2), r = Math.round(r / 2) } render(n, e, t, r, i) { n.getClearColor(this._oldClearColor), this.oldClearAlpha = n.getClearAlpha(); const o = n.autoClear; n.autoClear = !1, n.setClearColor(this.clearColor, 0), i && n.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = t.texture, n.setRenderTarget(null), n.clear(), this.fsQuad.render(n)), this.highPassUniforms.tDiffuse.value = t.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, n.setRenderTarget(this.renderTargetBright), n.clear(), this.fsQuad.render(n); let s = this.renderTargetBright; for (let a = 0; a < this.nMips; a++)this.fsQuad.material = this.separableBlurMaterials[a], this.separableBlurMaterials[a].uniforms.colorTexture.value = s.texture, this.separableBlurMaterials[a].uniforms.direction.value = XA.BlurDirectionX, n.setRenderTarget(this.renderTargetsHorizontal[a]), n.clear(), this.fsQuad.render(n), this.separableBlurMaterials[a].uniforms.colorTexture.value = this.renderTargetsHorizontal[a].texture, this.separableBlurMaterials[a].uniforms.direction.value = XA.BlurDirectionY, n.setRenderTarget(this.renderTargetsVertical[a]), n.clear(), this.fsQuad.render(n), s = this.renderTargetsVertical[a]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, n.setRenderTarget(this.renderTargetsHorizontal[0]), n.clear(), this.fsQuad.render(n), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i && n.state.buffers.stencil.setTest(!0), this.renderToScreen ? (n.setRenderTarget(null), this.fsQuad.render(n)) : (n.setRenderTarget(t), this.fsQuad.render(n)), n.setClearColor(this._oldClearColor, this.oldClearAlpha), n.autoClear = o } getSeperableBlurMaterial(n) {
		return new _r({
			defines: { KERNEL_RADIUS: n, SIGMA: n }, uniforms: { colorTexture: { value: null }, texSize: { value: new Be(.5, .5) }, direction: { value: new Be(.5, .5) } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})
	} getCompositeMaterial(n) {
		return new _r({
			defines: { NUM_MIPS: n }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})
	}
}; let pw = XA; fF(pw, "BlurDirectionX", new Be(1, 0)); fF(pw, "BlurDirectionY", new Be(0, 1)); var JW = Object.defineProperty, KW = (n, e, t) => e in n ? JW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Rx = (n, e, t) => (KW(n, typeof e != "symbol" ? e + "" : e, t), t); class NR extends Yp { constructor(e, t) { super(), Rx(this, "scene"), Rx(this, "camera"), Rx(this, "inverse"), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1 } render(e, t, r) { const i = e.getContext(), o = e.state; o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0); let s, a; this.inverse ? (s = 0, a = 1) : (s = 1, a = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), o.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), o.buffers.stencil.setClear(a), o.buffers.stencil.setLocked(!0), e.setRenderTarget(r), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), o.buffers.stencil.setLocked(!0) } } class YW extends Yp { constructor() { super(), this.needsSwap = !1 } render(e) { e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1) } } var $W = Object.defineProperty, QW = (n, e, t) => e in n ? $W(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, So = (n, e, t) => (QW(n, typeof e != "symbol" ? e + "" : e, t), t); class ZW { constructor(e, t) { if (So(this, "renderer"), So(this, "_pixelRatio"), So(this, "_width"), So(this, "_height"), So(this, "renderTarget1"), So(this, "renderTarget2"), So(this, "writeBuffer"), So(this, "readBuffer"), So(this, "renderToScreen"), So(this, "passes", []), So(this, "copyPass"), So(this, "clock"), this.renderer = e, t === void 0) { const r = { minFilter: fn, magFilter: fn, format: Yr }, i = e.getSize(new Be); this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, t = new Qr(this._width * this._pixelRatio, this._height * this._pixelRatio, r), t.texture.name = "EffectComposer.rt1" } else this._pixelRatio = 1, this._width = t.width, this._height = t.height; this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, jA === void 0 && console.error("THREE.EffectComposer relies on CopyShader"), WA === void 0 && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new WA(jA), this.copyPass.material.blending = bs, this.clock = new Uy } swapBuffers() { const e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } addPass(e) { this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(e, t) { this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(e) { const t = this.passes.indexOf(e); t !== -1 && this.passes.splice(t, 1) } isLastEnabledPass(e) { for (let t = e + 1; t < this.passes.length; t++)if (this.passes[t].enabled) return !1; return !0 } render(e) { e === void 0 && (e = this.clock.getDelta()); const t = this.renderer.getRenderTarget(); let r = !1; const i = this.passes.length; for (let o = 0; o < i; o++) { const s = this.passes[o]; if (s.enabled !== !1) { if (s.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o), s.render(this.renderer, this.writeBuffer, this.readBuffer, e, r), s.needsSwap) { if (r) { const a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil; l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(a.EQUAL, 1, 4294967295) } this.swapBuffers() } NR !== void 0 && (s instanceof NR ? r = !0 : s instanceof YW && (r = !1)) } } this.renderer.setRenderTarget(t) } reset(e) { if (e === void 0) { const t = this.renderer.getSize(new Be); this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(e, t) { this._width = e, this._height = t; const r = this._width * this._pixelRatio, i = this._height * this._pixelRatio; this.renderTarget1.setSize(r, i), this.renderTarget2.setSize(r, i); for (let o = 0; o < this.passes.length; o++)this.passes[o].setSize(r, i) } setPixelRatio(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } } var qW = Object.defineProperty, e7 = (n, e, t) => e in n ? qW(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, ic = (n, e, t) => (e7(n, typeof e != "symbol" ? e + "" : e, t), t); class t7 extends Yp { constructor(e, t, r, i, o = 0) { super(), ic(this, "scene"), ic(this, "camera"), ic(this, "overrideMaterial"), ic(this, "clearColor"), ic(this, "clearAlpha"), ic(this, "clearDepth", !1), ic(this, "_oldClearColor", new qe), this.scene = e, this.camera = t, this.overrideMaterial = r, this.clearColor = i, this.clearAlpha = o, this.clear = !0, this.needsSwap = !1 } render(e, t, r) { let i = e.autoClear; e.autoClear = !1; let o, s = null; this.overrideMaterial !== void 0 && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), o = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : r), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, o), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = s), e.autoClear = i } } class mw extends ei { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new s7(t) }), this.register(function (t) { return new p7(t) }), this.register(function (t) { return new m7(t) }), this.register(function (t) { return new g7(t) }), this.register(function (t) { return new l7(t) }), this.register(function (t) { return new c7(t) }), this.register(function (t) { return new u7(t) }), this.register(function (t) { return new f7(t) }), this.register(function (t) { return new o7(t) }), this.register(function (t) { return new d7(t) }), this.register(function (t) { return new a7(t) }), this.register(function (t) { return new h7(t) }), this.register(function (t) { return new r7(t) }), this.register(function (t) { return new v7(t) }), this.register(function (t) { return new y7(t) }) } load(e, t, r, i) { const o = this; let s; this.resourcePath !== "" ? s = this.resourcePath : this.path !== "" ? s = this.path : s = Ps.extractUrlBase(e), this.manager.itemStart(e); const a = function (c) { i ? i(c) : console.error(c), o.manager.itemError(e), o.manager.itemEnd(e) }, l = new io(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) { try { o.parse(c, s, function (u) { t(u), o.manager.itemEnd(e) }, a) } catch (u) { a(u) } }, r, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, r, i) { let o; const s = {}, a = {}; if (typeof e == "string") o = JSON.parse(e); else if (e instanceof ArrayBuffer) if (Ps.decodeText(new Uint8Array(e.slice(0, 4))) === dF) { try { s[Nt.KHR_BINARY_GLTF] = new _7(e) } catch (u) { i && i(u); return } o = JSON.parse(s[Nt.KHR_BINARY_GLTF].content) } else o = JSON.parse(Ps.decodeText(new Uint8Array(e))); else o = e; if (o.asset === void 0 || o.asset.version[0] < 2) { i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const l = new I7(o, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let c = 0; c < this.pluginCallbacks.length; c++) { const u = this.pluginCallbacks[c](l); a[u.name] = u, s[u.name] = !0 } if (o.extensionsUsed) for (let c = 0; c < o.extensionsUsed.length; ++c) { const u = o.extensionsUsed[c], d = o.extensionsRequired || []; switch (u) { case Nt.KHR_MATERIALS_UNLIT: s[u] = new i7; break; case Nt.KHR_DRACO_MESH_COMPRESSION: s[u] = new x7(o, this.dracoLoader); break; case Nt.KHR_TEXTURE_TRANSFORM: s[u] = new S7; break; case Nt.KHR_MESH_QUANTIZATION: s[u] = new A7; break; default: d.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".') } } l.setExtensions(s), l.setPlugins(a), l.parse(r, i) } parseAsync(e, t) { const r = this; return new Promise(function (i, o) { r.parse(e, t, i, o) }) } } function n7() { let n = {}; return { get: function (e) { return n[e] }, add: function (e, t) { n[e] = t }, remove: function (e) { delete n[e] }, removeAll: function () { n = {} } } } const Nt = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class r7 { constructor(e) { this.parser = e, this.name = Nt.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let r = 0, i = t.length; r < i; r++) { const o = t[r]; o.extensions && o.extensions[this.name] && o.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, o.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, r = "light:" + e; let i = t.cache.get(r); if (i) return i; const o = t.json, l = ((o.extensions && o.extensions[this.name] || {}).lights || [])[e]; let c; const u = new qe(16777215); l.color !== void 0 && u.fromArray(l.color); const d = l.range !== void 0 ? l.range : 0; switch (l.type) { case "directional": c = new sw(u), c.target.position.set(0, 0, -1), c.add(c.target); break; case "point": c = new ow(u), c.distance = d; break; case "spot": c = new iw(u), c.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type) }return c.position.set(0, 0, 0), c.decay = 2, Qa(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(r, i), i } getDependency(e, t) { if (e === "light") return this._loadLight(t) } createNodeAttachment(e) { const t = this, r = this.parser, o = r.json.nodes[e], a = (o.extensions && o.extensions[this.name] || {}).light; return a === void 0 ? null : this._loadLight(a).then(function (l) { return r._getNodeRef(t.cache, a, l) }) } } class i7 { constructor() { this.name = Nt.KHR_MATERIALS_UNLIT } getMaterialType() { return hi } extendParams(e, t, r) { const i = []; e.color = new qe(1, 1, 1), e.opacity = 1; const o = t.pbrMetallicRoughness; if (o) { if (Array.isArray(o.baseColorFactor)) { const s = o.baseColorFactor; e.color.fromArray(s), e.opacity = s[3] } o.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", o.baseColorTexture, 3001)) } return Promise.all(i) } } class o7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = i.extensions[this.name].emissiveStrength; return o !== void 0 && (t.emissiveIntensity = o), Promise.resolve() } } class s7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; if (s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor), s.clearcoatTexture !== void 0 && o.push(r.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), s.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), s.clearcoatRoughnessTexture !== void 0 && o.push(r.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), s.clearcoatNormalTexture !== void 0 && (o.push(r.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), s.clearcoatNormalTexture.scale !== void 0)) { const a = s.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Be(a, a) } return Promise.all(o) } } class a7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; return s.iridescenceFactor !== void 0 && (t.iridescence = s.iridescenceFactor), s.iridescenceTexture !== void 0 && o.push(r.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), s.iridescenceIor !== void 0 && (t.iridescenceIOR = s.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), s.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), s.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), s.iridescenceThicknessTexture !== void 0 && o.push(r.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(o) } } class l7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_SHEEN } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = []; t.sheenColor = new qe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const s = i.extensions[this.name]; return s.sheenColorFactor !== void 0 && t.sheenColor.fromArray(s.sheenColorFactor), s.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = s.sheenRoughnessFactor), s.sheenColorTexture !== void 0 && o.push(r.assignTexture(t, "sheenColorMap", s.sheenColorTexture, 3001)), s.sheenRoughnessTexture !== void 0 && o.push(r.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(o) } } class c7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; return s.transmissionFactor !== void 0 && (t.transmission = s.transmissionFactor), s.transmissionTexture !== void 0 && o.push(r.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(o) } } class u7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_VOLUME } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; t.thickness = s.thicknessFactor !== void 0 ? s.thicknessFactor : 0, s.thicknessTexture !== void 0 && o.push(r.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 1 / 0; const a = s.attenuationColor || [1, 1, 1]; return t.attenuationColor = new qe(a[0], a[1], a[2]), Promise.all(o) } } class f7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_IOR } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = i.extensions[this.name]; return t.ior = o.ior !== void 0 ? o.ior : 1.5, Promise.resolve() } } class d7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; t.specularIntensity = s.specularFactor !== void 0 ? s.specularFactor : 1, s.specularTexture !== void 0 && o.push(r.assignTexture(t, "specularIntensityMap", s.specularTexture)); const a = s.specularColorFactor || [1, 1, 1]; return t.specularColor = new qe(a[0], a[1], a[2]), s.specularColorTexture !== void 0 && o.push(r.assignTexture(t, "specularColorMap", s.specularColorTexture, 3001)), Promise.all(o) } } class h7 { constructor(e) { this.parser = e, this.name = Nt.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : ks } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const o = [], s = i.extensions[this.name]; return s.anisotropyStrength !== void 0 && (t.anisotropy = s.anisotropyStrength), s.anisotropyRotation !== void 0 && (t.anisotropyRotation = s.anisotropyRotation), s.anisotropyTexture !== void 0 && o.push(r.assignTexture(t, "anisotropyMap", s.anisotropyTexture)), Promise.all(o) } } class p7 { constructor(e) { this.parser = e, this.name = Nt.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, r = t.json, i = r.textures[e]; if (!i.extensions || !i.extensions[this.name]) return null; const o = i.extensions[this.name], s = t.options.ktx2Loader; if (!s) { if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, o.source, s) } } class m7 { constructor(e) { this.parser = e, this.name = Nt.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, r = this.parser, i = r.json, o = i.textures[e]; if (!o.extensions || !o.extensions[t]) return null; const s = o.extensions[t], a = i.images[s.source]; let l = r.textureLoader; if (a.uri) { const c = r.options.manager.getHandler(a.uri); c !== null && (l = c) } return this.detectSupport().then(function (c) { if (c) return r.loadTextureImage(e, s.source, l); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return r.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class g7 { constructor(e) { this.parser = e, this.name = Nt.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, r = this.parser, i = r.json, o = i.textures[e]; if (!o.extensions || !o.extensions[t]) return null; const s = o.extensions[t], a = i.images[s.source]; let l = r.textureLoader; if (a.uri) { const c = r.options.manager.getHandler(a.uri); c !== null && (l = c) } return this.detectSupport().then(function (c) { if (c) return r.loadTextureImage(e, s.source, l); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return r.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class v7 { constructor(e) { this.name = Nt.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, r = t.bufferViews[e]; if (r.extensions && r.extensions[this.name]) { const i = r.extensions[this.name], o = this.parser.getDependency("buffer", i.buffer), s = this.parser.options.meshoptDecoder; if (!s || !s.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return o.then(function (a) { const l = i.byteOffset || 0, c = i.byteLength || 0, u = i.count, d = i.byteStride, p = new Uint8Array(a, l, c); return s.decodeGltfBufferAsync ? s.decodeGltfBufferAsync(u, d, p, i.mode, i.filter).then(function (m) { return m.buffer }) : s.ready.then(function () { const m = new ArrayBuffer(u * d); return s.decodeGltfBuffer(new Uint8Array(m), u, d, p, i.mode, i.filter), m }) }) } else return null } } class y7 { constructor(e) { this.name = Nt.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, r = t.nodes[e]; if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0) return null; const i = t.meshes[r.mesh]; for (const c of i.primitives) if (c.mode !== Ao.TRIANGLES && c.mode !== Ao.TRIANGLE_STRIP && c.mode !== Ao.TRIANGLE_FAN && c.mode !== void 0) return null; const s = r.extensions[this.name].attributes, a = [], l = {}; for (const c in s) a.push(this.parser.getDependency("accessor", s[c]).then(u => (l[c] = u, l[c]))); return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(c => { const u = c.pop(), d = u.isGroup ? u.children : [u], p = c[0].count, m = []; for (const v of d) { const y = new _t, _ = new X, g = new Sr, x = new X(1, 1, 1), A = new VM(v.geometry, v.material, p); for (let E = 0; E < p; E++)l.TRANSLATION && _.fromBufferAttribute(l.TRANSLATION, E), l.ROTATION && g.fromBufferAttribute(l.ROTATION, E), l.SCALE && x.fromBufferAttribute(l.SCALE, E), A.setMatrixAt(E, y.compose(_, g, x)); for (const E in l) E !== "TRANSLATION" && E !== "ROTATION" && E !== "SCALE" && v.geometry.setAttribute(E, l[E]); Ut.prototype.copy.call(A, v), this.parser.assignFinalMaterial(A), m.push(A) } return u.isGroup ? (u.clear(), u.add(...m), u) : m[0] })) } } const dF = "glTF", nh = 12, zR = { JSON: 1313821514, BIN: 5130562 }; class _7 { constructor(e) { this.name = Nt.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, nh); if (this.header = { magic: Ps.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== dF) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const r = this.header.length - nh, i = new DataView(e, nh); let o = 0; for (; o < r;) { const s = i.getUint32(o, !0); o += 4; const a = i.getUint32(o, !0); if (o += 4, a === zR.JSON) { const l = new Uint8Array(e, nh + o, s); this.content = Ps.decodeText(l) } else if (a === zR.BIN) { const l = nh + o; this.body = e.slice(l, l + s) } o += s } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class x7 { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Nt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const r = this.json, i = this.dracoLoader, o = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, a = {}, l = {}, c = {}; for (const u in s) { const d = JA[u] || u.toLowerCase(); a[d] = s[u] } for (const u in e.attributes) { const d = JA[u] || u.toLowerCase(); if (s[u] !== void 0) { const p = r.accessors[e.attributes[u]], m = Cf[p.componentType]; c[d] = m.name, l[d] = p.normalized === !0 } } return t.getDependency("bufferView", o).then(function (u) { return new Promise(function (d) { i.decodeDracoFile(u, function (p) { for (const m in p.attributes) { const v = p.attributes[m], y = l[m]; y !== void 0 && (v.normalized = y) } d(p) }, a, c) }) }) } } class S7 { constructor() { this.name = Nt.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class A7 { constructor() { this.name = Nt.KHR_MESH_QUANTIZATION } } class hF extends cd { constructor(e, t, r, i) { super(e, t, r, i) } copySampleValue_(e) { const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, o = e * i * 3 + i; for (let s = 0; s !== i; s++)t[s] = r[o + s]; return t } interpolate_(e, t, r, i) { const o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = i - t, d = (r - t) / u, p = d * d, m = p * d, v = e * c, y = v - c, _ = -2 * m + 3 * p, g = m - p, x = 1 - _, A = g - p + d; for (let E = 0; E !== a; E++) { const w = s[y + E + a], b = s[y + E + l] * u, T = s[v + E + a], B = s[v + E] * u; o[E] = x * w + A * b + _ * T + g * B } return o } } const E7 = new Sr; class M7 extends hF { interpolate_(e, t, r, i) { const o = super.interpolate_(e, t, r, i); return E7.fromArray(o).normalize().toArray(o), o } } const Ao = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Cf = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, GR = { 9728: Gn, 9729: fn, 9984: op, 9985: ay, 9986: Mf, 9987: Ds }, HR = { 33071: Rr, 33648: Nf, 10497: Al }, Px = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, JA = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", ...OW >= 152 ? { TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3" } : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }, COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Ja = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, w7 = { CUBICSPLINE: void 0, LINEAR: Hc, STEP: zf }, Bx = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function b7(n) { return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Xp({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: qo })), n.DefaultMaterial } function oc(n, e, t) { for (const r in t.extensions) n[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]) } function Qa(n, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function C7(n, e, t) { let r = !1, i = !1, o = !1; for (let c = 0, u = e.length; c < u; c++) { const d = e[c]; if (d.POSITION !== void 0 && (r = !0), d.NORMAL !== void 0 && (i = !0), d.COLOR_0 !== void 0 && (o = !0), r && i && o) break } if (!r && !i && !o) return Promise.resolve(n); const s = [], a = [], l = []; for (let c = 0, u = e.length; c < u; c++) { const d = e[c]; if (r) { const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : n.attributes.position; s.push(p) } if (i) { const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : n.attributes.normal; a.push(p) } if (o) { const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : n.attributes.color; l.push(p) } } return Promise.all([Promise.all(s), Promise.all(a), Promise.all(l)]).then(function (c) { const u = c[0], d = c[1], p = c[2]; return r && (n.morphAttributes.position = u), i && (n.morphAttributes.normal = d), o && (n.morphAttributes.color = p), n.morphTargetsRelative = !0, n }) } function T7(n, e) { if (n.updateMorphTargets(), e.weights !== void 0) for (let t = 0, r = e.weights.length; t < r; t++)n.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (n.morphTargetInfluences.length === t.length) { n.morphTargetDictionary = {}; for (let r = 0, i = t.length; r < i; r++)n.morphTargetDictionary[t[r]] = r } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function R7(n) { let e; const t = n.extensions && n.extensions[Nt.KHR_DRACO_MESH_COMPRESSION]; if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Ix(t.attributes) : e = n.indices + ":" + Ix(n.attributes) + ":" + n.mode, n.targets !== void 0) for (let r = 0, i = n.targets.length; r < i; r++)e += ":" + Ix(n.targets[r]); return e } function Ix(n) { let e = ""; const t = Object.keys(n).sort(); for (let r = 0, i = t.length; r < i; r++)e += t[r] + ":" + n[t[r]] + ";"; return e } function KA(n) { switch (n) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function P7(n) { return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } const B7 = new _t; class I7 { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new n7, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let r = !1, i = !1, o = -1; typeof navigator < "u" && typeof navigator.userAgent < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, o = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || i && o < 98 ? this.textureLoader = new Ca(this.options.manager) : this.textureLoader = new BO(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new io(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const r = this, i = this.json, o = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (s) { return s._markDefs && s._markDefs() }), Promise.all(this._invokeAll(function (s) { return s.beforeRoot && s.beforeRoot() })).then(function () { return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")]) }).then(function (s) { const a = { scene: s[0][i.scene || 0], scenes: s[0], animations: s[1], cameras: s[2], asset: i.asset, parser: r, userData: {} }; oc(o, a, i), Qa(a, i), Promise.all(r._invokeAll(function (l) { return l.afterRoot && l.afterRoot(a) })).then(function () { e(a) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || []; for (let i = 0, o = t.length; i < o; i++) { const s = t[i].joints; for (let a = 0, l = s.length; a < l; a++)e[s[a]].isBone = !0 } for (let i = 0, o = e.length; i < o; i++) { const s = e[i]; s.mesh !== void 0 && (this._addNodeRef(this.meshCache, s.mesh), s.skin !== void 0 && (r[s.mesh].isSkinnedMesh = !0)), s.camera !== void 0 && this._addNodeRef(this.cameraCache, s.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, r) { if (e.refs[t] <= 1) return r; const i = r.clone(), o = (s, a) => { const l = this.associations.get(s); l != null && this.associations.set(a, l); for (const [c, u] of s.children.entries()) o(u, a.children[c]) }; return o(r, i), i.name += "_instance_" + e.uses[t]++, i } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let r = 0; r < t.length; r++) { const i = e(t[r]); if (i) return i } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const r = []; for (let i = 0; i < t.length; i++) { const o = e(t[i]); o && r.push(o) } return r } getDependency(e, t) { const r = e + ":" + t; let i = this.cache.get(r); if (!i) { switch (e) { case "scene": i = this.loadScene(t); break; case "node": i = this._invokeOne(function (o) { return o.loadNode && o.loadNode(t) }); break; case "mesh": i = this._invokeOne(function (o) { return o.loadMesh && o.loadMesh(t) }); break; case "accessor": i = this.loadAccessor(t); break; case "bufferView": i = this._invokeOne(function (o) { return o.loadBufferView && o.loadBufferView(t) }); break; case "buffer": i = this.loadBuffer(t); break; case "material": i = this._invokeOne(function (o) { return o.loadMaterial && o.loadMaterial(t) }); break; case "texture": i = this._invokeOne(function (o) { return o.loadTexture && o.loadTexture(t) }); break; case "skin": i = this.loadSkin(t); break; case "animation": i = this._invokeOne(function (o) { return o.loadAnimation && o.loadAnimation(t) }); break; case "camera": i = this.loadCamera(t); break; default: if (i = this._invokeOne(function (o) { return o != this && o.getDependency && o.getDependency(e, t) }), !i) throw new Error("Unknown type: " + e); break }this.cache.add(r, i) } return i } getDependencies(e) { let t = this.cache.get(e); if (!t) { const r = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(i.map(function (o, s) { return r.getDependency(e, s) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], r = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Nt.KHR_BINARY_GLTF].body); const i = this.options; return new Promise(function (o, s) { r.load(Ps.resolveURL(t.uri, i.path), o, void 0, function () { s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (r) { const i = t.byteLength || 0, o = t.byteOffset || 0; return r.slice(o, o + i) }) } loadAccessor(e) { const t = this, r = this.json, i = this.json.accessors[e]; if (i.bufferView === void 0 && i.sparse === void 0) { const s = Px[i.type], a = Cf[i.componentType], l = i.normalized === !0, c = new a(i.count * s); return Promise.resolve(new Kt(c, s, l)) } const o = []; return i.bufferView !== void 0 ? o.push(this.getDependency("bufferView", i.bufferView)) : o.push(null), i.sparse !== void 0 && (o.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(o).then(function (s) { const a = s[0], l = Px[i.type], c = Cf[i.componentType], u = c.BYTES_PER_ELEMENT, d = u * l, p = i.byteOffset || 0, m = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0, v = i.normalized === !0; let y, _; if (m && m !== d) { const g = Math.floor(p / m), x = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + g + ":" + i.count; let A = t.cache.get(x); A || (y = new c(a, g * m, i.count * m / u), A = new Gp(y, m / u), t.cache.add(x, A)), _ = new Bi(A, l, p % m / u, v) } else a === null ? y = new c(i.count * l) : y = new c(a, p, i.count * l), _ = new Kt(y, l, v); if (i.sparse !== void 0) { const g = Px.SCALAR, x = Cf[i.sparse.indices.componentType], A = i.sparse.indices.byteOffset || 0, E = i.sparse.values.byteOffset || 0, w = new x(s[1], A, i.sparse.count * g), b = new c(s[2], E, i.sparse.count * l); a !== null && (_ = new Kt(_.array.slice(), _.itemSize, _.normalized)); for (let T = 0, B = w.length; T < B; T++) { const R = w[T]; if (_.setX(R, b[T * l]), l >= 2 && _.setY(R, b[T * l + 1]), l >= 3 && _.setZ(R, b[T * l + 2]), l >= 4 && _.setW(R, b[T * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return _ }) } loadTexture(e) { const t = this.json, r = this.options, o = t.textures[e].source, s = t.images[o]; let a = this.textureLoader; if (s.uri) { const l = r.manager.getHandler(s.uri); l !== null && (a = l) } return this.loadTextureImage(e, o, a) } loadTextureImage(e, t, r) { const i = this, o = this.json, s = o.textures[e], a = o.images[t], l = (a.uri || a.bufferView) + ":" + s.sampler; if (this.textureCache[l]) return this.textureCache[l]; const c = this.loadImageSource(t, r).then(function (u) { u.flipY = !1, u.name = s.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri); const p = (o.samplers || {})[s.sampler] || {}; return u.magFilter = GR[p.magFilter] || fn, u.minFilter = GR[p.minFilter] || Ds, u.wrapS = HR[p.wrapS] || Al, u.wrapT = HR[p.wrapT] || Al, i.associations.set(u, { textures: e }), u }).catch(function () { return null }); return this.textureCache[l] = c, c } loadImageSource(e, t) { const r = this, i = this.json, o = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone()); const s = i.images[e], a = self.URL || self.webkitURL; let l = s.uri || "", c = !1; if (s.bufferView !== void 0) l = r.getDependency("bufferView", s.bufferView).then(function (d) { c = !0; const p = new Blob([d], { type: s.mimeType }); return l = a.createObjectURL(p), l }); else if (s.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const u = Promise.resolve(l).then(function (d) { return new Promise(function (p, m) { let v = p; t.isImageBitmapLoader === !0 && (v = function (y) { const _ = new An(y); _.needsUpdate = !0, p(_) }), t.load(Ps.resolveURL(d, o.path), v, void 0, m) }) }).then(function (d) { return c === !0 && a.revokeObjectURL(l), d.userData.mimeType = s.mimeType || P7(s.uri), d }).catch(function (d) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d }); return this.sourceCache[e] = u, u } assignTexture(e, t, r, i) { const o = this; return this.getDependency("texture", r.index).then(function (s) { if (!s) return null; if (r.texCoord !== void 0 && r.texCoord > 0 && (s = s.clone(), s.channel = r.texCoord), o.extensions[Nt.KHR_TEXTURE_TRANSFORM]) { const a = r.extensions !== void 0 ? r.extensions[Nt.KHR_TEXTURE_TRANSFORM] : void 0; if (a) { const l = o.associations.get(s); s = o.extensions[Nt.KHR_TEXTURE_TRANSFORM].extendTexture(s, a), o.associations.set(s, l) } } return i !== void 0 && ("colorSpace" in s ? s.colorSpace = i === 3001 ? "srgb" : "srgb-linear" : s.encoding = i), e[t] = s, s }) } assignFinalMaterial(e) { const t = e.geometry; let r = e.material; const i = t.attributes.tangent === void 0, o = t.attributes.color !== void 0, s = t.attributes.normal === void 0; if (e.isPoints) { const a = "PointsMaterial:" + r.uuid; let l = this.cache.get(a); l || (l = new _y, rr.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, l.sizeAttenuation = !1, this.cache.add(a, l)), r = l } else if (e.isLine) { const a = "LineBasicMaterial:" + r.uuid; let l = this.cache.get(a); l || (l = new qr, rr.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, this.cache.add(a, l)), r = l } if (i || o || s) { let a = "ClonedMaterial:" + r.uuid + ":"; i && (a += "derivative-tangents:"), o && (a += "vertex-colors:"), s && (a += "flat-shading:"); let l = this.cache.get(a); l || (l = r.clone(), o && (l.vertexColors = !0), s && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(r))), r = l } e.material = r } getMaterialType() { return Xp } loadMaterial(e) { const t = this, r = this.json, i = this.extensions, o = r.materials[e]; let s; const a = {}, l = o.extensions || {}, c = []; if (l[Nt.KHR_MATERIALS_UNLIT]) { const d = i[Nt.KHR_MATERIALS_UNLIT]; s = d.getMaterialType(), c.push(d.extendParams(a, o, t)) } else { const d = o.pbrMetallicRoughness || {}; if (a.color = new qe(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) { const p = d.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", d.baseColorTexture, 3001)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), s = this._invokeOne(function (p) { return p.getMaterialType && p.getMaterialType(e) }), c.push(Promise.all(this._invokeAll(function (p) { return p.extendMaterialParams && p.extendMaterialParams(e, a) }))) } o.doubleSided === !0 && (a.side = Ti); const u = o.alphaMode || Bx.OPAQUE; if (u === Bx.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === Bx.MASK && (a.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : .5)), o.normalTexture !== void 0 && s !== hi && (c.push(t.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new Be(1, 1), o.normalTexture.scale !== void 0)) { const d = o.normalTexture.scale; a.normalScale.set(d, d) } return o.occlusionTexture !== void 0 && s !== hi && (c.push(t.assignTexture(a, "aoMap", o.occlusionTexture)), o.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = o.occlusionTexture.strength)), o.emissiveFactor !== void 0 && s !== hi && (a.emissive = new qe().fromArray(o.emissiveFactor)), o.emissiveTexture !== void 0 && s !== hi && c.push(t.assignTexture(a, "emissiveMap", o.emissiveTexture, 3001)), Promise.all(c).then(function () { const d = new s(a); return o.name && (d.name = o.name), Qa(d, o), t.associations.set(d, { materials: e }), o.extensions && oc(i, d, o), d }) } createUniqueName(e) { const t = Gt.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, r = this.extensions, i = this.primitiveCache; function o(a) { return r[Nt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) { return VR(l, a, t) }) } const s = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], u = R7(c), d = i[u]; if (d) s.push(d.promise); else { let p; c.extensions && c.extensions[Nt.KHR_DRACO_MESH_COMPRESSION] ? p = o(c) : p = VR(new bt, c, t), i[u] = { primitive: c, promise: p }, s.push(p) } } return Promise.all(s) } loadMesh(e) { const t = this, r = this.json, i = this.extensions, o = r.meshes[e], s = o.primitives, a = []; for (let l = 0, c = s.length; l < c; l++) { const u = s[l].material === void 0 ? b7(this.cache) : this.getDependency("material", s[l].material); a.push(u) } return a.push(t.loadGeometries(s)), Promise.all(a).then(function (l) { const c = l.slice(0, l.length - 1), u = l[l.length - 1], d = []; for (let m = 0, v = u.length; m < v; m++) { const y = u[m], _ = s[m]; let g; const x = c[m]; if (_.mode === Ao.TRIANGLES || _.mode === Ao.TRIANGLE_STRIP || _.mode === Ao.TRIANGLE_FAN || _.mode === void 0) g = o.isSkinnedMesh === !0 ? new HM(y, x) : new In(y, x), g.isSkinnedMesh === !0 && g.normalizeSkinWeights(), _.mode === Ao.TRIANGLE_STRIP ? g.geometry = FR(g.geometry, BM) : _.mode === Ao.TRIANGLE_FAN && (g.geometry = FR(g.geometry, xv)); else if (_.mode === Ao.LINES) g = new es(y, x); else if (_.mode === Ao.LINE_STRIP) g = new xa(y, x); else if (_.mode === Ao.LINE_LOOP) g = new WM(y, x); else if (_.mode === Ao.POINTS) g = new jM(y, x); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + _.mode); Object.keys(g.geometry.morphAttributes).length > 0 && T7(g, o), g.name = t.createUniqueName(o.name || "mesh_" + e), Qa(g, o), _.extensions && oc(i, g, _), t.assignFinalMaterial(g), d.push(g) } for (let m = 0, v = d.length; m < v; m++)t.associations.set(d[m], { meshes: e, primitives: m }); if (d.length === 1) return o.extensions && oc(i, d[0], o), d[0]; const p = new fa; o.extensions && oc(i, p, o), t.associations.set(p, { meshes: e }); for (let m = 0, v = d.length; m < v; m++)p.add(d[m]); return p }) } loadCamera(e) { let t; const r = this.json.cameras[e], i = r[r.type]; if (!i) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return r.type === "perspective" ? t = new xn(Up.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : r.type === "orthographic" && (t = new qi(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Qa(t, r), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], r = []; for (let i = 0, o = t.joints.length; i < o; i++)r.push(this._loadNodeShallow(t.joints[i])); return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function (i) { const o = i.pop(), s = i, a = [], l = []; for (let c = 0, u = s.length; c < u; c++) { const d = s[c]; if (d) { a.push(d); const p = new _t; o !== null && p.fromArray(o.array, c * 16), l.push(p) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]) } return new Hp(a, l) }) } loadAnimation(e) { const r = this.json.animations[e], i = r.name ? r.name : "animation_" + e, o = [], s = [], a = [], l = [], c = []; for (let u = 0, d = r.channels.length; u < d; u++) { const p = r.channels[u], m = r.samplers[p.sampler], v = p.target, y = v.node, _ = r.parameters !== void 0 ? r.parameters[m.input] : m.input, g = r.parameters !== void 0 ? r.parameters[m.output] : m.output; v.node !== void 0 && (o.push(this.getDependency("node", y)), s.push(this.getDependency("accessor", _)), a.push(this.getDependency("accessor", g)), l.push(m), c.push(v)) } return Promise.all([Promise.all(o), Promise.all(s), Promise.all(a), Promise.all(l), Promise.all(c)]).then(function (u) { const d = u[0], p = u[1], m = u[2], v = u[3], y = u[4], _ = []; for (let g = 0, x = d.length; g < x; g++) { const A = d[g], E = p[g], w = m[g], b = v[g], T = y[g]; if (A === void 0) continue; A.updateMatrix(); let B; switch (Ja[T.path]) { case Ja.weights: B = Vf; break; case Ja.rotation: B = El; break; case Ja.position: case Ja.scale: default: B = Wf; break }const R = A.name ? A.name : A.uuid, P = b.interpolation !== void 0 ? w7[b.interpolation] : Hc, U = []; Ja[T.path] === Ja.weights ? A.traverse(function ($) { $.morphTargetInfluences && U.push($.name ? $.name : $.uuid) }) : U.push(R); let G = w.array; if (w.normalized) { const $ = KA(G.constructor), z = new Float32Array(G.length); for (let j = 0, q = G.length; j < q; j++)z[j] = G[j] * $; G = z } for (let $ = 0, z = U.length; $ < z; $++) { const j = new B(U[$] + "." + Ja[T.path], E.array, G, P); b.interpolation === "CUBICSPLINE" && (j.createInterpolant = function (se) { const W = this instanceof El ? M7 : hF; return new W(this.times, this.values, this.getValueSize() / 3, se) }, j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), _.push(j) } } return new jf(i, void 0, _) }) } createNodeMesh(e) { const t = this.json, r = this, i = t.nodes[e]; return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function (o) { const s = r._getNodeRef(r.meshCache, i.mesh, o); return i.weights !== void 0 && s.traverse(function (a) { if (a.isMesh) for (let l = 0, c = i.weights.length; l < c; l++)a.morphTargetInfluences[l] = i.weights[l] }), s }) } loadNode(e) { const t = this.json, r = this, i = t.nodes[e], o = r._loadNodeShallow(e), s = [], a = i.children || []; for (let c = 0, u = a.length; c < u; c++)s.push(r.getDependency("node", a[c])); const l = i.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", i.skin); return Promise.all([o, Promise.all(s), l]).then(function (c) { const u = c[0], d = c[1], p = c[2]; p !== null && u.traverse(function (m) { m.isSkinnedMesh && m.bind(p, B7) }); for (let m = 0, v = d.length; m < v; m++)u.add(d[m]); return u }) } _loadNodeShallow(e) { const t = this.json, r = this.extensions, i = this; if (this.nodeCache[e] !== void 0) return this.nodeCache[e]; const o = t.nodes[e], s = o.name ? i.createUniqueName(o.name) : "", a = [], l = i._invokeOne(function (c) { return c.createNodeMesh && c.createNodeMesh(e) }); return l && a.push(l), o.camera !== void 0 && a.push(i.getDependency("camera", o.camera).then(function (c) { return i._getNodeRef(i.cameraCache, o.camera, c) })), i._invokeAll(function (c) { return c.createNodeAttachment && c.createNodeAttachment(e) }).forEach(function (c) { a.push(c) }), this.nodeCache[e] = Promise.all(a).then(function (c) { let u; if (o.isBone === !0 ? u = new yy : c.length > 1 ? u = new fa : c.length === 1 ? u = c[0] : u = new Ut, u !== c[0]) for (let d = 0, p = c.length; d < p; d++)u.add(c[d]); if (o.name && (u.userData.name = o.name, u.name = s), Qa(u, o), o.extensions && oc(r, u, o), o.matrix !== void 0) { const d = new _t; d.fromArray(o.matrix), u.applyMatrix4(d) } else o.translation !== void 0 && u.position.fromArray(o.translation), o.rotation !== void 0 && u.quaternion.fromArray(o.rotation), o.scale !== void 0 && u.scale.fromArray(o.scale); return i.associations.has(u) || i.associations.set(u, {}), i.associations.get(u).nodes = e, u }), this.nodeCache[e] } loadScene(e) { const t = this.extensions, r = this.json.scenes[e], i = this, o = new fa; r.name && (o.name = i.createUniqueName(r.name)), Qa(o, r), r.extensions && oc(t, o, r); const s = r.nodes || [], a = []; for (let l = 0, c = s.length; l < c; l++)a.push(i.getDependency("node", s[l])); return Promise.all(a).then(function (l) { for (let u = 0, d = l.length; u < d; u++)o.add(l[u]); const c = u => { const d = new Map; for (const [p, m] of i.associations) (p instanceof rr || p instanceof An) && d.set(p, m); return u.traverse(p => { const m = i.associations.get(p); m != null && d.set(p, m) }), d }; return i.associations = c(o), o }) } } function L7(n, e, t) { const r = e.attributes, i = new yi; if (r.POSITION !== void 0) { const a = t.json.accessors[r.POSITION], l = a.min, c = a.max; if (l !== void 0 && c !== void 0) { if (i.set(new X(l[0], l[1], l[2]), new X(c[0], c[1], c[2])), a.normalized) { const u = KA(Cf[a.componentType]); i.min.multiplyScalar(u), i.max.multiplyScalar(u) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const o = e.targets; if (o !== void 0) { const a = new X, l = new X; for (let c = 0, u = o.length; c < u; c++) { const d = o[c]; if (d.POSITION !== void 0) { const p = t.json.accessors[d.POSITION], m = p.min, v = p.max; if (m !== void 0 && v !== void 0) { if (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))), p.normalized) { const y = KA(Cf[p.componentType]); l.multiplyScalar(y) } a.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(a) } n.boundingBox = i; const s = new _i; i.getCenter(s.center), s.radius = i.min.distanceTo(i.max) / 2, n.boundingSphere = s } function VR(n, e, t) { const r = e.attributes, i = []; function o(s, a) { return t.getDependency("accessor", s).then(function (l) { n.setAttribute(a, l) }) } for (const s in r) { const a = JA[s] || s.toLowerCase(); a in n.attributes || i.push(o(r[s], a)) } if (e.indices !== void 0 && !n.index) { const s = t.getDependency("accessor", e.indices).then(function (a) { n.setIndex(a) }); i.push(s) } return Qa(n, e), L7(n, e, t), Promise.all(i).then(function () { return e.targets !== void 0 ? C7(n, e.targets, t) : n }) } const D7 = {
	uniforms: { tDiffuse: { value: null } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vUv );", "	gl_FragColor = LinearTosRGB( tex );", "}"].join(`
`)
}, Lx = new WeakMap; class O7 extends ei {
	constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, r, i) { const o = new io(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, s => { const a = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(s, a).then(t).catch(i) }, r, i) } decodeDracoFile(e, t, r, i) { const o = { attributeIDs: r || this.defaultAttributeIDs, attributeTypes: i || this.defaultAttributeTypes, useUniqueIDs: !!r }; this.decodeGeometry(e, o).then(t) } decodeGeometry(e, t) { for (const l in t.attributeTypes) { const c = t.attributeTypes[l]; c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name) } const r = JSON.stringify(t); if (Lx.has(e)) { const l = Lx.get(e); if (l.key === r) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let i; const o = this.workerNextTaskID++, s = e.byteLength, a = this._getWorker(o, s).then(l => (i = l, new Promise((c, u) => { i._callbacks[o] = { resolve: c, reject: u }, i.postMessage({ type: "decode", id: o, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { i && o && this._releaseTask(i, o) }), Lx.set(e, { key: r, promise: a }), a } _createGeometry(e) { const t = new bt; e.index && t.setIndex(new Kt(e.index.array, 1)); for (let r = 0; r < e.attributes.length; r++) { const i = e.attributes[r], o = i.name, s = i.array, a = i.itemSize; t.setAttribute(o, new Kt(s, a)) } return t } _loadLibrary(e, t) { const r = new io(this.manager); return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((i, o) => { r.load(e, i, void 0, o) }) } preload() { return this._initDecoder(), this } _initDecoder() {
		if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(r => {
			const i = r[0]; e || (this.decoderConfig.wasmBinary = r[1]); const o = F7.toString(), s = ["/* draco decoder */", i, "", "/* worker */", o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([s]))
		}), this.decoderPending
	} _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const i = new Worker(this.workerSourceURL); i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function (o) { const s = o.data; switch (s.type) { case "decode": i._callbacks[s.id].resolve(s); break; case "error": i._callbacks[s.id].reject(s); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + s.type + '"') } }, this.workerPool.push(i) } else this.workerPool.sort(function (i, o) { return i._taskLoad > o._taskLoad ? -1 : 1 }); const r = this.workerPool[this.workerPool.length - 1]; return r._taskCosts[e] = t, r._taskLoad += t, r }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
} function F7() { let n, e; onmessage = function (s) { const a = s.data; switch (a.type) { case "init": n = a.decoderConfig, e = new Promise(function (u) { n.onModuleLoaded = function (d) { u({ draco: d }) }, DracoDecoderModule(n) }); break; case "decode": const l = a.buffer, c = a.taskConfig; e.then(u => { const d = u.draco, p = new d.Decoder, m = new d.DecoderBuffer; m.Init(new Int8Array(l), l.byteLength); try { const v = t(d, p, m, c), y = v.attributes.map(_ => _.array.buffer); v.index && y.push(v.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: v }, y) } catch (v) { console.error(v), self.postMessage({ type: "error", id: a.id, error: v.message }) } finally { d.destroy(m), d.destroy(p) } }); break } }; function t(s, a, l, c) { const u = c.attributeIDs, d = c.attributeTypes; let p, m; const v = a.GetEncodedGeometryType(l); if (v === s.TRIANGULAR_MESH) p = new s.Mesh, m = a.DecodeBufferToMesh(l, p); else if (v === s.POINT_CLOUD) p = new s.PointCloud, m = a.DecodeBufferToPointCloud(l, p); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg()); const y = { index: null, attributes: [] }; for (const _ in u) { const g = self[d[_]]; let x, A; if (c.useUniqueIDs) A = u[_], x = a.GetAttributeByUniqueId(p, A); else { if (A = a.GetAttributeId(p, s[u[_]]), A === -1) continue; x = a.GetAttribute(p, A) } y.attributes.push(i(s, a, p, _, g, x)) } return v === s.TRIANGULAR_MESH && (y.index = r(s, a, p)), s.destroy(p), y } function r(s, a, l) { const u = l.num_faces() * 3, d = u * 4, p = s._malloc(d); a.GetTrianglesUInt32Array(l, d, p); const m = new Uint32Array(s.HEAPF32.buffer, p, u).slice(); return s._free(p), { array: m, itemSize: 1 } } function i(s, a, l, c, u, d) { const p = d.num_components(), v = l.num_points() * p, y = v * u.BYTES_PER_ELEMENT, _ = o(s, u), g = s._malloc(y); a.GetAttributeDataArrayForAllPoints(l, d, _, y, g); const x = new u(s.HEAPF32.buffer, g, v).slice(); return s._free(g), { name: c, array: x, itemSize: p } } function o(s, a) { switch (a) { case Float32Array: return s.DT_FLOAT32; case Int8Array: return s.DT_INT8; case Int16Array: return s.DT_INT16; case Int32Array: return s.DT_INT32; case Uint8Array: return s.DT_UINT8; case Uint16Array: return s.DT_UINT16; case Uint32Array: return s.DT_UINT32 } } } const WR = new yi, o0 = new X; class gw extends Fy { constructor() { super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry"; const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]; this.setIndex(r), this.setAttribute("position", new ut(e, 3)), this.setAttribute("uv", new ut(t, 2)) } applyMatrix4(e) { const t = this.attributes.instanceStart, r = this.attributes.instanceEnd; return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } setPositions(e) { let t; e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)); const r = new wv(t, 6, 1); return this.setAttribute("instanceStart", new Bi(r, 3, 0)), this.setAttribute("instanceEnd", new Bi(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } setColors(e) { let t; e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)); const r = new wv(t, 6, 1); return this.setAttribute("instanceColorStart", new Bi(r, 3, 0)), this.setAttribute("instanceColorEnd", new Bi(r, 3, 3)), this } fromWireframeGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromEdgesGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromMesh(e) { return this.fromWireframeGeometry(new ZM(e.geometry)), this } fromLineSegments(e) { const t = e.geometry; return this.setPositions(t.attributes.position.array), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new yi); const e = this.attributes.instanceStart, t = this.attributes.instanceEnd; e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), WR.setFromBufferAttribute(t), this.boundingBox.union(WR)) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new _i), this.boundingBox === null && this.computeBoundingBox(); const e = this.attributes.instanceStart, t = this.attributes.instanceEnd; if (e !== void 0 && t !== void 0) { const r = this.boundingSphere.center; this.boundingBox.getCenter(r); let i = 0; for (let o = 0, s = e.count; o < s; o++)o0.fromBufferAttribute(e, o), i = Math.max(i, r.distanceToSquared(o0)), o0.fromBufferAttribute(t, o), i = Math.max(i, r.distanceToSquared(o0)); this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } applyMatrix(e) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e) } } class pF extends gw { constructor() { super(), this.isLineGeometry = !0, this.type = "LineGeometry" } setPositions(e) { const t = e.length - 3, r = new Float32Array(2 * t); for (let i = 0; i < t; i += 3)r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5]; return super.setPositions(r), this } setColors(e) { const t = e.length - 3, r = new Float32Array(2 * t); for (let i = 0; i < t; i += 3)r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5]; return super.setColors(r), this } fromLine(e) { const t = e.geometry; return this.setPositions(t.attributes.position.array), this } } class vw extends _r {
	constructor(e) {
		super({
			type: "LineMaterial", uniforms: _a.clone(_a.merge([et.common, et.fog, { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new Be(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }])), vertexShader: `
				#include <common>
				#include <color_pars_vertex>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				attribute vec3 instanceColorStart;
				attribute vec3 instanceColorEnd;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`, fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <color_pars_fragment>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );

					#include <logdepthbuf_fragment>
					#include <color_fragment>

					gl_FragColor = vec4( diffuseColor.rgb, alpha );

					#include <tonemapping_fragment>
					#include <${parseInt(Qc.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`, clipping: !0
		}), this.isLineMaterial = !0, Object.defineProperties(this, { color: { enumerable: !0, get: function () { return this.uniforms.diffuse.value }, set: function (t) { this.uniforms.diffuse.value = t } }, worldUnits: { enumerable: !0, get: function () { return "WORLD_UNITS" in this.defines }, set: function (t) { t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS } }, linewidth: { enumerable: !0, get: function () { return this.uniforms.linewidth.value }, set: function (t) { this.uniforms.linewidth.value = t } }, dashed: { enumerable: !0, get: function () { return "USE_DASH" in this.defines }, set(t) { !!t != "USE_DASH" in this.defines && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH } }, dashScale: { enumerable: !0, get: function () { return this.uniforms.dashScale.value }, set: function (t) { this.uniforms.dashScale.value = t } }, dashSize: { enumerable: !0, get: function () { return this.uniforms.dashSize.value }, set: function (t) { this.uniforms.dashSize.value = t } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (t) { this.uniforms.dashOffset.value = t } }, gapSize: { enumerable: !0, get: function () { return this.uniforms.gapSize.value }, set: function (t) { this.uniforms.gapSize.value = t } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (t) { this.uniforms.opacity.value = t } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (t) { this.uniforms.resolution.value.copy(t) } }, alphaToCoverage: { enumerable: !0, get: function () { return "USE_ALPHA_TO_COVERAGE" in this.defines }, set: function (t) { !!t != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1) } } }), this.setValues(e)
	}
} const jR = new X, XR = new X, Mr = new Ft, wr = new Ft, hs = new Ft, Dx = new X, Ox = new _t, Xr = new UO, JR = new X, s0 = new yi, a0 = new _i, ps = new Ft; let xs, YA, mF, Lc; function KR(n, e, t) { return ps.set(0, 0, -e, 1).applyMatrix4(n.projectionMatrix), ps.multiplyScalar(1 / ps.w), ps.x = Lc / t.width, ps.y = Lc / t.height, ps.applyMatrix4(n.projectionMatrixInverse), ps.multiplyScalar(1 / ps.w), Math.abs(Math.max(ps.x, ps.y)) } function U7(n, e) { for (let t = 0, r = YA.count; t < r; t++) { Xr.start.fromBufferAttribute(YA, t), Xr.end.fromBufferAttribute(mF, t); const i = new X, o = new X; xs.distanceSqToSegment(Xr.start, Xr.end, o, i), o.distanceTo(i) < Lc * .5 && e.push({ point: o, pointOnLine: i, distance: xs.origin.distanceTo(o), object: n, face: null, faceIndex: t, uv: null, uv2: null }) } } function k7(n, e, t) { const r = e.projectionMatrix, o = n.material.resolution, s = n.matrixWorld, a = n.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, u = -e.near; xs.at(1, hs), hs.w = 1, hs.applyMatrix4(e.matrixWorldInverse), hs.applyMatrix4(r), hs.multiplyScalar(1 / hs.w), hs.x *= o.x / 2, hs.y *= o.y / 2, hs.z = 0, Dx.copy(hs), Ox.multiplyMatrices(e.matrixWorldInverse, s); for (let d = 0, p = l.count; d < p; d++) { if (Mr.fromBufferAttribute(l, d), wr.fromBufferAttribute(c, d), Mr.w = 1, wr.w = 1, Mr.applyMatrix4(Ox), wr.applyMatrix4(Ox), Mr.z > u && wr.z > u) continue; if (Mr.z > u) { const x = Mr.z - wr.z, A = (Mr.z - u) / x; Mr.lerp(wr, A) } else if (wr.z > u) { const x = wr.z - Mr.z, A = (wr.z - u) / x; wr.lerp(Mr, A) } Mr.applyMatrix4(r), wr.applyMatrix4(r), Mr.multiplyScalar(1 / Mr.w), wr.multiplyScalar(1 / wr.w), Mr.x *= o.x / 2, Mr.y *= o.y / 2, wr.x *= o.x / 2, wr.y *= o.y / 2, Xr.start.copy(Mr), Xr.start.z = 0, Xr.end.copy(wr), Xr.end.z = 0; const v = Xr.closestPointToPointParameter(Dx, !0); Xr.at(v, JR); const y = Up.lerp(Mr.z, wr.z, v), _ = y >= -1 && y <= 1, g = Dx.distanceTo(JR) < Lc * .5; if (_ && g) { Xr.start.fromBufferAttribute(l, d), Xr.end.fromBufferAttribute(c, d), Xr.start.applyMatrix4(s), Xr.end.applyMatrix4(s); const x = new X, A = new X; xs.distanceSqToSegment(Xr.start, Xr.end, A, x), t.push({ point: A, pointOnLine: x, distance: xs.origin.distanceTo(A), object: n, face: null, faceIndex: d, uv: null, uv2: null }) } } } class gF extends In { constructor(e = new gw, t = new vw({ color: Math.random() * 16777215 })) { super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2" } computeLineDistances() { const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, i = new Float32Array(2 * t.count); for (let s = 0, a = 0, l = t.count; s < l; s++, a += 2)jR.fromBufferAttribute(t, s), XR.fromBufferAttribute(r, s), i[a] = a === 0 ? 0 : i[a - 1], i[a + 1] = i[a] + jR.distanceTo(XR); const o = new wv(i, 2, 1); return e.setAttribute("instanceDistanceStart", new Bi(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new Bi(o, 1, 1)), this } raycast(e, t) { const r = this.material.worldUnits, i = e.camera; i === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'); const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0; xs = e.ray; const s = this.matrixWorld, a = this.geometry, l = this.material; Lc = l.linewidth + o, YA = a.attributes.instanceStart, mF = a.attributes.instanceEnd, a.boundingSphere === null && a.computeBoundingSphere(), a0.copy(a.boundingSphere).applyMatrix4(s); let c; if (r) c = Lc * .5; else { const d = Math.max(i.near, a0.distanceToPoint(xs.origin)); c = KR(i, d, l.resolution) } if (a0.radius += c, xs.intersectsSphere(a0) === !1) return; a.boundingBox === null && a.computeBoundingBox(), s0.copy(a.boundingBox).applyMatrix4(s); let u; if (r) u = Lc * .5; else { const d = Math.max(i.near, s0.distanceToPoint(xs.origin)); u = KR(i, d, l.resolution) } s0.expandByScalar(u), xs.intersectsBox(s0) !== !1 && (r ? U7(this, t) : k7(this, i, t)) } } class N7 extends gF { constructor(e = new pF, t = new vw({ color: Math.random() * 16777215 })) { super(e, t), this.isLine2 = !0, this.type = "Line2" } } let l0; const Fx = () => { if (l0) return l0; const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), r = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if (typeof WebAssembly != "object") return { supported: !1 }; let i = n; WebAssembly.validate(t) && (i = e); let o; const s = WebAssembly.instantiate(a(i), {}).then(d => { o = d.instance, o.exports.__wasm_call_ctors() }); function a(d) { const p = new Uint8Array(d.length); for (let v = 0; v < d.length; ++v) { const y = d.charCodeAt(v); p[v] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62 } let m = 0; for (let v = 0; v < d.length; ++v)p[m++] = p[v] < 60 ? r[p[v]] : (p[v] - 60) * 64 + p[++v]; return p.buffer.slice(0, m) } function l(d, p, m, v, y, _) { const g = o.exports.sbrk, x = m + 3 & -4, A = g(x * v), E = g(y.length), w = new Uint8Array(o.exports.memory.buffer); w.set(y, E); const b = d(A, m, v, E, y.length); if (b === 0 && _ && _(A, x, v), p.set(w.subarray(A, A + m * v)), g(A - g(0)), b !== 0) throw new Error(`Malformed buffer data: ${b}`) } const c = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, u = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return l0 = { ready: s, supported: !0, decodeVertexBuffer(d, p, m, v, y) { l(o.exports.meshopt_decodeVertexBuffer, d, p, m, v, o.exports[c[y]]) }, decodeIndexBuffer(d, p, m, v) { l(o.exports.meshopt_decodeIndexBuffer, d, p, m, v) }, decodeIndexSequence(d, p, m, v) { l(o.exports.meshopt_decodeIndexSequence, d, p, m, v) }, decodeGltfBuffer(d, p, m, v, y, _) { l(o.exports[u[y]], d, p, m, v, o.exports[c[_]]) } }, l0 }, Ka = N.forwardRef(function ({ points: e, color: t = "black", vertexColors: r, linewidth: i, lineWidth: o, segments: s, dashed: a, ...l }, c) { const u = Yi(v => v.size), d = N.useMemo(() => s ? new gF : new N7, [s]), [p] = N.useState(() => new vw), m = N.useMemo(() => { const v = s ? new gw : new pF, y = e.map(_ => { const g = Array.isArray(_); return _ instanceof X ? [_.x, _.y, _.z] : _ instanceof Be ? [_.x, _.y, 0] : g && _.length === 3 ? [_[0], _[1], _[2]] : g && _.length === 2 ? [_[0], _[1], 0] : _ }); if (v.setPositions(y.flat()), r) { const _ = r.map(g => g instanceof qe ? g.toArray() : g); v.setColors(_.flat()) } return v }, [e, s, r]); return N.useLayoutEffect(() => { d.computeLineDistances() }, [e, d]), N.useLayoutEffect(() => { a ? p.defines.USE_DASH = "" : delete p.defines.USE_DASH, p.needsUpdate = !0 }, [a, p]), N.useEffect(() => () => m.dispose(), [m]), N.createElement("primitive", Ee({ object: d, ref: c }, l), N.createElement("primitive", { object: m, attach: "geometry" }), N.createElement("primitive", Ee({ object: p, attach: "material", color: t, vertexColors: !!r, resolution: [u.width, u.height], linewidth: i ?? o, dashed: a }, l))) }); function z7() {
	var n = Object.create(null); function e(i, o) { var s = i.id, a = i.name, l = i.dependencies; l === void 0 && (l = []); var c = i.init; c === void 0 && (c = function () { }); var u = i.getTransferables; if (u === void 0 && (u = null), !n[s]) try { l = l.map(function (p) { return p && p.isWorkerModule && (e(p, function (m) { if (m instanceof Error) throw m }), p = n[p.id].value), p }), c = r("<" + a + ">.init", c), u && (u = r("<" + a + ">.getTransferables", u)); var d = null; typeof c == "function" ? d = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), n[s] = { id: s, value: d, getTransferables: u }, o(d) } catch (p) { p && p.noLog || console.error(p), o(p) } } function t(i, o) { var s, a = i.id, l = i.args; (!n[a] || typeof n[a].value != "function") && o(new Error("Worker module " + a + ": not found or its 'init' did not return a function")); try { var c = (s = n[a]).value.apply(s, l); c && typeof c.then == "function" ? c.then(u, function (d) { return o(d instanceof Error ? d : new Error("" + d)) }) : u(c) } catch (d) { o(d) } function u(d) { try { var p = n[a].getTransferables && n[a].getTransferables(d); (!p || !Array.isArray(p) || !p.length) && (p = void 0), o(d, p) } catch (m) { console.error(m), o(m) } } } function r(i, o) {
		var s = void 0; self.troikaDefine = function (l) { return s = l }; var a = URL.createObjectURL(new Blob(["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
`+ o + `
)`], { type: "application/javascript" })); try { importScripts(a) } catch (l) { console.error(l) } return URL.revokeObjectURL(a), delete self.troikaDefine, s
	} self.addEventListener("message", function (i) { var o = i.data, s = o.messageId, a = o.action, l = o.data; try { a === "registerModule" && e(l, function (c) { c instanceof Error ? postMessage({ messageId: s, success: !1, error: c.message }) : postMessage({ messageId: s, success: !0, result: { isCallable: typeof c == "function" } }) }), a === "callModule" && t(l, function (c, u) { c instanceof Error ? postMessage({ messageId: s, success: !1, error: c.message }) : postMessage({ messageId: s, success: !0, result: c }, u || void 0) }) } catch (c) { postMessage({ messageId: s, success: !1, error: c.stack }) } })
} function G7(n) { var e = function () { for (var t = [], r = arguments.length; r--;)t[r] = arguments[r]; return e._getInitResult().then(function (i) { if (typeof i == "function") return i.apply(void 0, t); throw new Error("Worker module function was called but `init` did not return a callable function") }) }; return e._getInitResult = function () { var t = n.dependencies, r = n.init; t = Array.isArray(t) ? t.map(function (o) { return o && o._getInitResult ? o._getInitResult() : o }) : []; var i = Promise.all(t).then(function (o) { return r.apply(null, o) }); return e._getInitResult = function () { return i }, i }, e } var vF = function () { var n = !1; if (typeof window < "u" && typeof window.document < "u") try { var e = new Worker(URL.createObjectURL(new Blob([""], { type: "application/javascript" }))); e.terminate(), n = !0 } catch (t) { typeof process < "u", console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]") } return vF = function () { return n }, n }, H7 = 0, V7 = 0, Ux = !1, Ih = Object.create(null), Lh = Object.create(null), $A = Object.create(null); function $p(n) {
	if ((!n || typeof n.init != "function") && !Ux) throw new Error("requires `options.init` function"); var e = n.dependencies, t = n.init, r = n.getTransferables, i = n.workerId; if (!vF()) return G7(n); i == null && (i = "#default"); var o = "workerModule" + ++H7, s = n.name || o, a = null; e = e && e.map(function (c) {
		return typeof c == "function" && !c.workerModuleData && (Ux = !0, c = $p({
			workerId: i, name: "<" + s + "> function dependency: " + c.name, init: `function(){return (
`+ N0(c) + `
)}`}), Ux = !1), c && c.workerModuleData && (c = c.workerModuleData), c
	}); function l() { for (var c = [], u = arguments.length; u--;)c[u] = arguments[u]; if (!a) { a = YR(i, "registerModule", l.workerModuleData); var d = function () { a = null, Lh[i].delete(d) }; (Lh[i] || (Lh[i] = new Set)).add(d) } return a.then(function (p) { var m = p.isCallable; if (m) return YR(i, "callModule", { id: o, args: c }); throw new Error("Worker module function was called but `init` did not return a callable function") }) } return l.workerModuleData = { isWorkerModule: !0, id: o, name: s, dependencies: e, init: N0(t), getTransferables: r && N0(r) }, l
} function W7(n) { Lh[n] && Lh[n].forEach(function (e) { e() }), Ih[n] && (Ih[n].terminate(), delete Ih[n]) } function N0(n) { var e = n.toString(); return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e } function j7(n) {
	var e = Ih[n]; if (!e) {
		var t = N0(z7); e = Ih[n] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + n.replace(/\*/g, "") + ` **/

;(`+ t + ")()"], { type: "application/javascript" }))), e.onmessage = function (r) { var i = r.data, o = i.messageId, s = $A[o]; if (!s) throw new Error("WorkerModule response with empty or unknown messageId"); delete $A[o], s(i) }
	} return e
} function YR(n, e, t) { return new Promise(function (r, i) { var o = ++V7; $A[o] = function (s) { s.success ? r(s.result) : i(new Error("Error in worker " + e + " call: " + s.error)) }, j7(n).postMessage({ messageId: o, action: e, data: t }) }) } function yF() { var n = function (e) { function t(V, J, O, k, Z, ee, ne, K) { var ae = 1 - ne; K.x = ae * ae * V + 2 * ae * ne * O + ne * ne * Z, K.y = ae * ae * J + 2 * ae * ne * k + ne * ne * ee } function r(V, J, O, k, Z, ee, ne, K, ae, ie) { var Se = 1 - ae; ie.x = Se * Se * Se * V + 3 * Se * Se * ae * O + 3 * Se * ae * ae * Z + ae * ae * ae * ne, ie.y = Se * Se * Se * J + 3 * Se * Se * ae * k + 3 * Se * ae * ae * ee + ae * ae * ae * K } function i(V, J) { for (var O = /([MLQCZ])([^MLQCZ]*)/g, k, Z, ee, ne, K; k = O.exec(V);) { var ae = k[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function (ie) { return parseFloat(ie) }); switch (k[1]) { case "M": ne = Z = ae[0], K = ee = ae[1]; break; case "L": (ae[0] !== ne || ae[1] !== K) && J("L", ne, K, ne = ae[0], K = ae[1]); break; case "Q": { J("Q", ne, K, ne = ae[2], K = ae[3], ae[0], ae[1]); break } case "C": { J("C", ne, K, ne = ae[4], K = ae[5], ae[0], ae[1], ae[2], ae[3]); break } case "Z": (ne !== Z || K !== ee) && J("L", ne, K, Z, ee); break } } } function o(V, J, O) { O === void 0 && (O = 16); var k = { x: 0, y: 0 }; i(V, function (Z, ee, ne, K, ae, ie, Se, Ce, le) { switch (Z) { case "L": J(ee, ne, K, ae); break; case "Q": { for (var F = ee, me = ne, he = 1; he < O; he++)t(ee, ne, ie, Se, K, ae, he / (O - 1), k), J(F, me, k.x, k.y), F = k.x, me = k.y; break } case "C": { for (var ce = ee, fe = ne, Re = 1; Re < O; Re++)r(ee, ne, ie, Se, Ce, le, K, ae, Re / (O - 1), k), J(ce, fe, k.x, k.y), ce = k.x, fe = k.y; break } } }) } var s = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", a = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", l = new WeakMap, c = { premultipliedAlpha: !1, preserveDrawingBuffer: !0, antialias: !1, depth: !1 }; function u(V, J) { var O = V.getContext ? V.getContext("webgl", c) : V, k = l.get(O); if (!k) { let ce = function (ge) { var Ve = ee[ge]; if (!Ve && (Ve = ee[ge] = O.getExtension(ge), !Ve)) throw new Error(ge + " not supported"); return Ve }, fe = function (ge, Ve) { var H = O.createShader(Ve); return O.shaderSource(H, ge), O.compileShader(H), H }, Re = function (ge, Ve, H, L) { if (!ne[ge]) { var oe = {}, Pe = {}, Ae = O.createProgram(); O.attachShader(Ae, fe(Ve, O.VERTEX_SHADER)), O.attachShader(Ae, fe(H, O.FRAGMENT_SHADER)), O.linkProgram(Ae), ne[ge] = { program: Ae, transaction: function (be) { O.useProgram(Ae), be({ setUniform: function (He, je) { for (var nt = [], Te = arguments.length - 2; Te-- > 0;)nt[Te] = arguments[Te + 2]; var Je = Pe[je] || (Pe[je] = O.getUniformLocation(Ae, je)); O["uniform" + He].apply(O, [Je].concat(nt)) }, setAttribute: function (He, je, nt, Te, Je) { var re = oe[He]; re || (re = oe[He] = { buf: O.createBuffer(), loc: O.getAttribLocation(Ae, He), data: null }), O.bindBuffer(O.ARRAY_BUFFER, re.buf), O.vertexAttribPointer(re.loc, je, O.FLOAT, !1, 0, 0), O.enableVertexAttribArray(re.loc), Z ? O.vertexAttribDivisor(re.loc, Te) : ce("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(re.loc, Te), Je !== re.data && (O.bufferData(O.ARRAY_BUFFER, Je, nt), re.data = Je) } }) } } } ne[ge].transaction(L) }, de = function (ge, Ve) { ae++; try { O.activeTexture(O.TEXTURE0 + ae); var H = K[ge]; H || (H = K[ge] = O.createTexture(), O.bindTexture(O.TEXTURE_2D, H), O.texParameteri(O.TEXTURE_2D, O.TEXTURE_MIN_FILTER, O.NEAREST), O.texParameteri(O.TEXTURE_2D, O.TEXTURE_MAG_FILTER, O.NEAREST)), O.bindTexture(O.TEXTURE_2D, H), Ve(H, ae) } finally { ae-- } }, Ie = function (ge, Ve, H) { var L = O.createFramebuffer(); ie.push(L), O.bindFramebuffer(O.FRAMEBUFFER, L), O.activeTexture(O.TEXTURE0 + Ve), O.bindTexture(O.TEXTURE_2D, ge), O.framebufferTexture2D(O.FRAMEBUFFER, O.COLOR_ATTACHMENT0, O.TEXTURE_2D, ge, 0); try { H(L) } finally { O.deleteFramebuffer(L), O.bindFramebuffer(O.FRAMEBUFFER, ie[--ie.length - 1] || null) } }, we = function () { ee = {}, ne = {}, K = {}, ae = -1, ie.length = 0 }; var Se = ce, Ce = fe, le = Re, F = de, me = Ie, he = we, Z = typeof WebGL2RenderingContext < "u" && O instanceof WebGL2RenderingContext, ee = {}, ne = {}, K = {}, ae = -1, ie = []; O.canvas.addEventListener("webglcontextlost", function (ge) { we(), ge.preventDefault() }, !1), l.set(O, k = { gl: O, isWebGL2: Z, getExtension: ce, withProgram: Re, withTexture: de, withTextureFramebuffer: Ie, handleContextLoss: we }) } J(k) } function d(V, J, O, k, Z, ee, ne, K) { ne === void 0 && (ne = 15), K === void 0 && (K = null), u(V, function (ae) { var ie = ae.gl, Se = ae.withProgram, Ce = ae.withTexture; Ce("copy", function (le, F) { ie.texImage2D(ie.TEXTURE_2D, 0, ie.RGBA, Z, ee, 0, ie.RGBA, ie.UNSIGNED_BYTE, J), Se("copy", s, a, function (me) { var he = me.setUniform, ce = me.setAttribute; ce("aUV", 2, ie.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), he("1i", "image", F), ie.bindFramebuffer(ie.FRAMEBUFFER, K || null), ie.disable(ie.BLEND), ie.colorMask(ne & 8, ne & 4, ne & 2, ne & 1), ie.viewport(O, k, Z, ee), ie.scissor(O, k, Z, ee), ie.drawArrays(ie.TRIANGLES, 0, 3) }) }) }) } function p(V, J, O) { var k = V.width, Z = V.height; u(V, function (ee) { var ne = ee.gl, K = new Uint8Array(k * Z * 4); ne.readPixels(0, 0, k, Z, ne.RGBA, ne.UNSIGNED_BYTE, K), V.width = J, V.height = O, d(ne, K, 0, 0, k, Z) }) } var m = Object.freeze({ __proto__: null, withWebGLContext: u, renderImageData: d, resizeWebGLCanvasWithoutClearing: p }); function v(V, J, O, k, Z, ee) { ee === void 0 && (ee = 1); var ne = new Uint8Array(V * J), K = k[2] - k[0], ae = k[3] - k[1], ie = []; o(O, function (ce, fe, Re, de) { ie.push({ x1: ce, y1: fe, x2: Re, y2: de, minX: Math.min(ce, Re), minY: Math.min(fe, de), maxX: Math.max(ce, Re), maxY: Math.max(fe, de) }) }), ie.sort(function (ce, fe) { return ce.maxX - fe.maxX }); for (var Se = 0; Se < V; Se++)for (var Ce = 0; Ce < J; Ce++) { var le = me(k[0] + K * (Se + .5) / V, k[1] + ae * (Ce + .5) / J), F = Math.pow(1 - Math.abs(le) / Z, ee) / 2; le < 0 && (F = 1 - F), F = Math.max(0, Math.min(255, Math.round(F * 255))), ne[Ce * V + Se] = F } return ne; function me(ce, fe) { for (var Re = 1 / 0, de = 1 / 0, Ie = ie.length; Ie--;) { var we = ie[Ie]; if (we.maxX + de <= ce) break; if (ce + de > we.minX && fe - de < we.maxY && fe + de > we.minY) { var ge = g(ce, fe, we.x1, we.y1, we.x2, we.y2); ge < Re && (Re = ge, de = Math.sqrt(Re)) } } return he(ce, fe) && (de = -de), de } function he(ce, fe) { for (var Re = 0, de = ie.length; de--;) { var Ie = ie[de]; if (Ie.maxX <= ce) break; var we = Ie.y1 > fe != Ie.y2 > fe && ce < (Ie.x2 - Ie.x1) * (fe - Ie.y1) / (Ie.y2 - Ie.y1) + Ie.x1; we && (Re += Ie.y1 < Ie.y2 ? 1 : -1) } return Re !== 0 } } function y(V, J, O, k, Z, ee, ne, K, ae, ie) { ee === void 0 && (ee = 1), K === void 0 && (K = 0), ae === void 0 && (ae = 0), ie === void 0 && (ie = 0), _(V, J, O, k, Z, ee, ne, null, K, ae, ie) } function _(V, J, O, k, Z, ee, ne, K, ae, ie, Se) { ee === void 0 && (ee = 1), ae === void 0 && (ae = 0), ie === void 0 && (ie = 0), Se === void 0 && (Se = 0); for (var Ce = v(V, J, O, k, Z, ee), le = new Uint8Array(Ce.length * 4), F = 0; F < Ce.length; F++)le[F * 4 + Se] = Ce[F]; d(ne, le, ae, ie, V, J, 1 << 3 - Se, K) } function g(V, J, O, k, Z, ee) { var ne = Z - O, K = ee - k, ae = ne * ne + K * K, ie = ae ? Math.max(0, Math.min(1, ((V - O) * ne + (J - k) * K) / ae)) : 0, Se = V - (O + ie * ne), Ce = J - (k + ie * K); return Se * Se + Ce * Ce } var x = Object.freeze({ __proto__: null, generate: v, generateIntoCanvas: y, generateIntoFramebuffer: _ }), A = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", E = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", w = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", b = new Float32Array([0, 0, 2, 0, 0, 2]), T = null, B = !1, R = {}, P = new WeakMap; function U(V) { if (!B && !j(V)) throw new Error("WebGL generation not supported") } function G(V, J, O, k, Z, ee, ne) { if (ee === void 0 && (ee = 1), ne === void 0 && (ne = null), !ne && (ne = T, !ne)) { var K = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null; if (!K) throw new Error("OffscreenCanvas or DOM canvas not supported"); ne = T = K.getContext("webgl", { depth: !1 }) } U(ne); var ae = new Uint8Array(V * J * 4); u(ne, function (le) { var F = le.gl, me = le.withTexture, he = le.withTextureFramebuffer; me("readable", function (ce, fe) { F.texImage2D(F.TEXTURE_2D, 0, F.RGBA, V, J, 0, F.RGBA, F.UNSIGNED_BYTE, null), he(ce, fe, function (Re) { z(V, J, O, k, Z, ee, F, Re, 0, 0, 0), F.readPixels(0, 0, V, J, F.RGBA, F.UNSIGNED_BYTE, ae) }) }) }); for (var ie = new Uint8Array(V * J), Se = 0, Ce = 0; Se < ae.length; Se += 4)ie[Ce++] = ae[Se]; return ie } function $(V, J, O, k, Z, ee, ne, K, ae, ie) { ee === void 0 && (ee = 1), K === void 0 && (K = 0), ae === void 0 && (ae = 0), ie === void 0 && (ie = 0), z(V, J, O, k, Z, ee, ne, null, K, ae, ie) } function z(V, J, O, k, Z, ee, ne, K, ae, ie, Se) { ee === void 0 && (ee = 1), ae === void 0 && (ae = 0), ie === void 0 && (ie = 0), Se === void 0 && (Se = 0), U(ne); var Ce = []; o(O, function (le, F, me, he) { Ce.push(le, F, me, he) }), Ce = new Float32Array(Ce), u(ne, function (le) { var F = le.gl, me = le.isWebGL2, he = le.getExtension, ce = le.withProgram, fe = le.withTexture, Re = le.withTextureFramebuffer, de = le.handleContextLoss; if (fe("rawDistances", function (Ie, we) { (V !== Ie._lastWidth || J !== Ie._lastHeight) && F.texImage2D(F.TEXTURE_2D, 0, F.RGBA, Ie._lastWidth = V, Ie._lastHeight = J, 0, F.RGBA, F.UNSIGNED_BYTE, null), ce("main", A, E, function (ge) { var Ve = ge.setAttribute, H = ge.setUniform, L = !me && he("ANGLE_instanced_arrays"), oe = !me && he("EXT_blend_minmax"); Ve("aUV", 2, F.STATIC_DRAW, 0, b), Ve("aLineSegment", 4, F.DYNAMIC_DRAW, 1, Ce), H.apply(void 0, ["4f", "uGlyphBounds"].concat(k)), H("1f", "uMaxDistance", Z), H("1f", "uExponent", ee), Re(Ie, we, function (Pe) { F.enable(F.BLEND), F.colorMask(!0, !0, !0, !0), F.viewport(0, 0, V, J), F.scissor(0, 0, V, J), F.blendFunc(F.ONE, F.ONE), F.blendEquationSeparate(F.FUNC_ADD, me ? F.MAX : oe.MAX_EXT), F.clear(F.COLOR_BUFFER_BIT), me ? F.drawArraysInstanced(F.TRIANGLES, 0, 3, Ce.length / 4) : L.drawArraysInstancedANGLE(F.TRIANGLES, 0, 3, Ce.length / 4) }) }), ce("post", s, w, function (ge) { ge.setAttribute("aUV", 2, F.STATIC_DRAW, 0, b), ge.setUniform("1i", "tex", we), F.bindFramebuffer(F.FRAMEBUFFER, K), F.disable(F.BLEND), F.colorMask(Se === 0, Se === 1, Se === 2, Se === 3), F.viewport(ae, ie, V, J), F.scissor(ae, ie, V, J), F.drawArrays(F.TRIANGLES, 0, 3) }) }), F.isContextLost()) throw de(), new Error("webgl context lost") }) } function j(V) { var J = !V || V === T ? R : V.canvas || V, O = P.get(J); if (O === void 0) { B = !0; var k = null; try { var Z = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97], ee = G(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, V); O = ee && Z.length === ee.length && ee.every(function (ne, K) { return ne === Z[K] }), O || (k = "bad trial run results", console.info(Z, ee)) } catch (ne) { O = !1, k = ne.message } k && console.warn("WebGL SDF generation not supported:", k), B = !1, P.set(J, O) } return O } var q = Object.freeze({ __proto__: null, generate: G, generateIntoCanvas: $, generateIntoFramebuffer: z, isSupported: j }); function se(V, J, O, k, Z, ee) { Z === void 0 && (Z = Math.max(k[2] - k[0], k[3] - k[1]) / 2), ee === void 0 && (ee = 1); try { return G.apply(q, arguments) } catch (ne) { return console.info("WebGL SDF generation failed, falling back to JS", ne), v.apply(x, arguments) } } function W(V, J, O, k, Z, ee, ne, K, ae, ie) { Z === void 0 && (Z = Math.max(k[2] - k[0], k[3] - k[1]) / 2), ee === void 0 && (ee = 1), K === void 0 && (K = 0), ae === void 0 && (ae = 0), ie === void 0 && (ie = 0); try { return $.apply(q, arguments) } catch (Se) { return console.info("WebGL SDF generation failed, falling back to JS", Se), y.apply(x, arguments) } } return e.forEachPathCommand = i, e.generate = se, e.generateIntoCanvas = W, e.javascript = x, e.pathToLineSegments = o, e.webgl = q, e.webglUtils = m, Object.defineProperty(e, "__esModule", { value: !0 }), e }({}); return n } function X7() { var n = function (e) { var t = { R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73", EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9", ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2", ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj", AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u", CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b", B: "a,3,f+2,2v,690", S: "9,2,k", WS: "c,k,4f4,1vk+a,u,1j,335", ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i", BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1", NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n", AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d", LRO: "6ct", RLO: "6cu", LRE: "6cq", RLE: "6cr", PDF: "6cs", LRI: "6ee", RLI: "6ef", FSI: "6eg", PDI: "6eh" }, r = {}, i = {}; r.L = 1, i[1] = "L", Object.keys(t).forEach(function (de, Ie) { r[de] = 1 << Ie + 1, i[r[de]] = de }), Object.freeze(r); var o = r.LRI | r.RLI | r.FSI, s = r.L | r.R | r.AL, a = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, l = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, c = r.S | r.WS | r.B | o | r.PDI | l, u = null; function d() { if (!u) { u = new Map; var de = function (we) { if (t.hasOwnProperty(we)) { var ge = 0; t[we].split(",").forEach(function (Ve) { var H = Ve.split("+"), L = H[0], oe = H[1]; L = parseInt(L, 36), oe = oe ? parseInt(oe, 36) : 0, u.set(ge += L, r[we]); for (var Pe = 0; Pe < oe; Pe++)u.set(++ge, r[we]) }) } }; for (var Ie in t) de(Ie) } } function p(de) { return d(), u.get(de.codePointAt(0)) || r.L } function m(de) { return i[p(de)] } var v = { pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1", canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye" }; function y(de, Ie) { var we = 36, ge = 0, Ve = new Map, H = Ie && new Map, L; return de.split(",").forEach(function oe(Pe) { if (Pe.indexOf("+") !== -1) for (var Ae = +Pe; Ae--;)oe(L); else { L = Pe; var ye = Pe.split(">"), be = ye[0], ke = ye[1]; be = String.fromCodePoint(ge += parseInt(be, we)), ke = String.fromCodePoint(ge += parseInt(ke, we)), Ve.set(be, ke), Ie && H.set(ke, be) } }), { map: Ve, reverseMap: H } } var _, g, x; function A() { if (!_) { var de = y(v.pairs, !0), Ie = de.map, we = de.reverseMap; _ = Ie, g = we, x = y(v.canonical, !1).map } } function E(de) { return A(), _.get(de) || null } function w(de) { return A(), g.get(de) || null } function b(de) { return A(), x.get(de) || null } var T = r.L, B = r.R, R = r.EN, P = r.ES, U = r.ET, G = r.AN, $ = r.CS, z = r.B, j = r.S, q = r.ON, se = r.BN, W = r.NSM, V = r.AL, J = r.LRO, O = r.RLO, k = r.LRE, Z = r.RLE, ee = r.PDF, ne = r.LRI, K = r.RLI, ae = r.FSI, ie = r.PDI; function Se(de, Ie) { for (var we = 125, ge = new Uint32Array(de.length), Ve = 0; Ve < de.length; Ve++)ge[Ve] = p(de[Ve]); var H = new Map; function L(pr, ai) { var Wn = ge[pr]; ge[pr] = ai, H.set(Wn, H.get(Wn) - 1), Wn & a && H.set(a, H.get(a) - 1), H.set(ai, (H.get(ai) || 0) + 1), ai & a && H.set(a, (H.get(a) || 0) + 1) } for (var oe = new Uint8Array(de.length), Pe = new Map, Ae = [], ye = null, be = 0; be < de.length; be++)ye || Ae.push(ye = { start: be, end: de.length - 1, level: Ie === "rtl" ? 1 : Ie === "ltr" ? 0 : au(be, !1) }), ge[be] & z && (ye.end = be, ye = null); for (var ke = Z | k | O | J | o | ie | ee | z, He = function (pr) { return pr + (pr & 1 ? 1 : 2) }, je = function (pr) { return pr + (pr & 1 ? 2 : 1) }, nt = 0; nt < Ae.length; nt++) { ye = Ae[nt]; var Te = [{ _level: ye.level, _override: 0, _isolate: 0 }], Je = void 0, re = 0, _e = 0, Ne = 0; H.clear(); for (var Y = ye.start; Y <= ye.end; Y++) { var Ue = ge[Y]; if (Je = Te[Te.length - 1], H.set(Ue, (H.get(Ue) || 0) + 1), Ue & a && H.set(a, (H.get(a) || 0) + 1), Ue & ke) if (Ue & (Z | k)) { oe[Y] = Je._level; var Ge = (Ue === Z ? je : He)(Je._level); Ge <= we && !re && !_e ? Te.push({ _level: Ge, _override: 0, _isolate: 0 }) : re || _e++ } else if (Ue & (O | J)) { oe[Y] = Je._level; var Ke = (Ue === O ? je : He)(Je._level); Ke <= we && !re && !_e ? Te.push({ _level: Ke, _override: Ue & O ? B : T, _isolate: 0 }) : re || _e++ } else if (Ue & o) { Ue & ae && (Ue = au(Y + 1, !0) === 1 ? K : ne), oe[Y] = Je._level, Je._override && L(Y, Je._override); var Qe = (Ue === K ? je : He)(Je._level); Qe <= we && re === 0 && _e === 0 ? (Ne++, Te.push({ _level: Qe, _override: 0, _isolate: 1, _isolInitIndex: Y })) : re++ } else if (Ue & ie) { if (re > 0) re--; else if (Ne > 0) { for (_e = 0; !Te[Te.length - 1]._isolate;)Te.pop(); var ze = Te[Te.length - 1]._isolInitIndex; ze != null && (Pe.set(ze, Y), Pe.set(Y, ze)), Te.pop(), Ne-- } Je = Te[Te.length - 1], oe[Y] = Je._level, Je._override && L(Y, Je._override) } else Ue & ee ? (re === 0 && (_e > 0 ? _e-- : !Je._isolate && Te.length > 1 && (Te.pop(), Je = Te[Te.length - 1])), oe[Y] = Je._level) : Ue & z && (oe[Y] = ye.level); else oe[Y] = Je._level, Je._override && Ue !== se && L(Y, Je._override) } for (var Ze = [], it = null, yt = ye.start; yt <= ye.end; yt++) { var Ct = ge[yt]; if (!(Ct & l)) { var At = oe[yt], xt = Ct & o, Yn = Ct === ie; it && At === it._level ? (it._end = yt, it._endsWithIsolInit = xt) : Ze.push(it = { _start: yt, _end: yt, _level: At, _startsWithPDI: Yn, _endsWithIsolInit: xt }) } } for (var $n = [], Dt = 0; Dt < Ze.length; Dt++) { var qt = Ze[Dt]; if (!qt._startsWithPDI || qt._startsWithPDI && !Pe.has(qt._start)) { for (var tn = [it = qt], Ht = void 0; it && it._endsWithIsolInit && (Ht = Pe.get(it._end)) != null;)for (var mn = Dt + 1; mn < Ze.length; mn++)if (Ze[mn]._start === Ht) { tn.push(it = Ze[mn]); break } for (var gn = [], Dr = 0; Dr < tn.length; Dr++)for (var dr = tn[Dr], Q = dr._start; Q <= dr._end; Q++)gn.push(Q); for (var ve = oe[gn[0]], De = ye.level, xe = gn[0] - 1; xe >= 0; xe--)if (!(ge[xe] & l)) { De = oe[xe]; break } var Oe = gn[gn.length - 1], ot = oe[Oe], dt = ye.level; if (!(ge[Oe] & o)) { for (var Ye = Oe + 1; Ye <= ye.end; Ye++)if (!(ge[Ye] & l)) { dt = oe[Ye]; break } } $n.push({ _seqIndices: gn, _sosType: Math.max(De, ve) % 2 ? B : T, _eosType: Math.max(dt, ot) % 2 ? B : T }) } } for (var lt = 0; lt < $n.length; lt++) { var Et = $n[lt], We = Et._seqIndices, pt = Et._sosType, ln = Et._eosType, jt = oe[We[0]] & 1 ? B : T; if (H.get(W)) for (var ir = 0; ir < We.length; ir++) { var Or = We[ir]; if (ge[Or] & W) { for (var Yt = pt, gt = ir - 1; gt >= 0; gt--)if (!(ge[We[gt]] & l)) { Yt = ge[We[gt]]; break } L(Or, Yt & (o | ie) ? q : Yt) } } if (H.get(R)) for (var zt = 0; zt < We.length; zt++) { var vt = We[zt]; if (ge[vt] & R) for (var Vn = zt - 1; Vn >= -1; Vn--) { var On = Vn === -1 ? pt : ge[We[Vn]]; if (On & s) { On === V && L(vt, G); break } } } if (H.get(V)) for (var En = 0; En < We.length; En++) { var xi = We[En]; ge[xi] & V && L(xi, B) } if (H.get(P) || H.get($)) for (var cn = 1; cn < We.length - 1; cn++) { var dn = We[cn]; if (ge[dn] & (P | $)) { for (var ri = 0, Qn = 0, is = cn - 1; is >= 0 && (ri = ge[We[is]], !!(ri & l)); is--); for (var os = cn + 1; os < We.length && (Qn = ge[We[os]], !!(Qn & l)); os++); ri === Qn && (ge[dn] === P ? ri === R : ri & (R | G)) && L(dn, ri) } } if (H.get(R)) for (var Fr = 0; Fr < We.length; Fr++) { var ki = We[Fr]; if (ge[ki] & R) { for (var ru = Fr - 1; ru >= 0 && ge[We[ru]] & (U | l); ru--)L(We[ru], R); for (Fr++; Fr < We.length && ge[We[Fr]] & (U | l | R); Fr++)ge[We[Fr]] !== R && L(We[Fr], R) } } if (H.get(U) || H.get(P) || H.get($)) for (var Ll = 0; Ll < We.length; Ll++) { var om = We[Ll]; if (ge[om] & (U | P | $)) { L(om, q); for (var zs = Ll - 1; zs >= 0 && ge[We[zs]] & l; zs--)L(We[zs], q); for (var Gs = Ll + 1; Gs < We.length && ge[We[Gs]] & l; Gs++)L(We[Gs], q) } } if (H.get(R)) for (var Hs = 0, Dl = pt; Hs < We.length; Hs++) { var sm = We[Hs], dd = ge[sm]; dd & R ? Dl === T && L(sm, T) : dd & s && (Dl = dd) } if (H.get(a)) { var Vs = B | R | G, iu = Vs | T, ss = []; { for (var Pa = [], as = 0; as < We.length; as++)if (ge[We[as]] & a) { var Ot = de[We[as]], hd = void 0; if (E(Ot) !== null) if (Pa.length < 63) Pa.push({ char: Ot, seqIndex: as }); else break; else if ((hd = w(Ot)) !== null) for (var Ws = Pa.length - 1; Ws >= 0; Ws--) { var ou = Pa[Ws].char; if (ou === hd || ou === w(b(Ot)) || E(b(ou)) === Ot) { ss.push([Pa[Ws].seqIndex, as]), Pa.length = Ws; break } } } ss.sort(function (pr, ai) { return pr[0] - ai[0] }) } for (var pd = 0; pd < ss.length; pd++) { for (var am = ss[pd], Tn = am[0], Ol = am[1], lm = !1, ii = 0, md = Tn + 1; md < Ol; md++) { var Fl = We[md]; if (ge[Fl] & iu) { lm = !0; var Ni = ge[Fl] & Vs ? B : T; if (Ni === jt) { ii = Ni; break } } } if (lm && !ii) { ii = pt; for (var gd = Tn - 1; gd >= 0; gd--) { var cm = We[gd]; if (ge[cm] & iu) { var zi = ge[cm] & Vs ? B : T; zi !== jt ? ii = zi : ii = jt; break } } } if (ii) { if (ge[We[Tn]] = ge[We[Ol]] = ii, ii !== jt) { for (var oi = Tn + 1; oi < We.length; oi++)if (!(ge[We[oi]] & l)) { p(de[We[oi]]) & W && (ge[We[oi]] = ii); break } } if (ii !== jt) { for (var ls = Ol + 1; ls < We.length; ls++)if (!(ge[We[ls]] & l)) { p(de[We[ls]]) & W && (ge[We[ls]] = ii); break } } } } for (var fo = 0; fo < We.length; fo++)if (ge[We[fo]] & a) { for (var vd = fo, yd = fo, Si = pt, Ul = fo - 1; Ul >= 0; Ul--)if (ge[We[Ul]] & l) vd = Ul; else { Si = ge[We[Ul]] & Vs ? B : T; break } for (var kl = ln, Nl = fo + 1; Nl < We.length; Nl++)if (ge[We[Nl]] & (a | l)) yd = Nl; else { kl = ge[We[Nl]] & Vs ? B : T; break } for (var si = vd; si <= yd; si++)ge[We[si]] = Si === kl ? Si : jt; fo = yd } } } for (var hr = ye.start; hr <= ye.end; hr++) { var su = oe[hr], Oo = ge[hr]; if (su & 1 ? Oo & (T | R | G) && oe[hr]++ : Oo & B ? oe[hr]++ : Oo & (G | R) && (oe[hr] += 2), Oo & l && (oe[hr] = hr === 0 ? ye.level : oe[hr - 1]), hr === ye.end || p(de[hr]) & (j | z)) for (var Ba = hr; Ba >= 0 && p(de[Ba]) & c; Ba--)oe[Ba] = ye.level } } return { levels: oe, paragraphs: Ae }; function au(pr, ai) { for (var Wn = pr; Wn < de.length; Wn++) { var jn = ge[Wn]; if (jn & (B | V)) return 1; if (jn & (z | T) || ai && jn === ie) return 0; if (jn & o) { var Gi = um(Wn); Wn = Gi === -1 ? de.length : Gi } } return 0 } function um(pr) { for (var ai = 1, Wn = pr + 1; Wn < de.length; Wn++) { var jn = ge[Wn]; if (jn & z) break; if (jn & ie) { if (--ai === 0) return Wn } else jn & o && ai++ } return -1 } } var Ce = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", le; function F() { if (!le) { var de = y(Ce, !0), Ie = de.map, we = de.reverseMap; we.forEach(function (ge, Ve) { Ie.set(Ve, ge) }), le = Ie } } function me(de) { return F(), le.get(de) || null } function he(de, Ie, we, ge) { var Ve = de.length; we = Math.max(0, we == null ? 0 : +we), ge = Math.min(Ve - 1, ge == null ? Ve - 1 : +ge); for (var H = new Map, L = we; L <= ge; L++)if (Ie[L] & 1) { var oe = me(de[L]); oe !== null && H.set(L, oe) } return H } function ce(de, Ie, we, ge) { var Ve = de.length; we = Math.max(0, we == null ? 0 : +we), ge = Math.min(Ve - 1, ge == null ? Ve - 1 : +ge); var H = []; return Ie.paragraphs.forEach(function (L) { var oe = Math.max(we, L.start), Pe = Math.min(ge, L.end); if (oe < Pe) { for (var Ae = Ie.levels.slice(oe, Pe + 1), ye = Pe; ye >= oe && p(de[ye]) & c; ye--)Ae[ye] = L.level; for (var be = L.level, ke = 1 / 0, He = 0; He < Ae.length; He++) { var je = Ae[He]; je > be && (be = je), je < ke && (ke = je | 1) } for (var nt = be; nt >= ke; nt--)for (var Te = 0; Te < Ae.length; Te++)if (Ae[Te] >= nt) { for (var Je = Te; Te + 1 < Ae.length && Ae[Te + 1] >= nt;)Te++; Te > Je && H.push([Je + oe, Te + oe]) } } }), H } function fe(de, Ie, we, ge) { var Ve = Re(de, Ie, we, ge), H = [].concat(de); return Ve.forEach(function (L, oe) { H[oe] = (Ie.levels[L] & 1 ? me(de[L]) : null) || de[L] }), H.join("") } function Re(de, Ie, we, ge) { for (var Ve = ce(de, Ie, we, ge), H = [], L = 0; L < de.length; L++)H[L] = L; return Ve.forEach(function (oe) { for (var Pe = oe[0], Ae = oe[1], ye = H.slice(Pe, Ae + 1), be = ye.length; be--;)H[Ae - be] = ye[be] }), H } return e.closingToOpeningBracket = w, e.getBidiCharType = p, e.getBidiCharTypeName = m, e.getCanonicalBracket = b, e.getEmbeddingLevels = Se, e.getMirroredCharacter = me, e.getMirroredCharactersMap = he, e.getReorderSegments = ce, e.getReorderedIndices = Re, e.getReorderedString = fe, e.openingToClosingBracket = E, Object.defineProperty(e, "__esModule", { value: !0 }), e }({}); return n } const _F = /\bvoid\s+main\s*\(\s*\)\s*{/g; function QA(n) { const e = /^[ \t]*#include +<([\w\d./]+)>/gm; function t(r, i) { let o = Tt[i]; return o ? QA(o) : r } return n.replace(e, t) } const br = []; for (let n = 0; n < 256; n++)br[n] = (n < 16 ? "0" : "") + n.toString(16); function J7() { const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0; return (br[n & 255] + br[n >> 8 & 255] + br[n >> 16 & 255] + br[n >> 24 & 255] + "-" + br[e & 255] + br[e >> 8 & 255] + "-" + br[e >> 16 & 15 | 64] + br[e >> 24 & 255] + "-" + br[t & 63 | 128] + br[t >> 8 & 255] + "-" + br[t >> 16 & 255] + br[t >> 24 & 255] + br[r & 255] + br[r >> 8 & 255] + br[r >> 16 & 255] + br[r >> 24 & 255]).toUpperCase() } const sc = Object.assign || function () { let n = arguments[0]; for (let e = 1, t = arguments.length; e < t; e++) { let r = arguments[e]; if (r) for (let i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]) } return n }, K7 = Date.now(), $R = new WeakMap, QR = new Map; let Y7 = 1e10; function ZA(n, e) { const t = q7(e); let r = $R.get(n); if (r || $R.set(n, r = Object.create(null)), r[t]) return new r[t]; const i = `_onBeforeCompile${t}`, o = function (c, u) { n.onBeforeCompile.call(this, c, u); const d = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader; let p = QR[d]; if (!p) { const m = $7(this, c, e, t); p = QR[d] = m } c.vertexShader = p.vertexShader, c.fragmentShader = p.fragmentShader, sc(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = { get value() { return Date.now() - K7 } }), this[i] && this[i](c) }, s = function () { return a(e.chained ? n : n.clone()) }, a = function (c) { const u = Object.create(c, l); return Object.defineProperty(u, "baseMaterial", { value: n }), Object.defineProperty(u, "id", { value: Y7++ }), u.uuid = J7(), u.uniforms = sc({}, c.uniforms, e.uniforms), u.defines = sc({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = sc({}, c.extensions, e.extensions), u._listeners = void 0, u }, l = { constructor: { value: s }, isDerivedMaterial: { value: !0 }, customProgramCacheKey: { writable: !0, configurable: !0, value: function () { return n.customProgramCacheKey() + "|" + t } }, onBeforeCompile: { get() { return o }, set(c) { this[i] = c } }, copy: { writable: !0, configurable: !0, value: function (c) { return n.copy.call(this, c), !n.isShaderMaterial && !n.isDerivedMaterial && (sc(this.extensions, c.extensions), sc(this.defines, c.defines), sc(this.uniforms, _a.clone(c.uniforms))), this } }, clone: { writable: !0, configurable: !0, value: function () { const c = new n.constructor; return a(c).copy(this) } }, getDepthMaterial: { writable: !0, configurable: !0, value: function () { let c = this._depthMaterial; return c || (c = this._depthMaterial = ZA(n.isDerivedMaterial ? n.getDepthMaterial() : new py({ depthPacking: LM }), e), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c } }, getDistanceMaterial: { writable: !0, configurable: !0, value: function () { let c = this._distanceMaterial; return c || (c = this._distanceMaterial = ZA(n.isDerivedMaterial ? n.getDistanceMaterial() : new my, e), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c } }, dispose: { writable: !0, configurable: !0, value() { const { _depthMaterial: c, _distanceMaterial: u } = this; c && c.dispose(), u && u.dispose(), n.dispose.call(this) } } }; return r[t] = s, new s } function $7(n, { vertexShader: e, fragmentShader: t }, r, i) {
	let { vertexDefs: o, vertexMainIntro: s, vertexMainOutro: a, vertexTransform: l, fragmentDefs: c, fragmentMainIntro: u, fragmentMainOutro: d, fragmentColorTransform: p, customRewriter: m, timeUniform: v } = r; if (o = o || "", s = s || "", a = a || "", c = c || "", u = u || "", d = d || "", (l || m) && (e = QA(e)), (p || m) && (t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`), t = QA(t)), m) { let y = m({ vertexShader: e, fragmentShader: t }); e = y.vertexShader, t = y.fragmentShader } if (p) {
		let y = []; t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, _ => (y.push(_), "")), d = `${p}
${y.join(`
`)}
${d}`
	} if (v) {
		const y = `
uniform float ${v};
`; o = y + o, c = y + c
	} return l && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`, e = e.replace(/\b(position|normal|uv)\b/g, (y, _, g, x) => /\battribute\s+vec[23]\s+$/.test(x.substr(0, g)) ? _ : `troika_${_}_${i}`), n.map && n.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = ZR(e, i, o, s, a), t = ZR(t, i, c, u, d), { vertexShader: e, fragmentShader: t }
} function ZR(n, e, t, r, i) {
	return (r || i || t) && (n = n.replace(_F, `
${t}
void troikaOrigMain${e}() {`), n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`), n
} function Q7(n, e) { return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e } let Z7 = 0; const qR = new Map; function q7(n) { const e = JSON.stringify(n, Q7); let t = qR.get(e); return t == null && qR.set(e, t = ++Z7), t } function ej(n, e, t) {
	const { defaultFontURL: r } = t, i = Object.create(null), o = 1 / 0, s = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, a = "[^\\S\\u00A0]", l = new RegExp(`${a}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`); function c(x, A) { function E() { const w = b => { console.error(`Failure loading font ${x}${x === r ? "" : "; trying fallback"}`, b), x !== r && (x = r, E()) }; try { const b = new XMLHttpRequest; b.open("get", x, !0), b.responseType = "arraybuffer", b.onload = function () { if (b.status >= 400) w(new Error(b.statusText)); else if (b.status > 0) try { const T = n(b.response); A(T) } catch (T) { w(T) } }, b.onerror = w, b.send() } catch (b) { w(b) } } E() } function u(x, A) { x || (x = r); let E = i[x]; E ? E.pending ? E.pending.push(A) : A(E) : (i[x] = { pending: [A] }, c(x, w => { let b = i[x].pending; i[x] = w, b.forEach(T => T(w)) })) } function d({ text: x = "", font: A = r, sdfGlyphSize: E = 64, fontSize: w = 1, letterSpacing: b = 0, lineHeight: T = "normal", maxWidth: B = o, direction: R, textAlign: P = "left", textIndent: U = 0, whiteSpace: G = "normal", overflowWrap: $ = "normal", anchorX: z = 0, anchorY: j = 0, includeCaretPositions: q = !1, chunkedBoundsSize: se = 8192, colorRanges: W = null }, V, J = !1) {
		const O = y(), k = { fontLoad: 0, typesetting: 0 }; x.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), x = x.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), w = +w, b = +b, B = +B, T = T || "normal", U = +U, u(A, Z => {
			const ee = isFinite(B); let ne = null, K = null, ae = null, ie = null, Se = null, Ce = null, le = null, F = 0, me = 0, he = G !== "nowrap"; const { ascender: ce, descender: fe, unitsPerEm: Re, lineGap: de, capHeight: Ie, xHeight: we } = Z; k.fontLoad = y() - O; const ge = y(), Ve = w / Re; T === "normal" && (T = (ce - fe + de) / Re), T = T * w; const H = (T - (ce - fe) * Ve) / 2, L = -(ce * Ve + H), oe = Math.min(T, (ce - fe) * Ve), Pe = (ce + fe) / 2 * Ve - oe / 2; let Ae = U, ye = new _; const be = [ye]; Z.forEachGlyph(x, w, b, (je, nt, Te) => {
				const Je = x.charAt(Te), re = je.advanceWidth * Ve, _e = ye.count; let Ne; if ("isEmpty" in je || (je.isWhitespace = !!Je && new RegExp(a).test(Je), je.canBreakAfter = !!Je && l.test(Je), je.isEmpty = je.xMin === je.xMax || je.yMin === je.yMax || s.test(Je)), !je.isWhitespace && !je.isEmpty && me++, he && ee && !je.isWhitespace && nt + re + Ae > B && _e) { if (ye.glyphAt(_e - 1).glyphObj.canBreakAfter) Ne = new _, Ae = -nt; else for (let Ue = _e; Ue--;)if (Ue === 0 && $ === "break-word") { Ne = new _, Ae = -nt; break } else if (ye.glyphAt(Ue).glyphObj.canBreakAfter) { Ne = ye.splitAt(Ue + 1); const Ge = Ne.glyphAt(0).x; Ae -= Ge; for (let Ke = Ne.count; Ke--;)Ne.glyphAt(Ke).x -= Ge; break } Ne && (ye.isSoftWrapped = !0, ye = Ne, be.push(ye), F = B) } let Y = ye.glyphAt(ye.count); Y.glyphObj = je, Y.x = nt + Ae, Y.width = re, Y.charIndex = Te, Je === `
`&& (ye = new _, be.push(ye), Ae = -(nt + re + b * w) + U)
			}), be.forEach(je => { for (let nt = je.count; nt--;) { let { glyphObj: Te, x: Je, width: re } = je.glyphAt(nt); if (!Te.isWhitespace) { je.width = Je + re, je.width > F && (F = je.width); return } } }); let ke = 0, He = 0; if (z && (typeof z == "number" ? ke = -z : typeof z == "string" && (ke = -F * (z === "left" ? 0 : z === "center" ? .5 : z === "right" ? 1 : m(z)))), j) { if (typeof j == "number") He = -j; else if (typeof j == "string") { let je = be.length * T; He = j === "top" ? 0 : j === "top-baseline" ? -L : j === "top-cap" ? -L - Ie * Ve : j === "top-ex" ? -L - we * Ve : j === "middle" ? je / 2 : j === "bottom" ? je : j === "bottom-baseline" ? je - H + fe * Ve : m(j) * je } } if (!J) { const je = e.getEmbeddingLevels(x, R); ne = new Uint16Array(me), K = new Float32Array(me * 2), ae = {}, Ce = [o, o, -o, -o], le = []; let nt = L; q && (Se = new Float32Array(x.length * 3)), W && (ie = new Uint8Array(me * 3)); let Te = 0, Je = -1, re = -1, _e, Ne; if (be.forEach((Y, Ue) => { let { count: Ge, width: Ke } = Y; if (Ge > 0) { let Qe = 0; for (let At = Ge; At-- && Y.glyphAt(At).glyphObj.isWhitespace;)Qe++; let ze = 0, Ze = 0; if (P === "center") ze = (F - Ke) / 2; else if (P === "right") ze = F - Ke; else if (P === "justify" && Y.isSoftWrapped) { let At = 0; for (let xt = Ge - Qe; xt--;)Y.glyphAt(xt).glyphObj.isWhitespace && At++; Ze = (F - Ke) / At } if (Ze || ze) { let At = 0; for (let xt = 0; xt < Ge; xt++) { let Yn = Y.glyphAt(xt); const $n = Yn.glyphObj; Yn.x += ze + At, Ze !== 0 && $n.isWhitespace && xt < Ge - Qe && (At += Ze, Yn.width += Ze) } } const it = e.getReorderSegments(x, je, Y.glyphAt(0).charIndex, Y.glyphAt(Y.count - 1).charIndex); for (let At = 0; At < it.length; At++) { const [xt, Yn] = it[At]; let $n = 1 / 0, Dt = -1 / 0; for (let qt = 0; qt < Ge; qt++)if (Y.glyphAt(qt).charIndex >= xt) { let tn = qt, Ht = qt; for (; Ht < Ge; Ht++) { let mn = Y.glyphAt(Ht); if (mn.charIndex > Yn) break; Ht < Ge - Qe && ($n = Math.min($n, mn.x), Dt = Math.max(Dt, mn.x + mn.width)) } for (let mn = tn; mn < Ht; mn++) { const gn = Y.glyphAt(mn); gn.x = Dt - (gn.x + gn.width - $n) } break } } let yt; const Ct = At => yt = At; for (let At = 0; At < Ge; At++) { let xt = Y.glyphAt(At); yt = xt.glyphObj; const Yn = yt.index, $n = je.levels[xt.charIndex] & 1; if ($n) { const Dt = e.getMirroredCharacter(x[xt.charIndex]); Dt && Z.forEachGlyph(Dt, 0, 0, Ct) } if (q) { const { charIndex: Dt } = xt, qt = xt.x + ke, tn = xt.x + xt.width + ke; Se[Dt * 3] = $n ? tn : qt, Se[Dt * 3 + 1] = $n ? qt : tn, Se[Dt * 3 + 2] = nt + Pe + He; const Ht = Dt - Je; Ht > 1 && v(Se, Je, Ht), Je = Dt } if (W) { const { charIndex: Dt } = xt; for (; Dt > re;)re++, W.hasOwnProperty(re) && (Ne = W[re]) } if (!yt.isWhitespace && !yt.isEmpty) { const Dt = Te++; ae[Yn] || (ae[Yn] = { path: yt.path, pathBounds: [yt.xMin, yt.yMin, yt.xMax, yt.yMax] }); const qt = xt.x + ke, tn = nt + He; K[Dt * 2] = qt, K[Dt * 2 + 1] = tn; const Ht = qt + yt.xMin * Ve, mn = tn + yt.yMin * Ve, gn = qt + yt.xMax * Ve, Dr = tn + yt.yMax * Ve; Ht < Ce[0] && (Ce[0] = Ht), mn < Ce[1] && (Ce[1] = mn), gn > Ce[2] && (Ce[2] = gn), Dr > Ce[3] && (Ce[3] = Dr), Dt % se === 0 && (_e = { start: Dt, end: Dt, rect: [o, o, -o, -o] }, le.push(_e)), _e.end++; const dr = _e.rect; if (Ht < dr[0] && (dr[0] = Ht), mn < dr[1] && (dr[1] = mn), gn > dr[2] && (dr[2] = gn), Dr > dr[3] && (dr[3] = Dr), ne[Dt] = Yn, W) { const Q = Dt * 3; ie[Q] = Ne >> 16 & 255, ie[Q + 1] = Ne >> 8 & 255, ie[Q + 2] = Ne & 255 } } } } nt -= T }), Se) { const Y = x.length - Je; Y > 1 && v(Se, Je, Y) } } k.typesetting = y() - ge, V({ glyphIds: ne, glyphPositions: K, glyphData: ae, caretPositions: Se, caretHeight: oe, glyphColors: ie, chunkedBounds: le, fontSize: w, unitsPerEm: Re, ascender: ce * Ve, descender: fe * Ve, capHeight: Ie * Ve, xHeight: we * Ve, lineHeight: T, topBaseline: L, blockBounds: [ke, He - be.length * T, ke + F, He], visibleBounds: Ce, timings: k })
		})
	} function p(x, A) { d(x, E => { const [w, b, T, B] = E.blockBounds; A({ width: T - w, height: B - b }) }, { metricsOnly: !0 }) } function m(x) { let A = x.match(/^([\d.]+)%$/), E = A ? parseFloat(A[1]) : NaN; return isNaN(E) ? 0 : E / 100 } function v(x, A, E) { const w = x[A * 3], b = x[A * 3 + 1], T = x[A * 3 + 2], B = (b - w) / E; for (let R = 0; R < E; R++) { const P = (A + R) * 3; x[P] = w + B * R, x[P + 1] = w + B * (R + 1), x[P + 2] = T } } function y() { return (self.performance || Date).now() } function _() { this.data = [] } const g = ["glyphObj", "x", "width", "charIndex"]; return _.prototype = { width: 0, isSoftWrapped: !1, get count() { return Math.ceil(this.data.length / g.length) }, glyphAt(x) { let A = _.flyweight; return A.data = this.data, A.index = x, A }, splitAt(x) { let A = new _; return A.data = this.data.splice(x * g.length), A } }, _.flyweight = g.reduce((x, A, E, w) => (Object.defineProperty(x, A, { get() { return this.data[this.index * g.length + E] }, set(b) { this.data[this.index * g.length + E] = b } }), x), { data: null, index: 0 }), { typeset: d, measure: p, loadFont: u }
} const Dc = () => (self.performance || Date).now(), Ny = yF(); let eP; function tj(n, e, t, r, i, o, s, a, l, c, u = !0) { return u ? rj(n, e, t, r, i, o, s, a, l, c).then(null, d => (eP || (console.warn("WebGL SDF generation failed, falling back to JS", d), eP = !0), nP(n, e, t, r, i, o, s, a, l, c))) : nP(n, e, t, r, i, o, s, a, l, c) } const z0 = [], nj = 5; let qA = 0; function xF() { const n = Dc(); for (; z0.length && Dc() - n < nj;)z0.shift()(); qA = z0.length ? setTimeout(xF, 0) : 0 } const rj = (...n) => new Promise((e, t) => { z0.push(() => { const r = Dc(); try { Ny.webgl.generateIntoCanvas(...n), e({ timing: Dc() - r }) } catch (i) { t(i) } }), qA || (qA = setTimeout(xF, 0)) }), ij = 4, oj = 2e3, tP = {}; let sj = 0; function nP(n, e, t, r, i, o, s, a, l, c) { const u = "TroikaTextSDFGenerator_JS_" + sj++ % ij; let d = tP[u]; return d || (d = tP[u] = { workerModule: $p({ name: u, workerId: u, dependencies: [yF, Dc], init(p, m) { const v = p().javascript.generate; return function (...y) { const _ = m(); return { textureData: v(...y), timing: m() - _ } } }, getTransferables(p) { return [p.textureData.buffer] } }), requests: 0, idleTimer: null }), d.requests++, clearTimeout(d.idleTimer), d.workerModule(n, e, t, r, i, o).then(({ textureData: p, timing: m }) => { const v = Dc(), y = new Uint8Array(p.length * 4); for (let _ = 0; _ < p.length; _++)y[_ * 4 + c] = p[_]; return Ny.webglUtils.renderImageData(s, y, a, l, n, e, 1 << 3 - c), m += Dc() - v, --d.requests === 0 && (d.idleTimer = setTimeout(() => { W7(u) }, oj)), { timing: m } }) } function aj(n) { n._warm || (Ny.webgl.isSupported(n), n._warm = !0) } const lj = Ny.webglUtils.resizeWebGLCanvasWithoutClearing;/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/function cj() { return typeof window > "u" && (self.window = self), function (n) { var e = { parse: function (i) { var o = e._bin, s = new Uint8Array(i); if (o.readASCII(s, 0, 4) == "ttcf") { var a = 4; o.readUshort(s, a), a += 2, o.readUshort(s, a), a += 2; var l = o.readUint(s, a); a += 4; for (var c = [], u = 0; u < l; u++) { var d = o.readUint(s, a); a += 4, c.push(e._readFont(s, d)) } return c } return [e._readFont(s, 0)] }, _readFont: function (i, o) { var s = e._bin, a = o; s.readFixed(i, o), o += 4; var l = s.readUshort(i, o); o += 2, s.readUshort(i, o), o += 2, s.readUshort(i, o), o += 2, s.readUshort(i, o), o += 2; for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: i, _offset: a }, d = {}, p = 0; p < l; p++) { var m = s.readASCII(i, o, 4); o += 4, s.readUint(i, o), o += 4; var v = s.readUint(i, o); o += 4; var y = s.readUint(i, o); o += 4, d[m] = { offset: v, length: y } } for (p = 0; p < c.length; p++) { var _ = c[p]; d[_] && (u[_.trim()] = e[_.trim()].parse(i, d[_].offset, d[_].length, u)) } return u }, _tabOffset: function (i, o, s) { for (var a = e._bin, l = a.readUshort(i, s + 4), c = s + 12, u = 0; u < l; u++) { var d = a.readASCII(i, c, 4); c += 4, a.readUint(i, c), c += 4; var p = a.readUint(i, c); if (c += 4, a.readUint(i, c), c += 4, d == o) return p } return 0 } }; e._bin = { readFixed: function (i, o) { return (i[o] << 8 | i[o + 1]) + (i[o + 2] << 8 | i[o + 3]) / 65540 }, readF2dot14: function (i, o) { return e._bin.readShort(i, o) / 16384 }, readInt: function (i, o) { return e._bin._view(i).getInt32(o) }, readInt8: function (i, o) { return e._bin._view(i).getInt8(o) }, readShort: function (i, o) { return e._bin._view(i).getInt16(o) }, readUshort: function (i, o) { return e._bin._view(i).getUint16(o) }, readUshorts: function (i, o, s) { for (var a = [], l = 0; l < s; l++)a.push(e._bin.readUshort(i, o + 2 * l)); return a }, readUint: function (i, o) { return e._bin._view(i).getUint32(o) }, readUint64: function (i, o) { return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4) }, readASCII: function (i, o, s) { for (var a = "", l = 0; l < s; l++)a += String.fromCharCode(i[o + l]); return a }, readUnicode: function (i, o, s) { for (var a = "", l = 0; l < s; l++) { var c = i[o++] << 8 | i[o++]; a += String.fromCharCode(c) } return a }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder : null, readUTF8: function (i, o, s) { var a = e._bin._tdec; return a && o == 0 && s == i.length ? a.decode(i) : e._bin.readASCII(i, o, s) }, readBytes: function (i, o, s) { for (var a = [], l = 0; l < s; l++)a.push(i[o + l]); return a }, readASCIIArray: function (i, o, s) { for (var a = [], l = 0; l < s; l++)a.push(String.fromCharCode(i[o + l])); return a }, _view: function (i) { return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer)) } }, e._lctf = {}, e._lctf.parse = function (i, o, s, a, l) { var c = e._bin, u = {}, d = o; c.readFixed(i, o), o += 4; var p = c.readUshort(i, o); o += 2; var m = c.readUshort(i, o); o += 2; var v = c.readUshort(i, o); return o += 2, u.scriptList = e._lctf.readScriptList(i, d + p), u.featureList = e._lctf.readFeatureList(i, d + m), u.lookupList = e._lctf.readLookupList(i, d + v, l), u }, e._lctf.readLookupList = function (i, o, s) { var a = e._bin, l = o, c = [], u = a.readUshort(i, o); o += 2; for (var d = 0; d < u; d++) { var p = a.readUshort(i, o); o += 2; var m = e._lctf.readLookupTable(i, l + p, s); c.push(m) } return c }, e._lctf.readLookupTable = function (i, o, s) { var a = e._bin, l = o, c = { tabs: [] }; c.ltype = a.readUshort(i, o), o += 2, c.flag = a.readUshort(i, o), o += 2; var u = a.readUshort(i, o); o += 2; for (var d = c.ltype, p = 0; p < u; p++) { var m = a.readUshort(i, o); o += 2; var v = s(i, d, l + m, c); c.tabs.push(v) } return c }, e._lctf.numOfOnes = function (i) { for (var o = 0, s = 0; s < 32; s++)i >>> s & 1 && o++; return o }, e._lctf.readClassDef = function (i, o) { var s = e._bin, a = [], l = s.readUshort(i, o); if (o += 2, l == 1) { var c = s.readUshort(i, o); o += 2; var u = s.readUshort(i, o); o += 2; for (var d = 0; d < u; d++)a.push(c + d), a.push(c + d), a.push(s.readUshort(i, o)), o += 2 } if (l == 2) { var p = s.readUshort(i, o); for (o += 2, d = 0; d < p; d++)a.push(s.readUshort(i, o)), o += 2, a.push(s.readUshort(i, o)), o += 2, a.push(s.readUshort(i, o)), o += 2 } return a }, e._lctf.getInterval = function (i, o) { for (var s = 0; s < i.length; s += 3) { var a = i[s], l = i[s + 1]; if (i[s + 2], a <= o && o <= l) return s } return -1 }, e._lctf.readCoverage = function (i, o) { var s = e._bin, a = {}; a.fmt = s.readUshort(i, o), o += 2; var l = s.readUshort(i, o); return o += 2, a.fmt == 1 && (a.tab = s.readUshorts(i, o, l)), a.fmt == 2 && (a.tab = s.readUshorts(i, o, 3 * l)), a }, e._lctf.coverageIndex = function (i, o) { var s = i.tab; if (i.fmt == 1) return s.indexOf(o); if (i.fmt == 2) { var a = e._lctf.getInterval(s, o); if (a != -1) return s[a + 2] + (o - s[a]) } return -1 }, e._lctf.readFeatureList = function (i, o) { var s = e._bin, a = o, l = [], c = s.readUshort(i, o); o += 2; for (var u = 0; u < c; u++) { var d = s.readASCII(i, o, 4); o += 4; var p = s.readUshort(i, o); o += 2; var m = e._lctf.readFeatureTable(i, a + p); m.tag = d.trim(), l.push(m) } return l }, e._lctf.readFeatureTable = function (i, o) { var s = e._bin, a = o, l = {}, c = s.readUshort(i, o); o += 2, c > 0 && (l.featureParams = a + c); var u = s.readUshort(i, o); o += 2, l.tab = []; for (var d = 0; d < u; d++)l.tab.push(s.readUshort(i, o + 2 * d)); return l }, e._lctf.readScriptList = function (i, o) { var s = e._bin, a = o, l = {}, c = s.readUshort(i, o); o += 2; for (var u = 0; u < c; u++) { var d = s.readASCII(i, o, 4); o += 4; var p = s.readUshort(i, o); o += 2, l[d.trim()] = e._lctf.readScriptTable(i, a + p) } return l }, e._lctf.readScriptTable = function (i, o) { var s = e._bin, a = o, l = {}, c = s.readUshort(i, o); o += 2, l.default = e._lctf.readLangSysTable(i, a + c); var u = s.readUshort(i, o); o += 2; for (var d = 0; d < u; d++) { var p = s.readASCII(i, o, 4); o += 4; var m = s.readUshort(i, o); o += 2, l[p.trim()] = e._lctf.readLangSysTable(i, a + m) } return l }, e._lctf.readLangSysTable = function (i, o) { var s = e._bin, a = {}; s.readUshort(i, o), o += 2, a.reqFeature = s.readUshort(i, o), o += 2; var l = s.readUshort(i, o); return o += 2, a.features = s.readUshorts(i, o, l), a }, e.CFF = {}, e.CFF.parse = function (i, o, s) { var a = e._bin; (i = new Uint8Array(i.buffer, o, s))[o = 0], i[++o], i[++o], i[++o], o++; var l = []; o = e.CFF.readIndex(i, o, l); for (var c = [], u = 0; u < l.length - 1; u++)c.push(a.readASCII(i, o + l[u], l[u + 1] - l[u])); o += l[l.length - 1]; var d = []; o = e.CFF.readIndex(i, o, d); var p = []; for (u = 0; u < d.length - 1; u++)p.push(e.CFF.readDict(i, o + d[u], o + d[u + 1])); o += d[d.length - 1]; var m = p[0], v = []; o = e.CFF.readIndex(i, o, v); var y = []; for (u = 0; u < v.length - 1; u++)y.push(a.readASCII(i, o + v[u], v[u + 1] - v[u])); if (o += v[v.length - 1], e.CFF.readSubrs(i, o, m), m.CharStrings) { o = m.CharStrings, v = [], o = e.CFF.readIndex(i, o, v); var _ = []; for (u = 0; u < v.length - 1; u++)_.push(a.readBytes(i, o + v[u], v[u + 1] - v[u])); m.CharStrings = _ } if (m.ROS) { o = m.FDArray; var g = []; for (o = e.CFF.readIndex(i, o, g), m.FDArray = [], u = 0; u < g.length - 1; u++) { var x = e.CFF.readDict(i, o + g[u], o + g[u + 1]); e.CFF._readFDict(i, x, y), m.FDArray.push(x) } o += g[g.length - 1], o = m.FDSelect, m.FDSelect = []; var A = i[o]; if (o++, A != 3) throw A; var E = a.readUshort(i, o); for (o += 2, u = 0; u < E + 1; u++)m.FDSelect.push(a.readUshort(i, o), i[o + 2]), o += 3 } return m.Encoding && (m.Encoding = e.CFF.readEncoding(i, m.Encoding, m.CharStrings.length)), m.charset && (m.charset = e.CFF.readCharset(i, m.charset, m.CharStrings.length)), e.CFF._readFDict(i, m, y), m }, e.CFF._readFDict = function (i, o, s) { var a; for (var l in o.Private && (a = o.Private[1], o.Private = e.CFF.readDict(i, a, a + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(i, a + o.Private.Subrs, o.Private)), o) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (o[l] = s[o[l] - 426 + 35]) }, e.CFF.readSubrs = function (i, o, s) { var a = e._bin, l = []; o = e.CFF.readIndex(i, o, l); var c, u = l.length; c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, s.Bias = c, s.Subrs = []; for (var d = 0; d < l.length - 1; d++)s.Subrs.push(a.readBytes(i, o + l[d], l[d + 1] - l[d])) }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function (i, o) { for (var s = 0; s < i.charset.length; s++)if (i.charset[s] == o) return s; return -1 }, e.CFF.glyphBySE = function (i, o) { return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]) }, e.CFF.readEncoding = function (i, o, s) { e._bin; var a = [".notdef"], l = i[o]; if (o++, l != 0) throw "error: unknown encoding format: " + l; var c = i[o]; o++; for (var u = 0; u < c; u++)a.push(i[o + u]); return a }, e.CFF.readCharset = function (i, o, s) { var a = e._bin, l = [".notdef"], c = i[o]; if (o++, c == 0) for (var u = 0; u < s; u++) { var d = a.readUshort(i, o); o += 2, l.push(d) } else { if (c != 1 && c != 2) throw "error: format: " + c; for (; l.length < s;) { d = a.readUshort(i, o), o += 2; var p = 0; for (c == 1 ? (p = i[o], o++) : (p = a.readUshort(i, o), o += 2), u = 0; u <= p; u++)l.push(d), d++ } } return l }, e.CFF.readIndex = function (i, o, s) { var a = e._bin, l = a.readUshort(i, o) + 1, c = i[o += 2]; if (o++, c == 1) for (var u = 0; u < l; u++)s.push(i[o + u]); else if (c == 2) for (u = 0; u < l; u++)s.push(a.readUshort(i, o + 2 * u)); else if (c == 3) for (u = 0; u < l; u++)s.push(16777215 & a.readUint(i, o + 3 * u - 1)); else if (l != 1) throw "unsupported offset size: " + c + ", count: " + l; return (o += l * c) - 1 }, e.CFF.getCharString = function (i, o, s) { var a = e._bin, l = i[o], c = i[o + 1]; i[o + 2], i[o + 3], i[o + 4]; var u = 1, d = null, p = null; l <= 20 && (d = l, u = 1), l == 12 && (d = 100 * l + c, u = 2), 21 <= l && l <= 27 && (d = l, u = 1), l == 28 && (p = a.readShort(i, o + 1), u = 3), 29 <= l && l <= 31 && (d = l, u = 1), 32 <= l && l <= 246 && (p = l - 139, u = 1), 247 <= l && l <= 250 && (p = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (p = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (p = a.readInt(i, o + 1) / 65535, u = 5), s.val = p ?? "o" + d, s.size = u }, e.CFF.readCharString = function (i, o, s) { for (var a = o + s, l = e._bin, c = []; o < a;) { var u = i[o], d = i[o + 1]; i[o + 2], i[o + 3], i[o + 4]; var p = 1, m = null, v = null; u <= 20 && (m = u, p = 1), u == 12 && (m = 100 * u + d, p = 2), u != 19 && u != 20 || (m = u, p = 2), 21 <= u && u <= 27 && (m = u, p = 1), u == 28 && (v = l.readShort(i, o + 1), p = 3), 29 <= u && u <= 31 && (m = u, p = 1), 32 <= u && u <= 246 && (v = u - 139, p = 1), 247 <= u && u <= 250 && (v = 256 * (u - 247) + d + 108, p = 2), 251 <= u && u <= 254 && (v = 256 * -(u - 251) - d - 108, p = 2), u == 255 && (v = l.readInt(i, o + 1) / 65535, p = 5), c.push(v ?? "o" + m), o += p } return c }, e.CFF.readDict = function (i, o, s) { for (var a = e._bin, l = {}, c = []; o < s;) { var u = i[o], d = i[o + 1]; i[o + 2], i[o + 3], i[o + 4]; var p = 1, m = null, v = null; if (u == 28 && (v = a.readShort(i, o + 1), p = 3), u == 29 && (v = a.readInt(i, o + 1), p = 5), 32 <= u && u <= 246 && (v = u - 139, p = 1), 247 <= u && u <= 250 && (v = 256 * (u - 247) + d + 108, p = 2), 251 <= u && u <= 254 && (v = 256 * -(u - 251) - d - 108, p = 2), u == 255) throw v = a.readInt(i, o + 1) / 65535, p = 5, "unknown number"; if (u == 30) { var y = []; for (p = 1; ;) { var _ = i[o + p]; p++; var g = _ >> 4, x = 15 & _; if (g != 15 && y.push(g), x != 15 && y.push(x), x == 15) break } for (var A = "", E = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], w = 0; w < y.length; w++)A += E[y[w]]; v = parseFloat(A) } u <= 21 && (m = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], p = 1, u == 12 && (m = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][d], p = 2)), m != null ? (l[m] = c.length == 1 ? c[0] : c, c = []) : c.push(v), o += p } return l }, e.cmap = {}, e.cmap.parse = function (i, o, s) { i = new Uint8Array(i.buffer, o, s), o = 0; var a = e._bin, l = {}; a.readUshort(i, o), o += 2; var c = a.readUshort(i, o); o += 2; var u = []; l.tables = []; for (var d = 0; d < c; d++) { var p = a.readUshort(i, o); o += 2; var m = a.readUshort(i, o); o += 2; var v = a.readUint(i, o); o += 4; var y = "p" + p + "e" + m, _ = u.indexOf(v); if (_ == -1) { var g; _ = l.tables.length, u.push(v); var x = a.readUshort(i, v); x == 0 ? g = e.cmap.parse0(i, v) : x == 4 ? g = e.cmap.parse4(i, v) : x == 6 ? g = e.cmap.parse6(i, v) : x == 12 ? g = e.cmap.parse12(i, v) : console.debug("unknown format: " + x, p, m, v), l.tables.push(g) } if (l[y] != null) throw "multiple tables for one platform+encoding"; l[y] = _ } return l }, e.cmap.parse0 = function (i, o) { var s = e._bin, a = {}; a.format = s.readUshort(i, o), o += 2; var l = s.readUshort(i, o); o += 2, s.readUshort(i, o), o += 2, a.map = []; for (var c = 0; c < l - 6; c++)a.map.push(i[o + c]); return a }, e.cmap.parse4 = function (i, o) { var s = e._bin, a = o, l = {}; l.format = s.readUshort(i, o), o += 2; var c = s.readUshort(i, o); o += 2, s.readUshort(i, o), o += 2; var u = s.readUshort(i, o); o += 2; var d = u / 2; l.searchRange = s.readUshort(i, o), o += 2, l.entrySelector = s.readUshort(i, o), o += 2, l.rangeShift = s.readUshort(i, o), o += 2, l.endCount = s.readUshorts(i, o, d), o += 2 * d, o += 2, l.startCount = s.readUshorts(i, o, d), o += 2 * d, l.idDelta = []; for (var p = 0; p < d; p++)l.idDelta.push(s.readShort(i, o)), o += 2; for (l.idRangeOffset = s.readUshorts(i, o, d), o += 2 * d, l.glyphIdArray = []; o < a + c;)l.glyphIdArray.push(s.readUshort(i, o)), o += 2; return l }, e.cmap.parse6 = function (i, o) { var s = e._bin, a = {}; a.format = s.readUshort(i, o), o += 2, s.readUshort(i, o), o += 2, s.readUshort(i, o), o += 2, a.firstCode = s.readUshort(i, o), o += 2; var l = s.readUshort(i, o); o += 2, a.glyphIdArray = []; for (var c = 0; c < l; c++)a.glyphIdArray.push(s.readUshort(i, o)), o += 2; return a }, e.cmap.parse12 = function (i, o) { var s = e._bin, a = {}; a.format = s.readUshort(i, o), o += 2, o += 2, s.readUint(i, o), o += 4, s.readUint(i, o), o += 4; var l = s.readUint(i, o); o += 4, a.groups = []; for (var c = 0; c < l; c++) { var u = o + 12 * c, d = s.readUint(i, u + 0), p = s.readUint(i, u + 4), m = s.readUint(i, u + 8); a.groups.push([d, p, m]) } return a }, e.glyf = {}, e.glyf.parse = function (i, o, s, a) { for (var l = [], c = 0; c < a.maxp.numGlyphs; c++)l.push(null); return l }, e.glyf._parseGlyf = function (i, o) { var s = e._bin, a = i._data, l = e._tabOffset(a, "glyf", i._offset) + i.loca[o]; if (i.loca[o] == i.loca[o + 1]) return null; var c = {}; if (c.noc = s.readShort(a, l), l += 2, c.xMin = s.readShort(a, l), l += 2, c.yMin = s.readShort(a, l), l += 2, c.xMax = s.readShort(a, l), l += 2, c.yMax = s.readShort(a, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax) return null; if (c.noc > 0) { c.endPts = []; for (var u = 0; u < c.noc; u++)c.endPts.push(s.readUshort(a, l)), l += 2; var d = s.readUshort(a, l); if (l += 2, a.length - l < d) return null; c.instructions = s.readBytes(a, l, d), l += d; var p = c.endPts[c.noc - 1] + 1; for (c.flags = [], u = 0; u < p; u++) { var m = a[l]; if (l++, c.flags.push(m), (8 & m) != 0) { var v = a[l]; l++; for (var y = 0; y < v; y++)c.flags.push(m), u++ } } for (c.xs = [], u = 0; u < p; u++) { var _ = (2 & c.flags[u]) != 0, g = (16 & c.flags[u]) != 0; _ ? (c.xs.push(g ? a[l] : -a[l]), l++) : g ? c.xs.push(0) : (c.xs.push(s.readShort(a, l)), l += 2) } for (c.ys = [], u = 0; u < p; u++)_ = (4 & c.flags[u]) != 0, g = (32 & c.flags[u]) != 0, _ ? (c.ys.push(g ? a[l] : -a[l]), l++) : g ? c.ys.push(0) : (c.ys.push(s.readShort(a, l)), l += 2); var x = 0, A = 0; for (u = 0; u < p; u++)x += c.xs[u], A += c.ys[u], c.xs[u] = x, c.ys[u] = A } else { var E; c.parts = []; do { E = s.readUshort(a, l), l += 2; var w = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 }; if (c.parts.push(w), w.glyphIndex = s.readUshort(a, l), l += 2, 1 & E) { var b = s.readShort(a, l); l += 2; var T = s.readShort(a, l); l += 2 } else b = s.readInt8(a, l), l++, T = s.readInt8(a, l), l++; 2 & E ? (w.m.tx = b, w.m.ty = T) : (w.p1 = b, w.p2 = T), 8 & E ? (w.m.a = w.m.d = s.readF2dot14(a, l), l += 2) : 64 & E ? (w.m.a = s.readF2dot14(a, l), l += 2, w.m.d = s.readF2dot14(a, l), l += 2) : 128 & E && (w.m.a = s.readF2dot14(a, l), l += 2, w.m.b = s.readF2dot14(a, l), l += 2, w.m.c = s.readF2dot14(a, l), l += 2, w.m.d = s.readF2dot14(a, l), l += 2) } while (32 & E); if (256 & E) { var B = s.readUshort(a, l); for (l += 2, c.instr = [], u = 0; u < B; u++)c.instr.push(a[l]), l++ } } return c }, e.GPOS = {}, e.GPOS.parse = function (i, o, s, a) { return e._lctf.parse(i, o, s, a, e.GPOS.subt) }, e.GPOS.subt = function (i, o, s, a) { var l = e._bin, c = s, u = {}; if (u.fmt = l.readUshort(i, s), s += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && u.fmt <= 2) { var d = l.readUshort(i, s); s += 2, u.coverage = e._lctf.readCoverage(i, d + c) } if (o == 1 && u.fmt == 1) { var p = l.readUshort(i, s); s += 2; var m = e._lctf.numOfOnes(p); p != 0 && (u.pos = e.GPOS.readValueRecord(i, s, p)) } else if (o == 2 && u.fmt >= 1 && u.fmt <= 2) { p = l.readUshort(i, s), s += 2; var v = l.readUshort(i, s); s += 2, m = e._lctf.numOfOnes(p); var y = e._lctf.numOfOnes(v); if (u.fmt == 1) { u.pairsets = []; var _ = l.readUshort(i, s); s += 2; for (var g = 0; g < _; g++) { var x = c + l.readUshort(i, s); s += 2; var A = l.readUshort(i, x); x += 2; for (var E = [], w = 0; w < A; w++) { var b = l.readUshort(i, x); x += 2, p != 0 && (G = e.GPOS.readValueRecord(i, x, p), x += 2 * m), v != 0 && ($ = e.GPOS.readValueRecord(i, x, v), x += 2 * y), E.push({ gid2: b, val1: G, val2: $ }) } u.pairsets.push(E) } } if (u.fmt == 2) { var T = l.readUshort(i, s); s += 2; var B = l.readUshort(i, s); s += 2; var R = l.readUshort(i, s); s += 2; var P = l.readUshort(i, s); for (s += 2, u.classDef1 = e._lctf.readClassDef(i, c + T), u.classDef2 = e._lctf.readClassDef(i, c + B), u.matrix = [], g = 0; g < R; g++) { var U = []; for (w = 0; w < P; w++) { var G = null, $ = null; p != 0 && (G = e.GPOS.readValueRecord(i, s, p), s += 2 * m), v != 0 && ($ = e.GPOS.readValueRecord(i, s, v), s += 2 * y), U.push({ val1: G, val2: $ }) } u.matrix.push(U) } } } else { if (o == 9 && u.fmt == 1) { var z = l.readUshort(i, s); s += 2; var j = l.readUint(i, s); if (s += 4, a.ltype == 9) a.ltype = z; else if (a.ltype != z) throw "invalid extension substitution"; return e.GPOS.subt(i, a.ltype, c + j) } console.debug("unsupported GPOS table LookupType", o, "format", u.fmt) } return u }, e.GPOS.readValueRecord = function (i, o, s) { var a = e._bin, l = []; return l.push(1 & s ? a.readShort(i, o) : 0), o += 1 & s ? 2 : 0, l.push(2 & s ? a.readShort(i, o) : 0), o += 2 & s ? 2 : 0, l.push(4 & s ? a.readShort(i, o) : 0), o += 4 & s ? 2 : 0, l.push(8 & s ? a.readShort(i, o) : 0), o += 8 & s ? 2 : 0, l }, e.GSUB = {}, e.GSUB.parse = function (i, o, s, a) { return e._lctf.parse(i, o, s, a, e.GSUB.subt) }, e.GSUB.subt = function (i, o, s, a) { var l = e._bin, c = s, u = {}; if (u.fmt = l.readUshort(i, s), s += 2, o != 1 && o != 4 && o != 5 && o != 6) return null; if (o == 1 || o == 4 || o == 5 && u.fmt <= 2 || o == 6 && u.fmt <= 2) { var d = l.readUshort(i, s); s += 2, u.coverage = e._lctf.readCoverage(i, c + d) } if (o == 1 && u.fmt >= 1 && u.fmt <= 2) { if (u.fmt == 1) u.delta = l.readShort(i, s), s += 2; else if (u.fmt == 2) { var p = l.readUshort(i, s); s += 2, u.newg = l.readUshorts(i, s, p), s += 2 * u.newg.length } } else if (o == 4) { u.vals = [], p = l.readUshort(i, s), s += 2; for (var m = 0; m < p; m++) { var v = l.readUshort(i, s); s += 2, u.vals.push(e.GSUB.readLigatureSet(i, c + v)) } } else if (o == 5 && u.fmt == 2) { if (u.fmt == 2) { var y = l.readUshort(i, s); s += 2, u.cDef = e._lctf.readClassDef(i, c + y), u.scset = []; var _ = l.readUshort(i, s); for (s += 2, m = 0; m < _; m++) { var g = l.readUshort(i, s); s += 2, u.scset.push(g == 0 ? null : e.GSUB.readSubClassSet(i, c + g)) } } } else if (o == 6 && u.fmt == 3) { if (u.fmt == 3) { for (m = 0; m < 3; m++) { p = l.readUshort(i, s), s += 2; for (var x = [], A = 0; A < p; A++)x.push(e._lctf.readCoverage(i, c + l.readUshort(i, s + 2 * A))); s += 2 * p, m == 0 && (u.backCvg = x), m == 1 && (u.inptCvg = x), m == 2 && (u.ahedCvg = x) } p = l.readUshort(i, s), s += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(i, s, p) } } else { if (o == 7 && u.fmt == 1) { var E = l.readUshort(i, s); s += 2; var w = l.readUint(i, s); if (s += 4, a.ltype == 9) a.ltype = E; else if (a.ltype != E) throw "invalid extension substitution"; return e.GSUB.subt(i, a.ltype, c + w) } console.debug("unsupported GSUB table LookupType", o, "format", u.fmt) } return u }, e.GSUB.readSubClassSet = function (i, o) { var s = e._bin.readUshort, a = o, l = [], c = s(i, o); o += 2; for (var u = 0; u < c; u++) { var d = s(i, o); o += 2, l.push(e.GSUB.readSubClassRule(i, a + d)) } return l }, e.GSUB.readSubClassRule = function (i, o) { var s = e._bin.readUshort, a = {}, l = s(i, o), c = s(i, o += 2); o += 2, a.input = []; for (var u = 0; u < l - 1; u++)a.input.push(s(i, o)), o += 2; return a.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, c), a }, e.GSUB.readSubstLookupRecords = function (i, o, s) { for (var a = e._bin.readUshort, l = [], c = 0; c < s; c++)l.push(a(i, o), a(i, o + 2)), o += 4; return l }, e.GSUB.readChainSubClassSet = function (i, o) { var s = e._bin, a = o, l = [], c = s.readUshort(i, o); o += 2; for (var u = 0; u < c; u++) { var d = s.readUshort(i, o); o += 2, l.push(e.GSUB.readChainSubClassRule(i, a + d)) } return l }, e.GSUB.readChainSubClassRule = function (i, o) { for (var s = e._bin, a = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) { var u = s.readUshort(i, o); o += 2, c == 1 && u--, a[l[c]] = s.readUshorts(i, o, u), o += 2 * a[l[c]].length } return u = s.readUshort(i, o), o += 2, a.subst = s.readUshorts(i, o, 2 * u), o += 2 * a.subst.length, a }, e.GSUB.readLigatureSet = function (i, o) { var s = e._bin, a = o, l = [], c = s.readUshort(i, o); o += 2; for (var u = 0; u < c; u++) { var d = s.readUshort(i, o); o += 2, l.push(e.GSUB.readLigature(i, a + d)) } return l }, e.GSUB.readLigature = function (i, o) { var s = e._bin, a = { chain: [] }; a.nglyph = s.readUshort(i, o), o += 2; var l = s.readUshort(i, o); o += 2; for (var c = 0; c < l - 1; c++)a.chain.push(s.readUshort(i, o)), o += 2; return a }, e.head = {}, e.head.parse = function (i, o, s) { var a = e._bin, l = {}; return a.readFixed(i, o), o += 4, l.fontRevision = a.readFixed(i, o), o += 4, a.readUint(i, o), o += 4, a.readUint(i, o), o += 4, l.flags = a.readUshort(i, o), o += 2, l.unitsPerEm = a.readUshort(i, o), o += 2, l.created = a.readUint64(i, o), o += 8, l.modified = a.readUint64(i, o), o += 8, l.xMin = a.readShort(i, o), o += 2, l.yMin = a.readShort(i, o), o += 2, l.xMax = a.readShort(i, o), o += 2, l.yMax = a.readShort(i, o), o += 2, l.macStyle = a.readUshort(i, o), o += 2, l.lowestRecPPEM = a.readUshort(i, o), o += 2, l.fontDirectionHint = a.readShort(i, o), o += 2, l.indexToLocFormat = a.readShort(i, o), o += 2, l.glyphDataFormat = a.readShort(i, o), o += 2, l }, e.hhea = {}, e.hhea.parse = function (i, o, s) { var a = e._bin, l = {}; return a.readFixed(i, o), o += 4, l.ascender = a.readShort(i, o), o += 2, l.descender = a.readShort(i, o), o += 2, l.lineGap = a.readShort(i, o), o += 2, l.advanceWidthMax = a.readUshort(i, o), o += 2, l.minLeftSideBearing = a.readShort(i, o), o += 2, l.minRightSideBearing = a.readShort(i, o), o += 2, l.xMaxExtent = a.readShort(i, o), o += 2, l.caretSlopeRise = a.readShort(i, o), o += 2, l.caretSlopeRun = a.readShort(i, o), o += 2, l.caretOffset = a.readShort(i, o), o += 2, o += 8, l.metricDataFormat = a.readShort(i, o), o += 2, l.numberOfHMetrics = a.readUshort(i, o), o += 2, l }, e.hmtx = {}, e.hmtx.parse = function (i, o, s, a) { for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, d = 0, p = 0; p < a.maxp.numGlyphs; p++)p < a.hhea.numberOfHMetrics && (u = l.readUshort(i, o), o += 2, d = l.readShort(i, o), o += 2), c.aWidth.push(u), c.lsBearing.push(d); return c }, e.kern = {}, e.kern.parse = function (i, o, s, a) { var l = e._bin, c = l.readUshort(i, o); if (o += 2, c == 1) return e.kern.parseV1(i, o - 2, s, a); var u = l.readUshort(i, o); o += 2; for (var d = { glyph1: [], rval: [] }, p = 0; p < u; p++) { o += 2, s = l.readUshort(i, o), o += 2; var m = l.readUshort(i, o); o += 2; var v = m >>> 8; if ((v &= 15) != 0) throw "unknown kern table format: " + v; o = e.kern.readFormat0(i, o, d) } return d }, e.kern.parseV1 = function (i, o, s, a) { var l = e._bin; l.readFixed(i, o), o += 4; var c = l.readUint(i, o); o += 4; for (var u = { glyph1: [], rval: [] }, d = 0; d < c; d++) { l.readUint(i, o), o += 4; var p = l.readUshort(i, o); o += 2, l.readUshort(i, o), o += 2; var m = p >>> 8; if ((m &= 15) != 0) throw "unknown kern table format: " + m; o = e.kern.readFormat0(i, o, u) } return u }, e.kern.readFormat0 = function (i, o, s) { var a = e._bin, l = -1, c = a.readUshort(i, o); o += 2, a.readUshort(i, o), o += 2, a.readUshort(i, o), o += 2, a.readUshort(i, o), o += 2; for (var u = 0; u < c; u++) { var d = a.readUshort(i, o); o += 2; var p = a.readUshort(i, o); o += 2; var m = a.readShort(i, o); o += 2, d != l && (s.glyph1.push(d), s.rval.push({ glyph2: [], vals: [] })); var v = s.rval[s.rval.length - 1]; v.glyph2.push(p), v.vals.push(m), l = d } return o }, e.loca = {}, e.loca.parse = function (i, o, s, a) { var l = e._bin, c = [], u = a.head.indexToLocFormat, d = a.maxp.numGlyphs + 1; if (u == 0) for (var p = 0; p < d; p++)c.push(l.readUshort(i, o + (p << 1)) << 1); if (u == 1) for (p = 0; p < d; p++)c.push(l.readUint(i, o + (p << 2))); return c }, e.maxp = {}, e.maxp.parse = function (i, o, s) { var a = e._bin, l = {}, c = a.readUint(i, o); return o += 4, l.numGlyphs = a.readUshort(i, o), o += 2, c == 65536 && (l.maxPoints = a.readUshort(i, o), o += 2, l.maxContours = a.readUshort(i, o), o += 2, l.maxCompositePoints = a.readUshort(i, o), o += 2, l.maxCompositeContours = a.readUshort(i, o), o += 2, l.maxZones = a.readUshort(i, o), o += 2, l.maxTwilightPoints = a.readUshort(i, o), o += 2, l.maxStorage = a.readUshort(i, o), o += 2, l.maxFunctionDefs = a.readUshort(i, o), o += 2, l.maxInstructionDefs = a.readUshort(i, o), o += 2, l.maxStackElements = a.readUshort(i, o), o += 2, l.maxSizeOfInstructions = a.readUshort(i, o), o += 2, l.maxComponentElements = a.readUshort(i, o), o += 2, l.maxComponentDepth = a.readUshort(i, o), o += 2), l }, e.name = {}, e.name.parse = function (i, o, s) { var a = e._bin, l = {}; a.readUshort(i, o), o += 2; var c = a.readUshort(i, o); o += 2, a.readUshort(i, o); for (var u, d = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], p = o += 2, m = 0; m < c; m++) { var v = a.readUshort(i, o); o += 2; var y = a.readUshort(i, o); o += 2; var _ = a.readUshort(i, o); o += 2; var g = a.readUshort(i, o); o += 2; var x = a.readUshort(i, o); o += 2; var A = a.readUshort(i, o); o += 2; var E, w = d[g], b = p + 12 * c + A; if (v == 0) E = a.readUnicode(i, b, x / 2); else if (v == 3 && y == 0) E = a.readUnicode(i, b, x / 2); else if (y == 0) E = a.readASCII(i, b, x); else if (y == 1) E = a.readUnicode(i, b, x / 2); else if (y == 3) E = a.readUnicode(i, b, x / 2); else { if (v != 1) throw "unknown encoding " + y + ", platformID: " + v; E = a.readASCII(i, b, x), console.debug("reading unknown MAC encoding " + y + " as ASCII") } var T = "p" + v + "," + _.toString(16); l[T] == null && (l[T] = {}), l[T][w !== void 0 ? w : g] = E, l[T]._lang = _ } for (var B in l) if (l[B].postScriptName != null && l[B]._lang == 1033) return l[B]; for (var B in l) if (l[B].postScriptName != null && l[B]._lang == 0) return l[B]; for (var B in l) if (l[B].postScriptName != null && l[B]._lang == 3084) return l[B]; for (var B in l) if (l[B].postScriptName != null) return l[B]; for (var B in l) { u = B; break } return console.debug("returning name table with languageID " + l[u]._lang), l[u] }, e["OS/2"] = {}, e["OS/2"].parse = function (i, o, s) { var a = e._bin.readUshort(i, o); o += 2; var l = {}; if (a == 0) e["OS/2"].version0(i, o, l); else if (a == 1) e["OS/2"].version1(i, o, l); else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(i, o, l); else { if (a != 5) throw "unknown OS/2 table version: " + a; e["OS/2"].version5(i, o, l) } return l }, e["OS/2"].version0 = function (i, o, s) { var a = e._bin; return s.xAvgCharWidth = a.readShort(i, o), o += 2, s.usWeightClass = a.readUshort(i, o), o += 2, s.usWidthClass = a.readUshort(i, o), o += 2, s.fsType = a.readUshort(i, o), o += 2, s.ySubscriptXSize = a.readShort(i, o), o += 2, s.ySubscriptYSize = a.readShort(i, o), o += 2, s.ySubscriptXOffset = a.readShort(i, o), o += 2, s.ySubscriptYOffset = a.readShort(i, o), o += 2, s.ySuperscriptXSize = a.readShort(i, o), o += 2, s.ySuperscriptYSize = a.readShort(i, o), o += 2, s.ySuperscriptXOffset = a.readShort(i, o), o += 2, s.ySuperscriptYOffset = a.readShort(i, o), o += 2, s.yStrikeoutSize = a.readShort(i, o), o += 2, s.yStrikeoutPosition = a.readShort(i, o), o += 2, s.sFamilyClass = a.readShort(i, o), o += 2, s.panose = a.readBytes(i, o, 10), o += 10, s.ulUnicodeRange1 = a.readUint(i, o), o += 4, s.ulUnicodeRange2 = a.readUint(i, o), o += 4, s.ulUnicodeRange3 = a.readUint(i, o), o += 4, s.ulUnicodeRange4 = a.readUint(i, o), o += 4, s.achVendID = [a.readInt8(i, o), a.readInt8(i, o + 1), a.readInt8(i, o + 2), a.readInt8(i, o + 3)], o += 4, s.fsSelection = a.readUshort(i, o), o += 2, s.usFirstCharIndex = a.readUshort(i, o), o += 2, s.usLastCharIndex = a.readUshort(i, o), o += 2, s.sTypoAscender = a.readShort(i, o), o += 2, s.sTypoDescender = a.readShort(i, o), o += 2, s.sTypoLineGap = a.readShort(i, o), o += 2, s.usWinAscent = a.readUshort(i, o), o += 2, s.usWinDescent = a.readUshort(i, o), o += 2 }, e["OS/2"].version1 = function (i, o, s) { var a = e._bin; return o = e["OS/2"].version0(i, o, s), s.ulCodePageRange1 = a.readUint(i, o), o += 4, s.ulCodePageRange2 = a.readUint(i, o), o += 4 }, e["OS/2"].version2 = function (i, o, s) { var a = e._bin; return o = e["OS/2"].version1(i, o, s), s.sxHeight = a.readShort(i, o), o += 2, s.sCapHeight = a.readShort(i, o), o += 2, s.usDefault = a.readUshort(i, o), o += 2, s.usBreak = a.readUshort(i, o), o += 2, s.usMaxContext = a.readUshort(i, o), o += 2 }, e["OS/2"].version5 = function (i, o, s) { var a = e._bin; return o = e["OS/2"].version2(i, o, s), s.usLowerOpticalPointSize = a.readUshort(i, o), o += 2, s.usUpperOpticalPointSize = a.readUshort(i, o), o += 2 }, e.post = {}, e.post.parse = function (i, o, s) { var a = e._bin, l = {}; return l.version = a.readFixed(i, o), o += 4, l.italicAngle = a.readFixed(i, o), o += 4, l.underlinePosition = a.readShort(i, o), o += 2, l.underlineThickness = a.readShort(i, o), o += 2, l }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function (i, o) { var s = i.cmap, a = -1; if (s.p0e4 != null ? a = s.p0e4 : s.p3e1 != null ? a = s.p3e1 : s.p1e0 != null ? a = s.p1e0 : s.p0e3 != null && (a = s.p0e3), a == -1) throw "no familiar platform and encoding!"; var l = s.tables[a]; if (l.format == 0) return o >= l.map.length ? 0 : l.map[o]; if (l.format == 4) { for (var c = -1, u = 0; u < l.endCount.length; u++)if (o <= l.endCount[u]) { c = u; break } return c == -1 || l.startCount[c] > o ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[o - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : o + l.idDelta[c]) } if (l.format == 12) { if (o > l.groups[l.groups.length - 1][1]) return 0; for (u = 0; u < l.groups.length; u++) { var d = l.groups[u]; if (d[0] <= o && o <= d[1]) return d[2] + (o - d[0]) } return 0 } throw "unknown cmap table format " + l.format }, e.U.glyphToPath = function (i, o) { var s = { cmds: [], crds: [] }; if (i.SVG && i.SVG.entries[o]) { var a = i.SVG.entries[o]; return a == null ? s : (typeof a == "string" && (a = e.SVG.toPath(a), i.SVG.entries[o] = a), a) } if (i.CFF) { var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, c = i.CFF, u = i.CFF.Private; if (c.ROS) { for (var d = 0; c.FDSelect[d + 2] <= o;)d += 2; u = c.FDArray[c.FDSelect[d + 1]].Private } e.U._drawCFF(i.CFF.CharStrings[o], l, c, u, s) } else i.glyf && e.U._drawGlyf(o, i, s); return s }, e.U._drawGlyf = function (i, o, s) { var a = o.glyf[i]; a == null && (a = o.glyf[i] = e.glyf._parseGlyf(o, i)), a != null && (a.noc > -1 ? e.U._simpleGlyph(a, s) : e.U._compoGlyph(a, o, s)) }, e.U._simpleGlyph = function (i, o) { for (var s = 0; s < i.noc; s++) { for (var a = s == 0 ? 0 : i.endPts[s - 1] + 1, l = i.endPts[s], c = a; c <= l; c++) { var u = c == a ? l : c - 1, d = c == l ? a : c + 1, p = 1 & i.flags[c], m = 1 & i.flags[u], v = 1 & i.flags[d], y = i.xs[c], _ = i.ys[c]; if (c == a) if (p) { if (!m) { e.U.P.moveTo(o, y, _); continue } e.U.P.moveTo(o, i.xs[u], i.ys[u]) } else m ? e.U.P.moveTo(o, i.xs[u], i.ys[u]) : e.U.P.moveTo(o, (i.xs[u] + y) / 2, (i.ys[u] + _) / 2); p ? m && e.U.P.lineTo(o, y, _) : v ? e.U.P.qcurveTo(o, y, _, i.xs[d], i.ys[d]) : e.U.P.qcurveTo(o, y, _, (y + i.xs[d]) / 2, (_ + i.ys[d]) / 2) } e.U.P.closePath(o) } }, e.U._compoGlyph = function (i, o, s) { for (var a = 0; a < i.parts.length; a++) { var l = { cmds: [], crds: [] }, c = i.parts[a]; e.U._drawGlyf(c.glyphIndex, o, l); for (var u = c.m, d = 0; d < l.crds.length; d += 2) { var p = l.crds[d], m = l.crds[d + 1]; s.crds.push(p * u.a + m * u.b + u.tx), s.crds.push(p * u.c + m * u.d + u.ty) } for (d = 0; d < l.cmds.length; d++)s.cmds.push(l.cmds[d]) } }, e.U._getGlyphClass = function (i, o) { var s = e._lctf.getInterval(o, i); return s == -1 ? 0 : o[s + 2] }, e.U.getPairAdjustment = function (i, o, s) { var a = !1; if (i.GPOS) for (var l = i.GPOS, c = l.lookupList, u = l.featureList, d = [], p = 0; p < u.length; p++) { var m = u[p]; if (m.tag == "kern") { a = !0; for (var v = 0; v < m.tab.length; v++)if (!d[m.tab[v]]) { d[m.tab[v]] = !0; for (var y = c[m.tab[v]], _ = 0; _ < y.tabs.length; _++)if (y.tabs[_] != null) { var g, x = y.tabs[_]; if ((!x.coverage || (g = e._lctf.coverageIndex(x.coverage, o)) != -1) && y.ltype != 1) { if (y.ltype == 2) { var A = null; if (x.fmt == 1) { var E = x.pairsets[g]; for (p = 0; p < E.length; p++)E[p].gid2 == s && (A = E[p]) } else if (x.fmt == 2) { var w = e.U._getGlyphClass(o, x.classDef1), b = e.U._getGlyphClass(s, x.classDef2); A = x.matrix[w][b] } if (A) { var T = 0; return A.val1 && A.val1[2] && (T += A.val1[2]), A.val2 && A.val2[0] && (T += A.val2[0]), T } } } } } } } if (i.kern && !a) { var B = i.kern.glyph1.indexOf(o); if (B != -1) { var R = i.kern.rval[B].glyph2.indexOf(s); if (R != -1) return i.kern.rval[B].vals[R] } } return 0 }, e.U._applySubs = function (i, o, s, a) { for (var l = i.length - o - 1, c = 0; c < s.tabs.length; c++)if (s.tabs[c] != null) { var u, d = s.tabs[c]; if (!d.coverage || (u = e._lctf.coverageIndex(d.coverage, i[o])) != -1) { if (s.ltype == 1) i[o], d.fmt == 1 ? i[o] = i[o] + d.delta : i[o] = d.newg[u]; else if (s.ltype == 4) for (var p = d.vals[u], m = 0; m < p.length; m++) { var v = p[m], y = v.chain.length; if (!(y > l)) { for (var _ = !0, g = 0, x = 0; x < y; x++) { for (; i[o + g + (1 + x)] == -1;)g++; v.chain[x] != i[o + g + (1 + x)] && (_ = !1) } if (_) { for (i[o] = v.nglyph, x = 0; x < y + g; x++)i[o + x + 1] = -1; break } } } else if (s.ltype == 5 && d.fmt == 2) for (var A = e._lctf.getInterval(d.cDef, i[o]), E = d.cDef[A + 2], w = d.scset[E], b = 0; b < w.length; b++) { var T = w[b], B = T.input; if (!(B.length > l)) { for (_ = !0, x = 0; x < B.length; x++) { var R = e._lctf.getInterval(d.cDef, i[o + 1 + x]); if (A == -1 && d.cDef[R + 2] != B[x]) { _ = !1; break } } if (_) { var P = T.substLookupRecords; for (m = 0; m < P.length; m += 2)P[m], P[m + 1] } } } else if (s.ltype == 6 && d.fmt == 3) { if (!e.U._glsCovered(i, d.backCvg, o - d.backCvg.length) || !e.U._glsCovered(i, d.inptCvg, o) || !e.U._glsCovered(i, d.ahedCvg, o + d.inptCvg.length)) continue; var U = d.lookupRec; for (b = 0; b < U.length; b += 2) { A = U[b]; var G = a[U[b + 1]]; e.U._applySubs(i, o + A, G, a) } } } } }, e.U._glsCovered = function (i, o, s) { for (var a = 0; a < o.length; a++)if (e._lctf.coverageIndex(o[a], i[s + a]) == -1) return !1; return !0 }, e.U.glyphsToPath = function (i, o, s) { for (var a = { cmds: [], crds: [] }, l = 0, c = 0; c < o.length; c++) { var u = o[c]; if (u != -1) { for (var d = c < o.length - 1 && o[c + 1] != -1 ? o[c + 1] : 0, p = e.U.glyphToPath(i, u), m = 0; m < p.crds.length; m += 2)a.crds.push(p.crds[m] + l), a.crds.push(p.crds[m + 1]); for (s && a.cmds.push(s), m = 0; m < p.cmds.length; m++)a.cmds.push(p.cmds[m]); s && a.cmds.push("X"), l += i.hmtx.aWidth[u], c < o.length - 1 && (l += e.U.getPairAdjustment(i, u, d)) } } return a }, e.U.P = {}, e.U.P.moveTo = function (i, o, s) { i.cmds.push("M"), i.crds.push(o, s) }, e.U.P.lineTo = function (i, o, s) { i.cmds.push("L"), i.crds.push(o, s) }, e.U.P.curveTo = function (i, o, s, a, l, c, u) { i.cmds.push("C"), i.crds.push(o, s, a, l, c, u) }, e.U.P.qcurveTo = function (i, o, s, a, l) { i.cmds.push("Q"), i.crds.push(o, s, a, l) }, e.U.P.closePath = function (i) { i.cmds.push("Z") }, e.U._drawCFF = function (i, o, s, a, l) { for (var c = o.stack, u = o.nStems, d = o.haveWidth, p = o.width, m = o.open, v = 0, y = o.x, _ = o.y, g = 0, x = 0, A = 0, E = 0, w = 0, b = 0, T = 0, B = 0, R = 0, P = 0, U = { val: 0, size: 0 }; v < i.length;) { e.CFF.getCharString(i, v, U); var G = U.val; if (v += U.size, G == "o1" || G == "o18") c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, d = !0; else if (G == "o3" || G == "o23") c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, d = !0; else if (G == "o4") c.length > 1 && !d && (p = c.shift() + a.nominalWidthX, d = !0), m && e.U.P.closePath(l), _ += c.pop(), e.U.P.moveTo(l, y, _), m = !0; else if (G == "o5") for (; c.length > 0;)y += c.shift(), _ += c.shift(), e.U.P.lineTo(l, y, _); else if (G == "o6" || G == "o7") for (var $ = c.length, z = G == "o6", j = 0; j < $; j++) { var q = c.shift(); z ? y += q : _ += q, z = !z, e.U.P.lineTo(l, y, _) } else if (G == "o8" || G == "o24") { $ = c.length; for (var se = 0; se + 6 <= $;)g = y + c.shift(), x = _ + c.shift(), A = g + c.shift(), E = x + c.shift(), y = A + c.shift(), _ = E + c.shift(), e.U.P.curveTo(l, g, x, A, E, y, _), se += 6; G == "o24" && (y += c.shift(), _ += c.shift(), e.U.P.lineTo(l, y, _)) } else { if (G == "o11") break; if (G == "o1234" || G == "o1235" || G == "o1236" || G == "o1237") G == "o1234" && (x = _, A = (g = y + c.shift()) + c.shift(), P = E = x + c.shift(), b = E, B = _, y = (T = (w = (R = A + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, g, x, A, E, R, P), e.U.P.curveTo(l, w, b, T, B, y, _)), G == "o1235" && (g = y + c.shift(), x = _ + c.shift(), A = g + c.shift(), E = x + c.shift(), R = A + c.shift(), P = E + c.shift(), w = R + c.shift(), b = P + c.shift(), T = w + c.shift(), B = b + c.shift(), y = T + c.shift(), _ = B + c.shift(), c.shift(), e.U.P.curveTo(l, g, x, A, E, R, P), e.U.P.curveTo(l, w, b, T, B, y, _)), G == "o1236" && (g = y + c.shift(), x = _ + c.shift(), A = g + c.shift(), P = E = x + c.shift(), b = E, T = (w = (R = A + c.shift()) + c.shift()) + c.shift(), B = b + c.shift(), y = T + c.shift(), e.U.P.curveTo(l, g, x, A, E, R, P), e.U.P.curveTo(l, w, b, T, B, y, _)), G == "o1237" && (g = y + c.shift(), x = _ + c.shift(), A = g + c.shift(), E = x + c.shift(), R = A + c.shift(), P = E + c.shift(), w = R + c.shift(), b = P + c.shift(), T = w + c.shift(), B = b + c.shift(), Math.abs(T - y) > Math.abs(B - _) ? y = T + c.shift() : _ = B + c.shift(), e.U.P.curveTo(l, g, x, A, E, R, P), e.U.P.curveTo(l, w, b, T, B, y, _)); else if (G == "o14") { if (c.length > 0 && !d && (p = c.shift() + s.nominalWidthX, d = !0), c.length == 4) { var W = c.shift(), V = c.shift(), J = c.shift(), O = c.shift(), k = e.CFF.glyphBySE(s, J), Z = e.CFF.glyphBySE(s, O); e.U._drawCFF(s.CharStrings[k], o, s, a, l), o.x = W, o.y = V, e.U._drawCFF(s.CharStrings[Z], o, s, a, l) } m && (e.U.P.closePath(l), m = !1) } else if (G == "o19" || G == "o20") c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, d = !0, v += u + 7 >> 3; else if (G == "o21") c.length > 2 && !d && (p = c.shift() + a.nominalWidthX, d = !0), _ += c.pop(), y += c.pop(), m && e.U.P.closePath(l), e.U.P.moveTo(l, y, _), m = !0; else if (G == "o22") c.length > 1 && !d && (p = c.shift() + a.nominalWidthX, d = !0), y += c.pop(), m && e.U.P.closePath(l), e.U.P.moveTo(l, y, _), m = !0; else if (G == "o25") { for (; c.length > 6;)y += c.shift(), _ += c.shift(), e.U.P.lineTo(l, y, _); g = y + c.shift(), x = _ + c.shift(), A = g + c.shift(), E = x + c.shift(), y = A + c.shift(), _ = E + c.shift(), e.U.P.curveTo(l, g, x, A, E, y, _) } else if (G == "o26") for (c.length % 2 && (y += c.shift()); c.length > 0;)g = y, x = _ + c.shift(), y = A = g + c.shift(), _ = (E = x + c.shift()) + c.shift(), e.U.P.curveTo(l, g, x, A, E, y, _); else if (G == "o27") for (c.length % 2 && (_ += c.shift()); c.length > 0;)x = _, A = (g = y + c.shift()) + c.shift(), E = x + c.shift(), y = A + c.shift(), _ = E, e.U.P.curveTo(l, g, x, A, E, y, _); else if (G == "o10" || G == "o29") { var ee = G == "o10" ? a : s; if (c.length == 0) console.debug("error: empty stack"); else { var ne = c.pop(), K = ee.Subrs[ne + ee.Bias]; o.x = y, o.y = _, o.nStems = u, o.haveWidth = d, o.width = p, o.open = m, e.U._drawCFF(K, o, s, a, l), y = o.x, _ = o.y, u = o.nStems, d = o.haveWidth, p = o.width, m = o.open } } else if (G == "o30" || G == "o31") { var ae = c.length, ie = (se = 0, G == "o31"); for (se += ae - ($ = -3 & ae); se < $;)ie ? (x = _, A = (g = y + c.shift()) + c.shift(), _ = (E = x + c.shift()) + c.shift(), $ - se == 5 ? (y = A + c.shift(), se++) : y = A, ie = !1) : (g = y, x = _ + c.shift(), A = g + c.shift(), E = x + c.shift(), y = A + c.shift(), $ - se == 5 ? (_ = E + c.shift(), se++) : _ = E, ie = !0), e.U.P.curveTo(l, g, x, A, E, y, _), se += 4 } else { if ((G + "").charAt(0) == "o") throw console.debug("Unknown operation: " + G, i), G; c.push(G) } } } o.x = y, o.y = _, o.nStems = u, o.haveWidth = d, o.width = p, o.open = m }; var t = e, r = { Typr: t }; return n.Typr = t, n.default = r, Object.defineProperty(n, "__esModule", { value: !0 }), n }({}).Typr }/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/function uj() { return function (n) { var e = Uint8Array, t = Uint16Array, r = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), s = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), a = function (G, $) { for (var z = new t(31), j = 0; j < 31; ++j)z[j] = $ += 1 << G[j - 1]; var q = new r(z[30]); for (j = 1; j < 30; ++j)for (var se = z[j]; se < z[j + 1]; ++se)q[se] = se - z[j] << 5 | j; return [z, q] }, l = a(i, 2), c = l[0], u = l[1]; c[28] = 258, u[258] = 28; for (var d = a(o, 0)[0], p = new t(32768), m = 0; m < 32768; ++m) { var v = (43690 & m) >>> 1 | (21845 & m) << 1; v = (61680 & (v = (52428 & v) >>> 2 | (13107 & v) << 2)) >>> 4 | (3855 & v) << 4, p[m] = ((65280 & v) >>> 8 | (255 & v) << 8) >>> 1 } var y = function (G, $, z) { for (var j = G.length, q = 0, se = new t($); q < j; ++q)++se[G[q] - 1]; var W, V = new t($); for (q = 0; q < $; ++q)V[q] = V[q - 1] + se[q - 1] << 1; if (z) { W = new t(1 << $); var J = 15 - $; for (q = 0; q < j; ++q)if (G[q]) for (var O = q << 4 | G[q], k = $ - G[q], Z = V[G[q] - 1]++ << k, ee = Z | (1 << k) - 1; Z <= ee; ++Z)W[p[Z] >>> J] = O } else for (W = new t(j), q = 0; q < j; ++q)G[q] && (W[q] = p[V[G[q] - 1]++] >>> 15 - G[q]); return W }, _ = new e(288); for (m = 0; m < 144; ++m)_[m] = 8; for (m = 144; m < 256; ++m)_[m] = 9; for (m = 256; m < 280; ++m)_[m] = 7; for (m = 280; m < 288; ++m)_[m] = 8; var g = new e(32); for (m = 0; m < 32; ++m)g[m] = 5; var x = y(_, 9, 1), A = y(g, 5, 1), E = function (G) { for (var $ = G[0], z = 1; z < G.length; ++z)G[z] > $ && ($ = G[z]); return $ }, w = function (G, $, z) { var j = $ / 8 | 0; return (G[j] | G[j + 1] << 8) >> (7 & $) & z }, b = function (G, $) { var z = $ / 8 | 0; return (G[z] | G[z + 1] << 8 | G[z + 2] << 16) >> (7 & $) }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], B = function (G, $, z) { var j = new Error($ || T[G]); if (j.code = G, Error.captureStackTrace && Error.captureStackTrace(j, B), !z) throw j; return j }, R = function (G, $, z) { var j = G.length; if (!j || z && !z.l && j < 5) return $ || new e(0); var q = !$ || z, se = !z || z.i; z || (z = {}), $ || ($ = new e(3 * j)); var W, V = function (Je) { var re = $.length; if (Je > re) { var _e = new e(Math.max(2 * re, Je)); _e.set($), $ = _e } }, J = z.f || 0, O = z.p || 0, k = z.b || 0, Z = z.l, ee = z.d, ne = z.m, K = z.n, ae = 8 * j; do { if (!Z) { z.f = J = w(G, O, 1); var ie = w(G, O + 1, 3); if (O += 3, !ie) { var Se = G[(we = ((W = O) / 8 | 0) + (7 & W && 1) + 4) - 4] | G[we - 3] << 8, Ce = we + Se; if (Ce > j) { se && B(0); break } q && V(k + Se), $.set(G.subarray(we, Ce), k), z.b = k += Se, z.p = O = 8 * Ce; continue } if (ie == 1) Z = x, ee = A, ne = 9, K = 5; else if (ie == 2) { var le = w(G, O, 31) + 257, F = w(G, O + 10, 15) + 4, me = le + w(G, O + 5, 31) + 1; O += 14; for (var he = new e(me), ce = new e(19), fe = 0; fe < F; ++fe)ce[s[fe]] = w(G, O + 3 * fe, 7); O += 3 * F; var Re = E(ce), de = (1 << Re) - 1, Ie = y(ce, Re, 1); for (fe = 0; fe < me;) { var we, ge = Ie[w(G, O, de)]; if (O += 15 & ge, (we = ge >>> 4) < 16) he[fe++] = we; else { var Ve = 0, H = 0; for (we == 16 ? (H = 3 + w(G, O, 3), O += 2, Ve = he[fe - 1]) : we == 17 ? (H = 3 + w(G, O, 7), O += 3) : we == 18 && (H = 11 + w(G, O, 127), O += 7); H--;)he[fe++] = Ve } } var L = he.subarray(0, le), oe = he.subarray(le); ne = E(L), K = E(oe), Z = y(L, ne, 1), ee = y(oe, K, 1) } else B(1); if (O > ae) { se && B(0); break } } q && V(k + 131072); for (var Pe = (1 << ne) - 1, Ae = (1 << K) - 1, ye = O; ; ye = O) { var be = (Ve = Z[b(G, O) & Pe]) >>> 4; if ((O += 15 & Ve) > ae) { se && B(0); break } if (Ve || B(2), be < 256) $[k++] = be; else { if (be == 256) { ye = O, Z = null; break } var ke = be - 254; if (be > 264) { var He = i[fe = be - 257]; ke = w(G, O, (1 << He) - 1) + c[fe], O += He } var je = ee[b(G, O) & Ae], nt = je >>> 4; if (je || B(3), O += 15 & je, oe = d[nt], nt > 3 && (He = o[nt], oe += b(G, O) & (1 << He) - 1, O += He), O > ae) { se && B(0); break } q && V(k + 131072); for (var Te = k + ke; k < Te; k += 4)$[k] = $[k - oe], $[k + 1] = $[k + 1 - oe], $[k + 2] = $[k + 2 - oe], $[k + 3] = $[k + 3 - oe]; k = Te } } z.l = Z, z.p = ye, z.b = k, Z && (J = 1, z.m = ne, z.d = ee, z.n = K) } while (!J); return k == $.length ? $ : function (Je, re, _e) { (re == null || re < 0) && (re = 0), (_e == null || _e > Je.length) && (_e = Je.length); var Ne = new (Je instanceof t ? t : Je instanceof r ? r : e)(_e - re); return Ne.set(Je.subarray(re, _e)), Ne }($, 0, k) }, P = new e(0), U = typeof TextDecoder < "u" && new TextDecoder; try { U.decode(P, { stream: !0 }) } catch { } return n.convert_streams = function (G) { var $ = new DataView(G), z = 0; function j() { var le = $.getUint16(z); return z += 2, le } function q() { var le = $.getUint32(z); return z += 4, le } function se(le) { Se.setUint16(Ce, le), Ce += 2 } function W(le) { Se.setUint32(Ce, le), Ce += 4 } for (var V = { signature: q(), flavor: q(), length: q(), numTables: j(), reserved: j(), totalSfntSize: q(), majorVersion: j(), minorVersion: j(), metaOffset: q(), metaLength: q(), metaOrigLength: q(), privOffset: q(), privLength: q() }, J = 0; Math.pow(2, J) <= V.numTables;)J++; J--; for (var O = 16 * Math.pow(2, J), k = 16 * V.numTables - O, Z = 12, ee = [], ne = 0; ne < V.numTables; ne++)ee.push({ tag: q(), offset: q(), compLength: q(), origLength: q(), origChecksum: q() }), Z += 16; var K, ae = new Uint8Array(12 + 16 * ee.length + ee.reduce(function (le, F) { return le + F.origLength + 4 }, 0)), ie = ae.buffer, Se = new DataView(ie), Ce = 0; return W(V.flavor), se(V.numTables), se(O), se(J), se(k), ee.forEach(function (le) { W(le.tag), W(le.origChecksum), W(Z), W(le.origLength), le.outOffset = Z, (Z += le.origLength) % 4 != 0 && (Z += 4 - Z % 4) }), ee.forEach(function (le) { var F, me = G.slice(le.offset, le.offset + le.compLength); if (le.compLength != le.origLength) { var he = new Uint8Array(le.origLength); F = new Uint8Array(me, 2), R(F, he) } else he = new Uint8Array(me); ae.set(he, le.outOffset); var ce = 0; (Z = le.outOffset + le.origLength) % 4 != 0 && (ce = 4 - Z % 4), ae.set(new Uint8Array(ce).buffer, le.outOffset + le.origLength), K = Z + ce }), ie.slice(0, K) }, Object.defineProperty(n, "__esModule", { value: !0 }), n }({}).convert_streams } function fj(n, e) { const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, o = 2, s = 4, a = 8, l = 16, c = 32; let u; function d(w) { if (!u) { const b = { R: o, L: i, D: s, C: l, U: c, T: a }; u = new Map; for (let T in r) { let B = 0; r[T].split(",").forEach(R => { let [P, U] = R.split("+"); P = parseInt(P, 36), U = U ? parseInt(U, 36) : 0, u.set(B += P, b[T]); for (let G = U; G--;)u.set(++B, b[T]) }) } } return u.get(w) || c } const p = 1, m = 2, v = 3, y = 4, _ = [null, "isol", "init", "fina", "medi"]; function g(w) { const b = new Uint8Array(w.length); let T = c, B = p, R = -1; for (let P = 0; P < w.length; P++) { const U = w.codePointAt(P); let G = d(U) | 0, $ = p; G & a || (T & (i | s | l) ? G & (o | s | l) ? ($ = v, (B === p || B === v) && b[R]++) : G & (i | c) && (B === m || B === y) && b[R]-- : T & (o | c) && (B === m || B === y) && b[R]--, B = b[P] = $, T = G, R = P, U > 65535 && P++) } return b } function x(w, b) { const T = []; for (let R = 0; R < b.length; R++) { const P = b.codePointAt(R); P > 65535 && R++, T.push(n.U.codeToGlyph(w, P)) } const B = w.GSUB; if (B) { const { lookupList: R, featureList: P } = B; let U; const G = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, $ = []; P.forEach(z => { if (G.test(z.tag)) for (let j = 0; j < z.tab.length; j++) { if ($[z.tab[j]]) continue; $[z.tab[j]] = !0; const q = R[z.tab[j]], se = /^(isol|init|fina|medi)$/.test(z.tag); se && !U && (U = g(b)); for (let W = 0; W < T.length; W++)(!U || !se || _[U[W]] === z.tag) && n.U._applySubs(T, W, q, R) } }) } return T } function A(...w) { for (let b = 0; b < w.length; b++)if (typeof w[b] == "number") return w[b] } function E(w) { const b = Object.create(null), T = w["OS/2"], B = w.hhea, R = w.head.unitsPerEm, P = A(T && T.sTypoAscender, B && B.ascender, R), U = { unitsPerEm: R, ascender: P, descender: A(T && T.sTypoDescender, B && B.descender, 0), capHeight: A(T && T.sCapHeight, P), xHeight: A(T && T.sxHeight, P), lineGap: A(T && T.sTypoLineGap, B && B.lineGap), forEachGlyph(G, $, z, j) { let q = 0; const se = 1 / U.unitsPerEm * $, W = x(w, G); let V = 0, J = -1; return W.forEach((O, k) => { if (O !== -1) { let Z = b[O]; if (!Z) { const { cmds: ee, crds: ne } = n.U.glyphToPath(w, O); let K = "", ae = 0; for (let F = 0, me = ee.length; F < me; F++) { const he = t[ee[F]]; K += ee[F]; for (let ce = 1; ce <= he; ce++)K += (ce > 1 ? "," : "") + ne[ae++] } let ie, Se, Ce, le; if (ne.length) { ie = Se = 1 / 0, Ce = le = -1 / 0; for (let F = 0, me = ne.length; F < me; F += 2) { let he = ne[F], ce = ne[F + 1]; he < ie && (ie = he), ce < Se && (Se = ce), he > Ce && (Ce = he), ce > le && (le = ce) } } else ie = Ce = Se = le = 0; Z = b[O] = { index: O, advanceWidth: w.hmtx.aWidth[O], xMin: ie, yMin: Se, xMax: Ce, yMax: le, path: K, pathCommandCount: ee.length } } J !== -1 && (q += n.U.getPairAdjustment(w, J, O) * se), j.call(null, Z, q, V), Z.advanceWidth && (q += Z.advanceWidth * se), z && (q += z * $), J = O } V += G.codePointAt(V) > 65535 ? 2 : 1 }), q } }; return U } return function (b) { const T = new Uint8Array(b, 0, 4), B = n._bin.readASCII(T, 0, 4); if (B === "wOFF") b = e(b); else if (B === "wOF2") throw new Error("woff2 fonts not supported"); return E(n.parse(b)[0]) } } const dj = $p({ name: "Typr Font Parser", dependencies: [cj, uj, fj], init(n, e, t) { const r = n(), i = e(); return t(r, i) } }), mf = { defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff", sdfGlyphSize: 64, sdfMargin: 1 / 16, sdfExponent: 9, textureWidth: 2048 }, hj = new qe; function Vu() { return (self.performance || Date).now() } const rP = Object.create(null); function SF(n, e) { n = gj({}, n); const t = Vu(); if (n.font = vj(n.font || mf.defaultFontURL), n.text = "" + n.text, n.sdfGlyphSize = n.sdfGlyphSize || mf.sdfGlyphSize, n.colorRanges != null) { let d = {}; for (let p in n.colorRanges) if (n.colorRanges.hasOwnProperty(p)) { let m = n.colorRanges[p]; typeof m != "number" && (m = hj.set(m).getHex()), d[p] = m } n.colorRanges = d } Object.freeze(n); const { textureWidth: r, sdfExponent: i } = mf, { sdfGlyphSize: o } = n, s = r / o * 4; let a = rP[o]; if (!a) { const d = document.createElement("canvas"); d.width = r, d.height = o * 256 / s, a = rP[o] = { glyphCount: 0, sdfGlyphSize: o, sdfCanvas: d, sdfTexture: new An(d, void 0, void 0, void 0, fn, fn), contextLost: !1, glyphsByFont: new Map }, a.sdfTexture.generateMipmaps = !1, pj(a) } const { sdfTexture: l, sdfCanvas: c } = a; let u = a.glyphsByFont.get(n.font); u || a.glyphsByFont.set(n.font, u = new Map), _j(n).then(d => { const { glyphIds: p, glyphPositions: m, fontSize: v, unitsPerEm: y, timings: _ } = d, g = [], x = new Float32Array(p.length * 4), A = v / y; let E = 0, w = 0; const b = Vu(); p.forEach((U, G) => { let $ = u.get(U); if (!$) { const { path: se, pathBounds: W } = d.glyphData[U], V = Math.max(W[2] - W[0], W[3] - W[1]) / o * (mf.sdfMargin * o + .5), J = a.glyphCount++, O = [W[0] - V, W[1] - V, W[2] + V, W[3] + V]; u.set(U, $ = { path: se, atlasIndex: J, sdfViewBox: O }), g.push($) } const { sdfViewBox: z } = $, j = m[w++], q = m[w++]; x[E++] = j + z[0] * A, x[E++] = q + z[1] * A, x[E++] = j + z[2] * A, x[E++] = q + z[3] * A, p[G] = $.atlasIndex }), _.quads = (_.quads || 0) + (Vu() - b); const T = Vu(); _.sdf = {}; const B = c.height, R = Math.ceil(a.glyphCount / s), P = Math.pow(2, Math.ceil(Math.log2(R * o))); P > B && (console.info(`Increasing SDF texture size ${B}->${P}`), lj(c, r, P), l.dispose()), Promise.all(g.map(U => AF(U, a, n.gpuAccelerateSDF).then(({ timing: G }) => { _.sdf[U.atlasIndex] = G }))).then(() => { g.length && !a.contextLost && (EF(a), l.needsUpdate = !0), _.sdfTotal = Vu() - T, _.total = Vu() - t, e(Object.freeze({ parameters: n, sdfTexture: l, sdfGlyphSize: o, sdfExponent: i, glyphBounds: x, glyphAtlasIndices: p, glyphColors: d.glyphColors, caretPositions: d.caretPositions, caretHeight: d.caretHeight, chunkedBounds: d.chunkedBounds, ascender: d.ascender, descender: d.descender, lineHeight: d.lineHeight, capHeight: d.capHeight, xHeight: d.xHeight, topBaseline: d.topBaseline, blockBounds: d.blockBounds, visibleBounds: d.visibleBounds, timings: d.timings })) }) }), Promise.resolve().then(() => { a.contextLost || aj(c) }) } function AF({ path: n, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: i, contextLost: o }, s) { if (o) return Promise.resolve({ timing: -1 }); const { textureWidth: a, sdfExponent: l } = mf, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), d = u % (a / r) * r, p = Math.floor(u / (a / r)) * r, m = e % 4; return tj(r, r, n, t, c, l, i, d, p, m, s) } function pj(n) { const e = n.sdfCanvas; e.addEventListener("webglcontextlost", t => { console.log("Context Lost", t), t.preventDefault(), n.contextLost = !0 }), e.addEventListener("webglcontextrestored", t => { console.log("Context Restored", t), n.contextLost = !1; const r = []; n.glyphsByFont.forEach(i => { i.forEach(o => { r.push(AF(o, n, !0)) }) }), Promise.all(r).then(() => { EF(n), n.sdfTexture.needsUpdate = !0 }) }) } function mj({ font: n, characters: e, sdfGlyphSize: t }, r) {
	let i = Array.isArray(e) ? e.join(`
`) : "" + e; SF({ font: n, sdfGlyphSize: t, text: i }, r)
} function gj(n, e) { for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]); return n } let c0; function vj(n) { return c0 || (c0 = typeof document > "u" ? {} : document.createElement("a")), c0.href = n, c0.href } function EF(n) { if (typeof createImageBitmap != "function") { console.info("Safari<15: applying SDF canvas workaround"); const { sdfCanvas: e, sdfTexture: t } = n, { width: r, height: i } = e, o = n.sdfCanvas.getContext("webgl"); let s = t.image.data; (!s || s.length !== r * i * 4) && (s = new Uint8Array(r * i * 4), t.image = { width: r, height: i, data: s }, t.flipY = !1, t.isDataTexture = !0), o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, s) } } const yj = $p({ name: "Typesetter", dependencies: [mf, dj, ej, X7], init(n, e, t, r) { const { defaultFontURL: i } = n; return t(e, r(), { defaultFontURL: i }) } }), _j = $p({ name: "Typesetter", dependencies: [yj], init(n) { return function (e) { return new Promise(t => { n.typeset(e, t) }) } }, getTransferables(n) { const e = [n.glyphPositions.buffer, n.glyphIds.buffer]; return n.caretPositions && e.push(n.caretPositions.buffer), n.glyphColors && e.push(n.glyphColors.buffer), e } }), iP = {}; function xj(n) { let e = iP[n]; if (!e) { const t = new ba(1, 1, n, n), r = t.clone(), i = t.attributes, o = r.attributes, s = new bt, a = i.uv.count; for (let l = 0; l < a; l++)o.position.array[l * 3] *= -1, o.normal.array[l * 3 + 2] *= -1;["position", "normal", "uv"].forEach(l => { s.setAttribute(l, new ut([...i[l].array, ...o[l].array], i[l].itemSize)) }), s.setIndex([...t.index.array, ...r.index.array.map(l => l + a)]), s.translate(.5, .5, 0), e = iP[n] = s } return e } const Sj = "aTroikaGlyphBounds", oP = "aTroikaGlyphIndex", Aj = "aTroikaGlyphColor"; class Ej extends Fy { constructor() { super(), this.detail = 1, this.curveRadius = 0, this.groups = [{ start: 0, count: 1 / 0, materialIndex: 0 }, { start: 0, count: 1 / 0, materialIndex: 1 }], this.boundingSphere = new _i, this.boundingBox = new yi } computeBoundingSphere() { } computeBoundingBox() { } setSide(e) { const t = this.getIndex().count; this.setDrawRange(e === $r ? t / 2 : 0, e === Ti ? t : t / 2) } set detail(e) { if (e !== this._detail) { this._detail = e, (typeof e != "number" || e < 1) && (e = 1); let t = xj(e);["position", "normal", "uv"].forEach(r => { this.attributes[r] = t.attributes[r].clone() }), this.setIndex(t.getIndex().clone()) } } get detail() { return this._detail } set curveRadius(e) { e !== this._curveRadius && (this._curveRadius = e, this._updateBounds()) } get curveRadius() { return this._curveRadius } updateGlyphs(e, t, r, i, o) { kx(this, Sj, e, 4), kx(this, oP, t, 1), kx(this, Aj, o, 3), this._blockBounds = r, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds() } _updateBounds() { const e = this._blockBounds; if (e) { const { curveRadius: t, boundingBox: r } = this; if (t) { const { PI: i, floor: o, min: s, max: a, sin: l, cos: c } = Math, u = i / 2, d = i * 2, p = Math.abs(t), m = e[0] / p, v = e[2] / p, y = o((m + u) / d) !== o((v + u) / d) ? -p : s(l(m) * p, l(v) * p), _ = o((m - u) / d) !== o((v - u) / d) ? p : a(l(m) * p, l(v) * p), g = o((m + i) / d) !== o((v + i) / d) ? p * 2 : a(p - c(m) * p, p - c(v) * p); r.min.set(y, e[1], t < 0 ? -g : 0), r.max.set(_, e[3], t < 0 ? 0 : g) } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0); r.getBoundingSphere(this.boundingSphere) } } applyClipRect(e) { let t = this.getAttribute(oP).count, r = this._chunkedBounds; if (r) for (let i = r.length; i--;) { t = r[i].end; let o = r[i].rect; if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break } this.instanceCount = t } } function kx(n, e, t, r) { const i = n.getAttribute(e); t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (n.setAttribute(e, new Vc(t, r)), delete n._maxInstanceCount, n.dispose()) : i && n.deleteAttribute(e) } const Mj = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, wj = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, bj = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, Cj = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`; function Tj(n) {
	const e = ZA(n, {
		chained: !0, extensions: { derivatives: !0 }, uniforms: { uTroikaSDFTexture: { value: null }, uTroikaSDFTextureSize: { value: new Be }, uTroikaSDFGlyphSize: { value: 0 }, uTroikaSDFExponent: { value: 0 }, uTroikaTotalBounds: { value: new Ft(0, 0, 0, 0) }, uTroikaClipRect: { value: new Ft(0, 0, 0, 0) }, uTroikaDistanceOffset: { value: 0 }, uTroikaOutlineOpacity: { value: 0 }, uTroikaFillOpacity: { value: 1 }, uTroikaPositionOffset: { value: new Be }, uTroikaCurveRadius: { value: 0 }, uTroikaBlurRadius: { value: 0 }, uTroikaStrokeWidth: { value: 0 }, uTroikaStrokeColor: { value: new qe }, uTroikaStrokeOpacity: { value: 1 }, uTroikaOrient: { value: new Rt }, uTroikaUseGlyphColors: { value: !0 }, uTroikaSDFDebug: { value: !1 } }, vertexDefs: Mj, vertexTransform: wj, fragmentDefs: bj, fragmentColorTransform: Cj, customRewriter({ vertexShader: t, fragmentShader: r }) {
			let i = /\buniform\s+vec3\s+diffuse\b/; return i.test(r) && (r = r.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(_F, `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))), { vertexShader: t, fragmentShader: r }
		}
	}); return e.transparent = !0, Object.defineProperties(e, { isTroikaTextMaterial: { value: !0 }, shadowSide: { get() { return this.side }, set() { } } }), e
} const yw = new hi({ color: 16777215, side: Ti, transparent: !0 }), sP = 8421504, aP = new _t, u0 = new X, Nx = new X, rh = [], Rj = new X, zx = "+x+y"; function lP(n) { return Array.isArray(n) ? n[0] : n } let MF = () => { const n = new In(new ba(1, 1), yw); return MF = () => n, n }, wF = () => { const n = new In(new ba(1, 1, 32, 1), yw); return wF = () => n, n }; const Pj = { type: "syncstart" }, Bj = { type: "synccomplete" }, bF = ["font", "fontSize", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"], Ij = bF.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail"); let CF = class extends In { constructor() { const e = new Ej; super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = .1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = sP, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = zx, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1 } sync(e) { this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(Pj), SF({ text: this.text, font: this.font, fontSize: this.fontSize || .1, letterSpacing: this.letterSpacing || 0, lineHeight: this.lineHeight || "normal", maxWidth: this.maxWidth, direction: this.direction || "auto", textAlign: this.textAlign, textIndent: this.textIndent, whiteSpace: this.whiteSpace, overflowWrap: this.overflowWrap, anchorX: this.anchorX, anchorY: this.anchorY, colorRanges: this.colorRanges, includeCaretPositions: !0, sdfGlyphSize: this.sdfGlyphSize, gpuAccelerateSDF: this.gpuAccelerateSDF }, t => { this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors); const r = this._queuedSyncs; r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => { r.forEach(i => i && i()) })), this.dispatchEvent(Bj), e && e() }))) } onBeforeRender(e, t, r, i, o, s) { this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o), o._hadOwnSide = o.hasOwnProperty("side"), this.geometry.setSide(o._actualSide = o.side), o.side = qo } onAfterRender(e, t, r, i, o, s) { o._hadOwnSide ? o.side = o._actualSide : delete o.side } dispose() { this.geometry.dispose() } get textRenderInfo() { return this._textRenderInfo || null } get material() { let e = this._derivedMaterial; const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = yw.clone()); if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = Tj(t), t.addEventListener("dispose", function r() { t.removeEventListener("dispose", r), e.dispose() })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) { let r = e._outlineMtl; return r || (r = e._outlineMtl = Object.create(e, { id: { value: e.id + .1 } }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function i() { e.removeEventListener("dispose", i), r.dispose() })), [r, e] } else return e } set material(e) { e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e } get glyphGeometryDetail() { return this.geometry.detail } set glyphGeometryDetail(e) { this.geometry.detail = e } get curveRadius() { return this.geometry.curveRadius } set curveRadius(e) { this.geometry.curveRadius = e } get customDepthMaterial() { return lP(this.material).getDepthMaterial() } get customDistanceMaterial() { return lP(this.material).getDistanceMaterial() } _prepareForRender(e) { const t = e.isTextOutlineMaterial, r = e.uniforms, i = this.textRenderInfo; if (i) { const { sdfTexture: a, blockBounds: l } = i; r.uTroikaSDFTexture.value = a, r.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, r.uTroikaSDFExponent.value = i.sdfExponent, r.uTroikaTotalBounds.value.fromArray(l), r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors; let c = 0, u = 0, d = 0, p, m, v, y = 0, _ = 0; if (t) { let { outlineWidth: x, outlineOffsetX: A, outlineOffsetY: E, outlineBlur: w, outlineOpacity: b } = this; c = this._parsePercent(x) || 0, u = Math.max(0, this._parsePercent(w) || 0), p = b, y = this._parsePercent(A) || 0, _ = this._parsePercent(E) || 0 } else d = Math.max(0, this._parsePercent(this.strokeWidth) || 0), d && (v = this.strokeColor, r.uTroikaStrokeColor.value.set(v ?? sP), m = this.strokeOpacity, m == null && (m = 1)), p = this.fillOpacity; r.uTroikaDistanceOffset.value = c, r.uTroikaPositionOffset.value.set(y, _), r.uTroikaBlurRadius.value = u, r.uTroikaStrokeWidth.value = d, r.uTroikaStrokeOpacity.value = m, r.uTroikaFillOpacity.value = p ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0; let g = this.clipRect; if (g && Array.isArray(g) && g.length === 4) r.uTroikaClipRect.value.fromArray(g); else { const x = (this.fontSize || .1) * 100; r.uTroikaClipRect.value.set(l[0] - x, l[1] - x, l[2] + x, l[3] + x) } this.geometry.applyClipRect(r.uTroikaClipRect.value) } r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0; const o = t ? this.outlineColor || 0 : this.color; if (o == null) delete e.color; else { const a = e.hasOwnProperty("color") ? e.color : e.color = new qe; (o !== a._input || typeof o == "object") && a.set(a._input = o) } let s = this.orientation || zx; if (s !== e._orientation) { let a = r.uTroikaOrient.value; s = s.replace(/[^-+xyz]/g, ""); let l = s !== zx && s.match(/^([-+])([xyz])([-+])([xyz])$/); if (l) { let [, c, u, d, p] = l; u0.set(0, 0, 0)[u] = c === "-" ? 1 : -1, Nx.set(0, 0, 0)[p] = d === "-" ? -1 : 1, aP.lookAt(Rj, u0.cross(Nx), Nx), a.setFromMatrix4(aP) } else a.identity(); e._orientation = s } } _parsePercent(e) { if (typeof e == "string") { let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN; e = (isNaN(r) ? 0 : r / 100) * this.fontSize } return e } localPositionToTextCoords(e, t = new Be) { t.copy(e); const r = this.curveRadius; return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t } worldPositionToTextCoords(e, t = new Be) { return u0.copy(e), this.localPositionToTextCoords(this.worldToLocal(u0), t) } raycast(e, t) { const { textRenderInfo: r, curveRadius: i } = this; if (r) { const o = r.blockBounds, s = i ? wF() : MF(), a = s.geometry, { position: l, uv: c } = a.attributes; for (let u = 0; u < c.count; u++) { let d = o[0] + c.getX(u) * (o[2] - o[0]); const p = o[1] + c.getY(u) * (o[3] - o[1]); let m = 0; i && (m = i - Math.cos(d / i) * i, d = Math.sin(d / i) * i), l.setXYZ(u, d, p, m) } a.boundingSphere = this.geometry.boundingSphere, a.boundingBox = this.geometry.boundingBox, s.matrixWorld = this.matrixWorld, s.material.side = this.material.side, rh.length = 0, s.raycast(e, rh); for (let u = 0; u < rh.length; u++)rh[u].object = this, t.push(rh[u]) } } copy(e) { const t = this.geometry; return super.copy(e), this.geometry = t, Ij.forEach(r => { this[r] = e[r] }), this } clone() { return new this.constructor().copy(this) } }; bF.forEach(n => { const e = "_private_" + n; Object.defineProperty(CF.prototype, n, { get() { return this[e] }, set(t) { t !== this[e] && (this[e] = t, this._needsSync = !0) } }) }); const _n = N.forwardRef(({ sdfGlyphSize: n = 64, anchorX: e = "center", anchorY: t = "middle", font: r, fontSize: i = 1, children: o, characters: s, onSync: a, ...l }, c) => { const u = Yi(({ invalidate: v }) => v), [d] = N.useState(() => new CF), [p, m] = N.useMemo(() => { const v = []; let y = ""; return N.Children.forEach(o, _ => { typeof _ == "string" || typeof _ == "number" ? y += _ : v.push(_) }), [v, y] }, [o]); return jO(() => new Promise(v => mj({ font: r, characters: s }, v)), ["troika-text", r, s]), N.useLayoutEffect(() => void d.sync(() => { u(), a && a(d) })), N.useEffect(() => () => d.dispose(), [d]), N.createElement("primitive", Ee({ object: d, ref: c, font: r, text: m, anchorX: e, anchorY: t, fontSize: i, sdfGlyphSize: n }, l), p) }), Lj = N.forwardRef(({ children: n, multisamping: e = 8, renderIndex: t = 1, disableRender: r, disableGamma: i, disableRenderPass: o, depthBuffer: s = !0, stencilBuffer: a = !1, anisotropy: l = 1, encoding: c, type: u, ...d }, p) => { N.useMemo(() => ky({ EffectComposer: ZW, RenderPass: t7, ShaderPass: WA }), []); const m = N.useRef(), { scene: v, camera: y, gl: _, size: g, viewport: x } = Yi(), [A] = N.useState(() => { const w = new Qr(g.width, g.height, { type: u || Ts, format: Yr, depthBuffer: s, stencilBuffer: a, anisotropy: l }); return u === $o && c != null && ("colorSpace" in w ? w.texture.colorSpace = c : w.texture.encoding = c), w.samples = e, w }); N.useEffect(() => { var w, b; (w = m.current) == null || w.setSize(g.width, g.height), (b = m.current) == null || b.setPixelRatio(x.dpr) }, [_, g, x.dpr]), rs(() => { var w; r || (w = m.current) == null || w.render() }, t); const E = []; return o || E.push(N.createElement("renderPass", { key: "renderpass", attach: `passes-${E.length}`, args: [v, y] })), i || E.push(N.createElement("shaderPass", { attach: `passes-${E.length}`, key: "gammapass", args: [D7] })), N.Children.forEach(n, w => { w && E.push(N.cloneElement(w, { key: E.length, attach: `passes-${E.length}` })) }), N.createElement("effectComposer", Ee({ ref: DW([p, m]), args: [_, A] }, d), E) }); function Dj(n, e, t, r) { const i = class extends _r { constructor(s = {}) { const a = Object.entries(n); super({ uniforms: a.reduce((l, [c, u]) => { const d = _a.clone({ [c]: { value: u } }); return { ...l, ...d } }, {}), vertexShader: e, fragmentShader: t }), this.key = "", a.forEach(([l]) => Object.defineProperty(this, l, { get: () => this.uniforms[l].value, set: c => this.uniforms[l].value = c })), Object.assign(this, s), r && r(this) } }; return i.key = Up.generateUUID(), i } const Oj = () => parseInt(Qc.replace(/\D+/g, "")), Fj = Oj(); let f0 = null, TF = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"; function RF(n, e, t) { return r => { t && t(r), n && (f0 || (f0 = new O7), f0.setDecoderPath(typeof n == "string" ? n : TF), r.setDRACOLoader(f0)), e && r.setMeshoptDecoder(typeof Fx == "function" ? Fx() : Fx) } } function Ns(n, e = !0, t = !0, r) { return Lo(mw, n, RF(e, t, r)) } Ns.preload = (n, e = !0, t = !0, r) => Lo.preload(mw, n, RF(e, t, r)); Ns.clear = n => Lo.clear(mw, n); Ns.setDecoderPath = n => { TF = n }; const Uj = N.forwardRef(({ makeDefault: n, camera: e, regress: t, domElement: r, enableDamping: i = !0, keyEvents: o = !1, onChange: s, onStart: a, onEnd: l, ...c }, u) => { const d = Yi(b => b.invalidate), p = Yi(b => b.camera), m = Yi(b => b.gl), v = Yi(b => b.events), y = Yi(b => b.setEvents), _ = Yi(b => b.set), g = Yi(b => b.get), x = Yi(b => b.performance), A = e || p, E = r || v.connected || m.domElement, w = N.useMemo(() => new NW(A), [A]); return rs(() => { w.enabled && w.update() }, -1), N.useEffect(() => (o && w.connect(o === !0 ? E : o), w.connect(E), () => void w.dispose()), [o, E, t, w, d]), N.useEffect(() => { const b = R => { d(), t && x.regress(), s && s(R) }, T = R => { a && a(R) }, B = R => { l && l(R) }; return w.addEventListener("change", b), w.addEventListener("start", T), w.addEventListener("end", B), () => { w.removeEventListener("start", T), w.removeEventListener("end", B), w.removeEventListener("change", b) } }, [s, a, l, w, d, y]), N.useEffect(() => { if (n) { const b = g().controls; return _({ controls: w }), () => _({ controls: b }) } }, [n, w]), N.createElement("primitive", Ee({ ref: u, object: w, enableDamping: i }, c)) }); function kj(n, e) { const t = N.useRef(), [r] = N.useState(() => e ? e instanceof Ut ? { current: e } : e : t), [i] = N.useState(() => new OO(void 0)); N.useLayoutEffect(() => { e && (r.current = e instanceof Ut ? e : e.current), i._root = r.current }); const o = N.useRef({}), s = N.useMemo(() => { const a = {}; return n.forEach(l => Object.defineProperty(a, l.name, { enumerable: !0, get() { if (r.current) return o.current[l.name] || (o.current[l.name] = i.clipAction(l, r.current)) }, configurable: !0 })), { ref: r, clips: n, actions: a, names: n.map(l => l.name), mixer: i } }, [n]); return rs((a, l) => i.update(l)), N.useEffect(() => { const a = r.current; return () => { o.current = {}, i.stopAllAction(), Object.values(s.actions).forEach(l => { a && i.uncacheAction(l, a) }) } }, [n]), s } const Nj = Dj({ time: 0, pixelRatio: 1 }, ` uniform float pixelRatio;
    uniform float time;
    attribute float size;  
    attribute float speed;  
    attribute float opacity;
    attribute vec3 noise;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vOpacity;
    void main() {
      vec4 modelPosition = modelMatrix * vec4(position, 1.0);
      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;
      gl_PointSize = size * 25. * pixelRatio;
      gl_PointSize *= (1.0 / - viewPosition.z);
      vColor = color;
      vOpacity = opacity;
    }`, ` varying vec3 vColor;
    varying float vOpacity;
    void main() {
      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
      float strength = 0.05 / distanceToCenter - 0.1;
      gl_FragColor = vec4(vColor, strength * vOpacity);
      #include <tonemapping_fragment>
      #include <${Fj >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`), PF = n => n && n.constructor === Float32Array, zj = n => [n.r, n.g, n.b], BF = n => n instanceof Be || n instanceof X || n instanceof Ft, IF = n => Array.isArray(n) ? n : BF(n) ? n.toArray() : [n, n, n]; function ih(n, e, t) { return N.useMemo(() => { if (e !== void 0) { if (PF(e)) return e; if (e instanceof qe) { const r = Array.from({ length: n * 3 }, () => zj(e)).flat(); return Float32Array.from(r) } else if (BF(e) || Array.isArray(e)) { const r = Array.from({ length: n * 3 }, () => IF(e)).flat(); return Float32Array.from(r) } return Float32Array.from({ length: n }, () => e) } return Float32Array.from({ length: n }, t) }, [e]) } const Gj = N.forwardRef(({ noise: n = 1, count: e = 100, speed: t = 1, opacity: r = 1, scale: i = 1, size: o, color: s, children: a, ...l }, c) => { N.useMemo(() => ky({ SparklesImplMaterial: Nj }), []); const u = N.useRef(null), d = Yi(A => A.viewport.dpr), p = IF(i), m = N.useMemo(() => Float32Array.from(Array.from({ length: e }, () => p.map(Up.randFloatSpread)).flat()), [e, ...p]), v = ih(e, o, Math.random), y = ih(e, r), _ = ih(e, t), g = ih(e * 3, n), x = ih(s === void 0 ? e * 3 : e, PF(s) ? s : new qe(s), () => 1); return rs(A => { u.current && u.current.material && (u.current.material.time = A.clock.elapsedTime) }), N.useImperativeHandle(c, () => u.current, []), N.createElement("points", Ee({ key: `particle-${e}-${JSON.stringify(i)}` }, l, { ref: u }), N.createElement("bufferGeometry", null, N.createElement("bufferAttribute", { attach: "attributes-position", args: [m, 3] }), N.createElement("bufferAttribute", { attach: "attributes-size", args: [v, 1] }), N.createElement("bufferAttribute", { attach: "attributes-opacity", args: [y, 1] }), N.createElement("bufferAttribute", { attach: "attributes-speed", args: [_, 1] }), N.createElement("bufferAttribute", { attach: "attributes-color", args: [x, 3] }), N.createElement("bufferAttribute", { attach: "attributes-noise", args: [g, 3] })), a || N.createElement("sparklesImplMaterial", { transparent: !0, pixelRatio: d, depthWrite: !1 })) }), Hj = "images/cubeText1-ec843cde.jpg"; var LF = { exports: {} }, DF = {};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Jf = N; function Vj(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var Wj = typeof Object.is == "function" ? Object.is : Vj, jj = Jf.useState, Xj = Jf.useEffect, Jj = Jf.useLayoutEffect, Kj = Jf.useDebugValue; function Yj(n, e) { var t = e(), r = jj({ inst: { value: t, getSnapshot: e } }), i = r[0].inst, o = r[1]; return Jj(function () { i.value = t, i.getSnapshot = e, Gx(i) && o({ inst: i }) }, [n, t, e]), Xj(function () { return Gx(i) && o({ inst: i }), n(function () { Gx(i) && o({ inst: i }) }) }, [n]), Kj(t), t } function Gx(n) { var e = n.getSnapshot; n = n.value; try { var t = e(); return !Wj(n, t) } catch { return !0 } } function $j(n, e) { return e() } var Qj = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? $j : Yj; DF.useSyncExternalStore = Jf.useSyncExternalStore !== void 0 ? Jf.useSyncExternalStore : Qj; LF.exports = DF; var Zj = LF.exports, OF = { exports: {} }, FF = {};/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var zy = N, qj = Zj; function eX(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var tX = typeof Object.is == "function" ? Object.is : eX, nX = qj.useSyncExternalStore, rX = zy.useRef, iX = zy.useEffect, oX = zy.useMemo, sX = zy.useDebugValue; FF.useSyncExternalStoreWithSelector = function (n, e, t, r, i) { var o = rX(null); if (o.current === null) { var s = { hasValue: !1, value: null }; o.current = s } else s = o.current; o = oX(function () { function l(m) { if (!c) { if (c = !0, u = m, m = r(m), i !== void 0 && s.hasValue) { var v = s.value; if (i(v, m)) return d = v } return d = m } if (v = d, tX(u, m)) return v; var y = r(m); return i !== void 0 && i(v, y) ? v : (u = m, d = y) } var c = !1, u, d, p = t === void 0 ? null : t; return [function () { return l(e()) }, p === null ? void 0 : function () { return l(p()) }] }, [e, t, r, i]); var a = nX(n, o[0], o[1]); return iX(function () { s.hasValue = !0, s.value = a }, [a]), sX(a), a }; OF.exports = FF; var aX = OF.exports; function lX(n) { n() } let UF = lX; const cX = n => UF = n, uX = () => UF, cP = Symbol.for("react-redux-context"), uP = typeof globalThis < "u" ? globalThis : {}; function fX() { var n; if (!N.createContext) return {}; const e = (n = uP[cP]) != null ? n : uP[cP] = new Map; let t = e.get(N.createContext); return t || (t = N.createContext(null), e.set(N.createContext, t)), t } const Ml = fX(); function _w(n = Ml) { return function () { return N.useContext(n) } } const kF = _w(), dX = () => { throw new Error("uSES not initialized!") }; let NF = dX; const hX = n => { NF = n }, pX = (n, e) => n === e; function mX(n = Ml) { const e = n === Ml ? kF : _w(n); return function (r, i = {}) { const { equalityFn: o = pX, stabilityCheck: s = void 0, noopCheck: a = void 0 } = typeof i == "function" ? { equalityFn: i } : i, { store: l, subscription: c, getServerState: u, stabilityCheck: d, noopCheck: p } = e(); N.useRef(!0); const m = N.useCallback({ [r.name](y) { return r(y) } }[r.name], [r, d, s]), v = NF(c.addNestedSub, l.getState, u || l.getState, m, o); return N.useDebugValue(v), v } } const mi = mX(); function Wt(n, e) { if (n == null) return {}; var t = {}, r = Object.keys(n), i, o; for (o = 0; o < r.length; o++)i = r[o], !(e.indexOf(i) >= 0) && (t[i] = n[i]); return t } var zF = { exports: {} }, sn = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ar = typeof Symbol == "function" && Symbol.for, xw = Ar ? Symbol.for("react.element") : 60103, Sw = Ar ? Symbol.for("react.portal") : 60106, Gy = Ar ? Symbol.for("react.fragment") : 60107, Hy = Ar ? Symbol.for("react.strict_mode") : 60108, Vy = Ar ? Symbol.for("react.profiler") : 60114, Wy = Ar ? Symbol.for("react.provider") : 60109, jy = Ar ? Symbol.for("react.context") : 60110, Aw = Ar ? Symbol.for("react.async_mode") : 60111, Xy = Ar ? Symbol.for("react.concurrent_mode") : 60111, Jy = Ar ? Symbol.for("react.forward_ref") : 60112, Ky = Ar ? Symbol.for("react.suspense") : 60113, gX = Ar ? Symbol.for("react.suspense_list") : 60120, Yy = Ar ? Symbol.for("react.memo") : 60115, $y = Ar ? Symbol.for("react.lazy") : 60116, vX = Ar ? Symbol.for("react.block") : 60121, yX = Ar ? Symbol.for("react.fundamental") : 60117, _X = Ar ? Symbol.for("react.responder") : 60118, xX = Ar ? Symbol.for("react.scope") : 60119; function uo(n) { if (typeof n == "object" && n !== null) { var e = n.$$typeof; switch (e) { case xw: switch (n = n.type, n) { case Aw: case Xy: case Gy: case Vy: case Hy: case Ky: return n; default: switch (n = n && n.$$typeof, n) { case jy: case Jy: case $y: case Yy: case Wy: return n; default: return e } }case Sw: return e } } } function GF(n) { return uo(n) === Xy } sn.AsyncMode = Aw; sn.ConcurrentMode = Xy; sn.ContextConsumer = jy; sn.ContextProvider = Wy; sn.Element = xw; sn.ForwardRef = Jy; sn.Fragment = Gy; sn.Lazy = $y; sn.Memo = Yy; sn.Portal = Sw; sn.Profiler = Vy; sn.StrictMode = Hy; sn.Suspense = Ky; sn.isAsyncMode = function (n) { return GF(n) || uo(n) === Aw }; sn.isConcurrentMode = GF; sn.isContextConsumer = function (n) { return uo(n) === jy }; sn.isContextProvider = function (n) { return uo(n) === Wy }; sn.isElement = function (n) { return typeof n == "object" && n !== null && n.$$typeof === xw }; sn.isForwardRef = function (n) { return uo(n) === Jy }; sn.isFragment = function (n) { return uo(n) === Gy }; sn.isLazy = function (n) { return uo(n) === $y }; sn.isMemo = function (n) { return uo(n) === Yy }; sn.isPortal = function (n) { return uo(n) === Sw }; sn.isProfiler = function (n) { return uo(n) === Vy }; sn.isStrictMode = function (n) { return uo(n) === Hy }; sn.isSuspense = function (n) { return uo(n) === Ky }; sn.isValidElementType = function (n) { return typeof n == "string" || typeof n == "function" || n === Gy || n === Xy || n === Vy || n === Hy || n === Ky || n === gX || typeof n == "object" && n !== null && (n.$$typeof === $y || n.$$typeof === Yy || n.$$typeof === Wy || n.$$typeof === jy || n.$$typeof === Jy || n.$$typeof === yX || n.$$typeof === _X || n.$$typeof === xX || n.$$typeof === vX) }; sn.typeOf = uo; zF.exports = sn; var SX = zF.exports, Ew = SX, AX = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, EX = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, MX = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, HF = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, Mw = {}; Mw[Ew.ForwardRef] = MX; Mw[Ew.Memo] = HF; function fP(n) { return Ew.isMemo(n) ? HF : Mw[n.$$typeof] || AX } var wX = Object.defineProperty, bX = Object.getOwnPropertyNames, dP = Object.getOwnPropertySymbols, CX = Object.getOwnPropertyDescriptor, TX = Object.getPrototypeOf, hP = Object.prototype; function VF(n, e, t) { if (typeof e != "string") { if (hP) { var r = TX(e); r && r !== hP && VF(n, r, t) } var i = bX(e); dP && (i = i.concat(dP(e))); for (var o = fP(n), s = fP(e), a = 0; a < i.length; ++a) { var l = i[a]; if (!EX[l] && !(t && t[l]) && !(s && s[l]) && !(o && o[l])) { var c = CX(e, l); try { wX(n, l, c) } catch { } } } } return n } var RX = VF; const PX = Rp(RX); var WF = { exports: {} }, an = {};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ww = Symbol.for("react.element"), bw = Symbol.for("react.portal"), Qy = Symbol.for("react.fragment"), Zy = Symbol.for("react.strict_mode"), qy = Symbol.for("react.profiler"), e1 = Symbol.for("react.provider"), t1 = Symbol.for("react.context"), BX = Symbol.for("react.server_context"), n1 = Symbol.for("react.forward_ref"), r1 = Symbol.for("react.suspense"), i1 = Symbol.for("react.suspense_list"), o1 = Symbol.for("react.memo"), s1 = Symbol.for("react.lazy"), IX = Symbol.for("react.offscreen"), jF; jF = Symbol.for("react.module.reference"); function Do(n) { if (typeof n == "object" && n !== null) { var e = n.$$typeof; switch (e) { case ww: switch (n = n.type, n) { case Qy: case qy: case Zy: case r1: case i1: return n; default: switch (n = n && n.$$typeof, n) { case BX: case t1: case n1: case s1: case o1: case e1: return n; default: return e } }case bw: return e } } } an.ContextConsumer = t1; an.ContextProvider = e1; an.Element = ww; an.ForwardRef = n1; an.Fragment = Qy; an.Lazy = s1; an.Memo = o1; an.Portal = bw; an.Profiler = qy; an.StrictMode = Zy; an.Suspense = r1; an.SuspenseList = i1; an.isAsyncMode = function () { return !1 }; an.isConcurrentMode = function () { return !1 }; an.isContextConsumer = function (n) { return Do(n) === t1 }; an.isContextProvider = function (n) { return Do(n) === e1 }; an.isElement = function (n) { return typeof n == "object" && n !== null && n.$$typeof === ww }; an.isForwardRef = function (n) { return Do(n) === n1 }; an.isFragment = function (n) { return Do(n) === Qy }; an.isLazy = function (n) { return Do(n) === s1 }; an.isMemo = function (n) { return Do(n) === o1 }; an.isPortal = function (n) { return Do(n) === bw }; an.isProfiler = function (n) { return Do(n) === qy }; an.isStrictMode = function (n) { return Do(n) === Zy }; an.isSuspense = function (n) { return Do(n) === r1 }; an.isSuspenseList = function (n) { return Do(n) === i1 }; an.isValidElementType = function (n) { return typeof n == "string" || typeof n == "function" || n === Qy || n === qy || n === Zy || n === r1 || n === i1 || n === IX || typeof n == "object" && n !== null && (n.$$typeof === s1 || n.$$typeof === o1 || n.$$typeof === e1 || n.$$typeof === t1 || n.$$typeof === n1 || n.$$typeof === jF || n.getModuleId !== void 0) }; an.typeOf = Do; WF.exports = an; var XF = WF.exports; function LX() { const n = uX(); let e = null, t = null; return { clear() { e = null, t = null }, notify() { n(() => { let r = e; for (; r;)r.callback(), r = r.next }) }, get() { let r = [], i = e; for (; i;)r.push(i), i = i.next; return r }, subscribe(r) { let i = !0, o = t = { callback: r, next: null, prev: t }; return o.prev ? o.prev.next = o : e = o, function () { !i || e === null || (i = !1, o.next ? o.next.prev = o.prev : t = o.prev, o.prev ? o.prev.next = o.next : e = o.next) } } } } const pP = { notify() { }, get: () => [] }; function DX(n, e) { let t, r = pP, i = 0, o = !1; function s(y) { u(); const _ = r.subscribe(y); let g = !1; return () => { g || (g = !0, _(), d()) } } function a() { r.notify() } function l() { v.onStateChange && v.onStateChange() } function c() { return o } function u() { i++, t || (t = e ? e.addNestedSub(l) : n.subscribe(l), r = LX()) } function d() { i--, t && i === 0 && (t(), t = void 0, r.clear(), r = pP) } function p() { o || (o = !0, u()) } function m() { o && (o = !1, d()) } const v = { addNestedSub: s, notifyNestedSubs: a, handleChangeWrapper: l, isSubscribed: c, trySubscribe: p, tryUnsubscribe: m, getListeners: () => r }; return v } const OX = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", FX = OX ? N.useLayoutEffect : N.useEffect; function UX({ store: n, context: e, children: t, serverState: r, stabilityCheck: i = "once", noopCheck: o = "once" }) { const s = N.useMemo(() => { const c = DX(n); return { store: n, subscription: c, getServerState: r ? () => r : void 0, stabilityCheck: i, noopCheck: o } }, [n, r, i, o]), a = N.useMemo(() => n.getState(), [n]); FX(() => { const { subscription: c } = s; return c.onStateChange = c.notifyNestedSubs, c.trySubscribe(), a !== n.getState() && c.notifyNestedSubs(), () => { c.tryUnsubscribe(), c.onStateChange = void 0 } }, [s, a]); const l = e || Ml; return N.createElement(l.Provider, { value: s }, t) } function JF(n = Ml) { const e = n === Ml ? kF : _w(n); return function () { const { store: r } = e(); return r } } const kX = JF(); function NX(n = Ml) { const e = n === Ml ? kX : JF(n); return function () { return e().dispatch } } const oo = NX(); hX(aX.useSyncExternalStoreWithSelector); cX(iy.unstable_batchedUpdates); function aa(n) { return n !== null && typeof n == "object" && n.constructor === Object } function KF(n) { if (!aa(n)) return n; const e = {}; return Object.keys(n).forEach(t => { e[t] = KF(n[t]) }), e } function Qo(n, e, t = { clone: !0 }) { const r = t.clone ? Ee({}, n) : n; return aa(n) && aa(e) && Object.keys(e).forEach(i => { i !== "__proto__" && (aa(e[i]) && i in n && aa(n[i]) ? r[i] = Qo(n[i], e[i], t) : t.clone ? r[i] = aa(e[i]) ? KF(e[i]) : e[i] : r[i] = e[i]) }), r } function Kf(n) { let e = "https://mui.com/production-error/?code=" + n; for (let t = 1; t < arguments.length; t += 1)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified MUI error #" + n + "; visit " + e + " for the full message." } function It(n) { if (typeof n != "string") throw new Error(Kf(7)); return n.charAt(0).toUpperCase() + n.slice(1) } function zX(...n) { return n.reduce((e, t) => t == null ? e : function (...i) { e.apply(this, i), t.apply(this, i) }, () => { }) } function Dh(n) { return n && n.ownerDocument || document } function eE(n, e) { typeof n == "function" ? n(e) : n && (n.current = e) } const GX = typeof window < "u" ? N.useLayoutEffect : N.useEffect, yp = GX; let mP = 0; function HX(n) { const [e, t] = N.useState(n), r = n || e; return N.useEffect(() => { e == null && (mP += 1, t(`mui-${mP}`)) }, [e]), r } const gP = oS["useId".toString()]; function VX(n) { if (gP !== void 0) { const e = gP(); return n ?? e } return HX(n) } function YF({ controlled: n, default: e, name: t, state: r = "value" }) { const { current: i } = N.useRef(n !== void 0), [o, s] = N.useState(e), a = i ? n : o, l = N.useCallback(c => { i || s(c) }, []); return [a, l] } function rl(n) { const e = N.useRef(n); return yp(() => { e.current = n }), N.useRef((...t) => (0, e.current)(...t)).current } function Sa(...n) { return N.useMemo(() => n.every(e => e == null) ? null : e => { n.forEach(t => { eE(t, e) }) }, n) } let a1 = !0, tE = !1, vP; const WX = { text: !0, search: !0, url: !0, tel: !0, email: !0, password: !0, number: !0, date: !0, month: !0, week: !0, time: !0, datetime: !0, "datetime-local": !0 }; function jX(n) { const { type: e, tagName: t } = n; return !!(t === "INPUT" && WX[e] && !n.readOnly || t === "TEXTAREA" && !n.readOnly || n.isContentEditable) } function XX(n) { n.metaKey || n.altKey || n.ctrlKey || (a1 = !0) } function Hx() { a1 = !1 } function JX() { this.visibilityState === "hidden" && tE && (a1 = !0) } function KX(n) { n.addEventListener("keydown", XX, !0), n.addEventListener("mousedown", Hx, !0), n.addEventListener("pointerdown", Hx, !0), n.addEventListener("touchstart", Hx, !0), n.addEventListener("visibilitychange", JX, !0) } function YX(n) { const { target: e } = n; try { return e.matches(":focus-visible") } catch { } return a1 || jX(e) } function $F() { const n = N.useCallback(i => { i != null && KX(i.ownerDocument) }, []), e = N.useRef(!1); function t() { return e.current ? (tE = !0, window.clearTimeout(vP), vP = window.setTimeout(() => { tE = !1 }, 100), e.current = !1, !0) : !1 } function r(i) { return YX(i) ? (e.current = !0, !0) : !1 } return { isFocusVisibleRef: e, onFocus: r, onBlur: t, ref: n } } function Cw(n, e) { const t = Ee({}, e); return Object.keys(n).forEach(r => { if (r.toString().match(/^(components|slots)$/)) t[r] = Ee({}, n[r], t[r]); else if (r.toString().match(/^(componentsProps|slotProps)$/)) { const i = n[r] || {}, o = e[r]; t[r] = {}, !o || !Object.keys(o) ? t[r] = i : !i || !Object.keys(i) ? t[r] = o : (t[r] = Ee({}, o), Object.keys(i).forEach(s => { t[r][s] = Cw(i[s], o[s]) })) } else t[r] === void 0 && (t[r] = n[r]) }), t } function ti(n, e, t = void 0) { const r = {}; return Object.keys(n).forEach(i => { r[i] = n[i].reduce((o, s) => { if (s) { const a = e(s); a !== "" && o.push(a), t && t[s] && o.push(t[s]) } return o }, []).join(" ") }), r } const yP = n => n, $X = () => { let n = yP; return { configure(e) { n = e }, generate(e) { return n(e) }, reset() { n = yP } } }, QX = $X(), ZX = QX, qX = { active: "active", checked: "checked", completed: "completed", disabled: "disabled", error: "error", expanded: "expanded", focused: "focused", focusVisible: "focusVisible", open: "open", readOnly: "readOnly", required: "required", selected: "selected" }; function Ir(n, e, t = "Mui") { const r = qX[e]; return r ? `${t}-${r}` : `${ZX.generate(n)}-${e}` } function Lr(n, e, t = "Mui") { const r = {}; return e.forEach(i => { r[i] = Ir(n, i, t) }), r } function QF(n) { var e, t, r = ""; if (typeof n == "string" || typeof n == "number") r += n; else if (typeof n == "object") if (Array.isArray(n)) for (e = 0; e < n.length; e++)n[e] && (t = QF(n[e])) && (r && (r += " "), r += t); else for (e in n) n[e] && (r && (r += " "), r += e); return r } function rn() { for (var n, e, t = 0, r = ""; t < arguments.length;)(n = arguments[t++]) && (e = QF(n)) && (r && (r += " "), r += e); return r } function ZF(n) { var e = Object.create(null); return function (t) { return e[t] === void 0 && (e[t] = n(t)), e[t] } } var eJ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, nE = ZF(function (n) { return eJ.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91 }); function tJ(n) { if (n.sheet) return n.sheet; for (var e = 0; e < document.styleSheets.length; e++)if (document.styleSheets[e].ownerNode === n) return document.styleSheets[e] } function nJ(n) { var e = document.createElement("style"); return e.setAttribute("data-emotion", n.key), n.nonce !== void 0 && e.setAttribute("nonce", n.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e } var rJ = function () { function n(t) { var r = this; this._insertTag = function (i) { var o; r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i) }, this.isSpeedy = t.speedy === void 0 ? !0 : t.speedy, this.tags = [], this.ctr = 0, this.nonce = t.nonce, this.key = t.key, this.container = t.container, this.prepend = t.prepend, this.insertionPoint = t.insertionPoint, this.before = null } var e = n.prototype; return e.hydrate = function (r) { r.forEach(this._insertTag) }, e.insert = function (r) { this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(nJ(this)); var i = this.tags[this.tags.length - 1]; if (this.isSpeedy) { var o = tJ(i); try { o.insertRule(r, o.cssRules.length) } catch { } } else i.appendChild(document.createTextNode(r)); this.ctr++ }, e.flush = function () { this.tags.forEach(function (r) { return r.parentNode && r.parentNode.removeChild(r) }), this.tags = [], this.ctr = 0 }, n }(), jr = "-ms-", Cv = "-moz-", $t = "-webkit-", qF = "comm", Tw = "rule", Rw = "decl", iJ = "@import", eU = "@keyframes", oJ = "@layer", sJ = Math.abs, l1 = String.fromCharCode, aJ = Object.assign; function lJ(n, e) { return Tr(n, 0) ^ 45 ? (((e << 2 ^ Tr(n, 0)) << 2 ^ Tr(n, 1)) << 2 ^ Tr(n, 2)) << 2 ^ Tr(n, 3) : 0 } function tU(n) { return n.trim() } function cJ(n, e) { return (n = e.exec(n)) ? n[0] : n } function Qt(n, e, t) { return n.replace(e, t) } function rE(n, e) { return n.indexOf(e) } function Tr(n, e) { return n.charCodeAt(e) | 0 } function _p(n, e, t) { return n.slice(e, t) } function gs(n) { return n.length } function Pw(n) { return n.length } function d0(n, e) { return e.push(n), n } function uJ(n, e) { return n.map(e).join("") } var c1 = 1, Yf = 1, nU = 0, Ui = 0, tr = 0, ud = ""; function u1(n, e, t, r, i, o, s) { return { value: n, root: e, parent: t, type: r, props: i, children: o, line: c1, column: Yf, length: s, return: "" } } function oh(n, e) { return aJ(u1("", null, null, "", null, null, 0), n, { length: -n.length }, e) } function fJ() { return tr } function dJ() { return tr = Ui > 0 ? Tr(ud, --Ui) : 0, Yf--, tr === 10 && (Yf = 1, c1--), tr } function no() { return tr = Ui < nU ? Tr(ud, Ui++) : 0, Yf++, tr === 10 && (Yf = 1, c1++), tr } function Bs() { return Tr(ud, Ui) } function G0() { return Ui } function Qp(n, e) { return _p(ud, n, e) } function xp(n) { switch (n) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function rU(n) { return c1 = Yf = 1, nU = gs(ud = n), Ui = 0, [] } function iU(n) { return ud = "", n } function H0(n) { return tU(Qp(Ui - 1, iE(n === 91 ? n + 2 : n === 40 ? n + 1 : n))) } function hJ(n) { for (; (tr = Bs()) && tr < 33;)no(); return xp(n) > 2 || xp(tr) > 3 ? "" : " " } function pJ(n, e) { for (; --e && no() && !(tr < 48 || tr > 102 || tr > 57 && tr < 65 || tr > 70 && tr < 97);); return Qp(n, G0() + (e < 6 && Bs() == 32 && no() == 32)) } function iE(n) { for (; no();)switch (tr) { case n: return Ui; case 34: case 39: n !== 34 && n !== 39 && iE(tr); break; case 40: n === 41 && iE(n); break; case 92: no(); break }return Ui } function mJ(n, e) { for (; no() && n + tr !== 47 + 10;)if (n + tr === 42 + 42 && Bs() === 47) break; return "/*" + Qp(e, Ui - 1) + "*" + l1(n === 47 ? n : no()) } function gJ(n) { for (; !xp(Bs());)no(); return Qp(n, Ui) } function vJ(n) { return iU(V0("", null, null, null, [""], n = rU(n), 0, [0], n)) } function V0(n, e, t, r, i, o, s, a, l) { for (var c = 0, u = 0, d = s, p = 0, m = 0, v = 0, y = 1, _ = 1, g = 1, x = 0, A = "", E = i, w = o, b = r, T = A; _;)switch (v = x, x = no()) { case 40: if (v != 108 && Tr(T, d - 1) == 58) { rE(T += Qt(H0(x), "&", "&\f"), "&\f") != -1 && (g = -1); break } case 34: case 39: case 91: T += H0(x); break; case 9: case 10: case 13: case 32: T += hJ(v); break; case 92: T += pJ(G0() - 1, 7); continue; case 47: switch (Bs()) { case 42: case 47: d0(yJ(mJ(no(), G0()), e, t), l); break; default: T += "/" }break; case 123 * y: a[c++] = gs(T) * g; case 125 * y: case 59: case 0: switch (x) { case 0: case 125: _ = 0; case 59 + u: g == -1 && (T = Qt(T, /\f/g, "")), m > 0 && gs(T) - d && d0(m > 32 ? xP(T + ";", r, t, d - 1) : xP(Qt(T, " ", "") + ";", r, t, d - 2), l); break; case 59: T += ";"; default: if (d0(b = _P(T, e, t, c, u, i, a, A, E = [], w = [], d), o), x === 123) if (u === 0) V0(T, e, b, b, E, o, d, a, w); else switch (p === 99 && Tr(T, 3) === 110 ? 100 : p) { case 100: case 108: case 109: case 115: V0(n, b, b, r && d0(_P(n, b, b, 0, 0, i, a, A, i, E = [], d), w), i, w, d, a, r ? E : w); break; default: V0(T, b, b, b, [""], w, 0, a, w) } }c = u = m = 0, y = g = 1, A = T = "", d = s; break; case 58: d = 1 + gs(T), m = v; default: if (y < 1) { if (x == 123) --y; else if (x == 125 && y++ == 0 && dJ() == 125) continue } switch (T += l1(x), x * y) { case 38: g = u > 0 ? 1 : (T += "\f", -1); break; case 44: a[c++] = (gs(T) - 1) * g, g = 1; break; case 64: Bs() === 45 && (T += H0(no())), p = Bs(), u = d = gs(A = T += gJ(G0())), x++; break; case 45: v === 45 && gs(T) == 2 && (y = 0) } }return o } function _P(n, e, t, r, i, o, s, a, l, c, u) { for (var d = i - 1, p = i === 0 ? o : [""], m = Pw(p), v = 0, y = 0, _ = 0; v < r; ++v)for (var g = 0, x = _p(n, d + 1, d = sJ(y = s[v])), A = n; g < m; ++g)(A = tU(y > 0 ? p[g] + " " + x : Qt(x, /&\f/g, p[g]))) && (l[_++] = A); return u1(n, e, t, i === 0 ? Tw : a, l, c, u) } function yJ(n, e, t) { return u1(n, e, t, qF, l1(fJ()), _p(n, 2, -2), 0) } function xP(n, e, t, r) { return u1(n, e, t, Rw, _p(n, 0, r), _p(n, r + 1, -1), r) } function Tf(n, e) { for (var t = "", r = Pw(n), i = 0; i < r; i++)t += e(n[i], i, n, e) || ""; return t } function _J(n, e, t, r) { switch (n.type) { case oJ: if (n.children.length) break; case iJ: case Rw: return n.return = n.return || n.value; case qF: return ""; case eU: return n.return = n.value + "{" + Tf(n.children, r) + "}"; case Tw: n.value = n.props.join(",") }return gs(t = Tf(n.children, r)) ? n.return = n.value + "{" + t + "}" : "" } function xJ(n) { var e = Pw(n); return function (t, r, i, o) { for (var s = "", a = 0; a < e; a++)s += n[a](t, r, i, o) || ""; return s } } function SJ(n) { return function (e) { e.root || (e = e.return) && n(e) } } var AJ = function (e, t, r) { for (var i = 0, o = 0; i = o, o = Bs(), i === 38 && o === 12 && (t[r] = 1), !xp(o);)no(); return Qp(e, Ui) }, EJ = function (e, t) { var r = -1, i = 44; do switch (xp(i)) { case 0: i === 38 && Bs() === 12 && (t[r] = 1), e[r] += AJ(Ui - 1, t, r); break; case 2: e[r] += H0(i); break; case 4: if (i === 44) { e[++r] = Bs() === 58 ? "&\f" : "", t[r] = e[r].length; break } default: e[r] += l1(i) } while (i = no()); return e }, MJ = function (e, t) { return iU(EJ(rU(e), t)) }, SP = new WeakMap, wJ = function (e) { if (!(e.type !== "rule" || !e.parent || e.length < 1)) { for (var t = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule";)if (r = r.parent, !r) return; if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !SP.get(r)) && !i) { SP.set(e, !0); for (var o = [], s = MJ(t, o), a = r.props, l = 0, c = 0; l < s.length; l++)for (var u = 0; u < a.length; u++, c++)e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l] } } }, bJ = function (e) { if (e.type === "decl") { var t = e.value; t.charCodeAt(0) === 108 && t.charCodeAt(2) === 98 && (e.return = "", e.value = "") } }; function oU(n, e) { switch (lJ(n, e)) { case 5103: return $t + "print-" + n + n; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return $t + n + n; case 5349: case 4246: case 4810: case 6968: case 2756: return $t + n + Cv + n + jr + n + n; case 6828: case 4268: return $t + n + jr + n + n; case 6165: return $t + n + jr + "flex-" + n + n; case 5187: return $t + n + Qt(n, /(\w+).+(:[^]+)/, $t + "box-$1$2" + jr + "flex-$1$2") + n; case 5443: return $t + n + jr + "flex-item-" + Qt(n, /flex-|-self/, "") + n; case 4675: return $t + n + jr + "flex-line-pack" + Qt(n, /align-content|flex-|-self/, "") + n; case 5548: return $t + n + jr + Qt(n, "shrink", "negative") + n; case 5292: return $t + n + jr + Qt(n, "basis", "preferred-size") + n; case 6060: return $t + "box-" + Qt(n, "-grow", "") + $t + n + jr + Qt(n, "grow", "positive") + n; case 4554: return $t + Qt(n, /([^-])(transform)/g, "$1" + $t + "$2") + n; case 6187: return Qt(Qt(Qt(n, /(zoom-|grab)/, $t + "$1"), /(image-set)/, $t + "$1"), n, "") + n; case 5495: case 3959: return Qt(n, /(image-set\([^]*)/, $t + "$1$`$1"); case 4968: return Qt(Qt(n, /(.+:)(flex-)?(.*)/, $t + "box-pack:$3" + jr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + $t + n + n; case 4095: case 3583: case 4068: case 2532: return Qt(n, /(.+)-inline(.+)/, $t + "$1$2") + n; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (gs(n) - 1 - e > 6) switch (Tr(n, e + 1)) { case 109: if (Tr(n, e + 4) !== 45) break; case 102: return Qt(n, /(.+:)(.+)-([^]+)/, "$1" + $t + "$2-$3$1" + Cv + (Tr(n, e + 3) == 108 ? "$3" : "$2-$3")) + n; case 115: return ~rE(n, "stretch") ? oU(Qt(n, "stretch", "fill-available"), e) + n : n }break; case 4949: if (Tr(n, e + 1) !== 115) break; case 6444: switch (Tr(n, gs(n) - 3 - (~rE(n, "!important") && 10))) { case 107: return Qt(n, ":", ":" + $t) + n; case 101: return Qt(n, /(.+:)([^;!]+)(;|!.+)?/, "$1" + $t + (Tr(n, 14) === 45 ? "inline-" : "") + "box$3$1" + $t + "$2$3$1" + jr + "$2box$3") + n }break; case 5936: switch (Tr(n, e + 11)) { case 114: return $t + n + jr + Qt(n, /[svh]\w+-[tblr]{2}/, "tb") + n; case 108: return $t + n + jr + Qt(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n; case 45: return $t + n + jr + Qt(n, /[svh]\w+-[tblr]{2}/, "lr") + n }return $t + n + jr + n + n }return n } var CJ = function (e, t, r, i) { if (e.length > -1 && !e.return) switch (e.type) { case Rw: e.return = oU(e.value, e.length); break; case eU: return Tf([oh(e, { value: Qt(e.value, "@", "@" + $t) })], i); case Tw: if (e.length) return uJ(e.props, function (o) { switch (cJ(o, /(::plac\w+|:read-\w+)/)) { case ":read-only": case ":read-write": return Tf([oh(e, { props: [Qt(o, /:(read-\w+)/, ":" + Cv + "$1")] })], i); case "::placeholder": return Tf([oh(e, { props: [Qt(o, /:(plac\w+)/, ":" + $t + "input-$1")] }), oh(e, { props: [Qt(o, /:(plac\w+)/, ":" + Cv + "$1")] }), oh(e, { props: [Qt(o, /:(plac\w+)/, jr + "input-$1")] })], i) }return "" }) } }, TJ = [CJ], RJ = function (e) { var t = e.key; if (t === "css") { var r = document.querySelectorAll("style[data-emotion]:not([data-s])"); Array.prototype.forEach.call(r, function (y) { var _ = y.getAttribute("data-emotion"); _.indexOf(" ") !== -1 && (document.head.appendChild(y), y.setAttribute("data-s", "")) }) } var i = e.stylisPlugins || TJ, o = {}, s, a = []; s = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + t + ' "]'), function (y) { for (var _ = y.getAttribute("data-emotion").split(" "), g = 1; g < _.length; g++)o[_[g]] = !0; a.push(y) }); var l, c = [wJ, bJ]; { var u, d = [_J, SJ(function (y) { u.insert(y) })], p = xJ(c.concat(i, d)), m = function (_) { return Tf(vJ(_), p) }; l = function (_, g, x, A) { u = x, m(_ ? _ + "{" + g.styles + "}" : g.styles), A && (v.inserted[g.name] = !0) } } var v = { key: t, sheet: new rJ({ key: t, container: s, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint }), nonce: e.nonce, inserted: o, registered: {}, insert: l }; return v.sheet.hydrate(a), v }, PJ = !0; function BJ(n, e, t) { var r = ""; return t.split(" ").forEach(function (i) { n[i] !== void 0 ? e.push(n[i] + ";") : r += i + " " }), r } var sU = function (e, t, r) { var i = e.key + "-" + t.name; (r === !1 || PJ === !1) && e.registered[i] === void 0 && (e.registered[i] = t.styles) }, IJ = function (e, t, r) { sU(e, t, r); var i = e.key + "-" + t.name; if (e.inserted[t.name] === void 0) { var o = t; do e.insert(t === o ? "." + i : "", o, e.sheet, !0), o = o.next; while (o !== void 0) } }; function LJ(n) { for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)t = n.charCodeAt(r) & 255 | (n.charCodeAt(++r) & 255) << 8 | (n.charCodeAt(++r) & 255) << 16 | (n.charCodeAt(++r) & 255) << 24, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), t ^= t >>> 24, e = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16); switch (i) { case 3: e ^= (n.charCodeAt(r + 2) & 255) << 16; case 2: e ^= (n.charCodeAt(r + 1) & 255) << 8; case 1: e ^= n.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16) }return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36) } var DJ = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, OJ = /[A-Z]|^ms/g, FJ = /_EMO_([^_]+?)_([^]*?)_EMO_/g, aU = function (e) { return e.charCodeAt(1) === 45 }, AP = function (e) { return e != null && typeof e != "boolean" }, Vx = ZF(function (n) { return aU(n) ? n : n.replace(OJ, "-$&").toLowerCase() }), EP = function (e, t) { switch (e) { case "animation": case "animationName": if (typeof t == "string") return t.replace(FJ, function (r, i, o) { return vs = { name: i, styles: o, next: vs }, i }) }return DJ[e] !== 1 && !aU(e) && typeof t == "number" && t !== 0 ? t + "px" : t }; function Sp(n, e, t) { if (t == null) return ""; if (t.__emotion_styles !== void 0) return t; switch (typeof t) { case "boolean": return ""; case "object": { if (t.anim === 1) return vs = { name: t.name, styles: t.styles, next: vs }, t.name; if (t.styles !== void 0) { var r = t.next; if (r !== void 0) for (; r !== void 0;)vs = { name: r.name, styles: r.styles, next: vs }, r = r.next; var i = t.styles + ";"; return i } return UJ(n, e, t) } case "function": { if (n !== void 0) { var o = vs, s = t(n); return vs = o, Sp(n, e, s) } break } }if (e == null) return t; var a = e[t]; return a !== void 0 ? a : t } function UJ(n, e, t) { var r = ""; if (Array.isArray(t)) for (var i = 0; i < t.length; i++)r += Sp(n, e, t[i]) + ";"; else for (var o in t) { var s = t[o]; if (typeof s != "object") e != null && e[s] !== void 0 ? r += o + "{" + e[s] + "}" : AP(s) && (r += Vx(o) + ":" + EP(o, s) + ";"); else if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0)) for (var a = 0; a < s.length; a++)AP(s[a]) && (r += Vx(o) + ":" + EP(o, s[a]) + ";"); else { var l = Sp(n, e, s); switch (o) { case "animation": case "animationName": { r += Vx(o) + ":" + l + ";"; break } default: r += o + "{" + l + "}" } } } return r } var MP = /label:\s*([^\s;\n{]+)\s*(;|$)/g, vs, lU = function (e, t, r) { if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0) return e[0]; var i = !0, o = ""; vs = void 0; var s = e[0]; s == null || s.raw === void 0 ? (i = !1, o += Sp(r, t, s)) : o += s[0]; for (var a = 1; a < e.length; a++)o += Sp(r, t, e[a]), i && (o += s[a]); MP.lastIndex = 0; for (var l = "", c; (c = MP.exec(o)) !== null;)l += "-" + c[1]; var u = LJ(o) + l; return { name: u, styles: o, next: vs } }, kJ = function (e) { return e() }, NJ = oS["useInsertionEffect"] ? oS["useInsertionEffect"] : !1, zJ = NJ || kJ, cU = N.createContext(typeof HTMLElement < "u" ? RJ({ key: "css" }) : null); cU.Provider; var GJ = function (e) { return N.forwardRef(function (t, r) { var i = N.useContext(cU); return e(t, i, r) }) }, uU = N.createContext({}); function HJ() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return lU(e) } var Bw = function () { var e = HJ.apply(void 0, arguments), t = "animation-" + e.name; return { name: t, styles: "@keyframes " + t + "{" + e.styles + "}", anim: 1, toString: function () { return "_EMO_" + this.name + "_" + this.styles + "_EMO_" } } }, VJ = nE, WJ = function (e) { return e !== "theme" }, wP = function (e) { return typeof e == "string" && e.charCodeAt(0) > 96 ? VJ : WJ }, bP = function (e, t, r) { var i; if (t) { var o = t.shouldForwardProp; i = e.__emotion_forwardProp && o ? function (s) { return e.__emotion_forwardProp(s) && o(s) } : o } return typeof i != "function" && r && (i = e.__emotion_forwardProp), i }, jJ = function (e) { var t = e.cache, r = e.serialized, i = e.isStringTag; return sU(t, r, i), zJ(function () { return IJ(t, r, i) }), null }, XJ = function n(e, t) { var r = e.__emotion_real === e, i = r && e.__emotion_base || e, o, s; t !== void 0 && (o = t.label, s = t.target); var a = bP(e, t, r), l = a || wP(i), c = !l("as"); return function () { var u = arguments, d = r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : []; if (o !== void 0 && d.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0) d.push.apply(d, u); else { d.push(u[0][0]); for (var p = u.length, m = 1; m < p; m++)d.push(u[m], u[0][m]) } var v = GJ(function (y, _, g) { var x = c && y.as || i, A = "", E = [], w = y; if (y.theme == null) { w = {}; for (var b in y) w[b] = y[b]; w.theme = N.useContext(uU) } typeof y.className == "string" ? A = BJ(_.registered, E, y.className) : y.className != null && (A = y.className + " "); var T = lU(d.concat(E), _.registered, w); A += _.key + "-" + T.name, s !== void 0 && (A += " " + s); var B = c && a === void 0 ? wP(x) : l, R = {}; for (var P in y) c && P === "as" || B(P) && (R[P] = y[P]); return R.className = A, R.ref = g, N.createElement(N.Fragment, null, N.createElement(jJ, { cache: _, serialized: T, isStringTag: typeof x == "string" }), N.createElement(x, R)) }); return v.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", v.defaultProps = e.defaultProps, v.__emotion_real = v, v.__emotion_base = i, v.__emotion_styles = d, v.__emotion_forwardProp = a, Object.defineProperty(v, "toString", { value: function () { return "." + s } }), v.withComponent = function (y, _) { return n(y, Ee({}, t, _, { shouldForwardProp: bP(v, _, !0) })).apply(void 0, d) }, v } }, JJ = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], oE = XJ.bind(); JJ.forEach(function (n) { oE[n] = oE(n) }); var fU = { exports: {} }, f1 = {};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var KJ = N, YJ = Symbol.for("react.element"), $J = Symbol.for("react.fragment"), QJ = Object.prototype.hasOwnProperty, ZJ = KJ.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, qJ = { key: !0, ref: !0, __self: !0, __source: !0 }; function dU(n, e, t) { var r, i = {}, o = null, s = null; t !== void 0 && (o = "" + t), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref); for (r in e) QJ.call(e, r) && !qJ.hasOwnProperty(r) && (i[r] = e[r]); if (n && n.defaultProps) for (r in e = n.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: YJ, type: n, key: o, ref: s, props: i, _owner: ZJ.current } } f1.Fragment = $J; f1.jsx = dU; f1.jsxs = dU; fU.exports = f1; var st = fU.exports;/**
 * @mui/styled-engine v5.14.16
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function eK(n, e) { return oE(n, e) } const tK = (n, e) => { Array.isArray(n.__emotion_styles) && (n.__emotion_styles = e(n.__emotion_styles)) }, nK = ["values", "unit", "step"], rK = n => { const e = Object.keys(n).map(t => ({ key: t, val: n[t] })) || []; return e.sort((t, r) => t.val - r.val), e.reduce((t, r) => Ee({}, t, { [r.key]: r.val }), {}) }; function iK(n) { const { values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, unit: t = "px", step: r = 5 } = n, i = Wt(n, nK), o = rK(e), s = Object.keys(o); function a(p) { return `@media (min-width:${typeof e[p] == "number" ? e[p] : p}${t})` } function l(p) { return `@media (max-width:${(typeof e[p] == "number" ? e[p] : p) - r / 100}${t})` } function c(p, m) { const v = s.indexOf(m); return `@media (min-width:${typeof e[p] == "number" ? e[p] : p}${t}) and (max-width:${(v !== -1 && typeof e[s[v]] == "number" ? e[s[v]] : m) - r / 100}${t})` } function u(p) { return s.indexOf(p) + 1 < s.length ? c(p, s[s.indexOf(p) + 1]) : a(p) } function d(p) { const m = s.indexOf(p); return m === 0 ? a(s[1]) : m === s.length - 1 ? l(s[m]) : c(p, s[s.indexOf(p) + 1]).replace("@media", "@media not all and") } return Ee({ keys: s, values: o, up: a, down: l, between: c, only: u, not: d, unit: t }, i) } const oK = { borderRadius: 4 }, sK = oK; function Oh(n, e) { return e ? Qo(n, e, { clone: !1 }) : n } const Iw = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, CP = { keys: ["xs", "sm", "md", "lg", "xl"], up: n => `@media (min-width:${Iw[n]}px)` }; function Aa(n, e, t) { const r = n.theme || {}; if (Array.isArray(e)) { const o = r.breakpoints || CP; return e.reduce((s, a, l) => (s[o.up(o.keys[l])] = t(e[l]), s), {}) } if (typeof e == "object") { const o = r.breakpoints || CP; return Object.keys(e).reduce((s, a) => { if (Object.keys(o.values || Iw).indexOf(a) !== -1) { const l = o.up(a); s[l] = t(e[a], a) } else { const l = a; s[l] = e[l] } return s }, {}) } return t(e) } function aK(n = {}) { var e; return ((e = n.keys) == null ? void 0 : e.reduce((r, i) => { const o = n.up(i); return r[o] = {}, r }, {})) || {} } function lK(n, e) { return n.reduce((t, r) => { const i = t[r]; return (!i || Object.keys(i).length === 0) && delete t[r], t }, e) } function d1(n, e, t = !0) { if (!e || typeof e != "string") return null; if (n && n.vars && t) { const r = `vars.${e}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, n); if (r != null) return r } return e.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, n) } function Tv(n, e, t, r = t) { let i; return typeof n == "function" ? i = n(t) : Array.isArray(n) ? i = n[t] || r : i = d1(n, t) || r, e && (i = e(i, r, n)), i } function en(n) { const { prop: e, cssProperty: t = n.prop, themeKey: r, transform: i } = n, o = s => { if (s[e] == null) return null; const a = s[e], l = s.theme, c = d1(l, r) || {}; return Aa(s, a, d => { let p = Tv(c, i, d); return d === p && typeof d == "string" && (p = Tv(c, i, `${e}${d === "default" ? "" : It(d)}`, d)), t === !1 ? p : { [t]: p } }) }; return o.propTypes = {}, o.filterProps = [e], o } function cK(n) { const e = {}; return t => (e[t] === void 0 && (e[t] = n(t)), e[t]) } const uK = { m: "margin", p: "padding" }, fK = { t: "Top", r: "Right", b: "Bottom", l: "Left", x: ["Left", "Right"], y: ["Top", "Bottom"] }, TP = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" }, dK = cK(n => { if (n.length > 2) if (TP[n]) n = TP[n]; else return [n]; const [e, t] = n.split(""), r = uK[e], i = fK[t] || ""; return Array.isArray(i) ? i.map(o => r + o) : [r + i] }), Lw = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Dw = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];[...Lw, ...Dw]; function Zp(n, e, t, r) { var i; const o = (i = d1(n, e, !1)) != null ? i : t; return typeof o == "number" ? s => typeof s == "string" ? s : o * s : Array.isArray(o) ? s => typeof s == "string" ? s : o[s] : typeof o == "function" ? o : () => { } } function hU(n) { return Zp(n, "spacing", 8) } function qp(n, e) { if (typeof e == "string" || e == null) return e; const t = Math.abs(e), r = n(t); return e >= 0 ? r : typeof r == "number" ? -r : `-${r}` } function hK(n, e) { return t => n.reduce((r, i) => (r[i] = qp(e, t), r), {}) } function pK(n, e, t, r) { if (e.indexOf(t) === -1) return null; const i = dK(t), o = hK(i, r), s = n[t]; return Aa(n, s, o) } function pU(n, e) { const t = hU(n.theme); return Object.keys(n).map(r => pK(n, e, r, t)).reduce(Oh, {}) } function kn(n) { return pU(n, Lw) } kn.propTypes = {}; kn.filterProps = Lw; function Nn(n) { return pU(n, Dw) } Nn.propTypes = {}; Nn.filterProps = Dw; function mK(n = 8) { if (n.mui) return n; const e = hU({ spacing: n }), t = (...r) => (r.length === 0 ? [1] : r).map(o => { const s = e(o); return typeof s == "number" ? `${s}px` : s }).join(" "); return t.mui = !0, t } function h1(...n) { const e = n.reduce((r, i) => (i.filterProps.forEach(o => { r[o] = i }), r), {}), t = r => Object.keys(r).reduce((i, o) => e[o] ? Oh(i, e[o](r)) : i, {}); return t.propTypes = {}, t.filterProps = n.reduce((r, i) => r.concat(i.filterProps), []), t } function Ss(n) { return typeof n != "number" ? n : `${n}px solid` } const gK = en({ prop: "border", themeKey: "borders", transform: Ss }), vK = en({ prop: "borderTop", themeKey: "borders", transform: Ss }), yK = en({ prop: "borderRight", themeKey: "borders", transform: Ss }), _K = en({ prop: "borderBottom", themeKey: "borders", transform: Ss }), xK = en({ prop: "borderLeft", themeKey: "borders", transform: Ss }), SK = en({ prop: "borderColor", themeKey: "palette" }), AK = en({ prop: "borderTopColor", themeKey: "palette" }), EK = en({ prop: "borderRightColor", themeKey: "palette" }), MK = en({ prop: "borderBottomColor", themeKey: "palette" }), wK = en({ prop: "borderLeftColor", themeKey: "palette" }), p1 = n => { if (n.borderRadius !== void 0 && n.borderRadius !== null) { const e = Zp(n.theme, "shape.borderRadius", 4), t = r => ({ borderRadius: qp(e, r) }); return Aa(n, n.borderRadius, t) } return null }; p1.propTypes = {}; p1.filterProps = ["borderRadius"]; h1(gK, vK, yK, _K, xK, SK, AK, EK, MK, wK, p1); const m1 = n => { if (n.gap !== void 0 && n.gap !== null) { const e = Zp(n.theme, "spacing", 8), t = r => ({ gap: qp(e, r) }); return Aa(n, n.gap, t) } return null }; m1.propTypes = {}; m1.filterProps = ["gap"]; const g1 = n => { if (n.columnGap !== void 0 && n.columnGap !== null) { const e = Zp(n.theme, "spacing", 8), t = r => ({ columnGap: qp(e, r) }); return Aa(n, n.columnGap, t) } return null }; g1.propTypes = {}; g1.filterProps = ["columnGap"]; const v1 = n => { if (n.rowGap !== void 0 && n.rowGap !== null) { const e = Zp(n.theme, "spacing", 8), t = r => ({ rowGap: qp(e, r) }); return Aa(n, n.rowGap, t) } return null }; v1.propTypes = {}; v1.filterProps = ["rowGap"]; const bK = en({ prop: "gridColumn" }), CK = en({ prop: "gridRow" }), TK = en({ prop: "gridAutoFlow" }), RK = en({ prop: "gridAutoColumns" }), PK = en({ prop: "gridAutoRows" }), BK = en({ prop: "gridTemplateColumns" }), IK = en({ prop: "gridTemplateRows" }), LK = en({ prop: "gridTemplateAreas" }), DK = en({ prop: "gridArea" }); h1(m1, g1, v1, bK, CK, TK, RK, PK, BK, IK, LK, DK); function Rf(n, e) { return e === "grey" ? e : n } const OK = en({ prop: "color", themeKey: "palette", transform: Rf }), FK = en({ prop: "bgcolor", cssProperty: "backgroundColor", themeKey: "palette", transform: Rf }), UK = en({ prop: "backgroundColor", themeKey: "palette", transform: Rf }); h1(OK, FK, UK); function Qi(n) { return n <= 1 && n !== 0 ? `${n * 100}%` : n } const kK = en({ prop: "width", transform: Qi }), Ow = n => { if (n.maxWidth !== void 0 && n.maxWidth !== null) { const e = t => { var r, i; const o = ((r = n.theme) == null || (r = r.breakpoints) == null || (r = r.values) == null ? void 0 : r[t]) || Iw[t]; return o ? ((i = n.theme) == null || (i = i.breakpoints) == null ? void 0 : i.unit) !== "px" ? { maxWidth: `${o}${n.theme.breakpoints.unit}` } : { maxWidth: o } : { maxWidth: Qi(t) } }; return Aa(n, n.maxWidth, e) } return null }; Ow.filterProps = ["maxWidth"]; const NK = en({ prop: "minWidth", transform: Qi }), zK = en({ prop: "height", transform: Qi }), GK = en({ prop: "maxHeight", transform: Qi }), HK = en({ prop: "minHeight", transform: Qi }); en({ prop: "size", cssProperty: "width", transform: Qi }); en({ prop: "size", cssProperty: "height", transform: Qi }); const VK = en({ prop: "boxSizing" }); h1(kK, Ow, NK, zK, GK, HK, VK); const WK = { border: { themeKey: "borders", transform: Ss }, borderTop: { themeKey: "borders", transform: Ss }, borderRight: { themeKey: "borders", transform: Ss }, borderBottom: { themeKey: "borders", transform: Ss }, borderLeft: { themeKey: "borders", transform: Ss }, borderColor: { themeKey: "palette" }, borderTopColor: { themeKey: "palette" }, borderRightColor: { themeKey: "palette" }, borderBottomColor: { themeKey: "palette" }, borderLeftColor: { themeKey: "palette" }, borderRadius: { themeKey: "shape.borderRadius", style: p1 }, color: { themeKey: "palette", transform: Rf }, bgcolor: { themeKey: "palette", cssProperty: "backgroundColor", transform: Rf }, backgroundColor: { themeKey: "palette", transform: Rf }, p: { style: Nn }, pt: { style: Nn }, pr: { style: Nn }, pb: { style: Nn }, pl: { style: Nn }, px: { style: Nn }, py: { style: Nn }, padding: { style: Nn }, paddingTop: { style: Nn }, paddingRight: { style: Nn }, paddingBottom: { style: Nn }, paddingLeft: { style: Nn }, paddingX: { style: Nn }, paddingY: { style: Nn }, paddingInline: { style: Nn }, paddingInlineStart: { style: Nn }, paddingInlineEnd: { style: Nn }, paddingBlock: { style: Nn }, paddingBlockStart: { style: Nn }, paddingBlockEnd: { style: Nn }, m: { style: kn }, mt: { style: kn }, mr: { style: kn }, mb: { style: kn }, ml: { style: kn }, mx: { style: kn }, my: { style: kn }, margin: { style: kn }, marginTop: { style: kn }, marginRight: { style: kn }, marginBottom: { style: kn }, marginLeft: { style: kn }, marginX: { style: kn }, marginY: { style: kn }, marginInline: { style: kn }, marginInlineStart: { style: kn }, marginInlineEnd: { style: kn }, marginBlock: { style: kn }, marginBlockStart: { style: kn }, marginBlockEnd: { style: kn }, displayPrint: { cssProperty: !1, transform: n => ({ "@media print": { display: n } }) }, display: {}, overflow: {}, textOverflow: {}, visibility: {}, whiteSpace: {}, flexBasis: {}, flexDirection: {}, flexWrap: {}, justifyContent: {}, alignItems: {}, alignContent: {}, order: {}, flex: {}, flexGrow: {}, flexShrink: {}, alignSelf: {}, justifyItems: {}, justifySelf: {}, gap: { style: m1 }, rowGap: { style: v1 }, columnGap: { style: g1 }, gridColumn: {}, gridRow: {}, gridAutoFlow: {}, gridAutoColumns: {}, gridAutoRows: {}, gridTemplateColumns: {}, gridTemplateRows: {}, gridTemplateAreas: {}, gridArea: {}, position: {}, zIndex: { themeKey: "zIndex" }, top: {}, right: {}, bottom: {}, left: {}, boxShadow: { themeKey: "shadows" }, width: { transform: Qi }, maxWidth: { style: Ow }, minWidth: { transform: Qi }, height: { transform: Qi }, maxHeight: { transform: Qi }, minHeight: { transform: Qi }, boxSizing: {}, fontFamily: { themeKey: "typography" }, fontSize: { themeKey: "typography" }, fontStyle: { themeKey: "typography" }, fontWeight: { themeKey: "typography" }, letterSpacing: {}, textTransform: {}, lineHeight: {}, textAlign: {}, typography: { cssProperty: !1, themeKey: "typography" } }, y1 = WK; function jK(...n) { const e = n.reduce((r, i) => r.concat(Object.keys(i)), []), t = new Set(e); return n.every(r => t.size === Object.keys(r).length) } function XK(n, e) { return typeof n == "function" ? n(e) : n } function JK() { function n(t, r, i, o) { const s = { [t]: r, theme: i }, a = o[t]; if (!a) return { [t]: r }; const { cssProperty: l = t, themeKey: c, transform: u, style: d } = a; if (r == null) return null; if (c === "typography" && r === "inherit") return { [t]: r }; const p = d1(i, c) || {}; return d ? d(s) : Aa(s, r, v => { let y = Tv(p, u, v); return v === y && typeof v == "string" && (y = Tv(p, u, `${t}${v === "default" ? "" : It(v)}`, v)), l === !1 ? y : { [l]: y } }) } function e(t) { var r; const { sx: i, theme: o = {} } = t || {}; if (!i) return null; const s = (r = o.unstable_sxConfig) != null ? r : y1; function a(l) { let c = l; if (typeof l == "function") c = l(o); else if (typeof l != "object") return l; if (!c) return null; const u = aK(o.breakpoints), d = Object.keys(u); let p = u; return Object.keys(c).forEach(m => { const v = XK(c[m], o); if (v != null) if (typeof v == "object") if (s[m]) p = Oh(p, n(m, v, o, s)); else { const y = Aa({ theme: o }, v, _ => ({ [m]: _ })); jK(y, v) ? p[m] = e({ sx: v, theme: o }) : p = Oh(p, y) } else p = Oh(p, n(m, v, o, s)) }), lK(d, p) } return Array.isArray(i) ? i.map(a) : a(i) } return e } const mU = JK(); mU.filterProps = ["sx"]; const Fw = mU, KK = ["breakpoints", "palette", "spacing", "shape"]; function Uw(n = {}, ...e) { const { breakpoints: t = {}, palette: r = {}, spacing: i, shape: o = {} } = n, s = Wt(n, KK), a = iK(t), l = mK(i); let c = Qo({ breakpoints: a, direction: "ltr", components: {}, palette: Ee({ mode: "light" }, r), spacing: l, shape: Ee({}, sK, o) }, s); return c = e.reduce((u, d) => Qo(u, d), c), c.unstable_sxConfig = Ee({}, y1, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function (d) { return Fw({ sx: d, theme: this }) }, c } function YK(n) { return Object.keys(n).length === 0 } function gU(n = null) { const e = N.useContext(uU); return !e || YK(e) ? n : e } const $K = Uw(); function vU(n = $K) { return gU(n) } const QK = ["sx"], ZK = n => { var e, t; const r = { systemProps: {}, otherProps: {} }, i = (e = n == null || (t = n.theme) == null ? void 0 : t.unstable_sxConfig) != null ? e : y1; return Object.keys(n).forEach(o => { i[o] ? r.systemProps[o] = n[o] : r.otherProps[o] = n[o] }), r }; function qK(n) { const { sx: e } = n, t = Wt(n, QK), { systemProps: r, otherProps: i } = ZK(t); let o; return Array.isArray(e) ? o = [r, ...e] : typeof e == "function" ? o = (...s) => { const a = e(...s); return aa(a) ? Ee({}, r, a) : r } : o = Ee({}, r, e), Ee({}, i, { sx: o }) } const eY = ["variant"]; function RP(n) { return n.length === 0 } function yU(n) { const { variant: e } = n, t = Wt(n, eY); let r = e || ""; return Object.keys(t).sort().forEach(i => { i === "color" ? r += RP(r) ? n[i] : It(n[i]) : r += `${RP(r) ? i : It(i)}${It(n[i].toString())}` }), r } const tY = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"]; function nY(n) { return Object.keys(n).length === 0 } function rY(n) { return typeof n == "string" && n.charCodeAt(0) > 96 } const iY = (n, e) => e.components && e.components[n] && e.components[n].styleOverrides ? e.components[n].styleOverrides : null, Rv = n => { const e = {}; return n && n.forEach(t => { const r = yU(t.props); e[r] = t.style }), e }, oY = (n, e) => { let t = []; return e && e.components && e.components[n] && e.components[n].variants && (t = e.components[n].variants), Rv(t) }, Pv = (n, e, t) => { const { ownerState: r = {} } = n, i = []; return t && t.forEach(o => { let s = !0; Object.keys(o.props).forEach(a => { r[a] !== o.props[a] && n[a] !== o.props[a] && (s = !1) }), s && i.push(e[yU(o.props)]) }), i }, sY = (n, e, t, r) => { var i; const o = t == null || (i = t.components) == null || (i = i[r]) == null ? void 0 : i.variants; return Pv(n, e, o) }; function W0(n) { return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as" } const aY = Uw(), lY = n => n && n.charAt(0).toLowerCase() + n.slice(1); function j0({ defaultTheme: n, theme: e, themeId: t }) { return nY(e) ? n : e[t] || e } function cY(n) { return n ? (e, t) => t[n] : null } const PP = ({ styledArg: n, props: e, defaultTheme: t, themeId: r }) => { const i = n(Ee({}, e, { theme: j0(Ee({}, e, { defaultTheme: t, themeId: r })) })); let o; if (i && i.variants && (o = i.variants, delete i.variants), o) { const s = Pv(e, Rv(o), o); return [i, ...s] } return i }; function uY(n = {}) { const { themeId: e, defaultTheme: t = aY, rootShouldForwardProp: r = W0, slotShouldForwardProp: i = W0 } = n, o = s => Fw(Ee({}, s, { theme: j0(Ee({}, s, { defaultTheme: t, themeId: e })) })); return o.__mui_systemSx = !0, (s, a = {}) => { tK(s, E => E.filter(w => !(w != null && w.__mui_systemSx))); const { name: l, slot: c, skipVariantsResolver: u, skipSx: d, overridesResolver: p = cY(lY(c)) } = a, m = Wt(a, tY), v = u !== void 0 ? u : c && c !== "Root" && c !== "root" || !1, y = d || !1; let _, g = W0; c === "Root" || c === "root" ? g = r : c ? g = i : rY(s) && (g = void 0); const x = eK(s, Ee({ shouldForwardProp: g, label: _ }, m)), A = (E, ...w) => { const b = w ? w.map(P => { if (typeof P == "function" && P.__emotion_real !== P) return U => PP({ styledArg: P, props: U, defaultTheme: t, themeId: e }); if (aa(P)) { let U = P, G; return P && P.variants && (G = P.variants, delete U.variants, U = $ => { let z = P; return Pv($, Rv(G), G).forEach(q => { z = Qo(z, q) }), z }), U } return P }) : []; let T = E; if (aa(E)) { let P; E && E.variants && (P = E.variants, delete T.variants, T = U => { let G = E; return Pv(U, Rv(P), P).forEach(z => { G = Qo(G, z) }), G }) } else typeof E == "function" && E.__emotion_real !== E && (T = P => PP({ styledArg: E, props: P, defaultTheme: t, themeId: e })); l && p && b.push(P => { const U = j0(Ee({}, P, { defaultTheme: t, themeId: e })), G = iY(l, U); if (G) { const $ = {}; return Object.entries(G).forEach(([z, j]) => { $[z] = typeof j == "function" ? j(Ee({}, P, { theme: U })) : j }), p(P, $) } return null }), l && !v && b.push(P => { const U = j0(Ee({}, P, { defaultTheme: t, themeId: e })); return sY(P, oY(l, U), U, l) }), y || b.push(o); const B = b.length - w.length; if (Array.isArray(E) && B > 0) { const P = new Array(B).fill(""); T = [...E, ...P], T.raw = [...E.raw, ...P] } const R = x(T, ...b); return s.muiName && (R.muiName = s.muiName), R }; return x.withConfig && (A.withConfig = x.withConfig), A } } function fY(n) { const { theme: e, name: t, props: r } = n; return !e || !e.components || !e.components[t] || !e.components[t].defaultProps ? r : Cw(e.components[t].defaultProps, r) } function dY({ props: n, name: e, defaultTheme: t, themeId: r }) { let i = vU(t); return r && (i = i[r] || i), fY({ theme: i, name: e, props: n }) } function kw(n, e = 0, t = 1) { return Math.min(Math.max(e, n), t) } function hY(n) { n = n.slice(1); const e = new RegExp(`.{1,${n.length >= 6 ? 2 : 1}}`, "g"); let t = n.match(e); return t && t[0].length === 1 && (t = t.map(r => r + r)), t ? `rgb${t.length === 4 ? "a" : ""}(${t.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "" } function Xc(n) { if (n.type) return n; if (n.charAt(0) === "#") return Xc(hY(n)); const e = n.indexOf("("), t = n.substring(0, e); if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1) throw new Error(Kf(9, n)); let r = n.substring(e + 1, n.length - 1), i; if (t === "color") { if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1) throw new Error(Kf(10, i)) } else r = r.split(","); return r = r.map(o => parseFloat(o)), { type: t, values: r, colorSpace: i } } function _1(n) { const { type: e, colorSpace: t } = n; let { values: r } = n; return e.indexOf("rgb") !== -1 ? r = r.map((i, o) => o < 3 ? parseInt(i, 10) : i) : e.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), e.indexOf("color") !== -1 ? r = `${t} ${r.join(" ")}` : r = `${r.join(", ")}`, `${e}(${r})` } function pY(n) { n = Xc(n); const { values: e } = n, t = e[0], r = e[1] / 100, i = e[2] / 100, o = r * Math.min(i, 1 - i), s = (c, u = (c + t / 30) % 12) => i - o * Math.max(Math.min(u - 3, 9 - u, 1), -1); let a = "rgb"; const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)]; return n.type === "hsla" && (a += "a", l.push(e[3])), _1({ type: a, values: l }) } function sE(n) { n = Xc(n); let e = n.type === "hsl" || n.type === "hsla" ? Xc(pY(n)).values : n.values; return e = e.map(t => (n.type !== "color" && (t /= 255), t <= .03928 ? t / 12.92 : ((t + .055) / 1.055) ** 2.4)), Number((.2126 * e[0] + .7152 * e[1] + .0722 * e[2]).toFixed(3)) } function mY(n, e) { const t = sE(n), r = sE(e); return (Math.max(t, r) + .05) / (Math.min(t, r) + .05) } function Jo(n, e) { return n = Xc(n), e = kw(e), (n.type === "rgb" || n.type === "hsl") && (n.type += "a"), n.type === "color" ? n.values[3] = `/${e}` : n.values[3] = e, _1(n) } function Bv(n, e) { if (n = Xc(n), e = kw(e), n.type.indexOf("hsl") !== -1) n.values[2] *= 1 - e; else if (n.type.indexOf("rgb") !== -1 || n.type.indexOf("color") !== -1) for (let t = 0; t < 3; t += 1)n.values[t] *= 1 - e; return _1(n) } function Iv(n, e) { if (n = Xc(n), e = kw(e), n.type.indexOf("hsl") !== -1) n.values[2] += (100 - n.values[2]) * e; else if (n.type.indexOf("rgb") !== -1) for (let t = 0; t < 3; t += 1)n.values[t] += (255 - n.values[t]) * e; else if (n.type.indexOf("color") !== -1) for (let t = 0; t < 3; t += 1)n.values[t] += (1 - n.values[t]) * e; return _1(n) } function gY(n, e = .15) { return sE(n) > .5 ? Bv(n, e) : Iv(n, e) } function vY(n, e) { return Ee({ toolbar: { minHeight: 56, [n.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } }, [n.up("sm")]: { minHeight: 64 } } }, e) } const yY = { black: "#000", white: "#fff" }, Ap = yY, _Y = { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", A100: "#f5f5f5", A200: "#eeeeee", A400: "#bdbdbd", A700: "#616161" }, xY = _Y, SY = { 50: "#f3e5f5", 100: "#e1bee7", 200: "#ce93d8", 300: "#ba68c8", 400: "#ab47bc", 500: "#9c27b0", 600: "#8e24aa", 700: "#7b1fa2", 800: "#6a1b9a", 900: "#4a148c", A100: "#ea80fc", A200: "#e040fb", A400: "#d500f9", A700: "#aa00ff" }, Wu = SY, AY = { 50: "#ffebee", 100: "#ffcdd2", 200: "#ef9a9a", 300: "#e57373", 400: "#ef5350", 500: "#f44336", 600: "#e53935", 700: "#d32f2f", 800: "#c62828", 900: "#b71c1c", A100: "#ff8a80", A200: "#ff5252", A400: "#ff1744", A700: "#d50000" }, ju = AY, EY = { 50: "#fff3e0", 100: "#ffe0b2", 200: "#ffcc80", 300: "#ffb74d", 400: "#ffa726", 500: "#ff9800", 600: "#fb8c00", 700: "#f57c00", 800: "#ef6c00", 900: "#e65100", A100: "#ffd180", A200: "#ffab40", A400: "#ff9100", A700: "#ff6d00" }, sh = EY, MY = { 50: "#e3f2fd", 100: "#bbdefb", 200: "#90caf9", 300: "#64b5f6", 400: "#42a5f5", 500: "#2196f3", 600: "#1e88e5", 700: "#1976d2", 800: "#1565c0", 900: "#0d47a1", A100: "#82b1ff", A200: "#448aff", A400: "#2979ff", A700: "#2962ff" }, ys = MY, wY = { 50: "#e1f5fe", 100: "#b3e5fc", 200: "#81d4fa", 300: "#4fc3f7", 400: "#29b6f6", 500: "#03a9f4", 600: "#039be5", 700: "#0288d1", 800: "#0277bd", 900: "#01579b", A100: "#80d8ff", A200: "#40c4ff", A400: "#00b0ff", A700: "#0091ea" }, Xu = wY, bY = { 50: "#e8f5e9", 100: "#c8e6c9", 200: "#a5d6a7", 300: "#81c784", 400: "#66bb6a", 500: "#4caf50", 600: "#43a047", 700: "#388e3c", 800: "#2e7d32", 900: "#1b5e20", A100: "#b9f6ca", A200: "#69f0ae", A400: "#00e676", A700: "#00c853" }, Ju = bY, CY = ["mode", "contrastThreshold", "tonalOffset"], BP = { text: { primary: "rgba(0, 0, 0, 0.87)", secondary: "rgba(0, 0, 0, 0.6)", disabled: "rgba(0, 0, 0, 0.38)" }, divider: "rgba(0, 0, 0, 0.12)", background: { paper: Ap.white, default: Ap.white }, action: { active: "rgba(0, 0, 0, 0.54)", hover: "rgba(0, 0, 0, 0.04)", hoverOpacity: .04, selected: "rgba(0, 0, 0, 0.08)", selectedOpacity: .08, disabled: "rgba(0, 0, 0, 0.26)", disabledBackground: "rgba(0, 0, 0, 0.12)", disabledOpacity: .38, focus: "rgba(0, 0, 0, 0.12)", focusOpacity: .12, activatedOpacity: .12 } }, Wx = { text: { primary: Ap.white, secondary: "rgba(255, 255, 255, 0.7)", disabled: "rgba(255, 255, 255, 0.5)", icon: "rgba(255, 255, 255, 0.5)" }, divider: "rgba(255, 255, 255, 0.12)", background: { paper: "#121212", default: "#121212" }, action: { active: Ap.white, hover: "rgba(255, 255, 255, 0.08)", hoverOpacity: .08, selected: "rgba(255, 255, 255, 0.16)", selectedOpacity: .16, disabled: "rgba(255, 255, 255, 0.3)", disabledBackground: "rgba(255, 255, 255, 0.12)", disabledOpacity: .38, focus: "rgba(255, 255, 255, 0.12)", focusOpacity: .12, activatedOpacity: .24 } }; function IP(n, e, t, r) { const i = r.light || r, o = r.dark || r * 1.5; n[e] || (n.hasOwnProperty(t) ? n[e] = n[t] : e === "light" ? n.light = Iv(n.main, i) : e === "dark" && (n.dark = Bv(n.main, o))) } function TY(n = "light") { return n === "dark" ? { main: ys[200], light: ys[50], dark: ys[400] } : { main: ys[700], light: ys[400], dark: ys[800] } } function RY(n = "light") { return n === "dark" ? { main: Wu[200], light: Wu[50], dark: Wu[400] } : { main: Wu[500], light: Wu[300], dark: Wu[700] } } function PY(n = "light") { return n === "dark" ? { main: ju[500], light: ju[300], dark: ju[700] } : { main: ju[700], light: ju[400], dark: ju[800] } } function BY(n = "light") { return n === "dark" ? { main: Xu[400], light: Xu[300], dark: Xu[700] } : { main: Xu[700], light: Xu[500], dark: Xu[900] } } function IY(n = "light") { return n === "dark" ? { main: Ju[400], light: Ju[300], dark: Ju[700] } : { main: Ju[800], light: Ju[500], dark: Ju[900] } } function LY(n = "light") { return n === "dark" ? { main: sh[400], light: sh[300], dark: sh[700] } : { main: "#ed6c02", light: sh[500], dark: sh[900] } } function DY(n) { const { mode: e = "light", contrastThreshold: t = 3, tonalOffset: r = .2 } = n, i = Wt(n, CY), o = n.primary || TY(e), s = n.secondary || RY(e), a = n.error || PY(e), l = n.info || BY(e), c = n.success || IY(e), u = n.warning || LY(e); function d(y) { return mY(y, Wx.text.primary) >= t ? Wx.text.primary : BP.text.primary } const p = ({ color: y, name: _, mainShade: g = 500, lightShade: x = 300, darkShade: A = 700 }) => { if (y = Ee({}, y), !y.main && y[g] && (y.main = y[g]), !y.hasOwnProperty("main")) throw new Error(Kf(11, _ ? ` (${_})` : "", g)); if (typeof y.main != "string") throw new Error(Kf(12, _ ? ` (${_})` : "", JSON.stringify(y.main))); return IP(y, "light", x, r), IP(y, "dark", A, r), y.contrastText || (y.contrastText = d(y.main)), y }, m = { dark: Wx, light: BP }; return Qo(Ee({ common: Ee({}, Ap), mode: e, primary: p({ color: o, name: "primary" }), secondary: p({ color: s, name: "secondary", mainShade: "A400", lightShade: "A200", darkShade: "A700" }), error: p({ color: a, name: "error" }), warning: p({ color: u, name: "warning" }), info: p({ color: l, name: "info" }), success: p({ color: c, name: "success" }), grey: xY, contrastThreshold: t, getContrastText: d, augmentColor: p, tonalOffset: r }, m[e]), i) } const OY = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]; function FY(n) { return Math.round(n * 1e5) / 1e5 } const LP = { textTransform: "uppercase" }, DP = '"Roboto", "Helvetica", "Arial", sans-serif'; function UY(n, e) { const t = typeof e == "function" ? e(n) : e, { fontFamily: r = DP, fontSize: i = 14, fontWeightLight: o = 300, fontWeightRegular: s = 400, fontWeightMedium: a = 500, fontWeightBold: l = 700, htmlFontSize: c = 16, allVariants: u, pxToRem: d } = t, p = Wt(t, OY), m = i / 14, v = d || (g => `${g / c * m}rem`), y = (g, x, A, E, w) => Ee({ fontFamily: r, fontWeight: g, fontSize: v(x), lineHeight: A }, r === DP ? { letterSpacing: `${FY(E / x)}em` } : {}, w, u), _ = { h1: y(o, 96, 1.167, -1.5), h2: y(o, 60, 1.2, -.5), h3: y(s, 48, 1.167, 0), h4: y(s, 34, 1.235, .25), h5: y(s, 24, 1.334, 0), h6: y(a, 20, 1.6, .15), subtitle1: y(s, 16, 1.75, .15), subtitle2: y(a, 14, 1.57, .1), body1: y(s, 16, 1.5, .15), body2: y(s, 14, 1.43, .15), button: y(a, 14, 1.75, .4, LP), caption: y(s, 12, 1.66, .4), overline: y(s, 12, 2.66, 1, LP), inherit: { fontFamily: "inherit", fontWeight: "inherit", fontSize: "inherit", lineHeight: "inherit", letterSpacing: "inherit" } }; return Qo(Ee({ htmlFontSize: c, pxToRem: v, fontFamily: r, fontSize: i, fontWeightLight: o, fontWeightRegular: s, fontWeightMedium: a, fontWeightBold: l }, _), p, { clone: !1 }) } const kY = .2, NY = .14, zY = .12; function wn(...n) { return [`${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px rgba(0,0,0,${kY})`, `${n[4]}px ${n[5]}px ${n[6]}px ${n[7]}px rgba(0,0,0,${NY})`, `${n[8]}px ${n[9]}px ${n[10]}px ${n[11]}px rgba(0,0,0,${zY})`].join(",") } const GY = ["none", wn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), wn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), wn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), wn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), wn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), wn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), wn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), wn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), wn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), wn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), wn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), wn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), wn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), wn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), wn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), wn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), wn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), wn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), wn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), wn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), wn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), wn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), wn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), wn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], HY = GY, VY = ["duration", "easing", "delay"], WY = { easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)", easeOut: "cubic-bezier(0.0, 0, 0.2, 1)", easeIn: "cubic-bezier(0.4, 0, 1, 1)", sharp: "cubic-bezier(0.4, 0, 0.6, 1)" }, jY = { shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195 }; function OP(n) { return `${Math.round(n)}ms` } function XY(n) { if (!n) return 0; const e = n / 36; return Math.round((4 + 15 * e ** .25 + e / 5) * 10) } function JY(n) { const e = Ee({}, WY, n.easing), t = Ee({}, jY, n.duration); return Ee({ getAutoHeightDuration: XY, create: (i = ["all"], o = {}) => { const { duration: s = t.standard, easing: a = e.easeInOut, delay: l = 0 } = o; return Wt(o, VY), (Array.isArray(i) ? i : [i]).map(c => `${c} ${typeof s == "string" ? s : OP(s)} ${a} ${typeof l == "string" ? l : OP(l)}`).join(",") } }, n, { easing: e, duration: t }) } const KY = { mobileStepper: 1e3, fab: 1050, speedDial: 1050, appBar: 1100, drawer: 1200, modal: 1300, snackbar: 1400, tooltip: 1500 }, YY = KY, $Y = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"]; function QY(n = {}, ...e) { const { mixins: t = {}, palette: r = {}, transitions: i = {}, typography: o = {} } = n, s = Wt(n, $Y); if (n.vars) throw new Error(Kf(18)); const a = DY(r), l = Uw(n); let c = Qo(l, { mixins: vY(l.breakpoints, t), palette: a, shadows: HY.slice(), typography: UY(a, o), transitions: JY(i), zIndex: Ee({}, YY) }); return c = Qo(c, s), c = e.reduce((u, d) => Qo(u, d), c), c.unstable_sxConfig = Ee({}, y1, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function (d) { return Fw({ sx: d, theme: this }) }, c } const ZY = QY(), Nw = ZY, zw = "$$material"; function ni({ props: n, name: e }) { return dY({ props: n, name: e, defaultTheme: Nw, themeId: zw }) } const em = n => W0(n) && n !== "classes", qY = uY({ themeId: zw, defaultTheme: Nw, rootShouldForwardProp: em }), Zt = qY; function e$(n) { return Ir("MuiSvgIcon", n) } Lr("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]); const t$ = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], n$ = n => { const { color: e, fontSize: t, classes: r } = n, i = { root: ["root", e !== "inherit" && `color${It(e)}`, `fontSize${It(t)}`] }; return ti(i, e$, r) }, r$ = Zt("svg", { name: "MuiSvgIcon", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, t.color !== "inherit" && e[`color${It(t.color)}`], e[`fontSize${It(t.fontSize)}`]] } })(({ theme: n, ownerState: e }) => { var t, r, i, o, s, a, l, c, u, d, p, m, v; return { userSelect: "none", width: "1em", height: "1em", display: "inline-block", fill: e.hasSvgAsChild ? void 0 : "currentColor", flexShrink: 0, transition: (t = n.transitions) == null || (r = t.create) == null ? void 0 : r.call(t, "fill", { duration: (i = n.transitions) == null || (i = i.duration) == null ? void 0 : i.shorter }), fontSize: { inherit: "inherit", small: ((o = n.typography) == null || (s = o.pxToRem) == null ? void 0 : s.call(o, 20)) || "1.25rem", medium: ((a = n.typography) == null || (l = a.pxToRem) == null ? void 0 : l.call(a, 24)) || "1.5rem", large: ((c = n.typography) == null || (u = c.pxToRem) == null ? void 0 : u.call(c, 35)) || "2.1875rem" }[e.fontSize], color: (d = (p = (n.vars || n).palette) == null || (p = p[e.color]) == null ? void 0 : p.main) != null ? d : { action: (m = (n.vars || n).palette) == null || (m = m.action) == null ? void 0 : m.active, disabled: (v = (n.vars || n).palette) == null || (v = v.action) == null ? void 0 : v.disabled, inherit: void 0 }[e.color] } }), _U = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiSvgIcon" }), { children: i, className: o, color: s = "inherit", component: a = "svg", fontSize: l = "medium", htmlColor: c, inheritViewBox: u = !1, titleAccess: d, viewBox: p = "0 0 24 24" } = r, m = Wt(r, t$), v = N.isValidElement(i) && i.type === "svg", y = Ee({}, r, { color: s, component: a, fontSize: l, instanceFontSize: e.fontSize, inheritViewBox: u, viewBox: p, hasSvgAsChild: v }), _ = {}; u || (_.viewBox = p); const g = n$(y); return st.jsxs(r$, Ee({ as: a, className: rn(g.root, o), focusable: "false", color: c, "aria-hidden": d ? void 0 : !0, role: d ? "img" : void 0, ref: t }, _, m, v && i.props, { ownerState: y, children: [v ? i.props.children : i, d ? st.jsx("title", { children: d }) : null] })) }); _U.muiName = "SvgIcon"; const FP = _U; function Ta(n, e) { function t(r, i) { return st.jsx(FP, Ee({ "data-testid": `${e}Icon`, ref: i }, r, { children: n })) } return t.muiName = FP.muiName, N.memo(N.forwardRef(t)) } const i$ = Ta(st.jsx("path", { d: "M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.69L9.54 5.98C8.87 5.55 8 6.03 8 6.82z" }), "PlayArrowRounded"), o$ = Ta(st.jsx("path", { d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91z" }), "RestartAlt"), x1 = "images/ledger-c7d63032.jpg"; function Xo(n) { for (var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; throw Error("[Immer] minified error nr: " + n + (t.length ? " " + t.map(function (i) { return "'" + i + "'" }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf") } function wl(n) { return !!n && !!n[bn] } function Ea(n) { var e; return !!n && (function (t) { if (!t || typeof t != "object") return !1; var r = Object.getPrototypeOf(t); if (r === null) return !0; var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor; return i === Object || typeof i == "function" && Function.toString.call(i) === p$ }(n) || Array.isArray(n) || !!n[VP] || !!(!((e = n.constructor) === null || e === void 0) && e[VP]) || Gw(n) || Hw(n)) } function Jc(n, e, t) { t === void 0 && (t = !1), fd(n) === 0 ? (t ? Object.keys : Bf)(n).forEach(function (r) { t && typeof r == "symbol" || e(r, n[r], n) }) : n.forEach(function (r, i) { return e(i, r, n) }) } function fd(n) { var e = n[bn]; return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(n) ? 1 : Gw(n) ? 2 : Hw(n) ? 3 : 0 } function Pf(n, e) { return fd(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e) } function s$(n, e) { return fd(n) === 2 ? n.get(e) : n[e] } function xU(n, e, t) { var r = fd(n); r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : n[e] = t } function SU(n, e) { return n === e ? n !== 0 || 1 / n == 1 / e : n != n && e != e } function Gw(n) { return d$ && n instanceof Map } function Hw(n) { return h$ && n instanceof Set } function dc(n) { return n.o || n.t } function Vw(n) { if (Array.isArray(n)) return Array.prototype.slice.call(n); var e = EU(n); delete e[bn]; for (var t = Bf(e), r = 0; r < t.length; r++) { var i = t[r], o = e[i]; o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (e[i] = { configurable: !0, writable: !0, enumerable: o.enumerable, value: n[i] }) } return Object.create(Object.getPrototypeOf(n), e) } function Ww(n, e) { return e === void 0 && (e = !1), jw(n) || wl(n) || !Ea(n) || (fd(n) > 1 && (n.set = n.add = n.clear = n.delete = a$), Object.freeze(n), e && Jc(n, function (t, r) { return Ww(r, !0) }, !0)), n } function a$() { Xo(2) } function jw(n) { return n == null || typeof n != "object" || Object.isFrozen(n) } function Is(n) { var e = uE[n]; return e || Xo(18, n), e } function l$(n, e) { uE[n] || (uE[n] = e) } function aE() { return Ep } function jx(n, e) { e && (Is("Patches"), n.u = [], n.s = [], n.v = e) } function Lv(n) { lE(n), n.p.forEach(c$), n.p = null } function lE(n) { n === Ep && (Ep = n.l) } function UP(n) { return Ep = { p: [], l: Ep, h: n, m: !0, _: 0 } } function c$(n) { var e = n[bn]; e.i === 0 || e.i === 1 ? e.j() : e.g = !0 } function Xx(n, e) { e._ = e.p.length; var t = e.p[0], r = n !== void 0 && n !== t; return e.h.O || Is("ES5").S(e, n, r), r ? (t[bn].P && (Lv(e), Xo(4)), Ea(n) && (n = Dv(e, n), e.l || Ov(e, n)), e.u && Is("Patches").M(t[bn].t, n, e.u, e.s)) : n = Dv(e, t, []), Lv(e), e.u && e.v(e.u, e.s), n !== AU ? n : void 0 } function Dv(n, e, t) { if (jw(e)) return e; var r = e[bn]; if (!r) return Jc(e, function (a, l) { return kP(n, r, e, a, l, t) }, !0), e; if (r.A !== n) return e; if (!r.P) return Ov(n, r.t, !0), r.t; if (!r.I) { r.I = !0, r.A._--; var i = r.i === 4 || r.i === 5 ? r.o = Vw(r.k) : r.o, o = i, s = !1; r.i === 3 && (o = new Set(i), i.clear(), s = !0), Jc(o, function (a, l) { return kP(n, r, i, a, l, t, s) }), Ov(n, i, !1), t && n.u && Is("Patches").N(r, t, n.u, n.s) } return r.o } function kP(n, e, t, r, i, o, s) { if (wl(i)) { var a = Dv(n, i, o && e && e.i !== 3 && !Pf(e.R, r) ? o.concat(r) : void 0); if (xU(t, r, a), !wl(a)) return; n.m = !1 } else s && t.add(i); if (Ea(i) && !jw(i)) { if (!n.h.D && n._ < 1) return; Dv(n, i), e && e.A.l || Ov(n, i) } } function Ov(n, e, t) { t === void 0 && (t = !1), !n.l && n.h.D && n.m && Ww(e, t) } function Jx(n, e) { var t = n[bn]; return (t ? dc(t) : n)[e] } function NP(n, e) { if (e in n) for (var t = Object.getPrototypeOf(n); t;) { var r = Object.getOwnPropertyDescriptor(t, e); if (r) return r; t = Object.getPrototypeOf(t) } } function el(n) { n.P || (n.P = !0, n.l && el(n.l)) } function Kx(n) { n.o || (n.o = Vw(n.t)) } function cE(n, e, t) { var r = Gw(e) ? Is("MapSet").F(e, t) : Hw(e) ? Is("MapSet").T(e, t) : n.O ? function (i, o) { var s = Array.isArray(i), a = { i: s ? 1 : 0, A: o ? o.A : aE(), P: !1, I: !1, R: {}, l: o, t: i, k: null, o: null, j: null, C: !1 }, l = a, c = Mp; s && (l = [a], c = mh); var u = Proxy.revocable(l, c), d = u.revoke, p = u.proxy; return a.k = p, a.j = d, p }(e, t) : Is("ES5").J(e, t); return (t ? t.A : aE()).p.push(r), r } function u$(n) { return wl(n) || Xo(22, n), function e(t) { if (!Ea(t)) return t; var r, i = t[bn], o = fd(t); if (i) { if (!i.P && (i.i < 4 || !Is("ES5").K(i))) return i.t; i.I = !0, r = zP(t, o), i.I = !1 } else r = zP(t, o); return Jc(r, function (s, a) { i && s$(i.t, s) === a || xU(r, s, e(a)) }), o === 3 ? new Set(r) : r }(n) } function zP(n, e) { switch (e) { case 2: return new Map(n); case 3: return Array.from(n) }return Vw(n) } function f$() { function n(o, s) { var a = i[o]; return a ? a.enumerable = s : i[o] = a = { configurable: !0, enumerable: s, get: function () { var l = this[bn]; return Mp.get(l, o) }, set: function (l) { var c = this[bn]; Mp.set(c, o, l) } }, a } function e(o) { for (var s = o.length - 1; s >= 0; s--) { var a = o[s][bn]; if (!a.P) switch (a.i) { case 5: r(a) && el(a); break; case 4: t(a) && el(a) } } } function t(o) { for (var s = o.t, a = o.k, l = Bf(a), c = l.length - 1; c >= 0; c--) { var u = l[c]; if (u !== bn) { var d = s[u]; if (d === void 0 && !Pf(s, u)) return !0; var p = a[u], m = p && p[bn]; if (m ? m.t !== d : !SU(p, d)) return !0 } } var v = !!s[bn]; return l.length !== Bf(s).length + (v ? 0 : 1) } function r(o) { var s = o.k; if (s.length !== o.t.length) return !0; var a = Object.getOwnPropertyDescriptor(s, s.length - 1); if (a && !a.get) return !0; for (var l = 0; l < s.length; l++)if (!s.hasOwnProperty(l)) return !0; return !1 } var i = {}; l$("ES5", { J: function (o, s) { var a = Array.isArray(o), l = function (u, d) { if (u) { for (var p = Array(d.length), m = 0; m < d.length; m++)Object.defineProperty(p, "" + m, n(m, !0)); return p } var v = EU(d); delete v[bn]; for (var y = Bf(v), _ = 0; _ < y.length; _++) { var g = y[_]; v[g] = n(g, u || !!v[g].enumerable) } return Object.create(Object.getPrototypeOf(d), v) }(a, o), c = { i: a ? 5 : 4, A: s ? s.A : aE(), P: !1, I: !1, R: {}, l: s, t: o, k: l, o: null, g: !1, C: !1 }; return Object.defineProperty(l, bn, { value: c, writable: !0 }), l }, S: function (o, s, a) { a ? wl(s) && s[bn].A === o && e(o.p) : (o.u && function l(c) { if (c && typeof c == "object") { var u = c[bn]; if (u) { var d = u.t, p = u.k, m = u.R, v = u.i; if (v === 4) Jc(p, function (A) { A !== bn && (d[A] !== void 0 || Pf(d, A) ? m[A] || l(p[A]) : (m[A] = !0, el(u))) }), Jc(d, function (A) { p[A] !== void 0 || Pf(p, A) || (m[A] = !1, el(u)) }); else if (v === 5) { if (r(u) && (el(u), m.length = !0), p.length < d.length) for (var y = p.length; y < d.length; y++)m[y] = !1; else for (var _ = d.length; _ < p.length; _++)m[_] = !0; for (var g = Math.min(p.length, d.length), x = 0; x < g; x++)p.hasOwnProperty(x) || (m[x] = !0), m[x] === void 0 && l(p[x]) } } } }(o.p[0]), e(o.p)) }, K: function (o) { return o.i === 4 ? t(o) : r(o) } }) } var GP, Ep, Xw = typeof Symbol < "u" && typeof Symbol("x") == "symbol", d$ = typeof Map < "u", h$ = typeof Set < "u", HP = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", AU = Xw ? Symbol.for("immer-nothing") : ((GP = {})["immer-nothing"] = !0, GP), VP = Xw ? Symbol.for("immer-draftable") : "__$immer_draftable", bn = Xw ? Symbol.for("immer-state") : "__$immer_state", p$ = "" + Object.prototype.constructor, Bf = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function (n) { return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n)) } : Object.getOwnPropertyNames, EU = Object.getOwnPropertyDescriptors || function (n) { var e = {}; return Bf(n).forEach(function (t) { e[t] = Object.getOwnPropertyDescriptor(n, t) }), e }, uE = {}, Mp = { get: function (n, e) { if (e === bn) return n; var t = dc(n); if (!Pf(t, e)) return function (i, o, s) { var a, l = NP(o, s); return l ? "value" in l ? l.value : (a = l.get) === null || a === void 0 ? void 0 : a.call(i.k) : void 0 }(n, t, e); var r = t[e]; return n.I || !Ea(r) ? r : r === Jx(n.t, e) ? (Kx(n), n.o[e] = cE(n.A.h, r, n)) : r }, has: function (n, e) { return e in dc(n) }, ownKeys: function (n) { return Reflect.ownKeys(dc(n)) }, set: function (n, e, t) { var r = NP(dc(n), e); if (r != null && r.set) return r.set.call(n.k, t), !0; if (!n.P) { var i = Jx(dc(n), e), o = i == null ? void 0 : i[bn]; if (o && o.t === t) return n.o[e] = t, n.R[e] = !1, !0; if (SU(t, i) && (t !== void 0 || Pf(n.t, e))) return !0; Kx(n), el(n) } return n.o[e] === t && (t !== void 0 || e in n.o) || Number.isNaN(t) && Number.isNaN(n.o[e]) || (n.o[e] = t, n.R[e] = !0), !0 }, deleteProperty: function (n, e) { return Jx(n.t, e) !== void 0 || e in n.t ? (n.R[e] = !1, Kx(n), el(n)) : delete n.R[e], n.o && delete n.o[e], !0 }, getOwnPropertyDescriptor: function (n, e) { var t = dc(n), r = Reflect.getOwnPropertyDescriptor(t, e); return r && { writable: !0, configurable: n.i !== 1 || e !== "length", enumerable: r.enumerable, value: t[e] } }, defineProperty: function () { Xo(11) }, getPrototypeOf: function (n) { return Object.getPrototypeOf(n.t) }, setPrototypeOf: function () { Xo(12) } }, mh = {}; Jc(Mp, function (n, e) { mh[n] = function () { return arguments[0] = arguments[0][0], e.apply(this, arguments) } }), mh.deleteProperty = function (n, e) { return mh.set.call(this, n, e, void 0) }, mh.set = function (n, e, t) { return Mp.set.call(this, n[0], e, t, n[0]) }; var m$ = function () { function n(t) { var r = this; this.O = HP, this.D = !0, this.produce = function (i, o, s) { if (typeof i == "function" && typeof o != "function") { var a = o; o = i; var l = r; return function (y) { var _ = this; y === void 0 && (y = a); for (var g = arguments.length, x = Array(g > 1 ? g - 1 : 0), A = 1; A < g; A++)x[A - 1] = arguments[A]; return l.produce(y, function (E) { var w; return (w = o).call.apply(w, [_, E].concat(x)) }) } } var c; if (typeof o != "function" && Xo(6), s !== void 0 && typeof s != "function" && Xo(7), Ea(i)) { var u = UP(r), d = cE(r, i, void 0), p = !0; try { c = o(d), p = !1 } finally { p ? Lv(u) : lE(u) } return typeof Promise < "u" && c instanceof Promise ? c.then(function (y) { return jx(u, s), Xx(y, u) }, function (y) { throw Lv(u), y }) : (jx(u, s), Xx(c, u)) } if (!i || typeof i != "object") { if ((c = o(i)) === void 0 && (c = i), c === AU && (c = void 0), r.D && Ww(c, !0), s) { var m = [], v = []; Is("Patches").M(i, c, m, v), s(m, v) } return c } Xo(21, i) }, this.produceWithPatches = function (i, o) { if (typeof i == "function") return function (c) { for (var u = arguments.length, d = Array(u > 1 ? u - 1 : 0), p = 1; p < u; p++)d[p - 1] = arguments[p]; return r.produceWithPatches(c, function (m) { return i.apply(void 0, [m].concat(d)) }) }; var s, a, l = r.produce(i, o, function (c, u) { s = c, a = u }); return typeof Promise < "u" && l instanceof Promise ? l.then(function (c) { return [c, s, a] }) : [l, s, a] }, typeof (t == null ? void 0 : t.useProxies) == "boolean" && this.setUseProxies(t.useProxies), typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze) } var e = n.prototype; return e.createDraft = function (t) { Ea(t) || Xo(8), wl(t) && (t = u$(t)); var r = UP(this), i = cE(this, t, void 0); return i[bn].C = !0, lE(r), i }, e.finishDraft = function (t, r) { var i = t && t[bn], o = i.A; return jx(o, r), Xx(void 0, o) }, e.setAutoFreeze = function (t) { this.D = t }, e.setUseProxies = function (t) { t && !HP && Xo(20), this.O = t }, e.applyPatches = function (t, r) { var i; for (i = r.length - 1; i >= 0; i--) { var o = r[i]; if (o.path.length === 0 && o.op === "replace") { t = o.value; break } } i > -1 && (r = r.slice(i + 1)); var s = Is("Patches").$; return wl(t) ? s(t, r) : this.produce(t, function (a) { return s(a, r) }) }, n }(), so = new m$, MU = so.produce; so.produceWithPatches.bind(so); so.setAutoFreeze.bind(so); so.setUseProxies.bind(so); so.applyPatches.bind(so); so.createDraft.bind(so); so.finishDraft.bind(so); function wp(n) { "@babel/helpers - typeof"; return wp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, wp(n) } function g$(n, e) { if (wp(n) !== "object" || n === null) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var r = t.call(n, e || "default"); if (wp(r) !== "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function v$(n) { var e = g$(n, "string"); return wp(e) === "symbol" ? e : String(e) } function y$(n, e, t) { return e = v$(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function WP(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable })), t.push.apply(t, r) } return t } function jP(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? WP(Object(t), !0).forEach(function (r) { y$(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : WP(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function Jr(n) { return "Minified Redux error #" + n + "; visit https://redux.js.org/Errors?code=" + n + " for the full message or use the non-minified dev environment for full errors. " } var XP = function () { return typeof Symbol == "function" && Symbol.observable || "@@observable" }(), Yx = function () { return Math.random().toString(36).substring(7).split("").join(".") }, Fv = { INIT: "@@redux/INIT" + Yx(), REPLACE: "@@redux/REPLACE" + Yx(), PROBE_UNKNOWN_ACTION: function () { return "@@redux/PROBE_UNKNOWN_ACTION" + Yx() } }; function _$(n) { if (typeof n != "object" || n === null) return !1; for (var e = n; Object.getPrototypeOf(e) !== null;)e = Object.getPrototypeOf(e); return Object.getPrototypeOf(n) === e } function wU(n, e, t) { var r; if (typeof e == "function" && typeof t == "function" || typeof t == "function" && typeof arguments[3] == "function") throw new Error(Jr(0)); if (typeof e == "function" && typeof t > "u" && (t = e, e = void 0), typeof t < "u") { if (typeof t != "function") throw new Error(Jr(1)); return t(wU)(n, e) } if (typeof n != "function") throw new Error(Jr(2)); var i = n, o = e, s = [], a = s, l = !1; function c() { a === s && (a = s.slice()) } function u() { if (l) throw new Error(Jr(3)); return o } function d(y) { if (typeof y != "function") throw new Error(Jr(4)); if (l) throw new Error(Jr(5)); var _ = !0; return c(), a.push(y), function () { if (_) { if (l) throw new Error(Jr(6)); _ = !1, c(); var x = a.indexOf(y); a.splice(x, 1), s = null } } } function p(y) { if (!_$(y)) throw new Error(Jr(7)); if (typeof y.type > "u") throw new Error(Jr(8)); if (l) throw new Error(Jr(9)); try { l = !0, o = i(o, y) } finally { l = !1 } for (var _ = s = a, g = 0; g < _.length; g++) { var x = _[g]; x() } return y } function m(y) { if (typeof y != "function") throw new Error(Jr(10)); i = y, p({ type: Fv.REPLACE }) } function v() { var y, _ = d; return y = { subscribe: function (x) { if (typeof x != "object" || x === null) throw new Error(Jr(11)); function A() { x.next && x.next(u()) } A(); var E = _(A); return { unsubscribe: E } } }, y[XP] = function () { return this }, y } return p({ type: Fv.INIT }), r = { dispatch: p, subscribe: d, getState: u, replaceReducer: m }, r[XP] = v, r } function x$(n) { Object.keys(n).forEach(function (e) { var t = n[e], r = t(void 0, { type: Fv.INIT }); if (typeof r > "u") throw new Error(Jr(12)); if (typeof t(void 0, { type: Fv.PROBE_UNKNOWN_ACTION() }) > "u") throw new Error(Jr(13)) }) } function S$(n) { for (var e = Object.keys(n), t = {}, r = 0; r < e.length; r++) { var i = e[r]; typeof n[i] == "function" && (t[i] = n[i]) } var o = Object.keys(t), s; try { x$(t) } catch (a) { s = a } return function (l, c) { if (l === void 0 && (l = {}), s) throw s; for (var u = !1, d = {}, p = 0; p < o.length; p++) { var m = o[p], v = t[m], y = l[m], _ = v(y, c); if (typeof _ > "u") throw c && c.type, new Error(Jr(14)); d[m] = _, u = u || _ !== y } return u = u || o.length !== Object.keys(l).length, u ? d : l } } function Uv() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return e.length === 0 ? function (r) { return r } : e.length === 1 ? e[0] : e.reduce(function (r, i) { return function () { return r(i.apply(void 0, arguments)) } }) } function A$() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return function (r) { return function () { var i = r.apply(void 0, arguments), o = function () { throw new Error(Jr(15)) }, s = { getState: i.getState, dispatch: function () { return o.apply(void 0, arguments) } }, a = e.map(function (l) { return l(s) }); return o = Uv.apply(void 0, a)(i.dispatch), jP(jP({}, i), {}, { dispatch: o }) } } } function bU(n) { var e = function (r) { var i = r.dispatch, o = r.getState; return function (s) { return function (a) { return typeof a == "function" ? a(i, o, n) : s(a) } } }; return e } var CU = bU(); CU.withExtraArgument = bU; const JP = CU; var TU = globalThis && globalThis.__extends || function () { var n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (r, i) { r.__proto__ = i } || function (r, i) { for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]) }, n(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); n(e, t); function r() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r) } }(), E$ = globalThis && globalThis.__generator || function (n, e) { var t = { label: 0, sent: function () { if (o[0] & 1) throw o[1]; return o[1] }, trys: [], ops: [] }, r, i, o, s; return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function () { return this }), s; function a(c) { return function (u) { return l([c, u]) } } function l(c) { if (r) throw new TypeError("Generator is already executing."); for (; t;)try { if (r = 1, i && (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, c[1])).done) return o; switch (i = 0, o && (c = [c[0] & 2, o.value]), c[0]) { case 0: case 1: o = c; break; case 4: return t.label++, { value: c[1], done: !1 }; case 5: t.label++, i = c[1], c = [0]; continue; case 7: c = t.ops.pop(), t.trys.pop(); continue; default: if (o = t.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) { t = 0; continue } if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) { t.label = c[1]; break } if (c[0] === 6 && t.label < o[1]) { t.label = o[1], o = c; break } if (o && t.label < o[2]) { t.label = o[2], t.ops.push(c); break } o[2] && t.ops.pop(), t.trys.pop(); continue }c = e.call(n, t) } catch (u) { c = [6, u], i = 0 } finally { r = o = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, $f = globalThis && globalThis.__spreadArray || function (n, e) { for (var t = 0, r = e.length, i = n.length; t < r; t++, i++)n[i] = e[t]; return n }, M$ = Object.defineProperty, w$ = Object.defineProperties, b$ = Object.getOwnPropertyDescriptors, KP = Object.getOwnPropertySymbols, C$ = Object.prototype.hasOwnProperty, T$ = Object.prototype.propertyIsEnumerable, YP = function (n, e, t) { return e in n ? M$(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t }, gl = function (n, e) { for (var t in e || (e = {})) C$.call(e, t) && YP(n, t, e[t]); if (KP) for (var r = 0, i = KP(e); r < i.length; r++) { var t = i[r]; T$.call(e, t) && YP(n, t, e[t]) } return n }, $x = function (n, e) { return w$(n, b$(e)) }, R$ = function (n, e, t) { return new Promise(function (r, i) { var o = function (l) { try { a(t.next(l)) } catch (c) { i(c) } }, s = function (l) { try { a(t.throw(l)) } catch (c) { i(c) } }, a = function (l) { return l.done ? r(l.value) : Promise.resolve(l.value).then(o, s) }; a((t = t.apply(n, e)).next()) }) }, P$ = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () { if (arguments.length !== 0) return typeof arguments[0] == "object" ? Uv : Uv.apply(null, arguments) }; function B$(n) { if (typeof n != "object" || n === null) return !1; var e = Object.getPrototypeOf(n); if (e === null) return !0; for (var t = e; Object.getPrototypeOf(t) !== null;)t = Object.getPrototypeOf(t); return e === t } function vl(n, e) { function t() { for (var r = [], i = 0; i < arguments.length; i++)r[i] = arguments[i]; if (e) { var o = e.apply(void 0, r); if (!o) throw new Error("prepareAction did not return an object"); return gl(gl({ type: n, payload: o.payload }, "meta" in o && { meta: o.meta }), "error" in o && { error: o.error }) } return { type: n, payload: r[0] } } return t.toString = function () { return "" + n }, t.type = n, t.match = function (r) { return r.type === n }, t } var I$ = function (n) { TU(e, n); function e() { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; var i = n.apply(this, t) || this; return Object.setPrototypeOf(i, e.prototype), i } return Object.defineProperty(e, Symbol.species, { get: function () { return e }, enumerable: !1, configurable: !0 }), e.prototype.concat = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; return n.prototype.concat.apply(this, t) }, e.prototype.prepend = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; return t.length === 1 && Array.isArray(t[0]) ? new (e.bind.apply(e, $f([void 0], t[0].concat(this)))) : new (e.bind.apply(e, $f([void 0], t.concat(this)))) }, e }(Array), L$ = function (n) { TU(e, n); function e() { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; var i = n.apply(this, t) || this; return Object.setPrototypeOf(i, e.prototype), i } return Object.defineProperty(e, Symbol.species, { get: function () { return e }, enumerable: !1, configurable: !0 }), e.prototype.concat = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; return n.prototype.concat.apply(this, t) }, e.prototype.prepend = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; return t.length === 1 && Array.isArray(t[0]) ? new (e.bind.apply(e, $f([void 0], t[0].concat(this)))) : new (e.bind.apply(e, $f([void 0], t.concat(this)))) }, e }(Array); function fE(n) { return Ea(n) ? MU(n, function () { }) : n } function D$(n) { return typeof n == "boolean" } function O$() { return function (e) { return F$(e) } } function F$(n) { n === void 0 && (n = {}); var e = n.thunk, t = e === void 0 ? !0 : e; n.immutableCheck, n.serializableCheck, n.actionCreatorCheck; var r = new I$; return t && (D$(t) ? r.push(JP) : r.push(JP.withExtraArgument(t.extraArgument))), r } var U$ = !0; function k$(n) { var e = O$(), t = n || {}, r = t.reducer, i = r === void 0 ? void 0 : r, o = t.middleware, s = o === void 0 ? e() : o, a = t.devTools, l = a === void 0 ? !0 : a, c = t.preloadedState, u = c === void 0 ? void 0 : c, d = t.enhancers, p = d === void 0 ? void 0 : d, m; if (typeof i == "function") m = i; else if (B$(i)) m = S$(i); else throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'); var v = s; typeof v == "function" && (v = v(e)); var y = A$.apply(void 0, v), _ = Uv; l && (_ = P$(gl({ trace: !U$ }, typeof l == "object" && l))); var g = new L$(y), x = g; Array.isArray(p) ? x = $f([y], p) : typeof p == "function" && (x = p(g)); var A = _.apply(void 0, x); return wU(m, u, A) } function RU(n) { var e = {}, t = [], r, i = { addCase: function (o, s) { var a = typeof o == "string" ? o : o.type; if (!a) throw new Error("`builder.addCase` cannot be called with an empty action type"); if (a in e) throw new Error("`builder.addCase` cannot be called with two reducers for the same action type"); return e[a] = s, i }, addMatcher: function (o, s) { return t.push({ matcher: o, reducer: s }), i }, addDefaultCase: function (o) { return r = o, i } }; return n(i), [e, t, r] } function N$(n) { return typeof n == "function" } function z$(n, e, t, r) { t === void 0 && (t = []); var i = typeof e == "function" ? RU(e) : [e, t, r], o = i[0], s = i[1], a = i[2], l; if (N$(n)) l = function () { return fE(n()) }; else { var c = fE(n); l = function () { return c } } function u(d, p) { d === void 0 && (d = l()); var m = $f([o[p.type]], s.filter(function (v) { var y = v.matcher; return y(p) }).map(function (v) { var y = v.reducer; return y })); return m.filter(function (v) { return !!v }).length === 0 && (m = [a]), m.reduce(function (v, y) { if (y) if (wl(v)) { var _ = v, g = y(_, p); return g === void 0 ? v : g } else { if (Ea(v)) return MU(v, function (x) { return y(x, p) }); var g = y(v, p); if (g === void 0) { if (v === null) return v; throw Error("A case reducer on a non-draftable value must not return undefined") } return g } return v }, d) } return u.getInitialState = l, u } function G$(n, e) { return n + "/" + e } function H$(n) { var e = n.name; if (!e) throw new Error("`name` is a required option for createSlice"); typeof process < "u"; var t = typeof n.initialState == "function" ? n.initialState : fE(n.initialState), r = n.reducers || {}, i = Object.keys(r), o = {}, s = {}, a = {}; i.forEach(function (u) { var d = r[u], p = G$(e, u), m, v; "reducer" in d ? (m = d.reducer, v = d.prepare) : m = d, o[u] = m, s[p] = m, a[u] = v ? vl(p, v) : vl(p) }); function l() { var u = typeof n.extraReducers == "function" ? RU(n.extraReducers) : [n.extraReducers], d = u[0], p = d === void 0 ? {} : d, m = u[1], v = m === void 0 ? [] : m, y = u[2], _ = y === void 0 ? void 0 : y, g = gl(gl({}, p), s); return z$(t, function (x) { for (var A in g) x.addCase(A, g[A]); for (var E = 0, w = v; E < w.length; E++) { var b = w[E]; x.addMatcher(b.matcher, b.reducer) } _ && x.addDefaultCase(_) }) } var c; return { name: e, reducer: function (u, d) { return c || (c = l()), c(u, d) }, actions: a, caseReducers: o, getInitialState: function () { return c || (c = l()), c.getInitialState() } } } var V$ = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", W$ = function (n) { n === void 0 && (n = 21); for (var e = "", t = n; t--;)e += V$[Math.random() * 64 | 0]; return e }, j$ = ["name", "message", "stack", "code"], Qx = function () { function n(e, t) { this.payload = e, this.meta = t } return n }(), $P = function () { function n(e, t) { this.payload = e, this.meta = t } return n }(), X$ = function (n) { if (typeof n == "object" && n !== null) { for (var e = {}, t = 0, r = j$; t < r.length; t++) { var i = r[t]; typeof n[i] == "string" && (e[i] = n[i]) } return e } return { message: String(n) } }; (function () { function n(e, t, r) { var i = vl(e + "/fulfilled", function (c, u, d, p) { return { payload: c, meta: $x(gl({}, p || {}), { arg: d, requestId: u, requestStatus: "fulfilled" }) } }), o = vl(e + "/pending", function (c, u, d) { return { payload: void 0, meta: $x(gl({}, d || {}), { arg: u, requestId: c, requestStatus: "pending" }) } }), s = vl(e + "/rejected", function (c, u, d, p, m) { return { payload: p, error: (r && r.serializeError || X$)(c || "Rejected"), meta: $x(gl({}, m || {}), { arg: d, requestId: u, rejectedWithValue: !!p, requestStatus: "rejected", aborted: (c == null ? void 0 : c.name) === "AbortError", condition: (c == null ? void 0 : c.name) === "ConditionError" }) } }), a = typeof AbortController < "u" ? AbortController : function () { function c() { this.signal = { aborted: !1, addEventListener: function () { }, dispatchEvent: function () { return !1 }, onabort: function () { }, removeEventListener: function () { }, reason: void 0, throwIfAborted: function () { } } } return c.prototype.abort = function () { }, c }(); function l(c) { return function (u, d, p) { var m = r != null && r.idGenerator ? r.idGenerator(c) : W$(), v = new a, y; function _(x) { y = x, v.abort() } var g = function () { return R$(this, null, function () { var x, A, E, w, b, T, B; return E$(this, function (R) { switch (R.label) { case 0: return R.trys.push([0, 4, , 5]), w = (x = r == null ? void 0 : r.condition) == null ? void 0 : x.call(r, c, { getState: d, extra: p }), K$(w) ? [4, w] : [3, 2]; case 1: w = R.sent(), R.label = 2; case 2: if (w === !1 || v.signal.aborted) throw { name: "ConditionError", message: "Aborted due to condition callback returning false." }; return b = new Promise(function (P, U) { return v.signal.addEventListener("abort", function () { return U({ name: "AbortError", message: y || "Aborted" }) }) }), u(o(m, c, (A = r == null ? void 0 : r.getPendingMeta) == null ? void 0 : A.call(r, { requestId: m, arg: c }, { getState: d, extra: p }))), [4, Promise.race([b, Promise.resolve(t(c, { dispatch: u, getState: d, extra: p, requestId: m, signal: v.signal, abort: _, rejectWithValue: function (P, U) { return new Qx(P, U) }, fulfillWithValue: function (P, U) { return new $P(P, U) } })).then(function (P) { if (P instanceof Qx) throw P; return P instanceof $P ? i(P.payload, m, c, P.meta) : i(P, m, c) })])]; case 3: return E = R.sent(), [3, 5]; case 4: return T = R.sent(), E = T instanceof Qx ? s(null, m, c, T.payload, T.meta) : s(T, m, c), [3, 5]; case 5: return B = r && !r.dispatchConditionRejection && s.match(E) && E.meta.condition, B || u(E), [2, E] } }) }) }(); return Object.assign(g, { abort: _, requestId: m, arg: c, unwrap: function () { return g.then(J$) } }) } } return Object.assign(l, { pending: o, rejected: s, fulfilled: i, typePrefix: e }) } return n.withTypes = function () { return n }, n })(); function J$(n) { if (n.meta && n.meta.rejectedWithValue) throw n.payload; if (n.error) throw n.error; return n.payload } function K$(n) { return n !== null && typeof n == "object" && typeof n.then == "function" } var Jw = "listenerMiddleware"; vl(Jw + "/add"); vl(Jw + "/removeAll"); vl(Jw + "/remove"); var QP; typeof queueMicrotask == "function" && queueMicrotask.bind(typeof window < "u" ? window : typeof global < "u" ? global : globalThis); f$(); const Y$ = { radioClicked: "conventional", userDetails: [], userBalance: 0, receiverAmt: 0, sendAnmiation: !1, playBlockChain: "conventional", showCard: !1, resetTheAnimation: !1, isTransactionProgressing: !1, receiverName: "", showLedger: !1, transactionError: !1, showSideOption: !1, isLoadingReceipt: !1, enableAlerts: !1, moneySendToReciver: !1, isCancelation: !1, isReturnAmt: !1, instructionMessage: [], isAnimating: !1, animationProgress: 0, showGlowCube: !0, waiting: !1, task: !0, request: "normal", selectedColor: { sender: "#008000", receiver: "#ddddff", verifier: "#FFFF00" }, verifierName: "", showLedgerAnimation: !1, clickedTime: 0, isRestart: !1, userBalanceBlockChain: 100, showCancelAlert: !1, isSceneLoaded: !1 }, PU = H$({ name: "BlockChainDetails", initialState: Y$, reducers: { updateRadionChange: (n, e) => { n.radioClicked = e.payload, n.showCard = !1, n.showLedger = !1, n.instructionMessage = [], n.userBalance = 0, n.isTransactionProgressing = !1, n.userDetails = [], n.waiting = !1, n.selectedColor = { sender: "#008000", receiver: "#ddddff", verifier: "#FFFF00" }, n.receiverName = "", n.verifierName = "", n.showLedgerAnimation = !1, n.clickedTime = 0, n.isRestart = !1, n.userBalanceBlockChain = 100, n.isSceneLoaded = !1 }, updateRetart: n => { n.radioClicked = "conventional", n.showCard = !1, n.showLedger = !1, n.instructionMessage = [], n.userBalance = 0, n.isTransactionProgressing = !1, n.waiting = !1, n.userDetails = [], n.isRestart = !0, n.isAnimating = !1, n.animationProgress = 0, n.showGlowCube = !0, n.waiting = !1, n.task = !0, n.request = "normal", n.selectedColor = { sender: "#008000", receiver: "#ddddff", verifier: "#FFFF00" }, n.receiverName = "", n.verifierName = "", n.showLedgerAnimation = !1, n.clickedTime = 0, n.isRestart = !1, n.userBalanceBlockChain = 100, n.isSceneLoaded = !1 }, sendMoneyToReceiver: (n, e) => { n.userDetails = [...n.userDetails, e.payload], n.receiverAmt = e.payload.amount, n.sendAnmiation = !0, n.verifierName = "" }, sendReceiverName: (n, e) => { n.receiverName = e.payload }, onHandlePlayBlokChain: (n, e) => { n.playBlockChain = e.payload.setType, n.showCard = e.payload.showCard }, transactionProgresing: n => { n.isTransactionProgressing = !0 }, onEnableAlerts: n => { n.enableAlerts = !0 }, UpdateMoneySendToReciver: (n, e) => { n.moneySendToReciver = e.payload }, transactionProgresingStop: n => { n.isTransactionProgressing = !1 }, updateBalance: (n, e) => { n.userBalance = e.payload }, updateBalanceBlockChain: (n, e) => { n.userBalanceBlockChain = e.payload }, resetAnimation: (n, e) => { n.resetTheAnimation = e.payload }, updateStopAnimation: (n, e) => { n.sendAnmiation = e.payload }, updateLedger: (n, e) => { n.showLedger = e.payload }, updateTranscationError: (n, e) => { n.transactionError = e.payload }, updateShowSideOption: (n, e) => { n.showSideOption = e.payload }, updateInstruction: (n, e) => { n.instructionMessage = e.payload }, startAnimation: n => { n.isAnimating = !0, n.showGlowCube = !0, n.animationProgress = 0 }, stopAnimation: n => { n.isAnimating = !1, n.animationProgress = 0, n.showGlowCube = !1 }, updateAnimationProgress: (n, e) => { n.animationProgress = e.payload }, waitingStart: (n, e) => { n.waiting = e.payload }, updateClickTime: (n, e) => { n.clickedTime = e.payload }, updateTask: (n, e) => { n.task = e.payload }, updateRquest: (n, e) => { n.request = e.payload }, updateSelectedColor: (n, e) => { n.selectedColor = e.payload }, onHandleChangeVerifer: (n, e) => { n.verifierName = e.payload }, updateLedgerAnimation: (n, e) => { n.showLedgerAnimation = e.payload }, updateShowAlert: (n, e) => { n.showCancelAlert = e.payload }, updateCancelationStatus: (n, e) => { n.isCancelation = e.payload }, updateSceneLoaded: (n, e) => { n.isSceneLoaded = e.payload } } }), { updateShowAlert: BU, returnAmount: Nne, updateRadionChange: $$, sendMoneyToReceiver: ZP, onHandlePlayBlokChain: qP, updateShowSideOption: IU, updateBalance: Q$, updateBalanceBlockChain: Z$, transactionProgresing: eB, resetAnimation: zne, updateTranscationError: Gne, updateLedger: q$, transactionProgresingStop: eQ, sendReceiverName: tB, updateStopAnimation: Hne, onEnableAlerts: Vne, UpdateMoneySendToReciver: Wne, updateIsCancel: jne, updateInstruction: lr, startAnimation: kv, stopAnimation: tQ, updateAnimationProgress: nQ, waitingStart: Kw, updateRetart: rQ, updateTask: nB, updateRquest: LU, updateSelectedColor: iQ, onHandleChangeVerifer: DU, updateLedgerAnimation: dE, updateClickTime: oQ, updateCancelationStatus: sQ, updateSceneLoaded: aQ } = PU.actions, lQ = PU.reducer, cQ = () => { const n = Lo(Ca, x1), e = oo(), { instructionMessage: t, verifierName: r } = mi(u => u.DoubleSpendingReducer), [i, o] = N.useState({ c: !0, d: !0, a: !0, e: !0, aHide: !1, dHide: !1, cHide: !1, eHide: !1 }), s = N.useRef(), a = N.useRef(), l = N.useRef(), c = N.useRef(); return rs(() => { i.a && (l.current.position.x -= .05, l.current.position.z += .02, l.current.position.y -= .05), i.c && (s.current.position.x += .05, s.current.position.z += .02, s.current.position.y -= .05), i.e && (c.current.position.y -= .05), i.d && (a.current.position.y -= .05) }), N.useEffect(() => { let u; return u = setTimeout(() => { o(d => ({ ...d, a: !1, aHide: !0, cHide: !0, c: !1 })), setTimeout(() => { o(d => ({ ...d, eHide: !0, e: !1, d: !1, dHide: !0 })) }, 1200), e(lr([...t, `User-${r} can now pass the transaction ledger to other users for additional verification`, ,])) }, 1e3), () => { clearTimeout(u) } }, []), D.createElement("group", null, D.createElement("mesh", { scale: i.aHide ? 0 : 1, position: [.4, 3, 0], ref: l }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { scale: i.cHide ? 0 : 1, position: [.3, 3, 0], ref: s }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [.5, 3, 0], scale: i.eHide ? 0 : 1, ref: c }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [.5, 3, 0], scale: i.dHide ? 0 : 1, ref: a }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n }))) }, uQ = () => { const n = Lo(Ca, x1), e = oo(), { instructionMessage: t, verifierName: r } = mi(u => u.DoubleSpendingReducer), [i, o] = N.useState({ c: !0, b: !0, a: !0, e: !0, aHide: !1, eHide: !1, cHide: !1, bHide: !1 }), s = N.useRef(), a = N.useRef(), l = N.useRef(), c = N.useRef(); return rs(() => { i.a && (l.current.position.y += .03, l.current.position.x -= .03), i.c && (s.current.position.y += .03, s.current.position.x += .03), i.e && (a.current.position.y += .03), i.d && (cubeD.current.position.y += .03) }), N.useEffect(() => { let u; return u = setTimeout(() => { o(d => ({ ...d, a: !1, aHide: !0, cHide: !0, c: !1 })), setTimeout(() => { o(d => ({ ...d, bHide: !0, b: !1, e: !1, eHide: !0 })) }, 1700), e(lr([...t, `User-${r} can now pass the transaction ledger to other users for additional verification`])) }, 1800), () => { clearTimeout(u) } }, []), D.createElement("group", null, D.createElement("mesh", { scale: i.aHide ? 0 : 1, position: [.1, -3, 0], ref: l }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { scale: i.cHide ? 0 : 1, position: [.3, -3, 0], ref: s }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [.5, -3, 0], scale: i.bHide ? 0 : 1, ref: c }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [.5, -3, 0], scale: i.eHide ? 0 : 1, ref: a }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n }))) }, fQ = () => { const n = Lo(Ca, x1); oo(), mi(a => a.DoubleSpendingReducer); const [e, t] = N.useState({ d: !0, e: !0, b: !0, a: !0, aHide: !1, eHide: !1, dHide: !1, bHide: !1 }), r = N.useRef(), i = N.useRef(), o = N.useRef(), s = N.useRef(); return rs(() => { e.b && (s.current.position.y += .03, s.current.position.x -= .03), e.d && (r.current.position.y -= .03, r.current.position.x -= .03), e.e && (i.current.position.x -= .03), e.a && (o.current.position.x -= .03) }), N.useEffect(() => { let a; return a = setTimeout(() => { t(d => ({ ...d, d: !1, dHide: !0, bHide: !0, b: !1 })), setTimeout(() => { t(d => ({ ...d, aHide: !0, a: !1, e: !1, eHide: !0 })) }, 1800), l(lr([...c, `User-${u} can now pass the transaction ledger to other users for additional verification`])); const l = oo(), { instructionMessage: c, verifierName: u } = mi(d => d.DoubleSpendingReducer) }, 1800), () => { clearTimeout(a) } }, []), D.createElement("group", null, D.createElement("mesh", { scale: e.bHide ? 0 : 1, position: [4, 0, 0], ref: s }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { scale: e.dHide ? 0 : 1, position: [3.7, 0, 0], ref: r }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [3.7, 0, 0], scale: e.aHide ? 0 : 1, ref: o }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n })), D.createElement("mesh", { position: [3.7, 0, 0], scale: e.eHide ? 0 : 1, ref: i }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: n }))) }, dQ = () => { const n = oo(), { instructionMessage: e, verifierName: t } = mi(u => u.DoubleSpendingReducer), [r, i] = N.useState({ d: !0, c: !0, b: !0, a: !0, aHide: !1, cHide: !1, dHide: !1, bHide: !1 }), o = N.useRef(), s = N.useRef(), a = N.useRef(), l = N.useRef(), c = Lo(Ca, x1); return rs(() => { r.b && (l.current.position.y += .03), r.d && (o.current.position.y -= .03), r.c && (s.current.position.x -= .03), r.a && (a.current.position.x += .03) }), N.useEffect(() => { let u; return u = setTimeout(() => { i(d => ({ ...d, d: !1, dHide: !0, bHide: !0, b: !1 })), setTimeout(() => { i(d => ({ ...d, aHide: !0, a: !1, c: !1, cHide: !0 })) }, 100), n(lr([...e, `User-${t} can now pass the transaction ledger to other users for additional verification`])) }, 1800), () => { clearTimeout(u) } }, []), D.createElement("group", null, D.createElement("mesh", { scale: r.bHide ? 0 : 1, position: [.5, 0, 0], ref: l }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: c })), D.createElement("mesh", { scale: r.dHide ? 0 : 1, position: [.5, 0, 0], ref: o }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: c })), D.createElement("mesh", { position: [.5, 0, 0], scale: r.aHide ? 0 : 1, ref: a }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: c })), D.createElement("mesh", { position: [.5, 0, 0], scale: r.cHide ? 0 : 1, ref: s }, D.createElement("boxGeometry", { args: [.5, .2, .5] }), D.createElement("meshBasicMaterial", { map: c }))) }, hQ = () => { const n = N.useRef(), e = N.useRef(), t = N.useRef(), r = N.useRef(), i = N.useRef(), o = Lo(Ca, Hj), { receiverName: s, receiverAmt: a, selectedColor: l, verifierName: c, showLedgerAnimation: u } = mi(v => v.DoubleSpendingReducer), { sender: d, receiver: p, verifier: m } = l; return rs(() => { n.current.rotation.y += .03, e.current.rotation.y += .03, t.current.rotation.y += .03, r.current.rotation.y += .03, i.current.rotation.y += .03 }), D.createElement("group", null, D.createElement("group", null, D.createElement("group", { position: [-1, 0, 0] }, D.createElement("mesh", { position: [-2, 0, 0] }, D.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }), D.createElement("meshBasicMaterial", { color: d, transparent: !0, opacity: .3 })), D.createElement("mesh", { ref: n, position: [-2, 0, 0] }, D.createElement("boxGeometry", { args: [.8, .8, .8] }), D.createElement("meshBasicMaterial", { map: o })), D.createElement(_n, { scale: .3, position: [-3.2, 0, 0] }, "A")), D.createElement("group", { position: [0, 1, 0] }, D.createElement("mesh", { position: [.5, 2, 0] }, D.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }), D.createElement("meshBasicMaterial", { color: c === "B" ? m : s === "B" ? p : "#ddddff", transparent: !0, opacity: .2 })), D.createElement("mesh", { ref: e, position: [.5, 2, 0] }, D.createElement("boxGeometry", { args: [.8, .8, .8] }), D.createElement("meshBasicMaterial", { map: o })), D.createElement(_n, { scale: .3, position: [.5, 3, 0] }, "B")), D.createElement("group", { position: [1, 0, 0] }, D.createElement("mesh", { position: [3, 0, 0] }, D.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }), D.createElement("meshBasicMaterial", { color: c === "C" ? m : s === "C" ? p : "#ddddff", transparent: !0, opacity: .3 })), D.createElement("mesh", { ref: t, position: [3, 0, 0] }, D.createElement("boxGeometry", { args: [.8, .8, .8] }), D.createElement("meshBasicMaterial", { map: o })), D.createElement(_n, { scale: .3, position: [4.2, 0, 0] }, "C")), D.createElement("group", { position: [0, -1, 0] }, D.createElement("mesh", { position: [.5, -2, 0] }, D.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }), D.createElement("meshBasicMaterial", { color: c === "D" ? m : s === "D" ? p : "#ddddff", transparent: !0, opacity: .3 })), D.createElement("mesh", { ref: r, position: [.5, -2, 0] }, D.createElement("boxGeometry", { args: [.8, .8, .8] }), D.createElement("meshBasicMaterial", { map: o })), D.createElement(_n, { scale: .3, position: [.5, -3.3, 0] }, "D")), D.createElement("group", null, D.createElement("mesh", { position: [.5, 0, 0] }, D.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }), D.createElement("meshBasicMaterial", { color: c === "E" ? m : s === "E" ? p : "#ddddff", transparent: !0, opacity: .3 })), D.createElement("mesh", { ref: i, position: [.5, 0, 0] }, D.createElement("boxGeometry", { args: [.8, .8, .8] }), D.createElement("meshBasicMaterial", { map: o })), D.createElement(_n, { scale: .3, position: [.7, 1, 0] }, "E"))), D.createElement("group", null, D.createElement(Ka, { points: [[.5, 2.2, 0], [.5, .8, 0]], lineWidth: 5, color: "#034179" }), D.createElement(Ka, { points: [[.5, -2.2, 0], [.5, .8, 0]], lineWidth: 5, color: "#034179" }), D.createElement(Ka, { points: [[1.3, 3, 0], [3.9, .8, 0]], lineWidth: 5, color: "#034179" }), D.createElement("group", null, D.createElement(Ka, { points: [[-.3, 3, 0], [-3, .8, 0]], lineWidth: 5, color: s === "B" ? d : "#034179", opacity: .5 }), s === "B" && D.createElement(_n, { color: "yellow", position: [-2, 2, 0], rotation: [0, 0, 6.95], scale: .23 }, "sending ", a, "Rs")), D.createElement("group", null, D.createElement(Ka, { points: [[-3, -.8, 0], [-.3, -3, 0]], lineWidth: 5, color: s === "D" ? d : "#034179" }), s === "D" && D.createElement(_n, { color: "yellow", position: [-2, -2, 0], rotation: [0, 0, -6.95], scale: .23 }, "sending ", a, "Rs")), D.createElement(Ka, { points: [[4, -.8, 0], [1.3, -3, 0]], lineWidth: 5, color: "#034179" }), D.createElement("group", null, s === "E" && D.createElement(_n, { color: "yellow", position: [-1.2, .5, 0], rotation: [0, 0, 0], scale: .23 }, "sending ", a, "Rs"), D.createElement(Ka, { points: [[-2.23, 0, 0], [-.3, -0, 0]], lineWidth: 5, color: s === "C" || s === "E" ? d : "#034179" })), D.createElement("group", null, D.createElement(Ka, { points: [[1.3, 0, 0], [3.25, -0, 0]], lineWidth: 5, color: s === "C" ? d : "#034179" }), s === "C" && D.createElement(_n, { color: "yellow", position: [2.2, .5, 0], rotation: [0, 0, 0], scale: .23 }, "sending ", a, "Rs")), D.createElement("group", null, u && c === "B" && D.createElement(cQ, null), u && c === "D" && D.createElement(uQ, null), u && c === "C" && D.createElement(fQ, null), u && c === "E" && D.createElement(dQ, null)))) }; function Zx(n) { const { nodes: e, materials: t } = Ns("images/server.glb"); return D.createElement("group", { scale: .7, ...n, dispose: null }, D.createElement("group", { position: [2.089, 0, -5], rotation: [-Math.PI / 2, 0, 0] }, D.createElement("group", { rotation: [Math.PI / 2, 0, 0], scale: .01 }, D.createElement("group", { position: [-233.279, 69.331, 371.805], rotation: [-Math.PI / 2, 0, -3.124], scale: 100 }, D.createElement("mesh", { geometry: e.Server_2_shell_alu_power_bank_0.geometry, material: t.alu_power_bank }), D.createElement("mesh", { geometry: e.Server_2_shell_alu_0.geometry, material: t.material }), D.createElement("mesh", { geometry: e.Server_2_shell_blinky_0.geometry, material: t.blinky }), D.createElement("mesh", { geometry: e.Server_2_shell_Blue_blinky_light_0.geometry, material: t.Blue_blinky_light }), D.createElement("mesh", { geometry: e.Server_2_shell_hdd_base_0.geometry, material: t.hdd_base }), D.createElement("mesh", { geometry: e.Server_2_shell_Hdd_case_sliver_0.geometry, material: t.Hdd_case_sliver }), D.createElement("mesh", { geometry: e.Server_2_shell_Hdd_Dock_0.geometry, material: t.Hdd_Dock }), D.createElement("mesh", { geometry: e.Server_2_shell_Material010_0.geometry, material: t["Material.010"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material012_0.geometry, material: t["Material.012"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material013_0.geometry, material: t["Material.013"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material015_0.geometry, material: t["Material.015"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material016_0.geometry, material: t["Material.016"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material017_0.geometry, material: t["Material.017"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material018_0.geometry, material: t["Material.018"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material020_0.geometry, material: t["Material.020"] }), D.createElement("mesh", { geometry: e.Server_2_shell_Material026_0.geometry, material: t["Material.026"] }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_green001_0.geometry, material: t["progress_bar_green.001"] }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_green002_0.geometry, material: t["progress_bar_green.002"] }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_green004_0.geometry, material: t["progress_bar_green.004"] }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_green_0.geometry, material: t.progress_bar_green }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_red_blinky_0.geometry, material: t.progress_bar_red_blinky }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_red_0.geometry, material: t.progress_bar_red }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_yellow001_0.geometry, material: t["progress_bar_yellow.001"] }), D.createElement("mesh", { geometry: e.Server_2_shell_progress_bar_yellow_0.geometry, material: t.progress_bar_yellow }), D.createElement("mesh", { geometry: e.Server_2_shell_server_computer001_0.geometry, material: t["server_computer.001"] }), D.createElement("mesh", { geometry: e.Server_2_shell_server_computer002_0.geometry, material: t["server_computer.002"] }), D.createElement("mesh", { geometry: e.Server_2_shell_server_computer_0.geometry, material: t.server_computer }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images__7_0"].geometry, material: t["server-images__7"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images__8_0"].geometry, material: t["server-images__8"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images__9_0"].geometry, material: t["server-images__9"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images_2_0"].geometry, material: t["server-images_2"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images_3_0"].geometry, material: t["server-images_3"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images_4_0"].geometry, material: t["server-images_4"] }), D.createElement("mesh", { geometry: e["Server_2_shell_server-images_5_0"].geometry, material: t["server-images_5"] }))))) } Ns.preload("images/server.glb"); const qx = ({ position: n }) => D.createElement("mesh", { position: n }, D.createElement("boxGeometry", { args: [.2, .2, .2] }), D.createElement("meshStandardMaterial", { emissive: "yellow" })); function pQ() {
	const { receiverName: n, receiverAmt: e, instructionMessage: t, isAnimating: r, showGlowCube: i, animationProgress: o, waiting: s, task: a, userBalance: l, request: c, isRestart: u } = mi(v => v.DoubleSpendingReducer), d = oo(), p = N.useRef(); function m(v, y, _) { console.log(v); const g = v + y / _; return g >= 1 ? (d(tQ()), d(Kw(!0)), 1) : g } return rs((v, y) => { if (console.log(c), r) { const g = m(o, y, 2.7); d(nQ(g)), c === "return" ? p.current.position.x -= y * 2 : p.current.position.x += y * 2 } }), N.useEffect(() => { let v; return s && (d(lr([...t, "Once Ram sends the money, it is received by the bank, which then initiates the  of the transaction."])), d(nB(1)), v = setTimeout(() => { d(kv()), d(nB(2)) }, 2e3)), () => { clearTimeout(v) } }, [s]), N.useEffect(() => {
		a === 2 && d(lr([...t, `
          In this process, the bank will disburse the funds to ${n} before the transaction is considered finalized.`, "By pressing the cancel button, you can detect instances of double spending occurring in a centralized database."]))
	}, [a]), N.useEffect(() => {
		let v; return c === "cancel" && (p.current.position.x = -1, p.current.position.y = 1.9, p.current.position.z = -1.5, d(lr([...t, `Ram has contacted the bank with a request to revoke or void the Demand Draft (DD) transaction that was originally intended for ${n}.`])), v = setTimeout(() => { d(LU("return")), d(kv()) }, 4e3)), c === "return" && d(lr([...t, `Despite the bank returning ${l} rupees to Ram, it failed to deduct the same amount from ${n}'s account.`, `
    In this scenario, both Ram and ${n} now possess ${l} rupees each, while the bank's ledger appears to be missing ${l} rupees, creating a discrepancy in the bank's records.`])), () => { clearTimeout(v) }
	}, [c]), D.createElement("group", { position: [0, -.5, 0] }, D.createElement("group", { scale: i ? 1 : 0, ref: p, rotation: [0, 6.2, 0], position: [-1, 1.9, -1.5] }, D.createElement(_n, { strokeColor: "white", position: [-4.7, .5, 0], fontSize: .2, scale: i ? 1 : 0, strokeWidth: 10 }, c === "cancel" ? "Cancel Request" : `${e} Rs`), D.createElement(qx, { position: [-5, 0, 0] }), D.createElement(qx, { position: [-4.7, 0, 0] }), D.createElement(qx, { position: [-4.4, 0, 0] })), D.createElement("group", { position: [0, 0, -.5] }, D.createElement("group", { position: [-1, -.1, 0] }, D.createElement(Zx, { position: [2, 0, 0] }), D.createElement(Zx, { position: [1, 0, 0] }), D.createElement(Zx, { position: [0, 0, 0] })), D.createElement(_n, { strokeColor: "white", position: [-.1, 4, -2.5], fontSize: .2, scale: 1.5, strokeWidth: 10 }, "Conventional Transaction"), D.createElement("mesh", null, D.createElement("spotLight", { intensity: 500, angle: .7, position: [0, -3, 0], color: s ? "red" : "white" }))))
} function mQ(n) { const e = N.useRef(), { nodes: t, materials: r, animations: i } = Ns("images/user1.glb"), { actions: o, names: s } = kj(i, e); return N.useEffect(() => { o[s[0]].reset().fadeIn(.5).play() }, []), D.createElement("group", { scale: 1.3, ref: e, ...n, dispose: null }, D.createElement("group", { position: [.35, .1, .55], rotation: [0, 3, 0], name: "Scene" }, D.createElement("group", { name: "Sketchfab_model", rotation: [-Math.PI / 2, 0, 0] }, D.createElement("group", { name: "fe4cac43b7ae44b39c27b8d450c38bb6fbx", rotation: [Math.PI / 2.5, 0, 0] }, D.createElement("group", { name: "RootNode" }, D.createElement("group", { name: "Bank_Asset" })))), D.createElement("group", { name: "Armature001", rotation: [Math.PI / 2, 0, 0], scale: .01 }, D.createElement("primitive", { object: t.mixamorig7Hips }), D.createElement("skinnedMesh", { name: "Ch33_Belt001", geometry: t.Ch33_Belt001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Belt001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Body001", geometry: t.Ch33_Body001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Body001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Eyelashes001", geometry: t.Ch33_Eyelashes001.geometry, material: r["Ch33_hair.001"], skeleton: t.Ch33_Eyelashes001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Hair001", geometry: t.Ch33_Hair001.geometry, material: r["Ch33_hair.001"], skeleton: t.Ch33_Hair001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Pants001", geometry: t.Ch33_Pants001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Pants001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Shirt001", geometry: t.Ch33_Shirt001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Shirt001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Shoes001", geometry: t.Ch33_Shoes001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Shoes001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Suit001", geometry: t.Ch33_Suit001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Suit001.skeleton }), D.createElement("skinnedMesh", { name: "Ch33_Tie001", geometry: t.Ch33_Tie001.geometry, material: r["Ch33_body.001"], skeleton: t.Ch33_Tie001.skeleton })))) } Ns.preload("images/user1.glb"); function gQ(n) { const { nodes: e, materials: t } = Ns("images/Office.glb"); return D.createElement("group", { ...n, dispose: null }, D.createElement("group", { position: [.27, .942, 0], rotation: [-Math.PI / 2, 0, 0], scale: .006 }, D.createElement("group", { rotation: [Math.PI / 2, 0, 0] }, D.createElement("group", { position: [47.82, -.996, 69.998], rotation: [-Math.PI / 2, 0, 1.658], scale: .21 }, D.createElement("mesh", { geometry: e["Box001_01_-_Default_0"].geometry, material: t["01_-_Default"], position: [274.495, -24.015, 0] }), D.createElement("mesh", { geometry: e["Box001_02_-_Default_0"].geometry, material: t["02_-_Default_1"] }), D.createElement("mesh", { geometry: e["Box001_03_-_Default_0"].geometry, material: t["03_-_Default_0"] }), D.createElement("mesh", { geometry: e["Box001_07_-_Default_0"].geometry, material: t["07_-_Default_0"] }), D.createElement("mesh", { geometry: e["Box001_07_-_Default_0001"].geometry, material: t["07_-_Default_1"] }), D.createElement("mesh", { geometry: e["Box001_13_-_Default_0"].geometry, material: t["13_-_Default_0"] })), D.createElement("group", { position: [.184, 0, 65.626], rotation: [-Math.PI / 2, 0, 0] }, D.createElement("mesh", { geometry: e["Box005_14_-_Default_0"].geometry, material: t["14_-_Default"], position: [0, 57.727, 0] }), D.createElement("mesh", { geometry: e["Box005_15_-_Default_0"].geometry, material: t["15_-_Default"] })), D.createElement("group", { position: [5.839, -7.659, 7.98], rotation: [-Math.PI / 2, 0, 0], scale: [1, .627, .36] }, D.createElement("mesh", { geometry: e["Box006_07_-_Default_0"].geometry, material: t["07_-_Default_0"] }), D.createElement("mesh", { geometry: e["Box006_Material_#195_0"].geometry, material: t.Material_195 })), D.createElement("group", { position: [-9.657, 4.698, 65.836], rotation: [-Math.PI / 2, 0, 0] }, D.createElement("group", { position: [.019, 1.129, -124.145] }, D.createElement("mesh", { geometry: e["Box008_07_-_Default_0"].geometry, material: t["07_-_Default_0"], position: [0, 56.475, 0] }), D.createElement("mesh", { geometry: e["Box008_15_-_Default_0"].geometry, material: t["15_-_Default"], position: [0, 57.727, 0] }))), D.createElement("group", { position: n.cpuPos, rotation: [-Math.PI / 2, 0, 0], scale: [.699, .929, .674] }, D.createElement("mesh", { geometry: e["Box011_07_-_Default_0"].geometry, material: t["07_-_Default_0"] }), D.createElement("mesh", { geometry: e["Box011_20_-_Default_0"].geometry, material: t["20_-_Default"] }), D.createElement("mesh", { geometry: e["Box011_22_-_Default_0"].geometry, material: t["22_-_Default"] })), D.createElement("group", { position: [-138.019, 0, 999.622], rotation: [-Math.PI / 2, 0, 0] }, D.createElement("mesh", { geometry: e["Box015_21_-_Default_0"].geometry, material: t["21_-_Default"] }), D.createElement("mesh", { geometry: e["Box015_24_-_Default_0"].geometry, material: t["24_-_Default"] }), D.createElement("mesh", { geometry: e["Box015_Material_#299_0"].geometry, material: t.Material_299 }), D.createElement("mesh", { geometry: e["Box015_Material_#301_0"].geometry, material: t.Material_301 }), D.createElement("mesh", { geometry: e["Box015_Material_#304_0"].geometry, material: t.Material_304 })), D.createElement("group", { position: [139.8, 0, 27.333], rotation: [-Math.PI / 2, 0, 1.134] }, D.createElement("mesh", { geometry: e["Cylinder010_02_-_Default_0"].geometry, material: t["02_-_Default_0"] }), D.createElement("mesh", { geometry: e["Cylinder010_07_-_Default_0"].geometry, material: t["07_-_Default"] })), D.createElement("group", { position: [146.046, 33.129, 14.355], rotation: [0, -.436, Math.PI / 2], scale: [.674, .674, .896] }, D.createElement("mesh", { geometry: e["Cylinder012_02_-_Default_0"].geometry, material: t["02_-_Default_0"] }), D.createElement("mesh", { geometry: e["Cylinder012_Material_#26_0"].geometry, material: t.Material_26 })), D.createElement("group", { position: [-135.652, 0, 28.517], rotation: [-Math.PI / 2, 0, 2.007] }, D.createElement("mesh", { geometry: e["Cylinder016_02_-_Default_0"].geometry, material: t["02_-_Default_0"] }), D.createElement("mesh", { geometry: e["Cylinder016_07_-_Default_0"].geometry, material: t["07_-_Default"] })), D.createElement("group", { position: [-141.578, 33.129, 15.39], rotation: [0, .436, Math.PI / 2], scale: [.674, .674, .896] }, D.createElement("mesh", { geometry: e["Cylinder018_02_-_Default_0"].geometry, material: t["02_-_Default_0"] }), D.createElement("mesh", { geometry: e["Cylinder018_Material_#26_0"].geometry, material: t.Material_26 })), D.createElement("group", { position: [-213.999, -148.217, -26.102], rotation: [-Math.PI / 2, 0, 0], scale: [.365, .365, .621] }, D.createElement("mesh", { geometry: e["Cylinder020_10_-_Default_0"].geometry, material: t["10_-_Default"] }), D.createElement("mesh", { geometry: e["Cylinder020_11_-_Default_0"].geometry, material: t["11_-_Default"] })), D.createElement("mesh", { geometry: e["Box009_Material_#195_0"].geometry, material: t.Material_195, position: [197.282, -151.061, -4.408], rotation: [-Math.PI / 2, 0, 0], scale: [1, 1.191, 1] }), D.createElement("mesh", { geometry: e["Box010_Material_#195_0"].geometry, material: t.Material_195, position: [-185.543, -151.061, -4.408], rotation: [-Math.PI / 2, 0, 0], scale: [1, 1.191, 1] }), D.createElement("mesh", { geometry: e["Box012_05_-_Default_0"].geometry, material: t["05_-_Default"], position: [-218.607, -47.433, 11.084], rotation: [-Math.PI / 2, Math.PI / 2, 0], scale: [.517, 1, 1] }), D.createElement("mesh", { geometry: e["Box013_04_-_Default_0"].geometry, material: t["04_-_Default"], position: [-194.114, -47.433, 18.7], rotation: [-Math.PI / 2, Math.PI / 2, 0], scale: [.517, 1, 1] }), D.createElement("mesh", { geometry: e["Box014_05_-_Default_0"].geometry, material: t["05_-_Default"], position: [-162.355, -49.417, 9.475], rotation: [Math.PI / 2, 1.396, -Math.PI], scale: [.44, 1, .596] }), D.createElement("mesh", { geometry: e["Cylinder011_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [146.179, 0, 3.45], rotation: [-Math.PI / 2, 0, 1.134] }), D.createElement("mesh", { geometry: e["Cylinder014_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [141.583, 1.43, 35.627], rotation: [-Math.PI / 2, 0, 1.134], scale: [.57, .57, 1.222] }), D.createElement("mesh", { geometry: e["Cylinder015_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [132.381, 1.43, 31.335], rotation: [-Math.PI / 2, 0, 1.134], scale: [.57, .57, 1.222] }), D.createElement("mesh", { geometry: e["Cylinder017_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [-149.847, 0, 8.278], rotation: [-Math.PI / 2, 0, 2.007] }), D.createElement("mesh", { geometry: e["Cylinder019_Material_#263_0"].geometry, material: t.Material_263, position: [-213.633, -145.673, -25.923], rotation: [-Math.PI / 2, 0, 0] }), D.createElement("mesh", { geometry: e["Cylinder021_24_-_Default_0"].geometry, material: t["24_-_Default"], position: [-108.158, -150.898, -32.593], rotation: [-Math.PI / 2, 0, 0] }), D.createElement("mesh", { geometry: e["GeoSphere004_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [131.503, 33.12, 45.508], rotation: [-Math.PI / 2, 0, 1.134], scale: .92 }), D.createElement("mesh", { geometry: e["GeoSphere005_02_-_Default_0"].geometry, material: t["02_-_Default_0"], position: [-127.062, 33.12, 46.555], rotation: [-Math.PI / 2, 0, 2.007], scale: .92 }), D.createElement("mesh", { geometry: e["Plane001_Material_#413_0"].geometry, material: t.Material_413, position: [6.27, -151.247, 154.387], rotation: [-Math.PI / 2, 0, 0], scale: [.721, .807, .721] }))), D.createElement("group", { position: [0, 1.024, 0], rotation: [-Math.PI / 2, 0, 3.101], scale: .005 }, D.createElement("group", { rotation: [Math.PI / 2, 0, 0] }, D.createElement("group", { position: [2.684, -.125, 67.889], rotation: [-Math.PI / 2, 0, -Math.PI], scale: 100 }, D.createElement("mesh", { geometry: e.Base_Base_0.geometry, material: t.Base, position: [.58, -.19, -.148], rotation: [0, 0, .006] })), D.createElement("group", { position: [2.684, 83.159, 64.775], rotation: [-1.484, 0, -Math.PI], scale: 100 }, D.createElement("mesh", { geometry: e.Display_iMac_0.geometry, material: t.iMac, position: [.58, -.176, -.164], rotation: [0, -.001, .006] })), D.createElement("group", { position: [22.163, 1.566, -.477], rotation: [-1.58, 0, 3.139], scale: 100 }, D.createElement("mesh", { geometry: e.Keyboard_Keyboard_0.geometry, material: t.Keyboard, position: [.737, -.053, -.098] }))))) } Ns.preload("images/Office.glb"); const vQ = ({ cpuPos: n }) => D.createElement("group", null, D.createElement(gQ, { cpuPos: n })); Ns.preload("images/user2.glb"); function Yw() { const n = vU(Nw); return n[zw] || n } const yQ = n => { let e; return n < 1 ? e = 5.11916 * n ** 2 : e = 4.5 * Math.log(n + 1) + 2, (e / 100).toFixed(2) }, rB = yQ; function hE(n, e) { return hE = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, hE(n, e) } function OU(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, hE(n, e) } const iB = { disabled: !1 }, Nv = D.createContext(null); var _Q = function (e) { return e.scrollTop }, gh = "unmounted", hc = "exited", pc = "entering", Qu = "entered", pE = "exiting", Ra = function (n) { OU(e, n); function e(r, i) { var o; o = n.call(this, r, i) || this; var s = i, a = s && !s.isMounting ? r.enter : r.appear, l; return o.appearStatus = null, r.in ? a ? (l = hc, o.appearStatus = pc) : l = Qu : r.unmountOnExit || r.mountOnEnter ? l = gh : l = hc, o.state = { status: l }, o.nextCallback = null, o } e.getDerivedStateFromProps = function (i, o) { var s = i.in; return s && o.status === gh ? { status: hc } : null }; var t = e.prototype; return t.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, t.componentDidUpdate = function (i) { var o = null; if (i !== this.props) { var s = this.state.status; this.props.in ? s !== pc && s !== Qu && (o = pc) : (s === pc || s === Qu) && (o = pE) } this.updateStatus(!1, o) }, t.componentWillUnmount = function () { this.cancelNextCallback() }, t.getTimeouts = function () { var i = this.props.timeout, o, s, a; return o = s = a = i, i != null && typeof i != "number" && (o = i.exit, s = i.enter, a = i.appear !== void 0 ? i.appear : s), { exit: o, enter: s, appear: a } }, t.updateStatus = function (i, o) { if (i === void 0 && (i = !1), o !== null) if (this.cancelNextCallback(), o === pc) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var s = this.props.nodeRef ? this.props.nodeRef.current : dg.findDOMNode(this); s && _Q(s) } this.performEnter(i) } else this.performExit(); else this.props.unmountOnExit && this.state.status === hc && this.setState({ status: gh }) }, t.performEnter = function (i) { var o = this, s = this.props.enter, a = this.context ? this.context.isMounting : i, l = this.props.nodeRef ? [a] : [dg.findDOMNode(this), a], c = l[0], u = l[1], d = this.getTimeouts(), p = a ? d.appear : d.enter; if (!i && !s || iB.disabled) { this.safeSetState({ status: Qu }, function () { o.props.onEntered(c) }); return } this.props.onEnter(c, u), this.safeSetState({ status: pc }, function () { o.props.onEntering(c, u), o.onTransitionEnd(p, function () { o.safeSetState({ status: Qu }, function () { o.props.onEntered(c, u) }) }) }) }, t.performExit = function () { var i = this, o = this.props.exit, s = this.getTimeouts(), a = this.props.nodeRef ? void 0 : dg.findDOMNode(this); if (!o || iB.disabled) { this.safeSetState({ status: hc }, function () { i.props.onExited(a) }); return } this.props.onExit(a), this.safeSetState({ status: pE }, function () { i.props.onExiting(a), i.onTransitionEnd(s.exit, function () { i.safeSetState({ status: hc }, function () { i.props.onExited(a) }) }) }) }, t.cancelNextCallback = function () { this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null) }, t.safeSetState = function (i, o) { o = this.setNextCallback(o), this.setState(i, o) }, t.setNextCallback = function (i) { var o = this, s = !0; return this.nextCallback = function (a) { s && (s = !1, o.nextCallback = null, i(a)) }, this.nextCallback.cancel = function () { s = !1 }, this.nextCallback }, t.onTransitionEnd = function (i, o) { this.setNextCallback(o); var s = this.props.nodeRef ? this.props.nodeRef.current : dg.findDOMNode(this), a = i == null && !this.props.addEndListener; if (!s || a) { setTimeout(this.nextCallback, 0); return } if (this.props.addEndListener) { var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], c = l[0], u = l[1]; this.props.addEndListener(c, u) } i != null && setTimeout(this.nextCallback, i) }, t.render = function () { var i = this.state.status; if (i === gh) return null; var o = this.props, s = o.children; o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef; var a = Wt(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]); return D.createElement(Nv.Provider, { value: null }, typeof s == "function" ? s(i, a) : D.cloneElement(D.Children.only(s), a)) }, e }(D.Component); Ra.contextType = Nv; Ra.propTypes = {}; function Ku() { } Ra.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: Ku, onEntering: Ku, onEntered: Ku, onExit: Ku, onExiting: Ku, onExited: Ku }; Ra.UNMOUNTED = gh; Ra.EXITED = hc; Ra.ENTERING = pc; Ra.ENTERED = Qu; Ra.EXITING = pE; const xQ = Ra; function SQ(n) { if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return n } function $w(n, e) { var t = function (o) { return e && N.isValidElement(o) ? e(o) : o }, r = Object.create(null); return n && N.Children.map(n, function (i) { return i }).forEach(function (i) { r[i.key] = t(i) }), r } function AQ(n, e) { n = n || {}, e = e || {}; function t(u) { return u in e ? e[u] : n[u] } var r = Object.create(null), i = []; for (var o in n) o in e ? i.length && (r[o] = i, i = []) : i.push(o); var s, a = {}; for (var l in e) { if (r[l]) for (s = 0; s < r[l].length; s++) { var c = r[l][s]; a[r[l][s]] = t(c) } a[l] = t(l) } for (s = 0; s < i.length; s++)a[i[s]] = t(i[s]); return a } function bc(n, e, t) { return t[e] != null ? t[e] : n.props[e] } function EQ(n, e) { return $w(n.children, function (t) { return N.cloneElement(t, { onExited: e.bind(null, t), in: !0, appear: bc(t, "appear", n), enter: bc(t, "enter", n), exit: bc(t, "exit", n) }) }) } function MQ(n, e, t) { var r = $w(n.children), i = AQ(e, r); return Object.keys(i).forEach(function (o) { var s = i[o]; if (N.isValidElement(s)) { var a = o in e, l = o in r, c = e[o], u = N.isValidElement(c) && !c.props.in; l && (!a || u) ? i[o] = N.cloneElement(s, { onExited: t.bind(null, s), in: !0, exit: bc(s, "exit", n), enter: bc(s, "enter", n) }) : !l && a && !u ? i[o] = N.cloneElement(s, { in: !1 }) : l && a && N.isValidElement(c) && (i[o] = N.cloneElement(s, { onExited: t.bind(null, s), in: c.props.in, exit: bc(s, "exit", n), enter: bc(s, "enter", n) })) } }), i } var wQ = Object.values || function (n) { return Object.keys(n).map(function (e) { return n[e] }) }, bQ = { component: "div", childFactory: function (e) { return e } }, Qw = function (n) { OU(e, n); function e(r, i) { var o; o = n.call(this, r, i) || this; var s = o.handleExited.bind(SQ(o)); return o.state = { contextValue: { isMounting: !0 }, handleExited: s, firstRender: !0 }, o } var t = e.prototype; return t.componentDidMount = function () { this.mounted = !0, this.setState({ contextValue: { isMounting: !1 } }) }, t.componentWillUnmount = function () { this.mounted = !1 }, e.getDerivedStateFromProps = function (i, o) { var s = o.children, a = o.handleExited, l = o.firstRender; return { children: l ? EQ(i, a) : MQ(i, s, a), firstRender: !1 } }, t.handleExited = function (i, o) { var s = $w(this.props.children); i.key in s || (i.props.onExited && i.props.onExited(o), this.mounted && this.setState(function (a) { var l = Ee({}, a.children); return delete l[i.key], { children: l } })) }, t.render = function () { var i = this.props, o = i.component, s = i.childFactory, a = Wt(i, ["component", "childFactory"]), l = this.state.contextValue, c = wQ(this.state.children).map(s); return delete a.appear, delete a.enter, delete a.exit, o === null ? D.createElement(Nv.Provider, { value: l }, c) : D.createElement(Nv.Provider, { value: l }, D.createElement(o, a, c)) }, e }(D.Component); Qw.propTypes = {}; Qw.defaultProps = bQ; const CQ = Qw, TQ = n => n.scrollTop; function oB(n, e) { var t, r; const { timeout: i, easing: o, style: s = {} } = n; return { duration: (t = s.transitionDuration) != null ? t : typeof i == "number" ? i : i[e.mode] || 0, easing: (r = s.transitionTimingFunction) != null ? r : typeof o == "object" ? o[e.mode] : o, delay: s.transitionDelay } } function RQ(n) { return Ir("MuiPaper", n) } Lr("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]); const PQ = ["className", "component", "elevation", "square", "variant"], BQ = n => { const { square: e, elevation: t, variant: r, classes: i } = n, o = { root: ["root", r, !e && "rounded", r === "elevation" && `elevation${t}`] }; return ti(o, RQ, i) }, IQ = Zt("div", { name: "MuiPaper", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, e[t.variant], !t.square && e.rounded, t.variant === "elevation" && e[`elevation${t.elevation}`]] } })(({ theme: n, ownerState: e }) => { var t; return Ee({ backgroundColor: (n.vars || n).palette.background.paper, color: (n.vars || n).palette.text.primary, transition: n.transitions.create("box-shadow") }, !e.square && { borderRadius: n.shape.borderRadius }, e.variant === "outlined" && { border: `1px solid ${(n.vars || n).palette.divider}` }, e.variant === "elevation" && Ee({ boxShadow: (n.vars || n).shadows[e.elevation] }, !n.vars && n.palette.mode === "dark" && { backgroundImage: `linear-gradient(${Jo("#fff", rB(e.elevation))}, ${Jo("#fff", rB(e.elevation))})` }, n.vars && { backgroundImage: (t = n.vars.overlays) == null ? void 0 : t[e.elevation] })) }), LQ = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiPaper" }), { className: i, component: o = "div", elevation: s = 1, square: a = !1, variant: l = "elevation" } = r, c = Wt(r, PQ), u = Ee({}, r, { component: o, elevation: s, square: a, variant: l }), d = BQ(u); return st.jsx(IQ, Ee({ as: o, ownerState: u, className: rn(d.root, i), ref: t }, c)) }), Zw = LQ; function DQ(n) { const { className: e, classes: t, pulsate: r = !1, rippleX: i, rippleY: o, rippleSize: s, in: a, onExited: l, timeout: c } = n, [u, d] = N.useState(!1), p = rn(e, t.ripple, t.rippleVisible, r && t.ripplePulsate), m = { width: s, height: s, top: -(s / 2) + o, left: -(s / 2) + i }, v = rn(t.child, u && t.childLeaving, r && t.childPulsate); return !a && !u && d(!0), N.useEffect(() => { if (!a && l != null) { const y = setTimeout(l, c); return () => { clearTimeout(y) } } }, [l, a, c]), st.jsx("span", { className: p, style: m, children: st.jsx("span", { className: v }) }) } const OQ = Lr("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Eo = OQ, FQ = ["center", "classes", "className"]; let S1 = n => n, sB, aB, lB, cB; const mE = 550, UQ = 80, kQ = Bw(sB || (sB = S1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), NQ = Bw(aB || (aB = S1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), zQ = Bw(lB || (lB = S1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), GQ = Zt("span", { name: "MuiTouchRipple", slot: "Root" })({ overflow: "hidden", pointerEvents: "none", position: "absolute", zIndex: 0, top: 0, right: 0, bottom: 0, left: 0, borderRadius: "inherit" }), HQ = Zt(DQ, { name: "MuiTouchRipple", slot: "Ripple" })(cB || (cB = S1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Eo.rippleVisible, kQ, mE, ({ theme: n }) => n.transitions.easing.easeInOut, Eo.ripplePulsate, ({ theme: n }) => n.transitions.duration.shorter, Eo.child, Eo.childLeaving, NQ, mE, ({ theme: n }) => n.transitions.easing.easeInOut, Eo.childPulsate, zQ, ({ theme: n }) => n.transitions.easing.easeInOut), VQ = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiTouchRipple" }), { center: i = !1, classes: o = {}, className: s } = r, a = Wt(r, FQ), [l, c] = N.useState([]), u = N.useRef(0), d = N.useRef(null); N.useEffect(() => { d.current && (d.current(), d.current = null) }, [l]); const p = N.useRef(!1), m = N.useRef(0), v = N.useRef(null), y = N.useRef(null); N.useEffect(() => () => { m.current && clearTimeout(m.current) }, []); const _ = N.useCallback(E => { const { pulsate: w, rippleX: b, rippleY: T, rippleSize: B, cb: R } = E; c(P => [...P, st.jsx(HQ, { classes: { ripple: rn(o.ripple, Eo.ripple), rippleVisible: rn(o.rippleVisible, Eo.rippleVisible), ripplePulsate: rn(o.ripplePulsate, Eo.ripplePulsate), child: rn(o.child, Eo.child), childLeaving: rn(o.childLeaving, Eo.childLeaving), childPulsate: rn(o.childPulsate, Eo.childPulsate) }, timeout: mE, pulsate: w, rippleX: b, rippleY: T, rippleSize: B }, u.current)]), u.current += 1, d.current = R }, [o]), g = N.useCallback((E = {}, w = {}, b = () => { }) => { const { pulsate: T = !1, center: B = i || w.pulsate, fakeElement: R = !1 } = w; if ((E == null ? void 0 : E.type) === "mousedown" && p.current) { p.current = !1; return } (E == null ? void 0 : E.type) === "touchstart" && (p.current = !0); const P = R ? null : y.current, U = P ? P.getBoundingClientRect() : { width: 0, height: 0, left: 0, top: 0 }; let G, $, z; if (B || E === void 0 || E.clientX === 0 && E.clientY === 0 || !E.clientX && !E.touches) G = Math.round(U.width / 2), $ = Math.round(U.height / 2); else { const { clientX: j, clientY: q } = E.touches && E.touches.length > 0 ? E.touches[0] : E; G = Math.round(j - U.left), $ = Math.round(q - U.top) } if (B) z = Math.sqrt((2 * U.width ** 2 + U.height ** 2) / 3), z % 2 === 0 && (z += 1); else { const j = Math.max(Math.abs((P ? P.clientWidth : 0) - G), G) * 2 + 2, q = Math.max(Math.abs((P ? P.clientHeight : 0) - $), $) * 2 + 2; z = Math.sqrt(j ** 2 + q ** 2) } E != null && E.touches ? v.current === null && (v.current = () => { _({ pulsate: T, rippleX: G, rippleY: $, rippleSize: z, cb: b }) }, m.current = setTimeout(() => { v.current && (v.current(), v.current = null) }, UQ)) : _({ pulsate: T, rippleX: G, rippleY: $, rippleSize: z, cb: b }) }, [i, _]), x = N.useCallback(() => { g({}, { pulsate: !0 }) }, [g]), A = N.useCallback((E, w) => { if (clearTimeout(m.current), (E == null ? void 0 : E.type) === "touchend" && v.current) { v.current(), v.current = null, m.current = setTimeout(() => { A(E, w) }); return } v.current = null, c(b => b.length > 0 ? b.slice(1) : b), d.current = w }, []); return N.useImperativeHandle(t, () => ({ pulsate: x, start: g, stop: A }), [x, g, A]), st.jsx(GQ, Ee({ className: rn(Eo.root, o.root, s), ref: y }, a, { children: st.jsx(CQ, { component: null, exit: !0, children: l }) })) }), WQ = VQ; function jQ(n) { return Ir("MuiButtonBase", n) } const XQ = Lr("MuiButtonBase", ["root", "disabled", "focusVisible"]), JQ = XQ, KQ = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], YQ = n => { const { disabled: e, focusVisible: t, focusVisibleClassName: r, classes: i } = n, s = ti({ root: ["root", e && "disabled", t && "focusVisible"] }, jQ, i); return t && r && (s.root += ` ${r}`), s }, $Q = Zt("button", { name: "MuiButtonBase", slot: "Root", overridesResolver: (n, e) => e.root })({ display: "inline-flex", alignItems: "center", justifyContent: "center", position: "relative", boxSizing: "border-box", WebkitTapHighlightColor: "transparent", backgroundColor: "transparent", outline: 0, border: 0, margin: 0, borderRadius: 0, padding: 0, cursor: "pointer", userSelect: "none", verticalAlign: "middle", MozAppearance: "none", WebkitAppearance: "none", textDecoration: "none", color: "inherit", "&::-moz-focus-inner": { borderStyle: "none" }, [`&.${JQ.disabled}`]: { pointerEvents: "none", cursor: "default" }, "@media print": { colorAdjust: "exact" } }), QQ = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiButtonBase" }), { action: i, centerRipple: o = !1, children: s, className: a, component: l = "button", disabled: c = !1, disableRipple: u = !1, disableTouchRipple: d = !1, focusRipple: p = !1, LinkComponent: m = "a", onBlur: v, onClick: y, onContextMenu: _, onDragLeave: g, onFocus: x, onFocusVisible: A, onKeyDown: E, onKeyUp: w, onMouseDown: b, onMouseLeave: T, onMouseUp: B, onTouchEnd: R, onTouchMove: P, onTouchStart: U, tabIndex: G = 0, TouchRippleProps: $, touchRippleRef: z, type: j } = r, q = Wt(r, KQ), se = N.useRef(null), W = N.useRef(null), V = Sa(W, z), { isFocusVisibleRef: J, onFocus: O, onBlur: k, ref: Z } = $F(), [ee, ne] = N.useState(!1); c && ee && ne(!1), N.useImperativeHandle(i, () => ({ focusVisible: () => { ne(!0), se.current.focus() } }), []); const [K, ae] = N.useState(!1); N.useEffect(() => { ae(!0) }, []); const ie = K && !u && !c; N.useEffect(() => { ee && p && !u && K && W.current.pulsate() }, [u, p, ee, K]); function Se(be, ke, He = d) { return rl(je => (ke && ke(je), !He && W.current && W.current[be](je), !0)) } const Ce = Se("start", b), le = Se("stop", _), F = Se("stop", g), me = Se("stop", B), he = Se("stop", be => { ee && be.preventDefault(), T && T(be) }), ce = Se("start", U), fe = Se("stop", R), Re = Se("stop", P), de = Se("stop", be => { k(be), J.current === !1 && ne(!1), v && v(be) }, !1), Ie = rl(be => { se.current || (se.current = be.currentTarget), O(be), J.current === !0 && (ne(!0), A && A(be)), x && x(be) }), we = () => { const be = se.current; return l && l !== "button" && !(be.tagName === "A" && be.href) }, ge = N.useRef(!1), Ve = rl(be => { p && !ge.current && ee && W.current && be.key === " " && (ge.current = !0, W.current.stop(be, () => { W.current.start(be) })), be.target === be.currentTarget && we() && be.key === " " && be.preventDefault(), E && E(be), be.target === be.currentTarget && we() && be.key === "Enter" && !c && (be.preventDefault(), y && y(be)) }), H = rl(be => { p && be.key === " " && W.current && ee && !be.defaultPrevented && (ge.current = !1, W.current.stop(be, () => { W.current.pulsate(be) })), w && w(be), y && be.target === be.currentTarget && we() && be.key === " " && !be.defaultPrevented && y(be) }); let L = l; L === "button" && (q.href || q.to) && (L = m); const oe = {}; L === "button" ? (oe.type = j === void 0 ? "button" : j, oe.disabled = c) : (!q.href && !q.to && (oe.role = "button"), c && (oe["aria-disabled"] = c)); const Pe = Sa(t, Z, se), Ae = Ee({}, r, { centerRipple: o, component: l, disabled: c, disableRipple: u, disableTouchRipple: d, focusRipple: p, tabIndex: G, focusVisible: ee }), ye = YQ(Ae); return st.jsxs($Q, Ee({ as: L, className: rn(ye.root, a), ownerState: Ae, onBlur: de, onClick: y, onContextMenu: le, onFocus: Ie, onKeyDown: Ve, onKeyUp: H, onMouseDown: Ce, onMouseLeave: he, onMouseUp: me, onDragLeave: F, onTouchEnd: fe, onTouchMove: Re, onTouchStart: ce, ref: Pe, tabIndex: c ? -1 : G, type: j }, oe, q, { children: [s, ie ? st.jsx(WQ, Ee({ ref: V, center: o }, $)) : null] })) }), qw = QQ; function ZQ(n) { return Ir("MuiAlert", n) } const qQ = Lr("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]), uB = qQ; function eZ(n) { return Ir("MuiIconButton", n) } const tZ = Lr("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), nZ = tZ, rZ = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"], iZ = n => { const { classes: e, disabled: t, color: r, edge: i, size: o } = n, s = { root: ["root", t && "disabled", r !== "default" && `color${It(r)}`, i && `edge${It(i)}`, `size${It(o)}`] }; return ti(s, eZ, e) }, oZ = Zt(qw, { name: "MuiIconButton", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, t.color !== "default" && e[`color${It(t.color)}`], t.edge && e[`edge${It(t.edge)}`], e[`size${It(t.size)}`]] } })(({ theme: n, ownerState: e }) => Ee({ textAlign: "center", flex: "0 0 auto", fontSize: n.typography.pxToRem(24), padding: 8, borderRadius: "50%", overflow: "visible", color: (n.vars || n).palette.action.active, transition: n.transitions.create("background-color", { duration: n.transitions.duration.shortest }) }, !e.disableRipple && { "&:hover": { backgroundColor: n.vars ? `rgba(${n.vars.palette.action.activeChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(n.palette.action.active, n.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } } }, e.edge === "start" && { marginLeft: e.size === "small" ? -3 : -12 }, e.edge === "end" && { marginRight: e.size === "small" ? -3 : -12 }), ({ theme: n, ownerState: e }) => { var t; const r = (t = (n.vars || n).palette) == null ? void 0 : t[e.color]; return Ee({}, e.color === "inherit" && { color: "inherit" }, e.color !== "inherit" && e.color !== "default" && Ee({ color: r == null ? void 0 : r.main }, !e.disableRipple && { "&:hover": Ee({}, r && { backgroundColor: n.vars ? `rgba(${r.mainChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(r.main, n.palette.action.hoverOpacity) }, { "@media (hover: none)": { backgroundColor: "transparent" } }) }), e.size === "small" && { padding: 5, fontSize: n.typography.pxToRem(18) }, e.size === "large" && { padding: 12, fontSize: n.typography.pxToRem(28) }, { [`&.${nZ.disabled}`]: { backgroundColor: "transparent", color: (n.vars || n).palette.action.disabled } }) }), sZ = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiIconButton" }), { edge: i = !1, children: o, className: s, color: a = "default", disabled: l = !1, disableFocusRipple: c = !1, size: u = "medium" } = r, d = Wt(r, rZ), p = Ee({}, r, { edge: i, color: a, disabled: l, disableFocusRipple: c, size: u }), m = iZ(p); return st.jsx(oZ, Ee({ className: rn(m.root, s), centerRipple: !0, focusRipple: !c, disabled: l, ref: t, ownerState: p }, d, { children: o })) }), FU = sZ, aZ = Ta(st.jsx("path", { d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z" }), "SuccessOutlined"), lZ = Ta(st.jsx("path", { d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z" }), "ReportProblemOutlined"), cZ = Ta(st.jsx("path", { d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }), "ErrorOutline"), uZ = Ta(st.jsx("path", { d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z" }), "InfoOutlined"), fZ = Ta(st.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }), "Close"), dZ = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"], hZ = n => { const { variant: e, color: t, severity: r, classes: i } = n, o = { root: ["root", `${e}${It(t || r)}`, `${e}`], icon: ["icon"], message: ["message"], action: ["action"] }; return ti(o, ZQ, i) }, pZ = Zt(Zw, { name: "MuiAlert", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, e[t.variant], e[`${t.variant}${It(t.color || t.severity)}`]] } })(({ theme: n, ownerState: e }) => { const t = n.palette.mode === "light" ? Bv : Iv, r = n.palette.mode === "light" ? Iv : Bv, i = e.color || e.severity; return Ee({}, n.typography.body2, { backgroundColor: "transparent", display: "flex", padding: "6px 16px" }, i && e.variant === "standard" && { color: n.vars ? n.vars.palette.Alert[`${i}Color`] : t(n.palette[i].light, .6), backgroundColor: n.vars ? n.vars.palette.Alert[`${i}StandardBg`] : r(n.palette[i].light, .9), [`& .${uB.icon}`]: n.vars ? { color: n.vars.palette.Alert[`${i}IconColor`] } : { color: n.palette[i].main } }, i && e.variant === "outlined" && { color: n.vars ? n.vars.palette.Alert[`${i}Color`] : t(n.palette[i].light, .6), border: `1px solid ${(n.vars || n).palette[i].light}`, [`& .${uB.icon}`]: n.vars ? { color: n.vars.palette.Alert[`${i}IconColor`] } : { color: n.palette[i].main } }, i && e.variant === "filled" && Ee({ fontWeight: n.typography.fontWeightMedium }, n.vars ? { color: n.vars.palette.Alert[`${i}FilledColor`], backgroundColor: n.vars.palette.Alert[`${i}FilledBg`] } : { backgroundColor: n.palette.mode === "dark" ? n.palette[i].dark : n.palette[i].main, color: n.palette.getContrastText(n.palette[i].main) })) }), mZ = Zt("div", { name: "MuiAlert", slot: "Icon", overridesResolver: (n, e) => e.icon })({ marginRight: 12, padding: "7px 0", display: "flex", fontSize: 22, opacity: .9 }), gZ = Zt("div", { name: "MuiAlert", slot: "Message", overridesResolver: (n, e) => e.message })({ padding: "8px 0", minWidth: 0, overflow: "auto" }), fB = Zt("div", { name: "MuiAlert", slot: "Action", overridesResolver: (n, e) => e.action })({ display: "flex", alignItems: "flex-start", padding: "4px 0 0 16px", marginLeft: "auto", marginRight: -8 }), dB = { success: st.jsx(aZ, { fontSize: "inherit" }), warning: st.jsx(lZ, { fontSize: "inherit" }), error: st.jsx(cZ, { fontSize: "inherit" }), info: st.jsx(uZ, { fontSize: "inherit" }) }, vZ = N.forwardRef(function (e, t) { var r, i, o, s, a, l; const c = ni({ props: e, name: "MuiAlert" }), { action: u, children: d, className: p, closeText: m = "Close", color: v, components: y = {}, componentsProps: _ = {}, icon: g, iconMapping: x = dB, onClose: A, role: E = "alert", severity: w = "success", slotProps: b = {}, slots: T = {}, variant: B = "standard" } = c, R = Wt(c, dZ), P = Ee({}, c, { color: v, severity: w, variant: B }), U = hZ(P), G = (r = (i = T.closeButton) != null ? i : y.CloseButton) != null ? r : FU, $ = (o = (s = T.closeIcon) != null ? s : y.CloseIcon) != null ? o : fZ, z = (a = b.closeButton) != null ? a : _.closeButton, j = (l = b.closeIcon) != null ? l : _.closeIcon; return st.jsxs(pZ, Ee({ role: E, elevation: 0, ownerState: P, className: rn(U.root, p), ref: t }, R, { children: [g !== !1 ? st.jsx(mZ, { ownerState: P, className: U.icon, children: g || x[w] || dB[w] }) : null, st.jsx(gZ, { ownerState: P, className: U.message, children: d }), u != null ? st.jsx(fB, { ownerState: P, className: U.action, children: u }) : null, u == null && A ? st.jsx(fB, { ownerState: P, className: U.action, children: st.jsx(G, Ee({ size: "small", "aria-label": m, title: m, color: "inherit", onClick: A }, z, { children: st.jsx($, Ee({ fontSize: "small" }, j)) })) }) : null] })) }), yZ = vZ; function _Z(n) { return Ir("MuiTypography", n) } Lr("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]); const xZ = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"], SZ = n => { const { align: e, gutterBottom: t, noWrap: r, paragraph: i, variant: o, classes: s } = n, a = { root: ["root", o, n.align !== "inherit" && `align${It(e)}`, t && "gutterBottom", r && "noWrap", i && "paragraph"] }; return ti(a, _Z, s) }, AZ = Zt("span", { name: "MuiTypography", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, t.variant && e[t.variant], t.align !== "inherit" && e[`align${It(t.align)}`], t.noWrap && e.noWrap, t.gutterBottom && e.gutterBottom, t.paragraph && e.paragraph] } })(({ theme: n, ownerState: e }) => Ee({ margin: 0 }, e.variant === "inherit" && { font: "inherit" }, e.variant !== "inherit" && n.typography[e.variant], e.align !== "inherit" && { textAlign: e.align }, e.noWrap && { overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, e.gutterBottom && { marginBottom: "0.35em" }, e.paragraph && { marginBottom: 16 })), hB = { h1: "h1", h2: "h2", h3: "h3", h4: "h4", h5: "h5", h6: "h6", subtitle1: "h6", subtitle2: "h6", body1: "p", body2: "p", inherit: "p" }, EZ = { primary: "primary.main", textPrimary: "text.primary", secondary: "secondary.main", textSecondary: "text.secondary", error: "error.main" }, MZ = n => EZ[n] || n, wZ = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiTypography" }), i = MZ(r.color), o = qK(Ee({}, r, { color: i })), { align: s = "inherit", className: a, component: l, gutterBottom: c = !1, noWrap: u = !1, paragraph: d = !1, variant: p = "body1", variantMapping: m = hB } = o, v = Wt(o, xZ), y = Ee({}, o, { align: s, color: i, className: a, component: l, gutterBottom: c, noWrap: u, paragraph: d, variant: p, variantMapping: m }), _ = l || (d ? "p" : m[p] || hB[p]) || "span", g = SZ(y); return st.jsx(AZ, Ee({ as: _, ref: t, ownerState: y, className: rn(g.root, a) }, v)) }), gf = wZ; function bZ(n) { return typeof n == "string" } function vh(n, e, t) { return n === void 0 || bZ(n) ? e : Ee({}, e, { ownerState: Ee({}, e.ownerState, t) }) } const CZ = { disableDefaultClasses: !1 }, TZ = N.createContext(CZ); function RZ(n) { const { disableDefaultClasses: e } = N.useContext(TZ); return t => e ? "" : n(t) } function gE(n, e = []) { if (n === void 0) return {}; const t = {}; return Object.keys(n).filter(r => r.match(/^on[A-Z]/) && typeof n[r] == "function" && !e.includes(r)).forEach(r => { t[r] = n[r] }), t } function PZ(n, e, t) { return typeof n == "function" ? n(e, t) : n } function pB(n) { if (n === void 0) return {}; const e = {}; return Object.keys(n).filter(t => !(t.match(/^on[A-Z]/) && typeof n[t] == "function")).forEach(t => { e[t] = n[t] }), e } function BZ(n) { const { getSlotProps: e, additionalProps: t, externalSlotProps: r, externalForwardedProps: i, className: o } = n; if (!e) { const m = rn(t == null ? void 0 : t.className, o, i == null ? void 0 : i.className, r == null ? void 0 : r.className), v = Ee({}, t == null ? void 0 : t.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style), y = Ee({}, t, i, r); return m.length > 0 && (y.className = m), Object.keys(v).length > 0 && (y.style = v), { props: y, internalRef: void 0 } } const s = gE(Ee({}, i, r)), a = pB(r), l = pB(i), c = e(s), u = rn(c == null ? void 0 : c.className, t == null ? void 0 : t.className, o, i == null ? void 0 : i.className, r == null ? void 0 : r.className), d = Ee({}, c == null ? void 0 : c.style, t == null ? void 0 : t.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style), p = Ee({}, c, t, l, a); return u.length > 0 && (p.className = u), Object.keys(d).length > 0 && (p.style = d), { props: p, internalRef: c.ref } } const IZ = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"]; function UU(n) { var e; const { elementType: t, externalSlotProps: r, ownerState: i, skipResolvingSlotProps: o = !1 } = n, s = Wt(n, IZ), a = o ? {} : PZ(r, i), { props: l, internalRef: c } = BZ(Ee({}, s, { externalSlotProps: a })), u = Sa(c, a == null ? void 0 : a.ref, (e = n.additionalProps) == null ? void 0 : e.ref); return vh(t, Ee({}, l, { ref: u }), i) } function mB(n) { return n.substring(2).toLowerCase() } function LZ(n, e) { return e.documentElement.clientWidth < n.clientX || e.documentElement.clientHeight < n.clientY } function DZ(n) { const { children: e, disableReactTree: t = !1, mouseEvent: r = "onClick", onClickAway: i, touchEvent: o = "onTouchEnd" } = n, s = N.useRef(!1), a = N.useRef(null), l = N.useRef(!1), c = N.useRef(!1); N.useEffect(() => (setTimeout(() => { l.current = !0 }, 0), () => { l.current = !1 }), []); const u = Sa(e.ref, a), d = rl(v => { const y = c.current; c.current = !1; const _ = Dh(a.current); if (!l.current || !a.current || "clientX" in v && LZ(v, _)) return; if (s.current) { s.current = !1; return } let g; v.composedPath ? g = v.composedPath().indexOf(a.current) > -1 : g = !_.documentElement.contains(v.target) || a.current.contains(v.target), !g && (t || !y) && i(v) }), p = v => y => { c.current = !0; const _ = e.props[v]; _ && _(y) }, m = { ref: u }; return o !== !1 && (m[o] = p(o)), N.useEffect(() => { if (o !== !1) { const v = mB(o), y = Dh(a.current), _ = () => { s.current = !0 }; return y.addEventListener(v, d), y.addEventListener("touchmove", _), () => { y.removeEventListener(v, d), y.removeEventListener("touchmove", _) } } }, [d, o]), r !== !1 && (m[r] = p(r)), N.useEffect(() => { if (r !== !1) { const v = mB(r), y = Dh(a.current); return y.addEventListener(v, d), () => { y.removeEventListener(v, d) } } }, [d, r]), st.jsx(N.Fragment, { children: N.cloneElement(e, m) }) } var Oi = "top", Bo = "bottom", Io = "right", Fi = "left", eb = "auto", tm = [Oi, Bo, Io, Fi], Qf = "start", bp = "end", OZ = "clippingParents", kU = "viewport", ah = "popper", FZ = "reference", gB = tm.reduce(function (n, e) { return n.concat([e + "-" + Qf, e + "-" + bp]) }, []), NU = [].concat(tm, [eb]).reduce(function (n, e) { return n.concat([e, e + "-" + Qf, e + "-" + bp]) }, []), UZ = "beforeRead", kZ = "read", NZ = "afterRead", zZ = "beforeMain", GZ = "main", HZ = "afterMain", VZ = "beforeWrite", WZ = "write", jZ = "afterWrite", XZ = [UZ, kZ, NZ, zZ, GZ, HZ, VZ, WZ, jZ]; function Fs(n) { return n ? (n.nodeName || "").toLowerCase() : null } function ao(n) { if (n == null) return window; if (n.toString() !== "[object Window]") { var e = n.ownerDocument; return e && e.defaultView || window } return n } function Kc(n) { var e = ao(n).Element; return n instanceof e || n instanceof Element } function To(n) { var e = ao(n).HTMLElement; return n instanceof e || n instanceof HTMLElement } function tb(n) { if (typeof ShadowRoot > "u") return !1; var e = ao(n).ShadowRoot; return n instanceof e || n instanceof ShadowRoot } function JZ(n) { var e = n.state; Object.keys(e.elements).forEach(function (t) { var r = e.styles[t] || {}, i = e.attributes[t] || {}, o = e.elements[t]; !To(o) || !Fs(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function (s) { var a = i[s]; a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a) })) }) } function KZ(n) { var e = n.state, t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function () { Object.keys(e.elements).forEach(function (r) { var i = e.elements[r], o = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), a = s.reduce(function (l, c) { return l[c] = "", l }, {}); !To(i) || !Fs(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function (l) { i.removeAttribute(l) })) }) } } const YZ = { name: "applyStyles", enabled: !0, phase: "write", fn: JZ, effect: KZ, requires: ["computeStyles"] }; function Ls(n) { return n.split("-")[0] } var Oc = Math.max, zv = Math.min, Zf = Math.round; function vE() { var n = navigator.userAgentData; return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function (e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function zU() { return !/^((?!chrome|android).)*safari/i.test(vE()) } function qf(n, e, t) { e === void 0 && (e = !1), t === void 0 && (t = !1); var r = n.getBoundingClientRect(), i = 1, o = 1; e && To(n) && (i = n.offsetWidth > 0 && Zf(r.width) / n.offsetWidth || 1, o = n.offsetHeight > 0 && Zf(r.height) / n.offsetHeight || 1); var s = Kc(n) ? ao(n) : window, a = s.visualViewport, l = !zU() && t, c = (r.left + (l && a ? a.offsetLeft : 0)) / i, u = (r.top + (l && a ? a.offsetTop : 0)) / o, d = r.width / i, p = r.height / o; return { width: d, height: p, top: u, right: c + d, bottom: u + p, left: c, x: c, y: u } } function nb(n) { var e = qf(n), t = n.offsetWidth, r = n.offsetHeight; return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: r } } function GU(n, e) { var t = e.getRootNode && e.getRootNode(); if (n.contains(e)) return !0; if (t && tb(t)) { var r = e; do { if (r && n.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function Ma(n) { return ao(n).getComputedStyle(n) } function $Z(n) { return ["table", "td", "th"].indexOf(Fs(n)) >= 0 } function Il(n) { return ((Kc(n) ? n.ownerDocument : n.document) || window.document).documentElement } function A1(n) { return Fs(n) === "html" ? n : n.assignedSlot || n.parentNode || (tb(n) ? n.host : null) || Il(n) } function vB(n) { return !To(n) || Ma(n).position === "fixed" ? null : n.offsetParent } function QZ(n) { var e = /firefox/i.test(vE()), t = /Trident/i.test(vE()); if (t && To(n)) { var r = Ma(n); if (r.position === "fixed") return null } var i = A1(n); for (tb(i) && (i = i.host); To(i) && ["html", "body"].indexOf(Fs(i)) < 0;) { var o = Ma(i); if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none") return i; i = i.parentNode } return null } function nm(n) { for (var e = ao(n), t = vB(n); t && $Z(t) && Ma(t).position === "static";)t = vB(t); return t && (Fs(t) === "html" || Fs(t) === "body" && Ma(t).position === "static") ? e : t || QZ(n) || e } function rb(n) { return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y" } function Fh(n, e, t) { return Oc(n, zv(e, t)) } function ZZ(n, e, t) { var r = Fh(n, e, t); return r > t ? t : r } function HU() { return { top: 0, right: 0, bottom: 0, left: 0 } } function VU(n) { return Object.assign({}, HU(), n) } function WU(n, e) { return e.reduce(function (t, r) { return t[r] = n, t }, {}) } var qZ = function (e, t) { return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, VU(typeof e != "number" ? e : WU(e, tm)) }; function eq(n) { var e, t = n.state, r = n.name, i = n.options, o = t.elements.arrow, s = t.modifiersData.popperOffsets, a = Ls(t.placement), l = rb(a), c = [Fi, Io].indexOf(a) >= 0, u = c ? "height" : "width"; if (!(!o || !s)) { var d = qZ(i.padding, t), p = nb(o), m = l === "y" ? Oi : Fi, v = l === "y" ? Bo : Io, y = t.rects.reference[u] + t.rects.reference[l] - s[l] - t.rects.popper[u], _ = s[l] - t.rects.reference[l], g = nm(o), x = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, A = y / 2 - _ / 2, E = d[m], w = x - p[u] - d[v], b = x / 2 - p[u] / 2 + A, T = Fh(E, b, w), B = l; t.modifiersData[r] = (e = {}, e[B] = T, e.centerOffset = T - b, e) } } function tq(n) { var e = n.state, t = n.options, r = t.element, i = r === void 0 ? "[data-popper-arrow]" : r; i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || GU(e.elements.popper, i) && (e.elements.arrow = i)) } const nq = { name: "arrow", enabled: !0, phase: "main", fn: eq, effect: tq, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function ed(n) { return n.split("-")[1] } var rq = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function iq(n, e) { var t = n.x, r = n.y, i = e.devicePixelRatio || 1; return { x: Zf(t * i) / i || 0, y: Zf(r * i) / i || 0 } } function yB(n) { var e, t = n.popper, r = n.popperRect, i = n.placement, o = n.variation, s = n.offsets, a = n.position, l = n.gpuAcceleration, c = n.adaptive, u = n.roundOffsets, d = n.isFixed, p = s.x, m = p === void 0 ? 0 : p, v = s.y, y = v === void 0 ? 0 : v, _ = typeof u == "function" ? u({ x: m, y }) : { x: m, y }; m = _.x, y = _.y; var g = s.hasOwnProperty("x"), x = s.hasOwnProperty("y"), A = Fi, E = Oi, w = window; if (c) { var b = nm(t), T = "clientHeight", B = "clientWidth"; if (b === ao(t) && (b = Il(t), Ma(b).position !== "static" && a === "absolute" && (T = "scrollHeight", B = "scrollWidth")), b = b, i === Oi || (i === Fi || i === Io) && o === bp) { E = Bo; var R = d && b === w && w.visualViewport ? w.visualViewport.height : b[T]; y -= R - r.height, y *= l ? 1 : -1 } if (i === Fi || (i === Oi || i === Bo) && o === bp) { A = Io; var P = d && b === w && w.visualViewport ? w.visualViewport.width : b[B]; m -= P - r.width, m *= l ? 1 : -1 } } var U = Object.assign({ position: a }, c && rq), G = u === !0 ? iq({ x: m, y }, ao(t)) : { x: m, y }; if (m = G.x, y = G.y, l) { var $; return Object.assign({}, U, ($ = {}, $[E] = x ? "0" : "", $[A] = g ? "0" : "", $.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + y + "px)" : "translate3d(" + m + "px, " + y + "px, 0)", $)) } return Object.assign({}, U, (e = {}, e[E] = x ? y + "px" : "", e[A] = g ? m + "px" : "", e.transform = "", e)) } function oq(n) { var e = n.state, t = n.options, r = t.gpuAcceleration, i = r === void 0 ? !0 : r, o = t.adaptive, s = o === void 0 ? !0 : o, a = t.roundOffsets, l = a === void 0 ? !0 : a, c = { placement: Ls(e.placement), variation: ed(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, yB(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: s, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, yB(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) } const sq = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: oq, data: {} }; var h0 = { passive: !0 }; function aq(n) { var e = n.state, t = n.instance, r = n.options, i = r.scroll, o = i === void 0 ? !0 : i, s = r.resize, a = s === void 0 ? !0 : s, l = ao(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper); return o && c.forEach(function (u) { u.addEventListener("scroll", t.update, h0) }), a && l.addEventListener("resize", t.update, h0), function () { o && c.forEach(function (u) { u.removeEventListener("scroll", t.update, h0) }), a && l.removeEventListener("resize", t.update, h0) } } const lq = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: aq, data: {} }; var cq = { left: "right", right: "left", bottom: "top", top: "bottom" }; function X0(n) { return n.replace(/left|right|bottom|top/g, function (e) { return cq[e] }) } var uq = { start: "end", end: "start" }; function _B(n) { return n.replace(/start|end/g, function (e) { return uq[e] }) } function ib(n) { var e = ao(n), t = e.pageXOffset, r = e.pageYOffset; return { scrollLeft: t, scrollTop: r } } function ob(n) { return qf(Il(n)).left + ib(n).scrollLeft } function fq(n, e) { var t = ao(n), r = Il(n), i = t.visualViewport, o = r.clientWidth, s = r.clientHeight, a = 0, l = 0; if (i) { o = i.width, s = i.height; var c = zU(); (c || !c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop) } return { width: o, height: s, x: a + ob(n), y: l } } function dq(n) { var e, t = Il(n), r = ib(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, o = Oc(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = Oc(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + ob(n), l = -r.scrollTop; return Ma(i || t).direction === "rtl" && (a += Oc(t.clientWidth, i ? i.clientWidth : 0) - o), { width: o, height: s, x: a, y: l } } function sb(n) { var e = Ma(n), t = e.overflow, r = e.overflowX, i = e.overflowY; return /auto|scroll|overlay|hidden/.test(t + i + r) } function jU(n) { return ["html", "body", "#document"].indexOf(Fs(n)) >= 0 ? n.ownerDocument.body : To(n) && sb(n) ? n : jU(A1(n)) } function Uh(n, e) { var t; e === void 0 && (e = []); var r = jU(n), i = r === ((t = n.ownerDocument) == null ? void 0 : t.body), o = ao(r), s = i ? [o].concat(o.visualViewport || [], sb(r) ? r : []) : r, a = e.concat(s); return i ? a : a.concat(Uh(A1(s))) } function yE(n) { return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height }) } function hq(n, e) { var t = qf(n, !1, e === "fixed"); return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t } function xB(n, e, t) { return e === kU ? yE(fq(n, t)) : Kc(e) ? hq(e, t) : yE(dq(Il(n))) } function pq(n) { var e = Uh(A1(n)), t = ["absolute", "fixed"].indexOf(Ma(n).position) >= 0, r = t && To(n) ? nm(n) : n; return Kc(r) ? e.filter(function (i) { return Kc(i) && GU(i, r) && Fs(i) !== "body" }) : [] } function mq(n, e, t, r) { var i = e === "clippingParents" ? pq(n) : [].concat(e), o = [].concat(i, [t]), s = o[0], a = o.reduce(function (l, c) { var u = xB(n, c, r); return l.top = Oc(u.top, l.top), l.right = zv(u.right, l.right), l.bottom = zv(u.bottom, l.bottom), l.left = Oc(u.left, l.left), l }, xB(n, s, r)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function XU(n) { var e = n.reference, t = n.element, r = n.placement, i = r ? Ls(r) : null, o = r ? ed(r) : null, s = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l; switch (i) { case Oi: l = { x: s, y: e.y - t.height }; break; case Bo: l = { x: s, y: e.y + e.height }; break; case Io: l = { x: e.x + e.width, y: a }; break; case Fi: l = { x: e.x - t.width, y: a }; break; default: l = { x: e.x, y: e.y } }var c = i ? rb(i) : null; if (c != null) { var u = c === "y" ? "height" : "width"; switch (o) { case Qf: l[c] = l[c] - (e[u] / 2 - t[u] / 2); break; case bp: l[c] = l[c] + (e[u] / 2 - t[u] / 2); break } } return l } function Cp(n, e) { e === void 0 && (e = {}); var t = e, r = t.placement, i = r === void 0 ? n.placement : r, o = t.strategy, s = o === void 0 ? n.strategy : o, a = t.boundary, l = a === void 0 ? OZ : a, c = t.rootBoundary, u = c === void 0 ? kU : c, d = t.elementContext, p = d === void 0 ? ah : d, m = t.altBoundary, v = m === void 0 ? !1 : m, y = t.padding, _ = y === void 0 ? 0 : y, g = VU(typeof _ != "number" ? _ : WU(_, tm)), x = p === ah ? FZ : ah, A = n.rects.popper, E = n.elements[v ? x : p], w = mq(Kc(E) ? E : E.contextElement || Il(n.elements.popper), l, u, s), b = qf(n.elements.reference), T = XU({ reference: b, element: A, strategy: "absolute", placement: i }), B = yE(Object.assign({}, A, T)), R = p === ah ? B : b, P = { top: w.top - R.top + g.top, bottom: R.bottom - w.bottom + g.bottom, left: w.left - R.left + g.left, right: R.right - w.right + g.right }, U = n.modifiersData.offset; if (p === ah && U) { var G = U[i]; Object.keys(P).forEach(function ($) { var z = [Io, Bo].indexOf($) >= 0 ? 1 : -1, j = [Oi, Bo].indexOf($) >= 0 ? "y" : "x"; P[$] += G[j] * z }) } return P } function gq(n, e) { e === void 0 && (e = {}); var t = e, r = t.placement, i = t.boundary, o = t.rootBoundary, s = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, c = l === void 0 ? NU : l, u = ed(r), d = u ? a ? gB : gB.filter(function (v) { return ed(v) === u }) : tm, p = d.filter(function (v) { return c.indexOf(v) >= 0 }); p.length === 0 && (p = d); var m = p.reduce(function (v, y) { return v[y] = Cp(n, { placement: y, boundary: i, rootBoundary: o, padding: s })[Ls(y)], v }, {}); return Object.keys(m).sort(function (v, y) { return m[v] - m[y] }) } function vq(n) { if (Ls(n) === eb) return []; var e = X0(n); return [_B(n), e, _B(e)] } function yq(n) { var e = n.state, t = n.options, r = n.name; if (!e.modifiersData[r]._skip) { for (var i = t.mainAxis, o = i === void 0 ? !0 : i, s = t.altAxis, a = s === void 0 ? !0 : s, l = t.fallbackPlacements, c = t.padding, u = t.boundary, d = t.rootBoundary, p = t.altBoundary, m = t.flipVariations, v = m === void 0 ? !0 : m, y = t.allowedAutoPlacements, _ = e.options.placement, g = Ls(_), x = g === _, A = l || (x || !v ? [X0(_)] : vq(_)), E = [_].concat(A).reduce(function (ee, ne) { return ee.concat(Ls(ne) === eb ? gq(e, { placement: ne, boundary: u, rootBoundary: d, padding: c, flipVariations: v, allowedAutoPlacements: y }) : ne) }, []), w = e.rects.reference, b = e.rects.popper, T = new Map, B = !0, R = E[0], P = 0; P < E.length; P++) { var U = E[P], G = Ls(U), $ = ed(U) === Qf, z = [Oi, Bo].indexOf(G) >= 0, j = z ? "width" : "height", q = Cp(e, { placement: U, boundary: u, rootBoundary: d, altBoundary: p, padding: c }), se = z ? $ ? Io : Fi : $ ? Bo : Oi; w[j] > b[j] && (se = X0(se)); var W = X0(se), V = []; if (o && V.push(q[G] <= 0), a && V.push(q[se] <= 0, q[W] <= 0), V.every(function (ee) { return ee })) { R = U, B = !1; break } T.set(U, V) } if (B) for (var J = v ? 3 : 1, O = function (ne) { var K = E.find(function (ae) { var ie = T.get(ae); if (ie) return ie.slice(0, ne).every(function (Se) { return Se }) }); if (K) return R = K, "break" }, k = J; k > 0; k--) { var Z = O(k); if (Z === "break") break } e.placement !== R && (e.modifiersData[r]._skip = !0, e.placement = R, e.reset = !0) } } const _q = { name: "flip", enabled: !0, phase: "main", fn: yq, requiresIfExists: ["offset"], data: { _skip: !1 } }; function SB(n, e, t) { return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x } } function AB(n) { return [Oi, Io, Bo, Fi].some(function (e) { return n[e] >= 0 }) } function xq(n) { var e = n.state, t = n.name, r = e.rects.reference, i = e.rects.popper, o = e.modifiersData.preventOverflow, s = Cp(e, { elementContext: "reference" }), a = Cp(e, { altBoundary: !0 }), l = SB(s, r), c = SB(a, i, o), u = AB(l), d = AB(c); e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } const Sq = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: xq }; function Aq(n, e, t) { var r = Ls(n), i = [Fi, Oi].indexOf(r) >= 0 ? -1 : 1, o = typeof t == "function" ? t(Object.assign({}, e, { placement: n })) : t, s = o[0], a = o[1]; return s = s || 0, a = (a || 0) * i, [Fi, Io].indexOf(r) >= 0 ? { x: a, y: s } : { x: s, y: a } } function Eq(n) { var e = n.state, t = n.options, r = n.name, i = t.offset, o = i === void 0 ? [0, 0] : i, s = NU.reduce(function (u, d) { return u[d] = Aq(d, e.rects, o), u }, {}), a = s[e.placement], l = a.x, c = a.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = s } const Mq = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: Eq }; function wq(n) { var e = n.state, t = n.name; e.modifiersData[t] = XU({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) } const bq = { name: "popperOffsets", enabled: !0, phase: "read", fn: wq, data: {} }; function Cq(n) { return n === "x" ? "y" : "x" } function Tq(n) { var e = n.state, t = n.options, r = n.name, i = t.mainAxis, o = i === void 0 ? !0 : i, s = t.altAxis, a = s === void 0 ? !1 : s, l = t.boundary, c = t.rootBoundary, u = t.altBoundary, d = t.padding, p = t.tether, m = p === void 0 ? !0 : p, v = t.tetherOffset, y = v === void 0 ? 0 : v, _ = Cp(e, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }), g = Ls(e.placement), x = ed(e.placement), A = !x, E = rb(g), w = Cq(E), b = e.modifiersData.popperOffsets, T = e.rects.reference, B = e.rects.popper, R = typeof y == "function" ? y(Object.assign({}, e.rects, { placement: e.placement })) : y, P = typeof R == "number" ? { mainAxis: R, altAxis: R } : Object.assign({ mainAxis: 0, altAxis: 0 }, R), U = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, G = { x: 0, y: 0 }; if (b) { if (o) { var $, z = E === "y" ? Oi : Fi, j = E === "y" ? Bo : Io, q = E === "y" ? "height" : "width", se = b[E], W = se + _[z], V = se - _[j], J = m ? -B[q] / 2 : 0, O = x === Qf ? T[q] : B[q], k = x === Qf ? -B[q] : -T[q], Z = e.elements.arrow, ee = m && Z ? nb(Z) : { width: 0, height: 0 }, ne = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : HU(), K = ne[z], ae = ne[j], ie = Fh(0, T[q], ee[q]), Se = A ? T[q] / 2 - J - ie - K - P.mainAxis : O - ie - K - P.mainAxis, Ce = A ? -T[q] / 2 + J + ie + ae + P.mainAxis : k + ie + ae + P.mainAxis, le = e.elements.arrow && nm(e.elements.arrow), F = le ? E === "y" ? le.clientTop || 0 : le.clientLeft || 0 : 0, me = ($ = U == null ? void 0 : U[E]) != null ? $ : 0, he = se + Se - me - F, ce = se + Ce - me, fe = Fh(m ? zv(W, he) : W, se, m ? Oc(V, ce) : V); b[E] = fe, G[E] = fe - se } if (a) { var Re, de = E === "x" ? Oi : Fi, Ie = E === "x" ? Bo : Io, we = b[w], ge = w === "y" ? "height" : "width", Ve = we + _[de], H = we - _[Ie], L = [Oi, Fi].indexOf(g) !== -1, oe = (Re = U == null ? void 0 : U[w]) != null ? Re : 0, Pe = L ? Ve : we - T[ge] - B[ge] - oe + P.altAxis, Ae = L ? we + T[ge] + B[ge] - oe - P.altAxis : H, ye = m && L ? ZZ(Pe, we, Ae) : Fh(m ? Pe : Ve, we, m ? Ae : H); b[w] = ye, G[w] = ye - we } e.modifiersData[r] = G } } const Rq = { name: "preventOverflow", enabled: !0, phase: "main", fn: Tq, requiresIfExists: ["offset"] }; function Pq(n) { return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } } function Bq(n) { return n === ao(n) || !To(n) ? ib(n) : Pq(n) } function Iq(n) { var e = n.getBoundingClientRect(), t = Zf(e.width) / n.offsetWidth || 1, r = Zf(e.height) / n.offsetHeight || 1; return t !== 1 || r !== 1 } function Lq(n, e, t) { t === void 0 && (t = !1); var r = To(e), i = To(e) && Iq(e), o = Il(e), s = qf(n, i, t), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (r || !r && !t) && ((Fs(e) !== "body" || sb(o)) && (a = Bq(e)), To(e) ? (l = qf(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = ob(o))), { x: s.left + a.scrollLeft - l.x, y: s.top + a.scrollTop - l.y, width: s.width, height: s.height } } function Dq(n) { var e = new Map, t = new Set, r = []; n.forEach(function (o) { e.set(o.name, o) }); function i(o) { t.add(o.name); var s = [].concat(o.requires || [], o.requiresIfExists || []); s.forEach(function (a) { if (!t.has(a)) { var l = e.get(a); l && i(l) } }), r.push(o) } return n.forEach(function (o) { t.has(o.name) || i(o) }), r } function Oq(n) { var e = Dq(n); return XZ.reduce(function (t, r) { return t.concat(e.filter(function (i) { return i.phase === r })) }, []) } function Fq(n) { var e; return function () { return e || (e = new Promise(function (t) { Promise.resolve().then(function () { e = void 0, t(n()) }) })), e } } function Uq(n) { var e = n.reduce(function (t, r) { var i = t[r.name]; return t[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, t }, {}); return Object.keys(e).map(function (t) { return e[t] }) } var EB = { placement: "bottom", modifiers: [], strategy: "absolute" }; function MB() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return !e.some(function (r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function kq(n) { n === void 0 && (n = {}); var e = n, t = e.defaultModifiers, r = t === void 0 ? [] : t, i = e.defaultOptions, o = i === void 0 ? EB : i; return function (a, l, c) { c === void 0 && (c = o); var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, EB, o), modifiersData: {}, elements: { reference: a, popper: l }, attributes: {}, styles: {} }, d = [], p = !1, m = { state: u, setOptions: function (g) { var x = typeof g == "function" ? g(u.options) : g; y(), u.options = Object.assign({}, o, u.options, x), u.scrollParents = { reference: Kc(a) ? Uh(a) : a.contextElement ? Uh(a.contextElement) : [], popper: Uh(l) }; var A = Oq(Uq([].concat(r, u.options.modifiers))); return u.orderedModifiers = A.filter(function (E) { return E.enabled }), v(), m.update() }, forceUpdate: function () { if (!p) { var g = u.elements, x = g.reference, A = g.popper; if (MB(x, A)) { u.rects = { reference: Lq(x, nm(A), u.options.strategy === "fixed"), popper: nb(A) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (P) { return u.modifiersData[P.name] = Object.assign({}, P.data) }); for (var E = 0; E < u.orderedModifiers.length; E++) { if (u.reset === !0) { u.reset = !1, E = -1; continue } var w = u.orderedModifiers[E], b = w.fn, T = w.options, B = T === void 0 ? {} : T, R = w.name; typeof b == "function" && (u = b({ state: u, options: B, name: R, instance: m }) || u) } } } }, update: Fq(function () { return new Promise(function (_) { m.forceUpdate(), _(u) }) }), destroy: function () { y(), p = !0 } }; if (!MB(a, l)) return m; m.setOptions(c).then(function (_) { !p && c.onFirstUpdate && c.onFirstUpdate(_) }); function v() { u.orderedModifiers.forEach(function (_) { var g = _.name, x = _.options, A = x === void 0 ? {} : x, E = _.effect; if (typeof E == "function") { var w = E({ state: u, name: g, instance: m, options: A }), b = function () { }; d.push(w || b) } }) } function y() { d.forEach(function (_) { return _() }), d = [] } return m } } var Nq = [lq, bq, sq, YZ, Mq, _q, Rq, nq, Sq], zq = kq({ defaultModifiers: Nq }); function Gq(n) { return typeof n == "function" ? n() : n } const Hq = N.forwardRef(function (e, t) { const { children: r, container: i, disablePortal: o = !1 } = e, [s, a] = N.useState(null), l = Sa(N.isValidElement(r) ? r.ref : null, t); if (yp(() => { o || a(Gq(i) || document.body) }, [i, o]), yp(() => { if (s && !o) return eE(t, s), () => { eE(t, null) } }, [t, s, o]), o) { if (N.isValidElement(r)) { const c = { ref: l }; return N.cloneElement(r, c) } return st.jsx(N.Fragment, { children: r }) } return st.jsx(N.Fragment, { children: s && iy.createPortal(r, s) }) }); function Vq(n) { return Ir("MuiPopper", n) } Lr("MuiPopper", ["root"]); const Wq = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], jq = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"]; function Xq(n, e) { if (e === "ltr") return n; switch (n) { case "bottom-end": return "bottom-start"; case "bottom-start": return "bottom-end"; case "top-end": return "top-start"; case "top-start": return "top-end"; default: return n } } function _E(n) { return typeof n == "function" ? n() : n } function Jq(n) { return n.nodeType !== void 0 } const Kq = () => ti({ root: ["root"] }, RZ(Vq)), Yq = {}, $q = N.forwardRef(function (e, t) { var r; const { anchorEl: i, children: o, direction: s, disablePortal: a, modifiers: l, open: c, placement: u, popperOptions: d, popperRef: p, slotProps: m = {}, slots: v = {}, TransitionProps: y } = e, _ = Wt(e, Wq), g = N.useRef(null), x = Sa(g, t), A = N.useRef(null), E = Sa(A, p), w = N.useRef(E); yp(() => { w.current = E }, [E]), N.useImperativeHandle(p, () => A.current, []); const b = Xq(u, s), [T, B] = N.useState(b), [R, P] = N.useState(_E(i)); N.useEffect(() => { A.current && A.current.forceUpdate() }), N.useEffect(() => { i && P(_E(i)) }, [i]), yp(() => { if (!R || !c) return; const j = W => { B(W.placement) }; let q = [{ name: "preventOverflow", options: { altBoundary: a } }, { name: "flip", options: { altBoundary: a } }, { name: "onUpdate", enabled: !0, phase: "afterWrite", fn: ({ state: W }) => { j(W) } }]; l != null && (q = q.concat(l)), d && d.modifiers != null && (q = q.concat(d.modifiers)); const se = zq(R, g.current, Ee({ placement: b }, d, { modifiers: q })); return w.current(se), () => { se.destroy(), w.current(null) } }, [R, a, l, c, d, b]); const U = { placement: T }; y !== null && (U.TransitionProps = y); const G = Kq(), $ = (r = v.root) != null ? r : "div", z = UU({ elementType: $, externalSlotProps: m.root, externalForwardedProps: _, additionalProps: { role: "tooltip", ref: x }, ownerState: e, className: G.root }); return st.jsx($, Ee({}, z, { children: typeof o == "function" ? o(U) : o })) }), Qq = N.forwardRef(function (e, t) { const { anchorEl: r, children: i, container: o, direction: s = "ltr", disablePortal: a = !1, keepMounted: l = !1, modifiers: c, open: u, placement: d = "bottom", popperOptions: p = Yq, popperRef: m, style: v, transition: y = !1, slotProps: _ = {}, slots: g = {} } = e, x = Wt(e, jq), [A, E] = N.useState(!0), w = () => { E(!1) }, b = () => { E(!0) }; if (!l && !u && (!y || A)) return null; let T; if (o) T = o; else if (r) { const P = _E(r); T = P && Jq(P) ? Dh(P).body : Dh(null).body } const B = !u && l && (!y || A) ? "none" : void 0, R = y ? { in: u, onEnter: w, onExited: b } : void 0; return st.jsx(Hq, { disablePortal: a, container: T, children: st.jsx($q, Ee({ anchorEl: r, direction: s, disablePortal: a, modifiers: c, ref: t, open: y ? !A : u, placement: d, popperOptions: p, popperRef: m, slotProps: _, slots: g }, x, { style: Ee({ position: "fixed", top: 0, left: 0, display: B }, v), TransitionProps: R, children: i })) }) }); function Zq(n = {}) { const { autoHideDuration: e = null, disableWindowBlurListener: t = !1, onClose: r, open: i, resumeHideDuration: o } = n, s = N.useRef(); N.useEffect(() => { if (!i) return; function g(x) { x.defaultPrevented || (x.key === "Escape" || x.key === "Esc") && (r == null || r(x, "escapeKeyDown")) } return document.addEventListener("keydown", g), () => { document.removeEventListener("keydown", g) } }, [i, r]); const a = rl((g, x) => { r == null || r(g, x) }), l = rl(g => { !r || g == null || (clearTimeout(s.current), s.current = setTimeout(() => { a(null, "timeout") }, g)) }); N.useEffect(() => (i && l(e), () => { clearTimeout(s.current) }), [i, e, l]); const c = g => { r == null || r(g, "clickaway") }, u = () => { clearTimeout(s.current) }, d = N.useCallback(() => { e != null && l(o ?? e * .5) }, [e, o, l]), p = g => x => { const A = g.onBlur; A == null || A(x), d() }, m = g => x => { const A = g.onFocus; A == null || A(x), u() }, v = g => x => { const A = g.onMouseEnter; A == null || A(x), u() }, y = g => x => { const A = g.onMouseLeave; A == null || A(x), d() }; return N.useEffect(() => { if (!t && i) return window.addEventListener("focus", d), window.addEventListener("blur", u), () => { window.removeEventListener("focus", d), window.removeEventListener("blur", u) } }, [t, d, i]), { getRootProps: (g = {}) => { const x = Ee({}, gE(n), gE(g)); return Ee({ role: "presentation" }, g, x, { onBlur: p(x), onFocus: m(x), onMouseEnter: v(x), onMouseLeave: y(x) }) }, onClickAway: c } } const qq = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"], eee = Zt(Qq, { name: "MuiPopper", slot: "Root", overridesResolver: (n, e) => e.root })({}), tee = N.forwardRef(function (e, t) { var r; const i = gU(), o = ni({ props: e, name: "MuiPopper" }), { anchorEl: s, component: a, components: l, componentsProps: c, container: u, disablePortal: d, keepMounted: p, modifiers: m, open: v, placement: y, popperOptions: _, popperRef: g, transition: x, slots: A, slotProps: E } = o, w = Wt(o, qq), b = (r = A == null ? void 0 : A.root) != null ? r : l == null ? void 0 : l.Root, T = Ee({ anchorEl: s, container: u, disablePortal: d, keepMounted: p, modifiers: m, open: v, placement: y, popperOptions: _, popperRef: g, transition: x }, w); return st.jsx(eee, Ee({ as: a, direction: i == null ? void 0 : i.direction, slots: { root: b }, slotProps: E ?? c }, T, { ref: t })) }), JU = tee, nee = N.createContext(void 0), ree = nee; function iee() { return N.useContext(ree) } function oee(n) { return Ir("MuiButton", n) } const see = Lr("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), p0 = see, aee = N.createContext({}), lee = aee, cee = N.createContext(void 0), uee = cee, fee = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"], dee = n => { const { color: e, disableElevation: t, fullWidth: r, size: i, variant: o, classes: s } = n, a = { root: ["root", o, `${o}${It(e)}`, `size${It(i)}`, `${o}Size${It(i)}`, e === "inherit" && "colorInherit", t && "disableElevation", r && "fullWidth"], label: ["label"], startIcon: ["startIcon", `iconSize${It(i)}`], endIcon: ["endIcon", `iconSize${It(i)}`] }, l = ti(a, oee, s); return Ee({}, s, l) }, KU = n => Ee({}, n.size === "small" && { "& > *:nth-of-type(1)": { fontSize: 18 } }, n.size === "medium" && { "& > *:nth-of-type(1)": { fontSize: 20 } }, n.size === "large" && { "& > *:nth-of-type(1)": { fontSize: 22 } }), hee = Zt(qw, { shouldForwardProp: n => em(n) || n === "classes", name: "MuiButton", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, e[t.variant], e[`${t.variant}${It(t.color)}`], e[`size${It(t.size)}`], e[`${t.variant}Size${It(t.size)}`], t.color === "inherit" && e.colorInherit, t.disableElevation && e.disableElevation, t.fullWidth && e.fullWidth] } })(({ theme: n, ownerState: e }) => { var t, r; const i = n.palette.mode === "light" ? n.palette.grey[300] : n.palette.grey[800], o = n.palette.mode === "light" ? n.palette.grey.A100 : n.palette.grey[700]; return Ee({}, n.typography.button, { minWidth: 64, padding: "6px 16px", borderRadius: (n.vars || n).shape.borderRadius, transition: n.transitions.create(["background-color", "box-shadow", "border-color", "color"], { duration: n.transitions.duration.short }), "&:hover": Ee({ textDecoration: "none", backgroundColor: n.vars ? `rgba(${n.vars.palette.text.primaryChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(n.palette.text.primary, n.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } }, e.variant === "text" && e.color !== "inherit" && { backgroundColor: n.vars ? `rgba(${n.vars.palette[e.color].mainChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(n.palette[e.color].main, n.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } }, e.variant === "outlined" && e.color !== "inherit" && { border: `1px solid ${(n.vars || n).palette[e.color].main}`, backgroundColor: n.vars ? `rgba(${n.vars.palette[e.color].mainChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(n.palette[e.color].main, n.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } }, e.variant === "contained" && { backgroundColor: n.vars ? n.vars.palette.Button.inheritContainedHoverBg : o, boxShadow: (n.vars || n).shadows[4], "@media (hover: none)": { boxShadow: (n.vars || n).shadows[2], backgroundColor: (n.vars || n).palette.grey[300] } }, e.variant === "contained" && e.color !== "inherit" && { backgroundColor: (n.vars || n).palette[e.color].dark, "@media (hover: none)": { backgroundColor: (n.vars || n).palette[e.color].main } }), "&:active": Ee({}, e.variant === "contained" && { boxShadow: (n.vars || n).shadows[8] }), [`&.${p0.focusVisible}`]: Ee({}, e.variant === "contained" && { boxShadow: (n.vars || n).shadows[6] }), [`&.${p0.disabled}`]: Ee({ color: (n.vars || n).palette.action.disabled }, e.variant === "outlined" && { border: `1px solid ${(n.vars || n).palette.action.disabledBackground}` }, e.variant === "contained" && { color: (n.vars || n).palette.action.disabled, boxShadow: (n.vars || n).shadows[0], backgroundColor: (n.vars || n).palette.action.disabledBackground }) }, e.variant === "text" && { padding: "6px 8px" }, e.variant === "text" && e.color !== "inherit" && { color: (n.vars || n).palette[e.color].main }, e.variant === "outlined" && { padding: "5px 15px", border: "1px solid currentColor" }, e.variant === "outlined" && e.color !== "inherit" && { color: (n.vars || n).palette[e.color].main, border: n.vars ? `1px solid rgba(${n.vars.palette[e.color].mainChannel} / 0.5)` : `1px solid ${Jo(n.palette[e.color].main, .5)}` }, e.variant === "contained" && { color: n.vars ? n.vars.palette.text.primary : (t = (r = n.palette).getContrastText) == null ? void 0 : t.call(r, n.palette.grey[300]), backgroundColor: n.vars ? n.vars.palette.Button.inheritContainedBg : i, boxShadow: (n.vars || n).shadows[2] }, e.variant === "contained" && e.color !== "inherit" && { color: (n.vars || n).palette[e.color].contrastText, backgroundColor: (n.vars || n).palette[e.color].main }, e.color === "inherit" && { color: "inherit", borderColor: "currentColor" }, e.size === "small" && e.variant === "text" && { padding: "4px 5px", fontSize: n.typography.pxToRem(13) }, e.size === "large" && e.variant === "text" && { padding: "8px 11px", fontSize: n.typography.pxToRem(15) }, e.size === "small" && e.variant === "outlined" && { padding: "3px 9px", fontSize: n.typography.pxToRem(13) }, e.size === "large" && e.variant === "outlined" && { padding: "7px 21px", fontSize: n.typography.pxToRem(15) }, e.size === "small" && e.variant === "contained" && { padding: "4px 10px", fontSize: n.typography.pxToRem(13) }, e.size === "large" && e.variant === "contained" && { padding: "8px 22px", fontSize: n.typography.pxToRem(15) }, e.fullWidth && { width: "100%" }) }, ({ ownerState: n }) => n.disableElevation && { boxShadow: "none", "&:hover": { boxShadow: "none" }, [`&.${p0.focusVisible}`]: { boxShadow: "none" }, "&:active": { boxShadow: "none" }, [`&.${p0.disabled}`]: { boxShadow: "none" } }), pee = Zt("span", { name: "MuiButton", slot: "StartIcon", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.startIcon, e[`iconSize${It(t.size)}`]] } })(({ ownerState: n }) => Ee({ display: "inherit", marginRight: 8, marginLeft: -4 }, n.size === "small" && { marginLeft: -2 }, KU(n))), mee = Zt("span", { name: "MuiButton", slot: "EndIcon", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.endIcon, e[`iconSize${It(t.size)}`]] } })(({ ownerState: n }) => Ee({ display: "inherit", marginRight: -4, marginLeft: 8 }, n.size === "small" && { marginRight: -2 }, KU(n))), gee = N.forwardRef(function (e, t) { const r = N.useContext(lee), i = N.useContext(uee), o = Cw(r, e), s = ni({ props: o, name: "MuiButton" }), { children: a, color: l = "primary", component: c = "button", className: u, disabled: d = !1, disableElevation: p = !1, disableFocusRipple: m = !1, endIcon: v, focusVisibleClassName: y, fullWidth: _ = !1, size: g = "medium", startIcon: x, type: A, variant: E = "text" } = s, w = Wt(s, fee), b = Ee({}, s, { color: l, component: c, disabled: d, disableElevation: p, disableFocusRipple: m, fullWidth: _, size: g, type: A, variant: E }), T = dee(b), B = x && st.jsx(pee, { className: T.startIcon, ownerState: b, children: x }), R = v && st.jsx(mee, { className: T.endIcon, ownerState: b, children: v }), P = i || ""; return st.jsxs(hee, Ee({ ownerState: b, className: rn(r.className, T.root, u, P), component: c, disabled: d, focusRipple: !m, focusVisibleClassName: rn(T.focusVisible, y), ref: t, type: A }, w, { classes: T, children: [B, a, R] })) }), vee = gee; function yee(n) { return Ir("MuiCard", n) } Lr("MuiCard", ["root"]); const _ee = ["className", "raised"], xee = n => { const { classes: e } = n; return ti({ root: ["root"] }, yee, e) }, See = Zt(Zw, { name: "MuiCard", slot: "Root", overridesResolver: (n, e) => e.root })(() => ({ overflow: "hidden" })), Aee = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiCard" }), { className: i, raised: o = !1 } = r, s = Wt(r, _ee), a = Ee({}, r, { raised: o }), l = xee(a); return st.jsx(See, Ee({ className: rn(l.root, i), elevation: o ? 8 : void 0, ref: t, ownerState: a }, s)) }), Eee = Aee; function Mee(n) { return Ir("MuiCardActions", n) } Lr("MuiCardActions", ["root", "spacing"]); const wee = ["disableSpacing", "className"], bee = n => { const { classes: e, disableSpacing: t } = n; return ti({ root: ["root", !t && "spacing"] }, Mee, e) }, Cee = Zt("div", { name: "MuiCardActions", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, !t.disableSpacing && e.spacing] } })(({ ownerState: n }) => Ee({ display: "flex", alignItems: "center", padding: 8 }, !n.disableSpacing && { "& > :not(:first-of-type)": { marginLeft: 8 } })), Tee = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiCardActions" }), { disableSpacing: i = !1, className: o } = r, s = Wt(r, wee), a = Ee({}, r, { disableSpacing: i }), l = bee(a); return st.jsx(Cee, Ee({ className: rn(l.root, o), ownerState: a, ref: t }, s)) }), Ree = Tee; function Pee(n) { return Ir("MuiCardContent", n) } Lr("MuiCardContent", ["root"]); const Bee = ["className", "component"], Iee = n => { const { classes: e } = n; return ti({ root: ["root"] }, Pee, e) }, Lee = Zt("div", { name: "MuiCardContent", slot: "Root", overridesResolver: (n, e) => e.root })(() => ({ padding: 16, "&:last-child": { paddingBottom: 24 } })), Dee = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiCardContent" }), { className: i, component: o = "div" } = r, s = Wt(r, Bee), a = Ee({}, r, { component: o }), l = Iee(a); return st.jsx(Lee, Ee({ as: o, className: rn(l.root, i), ownerState: a, ref: t }, s)) }), wB = Dee; function Oee(n) { return Ir("PrivateSwitchBase", n) } Lr("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]); const Fee = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"], Uee = n => { const { classes: e, checked: t, disabled: r, edge: i } = n, o = { root: ["root", t && "checked", r && "disabled", i && `edge${It(i)}`], input: ["input"] }; return ti(o, Oee, e) }, kee = Zt(qw)(({ ownerState: n }) => Ee({ padding: 9, borderRadius: "50%" }, n.edge === "start" && { marginLeft: n.size === "small" ? -3 : -12 }, n.edge === "end" && { marginRight: n.size === "small" ? -3 : -12 })), Nee = Zt("input", { shouldForwardProp: em })({ cursor: "inherit", position: "absolute", opacity: 0, width: "100%", height: "100%", top: 0, left: 0, margin: 0, padding: 0, zIndex: 1 }), zee = N.forwardRef(function (e, t) { const { autoFocus: r, checked: i, checkedIcon: o, className: s, defaultChecked: a, disabled: l, disableFocusRipple: c = !1, edge: u = !1, icon: d, id: p, inputProps: m, inputRef: v, name: y, onBlur: _, onChange: g, onFocus: x, readOnly: A, required: E = !1, tabIndex: w, type: b, value: T } = e, B = Wt(e, Fee), [R, P] = YF({ controlled: i, default: !!a, name: "SwitchBase", state: "checked" }), U = iee(), G = V => { x && x(V), U && U.onFocus && U.onFocus(V) }, $ = V => { _ && _(V), U && U.onBlur && U.onBlur(V) }, z = V => { if (V.nativeEvent.defaultPrevented) return; const J = V.target.checked; P(J), g && g(V, J) }; let j = l; U && typeof j > "u" && (j = U.disabled); const q = b === "checkbox" || b === "radio", se = Ee({}, e, { checked: R, disabled: j, disableFocusRipple: c, edge: u }), W = Uee(se); return st.jsxs(kee, Ee({ component: "span", className: rn(W.root, s), centerRipple: !0, focusRipple: !c, disabled: j, tabIndex: null, role: void 0, onFocus: G, onBlur: $, ownerState: se, ref: t }, B, { children: [st.jsx(Nee, Ee({ autoFocus: r, checked: i, defaultChecked: a, className: W.input, disabled: j, id: q ? p : void 0, name: y, onChange: z, readOnly: A, ref: v, required: E, ownerState: se, tabIndex: w, type: b }, b === "checkbox" && T === void 0 ? {} : { value: T }, m)), R ? o : d] })) }), Gee = zee, Hee = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]; function xE(n) { return `scale(${n}, ${n ** 2})` } const Vee = { entering: { opacity: 1, transform: xE(1) }, entered: { opacity: 1, transform: "none" } }, eS = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), YU = N.forwardRef(function (e, t) { const { addEndListener: r, appear: i = !0, children: o, easing: s, in: a, onEnter: l, onEntered: c, onEntering: u, onExit: d, onExited: p, onExiting: m, style: v, timeout: y = "auto", TransitionComponent: _ = xQ } = e, g = Wt(e, Hee), x = N.useRef(), A = N.useRef(), E = Yw(), w = N.useRef(null), b = Sa(w, o.ref, t), T = j => q => { if (j) { const se = w.current; q === void 0 ? j(se) : j(se, q) } }, B = T(u), R = T((j, q) => { TQ(j); const { duration: se, delay: W, easing: V } = oB({ style: v, timeout: y, easing: s }, { mode: "enter" }); let J; y === "auto" ? (J = E.transitions.getAutoHeightDuration(j.clientHeight), A.current = J) : J = se, j.style.transition = [E.transitions.create("opacity", { duration: J, delay: W }), E.transitions.create("transform", { duration: eS ? J : J * .666, delay: W, easing: V })].join(","), l && l(j, q) }), P = T(c), U = T(m), G = T(j => { const { duration: q, delay: se, easing: W } = oB({ style: v, timeout: y, easing: s }, { mode: "exit" }); let V; y === "auto" ? (V = E.transitions.getAutoHeightDuration(j.clientHeight), A.current = V) : V = q, j.style.transition = [E.transitions.create("opacity", { duration: V, delay: se }), E.transitions.create("transform", { duration: eS ? V : V * .666, delay: eS ? se : se || V * .333, easing: W })].join(","), j.style.opacity = 0, j.style.transform = xE(.75), d && d(j) }), $ = T(p), z = j => { y === "auto" && (x.current = setTimeout(j, A.current || 0)), r && r(w.current, j) }; return N.useEffect(() => () => { clearTimeout(x.current) }, []), st.jsx(_, Ee({ appear: i, in: a, nodeRef: w, onEnter: R, onEntered: P, onEntering: B, onExit: G, onExited: $, onExiting: U, addEndListener: z, timeout: y === "auto" ? null : y }, g, { children: (j, q) => N.cloneElement(o, Ee({ style: Ee({ opacity: 0, transform: xE(.75), visibility: j === "exited" && !a ? "hidden" : void 0 }, Vee[j], v, o.props.style), ref: b }, q)) })) }); YU.muiSupportAuto = !0; const SE = YU, Wee = Ta(st.jsx("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }), "RadioButtonUnchecked"), jee = Ta(st.jsx("path", { d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z" }), "RadioButtonChecked"), Xee = Zt("span", { shouldForwardProp: em })({ position: "relative", display: "flex" }), Jee = Zt(Wee)({ transform: "scale(1)" }), Kee = Zt(jee)(({ theme: n, ownerState: e }) => Ee({ left: 0, position: "absolute", transform: "scale(0)", transition: n.transitions.create("transform", { easing: n.transitions.easing.easeIn, duration: n.transitions.duration.shortest }) }, e.checked && { transform: "scale(1)", transition: n.transitions.create("transform", { easing: n.transitions.easing.easeOut, duration: n.transitions.duration.shortest }) })); function $U(n) { const { checked: e = !1, classes: t = {}, fontSize: r } = n, i = Ee({}, n, { checked: e }); return st.jsxs(Xee, { className: t.root, ownerState: i, children: [st.jsx(Jee, { fontSize: r, className: t.background, ownerState: i }), st.jsx(Kee, { fontSize: r, className: t.dot, ownerState: i })] }) } const Yee = N.createContext(void 0), $ee = Yee; function Qee() { return N.useContext($ee) } function Zee(n) { return Ir("MuiRadio", n) } const qee = Lr("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), bB = qee, ete = ["checked", "checkedIcon", "color", "icon", "name", "onChange", "size", "className"], tte = n => { const { classes: e, color: t, size: r } = n, i = { root: ["root", `color${It(t)}`, r !== "medium" && `size${It(r)}`] }; return Ee({}, e, ti(i, Zee, e)) }, nte = Zt(Gee, { shouldForwardProp: n => em(n) || n === "classes", name: "MuiRadio", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, t.size !== "medium" && e[`size${It(t.size)}`], e[`color${It(t.color)}`]] } })(({ theme: n, ownerState: e }) => Ee({ color: (n.vars || n).palette.text.secondary }, !e.disableRipple && { "&:hover": { backgroundColor: n.vars ? `rgba(${e.color === "default" ? n.vars.palette.action.activeChannel : n.vars.palette[e.color].mainChannel} / ${n.vars.palette.action.hoverOpacity})` : Jo(e.color === "default" ? n.palette.action.active : n.palette[e.color].main, n.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } } }, e.color !== "default" && { [`&.${bB.checked}`]: { color: (n.vars || n).palette[e.color].main } }, { [`&.${bB.disabled}`]: { color: (n.vars || n).palette.action.disabled } })); function rte(n, e) { return typeof e == "object" && e !== null ? n === e : String(n) === String(e) } const CB = st.jsx($U, { checked: !0 }), TB = st.jsx($U, {}), ite = N.forwardRef(function (e, t) { var r, i; const o = ni({ props: e, name: "MuiRadio" }), { checked: s, checkedIcon: a = CB, color: l = "primary", icon: c = TB, name: u, onChange: d, size: p = "medium", className: m } = o, v = Wt(o, ete), y = Ee({}, o, { color: l, size: p }), _ = tte(y), g = Qee(); let x = s; const A = zX(d, g && g.onChange); let E = u; return g && (typeof x > "u" && (x = rte(g.value, o.value)), typeof E > "u" && (E = g.name)), st.jsx(nte, Ee({ type: "radio", icon: N.cloneElement(c, { fontSize: (r = TB.props.fontSize) != null ? r : p }), checkedIcon: N.cloneElement(a, { fontSize: (i = CB.props.fontSize) != null ? i : p }), ownerState: y, classes: _, name: E, checked: x, onChange: A, ref: t, className: rn(_.root, m) }, v)) }), RB = ite; function ote(n) { return Ir("MuiSnackbarContent", n) } Lr("MuiSnackbarContent", ["root", "message", "action"]); const ste = ["action", "className", "message", "role"], ate = n => { const { classes: e } = n; return ti({ root: ["root"], action: ["action"], message: ["message"] }, ote, e) }, lte = Zt(Zw, { name: "MuiSnackbarContent", slot: "Root", overridesResolver: (n, e) => e.root })(({ theme: n }) => { const e = n.palette.mode === "light" ? .8 : .98, t = gY(n.palette.background.default, e); return Ee({}, n.typography.body2, { color: n.vars ? n.vars.palette.SnackbarContent.color : n.palette.getContrastText(t), backgroundColor: n.vars ? n.vars.palette.SnackbarContent.bg : t, display: "flex", alignItems: "center", flexWrap: "wrap", padding: "6px 16px", borderRadius: (n.vars || n).shape.borderRadius, flexGrow: 1, [n.breakpoints.up("sm")]: { flexGrow: "initial", minWidth: 288 } }) }), cte = Zt("div", { name: "MuiSnackbarContent", slot: "Message", overridesResolver: (n, e) => e.message })({ padding: "8px 0" }), ute = Zt("div", { name: "MuiSnackbarContent", slot: "Action", overridesResolver: (n, e) => e.action })({ display: "flex", alignItems: "center", marginLeft: "auto", paddingLeft: 16, marginRight: -8 }), fte = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiSnackbarContent" }), { action: i, className: o, message: s, role: a = "alert" } = r, l = Wt(r, ste), c = r, u = ate(c); return st.jsxs(lte, Ee({ role: a, square: !0, elevation: 6, className: rn(u.root, o), ownerState: c, ref: t }, l, { children: [st.jsx(cte, { className: u.message, ownerState: c, children: s }), i ? st.jsx(ute, { className: u.action, ownerState: c, children: i }) : null] })) }), dte = fte; function hte(n) { return Ir("MuiSnackbar", n) } Lr("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]); const pte = ["onEnter", "onExited"], mte = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"], gte = n => { const { classes: e, anchorOrigin: t } = n, r = { root: ["root", `anchorOrigin${It(t.vertical)}${It(t.horizontal)}`] }; return ti(r, hte, e) }, PB = Zt("div", { name: "MuiSnackbar", slot: "Root", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.root, e[`anchorOrigin${It(t.anchorOrigin.vertical)}${It(t.anchorOrigin.horizontal)}`]] } })(({ theme: n, ownerState: e }) => { const t = { left: "50%", right: "auto", transform: "translateX(-50%)" }; return Ee({ zIndex: (n.vars || n).zIndex.snackbar, position: "fixed", display: "flex", left: 8, right: 8, justifyContent: "center", alignItems: "center" }, e.anchorOrigin.vertical === "top" ? { top: 8 } : { bottom: 8 }, e.anchorOrigin.horizontal === "left" && { justifyContent: "flex-start" }, e.anchorOrigin.horizontal === "right" && { justifyContent: "flex-end" }, { [n.breakpoints.up("sm")]: Ee({}, e.anchorOrigin.vertical === "top" ? { top: 24 } : { bottom: 24 }, e.anchorOrigin.horizontal === "center" && t, e.anchorOrigin.horizontal === "left" && { left: 24, right: "auto" }, e.anchorOrigin.horizontal === "right" && { right: 24, left: "auto" }) }) }), vte = N.forwardRef(function (e, t) { const r = ni({ props: e, name: "MuiSnackbar" }), i = Yw(), o = { enter: i.transitions.duration.enteringScreen, exit: i.transitions.duration.leavingScreen }, { action: s, anchorOrigin: { vertical: a, horizontal: l } = { vertical: "bottom", horizontal: "left" }, autoHideDuration: c = null, children: u, className: d, ClickAwayListenerProps: p, ContentProps: m, disableWindowBlurListener: v = !1, message: y, open: _, TransitionComponent: g = SE, transitionDuration: x = o, TransitionProps: { onEnter: A, onExited: E } = {} } = r, w = Wt(r.TransitionProps, pte), b = Wt(r, mte), T = Ee({}, r, { anchorOrigin: { vertical: a, horizontal: l }, autoHideDuration: c, disableWindowBlurListener: v, TransitionComponent: g, transitionDuration: x }), B = gte(T), { getRootProps: R, onClickAway: P } = Zq(Ee({}, T)), [U, G] = N.useState(!0), $ = UU({ elementType: PB, getSlotProps: R, externalForwardedProps: b, ownerState: T, additionalProps: { ref: t }, className: [B.root, d] }), z = q => { G(!0), E && E(q) }, j = (q, se) => { G(!1), A && A(q, se) }; return !_ && U ? null : st.jsx(DZ, Ee({ onClickAway: P }, p, { children: st.jsx(PB, Ee({}, $, { children: st.jsx(g, Ee({ appear: !0, in: _, timeout: x, direction: a === "top" ? "down" : "up", onEnter: j, onExited: z }, w, { children: u || st.jsx(dte, Ee({ message: y, action: s }, m)) })) })) })) }), yte = vte; function _te(n) { return Ir("MuiTooltip", n) } const xte = Lr("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]), il = xte, Ste = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"]; function Ate(n) { return Math.round(n * 1e5) / 1e5 } const Ete = n => { const { classes: e, disableInteractive: t, arrow: r, touch: i, placement: o } = n, s = { popper: ["popper", !t && "popperInteractive", r && "popperArrow"], tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${It(o.split("-")[0])}`], arrow: ["arrow"] }; return ti(s, _te, e) }, Mte = Zt(JU, { name: "MuiTooltip", slot: "Popper", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.popper, !t.disableInteractive && e.popperInteractive, t.arrow && e.popperArrow, !t.open && e.popperClose] } })(({ theme: n, ownerState: e, open: t }) => Ee({ zIndex: (n.vars || n).zIndex.tooltip, pointerEvents: "none" }, !e.disableInteractive && { pointerEvents: "auto" }, !t && { pointerEvents: "none" }, e.arrow && { [`&[data-popper-placement*="bottom"] .${il.arrow}`]: { top: 0, marginTop: "-0.71em", "&::before": { transformOrigin: "0 100%" } }, [`&[data-popper-placement*="top"] .${il.arrow}`]: { bottom: 0, marginBottom: "-0.71em", "&::before": { transformOrigin: "100% 0" } }, [`&[data-popper-placement*="right"] .${il.arrow}`]: Ee({}, e.isRtl ? { right: 0, marginRight: "-0.71em" } : { left: 0, marginLeft: "-0.71em" }, { height: "1em", width: "0.71em", "&::before": { transformOrigin: "100% 100%" } }), [`&[data-popper-placement*="left"] .${il.arrow}`]: Ee({}, e.isRtl ? { left: 0, marginLeft: "-0.71em" } : { right: 0, marginRight: "-0.71em" }, { height: "1em", width: "0.71em", "&::before": { transformOrigin: "0 0" } }) })), wte = Zt("div", { name: "MuiTooltip", slot: "Tooltip", overridesResolver: (n, e) => { const { ownerState: t } = n; return [e.tooltip, t.touch && e.touch, t.arrow && e.tooltipArrow, e[`tooltipPlacement${It(t.placement.split("-")[0])}`]] } })(({ theme: n, ownerState: e }) => Ee({ backgroundColor: n.vars ? n.vars.palette.Tooltip.bg : Jo(n.palette.grey[700], .92), borderRadius: (n.vars || n).shape.borderRadius, color: (n.vars || n).palette.common.white, fontFamily: n.typography.fontFamily, padding: "4px 8px", fontSize: n.typography.pxToRem(11), maxWidth: 300, margin: 2, wordWrap: "break-word", fontWeight: n.typography.fontWeightMedium }, e.arrow && { position: "relative", margin: 0 }, e.touch && { padding: "8px 16px", fontSize: n.typography.pxToRem(14), lineHeight: `${Ate(16 / 14)}em`, fontWeight: n.typography.fontWeightRegular }, { [`.${il.popper}[data-popper-placement*="left"] &`]: Ee({ transformOrigin: "right center" }, e.isRtl ? Ee({ marginLeft: "14px" }, e.touch && { marginLeft: "24px" }) : Ee({ marginRight: "14px" }, e.touch && { marginRight: "24px" })), [`.${il.popper}[data-popper-placement*="right"] &`]: Ee({ transformOrigin: "left center" }, e.isRtl ? Ee({ marginRight: "14px" }, e.touch && { marginRight: "24px" }) : Ee({ marginLeft: "14px" }, e.touch && { marginLeft: "24px" })), [`.${il.popper}[data-popper-placement*="top"] &`]: Ee({ transformOrigin: "center bottom", marginBottom: "14px" }, e.touch && { marginBottom: "24px" }), [`.${il.popper}[data-popper-placement*="bottom"] &`]: Ee({ transformOrigin: "center top", marginTop: "14px" }, e.touch && { marginTop: "24px" }) })), bte = Zt("span", { name: "MuiTooltip", slot: "Arrow", overridesResolver: (n, e) => e.arrow })(({ theme: n }) => ({ overflow: "hidden", position: "absolute", width: "1em", height: "0.71em", boxSizing: "border-box", color: n.vars ? n.vars.palette.Tooltip.bg : Jo(n.palette.grey[700], .9), "&::before": { content: '""', margin: "auto", display: "block", width: "100%", height: "100%", backgroundColor: "currentColor", transform: "rotate(45deg)" } })); let m0 = !1, tS = null, lh = { x: 0, y: 0 }; function g0(n, e) { return t => { e && e(t), n(t) } } const Cte = N.forwardRef(function (e, t) { var r, i, o, s, a, l, c, u, d, p, m, v, y, _, g, x, A, E, w; const b = ni({ props: e, name: "MuiTooltip" }), { arrow: T = !1, children: B, components: R = {}, componentsProps: P = {}, describeChild: U = !1, disableFocusListener: G = !1, disableHoverListener: $ = !1, disableInteractive: z = !1, disableTouchListener: j = !1, enterDelay: q = 100, enterNextDelay: se = 0, enterTouchDelay: W = 700, followCursor: V = !1, id: J, leaveDelay: O = 0, leaveTouchDelay: k = 1500, onClose: Z, onOpen: ee, open: ne, placement: K = "bottom", PopperComponent: ae, PopperProps: ie = {}, slotProps: Se = {}, slots: Ce = {}, title: le, TransitionComponent: F = SE, TransitionProps: me } = b, he = Wt(b, Ste), ce = N.isValidElement(B) ? B : st.jsx("span", { children: B }), fe = Yw(), Re = fe.direction === "rtl", [de, Ie] = N.useState(), [we, ge] = N.useState(null), Ve = N.useRef(!1), H = z || V, L = N.useRef(), oe = N.useRef(), Pe = N.useRef(), Ae = N.useRef(), [ye, be] = YF({ controlled: ne, default: !1, name: "Tooltip", state: "open" }); let ke = ye; const He = VX(J), je = N.useRef(), nt = N.useCallback(() => { je.current !== void 0 && (document.body.style.WebkitUserSelect = je.current, je.current = void 0), clearTimeout(Ae.current) }, []); N.useEffect(() => () => { clearTimeout(L.current), clearTimeout(oe.current), clearTimeout(Pe.current), nt() }, [nt]); const Te = Ye => { clearTimeout(tS), m0 = !0, be(!0), ee && !ke && ee(Ye) }, Je = rl(Ye => { clearTimeout(tS), tS = setTimeout(() => { m0 = !1 }, 800 + O), be(!1), Z && ke && Z(Ye), clearTimeout(L.current), L.current = setTimeout(() => { Ve.current = !1 }, fe.transitions.duration.shortest) }), re = Ye => { Ve.current && Ye.type !== "touchstart" || (de && de.removeAttribute("title"), clearTimeout(oe.current), clearTimeout(Pe.current), q || m0 && se ? oe.current = setTimeout(() => { Te(Ye) }, m0 ? se : q) : Te(Ye)) }, _e = Ye => { clearTimeout(oe.current), clearTimeout(Pe.current), Pe.current = setTimeout(() => { Je(Ye) }, O) }, { isFocusVisibleRef: Ne, onBlur: Y, onFocus: Ue, ref: Ge } = $F(), [, Ke] = N.useState(!1), Qe = Ye => { Y(Ye), Ne.current === !1 && (Ke(!1), _e(Ye)) }, ze = Ye => { de || Ie(Ye.currentTarget), Ue(Ye), Ne.current === !0 && (Ke(!0), re(Ye)) }, Ze = Ye => { Ve.current = !0; const lt = ce.props; lt.onTouchStart && lt.onTouchStart(Ye) }, it = re, yt = _e, Ct = Ye => { Ze(Ye), clearTimeout(Pe.current), clearTimeout(L.current), nt(), je.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Ae.current = setTimeout(() => { document.body.style.WebkitUserSelect = je.current, re(Ye) }, W) }, At = Ye => { ce.props.onTouchEnd && ce.props.onTouchEnd(Ye), nt(), clearTimeout(Pe.current), Pe.current = setTimeout(() => { Je(Ye) }, k) }; N.useEffect(() => { if (!ke) return; function Ye(lt) { (lt.key === "Escape" || lt.key === "Esc") && Je(lt) } return document.addEventListener("keydown", Ye), () => { document.removeEventListener("keydown", Ye) } }, [Je, ke]); const xt = Sa(ce.ref, Ge, Ie, t); !le && le !== 0 && (ke = !1); const Yn = N.useRef(), $n = Ye => { const lt = ce.props; lt.onMouseMove && lt.onMouseMove(Ye), lh = { x: Ye.clientX, y: Ye.clientY }, Yn.current && Yn.current.update() }, Dt = {}, qt = typeof le == "string"; U ? (Dt.title = !ke && qt && !$ ? le : null, Dt["aria-describedby"] = ke ? He : null) : (Dt["aria-label"] = qt ? le : null, Dt["aria-labelledby"] = ke && !qt ? He : null); const tn = Ee({}, Dt, he, ce.props, { className: rn(he.className, ce.props.className), onTouchStart: Ze, ref: xt }, V ? { onMouseMove: $n } : {}), Ht = {}; j || (tn.onTouchStart = Ct, tn.onTouchEnd = At), $ || (tn.onMouseOver = g0(it, tn.onMouseOver), tn.onMouseLeave = g0(yt, tn.onMouseLeave), H || (Ht.onMouseOver = it, Ht.onMouseLeave = yt)), G || (tn.onFocus = g0(ze, tn.onFocus), tn.onBlur = g0(Qe, tn.onBlur), H || (Ht.onFocus = ze, Ht.onBlur = Qe)); const mn = N.useMemo(() => { var Ye; let lt = [{ name: "arrow", enabled: !!we, options: { element: we, padding: 4 } }]; return (Ye = ie.popperOptions) != null && Ye.modifiers && (lt = lt.concat(ie.popperOptions.modifiers)), Ee({}, ie.popperOptions, { modifiers: lt }) }, [we, ie]), gn = Ee({}, b, { isRtl: Re, arrow: T, disableInteractive: H, placement: K, PopperComponentProp: ae, touch: Ve.current }), Dr = Ete(gn), dr = (r = (i = Ce.popper) != null ? i : R.Popper) != null ? r : Mte, Q = (o = (s = (a = Ce.transition) != null ? a : R.Transition) != null ? s : F) != null ? o : SE, ve = (l = (c = Ce.tooltip) != null ? c : R.Tooltip) != null ? l : wte, De = (u = (d = Ce.arrow) != null ? d : R.Arrow) != null ? u : bte, xe = vh(dr, Ee({}, ie, (p = Se.popper) != null ? p : P.popper, { className: rn(Dr.popper, ie == null ? void 0 : ie.className, (m = (v = Se.popper) != null ? v : P.popper) == null ? void 0 : m.className) }), gn), Oe = vh(Q, Ee({}, me, (y = Se.transition) != null ? y : P.transition), gn), ot = vh(ve, Ee({}, (_ = Se.tooltip) != null ? _ : P.tooltip, { className: rn(Dr.tooltip, (g = (x = Se.tooltip) != null ? x : P.tooltip) == null ? void 0 : g.className) }), gn), dt = vh(De, Ee({}, (A = Se.arrow) != null ? A : P.arrow, { className: rn(Dr.arrow, (E = (w = Se.arrow) != null ? w : P.arrow) == null ? void 0 : E.className) }), gn); return st.jsxs(N.Fragment, { children: [N.cloneElement(ce, tn), st.jsx(dr, Ee({ as: ae ?? JU, placement: K, anchorEl: V ? { getBoundingClientRect: () => ({ top: lh.y, left: lh.x, right: lh.x, bottom: lh.y, width: 0, height: 0 }) } : de, popperRef: Yn, open: de ? ke : !1, id: He, transition: !0 }, Ht, xe, { popperOptions: mn, children: ({ TransitionProps: Ye }) => st.jsx(Q, Ee({ timeout: fe.transitions.duration.shorter }, Ye, Oe, { children: st.jsxs(ve, Ee({}, ot, { children: [le, T ? st.jsx(De, Ee({}, dt, { ref: ge })) : null] })) })) }))] }) }), Tte = Cte, Rte = () => { const n = oo(), { instructionMessage: e } = mi(r => r.DoubleSpendingReducer), t = () => { n(BU(!0)) }; return D.createElement("div", { style: { position: "absolute", bottom: 0, right: 0, background: "#ffffff10", paddingInline: 10 } }, D.createElement("h4", { style: { textAlign: "center", color: "white", fontFamily: "sans-serif" } }, " ", "Process"), e.map((r, i) => D.createElement("div", { key: i, style: { width: "400px", display: "flex", flexDirection: "column", alignItems: "center", padding: 5, marginLeft: 3 * i } }, D.createElement("div", { style: { display: "flex", margin: 0, flexDirection: "row" } }, D.createElement("p", { style: { marginInline: 2, marginBlock: 0, color: "white", display: "flex" } }, i + 1, " ", "   ", D.createElement("span", null, ".")), D.createElement("p", { style: { marginInline: 4, marginBlock: 0, color: "yellow" } }, r)), i === 3 && D.createElement("button", { onClick: t, style: { width: 150, padding: 3, marginTop: 15 } }, "Cancel Request")))) }, Pte = "images/alert-01dc5b70.jpg", Bte = "images/paper-eaaa0371.jpg", Ite = ({ position: n, firstTxt: e, rotation: t, secondTxt: r }) => { const { receiverName: i, receiverAmt: o, userBalance: s } = mi(l => l.DoubleSpendingReducer), a = Lo(Ca, Bte); return console.log(s, o), D.createElement("group", { rotation: t, position: n }, D.createElement("mesh", { rotation: [0, 50, 0] }, D.createElement(_n, { color: "yellow", position: [0, 1.9, 0], fontSize: .16 }, e), (s > 0 || o > 0) && D.createElement(_n, { color: "white", position: [0, 1.5, 0], fontSize: .16 }, r), D.createElement("boxGeometry", { args: [4, 2, .8] }), D.createElement("meshBasicMaterial", { map: a })), D.createElement("mesh", { position: [-.2, .8, .4], rotation: [0, 50, 0] }, D.createElement("boxGeometry", { args: [3, .3, .1] }), D.createElement("meshBasicMaterial", { color: "white" }), D.createElement(_n, { color: "black", position: [0, 0, .1], fontSize: .2 }, "DEMAND DRAFT"), D.createElement(_n, { color: "black", position: [0, 0, .1], fontSize: .2 }, "DEMAND DRAFT")), D.createElement("mesh", { position: [-.2, .2, .4], rotation: [0, 50, 0] }, D.createElement("boxGeometry", { args: [3.5, .3, .1] }), D.createElement("meshBasicMaterial", { color: "white" }), D.createElement(_n, { color: "black", position: [-1, 0, .1], fontSize: .2 }, "Name :"), D.createElement(_n, { color: "blue", position: [1, 0, .1], fontSize: .2 }, i)), D.createElement("mesh", { position: [-.2, -.2, .4], rotation: [0, 50, 0] }, D.createElement("boxGeometry", { args: [3.5, .3, .1] }), D.createElement("meshBasicMaterial", { color: "white" }), D.createElement(_n, { color: "black", position: [-1, 0, .1], fontSize: .2 }, "amount :"), D.createElement(_n, { color: "blue", position: [1, 0, .1], fontSize: .2 }, o)), D.createElement("mesh", { position: [1, -.6, .7], rotation: [0, 50, 0] }, D.createElement(_n, { color: "blue", position: [0, -.12, .1], fontSize: .15 }, "Ram"), D.createElement(_n, { color: "black", position: [0, -.26, .1], fontSize: .15 }, "Signature"))) }, Lte = () => { const { receiverName: n, moneySendToReciver: e, receiverAmt: t, isCancelation: r, userBalance: i, isReturnAmt: o, enableAlerts: s, waiting: a, request: l } = mi(m => m.DoubleSpendingReducer), c = Lo(Ca, Pte), u = oo(), [d, p] = N.useState(!1); return N.useEffect(() => { u(IU(!0)), r && (p(!0), setTimeout(() => { p(!1) }, 5e3)) }, [r, u]), D.createElement("group", null, D.createElement("group", { position: [0, 0, -3] }, D.createElement(Ite, { firstTxt: "Ram", secondTxt: `Balance : ${l === "return" ? t : a ? 0 : i} `, position: [-5, 1, -.5] }), D.createElement("group", { rotation: [0, 90, 0], position: [6, 0, 3] }, n !== "" && D.createElement(D.Fragment, null, D.createElement(_n, { color: "yellow", rotation: [0, 60, 0], position: [0, 3, 0], fontSize: .16 }, n), D.createElement(_n, { rotation: [0, 60, 0], color: "white", position: [0, 2.5, 0], fontSize: .16 }, `Balance : ${a ? t : 0} `)), D.createElement(mQ, null), D.createElement(vQ, null))), D.createElement("group", { rotation: [0, 50, 0] }, D.createElement(pQ, null), a && !r && D.createElement("mesh", { position: [0, 1, -1.3] }, D.createElement("boxGeometry", { args: [3, 1, .1] }), D.createElement("meshBasicMaterial", { map: c }), D.createElement(_n, { rotation: [0, 0, 0], color: "white", position: [0, 0, .1], fontSize: .3 }, "Processing...")), d && D.createElement("mesh", { position: [0, 1, -1.3] }, D.createElement("boxGeometry", { args: [3, 1, .1] }), D.createElement("meshBasicMaterial", { map: c }), D.createElement(_n, { rotation: [0, 0, 0], color: "white", position: [0, 0, .1], fontSize: .3 }, "Processing...")))) }, Dte = () => D.createElement(LW, { position: [-2, 0, 0] }, D.createElement("div", { style: { width: "100%", height: "100%", display: "flex", alignItems: "center" } }, D.createElement("div", { style: { color: "white", width: "500px" } }, D.createElement("span", null, "Initializing Simulation Sequence...")))); ky({ UnrealBloomPass: pw }); const Ote = () => { const { playBlockChain: n, showCard: e, radioClicked: t } = mi(r => r.DoubleSpendingReducer); return D.createElement(EW, { camera: { fov: 20, position: t === "conventional" ? [-10, 5, 30] : [-1, 5, 30] }, style: { height: "100vh", position: "absolute" } }, D.createElement(N.Suspense, { fallback: D.createElement(Dte, null) }, D.createElement(Lj, { disableGamma: !0 }, D.createElement("unrealBloomPass", { threshold: 1, strength: 1, radius: 1 })), D.createElement("ambientLight", null), D.createElement("pointLight", { position: [10, 10, 10] }), t === "conventional" && D.createElement(Lte, null), t === "blockChain" && D.createElement(hQ, null), D.createElement(Gj, { count: 200, scale: [60, 20, 10], size: 1.5, speed: 2 }), D.createElement("mesh", { castShadow: !0, receiveShadow: !0, "material-color": "#778", position: [-.1, .03, .07] }), D.createElement("color", { attach: "background", args: ["#2e3747"] }), D.createElement(Uj, { enableZoom: t !== "conventional" }))) }, Fte = () => { const n = oo(), { showLedger: e, showCancelAlert: t, isCancelation: r, radioClicked: i } = mi(s => s.DoubleSpendingReducer); N.useEffect(() => { const s = setTimeout(() => { n(aQ(!0)) }, 2e3); return () => clearTimeout(s) }, [n, i]); const o = () => { n(kv()), n(LU("cancel")), n(lr([])), n(BU(!1)), n(sQ(!0)) }; return D.createElement("div", { style: { height: "100%", position: "relative" } }, D.createElement(yte, { open: t, severity: "info", anchorOrigin: { vertical: "top", horizontal: "center" } }, D.createElement(yZ, { severity: "success", sx: { width: "100%" } }, "Confirm the cancellation of the DD request?", D.createElement("div", { style: { marginTop: 10, display: "flex", justifyContent: "center" } }, D.createElement("button", { onClick: o, style: { width: 150, padding: 2 } }, "Confirm")))), D.createElement(Ote, null), e && D.createElement(Rte, null)) }; function Ute() { const { radioClicked: n } = mi(r => r.DoubleSpendingReducer), e = oo(), t = r => { e($$(r.target.value)), e(IU(!0)) }; return N.createElement("div", { style: { display: "flex", justifyContent: "space-around" } }, N.createElement("div", { style: { display: "flex", alignItems: "center" } }, N.createElement(RB, { checked: n === "conventional", onChange: t, value: "conventional", name: "radio-buttons", sx: { color: ys[500], "&.Mui-checked": { color: ys[600] } } }), N.createElement(gf, { style: { color: "white" } }, "Conventional")), N.createElement("div", { style: { display: "flex", alignItems: "center" } }, N.createElement(RB, { checked: n === "blockChain", onChange: t, value: "blockChain", name: "radio-buttons", sx: { color: ys[500], "&.Mui-checked": { color: ys[600] } } }), N.createElement(gf, { style: { color: "white" } }, "BlockChain"))) } const BB = ({ text: n, onClick: e, isConventional: t = !1, isSceneLoaded: r }) => D.createElement("div", { style: { width: "100%", display: "flex", flexDirection: "column", alignItems: "center" } }, t ? D.createElement("p", { style: { padding: 5, color: "white", fontFamily: "sans-serif", fontSize: 15, lineHeight: 1.4 } }, "In a centralized banking system, when you make a payment or transfer money, the bank central authority keeps a ledger of all transactions. It ensures that you cannot spend the same money twice because it deducts the exact amount from your account when you make a payment. The bank has full control over the ledger and the ability to verify the authenticity of each transaction, so double spending is not a significant concern in this context.") : D.createElement("p", { style: { padding: 5, color: "white", fontFamily: "sans-serif", fontSize: 15, lineHeight: 1.4 } }, "In a blockchain-based system, when you make a payment or transfer digital assets, the ledger is decentralized and distributed across a network of nodes. This technology ensures that you cannot spend the same digital assets twice because it records the transaction on a public ledger. The blockchain network collectively verifies the authenticity of each transaction, making it highly resistant to double spending, as there is no central authority controlling the ledger."), r && D.createElement(vee, { style: { width: "100px", backgroundColor: "white", height: 40 }, onClick: () => e(t) }, D.createElement(i$, null), D.createElement("p", null, "Play"))); var kte = function (n) { return { display: n ? "flex" : "none" } }, IB = "#4fa94d", Nte = { "aria-busy": !0, role: "status" }, LB = globalThis && globalThis.__assign || function () { return LB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, LB.apply(this, arguments) }, DB = globalThis && globalThis.__assign || function () { return DB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, DB.apply(this, arguments) }, OB = globalThis && globalThis.__assign || function () { return OB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, OB.apply(this, arguments) }, FB = globalThis && globalThis.__assign || function () { return FB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, FB.apply(this, arguments) }, UB = globalThis && globalThis.__assign || function () { return UB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, UB.apply(this, arguments) }, kB = globalThis && globalThis.__assign || function () { return kB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, kB.apply(this, arguments) }, NB = globalThis && globalThis.__assign || function () { return NB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, NB.apply(this, arguments) }; function zte(n) { function e(k, Z, ee, ne, K) { for (var ae = 0, ie = 0, Se = 0, Ce = 0, le, F, me = 0, he = 0, ce, fe = ce = le = 0, Re = 0, de = 0, Ie = 0, we = 0, ge = ee.length, Ve = ge - 1, H, L = "", oe = "", Pe = "", Ae = "", ye; Re < ge;) { if (F = ee.charCodeAt(Re), Re === Ve && ie + Ce + Se + ae !== 0 && (ie !== 0 && (F = ie === 47 ? 10 : 47), Ce = Se = ae = 0, ge++, Ve++), ie + Ce + Se + ae === 0) { if (Re === Ve && (0 < de && (L = L.replace(p, "")), 0 < L.trim().length)) { switch (F) { case 32: case 9: case 59: case 13: case 10: break; default: L += ee.charAt(Re) }F = 59 } switch (F) { case 123: for (L = L.trim(), le = L.charCodeAt(0), ce = 1, we = ++Re; Re < ge;) { switch (F = ee.charCodeAt(Re)) { case 123: ce++; break; case 125: ce--; break; case 47: switch (F = ee.charCodeAt(Re + 1)) { case 42: case 47: e: { for (fe = Re + 1; fe < Ve; ++fe)switch (ee.charCodeAt(fe)) { case 47: if (F === 42 && ee.charCodeAt(fe - 1) === 42 && Re + 2 !== fe) { Re = fe + 1; break e } break; case 10: if (F === 47) { Re = fe + 1; break e } }Re = fe } }break; case 91: F++; case 40: F++; case 34: case 39: for (; Re++ < Ve && ee.charCodeAt(Re) !== F;); }if (ce === 0) break; Re++ } switch (ce = ee.substring(we, Re), le === 0 && (le = (L = L.replace(d, "").trim()).charCodeAt(0)), le) { case 64: switch (0 < de && (L = L.replace(p, "")), F = L.charCodeAt(1), F) { case 100: case 109: case 115: case 45: de = Z; break; default: de = q }if (ce = e(Z, de, ce, F, K + 1), we = ce.length, 0 < W && (de = t(q, L, Ie), ye = a(3, ce, de, Z, $, G, we, F, K, ne), L = de.join(""), ye !== void 0 && (we = (ce = ye.trim()).length) === 0 && (F = 0, ce = "")), 0 < we) switch (F) { case 115: L = L.replace(b, s); case 100: case 109: case 45: ce = L + "{" + ce + "}"; break; case 107: L = L.replace(x, "$1 $2"), ce = L + "{" + ce + "}", ce = j === 1 || j === 2 && o("@" + ce, 3) ? "@-webkit-" + ce + "@" + ce : "@" + ce; break; default: ce = L + ce, ne === 112 && (ce = (oe += ce, "")) } else ce = ""; break; default: ce = e(Z, t(Z, L, Ie), ce, ne, K + 1) }Pe += ce, ce = Ie = de = fe = le = 0, L = "", F = ee.charCodeAt(++Re); break; case 125: case 59: if (L = (0 < de ? L.replace(p, "") : L).trim(), 1 < (we = L.length)) switch (fe === 0 && (le = L.charCodeAt(0), le === 45 || 96 < le && 123 > le) && (we = (L = L.replace(" ", ":")).length), 0 < W && (ye = a(1, L, Z, k, $, G, oe.length, ne, K, ne)) !== void 0 && (we = (L = ye.trim()).length) === 0 && (L = "\0\0"), le = L.charCodeAt(0), F = L.charCodeAt(1), le) { case 0: break; case 64: if (F === 105 || F === 99) { Ae += L + ee.charAt(Re); break } default: L.charCodeAt(we - 1) !== 58 && (oe += i(L, le, F, L.charCodeAt(2))) }Ie = de = fe = le = 0, L = "", F = ee.charCodeAt(++Re) } } switch (F) { case 13: case 10: ie === 47 ? ie = 0 : 1 + le === 0 && ne !== 107 && 0 < L.length && (de = 1, L += "\0"), 0 < W * J && a(0, L, Z, k, $, G, oe.length, ne, K, ne), G = 1, $++; break; case 59: case 125: if (ie + Ce + Se + ae === 0) { G++; break } default: switch (G++, H = ee.charAt(Re), F) { case 9: case 32: if (Ce + ae + ie === 0) switch (me) { case 44: case 58: case 9: case 32: H = ""; break; default: F !== 32 && (H = " ") }break; case 0: H = "\\0"; break; case 12: H = "\\f"; break; case 11: H = "\\v"; break; case 38: Ce + ie + ae === 0 && (de = Ie = 1, H = "\f" + H); break; case 108: if (Ce + ie + ae + z === 0 && 0 < fe) switch (Re - fe) { case 2: me === 112 && ee.charCodeAt(Re - 3) === 58 && (z = me); case 8: he === 111 && (z = he) }break; case 58: Ce + ie + ae === 0 && (fe = Re); break; case 44: ie + Se + Ce + ae === 0 && (de = 1, H += "\r"); break; case 34: case 39: ie === 0 && (Ce = Ce === F ? 0 : Ce === 0 ? F : Ce); break; case 91: Ce + ie + Se === 0 && ae++; break; case 93: Ce + ie + Se === 0 && ae--; break; case 41: Ce + ie + ae === 0 && Se--; break; case 40: if (Ce + ie + ae === 0) { if (le === 0) switch (2 * me + 3 * he) { case 533: break; default: le = 1 }Se++ } break; case 64: ie + Se + Ce + ae + fe + ce === 0 && (ce = 1); break; case 42: case 47: if (!(0 < Ce + ae + Se)) switch (ie) { case 0: switch (2 * F + 3 * ee.charCodeAt(Re + 1)) { case 235: ie = 47; break; case 220: we = Re, ie = 42 }break; case 42: F === 47 && me === 42 && we + 2 !== Re && (ee.charCodeAt(we + 2) === 33 && (oe += ee.substring(we, Re + 1)), H = "", ie = 0) } }ie === 0 && (L += H) }he = me, me = F, Re++ } if (we = oe.length, 0 < we) { if (de = Z, 0 < W && (ye = a(2, oe, de, k, $, G, we, ne, K, ne), ye !== void 0 && (oe = ye).length === 0)) return Ae + oe + Pe; if (oe = de.join(",") + "{" + oe + "}", j * z !== 0) { switch (j !== 2 || o(oe, 2) || (z = 0), z) { case 111: oe = oe.replace(E, ":-moz-$1") + oe; break; case 112: oe = oe.replace(A, "::-webkit-input-$1") + oe.replace(A, "::-moz-$1") + oe.replace(A, ":-ms-input-$1") + oe }z = 0 } } return Ae + oe + Pe } function t(k, Z, ee) { var ne = Z.trim().split(_); Z = ne; var K = ne.length, ae = k.length; switch (ae) { case 0: case 1: var ie = 0; for (k = ae === 0 ? "" : k[0] + " "; ie < K; ++ie)Z[ie] = r(k, Z[ie], ee).trim(); break; default: var Se = ie = 0; for (Z = []; ie < K; ++ie)for (var Ce = 0; Ce < ae; ++Ce)Z[Se++] = r(k[Ce] + " ", ne[ie], ee).trim() }return Z } function r(k, Z, ee) { var ne = Z.charCodeAt(0); switch (33 > ne && (ne = (Z = Z.trim()).charCodeAt(0)), ne) { case 38: return Z.replace(g, "$1" + k.trim()); case 58: return k.trim() + Z.replace(g, "$1" + k.trim()); default: if (0 < 1 * ee && 0 < Z.indexOf("\f")) return Z.replace(g, (k.charCodeAt(0) === 58 ? "" : "$1") + k.trim()) }return k + Z } function i(k, Z, ee, ne) { var K = k + ";", ae = 2 * Z + 3 * ee + 4 * ne; if (ae === 944) { k = K.indexOf(":", 9) + 1; var ie = K.substring(k, K.length - 1).trim(); return ie = K.substring(0, k).trim() + ie + ";", j === 1 || j === 2 && o(ie, 1) ? "-webkit-" + ie + ie : ie } if (j === 0 || j === 2 && !o(K, 1)) return K; switch (ae) { case 1015: return K.charCodeAt(10) === 97 ? "-webkit-" + K + K : K; case 951: return K.charCodeAt(3) === 116 ? "-webkit-" + K + K : K; case 963: return K.charCodeAt(5) === 110 ? "-webkit-" + K + K : K; case 1009: if (K.charCodeAt(4) !== 100) break; case 969: case 942: return "-webkit-" + K + K; case 978: return "-webkit-" + K + "-moz-" + K + K; case 1019: case 983: return "-webkit-" + K + "-moz-" + K + "-ms-" + K + K; case 883: if (K.charCodeAt(8) === 45) return "-webkit-" + K + K; if (0 < K.indexOf("image-set(", 11)) return K.replace(U, "$1-webkit-$2") + K; break; case 932: if (K.charCodeAt(4) === 45) switch (K.charCodeAt(5)) { case 103: return "-webkit-box-" + K.replace("-grow", "") + "-webkit-" + K + "-ms-" + K.replace("grow", "positive") + K; case 115: return "-webkit-" + K + "-ms-" + K.replace("shrink", "negative") + K; case 98: return "-webkit-" + K + "-ms-" + K.replace("basis", "preferred-size") + K }return "-webkit-" + K + "-ms-" + K + K; case 964: return "-webkit-" + K + "-ms-flex-" + K + K; case 1023: if (K.charCodeAt(8) !== 99) break; return ie = K.substring(K.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + ie + "-webkit-" + K + "-ms-flex-pack" + ie + K; case 1005: return v.test(K) ? K.replace(m, ":-webkit-") + K.replace(m, ":-moz-") + K : K; case 1e3: switch (ie = K.substring(13).trim(), Z = ie.indexOf("-") + 1, ie.charCodeAt(0) + ie.charCodeAt(Z)) { case 226: ie = K.replace(w, "tb"); break; case 232: ie = K.replace(w, "tb-rl"); break; case 220: ie = K.replace(w, "lr"); break; default: return K }return "-webkit-" + K + "-ms-" + ie + K; case 1017: if (K.indexOf("sticky", 9) === -1) break; case 975: switch (Z = (K = k).length - 10, ie = (K.charCodeAt(Z) === 33 ? K.substring(0, Z) : K).substring(k.indexOf(":", 7) + 1).trim(), ae = ie.charCodeAt(0) + (ie.charCodeAt(7) | 0)) { case 203: if (111 > ie.charCodeAt(8)) break; case 115: K = K.replace(ie, "-webkit-" + ie) + ";" + K; break; case 207: case 102: K = K.replace(ie, "-webkit-" + (102 < ae ? "inline-" : "") + "box") + ";" + K.replace(ie, "-webkit-" + ie) + ";" + K.replace(ie, "-ms-" + ie + "box") + ";" + K }return K + ";"; case 938: if (K.charCodeAt(5) === 45) switch (K.charCodeAt(6)) { case 105: return ie = K.replace("-items", ""), "-webkit-" + K + "-webkit-box-" + ie + "-ms-flex-" + ie + K; case 115: return "-webkit-" + K + "-ms-flex-item-" + K.replace(B, "") + K; default: return "-webkit-" + K + "-ms-flex-line-pack" + K.replace("align-content", "").replace(B, "") + K }break; case 973: case 989: if (K.charCodeAt(3) !== 45 || K.charCodeAt(4) === 122) break; case 931: case 953: if (P.test(k) === !0) return (ie = k.substring(k.indexOf(":") + 1)).charCodeAt(0) === 115 ? i(k.replace("stretch", "fill-available"), Z, ee, ne).replace(":fill-available", ":stretch") : K.replace(ie, "-webkit-" + ie) + K.replace(ie, "-moz-" + ie.replace("fill-", "")) + K; break; case 962: if (K = "-webkit-" + K + (K.charCodeAt(5) === 102 ? "-ms-" + K : "") + K, ee + ne === 211 && K.charCodeAt(13) === 105 && 0 < K.indexOf("transform", 10)) return K.substring(0, K.indexOf(";", 27) + 1).replace(y, "$1-webkit-$2") + K }return K } function o(k, Z) { var ee = k.indexOf(Z === 1 ? ":" : "{"), ne = k.substring(0, Z !== 3 ? ee : 10); return ee = k.substring(ee + 1, k.length - 1), V(Z !== 2 ? ne : ne.replace(R, "$1"), ee, Z) } function s(k, Z) { var ee = i(Z, Z.charCodeAt(0), Z.charCodeAt(1), Z.charCodeAt(2)); return ee !== Z + ";" ? ee.replace(T, " or ($1)").substring(4) : "(" + Z + ")" } function a(k, Z, ee, ne, K, ae, ie, Se, Ce, le) { for (var F = 0, me = Z, he; F < W; ++F)switch (he = se[F].call(u, k, me, ee, ne, K, ae, ie, Se, Ce, le)) { case void 0: case !1: case !0: case null: break; default: me = he }if (me !== Z) return me } function l(k) { switch (k) { case void 0: case null: W = se.length = 0; break; default: if (typeof k == "function") se[W++] = k; else if (typeof k == "object") for (var Z = 0, ee = k.length; Z < ee; ++Z)l(k[Z]); else J = !!k | 0 }return l } function c(k) { return k = k.prefix, k !== void 0 && (V = null, k ? typeof k != "function" ? j = 1 : (j = 2, V = k) : j = 0), c } function u(k, Z) { var ee = k; if (33 > ee.charCodeAt(0) && (ee = ee.trim()), O = ee, ee = [O], 0 < W) { var ne = a(-1, Z, ee, ee, $, G, 0, 0, 0, 0); ne !== void 0 && typeof ne == "string" && (Z = ne) } var K = e(q, ee, Z, 0, 0); return 0 < W && (ne = a(-2, K, ee, ee, $, G, K.length, 0, 0, 0), ne !== void 0 && (K = ne)), O = "", z = 0, G = $ = 1, K } var d = /^\0+/g, p = /[\0\r\f]/g, m = /: */g, v = /zoo|gra/, y = /([,: ])(transform)/g, _ = /,\r+?/g, g = /([\t\r\n ])*\f?&/g, x = /@(k\w+)\s*(\S*)\s*/, A = /::(place)/g, E = /:(read-only)/g, w = /[svh]\w+-[tblr]{2}/, b = /\(\s*(.*)\s*\)/g, T = /([\s\S]*?);/g, B = /-self|flex-/g, R = /[^]*?(:[rp][el]a[\w-]+)[^]*/, P = /stretch|:\s*\w+\-(?:conte|avail)/, U = /([^-])(image-set\()/, G = 1, $ = 1, z = 0, j = 1, q = [], se = [], W = 0, V = null, J = 0, O = ""; return u.use = l, u.set = c, n !== void 0 && c(n), u } var Gte = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }; function da() { return (da = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }).apply(this, arguments) } var zB = function (n, e) { for (var t = [n[0]], r = 0, i = e.length; r < i; r += 1)t.push(e[r], n[r + 1]); return t }, AE = function (n) { return n !== null && typeof n == "object" && (n.toString ? n.toString() : Object.prototype.toString.call(n)) === "[object Object]" && !XF.typeOf(n) }, Gv = Object.freeze([]), yl = Object.freeze({}); function Tp(n) { return typeof n == "function" } function GB(n) { return n.displayName || n.name || "Component" } function ab(n) { return n && typeof n.styledComponentId == "string" } var td = typeof process < "u" && process.env !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", lb = typeof window < "u" && "HTMLElement" in window, Hte = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && ({}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" && {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY)); function rm(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; throw new Error("An error occurred. See https://git.io/JUIaE#" + n + " for more information." + (t.length > 0 ? " Args: " + t.join(", ") : "")) } var Vte = function () {
	function n(t) { this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t } var e = n.prototype; return e.indexOfGroup = function (t) { for (var r = 0, i = 0; i < t; i++)r += this.groupSizes[i]; return r }, e.insertRules = function (t, r) { if (t >= this.groupSizes.length) { for (var i = this.groupSizes, o = i.length, s = o; t >= s;)(s <<= 1) < 0 && rm(16, "" + t); this.groupSizes = new Uint32Array(s), this.groupSizes.set(i), this.length = s; for (var a = o; a < s; a++)this.groupSizes[a] = 0 } for (var l = this.indexOfGroup(t + 1), c = 0, u = r.length; c < u; c++)this.tag.insertRule(l, r[c]) && (this.groupSizes[t]++, l++) }, e.clearGroup = function (t) { if (t < this.length) { var r = this.groupSizes[t], i = this.indexOfGroup(t), o = i + r; this.groupSizes[t] = 0; for (var s = i; s < o; s++)this.tag.deleteRule(i) } }, e.getGroup = function (t) {
		var r = ""; if (t >= this.length || this.groupSizes[t] === 0) return r; for (var i = this.groupSizes[t], o = this.indexOfGroup(t), s = o + i, a = o; a < s; a++)r += this.tag.getRule(a) + `/*!sc*/
`; return r
	}, n
}(), J0 = new Map, Hv = new Map, kh = 1, v0 = function (n) { if (J0.has(n)) return J0.get(n); for (; Hv.has(kh);)kh++; var e = kh++; return J0.set(n, e), Hv.set(e, n), e }, Wte = function (n) { return Hv.get(n) }, jte = function (n, e) { e >= kh && (kh = e + 1), J0.set(n, e), Hv.set(e, n) }, Xte = "style[" + td + '][data-styled-version="5.3.11"]', Jte = new RegExp("^" + td + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), Kte = function (n, e, t) { for (var r, i = t.split(","), o = 0, s = i.length; o < s; o++)(r = i[o]) && n.registerName(e, r) }, Yte = function (n, e) {
	for (var t = (e.textContent || "").split(`/*!sc*/
`), r = [], i = 0, o = t.length; i < o; i++) { var s = t[i].trim(); if (s) { var a = s.match(Jte); if (a) { var l = 0 | parseInt(a[1], 10), c = a[2]; l !== 0 && (jte(c, l), Kte(n, c, a[3]), n.getTag().insertRules(l, r)), r.length = 0 } else r.push(s) } }
}, $te = function () { return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null }, QU = function (n) { var e = document.head, t = n || e, r = document.createElement("style"), i = function (a) { for (var l = a.childNodes, c = l.length; c >= 0; c--) { var u = l[c]; if (u && u.nodeType === 1 && u.hasAttribute(td)) return u } }(t), o = i !== void 0 ? i.nextSibling : null; r.setAttribute(td, "active"), r.setAttribute("data-styled-version", "5.3.11"); var s = $te(); return s && r.setAttribute("nonce", s), t.insertBefore(r, o), r }, Qte = function () { function n(t) { var r = this.element = QU(t); r.appendChild(document.createTextNode("")), this.sheet = function (i) { if (i.sheet) return i.sheet; for (var o = document.styleSheets, s = 0, a = o.length; s < a; s++) { var l = o[s]; if (l.ownerNode === i) return l } rm(17) }(r), this.length = 0 } var e = n.prototype; return e.insertRule = function (t, r) { try { return this.sheet.insertRule(r, t), this.length++, !0 } catch { return !1 } }, e.deleteRule = function (t) { this.sheet.deleteRule(t), this.length-- }, e.getRule = function (t) { var r = this.sheet.cssRules[t]; return r !== void 0 && typeof r.cssText == "string" ? r.cssText : "" }, n }(), Zte = function () { function n(t) { var r = this.element = QU(t); this.nodes = r.childNodes, this.length = 0 } var e = n.prototype; return e.insertRule = function (t, r) { if (t <= this.length && t >= 0) { var i = document.createTextNode(r), o = this.nodes[t]; return this.element.insertBefore(i, o || null), this.length++, !0 } return !1 }, e.deleteRule = function (t) { this.element.removeChild(this.nodes[t]), this.length-- }, e.getRule = function (t) { return t < this.length ? this.nodes[t].textContent : "" }, n }(), qte = function () { function n(t) { this.rules = [], this.length = 0 } var e = n.prototype; return e.insertRule = function (t, r) { return t <= this.length && (this.rules.splice(t, 0, r), this.length++, !0) }, e.deleteRule = function (t) { this.rules.splice(t, 1), this.length-- }, e.getRule = function (t) { return t < this.length ? this.rules[t] : "" }, n }(), HB = lb, ene = { isServer: !lb, useCSSOMInjection: !Hte }, ZU = function () {
	function n(t, r, i) { t === void 0 && (t = yl), r === void 0 && (r = {}), this.options = da({}, ene, {}, t), this.gs = r, this.names = new Map(i), this.server = !!t.isServer, !this.server && lb && HB && (HB = !1, function (o) { for (var s = document.querySelectorAll(Xte), a = 0, l = s.length; a < l; a++) { var c = s[a]; c && c.getAttribute(td) !== "active" && (Yte(o, c), c.parentNode && c.parentNode.removeChild(c)) } }(this)) } n.registerId = function (t) { return v0(t) }; var e = n.prototype; return e.reconstructWithOptions = function (t, r) { return r === void 0 && (r = !0), new n(da({}, this.options, {}, t), this.gs, r && this.names || void 0) }, e.allocateGSInstance = function (t) { return this.gs[t] = (this.gs[t] || 0) + 1 }, e.getTag = function () { return this.tag || (this.tag = (i = (r = this.options).isServer, o = r.useCSSOMInjection, s = r.target, t = i ? new qte(s) : o ? new Qte(s) : new Zte(s), new Vte(t))); var t, r, i, o, s }, e.hasNameForId = function (t, r) { return this.names.has(t) && this.names.get(t).has(r) }, e.registerName = function (t, r) { if (v0(t), this.names.has(t)) this.names.get(t).add(r); else { var i = new Set; i.add(r), this.names.set(t, i) } }, e.insertRules = function (t, r, i) { this.registerName(t, r), this.getTag().insertRules(v0(t), i) }, e.clearNames = function (t) { this.names.has(t) && this.names.get(t).clear() }, e.clearRules = function (t) { this.getTag().clearGroup(v0(t)), this.clearNames(t) }, e.clearTag = function () { this.tag = void 0 }, e.toString = function () {
		return function (t) {
			for (var r = t.getTag(), i = r.length, o = "", s = 0; s < i; s++) {
				var a = Wte(s); if (a !== void 0) {
					var l = t.names.get(a), c = r.getGroup(s); if (l && c && l.size) {
						var u = td + ".g" + s + '[id="' + a + '"]', d = ""; l !== void 0 && l.forEach(function (p) { p.length > 0 && (d += p + ",") }), o += "" + c + u + '{content:"' + d + `"}/*!sc*/
`}
				}
			} return o
		}(this)
	}, n
}(), tne = /(a)(d)/gi, VB = function (n) { return String.fromCharCode(n + (n > 25 ? 39 : 97)) }; function EE(n) { var e, t = ""; for (e = Math.abs(n); e > 52; e = e / 52 | 0)t = VB(e % 52) + t; return (VB(e % 52) + t).replace(tne, "$1-$2") } var vf = function (n, e) { for (var t = e.length; t;)n = 33 * n ^ e.charCodeAt(--t); return n }, qU = function (n) { return vf(5381, n) }; function nne(n) { for (var e = 0; e < n.length; e += 1) { var t = n[e]; if (Tp(t) && !ab(t)) return !1 } return !0 } var rne = qU("5.3.11"), ine = function () { function n(e, t, r) { this.rules = e, this.staticRulesId = "", this.isStatic = (r === void 0 || r.isStatic) && nne(e), this.componentId = t, this.baseHash = vf(rne, t), this.baseStyle = r, ZU.registerId(t) } return n.prototype.generateAndInjectStyles = function (e, t, r) { var i = this.componentId, o = []; if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e, t, r)), this.isStatic && !r.hash) if (this.staticRulesId && t.hasNameForId(i, this.staticRulesId)) o.push(this.staticRulesId); else { var s = nd(this.rules, e, t, r).join(""), a = EE(vf(this.baseHash, s) >>> 0); if (!t.hasNameForId(i, a)) { var l = r(s, "." + a, void 0, i); t.insertRules(i, a, l) } o.push(a), this.staticRulesId = a } else { for (var c = this.rules.length, u = vf(this.baseHash, r.hash), d = "", p = 0; p < c; p++) { var m = this.rules[p]; if (typeof m == "string") d += m; else if (m) { var v = nd(m, e, t, r), y = Array.isArray(v) ? v.join("") : v; u = vf(u, y + p), d += y } } if (d) { var _ = EE(u >>> 0); if (!t.hasNameForId(i, _)) { var g = r(d, "." + _, void 0, i); t.insertRules(i, _, g) } o.push(_) } } return o.join(" ") }, n }(), one = /^\s*\/\/.*$/gm, sne = [":", "[", ".", "#"]; function ane(n) { var e, t, r, i, o = n === void 0 ? yl : n, s = o.options, a = s === void 0 ? yl : s, l = o.plugins, c = l === void 0 ? Gv : l, u = new zte(a), d = [], p = function (y) { function _(g) { if (g) try { y(g + "}") } catch { } } return function (g, x, A, E, w, b, T, B, R, P) { switch (g) { case 1: if (R === 0 && x.charCodeAt(0) === 64) return y(x + ";"), ""; break; case 2: if (B === 0) return x + "/*|*/"; break; case 3: switch (B) { case 102: case 112: return y(A[0] + x), ""; default: return x + (P === 0 ? "/*|*/" : "") }case -2: x.split("/*|*/}").forEach(_) } } }(function (y) { d.push(y) }), m = function (y, _, g) { return _ === 0 && sne.indexOf(g[t.length]) !== -1 || g.match(i) ? y : "." + e }; function v(y, _, g, x) { x === void 0 && (x = "&"); var A = y.replace(one, ""), E = _ && g ? g + " " + _ + " { " + A + " }" : A; return e = x, t = _, r = new RegExp("\\" + t + "\\b", "g"), i = new RegExp("(\\" + t + "\\b){2,}"), u(g || !_ ? "" : _, E) } return u.use([].concat(c, [function (y, _, g) { y === 2 && g.length && g[0].lastIndexOf(t) > 0 && (g[0] = g[0].replace(r, m)) }, p, function (y) { if (y === -2) { var _ = d; return d = [], _ } }])), v.hash = c.length ? c.reduce(function (y, _) { return _.name || rm(15), vf(y, _.name) }, 5381).toString() : "", v } var ek = D.createContext(); ek.Consumer; var tk = D.createContext(), lne = (tk.Consumer, new ZU), ME = ane(); function cne() { return N.useContext(ek) || lne } function une() { return N.useContext(tk) || ME } var nk = function () { function n(e, t) { var r = this; this.inject = function (i, o) { o === void 0 && (o = ME); var s = r.name + o.hash; i.hasNameForId(r.id, s) || i.insertRules(r.id, s, o(r.rules, s, "@keyframes")) }, this.toString = function () { return rm(12, String(r.name)) }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = t } return n.prototype.getName = function (e) { return e === void 0 && (e = ME), this.name + e.hash }, n }(), fne = /([A-Z])/, dne = /([A-Z])/g, hne = /^ms-/, pne = function (n) { return "-" + n.toLowerCase() }; function WB(n) { return fne.test(n) ? n.replace(dne, pne).replace(hne, "-ms-") : n } var jB = function (n) { return n == null || n === !1 || n === "" }; function nd(n, e, t, r) { if (Array.isArray(n)) { for (var i, o = [], s = 0, a = n.length; s < a; s += 1)(i = nd(n[s], e, t, r)) !== "" && (Array.isArray(i) ? o.push.apply(o, i) : o.push(i)); return o } if (jB(n)) return ""; if (ab(n)) return "." + n.styledComponentId; if (Tp(n)) { if (typeof (c = n) != "function" || c.prototype && c.prototype.isReactComponent || !e) return n; var l = n(e); return nd(l, e, t, r) } var c; return n instanceof nk ? t ? (n.inject(t, r), n.getName(r)) : n : AE(n) ? function u(d, p) { var m, v, y = []; for (var _ in d) d.hasOwnProperty(_) && !jB(d[_]) && (Array.isArray(d[_]) && d[_].isCss || Tp(d[_]) ? y.push(WB(_) + ":", d[_], ";") : AE(d[_]) ? y.push.apply(y, u(d[_], _)) : y.push(WB(_) + ": " + (m = _, (v = d[_]) == null || typeof v == "boolean" || v === "" ? "" : typeof v != "number" || v === 0 || m in Gte || m.startsWith("--") ? String(v).trim() : v + "px") + ";")); return p ? [p + " {"].concat(y, ["}"]) : y }(n) : n.toString() } var XB = function (n) { return Array.isArray(n) && (n.isCss = !0), n }; function rk(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; return Tp(n) || AE(n) ? XB(nd(zB(Gv, [n].concat(t)))) : t.length === 0 && n.length === 1 && typeof n[0] == "string" ? n : XB(nd(zB(n, t))) } var mne = function (n, e, t) { return t === void 0 && (t = yl), n.theme !== t.theme && n.theme || e || t.theme }, gne = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, vne = /(^-|-$)/g; function nS(n) { return n.replace(gne, "-").replace(vne, "") } var ik = function (n) { return EE(qU(n) >>> 0) }; function y0(n) { return typeof n == "string" && !0 } var wE = function (n) { return typeof n == "function" || typeof n == "object" && n !== null && !Array.isArray(n) }, yne = function (n) { return n !== "__proto__" && n !== "constructor" && n !== "prototype" }; function _ne(n, e, t) { var r = n[t]; wE(e) && wE(r) ? ok(r, e) : n[t] = e } function ok(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; for (var i = 0, o = t; i < o.length; i++) { var s = o[i]; if (wE(s)) for (var a in s) yne(a) && _ne(n, s[a], a) } return n } var sk = D.createContext(); sk.Consumer; var rS = {}; function ak(n, e, t) { var r = ab(n), i = !y0(n), o = e.attrs, s = o === void 0 ? Gv : o, a = e.componentId, l = a === void 0 ? function (x, A) { var E = typeof x != "string" ? "sc" : nS(x); rS[E] = (rS[E] || 0) + 1; var w = E + "-" + ik("5.3.11" + E + rS[E]); return A ? A + "-" + w : w }(e.displayName, e.parentComponentId) : a, c = e.displayName, u = c === void 0 ? function (x) { return y0(x) ? "styled." + x : "Styled(" + GB(x) + ")" }(n) : c, d = e.displayName && e.componentId ? nS(e.displayName) + "-" + e.componentId : e.componentId || l, p = r && n.attrs ? Array.prototype.concat(n.attrs, s).filter(Boolean) : s, m = e.shouldForwardProp; r && n.shouldForwardProp && (m = e.shouldForwardProp ? function (x, A, E) { return n.shouldForwardProp(x, A, E) && e.shouldForwardProp(x, A, E) } : n.shouldForwardProp); var v, y = new ine(t, d, r ? n.componentStyle : void 0), _ = y.isStatic && s.length === 0, g = function (x, A) { return function (E, w, b, T) { var B = E.attrs, R = E.componentStyle, P = E.defaultProps, U = E.foldedComponentIds, G = E.shouldForwardProp, $ = E.styledComponentId, z = E.target, j = function (ne, K, ae) { ne === void 0 && (ne = yl); var ie = da({}, K, { theme: ne }), Se = {}; return ae.forEach(function (Ce) { var le, F, me, he = Ce; for (le in Tp(he) && (he = he(ie)), he) ie[le] = Se[le] = le === "className" ? (F = Se[le], me = he[le], F && me ? F + " " + me : F || me) : he[le] }), [ie, Se] }(mne(w, N.useContext(sk), P) || yl, w, B), q = j[0], se = j[1], W = function (ne, K, ae, ie) { var Se = cne(), Ce = une(), le = K ? ne.generateAndInjectStyles(yl, Se, Ce) : ne.generateAndInjectStyles(ae, Se, Ce); return le }(R, T, q), V = b, J = se.$as || w.$as || se.as || w.as || z, O = y0(J), k = se !== w ? da({}, w, {}, se) : w, Z = {}; for (var ee in k) ee[0] !== "$" && ee !== "as" && (ee === "forwardedAs" ? Z.as = k[ee] : (G ? G(ee, nE, J) : !O || nE(ee)) && (Z[ee] = k[ee])); return w.style && se.style !== w.style && (Z.style = da({}, w.style, {}, se.style)), Z.className = Array.prototype.concat(U, $, W !== $ ? W : null, w.className, se.className).filter(Boolean).join(" "), Z.ref = V, N.createElement(J, Z) }(v, x, A, _) }; return g.displayName = u, (v = D.forwardRef(g)).attrs = p, v.componentStyle = y, v.displayName = u, v.shouldForwardProp = m, v.foldedComponentIds = r ? Array.prototype.concat(n.foldedComponentIds, n.styledComponentId) : Gv, v.styledComponentId = d, v.target = r ? n.target : n, v.withComponent = function (x) { var A = e.componentId, E = function (b, T) { if (b == null) return {}; var B, R, P = {}, U = Object.keys(b); for (R = 0; R < U.length; R++)B = U[R], T.indexOf(B) >= 0 || (P[B] = b[B]); return P }(e, ["componentId"]), w = A && A + "-" + (y0(x) ? x : nS(GB(x))); return ak(x, da({}, E, { attrs: p, componentId: w }), t) }, Object.defineProperty(v, "defaultProps", { get: function () { return this._foldedDefaultProps }, set: function (x) { this._foldedDefaultProps = r ? ok({}, n.defaultProps, x) : x } }), Object.defineProperty(v, "toString", { value: function () { return "." + v.styledComponentId } }), i && PX(v, n, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), v } var bE = function (n) { return function e(t, r, i) { if (i === void 0 && (i = yl), !XF.isValidElementType(r)) return rm(1, String(r)); var o = function () { return t(r, i, rk.apply(void 0, arguments)) }; return o.withConfig = function (s) { return e(t, r, da({}, i, {}, s)) }, o.attrs = function (s) { return e(t, r, da({}, i, { attrs: Array.prototype.concat(i.attrs, s).filter(Boolean) })) }, o }(ak, n) };["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function (n) { bE[n] = bE(n) }); function cb(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; var i = rk.apply(void 0, [n].concat(t)).join(""), o = ik(i); return new nk(o, i) } const im = bE; var lk = globalThis && globalThis.__makeTemplateObject || function (n, e) { return Object.defineProperty ? Object.defineProperty(n, "raw", { value: e }) : n.raw = e, n }, zo = 242.776657104492, xne = 1.6, Sne = cb(JB || (JB = lk([`
  12.5% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
  43.75% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
  100% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
`], [`
  12.5% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
  43.75% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
  100% {
    stroke-dasharray: `, "px, ", `px;
    stroke-dashoffset: -`, `px;
  }
`])), zo * .14, zo, zo * .11, zo * .35, zo, zo * .35, zo * .01, zo, zo * .99); im.path(KB || (KB = lk([`
  stroke-dasharray: `, "px, ", `;
  stroke-dashoffset: 0;
  animation: `, " ", `s linear infinite;
`], [`
  stroke-dasharray: `, "px, ", `;
  stroke-dashoffset: 0;
  animation: `, " ", `s linear infinite;
`])), zo * .01, zo, Sne, xne); var JB, KB, YB = globalThis && globalThis.__assign || function () { return YB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, YB.apply(this, arguments) }, $B = globalThis && globalThis.__assign || function () { return $B = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, $B.apply(this, arguments) }, Nh = globalThis && globalThis.__assign || function () { return Nh = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, Nh.apply(this, arguments) }, iS = 20, Ane = function (n) { return ["M" + n + " 0c0-9.94-8.06", n, n, n].join("-") }, Ene = function (n, e, t) { var r = Math.max(n, e), i = -t - r / 2 + 1, o = t * 2 + r; return [i, i, o, o].join(" ") }, Mne = function (n) { var e = n.height, t = e === void 0 ? 80 : e, r = n.width, i = r === void 0 ? 80 : r, o = n.color, s = o === void 0 ? IB : o, a = n.secondaryColor, l = a === void 0 ? IB : a, c = n.ariaLabel, u = c === void 0 ? "oval-loading" : c, d = n.wrapperStyle, p = n.wrapperClass, m = n.visible, v = m === void 0 ? !0 : m, y = n.strokeWidth, _ = y === void 0 ? 2 : y, g = n.strokeWidthSecondary; return D.createElement("div", Nh({ style: Nh(Nh({}, kte(v)), d), className: p, "data-testid": "oval-loading", "aria-label": u }, Nte), D.createElement("svg", { width: i, height: t, viewBox: Ene(Number(_), Number(g || _), iS), xmlns: "http://www.w3.org/2000/svg", stroke: s, "data-testid": "oval-svg" }, D.createElement("g", { fill: "none", fillRule: "evenodd" }, D.createElement("g", { transform: "translate(1 1)", strokeWidth: Number(g || _), "data-testid": "oval-secondary-group" }, D.createElement("circle", { strokeOpacity: ".5", cx: "0", cy: "0", r: iS, stroke: l, strokeWidth: _ }), D.createElement("path", { d: Ane(iS) }, D.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 0 0", to: "360 0 0", dur: "1s", repeatCount: "indefinite" })))))) }, QB = globalThis && globalThis.__assign || function () { return QB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, QB.apply(this, arguments) }, ZB = globalThis && globalThis.__assign || function () { return ZB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, ZB.apply(this, arguments) }, qB = globalThis && globalThis.__assign || function () { return qB = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, qB.apply(this, arguments) }, e3 = globalThis && globalThis.__assign || function () { return e3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, e3.apply(this, arguments) }, wne = function (e, t) { return function () { var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (typeof r[e] < "u") return r[e]; if (e && e.indexOf(".") > 0) { for (var i = e.split("."), o = i.length, s = r[i[0]], a = 1; s != null && a < o;)s = s[i[a]], a += 1; if (typeof s < "u") return s } return t } }, ub = globalThis && globalThis.__makeTemplateObject || function (n, e) { return Object.defineProperty ? Object.defineProperty(n, "raw", { value: e }) : n.raw = e, n }, t3 = globalThis && globalThis.__assign || function () { return t3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, t3.apply(this, arguments) }, bne = cb(n3 || (n3 = ub([`
 to {
    transform: rotate(360deg);
  }
`], [`
 to {
    transform: rotate(360deg);
  }
`]))); im.svg(r3 || (r3 = ub([`
  animation: `, ` 0.75s steps(12, end) infinite;
  animation-duration: `, `s;
`], [`
  animation: `, ` 0.75s steps(12, end) infinite;
  animation-duration: `, `s;
`])), bne, wne("speed", "0.75")); im.polyline(i3 || (i3 = ub([`
  stroke-width: `, `px;
  stroke-linecap: round;

  &:nth-child(12n + 0) {
    stroke-opacity: 0.08;
  }

  &:nth-child(12n + 1) {
    stroke-opacity: 0.17;
  }

  &:nth-child(12n + 2) {
    stroke-opacity: 0.25;
  }

  &:nth-child(12n + 3) {
    stroke-opacity: 0.33;
  }

  &:nth-child(12n + 4) {
    stroke-opacity: 0.42;
  }

  &:nth-child(12n + 5) {
    stroke-opacity: 0.5;
  }

  &:nth-child(12n + 6) {
    stroke-opacity: 0.58;
  }

  &:nth-child(12n + 7) {
    stroke-opacity: 0.66;
  }

  &:nth-child(12n + 8) {
    stroke-opacity: 0.75;
  }

  &:nth-child(12n + 9) {
    stroke-opacity: 0.83;
  }

  &:nth-child(12n + 11) {
    stroke-opacity: 0.92;
  }
`], [`
  stroke-width: `, `px;
  stroke-linecap: round;

  &:nth-child(12n + 0) {
    stroke-opacity: 0.08;
  }

  &:nth-child(12n + 1) {
    stroke-opacity: 0.17;
  }

  &:nth-child(12n + 2) {
    stroke-opacity: 0.25;
  }

  &:nth-child(12n + 3) {
    stroke-opacity: 0.33;
  }

  &:nth-child(12n + 4) {
    stroke-opacity: 0.42;
  }

  &:nth-child(12n + 5) {
    stroke-opacity: 0.5;
  }

  &:nth-child(12n + 6) {
    stroke-opacity: 0.58;
  }

  &:nth-child(12n + 7) {
    stroke-opacity: 0.66;
  }

  &:nth-child(12n + 8) {
    stroke-opacity: 0.75;
  }

  &:nth-child(12n + 9) {
    stroke-opacity: 0.83;
  }

  &:nth-child(12n + 11) {
    stroke-opacity: 0.92;
  }
`])), function (n) { return n.width }); var n3, r3, i3, o3 = globalThis && globalThis.__assign || function () { return o3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, o3.apply(this, arguments) }, s3 = globalThis && globalThis.__assign || function () { return s3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, s3.apply(this, arguments) }, a3 = globalThis && globalThis.__assign || function () { return a3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, a3.apply(this, arguments) }, fb = globalThis && globalThis.__makeTemplateObject || function (n, e) { return Object.defineProperty ? Object.defineProperty(n, "raw", { value: e }) : n.raw = e, n }, l3 = globalThis && globalThis.__assign || function () { return l3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, l3.apply(this, arguments) }, Cne = cb(c3 || (c3 = fb([`
 to {
    stroke-dashoffset: 136;
  }
`], [`
 to {
    stroke-dashoffset: 136;
  }
`]))); im.polygon(u3 || (u3 = fb([`
  stroke-dasharray: 17;
  animation: `, ` 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;
`], [`
  stroke-dasharray: 17;
  animation: `, ` 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;
`])), Cne); im.svg(f3 || (f3 = fb([`
  transform-origin: 50% 65%;
`], [`
  transform-origin: 50% 65%;
`]))); var c3, u3, f3, d3 = globalThis && globalThis.__assign || function () { return d3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, d3.apply(this, arguments) }, h3 = globalThis && globalThis.__assign || function () { return h3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, h3.apply(this, arguments) }, p3 = globalThis && globalThis.__assign || function () { return p3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, p3.apply(this, arguments) }, m3 = globalThis && globalThis.__assign || function () { return m3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, m3.apply(this, arguments) }, g3 = globalThis && globalThis.__assign || function () { return g3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, g3.apply(this, arguments) }, v3 = globalThis && globalThis.__assign || function () { return v3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, v3.apply(this, arguments) }, y3 = globalThis && globalThis.__assign || function () { return y3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, y3.apply(this, arguments) }, _3 = globalThis && globalThis.__assign || function () { return _3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, _3.apply(this, arguments) }, x3 = globalThis && globalThis.__assign || function () { return x3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, x3.apply(this, arguments) }, S3 = globalThis && globalThis.__assign || function () { return S3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, S3.apply(this, arguments) }, A3 = globalThis && globalThis.__assign || function () { return A3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, A3.apply(this, arguments) }, E3 = globalThis && globalThis.__assign || function () { return E3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, E3.apply(this, arguments) }, M3 = globalThis && globalThis.__assign || function () { return M3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, M3.apply(this, arguments) }, w3 = globalThis && globalThis.__assign || function () { return w3 = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) { e = arguments[t]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]) } return n }, w3.apply(this, arguments) }; const Tne = () => { const { userDetails: n, userBalance: e, playBlockChain: t, showCard: r, isTransactionProgressing: i, showSideOption: o, instructionMessage: s, radioClicked: a, clickedTime: l, userBalanceBlockChain: c, isRestart: u, isSceneLoaded: d } = mi(b => b.DoubleSpendingReducer), [p, m] = N.useState({ receiver: "", amount: 0, isErr: !1, isAmountErr: !1, showCard: !1, id: 1, clickedTime: 0 }), [v, y] = N.useState(!1), [_, g] = N.useState(""), x = oo(), A = b => { const { name: T, value: B } = b.target; m(R => ({ ...R, [T]: B.toUpperCase() })) }, E = () => { if (p.receiver !== "" && p.amount > "0") { const b = { id: p.id, receiverName: p.receiver, amount: Number(p.amount) }; m(T => ({ ...T, isErr: !1, isAmountErr: !1, id: p.id + 1 })), a === "conventional" ? (x(lr([...s, `Ram has chosen to transmit ${p.amount} rupees to ${p.receiver} by means of a Demand Draft (DD).`])), x(q$(!0)), x(tB(p.receiver)), x(ZP(b)), x(eB()), x(Q$(p.amount)), x(kv())) : ["B", "C", "D", "E"].includes(p.receiver) ? (x(tB(p.receiver)), x(Z$(c - p.amount)), x(ZP(b)), x(Kw(!0)), x(eB()), x(dE(!1)), x(DU("W")), x(oQ(l + 1)), l >= 1 ? x(lr(["Initially there will be five users, with each block representing distinct blocks in the blockchain ", `A initiates a transfer of Rs ${p.amount} to ${p.receiver}`])) : x(lr([...s, `A initiates a transfer of Rs ${p.amount} to ${p.receiver}`])), p.amount <= c ? (y(!0), setTimeout(() => { y(!1), g("") }, 8e3)) : (y(!0), setTimeout(() => { y(!1), g("Rejected") }, 8e3))) : m(T => ({ ...T, isErr: !0 })) } p.receiver === "" && m(b => ({ ...b, isErr: !0 })), p.amount === 0 && m(b => ({ ...b, isAmountErr: !0 })) }, w = () => { a !== "conventional" ? (x(qP({ setType: "playBlockChain", showCard: !0 })), x(lr([...s, "Initially there will be five users, with each block representing distinct blocks in the blockchain "]))) : x(qP({ setType: "conventional", showCard: !0 })) }; return N.useEffect(() => { m(b => ({ ...b, isAmountErr: !1, receiver: "", amount: 0, isErr: !1 })) }, [a, u]), D.createElement("div", { style: { paddingBlock: 15, paddingInline: 10, borderWidth: 5 } }, r ? o ? D.createElement("div", { style: { borderStyle: "solid", borderWidth: "1px", borderBlockColor: "#1BFAFF", position: "relative", borderInlineColor: "#1bfaff" } }, D.createElement("div", { style: { position: "absolute", background: "#313b5d", top: -25, left: "35%", width: 100, padding: 3, display: "flex", justifyContent: "center", borderRadius: 50 } }, D.createElement("p", { style: { fontSize: 15, color: "white" } }, "User Account")), D.createElement(Eee, { style: { backgroundColor: "transparent", border: "none", boxShadow: "none", display: "flex", flexDirection: "column" } }, D.createElement(wB, null, D.createElement("div", { style: { display: "flex", flexDirection: "column", alignItems: "flex-end", width: "100%", paddingBlock: 15 } }, a !== "conventional" && D.createElement("div", { style: { display: "flex" } }, D.createElement(gf, { sx: { color: "white", fontSize: 15 } }, "Balance :", "     "), D.createElement(gf, { sx: { color: "yellow", fontWeight: 800, fontSize: 16 } }, "      ", c, " ₹")), D.createElement("div", { style: { display: "flex" } }, D.createElement(gf, { sx: { color: "white", fontSize: 15 } }, "Sender :", "  "), D.createElement(gf, { sx: { color: "yellow", fontWeight: 800, fontSize: 16 } }, " ", a === "conventional" ? "Ram" : " A")))), D.createElement(wB, null, D.createElement("div", { style: { display: "flex", flexDirection: "column", alignItems: "center" } }, D.createElement("div", { style: { display: "flex", flexDirection: "column", justifyContent: "flex-start", marginBlock: 2 } }, D.createElement("label", { style: { color: "white" } }, "Receiver"), D.createElement("input", { name: "receiver", value: p.receiver, style: { padding: 10, border: "none", outline: "none", marginBlock: 5, boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px", width: 240 }, placeholder: "Receiver", onChange: A }), p.isErr && a !== "conventional" && D.createElement("span", { style: { color: "red" } }, !["B", "C", "D", "E"].includes(p.receiver) && "Please Enter valid receiver name (B,C,D,E)"), p.isErr && a === "conventional" && D.createElement("span", { style: { color: "red" } }, "Please enter receiver name")), D.createElement("div", { style: { display: "flex", flexDirection: "column", justifyContent: "flex-start", marginBlock: 2 } }, D.createElement("label", { style: { color: "white" } }, "Amount"), D.createElement("input", { name: "amount", value: p.amount, type: "number", style: { padding: 10, border: "none", outline: "none", marginBlock: 5, boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px", width: 240 }, placeholder: "Amount", onChange: A }), p.isAmountErr && D.createElement("span", { style: { color: "red" } }, "Amount should be greater than 0")))), D.createElement(Ree, null, D.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", width: "100%", flexDirection: "column" } }, D.createElement("button", { disabled: i, style: { backgroundColor: "#64aed0", border: "none", padding: 10, borderRadius: 20, width: "120px", marginBottom: 10, color: "white", boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px" }, onClick: E }, v ? D.createElement("div", { style: { width: "100%", display: "flex", justifyContent: "center" } }, D.createElement(Mne, { height: 15, width: 15, color: "yellow", wrapperStyle: {}, wrapperClass: "", visible: !0, ariaLabel: "oval-loading", secondaryColor: "yellow", strokeWidth: 2, strokeWidthSecondary: 2 }), D.createElement("span", { style: { marginLeft: 5 } }, "processing")) : "Send"))))) : D.createElement(D.Fragment, null) : a !== "conventional" ? D.createElement(BB, { onClick: w, isSceneLoaded: d }) : D.createElement(BB, { onClick: w, isConventional: !0, isSceneLoaded: d })) }, Rne = () => { const n = oo(), e = () => { n(rQ()) }; return D.createElement("div", { style: { background: "linear-gradient(170deg, rgb(56 68 139 / 59%) -70.38%, rgba(3, 124, 235, 0.00) 140.44%)", padding: 2, height: "100%" } }, D.createElement("div", { style: { backgroundColor: "white", position: "relative" } }, D.createElement("h4", { style: { textAlign: "center", margin: 0, paddingBlock: 15, textTransform: "uppercase", fontFamily: "sans-serif", fontSize: 15, color: "black" } }, "Double Spending"), D.createElement(FU, { onClick: e, style: { position: "absolute", right: 0, top: 2 } }, D.createElement(Tte, { title: "restart" }, D.createElement(o$, { style: { color: "#313b5e" }, color: "#313b5e" })))), D.createElement("div", { style: { paddingTop: 15, marginBottom: 40 } }, D.createElement(Ute, null)), D.createElement("div", { style: { height: "80%" } }, D.createElement(Tne, null))) }, Pne = () => { const { receiverName: n, verifierName: e, selectedColor: t, waiting: r, radioClicked: i, showCard: o, clickedTime: s, userBalanceBlockChain: a, instructionMessage: l } = mi(b => b.DoubleSpendingReducer), c = oo(), { sender: u, receiver: d, verifier: p } = t, [m, v] = N.useState(!1), [y, _] = N.useState(!1), g = n === "B" ? `One among C,D,E is required to verify the transaction while A and ${n} waits ` : n === "C" ? `One among ,B,D,E is required to verify the transaction while A and ${n} waits` : n === "D" ? `One among B,C,E is required to verify the transaction while A and ${n} waits` : n === "E" ? `One among B,C,D is required to verify the transaction while A and ${n} waits` : "", x = n === "B" ? ["C", "D", "E"] : n === "C" ? ["B", "D", "E"] : n === "D" ? ["B", "C", "E"] : n === "E" ? ["B", "C", "D"] : "", A = b => { const { name: T, value: B } = b.target, R = { ...t, [T]: B }; c(iQ(R)) }; N.useEffect(() => { let b; if (r && i !== "conventional") return b = setTimeout(() => { c(lr([...l, g])), v(!0), _(!1) }, 2500), () => clearTimeout(b) }, [r]), N.useEffect(() => { let b; if (m && i !== "conventional") return b = setTimeout(() => { c(lr([...l, "select from one of the three option to act as the verifier    "])), v(!0) }, 1500), () => clearTimeout(b) }, [m]); const E = b => { console.log(s), c(DU(b)), c(lr([...l, `User-${b} Verifing the transaction.... `])), setTimeout(() => { c(lr([...l, `User-${b} Verify the transaction to ensure it's valid and conforms to the network's rules, such as having sufficient funds in your account to make the transfer.`])) }, 2e3), setTimeout(() => { a < 0 ? (c(lr([...l, `During the verification process, User-${b} detects that User A's account has insufficient balance to cover the transaction amount. `, `User-${b} concludes that the transaction should be rejected due to insufficient balance, and they communicate this decision to the network.`, `<span style="color: white; font-weight: bold; background-color: red; padding: 2px; border-radius: 5px;">The majority of nodes agree with User-${b}'s verification and reject the transaction. This consensus is crucial to prevent fraudulent or invalid transactions from being added to the ledger.</span>`])), c(dE(!1))) : (c(dE(!0)), c(eQ()), c(lr([...l, `User-${b} confirms that the sender has enough balance to cover the transaction, the transaction is considered valid.`]))), c(Kw(!1)), v(!1) }, 7e3), _(!0) }, w = i !== "conventional" && o ? .5 : .8; return D.createElement("div", { style: { width: "100%", height: "100%", display: "flex" } }, D.createElement("div", { style: { flex: w, position: "relative" } }, D.createElement(Fte, null)), i !== "conventional" && o && D.createElement("div", { style: { flex: .3, backgroundColor: "#1d273a" } }, D.createElement("div", { style: { display: "flex", flexDirection: "column" } }, D.createElement("div", { style: { width: "100%", display: "flex", justifyContent: "flex-end" } }, D.createElement("div", { style: { padding: 5, display: "flex", flexDirection: "column", alignItems: "flex-end", paddingBlock: 15, width: "150px", marginTop: 25, borderWidth: 1, borderColor: "yellow", borderStyle: "dashed", marginRight: 5 } }, D.createElement("h4", { style: { color: "white", textTransform: "capitalize" } }, "custom color"), D.createElement("div", { style: { padding: 2 } }, D.createElement("span", { style: { color: "yellow", marginRight: 5 } }, "Sender :"), D.createElement("input", { onChange: A, value: u, type: "color", name: "sender" })), D.createElement("div", { style: { padding: 2 } }, D.createElement("span", { style: { color: "yellow", marginRight: 5 } }, "Receiver :"), D.createElement("input", { onChange: A, value: d, name: "receiver", type: "color" })), D.createElement("div", null, D.createElement("span", { style: { color: "yellow", marginRight: 5 } }, "Verifier :"), D.createElement("input", { onChange: A, value: p, name: "verifier", type: "color" })))), D.createElement("div", null, D.createElement("div", null, D.createElement("h4", { style: { color: "white", textAlign: "center", fontFamily: "sans-serif" } }, "Steps"), D.createElement("div", { style: { paddingLeft: 50 } }, l.map((b, T) => D.createElement("div", { key: T, style: { display: "flex", flexDirection: "column", marginBlock: 9, fontFamily: "sans-serif" } }, D.createElement("div", { style: { display: "flex", justifyContent: "flex-start" } }, D.createElement("span", { style: { color: "yellow" } }, T + 1, D.createElement("span", null, ")")), D.createElement("p", { style: { color: "yellow", marginBlock: 0, marginInline: 3, textAlign: "start" }, dangerouslySetInnerHTML: { __html: b } })), D.createElement("div", { style: { display: "flex", flexDirection: "row", justifyContent: "center", width: "100%", marginBlock: 5 } }, T === 3 && x.map(B => D.createElement("div", { key: B }, D.createElement("button", { style: { width: 50, background: y && B !== e ? "grey" : "white", color: "black", borderRadius: 20, border: "none", marginInline: 2 }, onClick: () => E(B), disabled: y ? B !== e : !1 }, B))))))))))), D.createElement("div", { style: { flex: .2 } }, D.createElement(Rne, null))) }, Bne = k$({ reducer: { DoubleSpendingReducer: lQ } }); function Ine() { return D.createElement("div", { style: { width: "100%", height: "98vh" } }, D.createElement(UX, { store: Bne }, D.createElement(Pne, null))) } sS.createRoot(document.getElementById("root")).render(D.createElement(D.StrictMode, null, D.createElement(Ine, null)));
