var lD = Object.defineProperty;
var uD = (t, e, n) =>
  e in t
    ? lD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (t[e] = n);
var gp = (t, e, n) => uD(t, typeof e != "symbol" ? e + "" : e, n);
function cD(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              t,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
function N1(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var rP = { exports: {} },
  Yg = {},
  iP = { exports: {} },
  Lt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Jd = Symbol.for("react.element"),
  fD = Symbol.for("react.portal"),
  dD = Symbol.for("react.fragment"),
  hD = Symbol.for("react.strict_mode"),
  pD = Symbol.for("react.profiler"),
  mD = Symbol.for("react.provider"),
  gD = Symbol.for("react.context"),
  vD = Symbol.for("react.forward_ref"),
  yD = Symbol.for("react.suspense"),
  xD = Symbol.for("react.memo"),
  _D = Symbol.for("react.lazy"),
  Fb = Symbol.iterator;
function SD(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Fb && t[Fb]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var sP = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  oP = Object.assign,
  aP = {};
function Cc(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = aP),
    (this.updater = n || sP);
}
Cc.prototype.isReactComponent = {};
Cc.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
Cc.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function lP() {}
lP.prototype = Cc.prototype;
function O1(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = aP),
    (this.updater = n || sP);
}
var D1 = (O1.prototype = new lP());
D1.constructor = O1;
oP(D1, Cc.prototype);
D1.isPureReactComponent = !0;
var zb = Array.isArray,
  uP = Object.prototype.hasOwnProperty,
  k1 = { current: null },
  cP = { key: !0, ref: !0, __self: !0, __source: !0 };
function fP(t, e, n) {
  var r,
    i = {},
    s = null,
    o = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      uP.call(e, r) && !cP.hasOwnProperty(r) && (i[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = n;
  else if (1 < a) {
    for (var l = Array(a), f = 0; f < a; f++) l[f] = arguments[f + 2];
    i.children = l;
  }
  if (t && t.defaultProps)
    for (r in ((a = t.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: Jd,
    type: t,
    key: s,
    ref: o,
    props: i,
    _owner: k1.current,
  };
}
function wD(t, e) {
  return {
    $$typeof: Jd,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function U1(t) {
  return typeof t == "object" && t !== null && t.$$typeof === Jd;
}
function MD(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var Bb = /\/+/g;
function Wy(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? MD("" + t.key)
    : e.toString(36);
}
function Dm(t, e, n, r, i) {
  var s = typeof t;
  (s === "undefined" || s === "boolean") && (t = null);
  var o = !1;
  if (t === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case Jd:
          case fD:
            o = !0;
        }
    }
  if (o)
    return (
      (o = t),
      (i = i(o)),
      (t = r === "" ? "." + Wy(o, 0) : r),
      zb(i)
        ? ((n = ""),
          t != null && (n = t.replace(Bb, "$&/") + "/"),
          Dm(i, e, n, "", function (f) {
            return f;
          }))
        : i != null &&
          (U1(i) &&
            (i = wD(
              i,
              n +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(Bb, "$&/") + "/") +
                t
            )),
          e.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), zb(t)))
    for (var a = 0; a < t.length; a++) {
      s = t[a];
      var l = r + Wy(s, a);
      o += Dm(s, e, n, l, i);
    }
  else if (((l = SD(t)), typeof l == "function"))
    for (t = l.call(t), a = 0; !(s = t.next()).done; )
      (s = s.value), (l = r + Wy(s, a++)), (o += Dm(s, e, n, l, i));
  else if (s === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function vp(t, e, n) {
  if (t == null) return t;
  var r = [],
    i = 0;
  return (
    Dm(t, r, "", "", function (s) {
      return e.call(n, s, i++);
    }),
    r
  );
}
function ED(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var Wr = { current: null },
  km = { transition: null },
  bD = {
    ReactCurrentDispatcher: Wr,
    ReactCurrentBatchConfig: km,
    ReactCurrentOwner: k1,
  };
function dP() {
  throw Error("act(...) is not supported in production builds of React.");
}
Lt.Children = {
  map: vp,
  forEach: function (t, e, n) {
    vp(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      vp(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      vp(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!U1(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
Lt.Component = Cc;
Lt.Fragment = dD;
Lt.Profiler = pD;
Lt.PureComponent = O1;
Lt.StrictMode = hD;
Lt.Suspense = yD;
Lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bD;
Lt.act = dP;
Lt.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var r = oP({}, t.props),
    i = t.key,
    s = t.ref,
    o = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = k1.current)),
      e.key !== void 0 && (i = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var a = t.type.defaultProps;
    for (l in e)
      uP.call(e, l) &&
        !cP.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
    a = Array(l);
    for (var f = 0; f < l; f++) a[f] = arguments[f + 2];
    r.children = a;
  }
  return { $$typeof: Jd, type: t.type, key: i, ref: s, props: r, _owner: o };
};
Lt.createContext = function (t) {
  return (
    (t = {
      $$typeof: gD,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: mD, _context: t }),
    (t.Consumer = t)
  );
};
Lt.createElement = fP;
Lt.createFactory = function (t) {
  var e = fP.bind(null, t);
  return (e.type = t), e;
};
Lt.createRef = function () {
  return { current: null };
};
Lt.forwardRef = function (t) {
  return { $$typeof: vD, render: t };
};
Lt.isValidElement = U1;
Lt.lazy = function (t) {
  return { $$typeof: _D, _payload: { _status: -1, _result: t }, _init: ED };
};
Lt.memo = function (t, e) {
  return { $$typeof: xD, type: t, compare: e === void 0 ? null : e };
};
Lt.startTransition = function (t) {
  var e = km.transition;
  km.transition = {};
  try {
    t();
  } finally {
    km.transition = e;
  }
};
Lt.unstable_act = dP;
Lt.useCallback = function (t, e) {
  return Wr.current.useCallback(t, e);
};
Lt.useContext = function (t) {
  return Wr.current.useContext(t);
};
Lt.useDebugValue = function () {};
Lt.useDeferredValue = function (t) {
  return Wr.current.useDeferredValue(t);
};
Lt.useEffect = function (t, e) {
  return Wr.current.useEffect(t, e);
};
Lt.useId = function () {
  return Wr.current.useId();
};
Lt.useImperativeHandle = function (t, e, n) {
  return Wr.current.useImperativeHandle(t, e, n);
};
Lt.useInsertionEffect = function (t, e) {
  return Wr.current.useInsertionEffect(t, e);
};
Lt.useLayoutEffect = function (t, e) {
  return Wr.current.useLayoutEffect(t, e);
};
Lt.useMemo = function (t, e) {
  return Wr.current.useMemo(t, e);
};
Lt.useReducer = function (t, e, n) {
  return Wr.current.useReducer(t, e, n);
};
Lt.useRef = function (t) {
  return Wr.current.useRef(t);
};
Lt.useState = function (t) {
  return Wr.current.useState(t);
};
Lt.useSyncExternalStore = function (t, e, n) {
  return Wr.current.useSyncExternalStore(t, e, n);
};
Lt.useTransition = function () {
  return Wr.current.useTransition();
};
Lt.version = "18.3.1";
iP.exports = Lt;
var U = iP.exports;
const ol = N1(U),
  b_ = cD({ __proto__: null, default: ol }, [U]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var TD = U,
  AD = Symbol.for("react.element"),
  CD = Symbol.for("react.fragment"),
  RD = Object.prototype.hasOwnProperty,
  PD = TD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  LD = { key: !0, ref: !0, __self: !0, __source: !0 };
function hP(t, e, n) {
  var r,
    i = {},
    s = null,
    o = null;
  n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (r in e) RD.call(e, r) && !LD.hasOwnProperty(r) && (i[r] = e[r]);
  if (t && t.defaultProps)
    for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: AD,
    type: t,
    key: s,
    ref: o,
    props: i,
    _owner: PD.current,
  };
}
Yg.Fragment = CD;
Yg.jsx = hP;
Yg.jsxs = hP;
rP.exports = Yg;
var Q = rP.exports,
  pP = { exports: {} },
  Si = {},
  mP = { exports: {} },
  gP = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(B, G) {
    var X = B.length;
    B.push(G);
    e: for (; 0 < X; ) {
      var te = (X - 1) >>> 1,
        oe = B[te];
      if (0 < i(oe, G)) (B[te] = G), (B[X] = oe), (X = te);
      else break e;
    }
  }
  function n(B) {
    return B.length === 0 ? null : B[0];
  }
  function r(B) {
    if (B.length === 0) return null;
    var G = B[0],
      X = B.pop();
    if (X !== G) {
      B[0] = X;
      e: for (var te = 0, oe = B.length, J = oe >>> 1; te < J; ) {
        var ae = 2 * (te + 1) - 1,
          Se = B[ae],
          Ie = ae + 1,
          Ce = B[Ie];
        if (0 > i(Se, X))
          Ie < oe && 0 > i(Ce, Se)
            ? ((B[te] = Ce), (B[Ie] = X), (te = Ie))
            : ((B[te] = Se), (B[ae] = X), (te = ae));
        else if (Ie < oe && 0 > i(Ce, X)) (B[te] = Ce), (B[Ie] = X), (te = Ie);
        else break e;
      }
    }
    return G;
  }
  function i(B, G) {
    var X = B.sortIndex - G.sortIndex;
    return X !== 0 ? X : B.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    t.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    f = [],
    d = 1,
    h = null,
    p = 3,
    g = !1,
    v = !1,
    _ = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    m = typeof clearTimeout == "function" ? clearTimeout : null,
    w = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(B) {
    for (var G = n(f); G !== null; ) {
      if (G.callback === null) r(f);
      else if (G.startTime <= B)
        r(f), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = n(f);
    }
  }
  function E(B) {
    if (((_ = !1), S(B), !v))
      if (n(l) !== null) (v = !0), Y(T);
      else {
        var G = n(f);
        G !== null && Z(E, G.startTime - B);
      }
  }
  function T(B, G) {
    (v = !1), _ && ((_ = !1), m(N), (N = -1)), (g = !0);
    var X = p;
    try {
      for (
        S(G), h = n(l);
        h !== null && (!(h.expirationTime > G) || (B && !k()));

      ) {
        var te = h.callback;
        if (typeof te == "function") {
          (h.callback = null), (p = h.priorityLevel);
          var oe = te(h.expirationTime <= G);
          (G = t.unstable_now()),
            typeof oe == "function" ? (h.callback = oe) : h === n(l) && r(l),
            S(G);
        } else r(l);
        h = n(l);
      }
      if (h !== null) var J = !0;
      else {
        var ae = n(f);
        ae !== null && Z(E, ae.startTime - G), (J = !1);
      }
      return J;
    } finally {
      (h = null), (p = X), (g = !1);
    }
  }
  var A = !1,
    L = null,
    N = -1,
    C = 5,
    I = -1;
  function k() {
    return !(t.unstable_now() - I < C);
  }
  function R() {
    if (L !== null) {
      var B = t.unstable_now();
      I = B;
      var G = !0;
      try {
        G = L(!0, B);
      } finally {
        G ? $() : ((A = !1), (L = null));
      }
    } else A = !1;
  }
  var $;
  if (typeof w == "function")
    $ = function () {
      w(R);
    };
  else if (typeof MessageChannel < "u") {
    var D = new MessageChannel(),
      W = D.port2;
    (D.port1.onmessage = R),
      ($ = function () {
        W.postMessage(null);
      });
  } else
    $ = function () {
      x(R, 0);
    };
  function Y(B) {
    (L = B), A || ((A = !0), $());
  }
  function Z(B, G) {
    N = x(function () {
      B(t.unstable_now());
    }, G);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (B) {
      B.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || g || ((v = !0), Y(T));
    }),
    (t.unstable_forceFrameRate = function (B) {
      0 > B || 125 < B
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (C = 0 < B ? Math.floor(1e3 / B) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (B) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var X = p;
      p = G;
      try {
        return B();
      } finally {
        p = X;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (B, G) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var X = p;
      p = B;
      try {
        return G();
      } finally {
        p = X;
      }
    }),
    (t.unstable_scheduleCallback = function (B, G, X) {
      var te = t.unstable_now();
      switch (
        (typeof X == "object" && X !== null
          ? ((X = X.delay), (X = typeof X == "number" && 0 < X ? te + X : te))
          : (X = te),
        B)
      ) {
        case 1:
          var oe = -1;
          break;
        case 2:
          oe = 250;
          break;
        case 5:
          oe = 1073741823;
          break;
        case 4:
          oe = 1e4;
          break;
        default:
          oe = 5e3;
      }
      return (
        (oe = X + oe),
        (B = {
          id: d++,
          callback: G,
          priorityLevel: B,
          startTime: X,
          expirationTime: oe,
          sortIndex: -1,
        }),
        X > te
          ? ((B.sortIndex = X),
            e(f, B),
            n(l) === null &&
              B === n(f) &&
              (_ ? (m(N), (N = -1)) : (_ = !0), Z(E, X - te)))
          : ((B.sortIndex = oe), e(l, B), v || g || ((v = !0), Y(T))),
        B
      );
    }),
    (t.unstable_shouldYield = k),
    (t.unstable_wrapCallback = function (B) {
      var G = p;
      return function () {
        var X = p;
        p = G;
        try {
          return B.apply(this, arguments);
        } finally {
          p = X;
        }
      };
    });
})(gP);
mP.exports = gP;
var ID = mP.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ND = U,
  xi = ID;
function De(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var vP = new Set(),
  ad = {};
function Ol(t, e) {
  cc(t, e), cc(t + "Capture", e);
}
function cc(t, e) {
  for (ad[t] = e, t = 0; t < e.length; t++) vP.add(e[t]);
}
var mo = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  T_ = Object.prototype.hasOwnProperty,
  OD =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Hb = {},
  Vb = {};
function DD(t) {
  return T_.call(Vb, t)
    ? !0
    : T_.call(Hb, t)
    ? !1
    : OD.test(t)
    ? (Vb[t] = !0)
    : ((Hb[t] = !0), !1);
}
function kD(t, e, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function UD(t, e, n, r) {
  if (e === null || typeof e > "u" || kD(t, e, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Gr(t, e, n, r, i, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var hr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    hr[t] = new Gr(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  hr[e] = new Gr(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  hr[t] = new Gr(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  hr[t] = new Gr(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    hr[t] = new Gr(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  hr[t] = new Gr(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  hr[t] = new Gr(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  hr[t] = new Gr(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  hr[t] = new Gr(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var F1 = /[\-:]([a-z])/g;
function z1(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(F1, z1);
    hr[e] = new Gr(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(F1, z1);
    hr[e] = new Gr(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(F1, z1);
  hr[e] = new Gr(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  hr[t] = new Gr(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
hr.xlinkHref = new Gr(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  hr[t] = new Gr(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function B1(t, e, n, r) {
  var i = hr.hasOwnProperty(e) ? hr[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (UD(e, n, i, r) && (n = null),
    r || i === null
      ? DD(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : i.mustUseProperty
      ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
}
var To = ND.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  yp = Symbol.for("react.element"),
  ku = Symbol.for("react.portal"),
  Uu = Symbol.for("react.fragment"),
  H1 = Symbol.for("react.strict_mode"),
  A_ = Symbol.for("react.profiler"),
  yP = Symbol.for("react.provider"),
  xP = Symbol.for("react.context"),
  V1 = Symbol.for("react.forward_ref"),
  C_ = Symbol.for("react.suspense"),
  R_ = Symbol.for("react.suspense_list"),
  W1 = Symbol.for("react.memo"),
  jo = Symbol.for("react.lazy"),
  _P = Symbol.for("react.offscreen"),
  Wb = Symbol.iterator;
function af(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Wb && t[Wb]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var mn = Object.assign,
  Gy;
function Nf(t) {
  if (Gy === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      Gy = (e && e[1]) || "";
    }
  return (
    `
` +
    Gy +
    t
  );
}
var jy = !1;
function $y(t, e) {
  if (!t || jy) return "";
  jy = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (f) {
          var r = f;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (f) {
          r = f;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (f) {
        r = f;
      }
      t();
    }
  } catch (f) {
    if (f && r && typeof f.stack == "string") {
      for (
        var i = f.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (jy = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? Nf(t) : "";
}
function FD(t) {
  switch (t.tag) {
    case 5:
      return Nf(t.type);
    case 16:
      return Nf("Lazy");
    case 13:
      return Nf("Suspense");
    case 19:
      return Nf("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = $y(t.type, !1)), t;
    case 11:
      return (t = $y(t.type.render, !1)), t;
    case 1:
      return (t = $y(t.type, !0)), t;
    default:
      return "";
  }
}
function P_(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Uu:
      return "Fragment";
    case ku:
      return "Portal";
    case A_:
      return "Profiler";
    case H1:
      return "StrictMode";
    case C_:
      return "Suspense";
    case R_:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case xP:
        return (t.displayName || "Context") + ".Consumer";
      case yP:
        return (t._context.displayName || "Context") + ".Provider";
      case V1:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case W1:
        return (
          (e = t.displayName || null), e !== null ? e : P_(t.type) || "Memo"
        );
      case jo:
        (e = t._payload), (t = t._init);
        try {
          return P_(t(e));
        } catch {}
    }
  return null;
}
function zD(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return P_(e);
    case 8:
      return e === H1 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function pa(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function SP(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function BD(t) {
  var e = SP(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      s = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function xp(t) {
  t._valueTracker || (t._valueTracker = BD(t));
}
function wP(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    r = "";
  return (
    t && (r = SP(t) ? (t.checked ? "true" : "false") : t.value),
    (t = r),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function sg(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function L_(t, e) {
  var n = e.checked;
  return mn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function Gb(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (n = pa(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function MP(t, e) {
  (e = e.checked), e != null && B1(t, "checked", e, !1);
}
function I_(t, e) {
  MP(t, e);
  var n = pa(e.value),
    r = e.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (r === "submit" || r === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? N_(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && N_(t, e.type, pa(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function jb(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function N_(t, e, n) {
  (e !== "number" || sg(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var Of = Array.isArray;
function Qu(t, e, n, r) {
  if (((t = t.options), e)) {
    e = {};
    for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
    for (n = 0; n < t.length; n++)
      (i = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== i && (t[n].selected = i),
        i && r && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + pa(n), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === n) {
        (t[i].selected = !0), r && (t[i].defaultSelected = !0);
        return;
      }
      e !== null || t[i].disabled || (e = t[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function O_(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(De(91));
  return mn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function $b(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(De(92));
      if (Of(n)) {
        if (1 < n.length) throw Error(De(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: pa(n) };
}
function EP(t, e) {
  var n = pa(e.value),
    r = pa(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = "" + r);
}
function Xb(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function bP(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function D_(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? bP(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var _p,
  TP = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        _p = _p || document.createElement("div"),
          _p.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = _p.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function ld(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var Wf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  HD = ["Webkit", "ms", "Moz", "O"];
Object.keys(Wf).forEach(function (t) {
  HD.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Wf[e] = Wf[t]);
  });
});
function AP(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (Wf.hasOwnProperty(t) && Wf[t])
    ? ("" + e).trim()
    : e + "px";
}
function CP(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = AP(n, e[n], r);
      n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : (t[n] = i);
    }
}
var VD = mn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function k_(t, e) {
  if (e) {
    if (VD[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(De(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(De(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(De(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(De(62));
  }
}
function U_(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var F_ = null;
function G1(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var z_ = null,
  ec = null,
  tc = null;
function Yb(t) {
  if ((t = th(t))) {
    if (typeof z_ != "function") throw Error(De(280));
    var e = t.stateNode;
    e && ((e = Qg(e)), z_(t.stateNode, t.type, e));
  }
}
function RP(t) {
  ec ? (tc ? tc.push(t) : (tc = [t])) : (ec = t);
}
function PP() {
  if (ec) {
    var t = ec,
      e = tc;
    if (((tc = ec = null), Yb(t), e)) for (t = 0; t < e.length; t++) Yb(e[t]);
  }
}
function LP(t, e) {
  return t(e);
}
function IP() {}
var Xy = !1;
function NP(t, e, n) {
  if (Xy) return t(e, n);
  Xy = !0;
  try {
    return LP(t, e, n);
  } finally {
    (Xy = !1), (ec !== null || tc !== null) && (IP(), PP());
  }
}
function ud(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var r = Qg(n);
  if (r === null) return null;
  n = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((t = t.type),
        (r = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !r);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(De(231, e, typeof n));
  return n;
}
var B_ = !1;
if (mo)
  try {
    var lf = {};
    Object.defineProperty(lf, "passive", {
      get: function () {
        B_ = !0;
      },
    }),
      window.addEventListener("test", lf, lf),
      window.removeEventListener("test", lf, lf);
  } catch {
    B_ = !1;
  }
function WD(t, e, n, r, i, s, o, a, l) {
  var f = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, f);
  } catch (d) {
    this.onError(d);
  }
}
var Gf = !1,
  og = null,
  ag = !1,
  H_ = null,
  GD = {
    onError: function (t) {
      (Gf = !0), (og = t);
    },
  };
function jD(t, e, n, r, i, s, o, a, l) {
  (Gf = !1), (og = null), WD.apply(GD, arguments);
}
function $D(t, e, n, r, i, s, o, a, l) {
  if ((jD.apply(this, arguments), Gf)) {
    if (Gf) {
      var f = og;
      (Gf = !1), (og = null);
    } else throw Error(De(198));
    ag || ((ag = !0), (H_ = f));
  }
}
function Dl(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function OP(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function qb(t) {
  if (Dl(t) !== t) throw Error(De(188));
}
function XD(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = Dl(t)), e === null)) throw Error(De(188));
    return e !== t ? null : t;
  }
  for (var n = t, r = e; ; ) {
    var i = n.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return qb(i), t;
        if (s === r) return qb(i), e;
        s = s.sibling;
      }
      throw Error(De(188));
    }
    if (n.return !== r.return) (n = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === n) {
          (o = !0), (n = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (n = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === n) {
            (o = !0), (n = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (n = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(De(189));
      }
    }
    if (n.alternate !== r) throw Error(De(190));
  }
  if (n.tag !== 3) throw Error(De(188));
  return n.stateNode.current === n ? t : e;
}
function DP(t) {
  return (t = XD(t)), t !== null ? kP(t) : null;
}
function kP(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = kP(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var UP = xi.unstable_scheduleCallback,
  Kb = xi.unstable_cancelCallback,
  YD = xi.unstable_shouldYield,
  qD = xi.unstable_requestPaint,
  Cn = xi.unstable_now,
  KD = xi.unstable_getCurrentPriorityLevel,
  j1 = xi.unstable_ImmediatePriority,
  FP = xi.unstable_UserBlockingPriority,
  lg = xi.unstable_NormalPriority,
  ZD = xi.unstable_LowPriority,
  zP = xi.unstable_IdlePriority,
  qg = null,
  Is = null;
function JD(t) {
  if (Is && typeof Is.onCommitFiberRoot == "function")
    try {
      Is.onCommitFiberRoot(qg, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var as = Math.clz32 ? Math.clz32 : tk,
  QD = Math.log,
  ek = Math.LN2;
function tk(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((QD(t) / ek) | 0)) | 0;
}
var Sp = 64,
  wp = 4194304;
function Df(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function ug(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = t.suspendedLanes,
    s = t.pingedLanes,
    o = n & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = Df(a)) : ((s &= o), s !== 0 && (r = Df(s)));
  } else (o = n & ~i), o !== 0 ? (r = Df(o)) : s !== 0 && (r = Df(s));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= r; 0 < e; )
      (n = 31 - as(e)), (i = 1 << n), (r |= t[n]), (e &= ~i);
  return r;
}
function nk(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function rk(t, e) {
  for (
    var n = t.suspendedLanes,
      r = t.pingedLanes,
      i = t.expirationTimes,
      s = t.pendingLanes;
    0 < s;

  ) {
    var o = 31 - as(s),
      a = 1 << o,
      l = i[o];
    l === -1
      ? (!(a & n) || a & r) && (i[o] = nk(a, e))
      : l <= e && (t.expiredLanes |= a),
      (s &= ~a);
  }
}
function V_(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function BP() {
  var t = Sp;
  return (Sp <<= 1), !(Sp & 4194240) && (Sp = 64), t;
}
function Yy(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function Qd(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - as(e)),
    (t[e] = n);
}
function ik(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var r = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var i = 31 - as(n),
      s = 1 << i;
    (e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~s);
  }
}
function $1(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var r = 31 - as(n),
      i = 1 << r;
    (i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i);
  }
}
var jt = 0;
function HP(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var VP,
  X1,
  WP,
  GP,
  jP,
  W_ = !1,
  Mp = [],
  Qo = null,
  ea = null,
  ta = null,
  cd = new Map(),
  fd = new Map(),
  Xo = [],
  sk =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Zb(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Qo = null;
      break;
    case "dragenter":
    case "dragleave":
      ea = null;
      break;
    case "mouseover":
    case "mouseout":
      ta = null;
      break;
    case "pointerover":
    case "pointerout":
      cd.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      fd.delete(e.pointerId);
  }
}
function uf(t, e, n, r, i, s) {
  return t === null || t.nativeEvent !== s
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = th(e)), e !== null && X1(e)),
      t)
    : ((t.eventSystemFlags |= r),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t);
}
function ok(t, e, n, r, i) {
  switch (e) {
    case "focusin":
      return (Qo = uf(Qo, t, e, n, r, i)), !0;
    case "dragenter":
      return (ea = uf(ea, t, e, n, r, i)), !0;
    case "mouseover":
      return (ta = uf(ta, t, e, n, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return cd.set(s, uf(cd.get(s) || null, t, e, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), fd.set(s, uf(fd.get(s) || null, t, e, n, r, i)), !0
      );
  }
  return !1;
}
function $P(t) {
  var e = al(t.target);
  if (e !== null) {
    var n = Dl(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = OP(n)), e !== null)) {
          (t.blockedOn = e),
            jP(t.priority, function () {
              WP(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function Um(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = G_(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var r = new n.constructor(n.type, n);
      (F_ = r), n.target.dispatchEvent(r), (F_ = null);
    } else return (e = th(n)), e !== null && X1(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function Jb(t, e, n) {
  Um(t) && n.delete(e);
}
function ak() {
  (W_ = !1),
    Qo !== null && Um(Qo) && (Qo = null),
    ea !== null && Um(ea) && (ea = null),
    ta !== null && Um(ta) && (ta = null),
    cd.forEach(Jb),
    fd.forEach(Jb);
}
function cf(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    W_ ||
      ((W_ = !0),
      xi.unstable_scheduleCallback(xi.unstable_NormalPriority, ak)));
}
function dd(t) {
  function e(i) {
    return cf(i, t);
  }
  if (0 < Mp.length) {
    cf(Mp[0], t);
    for (var n = 1; n < Mp.length; n++) {
      var r = Mp[n];
      r.blockedOn === t && (r.blockedOn = null);
    }
  }
  for (
    Qo !== null && cf(Qo, t),
      ea !== null && cf(ea, t),
      ta !== null && cf(ta, t),
      cd.forEach(e),
      fd.forEach(e),
      n = 0;
    n < Xo.length;
    n++
  )
    (r = Xo[n]), r.blockedOn === t && (r.blockedOn = null);
  for (; 0 < Xo.length && ((n = Xo[0]), n.blockedOn === null); )
    $P(n), n.blockedOn === null && Xo.shift();
}
var nc = To.ReactCurrentBatchConfig,
  cg = !0;
function lk(t, e, n, r) {
  var i = jt,
    s = nc.transition;
  nc.transition = null;
  try {
    (jt = 1), Y1(t, e, n, r);
  } finally {
    (jt = i), (nc.transition = s);
  }
}
function uk(t, e, n, r) {
  var i = jt,
    s = nc.transition;
  nc.transition = null;
  try {
    (jt = 4), Y1(t, e, n, r);
  } finally {
    (jt = i), (nc.transition = s);
  }
}
function Y1(t, e, n, r) {
  if (cg) {
    var i = G_(t, e, n, r);
    if (i === null) ix(t, e, r, fg, n), Zb(t, r);
    else if (ok(i, t, e, n, r)) r.stopPropagation();
    else if ((Zb(t, r), e & 4 && -1 < sk.indexOf(t))) {
      for (; i !== null; ) {
        var s = th(i);
        if (
          (s !== null && VP(s),
          (s = G_(t, e, n, r)),
          s === null && ix(t, e, r, fg, n),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else ix(t, e, r, null, n);
  }
}
var fg = null;
function G_(t, e, n, r) {
  if (((fg = null), (t = G1(r)), (t = al(t)), t !== null))
    if (((e = Dl(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = OP(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (fg = t), null;
}
function XP(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (KD()) {
        case j1:
          return 1;
        case FP:
          return 4;
        case lg:
        case ZD:
          return 16;
        case zP:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Zo = null,
  q1 = null,
  Fm = null;
function YP() {
  if (Fm) return Fm;
  var t,
    e = q1,
    n = e.length,
    r,
    i = "value" in Zo ? Zo.value : Zo.textContent,
    s = i.length;
  for (t = 0; t < n && e[t] === i[t]; t++);
  var o = n - t;
  for (r = 1; r <= o && e[n - r] === i[s - r]; r++);
  return (Fm = i.slice(t, 1 < r ? 1 - r : void 0));
}
function zm(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function Ep() {
  return !0;
}
function Qb() {
  return !1;
}
function wi(t) {
  function e(n, r, i, s, o) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in t)
      t.hasOwnProperty(a) && ((n = t[a]), (this[a] = n ? n(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Ep
        : Qb),
      (this.isPropagationStopped = Qb),
      this
    );
  }
  return (
    mn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = Ep));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = Ep));
      },
      persist: function () {},
      isPersistent: Ep,
    }),
    e
  );
}
var Rc = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  K1 = wi(Rc),
  eh = mn({}, Rc, { view: 0, detail: 0 }),
  ck = wi(eh),
  qy,
  Ky,
  ff,
  Kg = mn({}, eh, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Z1,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== ff &&
            (ff && t.type === "mousemove"
              ? ((qy = t.screenX - ff.screenX), (Ky = t.screenY - ff.screenY))
              : (Ky = qy = 0),
            (ff = t)),
          qy);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : Ky;
    },
  }),
  eT = wi(Kg),
  fk = mn({}, Kg, { dataTransfer: 0 }),
  dk = wi(fk),
  hk = mn({}, eh, { relatedTarget: 0 }),
  Zy = wi(hk),
  pk = mn({}, Rc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  mk = wi(pk),
  gk = mn({}, Rc, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  vk = wi(gk),
  yk = mn({}, Rc, { data: 0 }),
  tT = wi(yk),
  xk = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  _k = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Sk = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function wk(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = Sk[t]) ? !!e[t] : !1;
}
function Z1() {
  return wk;
}
var Mk = mn({}, eh, {
    key: function (t) {
      if (t.key) {
        var e = xk[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = zm(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? _k[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Z1,
    charCode: function (t) {
      return t.type === "keypress" ? zm(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? zm(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  Ek = wi(Mk),
  bk = mn({}, Kg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  nT = wi(bk),
  Tk = mn({}, eh, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Z1,
  }),
  Ak = wi(Tk),
  Ck = mn({}, Rc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Rk = wi(Ck),
  Pk = mn({}, Kg, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Lk = wi(Pk),
  Ik = [9, 13, 27, 32],
  J1 = mo && "CompositionEvent" in window,
  jf = null;
mo && "documentMode" in document && (jf = document.documentMode);
var Nk = mo && "TextEvent" in window && !jf,
  qP = mo && (!J1 || (jf && 8 < jf && 11 >= jf)),
  rT = " ",
  iT = !1;
function KP(t, e) {
  switch (t) {
    case "keyup":
      return Ik.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function ZP(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Fu = !1;
function Ok(t, e) {
  switch (t) {
    case "compositionend":
      return ZP(e);
    case "keypress":
      return e.which !== 32 ? null : ((iT = !0), rT);
    case "textInput":
      return (t = e.data), t === rT && iT ? null : t;
    default:
      return null;
  }
}
function Dk(t, e) {
  if (Fu)
    return t === "compositionend" || (!J1 && KP(t, e))
      ? ((t = YP()), (Fm = q1 = Zo = null), (Fu = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return qP && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var kk = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function sT(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!kk[t.type] : e === "textarea";
}
function JP(t, e, n, r) {
  RP(r),
    (e = dg(e, "onChange")),
    0 < e.length &&
      ((n = new K1("onChange", "change", null, n, r)),
      t.push({ event: n, listeners: e }));
}
var $f = null,
  hd = null;
function Uk(t) {
  u2(t, 0);
}
function Zg(t) {
  var e = Hu(t);
  if (wP(e)) return t;
}
function Fk(t, e) {
  if (t === "change") return e;
}
var QP = !1;
if (mo) {
  var Jy;
  if (mo) {
    var Qy = "oninput" in document;
    if (!Qy) {
      var oT = document.createElement("div");
      oT.setAttribute("oninput", "return;"),
        (Qy = typeof oT.oninput == "function");
    }
    Jy = Qy;
  } else Jy = !1;
  QP = Jy && (!document.documentMode || 9 < document.documentMode);
}
function aT() {
  $f && ($f.detachEvent("onpropertychange", e2), (hd = $f = null));
}
function e2(t) {
  if (t.propertyName === "value" && Zg(hd)) {
    var e = [];
    JP(e, hd, t, G1(t)), NP(Uk, e);
  }
}
function zk(t, e, n) {
  t === "focusin"
    ? (aT(), ($f = e), (hd = n), $f.attachEvent("onpropertychange", e2))
    : t === "focusout" && aT();
}
function Bk(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return Zg(hd);
}
function Hk(t, e) {
  if (t === "click") return Zg(e);
}
function Vk(t, e) {
  if (t === "input" || t === "change") return Zg(e);
}
function Wk(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var us = typeof Object.is == "function" ? Object.is : Wk;
function pd(t, e) {
  if (us(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!T_.call(e, i) || !us(t[i], e[i])) return !1;
  }
  return !0;
}
function lT(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function uT(t, e) {
  var n = lT(t);
  t = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = t + n.textContent.length), t <= e && r >= e))
        return { node: n, offset: e - t };
      t = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = lT(n);
  }
}
function t2(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? t2(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function n2() {
  for (var t = window, e = sg(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = sg(t.document);
  }
  return e;
}
function Q1(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function Gk(t) {
  var e = n2(),
    n = t.focusedElem,
    r = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    t2(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && Q1(n)) {
      if (
        ((e = r.start),
        (t = r.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var i = n.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !t.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = uT(n, s));
        var o = uT(n, r);
        i &&
          o &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== o.node ||
            t.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          s > r
            ? (t.addRange(e), t.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var jk = mo && "documentMode" in document && 11 >= document.documentMode,
  zu = null,
  j_ = null,
  Xf = null,
  $_ = !1;
function cT(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  $_ ||
    zu == null ||
    zu !== sg(r) ||
    ((r = zu),
    "selectionStart" in r && Q1(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (Xf && pd(Xf, r)) ||
      ((Xf = r),
      (r = dg(j_, "onSelect")),
      0 < r.length &&
        ((e = new K1("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: r }),
        (e.target = zu))));
}
function bp(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var Bu = {
    animationend: bp("Animation", "AnimationEnd"),
    animationiteration: bp("Animation", "AnimationIteration"),
    animationstart: bp("Animation", "AnimationStart"),
    transitionend: bp("Transition", "TransitionEnd"),
  },
  ex = {},
  r2 = {};
mo &&
  ((r2 = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Bu.animationend.animation,
    delete Bu.animationiteration.animation,
    delete Bu.animationstart.animation),
  "TransitionEvent" in window || delete Bu.transitionend.transition);
function Jg(t) {
  if (ex[t]) return ex[t];
  if (!Bu[t]) return t;
  var e = Bu[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in r2) return (ex[t] = e[n]);
  return t;
}
var i2 = Jg("animationend"),
  s2 = Jg("animationiteration"),
  o2 = Jg("animationstart"),
  a2 = Jg("transitionend"),
  l2 = new Map(),
  fT =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function wa(t, e) {
  l2.set(t, e), Ol(e, [t]);
}
for (var tx = 0; tx < fT.length; tx++) {
  var nx = fT[tx],
    $k = nx.toLowerCase(),
    Xk = nx[0].toUpperCase() + nx.slice(1);
  wa($k, "on" + Xk);
}
wa(i2, "onAnimationEnd");
wa(s2, "onAnimationIteration");
wa(o2, "onAnimationStart");
wa("dblclick", "onDoubleClick");
wa("focusin", "onFocus");
wa("focusout", "onBlur");
wa(a2, "onTransitionEnd");
cc("onMouseEnter", ["mouseout", "mouseover"]);
cc("onMouseLeave", ["mouseout", "mouseover"]);
cc("onPointerEnter", ["pointerout", "pointerover"]);
cc("onPointerLeave", ["pointerout", "pointerover"]);
Ol(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Ol(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Ol("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ol(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Ol(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Ol(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var kf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Yk = new Set("cancel close invalid load scroll toggle".split(" ").concat(kf));
function dT(t, e, n) {
  var r = t.type || "unknown-event";
  (t.currentTarget = n), $D(r, e, void 0, t), (t.currentTarget = null);
}
function u2(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            f = a.currentTarget;
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e;
          dT(i, a, f), (s = l);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (f = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          dT(i, a, f), (s = l);
        }
    }
  }
  if (ag) throw ((t = H_), (ag = !1), (H_ = null), t);
}
function nn(t, e) {
  var n = e[Z_];
  n === void 0 && (n = e[Z_] = new Set());
  var r = t + "__bubble";
  n.has(r) || (c2(e, t, 2, !1), n.add(r));
}
function rx(t, e, n) {
  var r = 0;
  e && (r |= 4), c2(n, t, r, e);
}
var Tp = "_reactListening" + Math.random().toString(36).slice(2);
function md(t) {
  if (!t[Tp]) {
    (t[Tp] = !0),
      vP.forEach(function (n) {
        n !== "selectionchange" && (Yk.has(n) || rx(n, !1, t), rx(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[Tp] || ((e[Tp] = !0), rx("selectionchange", !1, e));
  }
}
function c2(t, e, n, r) {
  switch (XP(e)) {
    case 1:
      var i = lk;
      break;
    case 4:
      i = uk;
      break;
    default:
      i = Y1;
  }
  (n = i.bind(null, e, n, t)),
    (i = void 0),
    !B_ ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: i })
        : t.addEventListener(e, n, !0)
      : i !== void 0
      ? t.addEventListener(e, n, { passive: i })
      : t.addEventListener(e, n, !1);
}
function ix(t, e, n, r, i) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = al(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  NP(function () {
    var f = s,
      d = G1(n),
      h = [];
    e: {
      var p = l2.get(t);
      if (p !== void 0) {
        var g = K1,
          v = t;
        switch (t) {
          case "keypress":
            if (zm(n) === 0) break e;
          case "keydown":
          case "keyup":
            g = Ek;
            break;
          case "focusin":
            (v = "focus"), (g = Zy);
            break;
          case "focusout":
            (v = "blur"), (g = Zy);
            break;
          case "beforeblur":
          case "afterblur":
            g = Zy;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            g = eT;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            g = dk;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            g = Ak;
            break;
          case i2:
          case s2:
          case o2:
            g = mk;
            break;
          case a2:
            g = Rk;
            break;
          case "scroll":
            g = ck;
            break;
          case "wheel":
            g = Lk;
            break;
          case "copy":
          case "cut":
          case "paste":
            g = vk;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            g = nT;
        }
        var _ = (e & 4) !== 0,
          x = !_ && t === "scroll",
          m = _ ? (p !== null ? p + "Capture" : null) : p;
        _ = [];
        for (var w = f, S; w !== null; ) {
          S = w;
          var E = S.stateNode;
          if (
            (S.tag === 5 &&
              E !== null &&
              ((S = E),
              m !== null && ((E = ud(w, m)), E != null && _.push(gd(w, E, S)))),
            x)
          )
            break;
          w = w.return;
        }
        0 < _.length &&
          ((p = new g(p, v, null, n, d)), h.push({ event: p, listeners: _ }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = t === "mouseover" || t === "pointerover"),
          (g = t === "mouseout" || t === "pointerout"),
          p &&
            n !== F_ &&
            (v = n.relatedTarget || n.fromElement) &&
            (al(v) || v[go]))
        )
          break e;
        if (
          (g || p) &&
          ((p =
            d.window === d
              ? d
              : (p = d.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          g
            ? ((v = n.relatedTarget || n.toElement),
              (g = f),
              (v = v ? al(v) : null),
              v !== null &&
                ((x = Dl(v)), v !== x || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((g = null), (v = f)),
          g !== v)
        ) {
          if (
            ((_ = eT),
            (E = "onMouseLeave"),
            (m = "onMouseEnter"),
            (w = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((_ = nT),
              (E = "onPointerLeave"),
              (m = "onPointerEnter"),
              (w = "pointer")),
            (x = g == null ? p : Hu(g)),
            (S = v == null ? p : Hu(v)),
            (p = new _(E, w + "leave", g, n, d)),
            (p.target = x),
            (p.relatedTarget = S),
            (E = null),
            al(d) === f &&
              ((_ = new _(m, w + "enter", v, n, d)),
              (_.target = S),
              (_.relatedTarget = x),
              (E = _)),
            (x = E),
            g && v)
          )
            t: {
              for (_ = g, m = v, w = 0, S = _; S; S = ru(S)) w++;
              for (S = 0, E = m; E; E = ru(E)) S++;
              for (; 0 < w - S; ) (_ = ru(_)), w--;
              for (; 0 < S - w; ) (m = ru(m)), S--;
              for (; w--; ) {
                if (_ === m || (m !== null && _ === m.alternate)) break t;
                (_ = ru(_)), (m = ru(m));
              }
              _ = null;
            }
          else _ = null;
          g !== null && hT(h, p, g, _, !1),
            v !== null && x !== null && hT(h, x, v, _, !0);
        }
      }
      e: {
        if (
          ((p = f ? Hu(f) : window),
          (g = p.nodeName && p.nodeName.toLowerCase()),
          g === "select" || (g === "input" && p.type === "file"))
        )
          var T = Fk;
        else if (sT(p))
          if (QP) T = Vk;
          else {
            T = Bk;
            var A = zk;
          }
        else
          (g = p.nodeName) &&
            g.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (T = Hk);
        if (T && (T = T(t, f))) {
          JP(h, T, n, d);
          break e;
        }
        A && A(t, p, f),
          t === "focusout" &&
            (A = p._wrapperState) &&
            A.controlled &&
            p.type === "number" &&
            N_(p, "number", p.value);
      }
      switch (((A = f ? Hu(f) : window), t)) {
        case "focusin":
          (sT(A) || A.contentEditable === "true") &&
            ((zu = A), (j_ = f), (Xf = null));
          break;
        case "focusout":
          Xf = j_ = zu = null;
          break;
        case "mousedown":
          $_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          ($_ = !1), cT(h, n, d);
          break;
        case "selectionchange":
          if (jk) break;
        case "keydown":
        case "keyup":
          cT(h, n, d);
      }
      var L;
      if (J1)
        e: {
          switch (t) {
            case "compositionstart":
              var N = "onCompositionStart";
              break e;
            case "compositionend":
              N = "onCompositionEnd";
              break e;
            case "compositionupdate":
              N = "onCompositionUpdate";
              break e;
          }
          N = void 0;
        }
      else
        Fu
          ? KP(t, n) && (N = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (N = "onCompositionStart");
      N &&
        (qP &&
          n.locale !== "ko" &&
          (Fu || N !== "onCompositionStart"
            ? N === "onCompositionEnd" && Fu && (L = YP())
            : ((Zo = d),
              (q1 = "value" in Zo ? Zo.value : Zo.textContent),
              (Fu = !0))),
        (A = dg(f, N)),
        0 < A.length &&
          ((N = new tT(N, t, null, n, d)),
          h.push({ event: N, listeners: A }),
          L ? (N.data = L) : ((L = ZP(n)), L !== null && (N.data = L)))),
        (L = Nk ? Ok(t, n) : Dk(t, n)) &&
          ((f = dg(f, "onBeforeInput")),
          0 < f.length &&
            ((d = new tT("onBeforeInput", "beforeinput", null, n, d)),
            h.push({ event: d, listeners: f }),
            (d.data = L)));
    }
    u2(h, e);
  });
}
function gd(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function dg(t, e) {
  for (var n = e + "Capture", r = []; t !== null; ) {
    var i = t,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = ud(t, n)),
      s != null && r.unshift(gd(t, s, i)),
      (s = ud(t, e)),
      s != null && r.push(gd(t, s, i))),
      (t = t.return);
  }
  return r;
}
function ru(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function hT(t, e, n, r, i) {
  for (var s = e._reactName, o = []; n !== null && n !== r; ) {
    var a = n,
      l = a.alternate,
      f = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      f !== null &&
      ((a = f),
      i
        ? ((l = ud(n, s)), l != null && o.unshift(gd(n, l, a)))
        : i || ((l = ud(n, s)), l != null && o.push(gd(n, l, a)))),
      (n = n.return);
  }
  o.length !== 0 && t.push({ event: e, listeners: o });
}
var qk = /\r\n?/g,
  Kk = /\u0000|\uFFFD/g;
function pT(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      qk,
      `
`
    )
    .replace(Kk, "");
}
function Ap(t, e, n) {
  if (((e = pT(e)), pT(t) !== e && n)) throw Error(De(425));
}
function hg() {}
var X_ = null,
  Y_ = null;
function q_(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var K_ = typeof setTimeout == "function" ? setTimeout : void 0,
  Zk = typeof clearTimeout == "function" ? clearTimeout : void 0,
  mT = typeof Promise == "function" ? Promise : void 0,
  Jk =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof mT < "u"
      ? function (t) {
          return mT.resolve(null).then(t).catch(Qk);
        }
      : K_;
function Qk(t) {
  setTimeout(function () {
    throw t;
  });
}
function sx(t, e) {
  var n = e,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((t.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          t.removeChild(i), dd(e);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  dd(e);
}
function na(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function gT(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var Pc = Math.random().toString(36).slice(2),
  Rs = "__reactFiber$" + Pc,
  vd = "__reactProps$" + Pc,
  go = "__reactContainer$" + Pc,
  Z_ = "__reactEvents$" + Pc,
  eU = "__reactListeners$" + Pc,
  tU = "__reactHandles$" + Pc;
function al(t) {
  var e = t[Rs];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[go] || n[Rs])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = gT(t); t !== null; ) {
          if ((n = t[Rs])) return n;
          t = gT(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function th(t) {
  return (
    (t = t[Rs] || t[go]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function Hu(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(De(33));
}
function Qg(t) {
  return t[vd] || null;
}
var J_ = [],
  Vu = -1;
function Ma(t) {
  return { current: t };
}
function rn(t) {
  0 > Vu || ((t.current = J_[Vu]), (J_[Vu] = null), Vu--);
}
function en(t, e) {
  Vu++, (J_[Vu] = t.current), (t.current = e);
}
var ma = {},
  Ir = Ma(ma),
  ei = Ma(!1),
  Ml = ma;
function fc(t, e) {
  var n = t.type.contextTypes;
  if (!n) return ma;
  var r = t.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in n) i[s] = e[s];
  return (
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function ti(t) {
  return (t = t.childContextTypes), t != null;
}
function pg() {
  rn(ei), rn(Ir);
}
function vT(t, e, n) {
  if (Ir.current !== ma) throw Error(De(168));
  en(Ir, e), en(ei, n);
}
function f2(t, e, n) {
  var r = t.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(De(108, zD(t) || "Unknown", i));
  return mn({}, n, r);
}
function mg(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || ma),
    (Ml = Ir.current),
    en(Ir, t),
    en(ei, ei.current),
    !0
  );
}
function yT(t, e, n) {
  var r = t.stateNode;
  if (!r) throw Error(De(169));
  n
    ? ((t = f2(t, e, Ml)),
      (r.__reactInternalMemoizedMergedChildContext = t),
      rn(ei),
      rn(Ir),
      en(Ir, t))
    : rn(ei),
    en(ei, n);
}
var oo = null,
  e0 = !1,
  ox = !1;
function d2(t) {
  oo === null ? (oo = [t]) : oo.push(t);
}
function nU(t) {
  (e0 = !0), d2(t);
}
function Ea() {
  if (!ox && oo !== null) {
    ox = !0;
    var t = 0,
      e = jt;
    try {
      var n = oo;
      for (jt = 1; t < n.length; t++) {
        var r = n[t];
        do r = r(!0);
        while (r !== null);
      }
      (oo = null), (e0 = !1);
    } catch (i) {
      throw (oo !== null && (oo = oo.slice(t + 1)), UP(j1, Ea), i);
    } finally {
      (jt = e), (ox = !1);
    }
  }
  return null;
}
var Wu = [],
  Gu = 0,
  gg = null,
  vg = 0,
  ki = [],
  Ui = 0,
  El = null,
  uo = 1,
  co = "";
function Ka(t, e) {
  (Wu[Gu++] = vg), (Wu[Gu++] = gg), (gg = t), (vg = e);
}
function h2(t, e, n) {
  (ki[Ui++] = uo), (ki[Ui++] = co), (ki[Ui++] = El), (El = t);
  var r = uo;
  t = co;
  var i = 32 - as(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var s = 32 - as(e) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (uo = (1 << (32 - as(e) + i)) | (n << i) | r),
      (co = s + t);
  } else (uo = (1 << s) | (n << i) | r), (co = t);
}
function ew(t) {
  t.return !== null && (Ka(t, 1), h2(t, 1, 0));
}
function tw(t) {
  for (; t === gg; )
    (gg = Wu[--Gu]), (Wu[Gu] = null), (vg = Wu[--Gu]), (Wu[Gu] = null);
  for (; t === El; )
    (El = ki[--Ui]),
      (ki[Ui] = null),
      (co = ki[--Ui]),
      (ki[Ui] = null),
      (uo = ki[--Ui]),
      (ki[Ui] = null);
}
var gi = null,
  mi = null,
  un = !1,
  ns = null;
function p2(t, e) {
  var n = zi(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function xT(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (gi = t), (mi = na(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (gi = t), (mi = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = El !== null ? { id: uo, overflow: co } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = zi(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (gi = t),
            (mi = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Q_(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function eS(t) {
  if (un) {
    var e = mi;
    if (e) {
      var n = e;
      if (!xT(t, e)) {
        if (Q_(t)) throw Error(De(418));
        e = na(n.nextSibling);
        var r = gi;
        e && xT(t, e)
          ? p2(r, n)
          : ((t.flags = (t.flags & -4097) | 2), (un = !1), (gi = t));
      }
    } else {
      if (Q_(t)) throw Error(De(418));
      (t.flags = (t.flags & -4097) | 2), (un = !1), (gi = t);
    }
  }
}
function _T(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  gi = t;
}
function Cp(t) {
  if (t !== gi) return !1;
  if (!un) return _T(t), (un = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !q_(t.type, t.memoizedProps))),
    e && (e = mi))
  ) {
    if (Q_(t)) throw (m2(), Error(De(418)));
    for (; e; ) p2(t, e), (e = na(e.nextSibling));
  }
  if ((_T(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(De(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              mi = na(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      mi = null;
    }
  } else mi = gi ? na(t.stateNode.nextSibling) : null;
  return !0;
}
function m2() {
  for (var t = mi; t; ) t = na(t.nextSibling);
}
function dc() {
  (mi = gi = null), (un = !1);
}
function nw(t) {
  ns === null ? (ns = [t]) : ns.push(t);
}
var rU = To.ReactCurrentBatchConfig;
function df(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(De(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(De(147, t));
      var i = r,
        s = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = i.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof t != "string") throw Error(De(284));
    if (!n._owner) throw Error(De(290, t));
  }
  return t;
}
function Rp(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      De(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function ST(t) {
  var e = t._init;
  return e(t._payload);
}
function g2(t) {
  function e(m, w) {
    if (t) {
      var S = m.deletions;
      S === null ? ((m.deletions = [w]), (m.flags |= 16)) : S.push(w);
    }
  }
  function n(m, w) {
    if (!t) return null;
    for (; w !== null; ) e(m, w), (w = w.sibling);
    return null;
  }
  function r(m, w) {
    for (m = new Map(); w !== null; )
      w.key !== null ? m.set(w.key, w) : m.set(w.index, w), (w = w.sibling);
    return m;
  }
  function i(m, w) {
    return (m = oa(m, w)), (m.index = 0), (m.sibling = null), m;
  }
  function s(m, w, S) {
    return (
      (m.index = S),
      t
        ? ((S = m.alternate),
          S !== null
            ? ((S = S.index), S < w ? ((m.flags |= 2), w) : S)
            : ((m.flags |= 2), w))
        : ((m.flags |= 1048576), w)
    );
  }
  function o(m) {
    return t && m.alternate === null && (m.flags |= 2), m;
  }
  function a(m, w, S, E) {
    return w === null || w.tag !== 6
      ? ((w = hx(S, m.mode, E)), (w.return = m), w)
      : ((w = i(w, S)), (w.return = m), w);
  }
  function l(m, w, S, E) {
    var T = S.type;
    return T === Uu
      ? d(m, w, S.props.children, E, S.key)
      : w !== null &&
        (w.elementType === T ||
          (typeof T == "object" &&
            T !== null &&
            T.$$typeof === jo &&
            ST(T) === w.type))
      ? ((E = i(w, S.props)), (E.ref = df(m, w, S)), (E.return = m), E)
      : ((E = $m(S.type, S.key, S.props, null, m.mode, E)),
        (E.ref = df(m, w, S)),
        (E.return = m),
        E);
  }
  function f(m, w, S, E) {
    return w === null ||
      w.tag !== 4 ||
      w.stateNode.containerInfo !== S.containerInfo ||
      w.stateNode.implementation !== S.implementation
      ? ((w = px(S, m.mode, E)), (w.return = m), w)
      : ((w = i(w, S.children || [])), (w.return = m), w);
  }
  function d(m, w, S, E, T) {
    return w === null || w.tag !== 7
      ? ((w = vl(S, m.mode, E, T)), (w.return = m), w)
      : ((w = i(w, S)), (w.return = m), w);
  }
  function h(m, w, S) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (w = hx("" + w, m.mode, S)), (w.return = m), w;
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case yp:
          return (
            (S = $m(w.type, w.key, w.props, null, m.mode, S)),
            (S.ref = df(m, null, w)),
            (S.return = m),
            S
          );
        case ku:
          return (w = px(w, m.mode, S)), (w.return = m), w;
        case jo:
          var E = w._init;
          return h(m, E(w._payload), S);
      }
      if (Of(w) || af(w))
        return (w = vl(w, m.mode, S, null)), (w.return = m), w;
      Rp(m, w);
    }
    return null;
  }
  function p(m, w, S, E) {
    var T = w !== null ? w.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return T !== null ? null : a(m, w, "" + S, E);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case yp:
          return S.key === T ? l(m, w, S, E) : null;
        case ku:
          return S.key === T ? f(m, w, S, E) : null;
        case jo:
          return (T = S._init), p(m, w, T(S._payload), E);
      }
      if (Of(S) || af(S)) return T !== null ? null : d(m, w, S, E, null);
      Rp(m, S);
    }
    return null;
  }
  function g(m, w, S, E, T) {
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return (m = m.get(S) || null), a(w, m, "" + E, T);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case yp:
          return (m = m.get(E.key === null ? S : E.key) || null), l(w, m, E, T);
        case ku:
          return (m = m.get(E.key === null ? S : E.key) || null), f(w, m, E, T);
        case jo:
          var A = E._init;
          return g(m, w, S, A(E._payload), T);
      }
      if (Of(E) || af(E)) return (m = m.get(S) || null), d(w, m, E, T, null);
      Rp(w, E);
    }
    return null;
  }
  function v(m, w, S, E) {
    for (
      var T = null, A = null, L = w, N = (w = 0), C = null;
      L !== null && N < S.length;
      N++
    ) {
      L.index > N ? ((C = L), (L = null)) : (C = L.sibling);
      var I = p(m, L, S[N], E);
      if (I === null) {
        L === null && (L = C);
        break;
      }
      t && L && I.alternate === null && e(m, L),
        (w = s(I, w, N)),
        A === null ? (T = I) : (A.sibling = I),
        (A = I),
        (L = C);
    }
    if (N === S.length) return n(m, L), un && Ka(m, N), T;
    if (L === null) {
      for (; N < S.length; N++)
        (L = h(m, S[N], E)),
          L !== null &&
            ((w = s(L, w, N)), A === null ? (T = L) : (A.sibling = L), (A = L));
      return un && Ka(m, N), T;
    }
    for (L = r(m, L); N < S.length; N++)
      (C = g(L, m, N, S[N], E)),
        C !== null &&
          (t && C.alternate !== null && L.delete(C.key === null ? N : C.key),
          (w = s(C, w, N)),
          A === null ? (T = C) : (A.sibling = C),
          (A = C));
    return (
      t &&
        L.forEach(function (k) {
          return e(m, k);
        }),
      un && Ka(m, N),
      T
    );
  }
  function _(m, w, S, E) {
    var T = af(S);
    if (typeof T != "function") throw Error(De(150));
    if (((S = T.call(S)), S == null)) throw Error(De(151));
    for (
      var A = (T = null), L = w, N = (w = 0), C = null, I = S.next();
      L !== null && !I.done;
      N++, I = S.next()
    ) {
      L.index > N ? ((C = L), (L = null)) : (C = L.sibling);
      var k = p(m, L, I.value, E);
      if (k === null) {
        L === null && (L = C);
        break;
      }
      t && L && k.alternate === null && e(m, L),
        (w = s(k, w, N)),
        A === null ? (T = k) : (A.sibling = k),
        (A = k),
        (L = C);
    }
    if (I.done) return n(m, L), un && Ka(m, N), T;
    if (L === null) {
      for (; !I.done; N++, I = S.next())
        (I = h(m, I.value, E)),
          I !== null &&
            ((w = s(I, w, N)), A === null ? (T = I) : (A.sibling = I), (A = I));
      return un && Ka(m, N), T;
    }
    for (L = r(m, L); !I.done; N++, I = S.next())
      (I = g(L, m, N, I.value, E)),
        I !== null &&
          (t && I.alternate !== null && L.delete(I.key === null ? N : I.key),
          (w = s(I, w, N)),
          A === null ? (T = I) : (A.sibling = I),
          (A = I));
    return (
      t &&
        L.forEach(function (R) {
          return e(m, R);
        }),
      un && Ka(m, N),
      T
    );
  }
  function x(m, w, S, E) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === Uu &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case yp:
          e: {
            for (var T = S.key, A = w; A !== null; ) {
              if (A.key === T) {
                if (((T = S.type), T === Uu)) {
                  if (A.tag === 7) {
                    n(m, A.sibling),
                      (w = i(A, S.props.children)),
                      (w.return = m),
                      (m = w);
                    break e;
                  }
                } else if (
                  A.elementType === T ||
                  (typeof T == "object" &&
                    T !== null &&
                    T.$$typeof === jo &&
                    ST(T) === A.type)
                ) {
                  n(m, A.sibling),
                    (w = i(A, S.props)),
                    (w.ref = df(m, A, S)),
                    (w.return = m),
                    (m = w);
                  break e;
                }
                n(m, A);
                break;
              } else e(m, A);
              A = A.sibling;
            }
            S.type === Uu
              ? ((w = vl(S.props.children, m.mode, E, S.key)),
                (w.return = m),
                (m = w))
              : ((E = $m(S.type, S.key, S.props, null, m.mode, E)),
                (E.ref = df(m, w, S)),
                (E.return = m),
                (m = E));
          }
          return o(m);
        case ku:
          e: {
            for (A = S.key; w !== null; ) {
              if (w.key === A)
                if (
                  w.tag === 4 &&
                  w.stateNode.containerInfo === S.containerInfo &&
                  w.stateNode.implementation === S.implementation
                ) {
                  n(m, w.sibling),
                    (w = i(w, S.children || [])),
                    (w.return = m),
                    (m = w);
                  break e;
                } else {
                  n(m, w);
                  break;
                }
              else e(m, w);
              w = w.sibling;
            }
            (w = px(S, m.mode, E)), (w.return = m), (m = w);
          }
          return o(m);
        case jo:
          return (A = S._init), x(m, w, A(S._payload), E);
      }
      if (Of(S)) return v(m, w, S, E);
      if (af(S)) return _(m, w, S, E);
      Rp(m, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        w !== null && w.tag === 6
          ? (n(m, w.sibling), (w = i(w, S)), (w.return = m), (m = w))
          : (n(m, w), (w = hx(S, m.mode, E)), (w.return = m), (m = w)),
        o(m))
      : n(m, w);
  }
  return x;
}
var hc = g2(!0),
  v2 = g2(!1),
  yg = Ma(null),
  xg = null,
  ju = null,
  rw = null;
function iw() {
  rw = ju = xg = null;
}
function sw(t) {
  var e = yg.current;
  rn(yg), (t._currentValue = e);
}
function tS(t, e, n) {
  for (; t !== null; ) {
    var r = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function rc(t, e) {
  (xg = t),
    (rw = ju = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (Qr = !0), (t.firstContext = null));
}
function Hi(t) {
  var e = t._currentValue;
  if (rw !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), ju === null)) {
      if (xg === null) throw Error(De(308));
      (ju = t), (xg.dependencies = { lanes: 0, firstContext: t });
    } else ju = ju.next = t;
  return e;
}
var ll = null;
function ow(t) {
  ll === null ? (ll = [t]) : ll.push(t);
}
function y2(t, e, n, r) {
  var i = e.interleaved;
  return (
    i === null ? ((n.next = n), ow(e)) : ((n.next = i.next), (i.next = n)),
    (e.interleaved = n),
    vo(t, r)
  );
}
function vo(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var $o = !1;
function aw(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function x2(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function ho(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function ra(t, e, n) {
  var r = t.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), Ot & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      vo(t, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), ow(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    vo(t, n)
  );
}
function Bm(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), $1(t, n);
  }
}
function wT(t, e) {
  var n = t.updateQueue,
    r = t.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (n = n.next);
      } while (n !== null);
      s === null ? (i = s = e) : (s = s.next = e);
    } else i = s = e;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function _g(t, e, n, r) {
  var i = t.updateQueue;
  $o = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      f = l.next;
    (l.next = null), o === null ? (s = f) : (o.next = f), (o = l);
    var d = t.alternate;
    d !== null &&
      ((d = d.updateQueue),
      (a = d.lastBaseUpdate),
      a !== o &&
        (a === null ? (d.firstBaseUpdate = f) : (a.next = f),
        (d.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var h = i.baseState;
    (o = 0), (d = f = l = null), (a = s);
    do {
      var p = a.lane,
        g = a.eventTime;
      if ((r & p) === p) {
        d !== null &&
          (d = d.next =
            {
              eventTime: g,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = t,
            _ = a;
          switch (((p = e), (g = n), _.tag)) {
            case 1:
              if (((v = _.payload), typeof v == "function")) {
                h = v.call(g, h, p);
                break e;
              }
              h = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = _.payload),
                (p = typeof v == "function" ? v.call(g, h, p) : v),
                p == null)
              )
                break e;
              h = mn({}, h, p);
              break e;
            case 2:
              $o = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((t.flags |= 64),
          (p = i.effects),
          p === null ? (i.effects = [a]) : p.push(a));
      } else
        (g = {
          eventTime: g,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          d === null ? ((f = d = g), (l = h)) : (d = d.next = g),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (i.lastBaseUpdate = p),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (d === null && (l = h),
      (i.baseState = l),
      (i.firstBaseUpdate = f),
      (i.lastBaseUpdate = d),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (o |= i.lane), (i = i.next);
      while (i !== e);
    } else s === null && (i.shared.lanes = 0);
    (Tl |= o), (t.lanes = o), (t.memoizedState = h);
  }
}
function MT(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(De(191, i));
        i.call(r);
      }
    }
}
var nh = {},
  Ns = Ma(nh),
  yd = Ma(nh),
  xd = Ma(nh);
function ul(t) {
  if (t === nh) throw Error(De(174));
  return t;
}
function lw(t, e) {
  switch ((en(xd, e), en(yd, t), en(Ns, nh), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : D_(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = D_(e, t));
  }
  rn(Ns), en(Ns, e);
}
function pc() {
  rn(Ns), rn(yd), rn(xd);
}
function _2(t) {
  ul(xd.current);
  var e = ul(Ns.current),
    n = D_(e, t.type);
  e !== n && (en(yd, t), en(Ns, n));
}
function uw(t) {
  yd.current === t && (rn(Ns), rn(yd));
}
var dn = Ma(0);
function Sg(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var ax = [];
function cw() {
  for (var t = 0; t < ax.length; t++)
    ax[t]._workInProgressVersionPrimary = null;
  ax.length = 0;
}
var Hm = To.ReactCurrentDispatcher,
  lx = To.ReactCurrentBatchConfig,
  bl = 0,
  pn = null,
  Vn = null,
  tr = null,
  wg = !1,
  Yf = !1,
  _d = 0,
  iU = 0;
function xr() {
  throw Error(De(321));
}
function fw(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!us(t[n], e[n])) return !1;
  return !0;
}
function dw(t, e, n, r, i, s) {
  if (
    ((bl = s),
    (pn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Hm.current = t === null || t.memoizedState === null ? lU : uU),
    (t = n(r, i)),
    Yf)
  ) {
    s = 0;
    do {
      if (((Yf = !1), (_d = 0), 25 <= s)) throw Error(De(301));
      (s += 1),
        (tr = Vn = null),
        (e.updateQueue = null),
        (Hm.current = cU),
        (t = n(r, i));
    } while (Yf);
  }
  if (
    ((Hm.current = Mg),
    (e = Vn !== null && Vn.next !== null),
    (bl = 0),
    (tr = Vn = pn = null),
    (wg = !1),
    e)
  )
    throw Error(De(300));
  return t;
}
function hw() {
  var t = _d !== 0;
  return (_d = 0), t;
}
function Ts() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return tr === null ? (pn.memoizedState = tr = t) : (tr = tr.next = t), tr;
}
function Vi() {
  if (Vn === null) {
    var t = pn.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Vn.next;
  var e = tr === null ? pn.memoizedState : tr.next;
  if (e !== null) (tr = e), (Vn = t);
  else {
    if (t === null) throw Error(De(310));
    (Vn = t),
      (t = {
        memoizedState: Vn.memoizedState,
        baseState: Vn.baseState,
        baseQueue: Vn.baseQueue,
        queue: Vn.queue,
        next: null,
      }),
      tr === null ? (pn.memoizedState = tr = t) : (tr = tr.next = t);
  }
  return tr;
}
function Sd(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function ux(t) {
  var e = Vi(),
    n = e.queue;
  if (n === null) throw Error(De(311));
  n.lastRenderedReducer = t;
  var r = Vn,
    i = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (n.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      l = null,
      f = s;
    do {
      var d = f.lane;
      if ((bl & d) === d)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: f.action,
              hasEagerState: f.hasEagerState,
              eagerState: f.eagerState,
              next: null,
            }),
          (r = f.hasEagerState ? f.eagerState : t(r, f.action));
      else {
        var h = {
          lane: d,
          action: f.action,
          hasEagerState: f.hasEagerState,
          eagerState: f.eagerState,
          next: null,
        };
        l === null ? ((a = l = h), (o = r)) : (l = l.next = h),
          (pn.lanes |= d),
          (Tl |= d);
      }
      f = f.next;
    } while (f !== null && f !== s);
    l === null ? (o = r) : (l.next = a),
      us(r, e.memoizedState) || (Qr = !0),
      (e.memoizedState = r),
      (e.baseState = o),
      (e.baseQueue = l),
      (n.lastRenderedState = r);
  }
  if (((t = n.interleaved), t !== null)) {
    i = t;
    do (s = i.lane), (pn.lanes |= s), (Tl |= s), (i = i.next);
    while (i !== t);
  } else i === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function cx(t) {
  var e = Vi(),
    n = e.queue;
  if (n === null) throw Error(De(311));
  n.lastRenderedReducer = t;
  var r = n.dispatch,
    i = n.pending,
    s = e.memoizedState;
  if (i !== null) {
    n.pending = null;
    var o = (i = i.next);
    do (s = t(s, o.action)), (o = o.next);
    while (o !== i);
    us(s, e.memoizedState) || (Qr = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, r];
}
function S2() {}
function w2(t, e) {
  var n = pn,
    r = Vi(),
    i = e(),
    s = !us(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (Qr = !0)),
    (r = r.queue),
    pw(b2.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || s || (tr !== null && tr.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      wd(9, E2.bind(null, n, r, i, e), void 0, null),
      nr === null)
    )
      throw Error(De(349));
    bl & 30 || M2(n, e, i);
  }
  return i;
}
function M2(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = pn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (pn.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function E2(t, e, n, r) {
  (e.value = n), (e.getSnapshot = r), T2(e) && A2(t);
}
function b2(t, e, n) {
  return n(function () {
    T2(e) && A2(t);
  });
}
function T2(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !us(t, n);
  } catch {
    return !0;
  }
}
function A2(t) {
  var e = vo(t, 1);
  e !== null && ls(e, t, 1, -1);
}
function ET(t) {
  var e = Ts();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Sd,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = aU.bind(null, pn, t)),
    [e.memoizedState, t]
  );
}
function wd(t, e, n, r) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
    (e = pn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (pn.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
    t
  );
}
function C2() {
  return Vi().memoizedState;
}
function Vm(t, e, n, r) {
  var i = Ts();
  (pn.flags |= t),
    (i.memoizedState = wd(1 | e, n, void 0, r === void 0 ? null : r));
}
function t0(t, e, n, r) {
  var i = Vi();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (Vn !== null) {
    var o = Vn.memoizedState;
    if (((s = o.destroy), r !== null && fw(r, o.deps))) {
      i.memoizedState = wd(e, n, s, r);
      return;
    }
  }
  (pn.flags |= t), (i.memoizedState = wd(1 | e, n, s, r));
}
function bT(t, e) {
  return Vm(8390656, 8, t, e);
}
function pw(t, e) {
  return t0(2048, 8, t, e);
}
function R2(t, e) {
  return t0(4, 2, t, e);
}
function P2(t, e) {
  return t0(4, 4, t, e);
}
function L2(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function I2(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), t0(4, 4, L2.bind(null, e, t), n)
  );
}
function mw() {}
function N2(t, e) {
  var n = Vi();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && fw(e, r[1])
    ? r[0]
    : ((n.memoizedState = [t, e]), t);
}
function O2(t, e) {
  var n = Vi();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && fw(e, r[1])
    ? r[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function D2(t, e, n) {
  return bl & 21
    ? (us(n, e) || ((n = BP()), (pn.lanes |= n), (Tl |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (Qr = !0)), (t.memoizedState = n));
}
function sU(t, e) {
  var n = jt;
  (jt = n !== 0 && 4 > n ? n : 4), t(!0);
  var r = lx.transition;
  lx.transition = {};
  try {
    t(!1), e();
  } finally {
    (jt = n), (lx.transition = r);
  }
}
function k2() {
  return Vi().memoizedState;
}
function oU(t, e, n) {
  var r = sa(t);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    U2(t))
  )
    F2(e, n);
  else if (((n = y2(t, e, n, r)), n !== null)) {
    var i = Br();
    ls(n, t, r, i), z2(n, e, r);
  }
}
function aU(t, e, n) {
  var r = sa(t),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (U2(t)) F2(e, i);
  else {
    var s = t.alternate;
    if (
      t.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, n);
        if (((i.hasEagerState = !0), (i.eagerState = a), us(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), ow(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = y2(t, e, i, r)),
      n !== null && ((i = Br()), ls(n, t, r, i), z2(n, e, r));
  }
}
function U2(t) {
  var e = t.alternate;
  return t === pn || (e !== null && e === pn);
}
function F2(t, e) {
  Yf = wg = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function z2(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), $1(t, n);
  }
}
var Mg = {
    readContext: Hi,
    useCallback: xr,
    useContext: xr,
    useEffect: xr,
    useImperativeHandle: xr,
    useInsertionEffect: xr,
    useLayoutEffect: xr,
    useMemo: xr,
    useReducer: xr,
    useRef: xr,
    useState: xr,
    useDebugValue: xr,
    useDeferredValue: xr,
    useTransition: xr,
    useMutableSource: xr,
    useSyncExternalStore: xr,
    useId: xr,
    unstable_isNewReconciler: !1,
  },
  lU = {
    readContext: Hi,
    useCallback: function (t, e) {
      return (Ts().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: Hi,
    useEffect: bT,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        Vm(4194308, 4, L2.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return Vm(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return Vm(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = Ts();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var r = Ts();
      return (
        (e = n !== void 0 ? n(e) : e),
        (r.memoizedState = r.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (r.queue = t),
        (t = t.dispatch = oU.bind(null, pn, t)),
        [r.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = Ts();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: ET,
    useDebugValue: mw,
    useDeferredValue: function (t) {
      return (Ts().memoizedState = t);
    },
    useTransition: function () {
      var t = ET(!1),
        e = t[0];
      return (t = sU.bind(null, t[1])), (Ts().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var r = pn,
        i = Ts();
      if (un) {
        if (n === void 0) throw Error(De(407));
        n = n();
      } else {
        if (((n = e()), nr === null)) throw Error(De(349));
        bl & 30 || M2(r, e, n);
      }
      i.memoizedState = n;
      var s = { value: n, getSnapshot: e };
      return (
        (i.queue = s),
        bT(b2.bind(null, r, s, t), [t]),
        (r.flags |= 2048),
        wd(9, E2.bind(null, r, s, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = Ts(),
        e = nr.identifierPrefix;
      if (un) {
        var n = co,
          r = uo;
        (n = (r & ~(1 << (32 - as(r) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = _d++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = iU++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  uU = {
    readContext: Hi,
    useCallback: N2,
    useContext: Hi,
    useEffect: pw,
    useImperativeHandle: I2,
    useInsertionEffect: R2,
    useLayoutEffect: P2,
    useMemo: O2,
    useReducer: ux,
    useRef: C2,
    useState: function () {
      return ux(Sd);
    },
    useDebugValue: mw,
    useDeferredValue: function (t) {
      var e = Vi();
      return D2(e, Vn.memoizedState, t);
    },
    useTransition: function () {
      var t = ux(Sd)[0],
        e = Vi().memoizedState;
      return [t, e];
    },
    useMutableSource: S2,
    useSyncExternalStore: w2,
    useId: k2,
    unstable_isNewReconciler: !1,
  },
  cU = {
    readContext: Hi,
    useCallback: N2,
    useContext: Hi,
    useEffect: pw,
    useImperativeHandle: I2,
    useInsertionEffect: R2,
    useLayoutEffect: P2,
    useMemo: O2,
    useReducer: cx,
    useRef: C2,
    useState: function () {
      return cx(Sd);
    },
    useDebugValue: mw,
    useDeferredValue: function (t) {
      var e = Vi();
      return Vn === null ? (e.memoizedState = t) : D2(e, Vn.memoizedState, t);
    },
    useTransition: function () {
      var t = cx(Sd)[0],
        e = Vi().memoizedState;
      return [t, e];
    },
    useMutableSource: S2,
    useSyncExternalStore: w2,
    useId: k2,
    unstable_isNewReconciler: !1,
  };
function Qi(t, e) {
  if (t && t.defaultProps) {
    (e = mn({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
function nS(t, e, n, r) {
  (e = t.memoizedState),
    (n = n(r, e)),
    (n = n == null ? e : mn({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var n0 = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Dl(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var r = Br(),
      i = sa(t),
      s = ho(r, i);
    (s.payload = e),
      n != null && (s.callback = n),
      (e = ra(t, s, i)),
      e !== null && (ls(e, t, i, r), Bm(e, t, i));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var r = Br(),
      i = sa(t),
      s = ho(r, i);
    (s.tag = 1),
      (s.payload = e),
      n != null && (s.callback = n),
      (e = ra(t, s, i)),
      e !== null && (ls(e, t, i, r), Bm(e, t, i));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = Br(),
      r = sa(t),
      i = ho(n, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = ra(t, i, r)),
      e !== null && (ls(e, t, r, n), Bm(e, t, r));
  },
};
function TT(t, e, n, r, i, s, o) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(r, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !pd(n, r) || !pd(i, s)
      : !0
  );
}
function B2(t, e, n) {
  var r = !1,
    i = ma,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Hi(s))
      : ((i = ti(e) ? Ml : Ir.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? fc(t, i) : ma)),
    (e = new e(n, s)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = n0),
    (t.stateNode = e),
    (e._reactInternals = t),
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function AT(t, e, n, r) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && n0.enqueueReplaceState(e, e.state, null);
}
function rS(t, e, n, r) {
  var i = t.stateNode;
  (i.props = n), (i.state = t.memoizedState), (i.refs = {}), aw(t);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (i.context = Hi(s))
    : ((s = ti(e) ? Ml : Ir.current), (i.context = fc(t, s))),
    (i.state = t.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (nS(t, e, s, n), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && n0.enqueueReplaceState(i, i.state, null),
      _g(t, n, i, r),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function mc(t, e) {
  try {
    var n = "",
      r = e;
    do (n += FD(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: t, source: e, stack: i, digest: null };
}
function fx(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function iS(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var fU = typeof WeakMap == "function" ? WeakMap : Map;
function H2(t, e, n) {
  (n = ho(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = e.value;
  return (
    (n.callback = function () {
      bg || ((bg = !0), (pS = r)), iS(t, e);
    }),
    n
  );
}
function V2(t, e, n) {
  (n = ho(-1, n)), (n.tag = 3);
  var r = t.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        iS(t, e);
      });
  }
  var s = t.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        iS(t, e),
          typeof r != "function" &&
            (ia === null ? (ia = new Set([this])) : ia.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    n
  );
}
function CT(t, e, n) {
  var r = t.pingCache;
  if (r === null) {
    r = t.pingCache = new fU();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(n) || (i.add(n), (t = bU.bind(null, t, e, n)), e.then(t, t));
}
function RT(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function PT(t, e, n, r, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = ho(-1, 1)), (e.tag = 2), ra(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var dU = To.ReactCurrentOwner,
  Qr = !1;
function Fr(t, e, n, r) {
  e.child = t === null ? v2(e, null, n, r) : hc(e, t.child, n, r);
}
function LT(t, e, n, r, i) {
  n = n.render;
  var s = e.ref;
  return (
    rc(e, i),
    (r = dw(t, e, n, r, s, i)),
    (n = hw()),
    t !== null && !Qr
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        yo(t, e, i))
      : (un && n && ew(e), (e.flags |= 1), Fr(t, e, r, i), e.child)
  );
}
function IT(t, e, n, r, i) {
  if (t === null) {
    var s = n.type;
    return typeof s == "function" &&
      !Mw(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), W2(t, e, s, r, i))
      : ((t = $m(n.type, null, r, e, e.mode, i)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((s = t.child), !(t.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : pd), n(o, r) && t.ref === e.ref)
    )
      return yo(t, e, i);
  }
  return (
    (e.flags |= 1),
    (t = oa(s, r)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function W2(t, e, n, r, i) {
  if (t !== null) {
    var s = t.memoizedProps;
    if (pd(s, r) && t.ref === e.ref)
      if (((Qr = !1), (e.pendingProps = r = s), (t.lanes & i) !== 0))
        t.flags & 131072 && (Qr = !0);
      else return (e.lanes = t.lanes), yo(t, e, i);
  }
  return sS(t, e, n, r, i);
}
function G2(t, e, n) {
  var r = e.pendingProps,
    i = r.children,
    s = t !== null ? t.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        en(Xu, di),
        (di |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = s !== null ? s.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          en(Xu, di),
          (di |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        en(Xu, di),
        (di |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | n), (e.memoizedState = null)) : (r = n),
      en(Xu, di),
      (di |= r);
  return Fr(t, e, i, n), e.child;
}
function j2(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function sS(t, e, n, r, i) {
  var s = ti(n) ? Ml : Ir.current;
  return (
    (s = fc(e, s)),
    rc(e, i),
    (n = dw(t, e, n, r, s, i)),
    (r = hw()),
    t !== null && !Qr
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        yo(t, e, i))
      : (un && r && ew(e), (e.flags |= 1), Fr(t, e, n, i), e.child)
  );
}
function NT(t, e, n, r, i) {
  if (ti(n)) {
    var s = !0;
    mg(e);
  } else s = !1;
  if ((rc(e, i), e.stateNode === null))
    Wm(t, e), B2(e, n, r), rS(e, n, r, i), (r = !0);
  else if (t === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      f = n.contextType;
    typeof f == "object" && f !== null
      ? (f = Hi(f))
      : ((f = ti(n) ? Ml : Ir.current), (f = fc(e, f)));
    var d = n.getDerivedStateFromProps,
      h =
        typeof d == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    h ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || l !== f) && AT(e, o, r, f)),
      ($o = !1);
    var p = e.memoizedState;
    (o.state = p),
      _g(e, r, o, i),
      (l = e.memoizedState),
      a !== r || p !== l || ei.current || $o
        ? (typeof d == "function" && (nS(e, n, d, r), (l = e.memoizedState)),
          (a = $o || TT(e, n, a, r, p, l, f))
            ? (h ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = f),
          (r = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (o = e.stateNode),
      x2(t, e),
      (a = e.memoizedProps),
      (f = e.type === e.elementType ? a : Qi(e.type, a)),
      (o.props = f),
      (h = e.pendingProps),
      (p = o.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = Hi(l))
        : ((l = ti(n) ? Ml : Ir.current), (l = fc(e, l)));
    var g = n.getDerivedStateFromProps;
    (d =
      typeof g == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== h || p !== l) && AT(e, o, r, l)),
      ($o = !1),
      (p = e.memoizedState),
      (o.state = p),
      _g(e, r, o, i);
    var v = e.memoizedState;
    a !== h || p !== v || ei.current || $o
      ? (typeof g == "function" && (nS(e, n, g, r), (v = e.memoizedState)),
        (f = $o || TT(e, n, f, r, p, v, l) || !1)
          ? (d ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, v, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, v, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = v)),
        (o.props = r),
        (o.state = v),
        (o.context = l),
        (r = f))
      : (typeof o.componentDidUpdate != "function" ||
          (a === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return oS(t, e, n, r, s, i);
}
function oS(t, e, n, r, i, s) {
  j2(t, e);
  var o = (e.flags & 128) !== 0;
  if (!r && !o) return i && yT(e, n, !1), yo(t, e, s);
  (r = e.stateNode), (dU.current = e);
  var a =
    o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    t !== null && o
      ? ((e.child = hc(e, t.child, null, s)), (e.child = hc(e, null, a, s)))
      : Fr(t, e, a, s),
    (e.memoizedState = r.state),
    i && yT(e, n, !0),
    e.child
  );
}
function $2(t) {
  var e = t.stateNode;
  e.pendingContext
    ? vT(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && vT(t, e.context, !1),
    lw(t, e.containerInfo);
}
function OT(t, e, n, r, i) {
  return dc(), nw(i), (e.flags |= 256), Fr(t, e, n, r), e.child;
}
var aS = { dehydrated: null, treeContext: null, retryLane: 0 };
function lS(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function X2(t, e, n) {
  var r = e.pendingProps,
    i = dn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (i |= 1),
    en(dn, i & 1),
    t === null)
  )
    return (
      eS(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = r.children),
          (t = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = s0(o, r, 0, null)),
              (t = vl(t, r, n, null)),
              (s.return = e),
              (t.return = e),
              (s.sibling = t),
              (e.child = s),
              (e.child.memoizedState = lS(n)),
              (e.memoizedState = aS),
              t)
            : gw(e, o))
    );
  if (((i = t.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return hU(t, e, o, r, a, i, n);
  if (s) {
    (s = r.fallback), (o = e.mode), (i = t.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = oa(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = oa(a, s)) : ((s = vl(s, o, n, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (o = t.child.memoizedState),
      (o =
        o === null
          ? lS(n)
          : {
              baseLanes: o.baseLanes | n,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = t.childLanes & ~n),
      (e.memoizedState = aS),
      r
    );
  }
  return (
    (s = t.child),
    (t = s.sibling),
    (r = oa(s, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = n),
    (r.return = e),
    (r.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function gw(t, e) {
  return (
    (e = s0({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function Pp(t, e, n, r) {
  return (
    r !== null && nw(r),
    hc(e, t.child, null, n),
    (t = gw(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function hU(t, e, n, r, i, s, o) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (r = fx(Error(De(422)))), Pp(t, e, o, r))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((s = r.fallback),
        (i = e.mode),
        (r = s0({ mode: "visible", children: r.children }, i, 0, null)),
        (s = vl(s, i, o, null)),
        (s.flags |= 2),
        (r.return = e),
        (s.return = e),
        (r.sibling = s),
        (e.child = r),
        e.mode & 1 && hc(e, t.child, null, o),
        (e.child.memoizedState = lS(o)),
        (e.memoizedState = aS),
        s);
  if (!(e.mode & 1)) return Pp(t, e, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (s = Error(De(419))), (r = fx(s, r, void 0)), Pp(t, e, o, r)
    );
  }
  if (((a = (o & t.childLanes) !== 0), Qr || a)) {
    if (((r = nr), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), vo(t, i), ls(r, t, i, -1));
    }
    return ww(), (r = fx(Error(De(421)))), Pp(t, e, o, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = TU.bind(null, t)),
      (i._reactRetry = e),
      null)
    : ((t = s.treeContext),
      (mi = na(i.nextSibling)),
      (gi = e),
      (un = !0),
      (ns = null),
      t !== null &&
        ((ki[Ui++] = uo),
        (ki[Ui++] = co),
        (ki[Ui++] = El),
        (uo = t.id),
        (co = t.overflow),
        (El = e)),
      (e = gw(e, r.children)),
      (e.flags |= 4096),
      e);
}
function DT(t, e, n) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), tS(t.return, e, n);
}
function dx(t, e, n, r, i) {
  var s = t.memoizedState;
  s === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i));
}
function Y2(t, e, n) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((Fr(t, e, r.children, n), (r = dn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && DT(t, n, e);
        else if (t.tag === 19) DT(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    r &= 1;
  }
  if ((en(dn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = e.child, i = null; n !== null; )
          (t = n.alternate),
            t !== null && Sg(t) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = e.child), (e.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          dx(e, !1, i, n, s);
        break;
      case "backwards":
        for (n = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && Sg(t) === null)) {
            e.child = i;
            break;
          }
          (t = i.sibling), (i.sibling = n), (n = i), (i = t);
        }
        dx(e, !0, n, null, s);
        break;
      case "together":
        dx(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function Wm(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function yo(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (Tl |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(De(153));
  if (e.child !== null) {
    for (
      t = e.child, n = oa(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = oa(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function pU(t, e, n) {
  switch (e.tag) {
    case 3:
      $2(e), dc();
      break;
    case 5:
      _2(e);
      break;
    case 1:
      ti(e.type) && mg(e);
      break;
    case 4:
      lw(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      en(yg, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (en(dn, dn.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? X2(t, e, n)
          : (en(dn, dn.current & 1),
            (t = yo(t, e, n)),
            t !== null ? t.sibling : null);
      en(dn, dn.current & 1);
      break;
    case 19:
      if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (r) return Y2(t, e, n);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        en(dn, dn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), G2(t, e, n);
  }
  return yo(t, e, n);
}
var q2, uS, K2, Z2;
q2 = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
uS = function () {};
K2 = function (t, e, n, r) {
  var i = t.memoizedProps;
  if (i !== r) {
    (t = e.stateNode), ul(Ns.current);
    var s = null;
    switch (n) {
      case "input":
        (i = L_(t, i)), (r = L_(t, r)), (s = []);
        break;
      case "select":
        (i = mn({}, i, { value: void 0 })),
          (r = mn({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = O_(t, i)), (r = O_(t, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (t.onclick = hg);
    }
    k_(n, r);
    var o;
    n = null;
    for (f in i)
      if (!r.hasOwnProperty(f) && i.hasOwnProperty(f) && i[f] != null)
        if (f === "style") {
          var a = i[f];
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), (n[o] = ""));
        } else
          f !== "dangerouslySetInnerHTML" &&
            f !== "children" &&
            f !== "suppressContentEditableWarning" &&
            f !== "suppressHydrationWarning" &&
            f !== "autoFocus" &&
            (ad.hasOwnProperty(f)
              ? s || (s = [])
              : (s = s || []).push(f, null));
    for (f in r) {
      var l = r[f];
      if (
        ((a = i != null ? i[f] : void 0),
        r.hasOwnProperty(f) && l !== a && (l != null || a != null))
      )
        if (f === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (n || (n = {}), (n[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (n || (n = {}), (n[o] = l[o]));
          } else n || (s || (s = []), s.push(f, n)), (n = l);
        else
          f === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(f, l))
            : f === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(f, "" + l)
            : f !== "suppressContentEditableWarning" &&
              f !== "suppressHydrationWarning" &&
              (ad.hasOwnProperty(f)
                ? (l != null && f === "onScroll" && nn("scroll", t),
                  s || a === l || (s = []))
                : (s = s || []).push(f, l));
    }
    n && (s = s || []).push("style", n);
    var f = s;
    (e.updateQueue = f) && (e.flags |= 4);
  }
};
Z2 = function (t, e, n, r) {
  n !== r && (e.flags |= 4);
};
function hf(t, e) {
  if (!un)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (r.sibling = null);
    }
}
function _r(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0;
  if (e)
    for (var i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling);
  else
    for (i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = t),
        (i = i.sibling);
  return (t.subtreeFlags |= r), (t.childLanes = n), e;
}
function mU(t, e, n) {
  var r = e.pendingProps;
  switch ((tw(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return _r(e), null;
    case 1:
      return ti(e.type) && pg(), _r(e), null;
    case 3:
      return (
        (r = e.stateNode),
        pc(),
        rn(ei),
        rn(Ir),
        cw(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (t === null || t.child === null) &&
          (Cp(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), ns !== null && (vS(ns), (ns = null)))),
        uS(t, e),
        _r(e),
        null
      );
    case 5:
      uw(e);
      var i = ul(xd.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        K2(t, e, n, r, i),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(De(166));
          return _r(e), null;
        }
        if (((t = ul(Ns.current)), Cp(e))) {
          (r = e.stateNode), (n = e.type);
          var s = e.memoizedProps;
          switch (((r[Rs] = e), (r[vd] = s), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              nn("cancel", r), nn("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              nn("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < kf.length; i++) nn(kf[i], r);
              break;
            case "source":
              nn("error", r);
              break;
            case "img":
            case "image":
            case "link":
              nn("error", r), nn("load", r);
              break;
            case "details":
              nn("toggle", r);
              break;
            case "input":
              Gb(r, s), nn("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                nn("invalid", r);
              break;
            case "textarea":
              $b(r, s), nn("invalid", r);
          }
          k_(n, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ap(r.textContent, a, t),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ap(r.textContent, a, t),
                    (i = ["children", "" + a]))
                : ad.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  nn("scroll", r);
            }
          switch (n) {
            case "input":
              xp(r), jb(r, s, !0);
              break;
            case "textarea":
              xp(r), Xb(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = hg);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = bP(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = o.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof r.is == "string"
                ? (t = o.createElement(n, { is: r.is }))
                : ((t = o.createElement(n)),
                  n === "select" &&
                    ((o = t),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (t = o.createElementNS(t, n)),
            (t[Rs] = e),
            (t[vd] = r),
            q2(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((o = U_(n, r)), n)) {
              case "dialog":
                nn("cancel", t), nn("close", t), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                nn("load", t), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < kf.length; i++) nn(kf[i], t);
                i = r;
                break;
              case "source":
                nn("error", t), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                nn("error", t), nn("load", t), (i = r);
                break;
              case "details":
                nn("toggle", t), (i = r);
                break;
              case "input":
                Gb(t, r), (i = L_(t, r)), nn("invalid", t);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = mn({}, r, { value: void 0 })),
                  nn("invalid", t);
                break;
              case "textarea":
                $b(t, r), (i = O_(t, r)), nn("invalid", t);
                break;
              default:
                i = r;
            }
            k_(n, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? CP(t, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && TP(t, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && ld(t, l)
                    : typeof l == "number" && ld(t, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (ad.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && nn("scroll", t)
                      : l != null && B1(t, s, l, o));
              }
            switch (n) {
              case "input":
                xp(t), jb(t, r, !1);
                break;
              case "textarea":
                xp(t), Xb(t);
                break;
              case "option":
                r.value != null && t.setAttribute("value", "" + pa(r.value));
                break;
              case "select":
                (t.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? Qu(t, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      Qu(t, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (t.onclick = hg);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return _r(e), null;
    case 6:
      if (t && e.stateNode != null) Z2(t, e, t.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(De(166));
        if (((n = ul(xd.current)), ul(Ns.current), Cp(e))) {
          if (
            ((r = e.stateNode),
            (n = e.memoizedProps),
            (r[Rs] = e),
            (s = r.nodeValue !== n) && ((t = gi), t !== null))
          )
            switch (t.tag) {
              case 3:
                Ap(r.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  Ap(r.nodeValue, n, (t.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Rs] = e),
            (e.stateNode = r);
      }
      return _r(e), null;
    case 13:
      if (
        (rn(dn),
        (r = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (un && mi !== null && e.mode & 1 && !(e.flags & 128))
          m2(), dc(), (e.flags |= 98560), (s = !1);
        else if (((s = Cp(e)), r !== null && r.dehydrated !== null)) {
          if (t === null) {
            if (!s) throw Error(De(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(De(317));
            s[Rs] = e;
          } else
            dc(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          _r(e), (s = !1);
        } else ns !== null && (vS(ns), (ns = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((r = r !== null),
          r !== (t !== null && t.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || dn.current & 1 ? Gn === 0 && (Gn = 3) : ww())),
          e.updateQueue !== null && (e.flags |= 4),
          _r(e),
          null);
    case 4:
      return (
        pc(), uS(t, e), t === null && md(e.stateNode.containerInfo), _r(e), null
      );
    case 10:
      return sw(e.type._context), _r(e), null;
    case 17:
      return ti(e.type) && pg(), _r(e), null;
    case 19:
      if ((rn(dn), (s = e.memoizedState), s === null)) return _r(e), null;
      if (((r = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) hf(s, !1);
        else {
          if (Gn !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((o = Sg(t)), o !== null)) {
                for (
                  e.flags |= 128,
                    hf(s, !1),
                    r = o.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = n,
                    n = e.child;
                  n !== null;

                )
                  (s = n),
                    (t = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = t),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (t = o.dependencies),
                        (s.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return en(dn, (dn.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          s.tail !== null &&
            Cn() > gc &&
            ((e.flags |= 128), (r = !0), hf(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((t = Sg(o)), t !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              hf(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !un)
            )
              return _r(e), null;
          } else
            2 * Cn() - s.renderingStartTime > gc &&
              n !== 1073741824 &&
              ((e.flags |= 128), (r = !0), hf(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((n = s.last),
            n !== null ? (n.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Cn()),
          (e.sibling = null),
          (n = dn.current),
          en(dn, r ? (n & 1) | 2 : n & 1),
          e)
        : (_r(e), null);
    case 22:
    case 23:
      return (
        Sw(),
        (r = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? di & 1073741824 && (_r(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : _r(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(De(156, e.tag));
}
function gU(t, e) {
  switch ((tw(e), e.tag)) {
    case 1:
      return (
        ti(e.type) && pg(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        pc(),
        rn(ei),
        rn(Ir),
        cw(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return uw(e), null;
    case 13:
      if (
        (rn(dn), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(De(340));
        dc();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return rn(dn), null;
    case 4:
      return pc(), null;
    case 10:
      return sw(e.type._context), null;
    case 22:
    case 23:
      return Sw(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Lp = !1,
  Tr = !1,
  vU = typeof WeakSet == "function" ? WeakSet : Set,
  Ke = null;
function $u(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        wn(t, e, r);
      }
    else n.current = null;
}
function cS(t, e, n) {
  try {
    n();
  } catch (r) {
    wn(t, e, r);
  }
}
var kT = !1;
function yU(t, e) {
  if (((X_ = cg), (t = n2()), Q1(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            f = 0,
            d = 0,
            h = t,
            p = null;
          t: for (;;) {
            for (
              var g;
              h !== n || (i !== 0 && h.nodeType !== 3) || (a = o + i),
                h !== s || (r !== 0 && h.nodeType !== 3) || (l = o + r),
                h.nodeType === 3 && (o += h.nodeValue.length),
                (g = h.firstChild) !== null;

            )
              (p = h), (h = g);
            for (;;) {
              if (h === t) break t;
              if (
                (p === n && ++f === i && (a = o),
                p === s && ++d === r && (l = o),
                (g = h.nextSibling) !== null)
              )
                break;
              (h = p), (p = h.parentNode);
            }
            h = g;
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    Y_ = { focusedElem: t, selectionRange: n }, cg = !1, Ke = e;
    Ke !== null;

  )
    if (((e = Ke), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (Ke = t);
    else
      for (; Ke !== null; ) {
        e = Ke;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var _ = v.memoizedProps,
                    x = v.memoizedState,
                    m = e.stateNode,
                    w = m.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? _ : Qi(e.type, _),
                      x
                    );
                  m.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(De(163));
            }
        } catch (E) {
          wn(e, e.return, E);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (Ke = t);
          break;
        }
        Ke = e.return;
      }
  return (v = kT), (kT = !1), v;
}
function qf(t, e, n) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & t) === t) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && cS(e, n, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function r0(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== e);
  }
}
function fS(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function J2(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), J2(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[Rs], delete e[vd], delete e[Z_], delete e[eU], delete e[tU])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function Q2(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function UT(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || Q2(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function dS(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = hg));
  else if (r !== 4 && ((t = t.child), t !== null))
    for (dS(t, e, n), t = t.sibling; t !== null; ) dS(t, e, n), (t = t.sibling);
}
function hS(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (r !== 4 && ((t = t.child), t !== null))
    for (hS(t, e, n), t = t.sibling; t !== null; ) hS(t, e, n), (t = t.sibling);
}
var ur = null,
  ts = !1;
function Uo(t, e, n) {
  for (n = n.child; n !== null; ) eL(t, e, n), (n = n.sibling);
}
function eL(t, e, n) {
  if (Is && typeof Is.onCommitFiberUnmount == "function")
    try {
      Is.onCommitFiberUnmount(qg, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Tr || $u(n, e);
    case 6:
      var r = ur,
        i = ts;
      (ur = null),
        Uo(t, e, n),
        (ur = r),
        (ts = i),
        ur !== null &&
          (ts
            ? ((t = ur),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : ur.removeChild(n.stateNode));
      break;
    case 18:
      ur !== null &&
        (ts
          ? ((t = ur),
            (n = n.stateNode),
            t.nodeType === 8
              ? sx(t.parentNode, n)
              : t.nodeType === 1 && sx(t, n),
            dd(t))
          : sx(ur, n.stateNode));
      break;
    case 4:
      (r = ur),
        (i = ts),
        (ur = n.stateNode.containerInfo),
        (ts = !0),
        Uo(t, e, n),
        (ur = r),
        (ts = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Tr &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && cS(n, e, o),
            (i = i.next);
        } while (i !== r);
      }
      Uo(t, e, n);
      break;
    case 1:
      if (
        !Tr &&
        ($u(n, e),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          wn(n, e, a);
        }
      Uo(t, e, n);
      break;
    case 21:
      Uo(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((Tr = (r = Tr) || n.memoizedState !== null), Uo(t, e, n), (Tr = r))
        : Uo(t, e, n);
      break;
    default:
      Uo(t, e, n);
  }
}
function FT(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new vU()),
      e.forEach(function (r) {
        var i = AU.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function qi(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var s = t,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (ur = a.stateNode), (ts = !1);
              break e;
            case 3:
              (ur = a.stateNode.containerInfo), (ts = !0);
              break e;
            case 4:
              (ur = a.stateNode.containerInfo), (ts = !0);
              break e;
          }
          a = a.return;
        }
        if (ur === null) throw Error(De(160));
        eL(s, o, i), (ur = null), (ts = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (f) {
        wn(i, e, f);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) tL(e, t), (e = e.sibling);
}
function tL(t, e) {
  var n = t.alternate,
    r = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((qi(e, t), Ms(t), r & 4)) {
        try {
          qf(3, t, t.return), r0(3, t);
        } catch (_) {
          wn(t, t.return, _);
        }
        try {
          qf(5, t, t.return);
        } catch (_) {
          wn(t, t.return, _);
        }
      }
      break;
    case 1:
      qi(e, t), Ms(t), r & 512 && n !== null && $u(n, n.return);
      break;
    case 5:
      if (
        (qi(e, t),
        Ms(t),
        r & 512 && n !== null && $u(n, n.return),
        t.flags & 32)
      ) {
        var i = t.stateNode;
        try {
          ld(i, "");
        } catch (_) {
          wn(t, t.return, _);
        }
      }
      if (r & 4 && ((i = t.stateNode), i != null)) {
        var s = t.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && MP(i, s),
              U_(a, o);
            var f = U_(a, s);
            for (o = 0; o < l.length; o += 2) {
              var d = l[o],
                h = l[o + 1];
              d === "style"
                ? CP(i, h)
                : d === "dangerouslySetInnerHTML"
                ? TP(i, h)
                : d === "children"
                ? ld(i, h)
                : B1(i, d, h, f);
            }
            switch (a) {
              case "input":
                I_(i, s);
                break;
              case "textarea":
                EP(i, s);
                break;
              case "select":
                var p = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var g = s.value;
                g != null
                  ? Qu(i, !!s.multiple, g, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Qu(i, !!s.multiple, s.defaultValue, !0)
                      : Qu(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[vd] = s;
          } catch (_) {
            wn(t, t.return, _);
          }
      }
      break;
    case 6:
      if ((qi(e, t), Ms(t), r & 4)) {
        if (t.stateNode === null) throw Error(De(162));
        (i = t.stateNode), (s = t.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (_) {
          wn(t, t.return, _);
        }
      }
      break;
    case 3:
      if (
        (qi(e, t), Ms(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          dd(e.containerInfo);
        } catch (_) {
          wn(t, t.return, _);
        }
      break;
    case 4:
      qi(e, t), Ms(t);
      break;
    case 13:
      qi(e, t),
        Ms(t),
        (i = t.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (xw = Cn())),
        r & 4 && FT(t);
      break;
    case 22:
      if (
        ((d = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((Tr = (f = Tr) || d), qi(e, t), (Tr = f)) : qi(e, t),
        Ms(t),
        r & 8192)
      ) {
        if (
          ((f = t.memoizedState !== null),
          (t.stateNode.isHidden = f) && !d && t.mode & 1)
        )
          for (Ke = t, d = t.child; d !== null; ) {
            for (h = Ke = d; Ke !== null; ) {
              switch (((p = Ke), (g = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  qf(4, p, p.return);
                  break;
                case 1:
                  $u(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (r = p), (n = p.return);
                    try {
                      (e = r),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (_) {
                      wn(r, n, _);
                    }
                  }
                  break;
                case 5:
                  $u(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    BT(h);
                    continue;
                  }
              }
              g !== null ? ((g.return = p), (Ke = g)) : BT(h);
            }
            d = d.sibling;
          }
        e: for (d = null, h = t; ; ) {
          if (h.tag === 5) {
            if (d === null) {
              d = h;
              try {
                (i = h.stateNode),
                  f
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = h.stateNode),
                      (l = h.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = AP("display", o)));
              } catch (_) {
                wn(t, t.return, _);
              }
            }
          } else if (h.tag === 6) {
            if (d === null)
              try {
                h.stateNode.nodeValue = f ? "" : h.memoizedProps;
              } catch (_) {
                wn(t, t.return, _);
              }
          } else if (
            ((h.tag !== 22 && h.tag !== 23) ||
              h.memoizedState === null ||
              h === t) &&
            h.child !== null
          ) {
            (h.child.return = h), (h = h.child);
            continue;
          }
          if (h === t) break e;
          for (; h.sibling === null; ) {
            if (h.return === null || h.return === t) break e;
            d === h && (d = null), (h = h.return);
          }
          d === h && (d = null), (h.sibling.return = h.return), (h = h.sibling);
        }
      }
      break;
    case 19:
      qi(e, t), Ms(t), r & 4 && FT(t);
      break;
    case 21:
      break;
    default:
      qi(e, t), Ms(t);
  }
}
function Ms(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (Q2(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(De(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (ld(i, ""), (r.flags &= -33));
          var s = UT(t);
          hS(t, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = UT(t);
          dS(t, a, o);
          break;
        default:
          throw Error(De(161));
      }
    } catch (l) {
      wn(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function xU(t, e, n) {
  (Ke = t), nL(t);
}
function nL(t, e, n) {
  for (var r = (t.mode & 1) !== 0; Ke !== null; ) {
    var i = Ke,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || Lp;
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || Tr;
        a = Lp;
        var f = Tr;
        if (((Lp = o), (Tr = l) && !f))
          for (Ke = i; Ke !== null; )
            (o = Ke),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? HT(i)
                : l !== null
                ? ((l.return = o), (Ke = l))
                : HT(i);
        for (; s !== null; ) (Ke = s), nL(s), (s = s.sibling);
        (Ke = i), (Lp = a), (Tr = f);
      }
      zT(t);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (Ke = s)) : zT(t);
  }
}
function zT(t) {
  for (; Ke !== null; ) {
    var e = Ke;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Tr || r0(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !Tr)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : Qi(e.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && MT(e, s, r);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                MT(e, o, n);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (n === null && e.flags & 4) {
                n = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var f = e.alternate;
                if (f !== null) {
                  var d = f.memoizedState;
                  if (d !== null) {
                    var h = d.dehydrated;
                    h !== null && dd(h);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(De(163));
          }
        Tr || (e.flags & 512 && fS(e));
      } catch (p) {
        wn(e, e.return, p);
      }
    }
    if (e === t) {
      Ke = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (Ke = n);
      break;
    }
    Ke = e.return;
  }
}
function BT(t) {
  for (; Ke !== null; ) {
    var e = Ke;
    if (e === t) {
      Ke = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (Ke = n);
      break;
    }
    Ke = e.return;
  }
}
function HT(t) {
  for (; Ke !== null; ) {
    var e = Ke;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            r0(4, e);
          } catch (l) {
            wn(e, n, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              wn(e, i, l);
            }
          }
          var s = e.return;
          try {
            fS(e);
          } catch (l) {
            wn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            fS(e);
          } catch (l) {
            wn(e, o, l);
          }
      }
    } catch (l) {
      wn(e, e.return, l);
    }
    if (e === t) {
      Ke = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (Ke = a);
      break;
    }
    Ke = e.return;
  }
}
var _U = Math.ceil,
  Eg = To.ReactCurrentDispatcher,
  vw = To.ReactCurrentOwner,
  Bi = To.ReactCurrentBatchConfig,
  Ot = 0,
  nr = null,
  Fn = null,
  dr = 0,
  di = 0,
  Xu = Ma(0),
  Gn = 0,
  Md = null,
  Tl = 0,
  i0 = 0,
  yw = 0,
  Kf = null,
  Kr = null,
  xw = 0,
  gc = 1 / 0,
  so = null,
  bg = !1,
  pS = null,
  ia = null,
  Ip = !1,
  Jo = null,
  Tg = 0,
  Zf = 0,
  mS = null,
  Gm = -1,
  jm = 0;
function Br() {
  return Ot & 6 ? Cn() : Gm !== -1 ? Gm : (Gm = Cn());
}
function sa(t) {
  return t.mode & 1
    ? Ot & 2 && dr !== 0
      ? dr & -dr
      : rU.transition !== null
      ? (jm === 0 && (jm = BP()), jm)
      : ((t = jt),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : XP(t.type))),
        t)
    : 1;
}
function ls(t, e, n, r) {
  if (50 < Zf) throw ((Zf = 0), (mS = null), Error(De(185)));
  Qd(t, n, r),
    (!(Ot & 2) || t !== nr) &&
      (t === nr && (!(Ot & 2) && (i0 |= n), Gn === 4 && Yo(t, dr)),
      ni(t, r),
      n === 1 && Ot === 0 && !(e.mode & 1) && ((gc = Cn() + 500), e0 && Ea()));
}
function ni(t, e) {
  var n = t.callbackNode;
  rk(t, e);
  var r = ug(t, t === nr ? dr : 0);
  if (r === 0)
    n !== null && Kb(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = r & -r), t.callbackPriority !== e)) {
    if ((n != null && Kb(n), e === 1))
      t.tag === 0 ? nU(VT.bind(null, t)) : d2(VT.bind(null, t)),
        Jk(function () {
          !(Ot & 6) && Ea();
        }),
        (n = null);
    else {
      switch (HP(r)) {
        case 1:
          n = j1;
          break;
        case 4:
          n = FP;
          break;
        case 16:
          n = lg;
          break;
        case 536870912:
          n = zP;
          break;
        default:
          n = lg;
      }
      n = cL(n, rL.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function rL(t, e) {
  if (((Gm = -1), (jm = 0), Ot & 6)) throw Error(De(327));
  var n = t.callbackNode;
  if (ic() && t.callbackNode !== n) return null;
  var r = ug(t, t === nr ? dr : 0);
  if (r === 0) return null;
  if (r & 30 || r & t.expiredLanes || e) e = Ag(t, r);
  else {
    e = r;
    var i = Ot;
    Ot |= 2;
    var s = sL();
    (nr !== t || dr !== e) && ((so = null), (gc = Cn() + 500), gl(t, e));
    do
      try {
        MU();
        break;
      } catch (a) {
        iL(t, a);
      }
    while (!0);
    iw(),
      (Eg.current = s),
      (Ot = i),
      Fn !== null ? (e = 0) : ((nr = null), (dr = 0), (e = Gn));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = V_(t)), i !== 0 && ((r = i), (e = gS(t, i)))), e === 1)
    )
      throw ((n = Md), gl(t, 0), Yo(t, r), ni(t, Cn()), n);
    if (e === 6) Yo(t, r);
    else {
      if (
        ((i = t.current.alternate),
        !(r & 30) &&
          !SU(i) &&
          ((e = Ag(t, r)),
          e === 2 && ((s = V_(t)), s !== 0 && ((r = s), (e = gS(t, s)))),
          e === 1))
      )
        throw ((n = Md), gl(t, 0), Yo(t, r), ni(t, Cn()), n);
      switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(De(345));
        case 2:
          Za(t, Kr, so);
          break;
        case 3:
          if (
            (Yo(t, r), (r & 130023424) === r && ((e = xw + 500 - Cn()), 10 < e))
          ) {
            if (ug(t, 0) !== 0) break;
            if (((i = t.suspendedLanes), (i & r) !== r)) {
              Br(), (t.pingedLanes |= t.suspendedLanes & i);
              break;
            }
            t.timeoutHandle = K_(Za.bind(null, t, Kr, so), e);
            break;
          }
          Za(t, Kr, so);
          break;
        case 4:
          if ((Yo(t, r), (r & 4194240) === r)) break;
          for (e = t.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - as(r);
            (s = 1 << o), (o = e[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = Cn() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * _U(r / 1960)) - r),
            10 < r)
          ) {
            t.timeoutHandle = K_(Za.bind(null, t, Kr, so), r);
            break;
          }
          Za(t, Kr, so);
          break;
        case 5:
          Za(t, Kr, so);
          break;
        default:
          throw Error(De(329));
      }
    }
  }
  return ni(t, Cn()), t.callbackNode === n ? rL.bind(null, t) : null;
}
function gS(t, e) {
  var n = Kf;
  return (
    t.current.memoizedState.isDehydrated && (gl(t, e).flags |= 256),
    (t = Ag(t, e)),
    t !== 2 && ((e = Kr), (Kr = n), e !== null && vS(e)),
    t
  );
}
function vS(t) {
  Kr === null ? (Kr = t) : Kr.push.apply(Kr, t);
}
function SU(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!us(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Yo(t, e) {
  for (
    e &= ~yw,
      e &= ~i0,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - as(e),
      r = 1 << n;
    (t[n] = -1), (e &= ~r);
  }
}
function VT(t) {
  if (Ot & 6) throw Error(De(327));
  ic();
  var e = ug(t, 0);
  if (!(e & 1)) return ni(t, Cn()), null;
  var n = Ag(t, e);
  if (t.tag !== 0 && n === 2) {
    var r = V_(t);
    r !== 0 && ((e = r), (n = gS(t, r)));
  }
  if (n === 1) throw ((n = Md), gl(t, 0), Yo(t, e), ni(t, Cn()), n);
  if (n === 6) throw Error(De(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    Za(t, Kr, so),
    ni(t, Cn()),
    null
  );
}
function _w(t, e) {
  var n = Ot;
  Ot |= 1;
  try {
    return t(e);
  } finally {
    (Ot = n), Ot === 0 && ((gc = Cn() + 500), e0 && Ea());
  }
}
function Al(t) {
  Jo !== null && Jo.tag === 0 && !(Ot & 6) && ic();
  var e = Ot;
  Ot |= 1;
  var n = Bi.transition,
    r = jt;
  try {
    if (((Bi.transition = null), (jt = 1), t)) return t();
  } finally {
    (jt = r), (Bi.transition = n), (Ot = e), !(Ot & 6) && Ea();
  }
}
function Sw() {
  (di = Xu.current), rn(Xu);
}
function gl(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), Zk(n)), Fn !== null))
    for (n = Fn.return; n !== null; ) {
      var r = n;
      switch ((tw(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && pg();
          break;
        case 3:
          pc(), rn(ei), rn(Ir), cw();
          break;
        case 5:
          uw(r);
          break;
        case 4:
          pc();
          break;
        case 13:
          rn(dn);
          break;
        case 19:
          rn(dn);
          break;
        case 10:
          sw(r.type._context);
          break;
        case 22:
        case 23:
          Sw();
      }
      n = n.return;
    }
  if (
    ((nr = t),
    (Fn = t = oa(t.current, null)),
    (dr = di = e),
    (Gn = 0),
    (Md = null),
    (yw = i0 = Tl = 0),
    (Kr = Kf = null),
    ll !== null)
  ) {
    for (e = 0; e < ll.length; e++)
      if (((n = ll[e]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          s = n.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        n.pending = r;
      }
    ll = null;
  }
  return t;
}
function iL(t, e) {
  do {
    var n = Fn;
    try {
      if ((iw(), (Hm.current = Mg), wg)) {
        for (var r = pn.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        wg = !1;
      }
      if (
        ((bl = 0),
        (tr = Vn = pn = null),
        (Yf = !1),
        (_d = 0),
        (vw.current = null),
        n === null || n.return === null)
      ) {
        (Gn = 1), (Md = e), (Fn = null);
        break;
      }
      e: {
        var s = t,
          o = n.return,
          a = n,
          l = e;
        if (
          ((e = dr),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var f = l,
            d = a,
            h = d.tag;
          if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
            var p = d.alternate;
            p
              ? ((d.updateQueue = p.updateQueue),
                (d.memoizedState = p.memoizedState),
                (d.lanes = p.lanes))
              : ((d.updateQueue = null), (d.memoizedState = null));
          }
          var g = RT(o);
          if (g !== null) {
            (g.flags &= -257),
              PT(g, o, a, s, e),
              g.mode & 1 && CT(s, f, e),
              (e = g),
              (l = f);
            var v = e.updateQueue;
            if (v === null) {
              var _ = new Set();
              _.add(l), (e.updateQueue = _);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              CT(s, f, e), ww();
              break e;
            }
            l = Error(De(426));
          }
        } else if (un && a.mode & 1) {
          var x = RT(o);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              PT(x, o, a, s, e),
              nw(mc(l, a));
            break e;
          }
        }
        (s = l = mc(l, a)),
          Gn !== 4 && (Gn = 2),
          Kf === null ? (Kf = [s]) : Kf.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var m = H2(s, l, e);
              wT(s, m);
              break e;
            case 1:
              a = l;
              var w = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof w.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (ia === null || !ia.has(S))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var E = V2(s, a, e);
                wT(s, E);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      aL(n);
    } catch (T) {
      (e = T), Fn === n && n !== null && (Fn = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function sL() {
  var t = Eg.current;
  return (Eg.current = Mg), t === null ? Mg : t;
}
function ww() {
  (Gn === 0 || Gn === 3 || Gn === 2) && (Gn = 4),
    nr === null || (!(Tl & 268435455) && !(i0 & 268435455)) || Yo(nr, dr);
}
function Ag(t, e) {
  var n = Ot;
  Ot |= 2;
  var r = sL();
  (nr !== t || dr !== e) && ((so = null), gl(t, e));
  do
    try {
      wU();
      break;
    } catch (i) {
      iL(t, i);
    }
  while (!0);
  if ((iw(), (Ot = n), (Eg.current = r), Fn !== null)) throw Error(De(261));
  return (nr = null), (dr = 0), Gn;
}
function wU() {
  for (; Fn !== null; ) oL(Fn);
}
function MU() {
  for (; Fn !== null && !YD(); ) oL(Fn);
}
function oL(t) {
  var e = uL(t.alternate, t, di);
  (t.memoizedProps = t.pendingProps),
    e === null ? aL(t) : (Fn = e),
    (vw.current = null);
}
function aL(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = gU(n, e)), n !== null)) {
        (n.flags &= 32767), (Fn = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (Gn = 6), (Fn = null);
        return;
      }
    } else if (((n = mU(n, e, di)), n !== null)) {
      Fn = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Fn = e;
      return;
    }
    Fn = e = t;
  } while (e !== null);
  Gn === 0 && (Gn = 5);
}
function Za(t, e, n) {
  var r = jt,
    i = Bi.transition;
  try {
    (Bi.transition = null), (jt = 1), EU(t, e, n, r);
  } finally {
    (Bi.transition = i), (jt = r);
  }
  return null;
}
function EU(t, e, n, r) {
  do ic();
  while (Jo !== null);
  if (Ot & 6) throw Error(De(327));
  n = t.finishedWork;
  var i = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(De(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (ik(t, s),
    t === nr && ((Fn = nr = null), (dr = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Ip ||
      ((Ip = !0),
      cL(lg, function () {
        return ic(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = Bi.transition), (Bi.transition = null);
    var o = jt;
    jt = 1;
    var a = Ot;
    (Ot |= 4),
      (vw.current = null),
      yU(t, n),
      tL(n, t),
      Gk(Y_),
      (cg = !!X_),
      (Y_ = X_ = null),
      (t.current = n),
      xU(n),
      qD(),
      (Ot = a),
      (jt = o),
      (Bi.transition = s);
  } else t.current = n;
  if (
    (Ip && ((Ip = !1), (Jo = t), (Tg = i)),
    (s = t.pendingLanes),
    s === 0 && (ia = null),
    JD(n.stateNode),
    ni(t, Cn()),
    e !== null)
  )
    for (r = t.onRecoverableError, n = 0; n < e.length; n++)
      (i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (bg) throw ((bg = !1), (t = pS), (pS = null), t);
  return (
    Tg & 1 && t.tag !== 0 && ic(),
    (s = t.pendingLanes),
    s & 1 ? (t === mS ? Zf++ : ((Zf = 0), (mS = t))) : (Zf = 0),
    Ea(),
    null
  );
}
function ic() {
  if (Jo !== null) {
    var t = HP(Tg),
      e = Bi.transition,
      n = jt;
    try {
      if (((Bi.transition = null), (jt = 16 > t ? 16 : t), Jo === null))
        var r = !1;
      else {
        if (((t = Jo), (Jo = null), (Tg = 0), Ot & 6)) throw Error(De(331));
        var i = Ot;
        for (Ot |= 4, Ke = t.current; Ke !== null; ) {
          var s = Ke,
            o = s.child;
          if (Ke.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var f = a[l];
                for (Ke = f; Ke !== null; ) {
                  var d = Ke;
                  switch (d.tag) {
                    case 0:
                    case 11:
                    case 15:
                      qf(8, d, s);
                  }
                  var h = d.child;
                  if (h !== null) (h.return = d), (Ke = h);
                  else
                    for (; Ke !== null; ) {
                      d = Ke;
                      var p = d.sibling,
                        g = d.return;
                      if ((J2(d), d === f)) {
                        Ke = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = g), (Ke = p);
                        break;
                      }
                      Ke = g;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var _ = v.child;
                if (_ !== null) {
                  v.child = null;
                  do {
                    var x = _.sibling;
                    (_.sibling = null), (_ = x);
                  } while (_ !== null);
                }
              }
              Ke = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (Ke = o);
          else
            e: for (; Ke !== null; ) {
              if (((s = Ke), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    qf(9, s, s.return);
                }
              var m = s.sibling;
              if (m !== null) {
                (m.return = s.return), (Ke = m);
                break e;
              }
              Ke = s.return;
            }
        }
        var w = t.current;
        for (Ke = w; Ke !== null; ) {
          o = Ke;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (Ke = S);
          else
            e: for (o = w; Ke !== null; ) {
              if (((a = Ke), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      r0(9, a);
                  }
                } catch (T) {
                  wn(a, a.return, T);
                }
              if (a === o) {
                Ke = null;
                break e;
              }
              var E = a.sibling;
              if (E !== null) {
                (E.return = a.return), (Ke = E);
                break e;
              }
              Ke = a.return;
            }
        }
        if (
          ((Ot = i), Ea(), Is && typeof Is.onPostCommitFiberRoot == "function")
        )
          try {
            Is.onPostCommitFiberRoot(qg, t);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (jt = n), (Bi.transition = e);
    }
  }
  return !1;
}
function WT(t, e, n) {
  (e = mc(n, e)),
    (e = H2(t, e, 1)),
    (t = ra(t, e, 1)),
    (e = Br()),
    t !== null && (Qd(t, 1, e), ni(t, e));
}
function wn(t, e, n) {
  if (t.tag === 3) WT(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        WT(e, t, n);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (ia === null || !ia.has(r)))
        ) {
          (t = mc(n, t)),
            (t = V2(e, t, 1)),
            (e = ra(e, t, 1)),
            (t = Br()),
            e !== null && (Qd(e, 1, t), ni(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function bU(t, e, n) {
  var r = t.pingCache;
  r !== null && r.delete(e),
    (e = Br()),
    (t.pingedLanes |= t.suspendedLanes & n),
    nr === t &&
      (dr & n) === n &&
      (Gn === 4 || (Gn === 3 && (dr & 130023424) === dr && 500 > Cn() - xw)
        ? gl(t, 0)
        : (yw |= n)),
    ni(t, e);
}
function lL(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = wp), (wp <<= 1), !(wp & 130023424) && (wp = 4194304))
      : (e = 1));
  var n = Br();
  (t = vo(t, e)), t !== null && (Qd(t, e, n), ni(t, n));
}
function TU(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), lL(t, n);
}
function AU(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        i = t.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = t.stateNode;
      break;
    default:
      throw Error(De(314));
  }
  r !== null && r.delete(e), lL(t, n);
}
var uL;
uL = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || ei.current) Qr = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (Qr = !1), pU(t, e, n);
      Qr = !!(t.flags & 131072);
    }
  else (Qr = !1), un && e.flags & 1048576 && h2(e, vg, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      Wm(t, e), (t = e.pendingProps);
      var i = fc(e, Ir.current);
      rc(e, n), (i = dw(null, e, r, t, i, n));
      var s = hw();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            ti(r) ? ((s = !0), mg(e)) : (s = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            aw(e),
            (i.updater = n0),
            (e.stateNode = i),
            (i._reactInternals = e),
            rS(e, r, t, n),
            (e = oS(null, e, r, !0, s, n)))
          : ((e.tag = 0), un && s && ew(e), Fr(null, e, i, n), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (Wm(t, e),
          (t = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = RU(r)),
          (t = Qi(r, t)),
          i)
        ) {
          case 0:
            e = sS(null, e, r, t, n);
            break e;
          case 1:
            e = NT(null, e, r, t, n);
            break e;
          case 11:
            e = LT(null, e, r, t, n);
            break e;
          case 14:
            e = IT(null, e, r, Qi(r.type, t), n);
            break e;
        }
        throw Error(De(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Qi(r, i)),
        sS(t, e, r, i, n)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Qi(r, i)),
        NT(t, e, r, i, n)
      );
    case 3:
      e: {
        if (($2(e), t === null)) throw Error(De(387));
        (r = e.pendingProps),
          (s = e.memoizedState),
          (i = s.element),
          x2(t, e),
          _g(e, r, null, n);
        var o = e.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (i = mc(Error(De(423)), e)), (e = OT(t, e, r, n, i));
            break e;
          } else if (r !== i) {
            (i = mc(Error(De(424)), e)), (e = OT(t, e, r, n, i));
            break e;
          } else
            for (
              mi = na(e.stateNode.containerInfo.firstChild),
                gi = e,
                un = !0,
                ns = null,
                n = v2(e, null, r, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((dc(), r === i)) {
            e = yo(t, e, n);
            break e;
          }
          Fr(t, e, r, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        _2(e),
        t === null && eS(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = t !== null ? t.memoizedProps : null),
        (o = i.children),
        q_(r, i) ? (o = null) : s !== null && q_(r, s) && (e.flags |= 32),
        j2(t, e),
        Fr(t, e, o, n),
        e.child
      );
    case 6:
      return t === null && eS(e), null;
    case 13:
      return X2(t, e, n);
    case 4:
      return (
        lw(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        t === null ? (e.child = hc(e, null, r, n)) : Fr(t, e, r, n),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Qi(r, i)),
        LT(t, e, r, i, n)
      );
    case 7:
      return Fr(t, e, e.pendingProps, n), e.child;
    case 8:
      return Fr(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return Fr(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (o = i.value),
          en(yg, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (us(s.value, o)) {
            if (s.children === i.children && !ei.current) {
              e = yo(t, e, n);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = ho(-1, n & -n)), (l.tag = 2);
                      var f = s.updateQueue;
                      if (f !== null) {
                        f = f.shared;
                        var d = f.pending;
                        d === null
                          ? (l.next = l)
                          : ((l.next = d.next), (d.next = l)),
                          (f.pending = l);
                      }
                    }
                    (s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      tS(s.return, n, e),
                      (a.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(De(341));
                (o.lanes |= n),
                  (a = o.alternate),
                  a !== null && (a.lanes |= n),
                  tS(o, n, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        Fr(t, e, i.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        rc(e, n),
        (i = Hi(i)),
        (r = r(i)),
        (e.flags |= 1),
        Fr(t, e, r, n),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = Qi(r, e.pendingProps)),
        (i = Qi(r.type, i)),
        IT(t, e, r, i, n)
      );
    case 15:
      return W2(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Qi(r, i)),
        Wm(t, e),
        (e.tag = 1),
        ti(r) ? ((t = !0), mg(e)) : (t = !1),
        rc(e, n),
        B2(e, r, i),
        rS(e, r, i, n),
        oS(null, e, r, !0, t, n)
      );
    case 19:
      return Y2(t, e, n);
    case 22:
      return G2(t, e, n);
  }
  throw Error(De(156, e.tag));
};
function cL(t, e) {
  return UP(t, e);
}
function CU(t, e, n, r) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function zi(t, e, n, r) {
  return new CU(t, e, n, r);
}
function Mw(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function RU(t) {
  if (typeof t == "function") return Mw(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === V1)) return 11;
    if (t === W1) return 14;
  }
  return 2;
}
function oa(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = zi(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function $m(t, e, n, r, i, s) {
  var o = 2;
  if (((r = t), typeof t == "function")) Mw(t) && (o = 1);
  else if (typeof t == "string") o = 5;
  else
    e: switch (t) {
      case Uu:
        return vl(n.children, i, s, e);
      case H1:
        (o = 8), (i |= 8);
        break;
      case A_:
        return (
          (t = zi(12, n, e, i | 2)), (t.elementType = A_), (t.lanes = s), t
        );
      case C_:
        return (t = zi(13, n, e, i)), (t.elementType = C_), (t.lanes = s), t;
      case R_:
        return (t = zi(19, n, e, i)), (t.elementType = R_), (t.lanes = s), t;
      case _P:
        return s0(n, i, s, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case yP:
              o = 10;
              break e;
            case xP:
              o = 9;
              break e;
            case V1:
              o = 11;
              break e;
            case W1:
              o = 14;
              break e;
            case jo:
              (o = 16), (r = null);
              break e;
          }
        throw Error(De(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = zi(o, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = s), e
  );
}
function vl(t, e, n, r) {
  return (t = zi(7, t, r, e)), (t.lanes = n), t;
}
function s0(t, e, n, r) {
  return (
    (t = zi(22, t, r, e)),
    (t.elementType = _P),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function hx(t, e, n) {
  return (t = zi(6, t, null, e)), (t.lanes = n), t;
}
function px(t, e, n) {
  return (
    (e = zi(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function PU(t, e, n, r, i) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Yy(0)),
    (this.expirationTimes = Yy(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Yy(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function Ew(t, e, n, r, i, s, o, a, l) {
  return (
    (t = new PU(t, e, n, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = zi(3, null, null, e)),
    (t.current = s),
    (s.stateNode = t),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    aw(s),
    t
  );
}
function LU(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: ku,
    key: r == null ? null : "" + r,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function fL(t) {
  if (!t) return ma;
  t = t._reactInternals;
  e: {
    if (Dl(t) !== t || t.tag !== 1) throw Error(De(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (ti(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(De(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (ti(n)) return f2(t, n, e);
  }
  return e;
}
function dL(t, e, n, r, i, s, o, a, l) {
  return (
    (t = Ew(n, r, !0, t, i, s, o, a, l)),
    (t.context = fL(null)),
    (n = t.current),
    (r = Br()),
    (i = sa(n)),
    (s = ho(r, i)),
    (s.callback = e ?? null),
    ra(n, s, i),
    (t.current.lanes = i),
    Qd(t, i, r),
    ni(t, r),
    t
  );
}
function o0(t, e, n, r) {
  var i = e.current,
    s = Br(),
    o = sa(i);
  return (
    (n = fL(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = ho(s, o)),
    (e.payload = { element: t }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (t = ra(i, e, o)),
    t !== null && (ls(t, i, o, s), Bm(t, i, o)),
    o
  );
}
function Cg(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function GT(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function bw(t, e) {
  GT(t, e), (t = t.alternate) && GT(t, e);
}
function IU() {
  return null;
}
var hL =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function Tw(t) {
  this._internalRoot = t;
}
a0.prototype.render = Tw.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(De(409));
  o0(t, e, null, null);
};
a0.prototype.unmount = Tw.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    Al(function () {
      o0(null, t, null, null);
    }),
      (e[go] = null);
  }
};
function a0(t) {
  this._internalRoot = t;
}
a0.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = GP();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < Xo.length && e !== 0 && e < Xo[n].priority; n++);
    Xo.splice(n, 0, t), n === 0 && $P(t);
  }
};
function Aw(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function l0(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function jT() {}
function NU(t, e, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var f = Cg(o);
        s.call(f);
      };
    }
    var o = dL(e, r, t, 0, null, !1, !1, "", jT);
    return (
      (t._reactRootContainer = o),
      (t[go] = o.current),
      md(t.nodeType === 8 ? t.parentNode : t),
      Al(),
      o
    );
  }
  for (; (i = t.lastChild); ) t.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var f = Cg(l);
      a.call(f);
    };
  }
  var l = Ew(t, 0, !1, null, null, !1, !1, "", jT);
  return (
    (t._reactRootContainer = l),
    (t[go] = l.current),
    md(t.nodeType === 8 ? t.parentNode : t),
    Al(function () {
      o0(e, l, n, r);
    }),
    l
  );
}
function u0(t, e, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = Cg(o);
        a.call(l);
      };
    }
    o0(e, o, t, i);
  } else o = NU(n, e, t, i, r);
  return Cg(o);
}
VP = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = Df(e.pendingLanes);
        n !== 0 &&
          ($1(e, n | 1), ni(e, Cn()), !(Ot & 6) && ((gc = Cn() + 500), Ea()));
      }
      break;
    case 13:
      Al(function () {
        var r = vo(t, 1);
        if (r !== null) {
          var i = Br();
          ls(r, t, 1, i);
        }
      }),
        bw(t, 1);
  }
};
X1 = function (t) {
  if (t.tag === 13) {
    var e = vo(t, 134217728);
    if (e !== null) {
      var n = Br();
      ls(e, t, 134217728, n);
    }
    bw(t, 134217728);
  }
};
WP = function (t) {
  if (t.tag === 13) {
    var e = sa(t),
      n = vo(t, e);
    if (n !== null) {
      var r = Br();
      ls(n, t, e, r);
    }
    bw(t, e);
  }
};
GP = function () {
  return jt;
};
jP = function (t, e) {
  var n = jt;
  try {
    return (jt = t), e();
  } finally {
    jt = n;
  }
};
z_ = function (t, e, n) {
  switch (e) {
    case "input":
      if ((I_(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var r = n[e];
          if (r !== t && r.form === t.form) {
            var i = Qg(r);
            if (!i) throw Error(De(90));
            wP(r), I_(r, i);
          }
        }
      }
      break;
    case "textarea":
      EP(t, n);
      break;
    case "select":
      (e = n.value), e != null && Qu(t, !!n.multiple, e, !1);
  }
};
LP = _w;
IP = Al;
var OU = { usingClientEntryPoint: !1, Events: [th, Hu, Qg, RP, PP, _w] },
  pf = {
    findFiberByHostInstance: al,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  DU = {
    bundleType: pf.bundleType,
    version: pf.version,
    rendererPackageName: pf.rendererPackageName,
    rendererConfig: pf.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: To.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = DP(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: pf.findFiberByHostInstance || IU,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Np = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Np.isDisabled && Np.supportsFiber)
    try {
      (qg = Np.inject(DU)), (Is = Np);
    } catch {}
}
Si.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = OU;
Si.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Aw(e)) throw Error(De(200));
  return LU(t, e, null, n);
};
Si.createRoot = function (t, e) {
  if (!Aw(t)) throw Error(De(299));
  var n = !1,
    r = "",
    i = hL;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = Ew(t, 1, !1, null, null, n, !1, r, i)),
    (t[go] = e.current),
    md(t.nodeType === 8 ? t.parentNode : t),
    new Tw(e)
  );
};
Si.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(De(188))
      : ((t = Object.keys(t).join(",")), Error(De(268, t)));
  return (t = DP(e)), (t = t === null ? null : t.stateNode), t;
};
Si.flushSync = function (t) {
  return Al(t);
};
Si.hydrate = function (t, e, n) {
  if (!l0(e)) throw Error(De(200));
  return u0(null, t, e, !0, n);
};
Si.hydrateRoot = function (t, e, n) {
  if (!Aw(t)) throw Error(De(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = "",
    o = hL;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    (e = dL(e, null, t, 1, n ?? null, i, !1, s, o)),
    (t[go] = e.current),
    md(t),
    r)
  )
    for (t = 0; t < r.length; t++)
      (n = r[t]),
        (i = n._getVersion),
        (i = i(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, i])
          : e.mutableSourceEagerHydrationData.push(n, i);
  return new a0(e);
};
Si.render = function (t, e, n) {
  if (!l0(e)) throw Error(De(200));
  return u0(null, t, e, !1, n);
};
Si.unmountComponentAtNode = function (t) {
  if (!l0(t)) throw Error(De(40));
  return t._reactRootContainer
    ? (Al(function () {
        u0(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[go] = null);
        });
      }),
      !0)
    : !1;
};
Si.unstable_batchedUpdates = _w;
Si.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
  if (!l0(n)) throw Error(De(200));
  if (t == null || t._reactInternals === void 0) throw Error(De(38));
  return u0(t, e, n, !1, r);
};
Si.version = "18.3.1-next-f1338f8080-20240426";
function pL() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(pL);
    } catch (t) {
      console.error(t);
    }
}
pL(), (pP.exports = Si);
var c0 = pP.exports;
const Op = N1(c0);
var mL,
  $T = c0;
(mL = $T.createRoot), $T.hydrateRoot;
var gL = { exports: {} },
  vL = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var vc = U;
function kU(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var UU = typeof Object.is == "function" ? Object.is : kU,
  FU = vc.useState,
  zU = vc.useEffect,
  BU = vc.useLayoutEffect,
  HU = vc.useDebugValue;
function VU(t, e) {
  var n = e(),
    r = FU({ inst: { value: n, getSnapshot: e } }),
    i = r[0].inst,
    s = r[1];
  return (
    BU(
      function () {
        (i.value = n), (i.getSnapshot = e), mx(i) && s({ inst: i });
      },
      [t, n, e]
    ),
    zU(
      function () {
        return (
          mx(i) && s({ inst: i }),
          t(function () {
            mx(i) && s({ inst: i });
          })
        );
      },
      [t]
    ),
    HU(n),
    n
  );
}
function mx(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !UU(t, n);
  } catch {
    return !0;
  }
}
function WU(t, e) {
  return e();
}
var GU =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? WU
    : VU;
vL.useSyncExternalStore =
  vc.useSyncExternalStore !== void 0 ? vc.useSyncExternalStore : GU;
gL.exports = vL;
var jU = gL.exports,
  yL = { exports: {} },
  xL = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f0 = U,
  $U = jU;
function XU(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var YU = typeof Object.is == "function" ? Object.is : XU,
  qU = $U.useSyncExternalStore,
  KU = f0.useRef,
  ZU = f0.useEffect,
  JU = f0.useMemo,
  QU = f0.useDebugValue;
xL.useSyncExternalStoreWithSelector = function (t, e, n, r, i) {
  var s = KU(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = JU(
    function () {
      function l(g) {
        if (!f) {
          if (((f = !0), (d = g), (g = r(g)), i !== void 0 && o.hasValue)) {
            var v = o.value;
            if (i(v, g)) return (h = v);
          }
          return (h = g);
        }
        if (((v = h), YU(d, g))) return v;
        var _ = r(g);
        return i !== void 0 && i(v, _) ? ((d = g), v) : ((d = g), (h = _));
      }
      var f = !1,
        d,
        h,
        p = n === void 0 ? null : n;
      return [
        function () {
          return l(e());
        },
        p === null
          ? void 0
          : function () {
              return l(p());
            },
      ];
    },
    [e, n, r, i]
  );
  var a = qU(t, s[0], s[1]);
  return (
    ZU(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a]
    ),
    QU(a),
    a
  );
};
yL.exports = xL;
var eF = yL.exports;
function tF(t) {
  t();
}
let _L = tF;
const nF = (t) => (_L = t),
  rF = () => _L,
  XT = Symbol.for("react-redux-context"),
  YT = typeof globalThis < "u" ? globalThis : {};
function iF() {
  var t;
  if (!U.createContext) return {};
  const e = (t = YT[XT]) != null ? t : (YT[XT] = new Map());
  let n = e.get(U.createContext);
  return n || ((n = U.createContext(null)), e.set(U.createContext, n)), n;
}
const ga = iF();
function Cw(t = ga) {
  return function () {
    return U.useContext(t);
  };
}
const SL = Cw(),
  sF = () => {
    throw new Error("uSES not initialized!");
  };
let wL = sF;
const oF = (t) => {
    wL = t;
  },
  aF = (t, e) => t === e;
function lF(t = ga) {
  const e = t === ga ? SL : Cw(t);
  return function (r, i = {}) {
    const {
        equalityFn: s = aF,
        stabilityCheck: o = void 0,
        noopCheck: a = void 0,
      } = typeof i == "function" ? { equalityFn: i } : i,
      {
        store: l,
        subscription: f,
        getServerState: d,
        stabilityCheck: h,
        noopCheck: p,
      } = e();
    U.useRef(!0);
    const g = U.useCallback(
        {
          [r.name](_) {
            return r(_);
          },
        }[r.name],
        [r, h, o]
      ),
      v = wL(f.addNestedSub, l.getState, d || l.getState, g, s);
    return U.useDebugValue(v), v;
  };
}
const fr = lF();
function Rg() {
  return (
    (Rg = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Rg.apply(null, arguments)
  );
}
function uF(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) !== -1) continue;
      n[r] = t[r];
    }
  return n;
}
var ML = { exports: {} },
  Xt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var rr = typeof Symbol == "function" && Symbol.for,
  Rw = rr ? Symbol.for("react.element") : 60103,
  Pw = rr ? Symbol.for("react.portal") : 60106,
  d0 = rr ? Symbol.for("react.fragment") : 60107,
  h0 = rr ? Symbol.for("react.strict_mode") : 60108,
  p0 = rr ? Symbol.for("react.profiler") : 60114,
  m0 = rr ? Symbol.for("react.provider") : 60109,
  g0 = rr ? Symbol.for("react.context") : 60110,
  Lw = rr ? Symbol.for("react.async_mode") : 60111,
  v0 = rr ? Symbol.for("react.concurrent_mode") : 60111,
  y0 = rr ? Symbol.for("react.forward_ref") : 60112,
  x0 = rr ? Symbol.for("react.suspense") : 60113,
  cF = rr ? Symbol.for("react.suspense_list") : 60120,
  _0 = rr ? Symbol.for("react.memo") : 60115,
  S0 = rr ? Symbol.for("react.lazy") : 60116,
  fF = rr ? Symbol.for("react.block") : 60121,
  dF = rr ? Symbol.for("react.fundamental") : 60117,
  hF = rr ? Symbol.for("react.responder") : 60118,
  pF = rr ? Symbol.for("react.scope") : 60119;
function Mi(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case Rw:
        switch (((t = t.type), t)) {
          case Lw:
          case v0:
          case d0:
          case p0:
          case h0:
          case x0:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case g0:
              case y0:
              case S0:
              case _0:
              case m0:
                return t;
              default:
                return e;
            }
        }
      case Pw:
        return e;
    }
  }
}
function EL(t) {
  return Mi(t) === v0;
}
Xt.AsyncMode = Lw;
Xt.ConcurrentMode = v0;
Xt.ContextConsumer = g0;
Xt.ContextProvider = m0;
Xt.Element = Rw;
Xt.ForwardRef = y0;
Xt.Fragment = d0;
Xt.Lazy = S0;
Xt.Memo = _0;
Xt.Portal = Pw;
Xt.Profiler = p0;
Xt.StrictMode = h0;
Xt.Suspense = x0;
Xt.isAsyncMode = function (t) {
  return EL(t) || Mi(t) === Lw;
};
Xt.isConcurrentMode = EL;
Xt.isContextConsumer = function (t) {
  return Mi(t) === g0;
};
Xt.isContextProvider = function (t) {
  return Mi(t) === m0;
};
Xt.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === Rw;
};
Xt.isForwardRef = function (t) {
  return Mi(t) === y0;
};
Xt.isFragment = function (t) {
  return Mi(t) === d0;
};
Xt.isLazy = function (t) {
  return Mi(t) === S0;
};
Xt.isMemo = function (t) {
  return Mi(t) === _0;
};
Xt.isPortal = function (t) {
  return Mi(t) === Pw;
};
Xt.isProfiler = function (t) {
  return Mi(t) === p0;
};
Xt.isStrictMode = function (t) {
  return Mi(t) === h0;
};
Xt.isSuspense = function (t) {
  return Mi(t) === x0;
};
Xt.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === d0 ||
    t === v0 ||
    t === p0 ||
    t === h0 ||
    t === x0 ||
    t === cF ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === S0 ||
        t.$$typeof === _0 ||
        t.$$typeof === m0 ||
        t.$$typeof === g0 ||
        t.$$typeof === y0 ||
        t.$$typeof === dF ||
        t.$$typeof === hF ||
        t.$$typeof === pF ||
        t.$$typeof === fF))
  );
};
Xt.typeOf = Mi;
ML.exports = Xt;
var mF = ML.exports,
  bL = mF,
  gF = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  vF = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  TL = {};
TL[bL.ForwardRef] = gF;
TL[bL.Memo] = vF;
var Yt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Iw = Symbol.for("react.element"),
  Nw = Symbol.for("react.portal"),
  w0 = Symbol.for("react.fragment"),
  M0 = Symbol.for("react.strict_mode"),
  E0 = Symbol.for("react.profiler"),
  b0 = Symbol.for("react.provider"),
  T0 = Symbol.for("react.context"),
  yF = Symbol.for("react.server_context"),
  A0 = Symbol.for("react.forward_ref"),
  C0 = Symbol.for("react.suspense"),
  R0 = Symbol.for("react.suspense_list"),
  P0 = Symbol.for("react.memo"),
  L0 = Symbol.for("react.lazy"),
  xF = Symbol.for("react.offscreen"),
  AL;
AL = Symbol.for("react.module.reference");
function Wi(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case Iw:
        switch (((t = t.type), t)) {
          case w0:
          case E0:
          case M0:
          case C0:
          case R0:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case yF:
              case T0:
              case A0:
              case L0:
              case P0:
              case b0:
                return t;
              default:
                return e;
            }
        }
      case Nw:
        return e;
    }
  }
}
Yt.ContextConsumer = T0;
Yt.ContextProvider = b0;
Yt.Element = Iw;
Yt.ForwardRef = A0;
Yt.Fragment = w0;
Yt.Lazy = L0;
Yt.Memo = P0;
Yt.Portal = Nw;
Yt.Profiler = E0;
Yt.StrictMode = M0;
Yt.Suspense = C0;
Yt.SuspenseList = R0;
Yt.isAsyncMode = function () {
  return !1;
};
Yt.isConcurrentMode = function () {
  return !1;
};
Yt.isContextConsumer = function (t) {
  return Wi(t) === T0;
};
Yt.isContextProvider = function (t) {
  return Wi(t) === b0;
};
Yt.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === Iw;
};
Yt.isForwardRef = function (t) {
  return Wi(t) === A0;
};
Yt.isFragment = function (t) {
  return Wi(t) === w0;
};
Yt.isLazy = function (t) {
  return Wi(t) === L0;
};
Yt.isMemo = function (t) {
  return Wi(t) === P0;
};
Yt.isPortal = function (t) {
  return Wi(t) === Nw;
};
Yt.isProfiler = function (t) {
  return Wi(t) === E0;
};
Yt.isStrictMode = function (t) {
  return Wi(t) === M0;
};
Yt.isSuspense = function (t) {
  return Wi(t) === C0;
};
Yt.isSuspenseList = function (t) {
  return Wi(t) === R0;
};
Yt.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === w0 ||
    t === E0 ||
    t === M0 ||
    t === C0 ||
    t === R0 ||
    t === xF ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === L0 ||
        t.$$typeof === P0 ||
        t.$$typeof === b0 ||
        t.$$typeof === T0 ||
        t.$$typeof === A0 ||
        t.$$typeof === AL ||
        t.getModuleId !== void 0))
  );
};
Yt.typeOf = Wi;
function _F() {
  const t = rF();
  let e = null,
    n = null;
  return {
    clear() {
      (e = null), (n = null);
    },
    notify() {
      t(() => {
        let r = e;
        for (; r; ) r.callback(), (r = r.next);
      });
    },
    get() {
      let r = [],
        i = e;
      for (; i; ) r.push(i), (i = i.next);
      return r;
    },
    subscribe(r) {
      let i = !0,
        s = (n = { callback: r, next: null, prev: n });
      return (
        s.prev ? (s.prev.next = s) : (e = s),
        function () {
          !i ||
            e === null ||
            ((i = !1),
            s.next ? (s.next.prev = s.prev) : (n = s.prev),
            s.prev ? (s.prev.next = s.next) : (e = s.next));
        }
      );
    },
  };
}
const qT = { notify() {}, get: () => [] };
function SF(t, e) {
  let n,
    r = qT,
    i = 0,
    s = !1;
  function o(_) {
    d();
    const x = r.subscribe(_);
    let m = !1;
    return () => {
      m || ((m = !0), x(), h());
    };
  }
  function a() {
    r.notify();
  }
  function l() {
    v.onStateChange && v.onStateChange();
  }
  function f() {
    return s;
  }
  function d() {
    i++, n || ((n = t.subscribe(l)), (r = _F()));
  }
  function h() {
    i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = qT));
  }
  function p() {
    s || ((s = !0), d());
  }
  function g() {
    s && ((s = !1), h());
  }
  const v = {
    addNestedSub: o,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: f,
    trySubscribe: p,
    tryUnsubscribe: g,
    getListeners: () => r,
  };
  return v;
}
const wF =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  MF = wF ? U.useLayoutEffect : U.useEffect;
function EF({
  store: t,
  context: e,
  children: n,
  serverState: r,
  stabilityCheck: i = "once",
  noopCheck: s = "once",
}) {
  const o = U.useMemo(() => {
      const f = SF(t);
      return {
        store: t,
        subscription: f,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        noopCheck: s,
      };
    }, [t, r, i, s]),
    a = U.useMemo(() => t.getState(), [t]);
  MF(() => {
    const { subscription: f } = o;
    return (
      (f.onStateChange = f.notifyNestedSubs),
      f.trySubscribe(),
      a !== t.getState() && f.notifyNestedSubs(),
      () => {
        f.tryUnsubscribe(), (f.onStateChange = void 0);
      }
    );
  }, [o, a]);
  const l = e || ga;
  return U.createElement(l.Provider, { value: o }, n);
}
function CL(t = ga) {
  const e = t === ga ? SL : Cw(t);
  return function () {
    const { store: r } = e();
    return r;
  };
}
const bF = CL();
function TF(t = ga) {
  const e = t === ga ? bF : CL(t);
  return function () {
    return e().dispatch;
  };
}
const Ow = TF();
oF(eF.useSyncExternalStoreWithSelector);
nF(c0.unstable_batchedUpdates);
function is(t) {
  for (
    var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    n[r - 1] = arguments[r];
  throw Error(
    "[Immer] minified error nr: " +
      t +
      (n.length
        ? " " +
          n
            .map(function (i) {
              return "'" + i + "'";
            })
            .join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function va(t) {
  return !!t && !!t[ln];
}
function xo(t) {
  var e;
  return (
    !!t &&
    ((function (n) {
      if (!n || typeof n != "object") return !1;
      var r = Object.getPrototypeOf(n);
      if (r === null) return !0;
      var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
      return (
        i === Object ||
        (typeof i == "function" && Function.toString.call(i) === DF)
      );
    })(t) ||
      Array.isArray(t) ||
      !!t[nA] ||
      !!(!((e = t.constructor) === null || e === void 0) && e[nA]) ||
      Dw(t) ||
      kw(t))
  );
}
function Cl(t, e, n) {
  n === void 0 && (n = !1),
    Lc(t) === 0
      ? (n ? Object.keys : oc)(t).forEach(function (r) {
          (n && typeof r == "symbol") || e(r, t[r], t);
        })
      : t.forEach(function (r, i) {
          return e(i, r, t);
        });
}
function Lc(t) {
  var e = t[ln];
  return e
    ? e.i > 3
      ? e.i - 4
      : e.i
    : Array.isArray(t)
    ? 1
    : Dw(t)
    ? 2
    : kw(t)
    ? 3
    : 0;
}
function sc(t, e) {
  return Lc(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function AF(t, e) {
  return Lc(t) === 2 ? t.get(e) : t[e];
}
function RL(t, e, n) {
  var r = Lc(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : (t[e] = n);
}
function PL(t, e) {
  return t === e ? t !== 0 || 1 / t == 1 / e : t != t && e != e;
}
function Dw(t) {
  return NF && t instanceof Map;
}
function kw(t) {
  return OF && t instanceof Set;
}
function Ja(t) {
  return t.o || t.t;
}
function Uw(t) {
  if (Array.isArray(t)) return Array.prototype.slice.call(t);
  var e = IL(t);
  delete e[ln];
  for (var n = oc(e), r = 0; r < n.length; r++) {
    var i = n[r],
      s = e[i];
    s.writable === !1 && ((s.writable = !0), (s.configurable = !0)),
      (s.get || s.set) &&
        (e[i] = {
          configurable: !0,
          writable: !0,
          enumerable: s.enumerable,
          value: t[i],
        });
  }
  return Object.create(Object.getPrototypeOf(t), e);
}
function Fw(t, e) {
  return (
    e === void 0 && (e = !1),
    zw(t) ||
      va(t) ||
      !xo(t) ||
      (Lc(t) > 1 && (t.set = t.add = t.clear = t.delete = CF),
      Object.freeze(t),
      e &&
        Cl(
          t,
          function (n, r) {
            return Fw(r, !0);
          },
          !0
        )),
    t
  );
}
function CF() {
  is(2);
}
function zw(t) {
  return t == null || typeof t != "object" || Object.isFrozen(t);
}
function Os(t) {
  var e = SS[t];
  return e || is(18, t), e;
}
function RF(t, e) {
  SS[t] || (SS[t] = e);
}
function yS() {
  return Ed;
}
function gx(t, e) {
  e && (Os("Patches"), (t.u = []), (t.s = []), (t.v = e));
}
function Pg(t) {
  xS(t), t.p.forEach(PF), (t.p = null);
}
function xS(t) {
  t === Ed && (Ed = t.l);
}
function KT(t) {
  return (Ed = { p: [], l: Ed, h: t, m: !0, _: 0 });
}
function PF(t) {
  var e = t[ln];
  e.i === 0 || e.i === 1 ? e.j() : (e.g = !0);
}
function vx(t, e) {
  e._ = e.p.length;
  var n = e.p[0],
    r = t !== void 0 && t !== n;
  return (
    e.h.O || Os("ES5").S(e, t, r),
    r
      ? (n[ln].P && (Pg(e), is(4)),
        xo(t) && ((t = Lg(e, t)), e.l || Ig(e, t)),
        e.u && Os("Patches").M(n[ln].t, t, e.u, e.s))
      : (t = Lg(e, n, [])),
    Pg(e),
    e.u && e.v(e.u, e.s),
    t !== LL ? t : void 0
  );
}
function Lg(t, e, n) {
  if (zw(e)) return e;
  var r = e[ln];
  if (!r)
    return (
      Cl(
        e,
        function (a, l) {
          return ZT(t, r, e, a, l, n);
        },
        !0
      ),
      e
    );
  if (r.A !== t) return e;
  if (!r.P) return Ig(t, r.t, !0), r.t;
  if (!r.I) {
    (r.I = !0), r.A._--;
    var i = r.i === 4 || r.i === 5 ? (r.o = Uw(r.k)) : r.o,
      s = i,
      o = !1;
    r.i === 3 && ((s = new Set(i)), i.clear(), (o = !0)),
      Cl(s, function (a, l) {
        return ZT(t, r, i, a, l, n, o);
      }),
      Ig(t, i, !1),
      n && t.u && Os("Patches").N(r, n, t.u, t.s);
  }
  return r.o;
}
function ZT(t, e, n, r, i, s, o) {
  if (va(i)) {
    var a = Lg(t, i, s && e && e.i !== 3 && !sc(e.R, r) ? s.concat(r) : void 0);
    if ((RL(n, r, a), !va(a))) return;
    t.m = !1;
  } else o && n.add(i);
  if (xo(i) && !zw(i)) {
    if (!t.h.D && t._ < 1) return;
    Lg(t, i), (e && e.A.l) || Ig(t, i);
  }
}
function Ig(t, e, n) {
  n === void 0 && (n = !1), !t.l && t.h.D && t.m && Fw(e, n);
}
function yx(t, e) {
  var n = t[ln];
  return (n ? Ja(n) : t)[e];
}
function JT(t, e) {
  if (e in t)
    for (var n = Object.getPrototypeOf(t); n; ) {
      var r = Object.getOwnPropertyDescriptor(n, e);
      if (r) return r;
      n = Object.getPrototypeOf(n);
    }
}
function qo(t) {
  t.P || ((t.P = !0), t.l && qo(t.l));
}
function xx(t) {
  t.o || (t.o = Uw(t.t));
}
function _S(t, e, n) {
  var r = Dw(e)
    ? Os("MapSet").F(e, n)
    : kw(e)
    ? Os("MapSet").T(e, n)
    : t.O
    ? (function (i, s) {
        var o = Array.isArray(i),
          a = {
            i: o ? 1 : 0,
            A: s ? s.A : yS(),
            P: !1,
            I: !1,
            R: {},
            l: s,
            t: i,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          l = a,
          f = bd;
        o && ((l = [a]), (f = Uf));
        var d = Proxy.revocable(l, f),
          h = d.revoke,
          p = d.proxy;
        return (a.k = p), (a.j = h), p;
      })(e, n)
    : Os("ES5").J(e, n);
  return (n ? n.A : yS()).p.push(r), r;
}
function LF(t) {
  return (
    va(t) || is(22, t),
    (function e(n) {
      if (!xo(n)) return n;
      var r,
        i = n[ln],
        s = Lc(n);
      if (i) {
        if (!i.P && (i.i < 4 || !Os("ES5").K(i))) return i.t;
        (i.I = !0), (r = QT(n, s)), (i.I = !1);
      } else r = QT(n, s);
      return (
        Cl(r, function (o, a) {
          (i && AF(i.t, o) === a) || RL(r, o, e(a));
        }),
        s === 3 ? new Set(r) : r
      );
    })(t)
  );
}
function QT(t, e) {
  switch (e) {
    case 2:
      return new Map(t);
    case 3:
      return Array.from(t);
  }
  return Uw(t);
}
function IF() {
  function t(s, o) {
    var a = i[s];
    return (
      a
        ? (a.enumerable = o)
        : (i[s] = a =
            {
              configurable: !0,
              enumerable: o,
              get: function () {
                var l = this[ln];
                return bd.get(l, s);
              },
              set: function (l) {
                var f = this[ln];
                bd.set(f, s, l);
              },
            }),
      a
    );
  }
  function e(s) {
    for (var o = s.length - 1; o >= 0; o--) {
      var a = s[o][ln];
      if (!a.P)
        switch (a.i) {
          case 5:
            r(a) && qo(a);
            break;
          case 4:
            n(a) && qo(a);
        }
    }
  }
  function n(s) {
    for (var o = s.t, a = s.k, l = oc(a), f = l.length - 1; f >= 0; f--) {
      var d = l[f];
      if (d !== ln) {
        var h = o[d];
        if (h === void 0 && !sc(o, d)) return !0;
        var p = a[d],
          g = p && p[ln];
        if (g ? g.t !== h : !PL(p, h)) return !0;
      }
    }
    var v = !!o[ln];
    return l.length !== oc(o).length + (v ? 0 : 1);
  }
  function r(s) {
    var o = s.k;
    if (o.length !== s.t.length) return !0;
    var a = Object.getOwnPropertyDescriptor(o, o.length - 1);
    if (a && !a.get) return !0;
    for (var l = 0; l < o.length; l++) if (!o.hasOwnProperty(l)) return !0;
    return !1;
  }
  var i = {};
  RF("ES5", {
    J: function (s, o) {
      var a = Array.isArray(s),
        l = (function (d, h) {
          if (d) {
            for (var p = Array(h.length), g = 0; g < h.length; g++)
              Object.defineProperty(p, "" + g, t(g, !0));
            return p;
          }
          var v = IL(h);
          delete v[ln];
          for (var _ = oc(v), x = 0; x < _.length; x++) {
            var m = _[x];
            v[m] = t(m, d || !!v[m].enumerable);
          }
          return Object.create(Object.getPrototypeOf(h), v);
        })(a, s),
        f = {
          i: a ? 5 : 4,
          A: o ? o.A : yS(),
          P: !1,
          I: !1,
          R: {},
          l: o,
          t: s,
          k: l,
          o: null,
          g: !1,
          C: !1,
        };
      return Object.defineProperty(l, ln, { value: f, writable: !0 }), l;
    },
    S: function (s, o, a) {
      a
        ? va(o) && o[ln].A === s && e(s.p)
        : (s.u &&
            (function l(f) {
              if (f && typeof f == "object") {
                var d = f[ln];
                if (d) {
                  var h = d.t,
                    p = d.k,
                    g = d.R,
                    v = d.i;
                  if (v === 4)
                    Cl(p, function (S) {
                      S !== ln &&
                        (h[S] !== void 0 || sc(h, S)
                          ? g[S] || l(p[S])
                          : ((g[S] = !0), qo(d)));
                    }),
                      Cl(h, function (S) {
                        p[S] !== void 0 || sc(p, S) || ((g[S] = !1), qo(d));
                      });
                  else if (v === 5) {
                    if ((r(d) && (qo(d), (g.length = !0)), p.length < h.length))
                      for (var _ = p.length; _ < h.length; _++) g[_] = !1;
                    else for (var x = h.length; x < p.length; x++) g[x] = !0;
                    for (
                      var m = Math.min(p.length, h.length), w = 0;
                      w < m;
                      w++
                    )
                      p.hasOwnProperty(w) || (g[w] = !0),
                        g[w] === void 0 && l(p[w]);
                  }
                }
              }
            })(s.p[0]),
          e(s.p));
    },
    K: function (s) {
      return s.i === 4 ? n(s) : r(s);
    },
  });
}
var eA,
  Ed,
  Bw = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
  NF = typeof Map < "u",
  OF = typeof Set < "u",
  tA = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
  LL = Bw
    ? Symbol.for("immer-nothing")
    : (((eA = {})["immer-nothing"] = !0), eA),
  nA = Bw ? Symbol.for("immer-draftable") : "__$immer_draftable",
  ln = Bw ? Symbol.for("immer-state") : "__$immer_state",
  DF = "" + Object.prototype.constructor,
  oc =
    typeof Reflect < "u" && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
      ? function (t) {
          return Object.getOwnPropertyNames(t).concat(
            Object.getOwnPropertySymbols(t)
          );
        }
      : Object.getOwnPropertyNames,
  IL =
    Object.getOwnPropertyDescriptors ||
    function (t) {
      var e = {};
      return (
        oc(t).forEach(function (n) {
          e[n] = Object.getOwnPropertyDescriptor(t, n);
        }),
        e
      );
    },
  SS = {},
  bd = {
    get: function (t, e) {
      if (e === ln) return t;
      var n = Ja(t);
      if (!sc(n, e))
        return (function (i, s, o) {
          var a,
            l = JT(s, o);
          return l
            ? "value" in l
              ? l.value
              : (a = l.get) === null || a === void 0
              ? void 0
              : a.call(i.k)
            : void 0;
        })(t, n, e);
      var r = n[e];
      return t.I || !xo(r)
        ? r
        : r === yx(t.t, e)
        ? (xx(t), (t.o[e] = _S(t.A.h, r, t)))
        : r;
    },
    has: function (t, e) {
      return e in Ja(t);
    },
    ownKeys: function (t) {
      return Reflect.ownKeys(Ja(t));
    },
    set: function (t, e, n) {
      var r = JT(Ja(t), e);
      if (r != null && r.set) return r.set.call(t.k, n), !0;
      if (!t.P) {
        var i = yx(Ja(t), e),
          s = i == null ? void 0 : i[ln];
        if (s && s.t === n) return (t.o[e] = n), (t.R[e] = !1), !0;
        if (PL(n, i) && (n !== void 0 || sc(t.t, e))) return !0;
        xx(t), qo(t);
      }
      return (
        (t.o[e] === n && (n !== void 0 || e in t.o)) ||
          (Number.isNaN(n) && Number.isNaN(t.o[e])) ||
          ((t.o[e] = n), (t.R[e] = !0)),
        !0
      );
    },
    deleteProperty: function (t, e) {
      return (
        yx(t.t, e) !== void 0 || e in t.t
          ? ((t.R[e] = !1), xx(t), qo(t))
          : delete t.R[e],
        t.o && delete t.o[e],
        !0
      );
    },
    getOwnPropertyDescriptor: function (t, e) {
      var n = Ja(t),
        r = Reflect.getOwnPropertyDescriptor(n, e);
      return (
        r && {
          writable: !0,
          configurable: t.i !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: n[e],
        }
      );
    },
    defineProperty: function () {
      is(11);
    },
    getPrototypeOf: function (t) {
      return Object.getPrototypeOf(t.t);
    },
    setPrototypeOf: function () {
      is(12);
    },
  },
  Uf = {};
Cl(bd, function (t, e) {
  Uf[t] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
}),
  (Uf.deleteProperty = function (t, e) {
    return Uf.set.call(this, t, e, void 0);
  }),
  (Uf.set = function (t, e, n) {
    return bd.set.call(this, t[0], e, n, t[0]);
  });
var kF = (function () {
    function t(n) {
      var r = this;
      (this.O = tA),
        (this.D = !0),
        (this.produce = function (i, s, o) {
          if (typeof i == "function" && typeof s != "function") {
            var a = s;
            s = i;
            var l = r;
            return function (_) {
              var x = this;
              _ === void 0 && (_ = a);
              for (
                var m = arguments.length, w = Array(m > 1 ? m - 1 : 0), S = 1;
                S < m;
                S++
              )
                w[S - 1] = arguments[S];
              return l.produce(_, function (E) {
                var T;
                return (T = s).call.apply(T, [x, E].concat(w));
              });
            };
          }
          var f;
          if (
            (typeof s != "function" && is(6),
            o !== void 0 && typeof o != "function" && is(7),
            xo(i))
          ) {
            var d = KT(r),
              h = _S(r, i, void 0),
              p = !0;
            try {
              (f = s(h)), (p = !1);
            } finally {
              p ? Pg(d) : xS(d);
            }
            return typeof Promise < "u" && f instanceof Promise
              ? f.then(
                  function (_) {
                    return gx(d, o), vx(_, d);
                  },
                  function (_) {
                    throw (Pg(d), _);
                  }
                )
              : (gx(d, o), vx(f, d));
          }
          if (!i || typeof i != "object") {
            if (
              ((f = s(i)) === void 0 && (f = i),
              f === LL && (f = void 0),
              r.D && Fw(f, !0),
              o)
            ) {
              var g = [],
                v = [];
              Os("Patches").M(i, f, g, v), o(g, v);
            }
            return f;
          }
          is(21, i);
        }),
        (this.produceWithPatches = function (i, s) {
          if (typeof i == "function")
            return function (f) {
              for (
                var d = arguments.length, h = Array(d > 1 ? d - 1 : 0), p = 1;
                p < d;
                p++
              )
                h[p - 1] = arguments[p];
              return r.produceWithPatches(f, function (g) {
                return i.apply(void 0, [g].concat(h));
              });
            };
          var o,
            a,
            l = r.produce(i, s, function (f, d) {
              (o = f), (a = d);
            });
          return typeof Promise < "u" && l instanceof Promise
            ? l.then(function (f) {
                return [f, o, a];
              })
            : [l, o, a];
        }),
        typeof (n == null ? void 0 : n.useProxies) == "boolean" &&
          this.setUseProxies(n.useProxies),
        typeof (n == null ? void 0 : n.autoFreeze) == "boolean" &&
          this.setAutoFreeze(n.autoFreeze);
    }
    var e = t.prototype;
    return (
      (e.createDraft = function (n) {
        xo(n) || is(8), va(n) && (n = LF(n));
        var r = KT(this),
          i = _S(this, n, void 0);
        return (i[ln].C = !0), xS(r), i;
      }),
      (e.finishDraft = function (n, r) {
        var i = n && n[ln],
          s = i.A;
        return gx(s, r), vx(void 0, s);
      }),
      (e.setAutoFreeze = function (n) {
        this.D = n;
      }),
      (e.setUseProxies = function (n) {
        n && !tA && is(20), (this.O = n);
      }),
      (e.applyPatches = function (n, r) {
        var i;
        for (i = r.length - 1; i >= 0; i--) {
          var s = r[i];
          if (s.path.length === 0 && s.op === "replace") {
            n = s.value;
            break;
          }
        }
        i > -1 && (r = r.slice(i + 1));
        var o = Os("Patches").$;
        return va(n)
          ? o(n, r)
          : this.produce(n, function (a) {
              return o(a, r);
            });
      }),
      t
    );
  })(),
  _i = new kF(),
  NL = _i.produce;
_i.produceWithPatches.bind(_i);
_i.setAutoFreeze.bind(_i);
_i.setUseProxies.bind(_i);
_i.applyPatches.bind(_i);
_i.createDraft.bind(_i);
_i.finishDraft.bind(_i);
function Td(t) {
  "@babel/helpers - typeof";
  return (
    (Td =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Td(t)
  );
}
function UF(t, e) {
  if (Td(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (Td(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function FF(t) {
  var e = UF(t, "string");
  return Td(e) == "symbol" ? e : e + "";
}
function zF(t, e, n) {
  return (
    (e = FF(e)) in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function rA(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function iA(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? rA(Object(n), !0).forEach(function (r) {
          zF(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : rA(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
function br(t) {
  return (
    "Minified Redux error #" +
    t +
    "; visit https://redux.js.org/Errors?code=" +
    t +
    " for the full message or use the non-minified dev environment for full errors. "
  );
}
var sA = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })(),
  _x = function () {
    return Math.random().toString(36).substring(7).split("").join(".");
  },
  Ng = {
    INIT: "@@redux/INIT" + _x(),
    REPLACE: "@@redux/REPLACE" + _x(),
    PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + _x();
    },
  };
function BF(t) {
  if (typeof t != "object" || t === null) return !1;
  for (var e = t; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
function OL(t, e, n) {
  var r;
  if (
    (typeof e == "function" && typeof n == "function") ||
    (typeof n == "function" && typeof arguments[3] == "function")
  )
    throw new Error(br(0));
  if (
    (typeof e == "function" && typeof n > "u" && ((n = e), (e = void 0)),
    typeof n < "u")
  ) {
    if (typeof n != "function") throw new Error(br(1));
    return n(OL)(t, e);
  }
  if (typeof t != "function") throw new Error(br(2));
  var i = t,
    s = e,
    o = [],
    a = o,
    l = !1;
  function f() {
    a === o && (a = o.slice());
  }
  function d() {
    if (l) throw new Error(br(3));
    return s;
  }
  function h(_) {
    if (typeof _ != "function") throw new Error(br(4));
    if (l) throw new Error(br(5));
    var x = !0;
    return (
      f(),
      a.push(_),
      function () {
        if (x) {
          if (l) throw new Error(br(6));
          (x = !1), f();
          var w = a.indexOf(_);
          a.splice(w, 1), (o = null);
        }
      }
    );
  }
  function p(_) {
    if (!BF(_)) throw new Error(br(7));
    if (typeof _.type > "u") throw new Error(br(8));
    if (l) throw new Error(br(9));
    try {
      (l = !0), (s = i(s, _));
    } finally {
      l = !1;
    }
    for (var x = (o = a), m = 0; m < x.length; m++) {
      var w = x[m];
      w();
    }
    return _;
  }
  function g(_) {
    if (typeof _ != "function") throw new Error(br(10));
    (i = _), p({ type: Ng.REPLACE });
  }
  function v() {
    var _,
      x = h;
    return (
      (_ = {
        subscribe: function (w) {
          if (typeof w != "object" || w === null) throw new Error(br(11));
          function S() {
            w.next && w.next(d());
          }
          S();
          var E = x(S);
          return { unsubscribe: E };
        },
      }),
      (_[sA] = function () {
        return this;
      }),
      _
    );
  }
  return (
    p({ type: Ng.INIT }),
    (r = { dispatch: p, subscribe: h, getState: d, replaceReducer: g }),
    (r[sA] = v),
    r
  );
}
function HF(t) {
  Object.keys(t).forEach(function (e) {
    var n = t[e],
      r = n(void 0, { type: Ng.INIT });
    if (typeof r > "u") throw new Error(br(12));
    if (typeof n(void 0, { type: Ng.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(br(13));
  });
}
function VF(t) {
  for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++) {
    var i = e[r];
    typeof t[i] == "function" && (n[i] = t[i]);
  }
  var s = Object.keys(n),
    o;
  try {
    HF(n);
  } catch (a) {
    o = a;
  }
  return function (l, f) {
    if ((l === void 0 && (l = {}), o)) throw o;
    for (var d = !1, h = {}, p = 0; p < s.length; p++) {
      var g = s[p],
        v = n[g],
        _ = l[g],
        x = v(_, f);
      if (typeof x > "u") throw (f && f.type, new Error(br(14)));
      (h[g] = x), (d = d || x !== _);
    }
    return (d = d || s.length !== Object.keys(l).length), d ? h : l;
  };
}
function Og() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return e.length === 0
    ? function (r) {
        return r;
      }
    : e.length === 1
    ? e[0]
    : e.reduce(function (r, i) {
        return function () {
          return r(i.apply(void 0, arguments));
        };
      });
}
function WF() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return function (r) {
    return function () {
      var i = r.apply(void 0, arguments),
        s = function () {
          throw new Error(br(15));
        },
        o = {
          getState: i.getState,
          dispatch: function () {
            return s.apply(void 0, arguments);
          },
        },
        a = e.map(function (l) {
          return l(o);
        });
      return (
        (s = Og.apply(void 0, a)(i.dispatch)),
        iA(iA({}, i), {}, { dispatch: s })
      );
    };
  };
}
function DL(t) {
  var e = function (r) {
    var i = r.dispatch,
      s = r.getState;
    return function (o) {
      return function (a) {
        return typeof a == "function" ? a(i, s, t) : o(a);
      };
    };
  };
  return e;
}
var wS = DL();
wS.withExtraArgument = DL;
var kL = (function () {
    var t = function (e, n) {
      return (
        (t =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (r, i) {
              r.__proto__ = i;
            }) ||
          function (r, i) {
            for (var s in i)
              Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
          }),
        t(e, n)
      );
    };
    return function (e, n) {
      if (typeof n != "function" && n !== null)
        throw new TypeError(
          "Class extends value " + String(n) + " is not a constructor or null"
        );
      t(e, n);
      function r() {
        this.constructor = e;
      }
      e.prototype =
        n === null ? Object.create(n) : ((r.prototype = n.prototype), new r());
    };
  })(),
  GF = function (t, e) {
    var n = {
        label: 0,
        sent: function () {
          if (s[0] & 1) throw s[1];
          return s[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      s,
      o;
    return (
      (o = { next: a(0), throw: a(1), return: a(2) }),
      typeof Symbol == "function" &&
        (o[Symbol.iterator] = function () {
          return this;
        }),
      o
    );
    function a(f) {
      return function (d) {
        return l([f, d]);
      };
    }
    function l(f) {
      if (r) throw new TypeError("Generator is already executing.");
      for (; n; )
        try {
          if (
            ((r = 1),
            i &&
              (s =
                f[0] & 2
                  ? i.return
                  : f[0]
                  ? i.throw || ((s = i.return) && s.call(i), 0)
                  : i.next) &&
              !(s = s.call(i, f[1])).done)
          )
            return s;
          switch (((i = 0), s && (f = [f[0] & 2, s.value]), f[0])) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return n.label++, { value: f[1], done: !1 };
            case 5:
              n.label++, (i = f[1]), (f = [0]);
              continue;
            case 7:
              (f = n.ops.pop()), n.trys.pop();
              continue;
            default:
              if (
                ((s = n.trys),
                !(s = s.length > 0 && s[s.length - 1]) &&
                  (f[0] === 6 || f[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (f[0] === 3 && (!s || (f[1] > s[0] && f[1] < s[3]))) {
                n.label = f[1];
                break;
              }
              if (f[0] === 6 && n.label < s[1]) {
                (n.label = s[1]), (s = f);
                break;
              }
              if (s && n.label < s[2]) {
                (n.label = s[2]), n.ops.push(f);
                break;
              }
              s[2] && n.ops.pop(), n.trys.pop();
              continue;
          }
          f = e.call(t, n);
        } catch (d) {
          (f = [6, d]), (i = 0);
        } finally {
          r = s = 0;
        }
      if (f[0] & 5) throw f[1];
      return { value: f[0] ? f[1] : void 0, done: !0 };
    }
  },
  yc = function (t, e) {
    for (var n = 0, r = e.length, i = t.length; n < r; n++, i++) t[i] = e[n];
    return t;
  },
  jF = Object.defineProperty,
  $F = Object.defineProperties,
  XF = Object.getOwnPropertyDescriptors,
  oA = Object.getOwnPropertySymbols,
  YF = Object.prototype.hasOwnProperty,
  qF = Object.prototype.propertyIsEnumerable,
  aA = function (t, e, n) {
    return e in t
      ? jF(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n);
  },
  aa = function (t, e) {
    for (var n in e || (e = {})) YF.call(e, n) && aA(t, n, e[n]);
    if (oA)
      for (var r = 0, i = oA(e); r < i.length; r++) {
        var n = i[r];
        qF.call(e, n) && aA(t, n, e[n]);
      }
    return t;
  },
  Sx = function (t, e) {
    return $F(t, XF(e));
  },
  KF = function (t, e, n) {
    return new Promise(function (r, i) {
      var s = function (l) {
          try {
            a(n.next(l));
          } catch (f) {
            i(f);
          }
        },
        o = function (l) {
          try {
            a(n.throw(l));
          } catch (f) {
            i(f);
          }
        },
        a = function (l) {
          return l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
        };
      a((n = n.apply(t, e)).next());
    });
  },
  ZF =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? Og
              : Og.apply(null, arguments);
        };
function JF(t) {
  if (typeof t != "object" || t === null) return !1;
  var e = Object.getPrototypeOf(t);
  if (e === null) return !0;
  for (var n = e; Object.getPrototypeOf(n) !== null; )
    n = Object.getPrototypeOf(n);
  return e === n;
}
function la(t, e) {
  function n() {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
    if (e) {
      var s = e.apply(void 0, r);
      if (!s) throw new Error("prepareAction did not return an object");
      return aa(
        aa({ type: t, payload: s.payload }, "meta" in s && { meta: s.meta }),
        "error" in s && { error: s.error }
      );
    }
    return { type: t, payload: r[0] };
  }
  return (
    (n.toString = function () {
      return "" + t;
    }),
    (n.type = t),
    (n.match = function (r) {
      return r.type === t;
    }),
    n
  );
}
var QF = (function (t) {
    kL(e, t);
    function e() {
      for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
      var i = t.apply(this, n) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return t.prototype.concat.apply(this, n);
      }),
      (e.prototype.prepend = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return n.length === 1 && Array.isArray(n[0])
          ? new (e.bind.apply(e, yc([void 0], n[0].concat(this))))()
          : new (e.bind.apply(e, yc([void 0], n.concat(this))))();
      }),
      e
    );
  })(Array),
  ez = (function (t) {
    kL(e, t);
    function e() {
      for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
      var i = t.apply(this, n) || this;
      return Object.setPrototypeOf(i, e.prototype), i;
    }
    return (
      Object.defineProperty(e, Symbol.species, {
        get: function () {
          return e;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.concat = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return t.prototype.concat.apply(this, n);
      }),
      (e.prototype.prepend = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return n.length === 1 && Array.isArray(n[0])
          ? new (e.bind.apply(e, yc([void 0], n[0].concat(this))))()
          : new (e.bind.apply(e, yc([void 0], n.concat(this))))();
      }),
      e
    );
  })(Array);
function MS(t) {
  return xo(t) ? NL(t, function () {}) : t;
}
function tz(t) {
  return typeof t == "boolean";
}
function nz() {
  return function (e) {
    return rz(e);
  };
}
function rz(t) {
  t === void 0 && (t = {});
  var e = t.thunk,
    n = e === void 0 ? !0 : e;
  t.immutableCheck, t.serializableCheck, t.actionCreatorCheck;
  var r = new QF();
  return (
    n && (tz(n) ? r.push(wS) : r.push(wS.withExtraArgument(n.extraArgument))), r
  );
}
function iz(t) {
  var e = nz(),
    n = t || {},
    r = n.reducer,
    i = r === void 0 ? void 0 : r,
    s = n.middleware,
    o = s === void 0 ? e() : s,
    a = n.devTools,
    l = a === void 0 ? !0 : a,
    f = n.preloadedState,
    d = f === void 0 ? void 0 : f,
    h = n.enhancers,
    p = h === void 0 ? void 0 : h,
    g;
  if (typeof i == "function") g = i;
  else if (JF(i)) g = VF(i);
  else
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  var v = o;
  typeof v == "function" && (v = v(e));
  var _ = WF.apply(void 0, v),
    x = Og;
  l && (x = ZF(aa({ trace: !1 }, typeof l == "object" && l)));
  var m = new ez(_),
    w = m;
  Array.isArray(p) ? (w = yc([_], p)) : typeof p == "function" && (w = p(m));
  var S = x.apply(void 0, w);
  return OL(g, d, S);
}
function UL(t) {
  var e = {},
    n = [],
    r,
    i = {
      addCase: function (s, o) {
        var a = typeof s == "string" ? s : s.type;
        if (!a)
          throw new Error(
            "`builder.addCase` cannot be called with an empty action type"
          );
        if (a in e)
          throw new Error(
            "`builder.addCase` cannot be called with two reducers for the same action type"
          );
        return (e[a] = o), i;
      },
      addMatcher: function (s, o) {
        return n.push({ matcher: s, reducer: o }), i;
      },
      addDefaultCase: function (s) {
        return (r = s), i;
      },
    };
  return t(i), [e, n, r];
}
function sz(t) {
  return typeof t == "function";
}
function oz(t, e, n, r) {
  n === void 0 && (n = []);
  var i = typeof e == "function" ? UL(e) : [e, n, r],
    s = i[0],
    o = i[1],
    a = i[2],
    l;
  if (sz(t))
    l = function () {
      return MS(t());
    };
  else {
    var f = MS(t);
    l = function () {
      return f;
    };
  }
  function d(h, p) {
    h === void 0 && (h = l());
    var g = yc(
      [s[p.type]],
      o
        .filter(function (v) {
          var _ = v.matcher;
          return _(p);
        })
        .map(function (v) {
          var _ = v.reducer;
          return _;
        })
    );
    return (
      g.filter(function (v) {
        return !!v;
      }).length === 0 && (g = [a]),
      g.reduce(function (v, _) {
        if (_)
          if (va(v)) {
            var x = v,
              m = _(x, p);
            return m === void 0 ? v : m;
          } else {
            if (xo(v))
              return NL(v, function (w) {
                return _(w, p);
              });
            var m = _(v, p);
            if (m === void 0) {
              if (v === null) return v;
              throw Error(
                "A case reducer on a non-draftable value must not return undefined"
              );
            }
            return m;
          }
        return v;
      }, h)
    );
  }
  return (d.getInitialState = l), d;
}
function az(t, e) {
  return t + "/" + e;
}
function I0(t) {
  var e = t.name;
  if (!e) throw new Error("`name` is a required option for createSlice");
  var n =
      typeof t.initialState == "function" ? t.initialState : MS(t.initialState),
    r = t.reducers || {},
    i = Object.keys(r),
    s = {},
    o = {},
    a = {};
  i.forEach(function (d) {
    var h = r[d],
      p = az(e, d),
      g,
      v;
    "reducer" in h ? ((g = h.reducer), (v = h.prepare)) : (g = h),
      (s[d] = g),
      (o[p] = g),
      (a[d] = v ? la(p, v) : la(p));
  });
  function l() {
    var d =
        typeof t.extraReducers == "function"
          ? UL(t.extraReducers)
          : [t.extraReducers],
      h = d[0],
      p = h === void 0 ? {} : h,
      g = d[1],
      v = g === void 0 ? [] : g,
      _ = d[2],
      x = _ === void 0 ? void 0 : _,
      m = aa(aa({}, p), o);
    return oz(n, function (w) {
      for (var S in m) w.addCase(S, m[S]);
      for (var E = 0, T = v; E < T.length; E++) {
        var A = T[E];
        w.addMatcher(A.matcher, A.reducer);
      }
      x && w.addDefaultCase(x);
    });
  }
  var f;
  return {
    name: e,
    reducer: function (d, h) {
      return f || (f = l()), f(d, h);
    },
    actions: a,
    caseReducers: s,
    getInitialState: function () {
      return f || (f = l()), f.getInitialState();
    },
  };
}
var lz = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  uz = function (t) {
    t === void 0 && (t = 21);
    for (var e = "", n = t; n--; ) e += lz[(Math.random() * 64) | 0];
    return e;
  },
  cz = ["name", "message", "stack", "code"],
  wx = (function () {
    function t(e, n) {
      (this.payload = e), (this.meta = n);
    }
    return t;
  })(),
  lA = (function () {
    function t(e, n) {
      (this.payload = e), (this.meta = n);
    }
    return t;
  })(),
  fz = function (t) {
    if (typeof t == "object" && t !== null) {
      for (var e = {}, n = 0, r = cz; n < r.length; n++) {
        var i = r[n];
        typeof t[i] == "string" && (e[i] = t[i]);
      }
      return e;
    }
    return { message: String(t) };
  };
(function () {
  function t(e, n, r) {
    var i = la(e + "/fulfilled", function (f, d, h, p) {
        return {
          payload: f,
          meta: Sx(aa({}, p || {}), {
            arg: h,
            requestId: d,
            requestStatus: "fulfilled",
          }),
        };
      }),
      s = la(e + "/pending", function (f, d, h) {
        return {
          payload: void 0,
          meta: Sx(aa({}, h || {}), {
            arg: d,
            requestId: f,
            requestStatus: "pending",
          }),
        };
      }),
      o = la(e + "/rejected", function (f, d, h, p, g) {
        return {
          payload: p,
          error: ((r && r.serializeError) || fz)(f || "Rejected"),
          meta: Sx(aa({}, g || {}), {
            arg: h,
            requestId: d,
            rejectedWithValue: !!p,
            requestStatus: "rejected",
            aborted: (f == null ? void 0 : f.name) === "AbortError",
            condition: (f == null ? void 0 : f.name) === "ConditionError",
          }),
        };
      }),
      a =
        typeof AbortController < "u"
          ? AbortController
          : (function () {
              function f() {
                this.signal = {
                  aborted: !1,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return !1;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {},
                };
              }
              return (f.prototype.abort = function () {}), f;
            })();
    function l(f) {
      return function (d, h, p) {
        var g = r != null && r.idGenerator ? r.idGenerator(f) : uz(),
          v = new a(),
          _;
        function x(w) {
          (_ = w), v.abort();
        }
        var m = (function () {
          return KF(this, null, function () {
            var w, S, E, T, A, L, N;
            return GF(this, function (C) {
              switch (C.label) {
                case 0:
                  return (
                    C.trys.push([0, 4, , 5]),
                    (T =
                      (w = r == null ? void 0 : r.condition) == null
                        ? void 0
                        : w.call(r, f, { getState: h, extra: p })),
                    hz(T) ? [4, T] : [3, 2]
                  );
                case 1:
                  (T = C.sent()), (C.label = 2);
                case 2:
                  if (T === !1 || v.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message:
                        "Aborted due to condition callback returning false.",
                    };
                  return (
                    (A = new Promise(function (I, k) {
                      return v.signal.addEventListener("abort", function () {
                        return k({
                          name: "AbortError",
                          message: _ || "Aborted",
                        });
                      });
                    })),
                    d(
                      s(
                        g,
                        f,
                        (S = r == null ? void 0 : r.getPendingMeta) == null
                          ? void 0
                          : S.call(
                              r,
                              { requestId: g, arg: f },
                              { getState: h, extra: p }
                            )
                      )
                    ),
                    [
                      4,
                      Promise.race([
                        A,
                        Promise.resolve(
                          n(f, {
                            dispatch: d,
                            getState: h,
                            extra: p,
                            requestId: g,
                            signal: v.signal,
                            abort: x,
                            rejectWithValue: function (I, k) {
                              return new wx(I, k);
                            },
                            fulfillWithValue: function (I, k) {
                              return new lA(I, k);
                            },
                          })
                        ).then(function (I) {
                          if (I instanceof wx) throw I;
                          return I instanceof lA
                            ? i(I.payload, g, f, I.meta)
                            : i(I, g, f);
                        }),
                      ]),
                    ]
                  );
                case 3:
                  return (E = C.sent()), [3, 5];
                case 4:
                  return (
                    (L = C.sent()),
                    (E =
                      L instanceof wx
                        ? o(null, g, f, L.payload, L.meta)
                        : o(L, g, f)),
                    [3, 5]
                  );
                case 5:
                  return (
                    (N =
                      r &&
                      !r.dispatchConditionRejection &&
                      o.match(E) &&
                      E.meta.condition),
                    N || d(E),
                    [2, E]
                  );
              }
            });
          });
        })();
        return Object.assign(m, {
          abort: x,
          requestId: g,
          arg: f,
          unwrap: function () {
            return m.then(dz);
          },
        });
      };
    }
    return Object.assign(l, {
      pending: s,
      rejected: o,
      fulfilled: i,
      typePrefix: e,
    });
  }
  return (
    (t.withTypes = function () {
      return t;
    }),
    t
  );
})();
function dz(t) {
  if (t.meta && t.meta.rejectedWithValue) throw t.payload;
  if (t.error) throw t.error;
  return t.payload;
}
function hz(t) {
  return t !== null && typeof t == "object" && typeof t.then == "function";
}
var Hw = "listenerMiddleware";
la(Hw + "/add");
la(Hw + "/removeAll");
la(Hw + "/remove");
var uA;
typeof queueMicrotask == "function" &&
  queueMicrotask.bind(
    typeof window < "u" ? window : typeof global < "u" ? global : globalThis
  );
IF();
const cA = (t) =>
    Array.from({ length: 3 }, (e, n) => ({
      id: `${t}-${n + 1}`,
      color: t,
      contains: null,
    })),
  FL = I0({
    name: "chain",
    initialState: {
      honest: cA("green"),
      secret: cA("red"),
      acceptedChain: null,
    },
    reducers: {
      addBlockToHonest(t, e) {
        t.honest.push(e.payload);
      },
      addBlockToSecret(t, e) {
        t.secret.push(e.payload);
      },
      resetSecret(t) {
        t.secret = [];
      },
      attachTxToLatestHonest(t, e) {
        const n = t.honest.length - 1;
        n >= 0 && (t.honest[n].contains = e.payload);
      },
      attachTxToLatestSecret(t, e) {
        const n = t.secret.length - 1;
        n >= 0 && (t.secret[n].contains = e.payload);
      },
      compareChains(t) {
        t.honest.length > t.secret.length
          ? (t.acceptedChain = "honest")
          : t.secret.length > t.honest.length
          ? (t.acceptedChain = "secret")
          : (t.acceptedChain = null);
      },
      setAcceptedChain(t, e) {
        t.acceptedChain = e.payload;
      },
    },
  }),
  { addBlockToHonest: pz, addBlockToSecret: mz, resetSecret: gz } = FL.actions,
  vz = FL.reducer,
  zL = I0({
    name: "tx",
    initialState: {
      pending: null,
      txA: null,
      txB: null,
      tnxSts: !1,
      tnxBlock: !1,
      confirmblock: !1,
      honestwins: !1,
    },
    reducers: {
      makeTnx(t, e) {
        t.tnxSts = !0;
      },
      createTxs(t, e) {
        t.tnxSts = !0;
        const n = `tnxA-${Date.now()}`,
          r = `tnxB-${Date.now()}`;
        (t.pending = n),
          (t.txA = {
            id: n,
            from: "attacker",
            to: "merchant",
            status: "pending",
            includedAt: null,
          }),
          (t.txB = {
            id: r,
            from: "attacker",
            to: "friend",
            status: "pending",
            includedAt: null,
          });
      },
      confirmTxA(t, e) {
        t.txA && ((t.txA.status = "confirmed"), (t.txA.includedAt = e.payload));
      },
      creditTxA(t) {
        t.txA && (t.txA.status = "credited");
      },
      confirmTxB(t, e) {
        t.txB && ((t.txB.status = "confirmed"), (t.txB.includedAt = e.payload));
      },
      discardTxB(t) {
        t.txB && (t.txB.status = "discarded");
      },
      setTnxBlock(t, e) {
        t.tnxBlock = e.payload;
      },
      setConfirmBlock(t, e) {
        t.confirmblock = e.payload;
      },
      setHonestWin(t) {
        t.honestwins = !0;
      },
    },
  }),
  {
    makeTnx: yz,
    confirmTxA: xz,
    setConfirmBlock: _z,
    setHonestWin: Sz,
    setTnxBlock: wz,
    confirmTxB: Mz,
    creditTxA: Ez,
  } = zL.actions,
  bz = zL.reducer,
  fA = (t) =>
    Array.from({ length: t }, (e, n) => ({
      id: `Miner ${n + 1}`,
      pct: Math.random() * 100,
    })),
  BL = I0({
    name: "miners",
    initialState: {
      honestMiners: fA(6),
      secretMiners: fA(3),
      enableReveal: !1,
      stopMining: !1,
      tnxRace: !1,
      othertnxmining: !1,
    },
    reducers: {
      setHonestMiners(t, e) {
        t.honestMiners = e.payload;
      },
      setSecretMiners(t, e) {
        t.secretMiners = e.payload;
      },
      updateHonestPct(t, e) {
        t.honestMiners = e.payload;
      },
      updateSecretPct(t, e) {
        t.secretMiners = e.payload;
      },
      enableRevealButton(t, e) {
        t.enableReveal = !0;
      },
      stopMining(t, e) {
        (t.stopMining = !0),
          console.log("HERE IN MINER SLICE STOP MINING", t.stopMining);
      },
      setTnxRace(t) {
        t.tnxRace = !0;
      },
      setOtherTnxMining(t) {
        t.othertnxmining = !0;
      },
    },
  }),
  {
    enableRevealButton: Tz,
    stopMining: Az,
    setOtherTnxMining: Cz,
    setTnxRace: Rz,
    updateHonestPct: Pz,
    updateSecretPct: Lz,
  } = BL.actions,
  Iz = BL.reducer,
  HL = I0({
    name: "balance",
    initialState: {
      attacker: 500,
      sendedAmount: 0,
      friend: 800,
      merchant: 2e3,
      paymentSts: "idle",
    },
    reducers: {
      creditMerchant(t, e) {
        (t.merchant += t.sendedAmount), (t.paymentSts = "credited");
      },
      creditFriend(t, e) {
        t.friend += e.payload || 100;
      },
      debitAttacker(t, e) {
        (t.attacker -= e.payload), (t.sendedAmount = e.payload);
      },
    },
  }),
  { creditMerchant: VL, creditFriend: Nz, debitAttacker: Oz } = HL.actions,
  Dz = HL.reducer,
  kz = iz({ reducer: { chain: vz, tx: bz, miners: Iz, balance: Dz } });
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const N0 = "159",
  Qa = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  el = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  WL = 0,
  ES = 1,
  GL = 2,
  Uz = 3,
  jL = 0,
  O0 = 1,
  Jf = 2,
  es = 3,
  _o = 0,
  Hr = 1,
  Ps = 2,
  Fz = 2,
  po = 0,
  yl = 1,
  bS = 2,
  TS = 3,
  AS = 4,
  $L = 5,
  Ko = 100,
  XL = 101,
  YL = 102,
  CS = 103,
  RS = 104,
  qL = 200,
  KL = 201,
  ZL = 202,
  JL = 203,
  Dg = 204,
  kg = 205,
  QL = 206,
  eI = 207,
  tI = 208,
  nI = 209,
  rI = 210,
  iI = 211,
  sI = 212,
  oI = 213,
  aI = 214,
  lI = 0,
  uI = 1,
  cI = 2,
  Ad = 3,
  fI = 4,
  dI = 5,
  hI = 6,
  pI = 7,
  rh = 0,
  mI = 1,
  gI = 2,
  Ds = 0,
  vI = 1,
  yI = 2,
  xI = 3,
  Vw = 4,
  _I = 5,
  PS = "attached",
  SI = "detached",
  D0 = 300,
  So = 301,
  ya = 302,
  Cd = 303,
  Rd = 304,
  Ic = 306,
  Pd = 1e3,
  Cr = 1001,
  Ld = 1002,
  An = 1003,
  Ug = 1004,
  zz = 1004,
  Qf = 1005,
  Bz = 1005,
  Rn = 1006,
  Ww = 1007,
  Hz = 1007,
  xa = 1008,
  Vz = 1008,
  ks = 1009,
  wI = 1010,
  MI = 1011,
  k0 = 1012,
  Gw = 1013,
  fo = 1014,
  ss = 1015,
  xc = 1016,
  jw = 1017,
  $w = 1018,
  ua = 1020,
  EI = 1021,
  zr = 1023,
  bI = 1024,
  TI = 1025,
  ca = 1026,
  Rl = 1027,
  AI = 1028,
  Xw = 1029,
  CI = 1030,
  Yw = 1031,
  qw = 1033,
  Xm = 33776,
  Ym = 33777,
  qm = 33778,
  Km = 33779,
  LS = 35840,
  IS = 35841,
  NS = 35842,
  OS = 35843,
  Kw = 36196,
  DS = 37492,
  kS = 37496,
  US = 37808,
  FS = 37809,
  zS = 37810,
  BS = 37811,
  HS = 37812,
  VS = 37813,
  WS = 37814,
  GS = 37815,
  jS = 37816,
  $S = 37817,
  XS = 37818,
  YS = 37819,
  qS = 37820,
  KS = 37821,
  Zm = 36492,
  ZS = 36494,
  JS = 36495,
  RI = 36283,
  QS = 36284,
  e1 = 36285,
  t1 = 36286,
  PI = 2200,
  LI = 2201,
  II = 2202,
  Id = 2300,
  Nd = 2301,
  Jm = 2302,
  cl = 2400,
  fl = 2401,
  Od = 2402,
  U0 = 2500,
  Zw = 2501,
  Wz = 0,
  Gz = 1,
  jz = 2,
  Jw = 3e3,
  fa = 3001,
  NI = 3200,
  OI = 3201,
  ba = 0,
  DI = 1,
  hi = "",
  Wn = "srgb",
  zs = "srgb-linear",
  F0 = "display-p3",
  ih = "display-p3-linear",
  Dd = "linear",
  Jt = "srgb",
  kd = "rec709",
  Ud = "p3",
  $z = 0,
  tl = 7680,
  Xz = 7681,
  Yz = 7682,
  qz = 7683,
  Kz = 34055,
  Zz = 34056,
  Jz = 5386,
  Qz = 512,
  eB = 513,
  tB = 514,
  nB = 515,
  rB = 516,
  iB = 517,
  sB = 518,
  n1 = 519,
  kI = 512,
  UI = 513,
  FI = 514,
  Qw = 515,
  zI = 516,
  BI = 517,
  HI = 518,
  VI = 519,
  Fd = 35044,
  oB = 35048,
  aB = 35040,
  lB = 35045,
  uB = 35049,
  cB = 35041,
  fB = 35046,
  dB = 35050,
  hB = 35042,
  pB = "100",
  r1 = "300 es",
  Fg = 1035,
  os = 2e3,
  _c = 2001;
let Ao = class {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(n);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
};
const Sr = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let dA = 1234567;
const xl = Math.PI / 180,
  Sc = 180 / Math.PI;
function vi() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Sr[t & 255] +
    Sr[(t >> 8) & 255] +
    Sr[(t >> 16) & 255] +
    Sr[(t >> 24) & 255] +
    "-" +
    Sr[e & 255] +
    Sr[(e >> 8) & 255] +
    "-" +
    Sr[((e >> 16) & 15) | 64] +
    Sr[(e >> 24) & 255] +
    "-" +
    Sr[(n & 63) | 128] +
    Sr[(n >> 8) & 255] +
    "-" +
    Sr[(n >> 16) & 255] +
    Sr[(n >> 24) & 255] +
    Sr[r & 255] +
    Sr[(r >> 8) & 255] +
    Sr[(r >> 16) & 255] +
    Sr[(r >> 24) & 255]
  ).toLowerCase();
}
function Mn(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function eM(t, e) {
  return ((t % e) + e) % e;
}
function mB(t, e, n, r, i) {
  return r + ((t - e) * (i - r)) / (n - e);
}
function gB(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0;
}
function ed(t, e, n) {
  return (1 - n) * t + n * e;
}
function vB(t, e, n, r) {
  return ed(t, e, 1 - Math.exp(-n * r));
}
function yB(t, e = 1) {
  return e - Math.abs(eM(t, e * 2) - e);
}
function xB(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
}
function _B(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * t * (t * (t * 6 - 15) + 10));
}
function SB(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function wB(t, e) {
  return t + Math.random() * (e - t);
}
function MB(t) {
  return t * (0.5 - Math.random());
}
function EB(t) {
  t !== void 0 && (dA = t);
  let e = (dA += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function bB(t) {
  return t * xl;
}
function TB(t) {
  return t * Sc;
}
function i1(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function AB(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function zg(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function CB(t, e, n, r, i) {
  const s = Math.cos,
    o = Math.sin,
    a = s(n / 2),
    l = o(n / 2),
    f = s((e + r) / 2),
    d = o((e + r) / 2),
    h = s((e - r) / 2),
    p = o((e - r) / 2),
    g = s((r - e) / 2),
    v = o((r - e) / 2);
  switch (i) {
    case "XYX":
      t.set(a * d, l * h, l * p, a * f);
      break;
    case "YZY":
      t.set(l * p, a * d, l * h, a * f);
      break;
    case "ZXZ":
      t.set(l * h, l * p, a * d, a * f);
      break;
    case "XZX":
      t.set(a * d, l * v, l * g, a * f);
      break;
    case "YXY":
      t.set(l * g, a * d, l * v, a * f);
      break;
    case "ZYZ":
      t.set(l * v, l * g, a * d, a * f);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Jr(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function St(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const RB = {
  DEG2RAD: xl,
  RAD2DEG: Sc,
  generateUUID: vi,
  clamp: Mn,
  euclideanModulo: eM,
  mapLinear: mB,
  inverseLerp: gB,
  lerp: ed,
  damp: vB,
  pingpong: yB,
  smoothstep: xB,
  smootherstep: _B,
  randInt: SB,
  randFloat: wB,
  randFloatSpread: MB,
  seededRandom: EB,
  degToRad: bB,
  radToDeg: TB,
  isPowerOfTwo: i1,
  ceilPowerOfTwo: AB,
  floorPowerOfTwo: zg,
  setQuaternionFromProperEuler: CB,
  normalize: St,
  denormalize: Jr,
};
class _e {
  constructor(e = 0, n = 0) {
    (_e.prototype.isVector2 = !0), (this.x = e), (this.y = n);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return (this.x = e), (this.y = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, n) {
    return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, n) {
    return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * n + i[3] * r + i[6]),
      (this.y = i[1] * n + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(Mn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y;
    return n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this;
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r), (this.y = e.y + (n.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), e;
  }
  fromBufferAttribute(e, n) {
    return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
  }
  rotateAround(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * r - o * i + e.x), (this.y = s * i + o * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Et {
  constructor(e, n, r, i, s, o, a, l, f) {
    (Et.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, s, o, a, l, f);
  }
  set(e, n, r, i, s, o, a, l, f) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[1] = i),
      (d[2] = a),
      (d[3] = n),
      (d[4] = s),
      (d[5] = l),
      (d[6] = r),
      (d[7] = o),
      (d[8] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      n.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return (
      this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      s = this.elements,
      o = r[0],
      a = r[3],
      l = r[6],
      f = r[1],
      d = r[4],
      h = r[7],
      p = r[2],
      g = r[5],
      v = r[8],
      _ = i[0],
      x = i[3],
      m = i[6],
      w = i[1],
      S = i[4],
      E = i[7],
      T = i[2],
      A = i[5],
      L = i[8];
    return (
      (s[0] = o * _ + a * w + l * T),
      (s[3] = o * x + a * S + l * A),
      (s[6] = o * m + a * E + l * L),
      (s[1] = f * _ + d * w + h * T),
      (s[4] = f * x + d * S + h * A),
      (s[7] = f * m + d * E + h * L),
      (s[2] = p * _ + g * w + v * T),
      (s[5] = p * x + g * S + v * A),
      (s[8] = p * m + g * E + v * L),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      (n[2] *= e),
      (n[5] *= e),
      (n[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      f = e[7],
      d = e[8];
    return (
      n * o * d - n * a * f - r * s * d + r * a * l + i * s * f - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      f = e[7],
      d = e[8],
      h = d * o - a * f,
      p = a * l - d * s,
      g = f * s - o * l,
      v = n * h + r * p + i * g;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / v;
    return (
      (e[0] = h * _),
      (e[1] = (i * f - d * r) * _),
      (e[2] = (a * r - i * o) * _),
      (e[3] = p * _),
      (e[4] = (d * n - i * l) * _),
      (e[5] = (i * s - a * n) * _),
      (e[6] = g * _),
      (e[7] = (r * l - f * n) * _),
      (e[8] = (o * n - r * s) * _),
      this
    );
  }
  transpose() {
    let e;
    const n = this.elements;
    return (
      (e = n[1]),
      (n[1] = n[3]),
      (n[3] = e),
      (e = n[2]),
      (n[2] = n[6]),
      (n[6] = e),
      (e = n[5]),
      (n[5] = n[7]),
      (n[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[3]),
      (e[2] = n[6]),
      (e[3] = n[1]),
      (e[4] = n[4]),
      (e[5] = n[7]),
      (e[6] = n[2]),
      (e[7] = n[5]),
      (e[8] = n[8]),
      this
    );
  }
  setUvTransform(e, n, r, i, s, o, a) {
    const l = Math.cos(s),
      f = Math.sin(s);
    return (
      this.set(
        r * l,
        r * f,
        -r * (l * o + f * a) + o + e,
        -i * f,
        i * l,
        -i * (-f * o + l * a) + a + n,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, n) {
    return this.premultiply(Mx.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(Mx.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(Mx.makeTranslation(e, n)), this;
  }
  makeTranslation(e, n) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this;
  }
  makeScale(e, n) {
    return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Mx = new Et();
function WI(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
const PB = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Yu(t, e) {
  return new PB[t](e);
}
function zd(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function GI() {
  const t = zd("canvas");
  return (t.style.display = "block"), t;
}
const hA = {};
function td(t) {
  t in hA || ((hA[t] = !0), console.warn(t));
}
const pA = new Et().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  mA = new Et().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Dp = {
    [zs]: {
      transfer: Dd,
      primaries: kd,
      toReference: (t) => t,
      fromReference: (t) => t,
    },
    [Wn]: {
      transfer: Jt,
      primaries: kd,
      toReference: (t) => t.convertSRGBToLinear(),
      fromReference: (t) => t.convertLinearToSRGB(),
    },
    [ih]: {
      transfer: Dd,
      primaries: Ud,
      toReference: (t) => t.applyMatrix3(mA),
      fromReference: (t) => t.applyMatrix3(pA),
    },
    [F0]: {
      transfer: Jt,
      primaries: Ud,
      toReference: (t) => t.convertSRGBToLinear().applyMatrix3(mA),
      fromReference: (t) => t.applyMatrix3(pA).convertLinearToSRGB(),
    },
  },
  LB = new Set([zs, ih]),
  Wt = {
    enabled: !0,
    _workingColorSpace: zs,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(t) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !t);
    },
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(t) {
      if (!LB.has(t))
        throw new Error(`Unsupported working color space, "${t}".`);
      this._workingColorSpace = t;
    },
    convert: function (t, e, n) {
      if (this.enabled === !1 || e === n || !e || !n) return t;
      const r = Dp[e].toReference,
        i = Dp[n].fromReference;
      return i(r(t));
    },
    fromWorkingColorSpace: function (t, e) {
      return this.convert(t, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (t, e) {
      return this.convert(t, e, this._workingColorSpace);
    },
    getPrimaries: function (t) {
      return Dp[t].primaries;
    },
    getTransfer: function (t) {
      return t === hi ? Dd : Dp[t].transfer;
    },
  };
function ac(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function Ex(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let iu;
class tM {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      iu === void 0 && (iu = zd("canvas")),
        (iu.width = e.width),
        (iu.height = e.height);
      const r = iu.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (n = iu);
    }
    return n.width > 2048 || n.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        n.toDataURL("image/jpeg", 0.6))
      : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const n = zd("canvas");
      (n.width = e.width), (n.height = e.height);
      const r = n.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let o = 0; o < s.length; o++) s[o] = ac(s[o] / 255) * 255;
      return r.putImageData(i, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let r = 0; r < n.length; r++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray
          ? (n[r] = Math.floor(ac(n[r] / 255) * 255))
          : (n[r] = ac(n[r]));
      return { data: n, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let IB = 0;
class dl {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: IB++ }),
      (this.uuid = vi()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? s.push(bx(i[o].image)) : s.push(bx(i[o]));
      } else s = bx(i);
      r.url = s;
    }
    return n || (e.images[this.uuid] = r), r;
  }
}
function bx(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? tM.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let NB = 0;
class Ln extends Ao {
  constructor(
    e = Ln.DEFAULT_IMAGE,
    n = Ln.DEFAULT_MAPPING,
    r = Cr,
    i = Cr,
    s = Rn,
    o = xa,
    a = zr,
    l = ks,
    f = Ln.DEFAULT_ANISOTROPY,
    d = hi
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: NB++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.source = new dl(e)),
      (this.mipmaps = []),
      (this.mapping = n),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = f),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new _e(0, 0)),
      (this.repeat = new _e(1, 1)),
      (this.center = new _e(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Et()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof d == "string"
        ? (this.colorSpace = d)
        : (td(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = d === fa ? Wn : hi)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      n || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== D0) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Pd:
          e.x = e.x - Math.floor(e.x);
          break;
        case Cr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Ld:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Pd:
          e.y = e.y - Math.floor(e.y);
          break;
        case Cr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Ld:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      td("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Wn ? fa : Jw
    );
  }
  set encoding(e) {
    td("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === fa ? Wn : hi);
  }
}
Ln.DEFAULT_IMAGE = null;
Ln.DEFAULT_MAPPING = D0;
Ln.DEFAULT_ANISOTROPY = 1;
class Gt {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (Gt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, r, i) {
    return (this.x = e), (this.y = n), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x),
      (this.y = e.y + n.y),
      (this.z = e.z + n.z),
      (this.w = e.w + n.w),
      this
    );
  }
  addScaledVector(e, n) {
    return (
      (this.x += e.x * n),
      (this.y += e.y * n),
      (this.z += e.z * n),
      (this.w += e.w * n),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x),
      (this.y = e.y - n.y),
      (this.z = e.z - n.z),
      (this.w = e.w - n.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[4] * r + o[8] * i + o[12] * s),
      (this.y = o[1] * n + o[5] * r + o[9] * i + o[13] * s),
      (this.z = o[2] * n + o[6] * r + o[10] * i + o[14] * s),
      (this.w = o[3] * n + o[7] * r + o[11] * i + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return (
      n < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / n), (this.y = e.y / n), (this.z = e.z / n)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, r, i, s;
    const l = e.elements,
      f = l[0],
      d = l[4],
      h = l[8],
      p = l[1],
      g = l[5],
      v = l[9],
      _ = l[2],
      x = l[6],
      m = l[10];
    if (
      Math.abs(d - p) < 0.01 &&
      Math.abs(h - _) < 0.01 &&
      Math.abs(v - x) < 0.01
    ) {
      if (
        Math.abs(d + p) < 0.1 &&
        Math.abs(h + _) < 0.1 &&
        Math.abs(v + x) < 0.1 &&
        Math.abs(f + g + m - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (f + 1) / 2,
        E = (g + 1) / 2,
        T = (m + 1) / 2,
        A = (d + p) / 4,
        L = (h + _) / 4,
        N = (v + x) / 4;
      return (
        S > E && S > T
          ? S < 0.01
            ? ((r = 0), (i = 0.707106781), (s = 0.707106781))
            : ((r = Math.sqrt(S)), (i = A / r), (s = L / r))
          : E > T
          ? E < 0.01
            ? ((r = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(E)), (r = A / i), (s = N / i))
          : T < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(T)), (r = L / s), (i = N / s)),
        this.set(r, i, s, n),
        this
      );
    }
    let w = Math.sqrt(
      (x - v) * (x - v) + (h - _) * (h - _) + (p - d) * (p - d)
    );
    return (
      Math.abs(w) < 0.001 && (w = 1),
      (this.x = (x - v) / w),
      (this.y = (h - _) / w),
      (this.z = (p - d) / w),
      (this.w = Math.acos((f + g + m - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      (this.w = Math.max(e.w, Math.min(n.w, this.w))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      (this.w = Math.max(e, Math.min(n, this.w))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      (this.w += (e.w - this.w) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      (this.w = e.w + (n.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return (
      (this.x = e[n]),
      (this.y = e[n + 1]),
      (this.z = e[n + 2]),
      (this.w = e[n + 3]),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this.x),
      (e[n + 1] = this.y),
      (e[n + 2] = this.z),
      (e[n + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)),
      (this.y = e.getY(n)),
      (this.z = e.getZ(n)),
      (this.w = e.getW(n)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class jI extends Ao {
  constructor(e = 1, n = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = n),
      (this.depth = 1),
      (this.scissor = new Gt(0, 0, e, n)),
      (this.scissorTest = !1),
      (this.viewport = new Gt(0, 0, e, n));
    const i = { width: e, height: n, depth: 1 };
    r.encoding !== void 0 &&
      (td(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (r.colorSpace = r.encoding === fa ? Wn : hi)),
      (r = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Rn,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        r
      )),
      (this.texture = new Ln(
        i,
        r.mapping,
        r.wrapS,
        r.wrapT,
        r.magFilter,
        r.minFilter,
        r.format,
        r.type,
        r.anisotropy,
        r.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = r.generateMipmaps),
      (this.texture.internalFormat = r.internalFormat),
      (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  setSize(e, n, r = 1) {
    (this.width !== e || this.height !== n || this.depth !== r) &&
      ((this.width = e),
      (this.height = n),
      (this.depth = r),
      (this.texture.image.width = e),
      (this.texture.image.height = n),
      (this.texture.image.depth = r),
      this.dispose()),
      this.viewport.set(0, 0, e, n),
      this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const n = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new dl(n)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class cs extends jI {
  constructor(e = 1, n = 1, r = {}) {
    super(e, n, r), (this.isWebGLRenderTarget = !0);
  }
}
class z0 extends Ln {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = An),
      (this.minFilter = An),
      (this.wrapR = Cr),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class OB extends cs {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new z0(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class nM extends Ln {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = An),
      (this.minFilter = An),
      (this.wrapR = Cr),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class DB extends cs {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new nM(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class kB extends cs {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < r; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, n, r = 1) {
    if (this.width !== e || this.height !== n || this.depth !== r) {
      (this.width = e), (this.height = n), (this.depth = r);
      for (let i = 0, s = this.texture.length; i < s; i++)
        (this.texture[i].image.width = e),
          (this.texture[i].image.height = n),
          (this.texture[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let n = 0, r = e.texture.length; n < r; n++)
      (this.texture[n] = e.texture[n].clone()),
        (this.texture[n].isRenderTargetTexture = !0);
    return this;
  }
}
class Rr {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, n, r, i, s, o, a) {
    let l = r[i + 0],
      f = r[i + 1],
      d = r[i + 2],
      h = r[i + 3];
    const p = s[o + 0],
      g = s[o + 1],
      v = s[o + 2],
      _ = s[o + 3];
    if (a === 0) {
      (e[n + 0] = l), (e[n + 1] = f), (e[n + 2] = d), (e[n + 3] = h);
      return;
    }
    if (a === 1) {
      (e[n + 0] = p), (e[n + 1] = g), (e[n + 2] = v), (e[n + 3] = _);
      return;
    }
    if (h !== _ || l !== p || f !== g || d !== v) {
      let x = 1 - a;
      const m = l * p + f * g + d * v + h * _,
        w = m >= 0 ? 1 : -1,
        S = 1 - m * m;
      if (S > Number.EPSILON) {
        const T = Math.sqrt(S),
          A = Math.atan2(T, m * w);
        (x = Math.sin(x * A) / T), (a = Math.sin(a * A) / T);
      }
      const E = a * w;
      if (
        ((l = l * x + p * E),
        (f = f * x + g * E),
        (d = d * x + v * E),
        (h = h * x + _ * E),
        x === 1 - a)
      ) {
        const T = 1 / Math.sqrt(l * l + f * f + d * d + h * h);
        (l *= T), (f *= T), (d *= T), (h *= T);
      }
    }
    (e[n] = l), (e[n + 1] = f), (e[n + 2] = d), (e[n + 3] = h);
  }
  static multiplyQuaternionsFlat(e, n, r, i, s, o) {
    const a = r[i],
      l = r[i + 1],
      f = r[i + 2],
      d = r[i + 3],
      h = s[o],
      p = s[o + 1],
      g = s[o + 2],
      v = s[o + 3];
    return (
      (e[n] = a * v + d * h + l * g - f * p),
      (e[n + 1] = l * v + d * p + f * h - a * g),
      (e[n + 2] = f * v + d * g + a * p - l * h),
      (e[n + 3] = d * v - a * h - l * p - f * g),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, n, r, i) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, n) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      f = a(r / 2),
      d = a(i / 2),
      h = a(s / 2),
      p = l(r / 2),
      g = l(i / 2),
      v = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * d * h + f * g * v),
          (this._y = f * g * h - p * d * v),
          (this._z = f * d * v + p * g * h),
          (this._w = f * d * h - p * g * v);
        break;
      case "YXZ":
        (this._x = p * d * h + f * g * v),
          (this._y = f * g * h - p * d * v),
          (this._z = f * d * v - p * g * h),
          (this._w = f * d * h + p * g * v);
        break;
      case "ZXY":
        (this._x = p * d * h - f * g * v),
          (this._y = f * g * h + p * d * v),
          (this._z = f * d * v + p * g * h),
          (this._w = f * d * h - p * g * v);
        break;
      case "ZYX":
        (this._x = p * d * h - f * g * v),
          (this._y = f * g * h + p * d * v),
          (this._z = f * d * v - p * g * h),
          (this._w = f * d * h + p * g * v);
        break;
      case "YZX":
        (this._x = p * d * h + f * g * v),
          (this._y = f * g * h + p * d * v),
          (this._z = f * d * v - p * g * h),
          (this._w = f * d * h - p * g * v);
        break;
      case "XZY":
        (this._x = p * d * h - f * g * v),
          (this._y = f * g * h - p * d * v),
          (this._z = f * d * v + p * g * h),
          (this._w = f * d * h + p * g * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return n !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const r = n / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const n = e.elements,
      r = n[0],
      i = n[4],
      s = n[8],
      o = n[1],
      a = n[5],
      l = n[9],
      f = n[2],
      d = n[6],
      h = n[10],
      p = r + a + h;
    if (p > 0) {
      const g = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / g),
        (this._x = (d - l) * g),
        (this._y = (s - f) * g),
        (this._z = (o - i) * g);
    } else if (r > a && r > h) {
      const g = 2 * Math.sqrt(1 + r - a - h);
      (this._w = (d - l) / g),
        (this._x = 0.25 * g),
        (this._y = (i + o) / g),
        (this._z = (s + f) / g);
    } else if (a > h) {
      const g = 2 * Math.sqrt(1 + a - r - h);
      (this._w = (s - f) / g),
        (this._x = (i + o) / g),
        (this._y = 0.25 * g),
        (this._z = (l + d) / g);
    } else {
      const g = 2 * Math.sqrt(1 + h - r - a);
      (this._w = (o - i) / g),
        (this._x = (s + f) / g),
        (this._y = (l + d) / g),
        (this._z = 0.25 * g);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let r = e.dot(n) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * n.z - e.z * n.y),
          (this._y = e.z * n.x - e.x * n.z),
          (this._z = e.x * n.y - e.y * n.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Mn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, n / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._w,
      a = n._x,
      l = n._y,
      f = n._z,
      d = n._w;
    return (
      (this._x = r * d + o * a + i * f - s * l),
      (this._y = i * d + o * l + s * a - r * f),
      (this._z = s * d + o * f + r * l - i * a),
      (this._w = o * d - r * a - i * l - s * f),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + r * e._x + i * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = r), (this._y = i), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const g = 1 - n;
      return (
        (this._w = g * o + n * this._w),
        (this._x = g * r + n * this._x),
        (this._y = g * i + n * this._y),
        (this._z = g * s + n * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const f = Math.sqrt(l),
      d = Math.atan2(f, a),
      h = Math.sin((1 - n) * d) / f,
      p = Math.sin(n * d) / f;
    return (
      (this._w = o * h + this._w * p),
      (this._x = r * h + this._x * p),
      (this._y = i * h + this._y * p),
      (this._z = s * h + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, n, r) {
    return this.copy(e).slerp(n, r);
  }
  random() {
    const e = Math.random(),
      n = Math.sqrt(1 - e),
      r = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      n * Math.cos(i),
      r * Math.sin(s),
      r * Math.cos(s),
      n * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, n = 0) {
    return (
      (this._x = e[n]),
      (this._y = e[n + 1]),
      (this._z = e[n + 2]),
      (this._w = e[n + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this._x = e.getX(n)),
      (this._y = e.getY(n)),
      (this._z = e.getZ(n)),
      (this._w = e.getW(n)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class z {
  constructor(e = 0, n = 0, r = 0) {
    (z.prototype.isVector3 = !0), (this.x = e), (this.y = n), (this.z = r);
  }
  set(e, n, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x), (this.y = e.y + n.y), (this.z = e.z + n.z), this
    );
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), (this.z += e.z * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x), (this.y = e.y - n.y), (this.z = e.z - n.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, n) {
    return (
      (this.x = e.x * n.x), (this.y = e.y * n.y), (this.z = e.z * n.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(gA.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(gA.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[3] * r + s[6] * i),
      (this.y = s[1] * n + s[4] * r + s[7] * i),
      (this.z = s[2] * n + s[5] * r + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      s = e.elements,
      o = 1 / (s[3] * n + s[7] * r + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * n + s[4] * r + s[8] * i + s[12]) * o),
      (this.y = (s[1] * n + s[5] * r + s[9] * i + s[13]) * o),
      (this.z = (s[2] * n + s[6] * r + s[10] * i + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      f = 2 * (o * i - a * r),
      d = 2 * (a * n - s * i),
      h = 2 * (s * r - o * n);
    return (
      (this.x = n + l * f + o * h - a * d),
      (this.y = r + l * d + a * f - s * h),
      (this.z = i + l * h + s * d - o * f),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[4] * r + s[8] * i),
      (this.y = s[1] * n + s[5] * r + s[9] * i),
      (this.z = s[2] * n + s[6] * r + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = n.x,
      a = n.y,
      l = n.z;
    return (
      (this.x = i * l - s * a),
      (this.y = s * o - r * l),
      (this.z = r * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / n;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return Tx.copy(this).projectOnVector(e), this.sub(Tx);
  }
  reflect(e) {
    return this.sub(Tx.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(Mn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return n * n + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, r) {
    const i = Math.sin(n) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(n) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, r) {
    return (
      (this.x = e * Math.sin(n)), (this.y = r), (this.z = e * Math.cos(n)), this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = n), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), (this.z = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), (e[n + 2] = this.z), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)), (this.y = e.getY(n)), (this.z = e.getZ(n)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      n = Math.random() * Math.PI * 2,
      r = Math.sqrt(1 - e ** 2);
    return (
      (this.x = r * Math.cos(n)), (this.y = r * Math.sin(n)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Tx = new z(),
  gA = new Rr();
class Vr {
  constructor(
    e = new z(1 / 0, 1 / 0, 1 / 0),
    n = new z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n += 3)
      this.expandByPoint(Ki.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, r = e.count; n < r; n++)
      this.expandByPoint(Ki.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = Ki.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const s = r.getAttribute("position");
      if (n === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Ki)
            : Ki.fromBufferAttribute(s, o),
            Ki.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Ki);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            kp.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            kp.copy(r.boundingBox)),
          kp.applyMatrix4(e.matrixWorld),
          this.union(kp);
    }
    const i = e.children;
    for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], n);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ki),
      Ki.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let n, r;
    return (
      e.normal.x > 0
        ? ((n = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((n = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((n += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((n += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((n += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((n += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      n <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(mf),
      Up.subVectors(this.max, mf),
      su.subVectors(e.a, mf),
      ou.subVectors(e.b, mf),
      au.subVectors(e.c, mf),
      Fo.subVectors(ou, su),
      zo.subVectors(au, ou),
      Fa.subVectors(su, au);
    let n = [
      0,
      -Fo.z,
      Fo.y,
      0,
      -zo.z,
      zo.y,
      0,
      -Fa.z,
      Fa.y,
      Fo.z,
      0,
      -Fo.x,
      zo.z,
      0,
      -zo.x,
      Fa.z,
      0,
      -Fa.x,
      -Fo.y,
      Fo.x,
      0,
      -zo.y,
      zo.x,
      0,
      -Fa.y,
      Fa.x,
      0,
    ];
    return !Ax(n, su, ou, au, Up) ||
      ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Ax(n, su, ou, au, Up))
      ? !1
      : (Fp.crossVectors(Fo, zo),
        (n = [Fp.x, Fp.y, Fp.z]),
        Ax(n, su, ou, au, Up));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ki).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ki).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ks[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ks[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ks[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ks[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ks[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ks[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ks[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ks[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ks),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ks = [
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
  ],
  Ki = new z(),
  kp = new Vr(),
  su = new z(),
  ou = new z(),
  au = new z(),
  Fo = new z(),
  zo = new z(),
  Fa = new z(),
  mf = new z(),
  Up = new z(),
  Fp = new z(),
  za = new z();
function Ax(t, e, n, r, i) {
  for (let s = 0, o = t.length - 3; s <= o; s += 3) {
    za.fromArray(t, s);
    const a =
        i.x * Math.abs(za.x) + i.y * Math.abs(za.y) + i.z * Math.abs(za.z),
      l = e.dot(za),
      f = n.dot(za),
      d = r.dot(za);
    if (Math.max(-Math.max(l, f, d), Math.min(l, f, d)) > a) return !1;
  }
  return !0;
}
const UB = new Vr(),
  gf = new z(),
  Cx = new z();
class Pr {
  constructor(e = new z(), n = -1) {
    (this.center = e), (this.radius = n);
  }
  set(e, n) {
    return this.center.copy(e), (this.radius = n), this;
  }
  setFromPoints(e, n) {
    const r = this.center;
    n !== void 0 ? r.copy(n) : UB.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, r.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const r = this.center.distanceToSquared(e);
    return (
      n.copy(e),
      r > this.radius * this.radius &&
        (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
      n
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    gf.subVectors(e, this.center);
    const n = gf.lengthSq();
    if (n > this.radius * this.radius) {
      const r = Math.sqrt(n),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(gf, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Cx.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(gf.copy(e.center).add(Cx)),
            this.expandByPoint(gf.copy(e.center).sub(Cx))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zs = new z(),
  Rx = new z(),
  zp = new z(),
  Bo = new z(),
  Px = new z(),
  Bp = new z(),
  Lx = new z();
class kl {
  constructor(e = new z(), n = new z(0, 0, -1)) {
    (this.origin = e), (this.direction = n);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Zs)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const r = n.dot(this.direction);
    return r < 0
      ? n.copy(this.origin)
      : n.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = Zs.subVectors(e, this.origin).dot(this.direction);
    return n < 0
      ? this.origin.distanceToSquared(e)
      : (Zs.copy(this.origin).addScaledVector(this.direction, n),
        Zs.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, r, i) {
    Rx.copy(e).add(n).multiplyScalar(0.5),
      zp.copy(n).sub(e).normalize(),
      Bo.copy(this.origin).sub(Rx);
    const s = e.distanceTo(n) * 0.5,
      o = -this.direction.dot(zp),
      a = Bo.dot(this.direction),
      l = -Bo.dot(zp),
      f = Bo.lengthSq(),
      d = Math.abs(1 - o * o);
    let h, p, g, v;
    if (d > 0)
      if (((h = o * l - a), (p = o * a - l), (v = s * d), h >= 0))
        if (p >= -v)
          if (p <= v) {
            const _ = 1 / d;
            (h *= _),
              (p *= _),
              (g = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + f);
          } else
            (p = s),
              (h = Math.max(0, -(o * p + a))),
              (g = -h * h + p * (p + 2 * l) + f);
        else
          (p = -s),
            (h = Math.max(0, -(o * p + a))),
            (g = -h * h + p * (p + 2 * l) + f);
      else
        p <= -v
          ? ((h = Math.max(0, -(-o * s + a))),
            (p = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (g = -h * h + p * (p + 2 * l) + f))
          : p <= v
          ? ((h = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (g = p * (p + 2 * l) + f))
          : ((h = Math.max(0, -(o * s + a))),
            (p = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (g = -h * h + p * (p + 2 * l) + f));
    else
      (p = o > 0 ? -s : s),
        (h = Math.max(0, -(o * p + a))),
        (g = -h * h + p * (p + 2 * l) + f);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, h),
      i && i.copy(Rx).addScaledVector(zp, p),
      g
    );
  }
  intersectSphere(e, n) {
    Zs.subVectors(e.center, this.origin);
    const r = Zs.dot(this.direction),
      i = Zs.dot(Zs) - r * r,
      s = e.radius * e.radius;
    if (i > s) return null;
    const o = Math.sqrt(s - i),
      a = r - o,
      l = r + o;
    return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / n;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, n) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let r, i, s, o, a, l;
    const f = 1 / this.direction.x,
      d = 1 / this.direction.y,
      h = 1 / this.direction.z,
      p = this.origin;
    return (
      f >= 0
        ? ((r = (e.min.x - p.x) * f), (i = (e.max.x - p.x) * f))
        : ((r = (e.max.x - p.x) * f), (i = (e.min.x - p.x) * f)),
      d >= 0
        ? ((s = (e.min.y - p.y) * d), (o = (e.max.y - p.y) * d))
        : ((s = (e.max.y - p.y) * d), (o = (e.min.y - p.y) * d)),
      r > o ||
      s > i ||
      ((s > r || isNaN(r)) && (r = s),
      (o < i || isNaN(i)) && (i = o),
      h >= 0
        ? ((a = (e.min.z - p.z) * h), (l = (e.max.z - p.z) * h))
        : ((a = (e.max.z - p.z) * h), (l = (e.min.z - p.z) * h)),
      r > l || a > i) ||
      ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, n)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Zs) !== null;
  }
  intersectTriangle(e, n, r, i, s) {
    Px.subVectors(n, e), Bp.subVectors(r, e), Lx.crossVectors(Px, Bp);
    let o = this.direction.dot(Lx),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    Bo.subVectors(this.origin, e);
    const l = a * this.direction.dot(Bp.crossVectors(Bo, Bp));
    if (l < 0) return null;
    const f = a * this.direction.dot(Px.cross(Bo));
    if (f < 0 || l + f > o) return null;
    const d = -a * Bo.dot(Lx);
    return d < 0 ? null : this.at(d / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ht {
  constructor(e, n, r, i, s, o, a, l, f, d, h, p, g, v, _, x) {
    (ht.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, s, o, a, l, f, d, h, p, g, v, _, x);
  }
  set(e, n, r, i, s, o, a, l, f, d, h, p, g, v, _, x) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[4] = n),
      (m[8] = r),
      (m[12] = i),
      (m[1] = s),
      (m[5] = o),
      (m[9] = a),
      (m[13] = l),
      (m[2] = f),
      (m[6] = d),
      (m[10] = h),
      (m[14] = p),
      (m[3] = g),
      (m[7] = v),
      (m[11] = _),
      (m[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new ht().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      (n[9] = r[9]),
      (n[10] = r[10]),
      (n[11] = r[11]),
      (n[12] = r[12]),
      (n[13] = r[13]),
      (n[14] = r[14]),
      (n[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const n = this.elements,
      r = e.elements;
    return (n[12] = r[12]), (n[13] = r[13]), (n[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return (
      this.set(
        n[0],
        n[3],
        n[6],
        0,
        n[1],
        n[4],
        n[7],
        0,
        n[2],
        n[5],
        n[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      n.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, n, r) {
    return (
      this.set(
        e.x,
        n.x,
        r.x,
        0,
        e.y,
        n.y,
        r.y,
        0,
        e.z,
        n.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const n = this.elements,
      r = e.elements,
      i = 1 / lu.setFromMatrixColumn(e, 0).length(),
      s = 1 / lu.setFromMatrixColumn(e, 1).length(),
      o = 1 / lu.setFromMatrixColumn(e, 2).length();
    return (
      (n[0] = r[0] * i),
      (n[1] = r[1] * i),
      (n[2] = r[2] * i),
      (n[3] = 0),
      (n[4] = r[4] * s),
      (n[5] = r[5] * s),
      (n[6] = r[6] * s),
      (n[7] = 0),
      (n[8] = r[8] * o),
      (n[9] = r[9] * o),
      (n[10] = r[10] * o),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      s = e.z,
      o = Math.cos(r),
      a = Math.sin(r),
      l = Math.cos(i),
      f = Math.sin(i),
      d = Math.cos(s),
      h = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * d,
        g = o * h,
        v = a * d,
        _ = a * h;
      (n[0] = l * d),
        (n[4] = -l * h),
        (n[8] = f),
        (n[1] = g + v * f),
        (n[5] = p - _ * f),
        (n[9] = -a * l),
        (n[2] = _ - p * f),
        (n[6] = v + g * f),
        (n[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * d,
        g = l * h,
        v = f * d,
        _ = f * h;
      (n[0] = p + _ * a),
        (n[4] = v * a - g),
        (n[8] = o * f),
        (n[1] = o * h),
        (n[5] = o * d),
        (n[9] = -a),
        (n[2] = g * a - v),
        (n[6] = _ + p * a),
        (n[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * d,
        g = l * h,
        v = f * d,
        _ = f * h;
      (n[0] = p - _ * a),
        (n[4] = -o * h),
        (n[8] = v + g * a),
        (n[1] = g + v * a),
        (n[5] = o * d),
        (n[9] = _ - p * a),
        (n[2] = -o * f),
        (n[6] = a),
        (n[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * d,
        g = o * h,
        v = a * d,
        _ = a * h;
      (n[0] = l * d),
        (n[4] = v * f - g),
        (n[8] = p * f + _),
        (n[1] = l * h),
        (n[5] = _ * f + p),
        (n[9] = g * f - v),
        (n[2] = -f),
        (n[6] = a * l),
        (n[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        g = o * f,
        v = a * l,
        _ = a * f;
      (n[0] = l * d),
        (n[4] = _ - p * h),
        (n[8] = v * h + g),
        (n[1] = h),
        (n[5] = o * d),
        (n[9] = -a * d),
        (n[2] = -f * d),
        (n[6] = g * h + v),
        (n[10] = p - _ * h);
    } else if (e.order === "XZY") {
      const p = o * l,
        g = o * f,
        v = a * l,
        _ = a * f;
      (n[0] = l * d),
        (n[4] = -h),
        (n[8] = f * d),
        (n[1] = p * h + _),
        (n[5] = o * d),
        (n[9] = g * h - v),
        (n[2] = v * h - g),
        (n[6] = a * d),
        (n[10] = _ * h + p);
    }
    return (
      (n[3] = 0),
      (n[7] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(FB, e, zB);
  }
  lookAt(e, n, r) {
    const i = this.elements;
    return (
      ci.subVectors(e, n),
      ci.lengthSq() === 0 && (ci.z = 1),
      ci.normalize(),
      Ho.crossVectors(r, ci),
      Ho.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (ci.x += 1e-4) : (ci.z += 1e-4),
        ci.normalize(),
        Ho.crossVectors(r, ci)),
      Ho.normalize(),
      Hp.crossVectors(ci, Ho),
      (i[0] = Ho.x),
      (i[4] = Hp.x),
      (i[8] = ci.x),
      (i[1] = Ho.y),
      (i[5] = Hp.y),
      (i[9] = ci.y),
      (i[2] = Ho.z),
      (i[6] = Hp.z),
      (i[10] = ci.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      s = this.elements,
      o = r[0],
      a = r[4],
      l = r[8],
      f = r[12],
      d = r[1],
      h = r[5],
      p = r[9],
      g = r[13],
      v = r[2],
      _ = r[6],
      x = r[10],
      m = r[14],
      w = r[3],
      S = r[7],
      E = r[11],
      T = r[15],
      A = i[0],
      L = i[4],
      N = i[8],
      C = i[12],
      I = i[1],
      k = i[5],
      R = i[9],
      $ = i[13],
      D = i[2],
      W = i[6],
      Y = i[10],
      Z = i[14],
      B = i[3],
      G = i[7],
      X = i[11],
      te = i[15];
    return (
      (s[0] = o * A + a * I + l * D + f * B),
      (s[4] = o * L + a * k + l * W + f * G),
      (s[8] = o * N + a * R + l * Y + f * X),
      (s[12] = o * C + a * $ + l * Z + f * te),
      (s[1] = d * A + h * I + p * D + g * B),
      (s[5] = d * L + h * k + p * W + g * G),
      (s[9] = d * N + h * R + p * Y + g * X),
      (s[13] = d * C + h * $ + p * Z + g * te),
      (s[2] = v * A + _ * I + x * D + m * B),
      (s[6] = v * L + _ * k + x * W + m * G),
      (s[10] = v * N + _ * R + x * Y + m * X),
      (s[14] = v * C + _ * $ + x * Z + m * te),
      (s[3] = w * A + S * I + E * D + T * B),
      (s[7] = w * L + S * k + E * W + T * G),
      (s[11] = w * N + S * R + E * Y + T * X),
      (s[15] = w * C + S * $ + E * Z + T * te),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[4] *= e),
      (n[8] *= e),
      (n[12] *= e),
      (n[1] *= e),
      (n[5] *= e),
      (n[9] *= e),
      (n[13] *= e),
      (n[2] *= e),
      (n[6] *= e),
      (n[10] *= e),
      (n[14] *= e),
      (n[3] *= e),
      (n[7] *= e),
      (n[11] *= e),
      (n[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[4],
      i = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      f = e[13],
      d = e[2],
      h = e[6],
      p = e[10],
      g = e[14],
      v = e[3],
      _ = e[7],
      x = e[11],
      m = e[15];
    return (
      v *
        (+s * l * h -
          i * f * h -
          s * a * p +
          r * f * p +
          i * a * g -
          r * l * g) +
      _ *
        (+n * l * g -
          n * f * p +
          s * o * p -
          i * o * g +
          i * f * d -
          s * l * d) +
      x *
        (+n * f * h -
          n * a * g -
          s * o * h +
          r * o * g +
          s * a * d -
          r * f * d) +
      m *
        (-i * a * d - n * l * h + n * a * p + i * o * h - r * o * p + r * l * d)
    );
  }
  transpose() {
    const e = this.elements;
    let n;
    return (
      (n = e[1]),
      (e[1] = e[4]),
      (e[4] = n),
      (n = e[2]),
      (e[2] = e[8]),
      (e[8] = n),
      (n = e[6]),
      (e[6] = e[9]),
      (e[9] = n),
      (n = e[3]),
      (e[3] = e[12]),
      (e[12] = n),
      (n = e[7]),
      (e[7] = e[13]),
      (e[13] = n),
      (n = e[11]),
      (e[11] = e[14]),
      (e[14] = n),
      this
    );
  }
  setPosition(e, n, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = n), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      f = e[7],
      d = e[8],
      h = e[9],
      p = e[10],
      g = e[11],
      v = e[12],
      _ = e[13],
      x = e[14],
      m = e[15],
      w = h * x * f - _ * p * f + _ * l * g - a * x * g - h * l * m + a * p * m,
      S = v * p * f - d * x * f - v * l * g + o * x * g + d * l * m - o * p * m,
      E = d * _ * f - v * h * f + v * a * g - o * _ * g - d * a * m + o * h * m,
      T = v * h * l - d * _ * l - v * a * p + o * _ * p + d * a * x - o * h * x,
      A = n * w + r * S + i * E + s * T;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / A;
    return (
      (e[0] = w * L),
      (e[1] =
        (_ * p * s -
          h * x * s -
          _ * i * g +
          r * x * g +
          h * i * m -
          r * p * m) *
        L),
      (e[2] =
        (a * x * s -
          _ * l * s +
          _ * i * f -
          r * x * f -
          a * i * m +
          r * l * m) *
        L),
      (e[3] =
        (h * l * s -
          a * p * s -
          h * i * f +
          r * p * f +
          a * i * g -
          r * l * g) *
        L),
      (e[4] = S * L),
      (e[5] =
        (d * x * s -
          v * p * s +
          v * i * g -
          n * x * g -
          d * i * m +
          n * p * m) *
        L),
      (e[6] =
        (v * l * s -
          o * x * s -
          v * i * f +
          n * x * f +
          o * i * m -
          n * l * m) *
        L),
      (e[7] =
        (o * p * s -
          d * l * s +
          d * i * f -
          n * p * f -
          o * i * g +
          n * l * g) *
        L),
      (e[8] = E * L),
      (e[9] =
        (v * h * s -
          d * _ * s -
          v * r * g +
          n * _ * g +
          d * r * m -
          n * h * m) *
        L),
      (e[10] =
        (o * _ * s -
          v * a * s +
          v * r * f -
          n * _ * f -
          o * r * m +
          n * a * m) *
        L),
      (e[11] =
        (d * a * s -
          o * h * s -
          d * r * f +
          n * h * f +
          o * r * g -
          n * a * g) *
        L),
      (e[12] = T * L),
      (e[13] =
        (d * _ * i -
          v * h * i +
          v * r * p -
          n * _ * p -
          d * r * x +
          n * h * x) *
        L),
      (e[14] =
        (v * a * i -
          o * _ * i -
          v * r * l +
          n * _ * l +
          o * r * x -
          n * a * x) *
        L),
      (e[15] =
        (o * h * i -
          d * a * i +
          d * r * l -
          n * h * l -
          o * r * p +
          n * a * p) *
        L),
      this
    );
  }
  scale(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      s = e.z;
    return (
      (n[0] *= r),
      (n[4] *= i),
      (n[8] *= s),
      (n[1] *= r),
      (n[5] *= i),
      (n[9] *= s),
      (n[2] *= r),
      (n[6] *= i),
      (n[10] *= s),
      (n[3] *= r),
      (n[7] *= i),
      (n[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, r, i));
  }
  makeTranslation(e, n, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      s = 1 - r,
      o = e.x,
      a = e.y,
      l = e.z,
      f = s * o,
      d = s * a;
    return (
      this.set(
        f * o + r,
        f * a - i * l,
        f * l + i * a,
        0,
        f * a + i * l,
        d * a + r,
        d * l - i * o,
        0,
        f * l - i * a,
        d * l + i * o,
        s * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, n, r) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, r, i, s, o) {
    return this.set(1, r, s, 0, e, 1, o, 0, n, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, r) {
    const i = this.elements,
      s = n._x,
      o = n._y,
      a = n._z,
      l = n._w,
      f = s + s,
      d = o + o,
      h = a + a,
      p = s * f,
      g = s * d,
      v = s * h,
      _ = o * d,
      x = o * h,
      m = a * h,
      w = l * f,
      S = l * d,
      E = l * h,
      T = r.x,
      A = r.y,
      L = r.z;
    return (
      (i[0] = (1 - (_ + m)) * T),
      (i[1] = (g + E) * T),
      (i[2] = (v - S) * T),
      (i[3] = 0),
      (i[4] = (g - E) * A),
      (i[5] = (1 - (p + m)) * A),
      (i[6] = (x + w) * A),
      (i[7] = 0),
      (i[8] = (v + S) * L),
      (i[9] = (x - w) * L),
      (i[10] = (1 - (p + _)) * L),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, n, r) {
    const i = this.elements;
    let s = lu.set(i[0], i[1], i[2]).length();
    const o = lu.set(i[4], i[5], i[6]).length(),
      a = lu.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Zi.copy(this);
    const f = 1 / s,
      d = 1 / o,
      h = 1 / a;
    return (
      (Zi.elements[0] *= f),
      (Zi.elements[1] *= f),
      (Zi.elements[2] *= f),
      (Zi.elements[4] *= d),
      (Zi.elements[5] *= d),
      (Zi.elements[6] *= d),
      (Zi.elements[8] *= h),
      (Zi.elements[9] *= h),
      (Zi.elements[10] *= h),
      n.setFromRotationMatrix(Zi),
      (r.x = s),
      (r.y = o),
      (r.z = a),
      this
    );
  }
  makePerspective(e, n, r, i, s, o, a = os) {
    const l = this.elements,
      f = (2 * s) / (n - e),
      d = (2 * s) / (r - i),
      h = (n + e) / (n - e),
      p = (r + i) / (r - i);
    let g, v;
    if (a === os) (g = -(o + s) / (o - s)), (v = (-2 * o * s) / (o - s));
    else if (a === _c) (g = -o / (o - s)), (v = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = f),
      (l[4] = 0),
      (l[8] = h),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = d),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, n, r, i, s, o, a = os) {
    const l = this.elements,
      f = 1 / (n - e),
      d = 1 / (r - i),
      h = 1 / (o - s),
      p = (n + e) * f,
      g = (r + i) * d;
    let v, _;
    if (a === os) (v = (o + s) * h), (_ = -2 * h);
    else if (a === _c) (v = s * h), (_ = -1 * h);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * f),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * d),
      (l[9] = 0),
      (l[13] = -g),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = _),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      (e[n + 9] = r[9]),
      (e[n + 10] = r[10]),
      (e[n + 11] = r[11]),
      (e[n + 12] = r[12]),
      (e[n + 13] = r[13]),
      (e[n + 14] = r[14]),
      (e[n + 15] = r[15]),
      e
    );
  }
}
const lu = new z(),
  Zi = new ht(),
  FB = new z(0, 0, 0),
  zB = new z(1, 1, 1),
  Ho = new z(),
  Hp = new z(),
  ci = new z(),
  vA = new ht(),
  yA = new Rr();
class sh {
  constructor(e = 0, n = 0, r = 0, i = sh.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, n, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, n = this._order, r = !0) {
    const i = e.elements,
      s = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      f = i[5],
      d = i[9],
      h = i[2],
      p = i[6],
      g = i[10];
    switch (n) {
      case "XYZ":
        (this._y = Math.asin(Mn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-d, g)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, f)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Mn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(a, g)), (this._z = Math.atan2(l, f)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Mn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-h, g)), (this._z = Math.atan2(-o, f)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Mn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(p, g)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, f)));
        break;
      case "YZX":
        (this._z = Math.asin(Mn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-d, f)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, g)));
        break;
      case "XZY":
        (this._z = Math.asin(-Mn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, f)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-d, g)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            n
        );
    }
    return (this._order = n), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, r) {
    return (
      vA.makeRotationFromQuaternion(e), this.setFromRotationMatrix(vA, n, r)
    );
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return yA.setFromEuler(this), this.setFromQuaternion(yA, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
sh.DEFAULT_ORDER = "XYZ";
class _l {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let BB = 0;
const xA = new z(),
  uu = new Rr(),
  Js = new ht(),
  Vp = new z(),
  vf = new z(),
  HB = new z(),
  VB = new Rr(),
  _A = new z(1, 0, 0),
  SA = new z(0, 1, 0),
  wA = new z(0, 0, 1),
  WB = { type: "added" },
  GB = { type: "removed" };
class Ft extends Ao {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: BB++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ft.DEFAULT_UP.clone());
    const e = new z(),
      n = new sh(),
      r = new Rr(),
      i = new z(1, 1, 1);
    function s() {
      r.setFromEuler(n, !1);
    }
    function o() {
      n.setFromQuaternion(r, void 0, !1);
    }
    n._onChange(s),
      r._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: n },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new ht() },
        normalMatrix: { value: new Et() },
      }),
      (this.matrix = new ht()),
      (this.matrixWorld = new ht()),
      (this.matrixAutoUpdate = Ft.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new _l()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return uu.setFromAxisAngle(e, n), this.quaternion.multiply(uu), this;
  }
  rotateOnWorldAxis(e, n) {
    return uu.setFromAxisAngle(e, n), this.quaternion.premultiply(uu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_A, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(SA, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(wA, e);
  }
  translateOnAxis(e, n) {
    return (
      xA.copy(e).applyQuaternion(this.quaternion),
      this.position.add(xA.multiplyScalar(n)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(_A, e);
  }
  translateY(e) {
    return this.translateOnAxis(SA, e);
  }
  translateZ(e) {
    return this.translateOnAxis(wA, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Js.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, n, r) {
    e.isVector3 ? Vp.copy(e) : Vp.set(e, n, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      vf.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Js.lookAt(vf, Vp, this.up)
        : Js.lookAt(Vp, vf, this.up),
      this.quaternion.setFromRotationMatrix(Js),
      i &&
        (Js.extractRotation(i.matrixWorld),
        uu.setFromRotationMatrix(Js),
        this.quaternion.premultiply(uu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(WB))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const n = this.children.indexOf(e);
    return (
      n !== -1 &&
        ((e.parent = null), this.children.splice(n, 1), e.dispatchEvent(GB)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Js.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Js.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Js),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const o = this.children[r].getObjectByProperty(e, n);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, n, r = []) {
    this[e] === n && r.push(this);
    const i = this.children;
    for (let s = 0, o = i.length; s < o; s++)
      i[s].getObjectsByProperty(e, n, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vf, e, HB), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vf, VB, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, n) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      n === !0)
    ) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++) {
        const a = i[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string",
      r = {};
    n &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (i.maxGeometryCount = this._maxGeometryCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let f = 0, d = l.length; f < d; f++) {
            const h = l[f];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, f = this.material.length; l < f; l++)
          a.push(s(e.materials, this.material[l]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(s(e.animations, l));
      }
    }
    if (n) {
      const a = o(e.geometries),
        l = o(e.materials),
        f = o(e.textures),
        d = o(e.images),
        h = o(e.shapes),
        p = o(e.skeletons),
        g = o(e.animations),
        v = o(e.nodes);
      a.length > 0 && (r.geometries = a),
        l.length > 0 && (r.materials = l),
        f.length > 0 && (r.textures = f),
        d.length > 0 && (r.images = d),
        h.length > 0 && (r.shapes = h),
        p.length > 0 && (r.skeletons = p),
        g.length > 0 && (r.animations = g),
        v.length > 0 && (r.nodes = v);
    }
    return (r.object = i), r;
    function o(a) {
      const l = [];
      for (const f in a) {
        const d = a[f];
        delete d.metadata, l.push(d);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      n === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Ft.DEFAULT_UP = new z(0, 1, 0);
Ft.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ji = new z(),
  Qs = new z(),
  Ix = new z(),
  eo = new z(),
  cu = new z(),
  fu = new z(),
  MA = new z(),
  Nx = new z(),
  Ox = new z(),
  Dx = new z();
let Wp = !1;
class Zr {
  constructor(e = new z(), n = new z(), r = new z()) {
    (this.a = e), (this.b = n), (this.c = r);
  }
  static getNormal(e, n, r, i) {
    i.subVectors(r, n), Ji.subVectors(e, n), i.cross(Ji);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, n, r, i, s) {
    Ji.subVectors(i, n), Qs.subVectors(r, n), Ix.subVectors(e, n);
    const o = Ji.dot(Ji),
      a = Ji.dot(Qs),
      l = Ji.dot(Ix),
      f = Qs.dot(Qs),
      d = Qs.dot(Ix),
      h = o * f - a * a;
    if (h === 0) return s.set(-2, -1, -1);
    const p = 1 / h,
      g = (f * l - a * d) * p,
      v = (o * d - a * l) * p;
    return s.set(1 - g - v, v, g);
  }
  static containsPoint(e, n, r, i) {
    return (
      this.getBarycoord(e, n, r, i, eo),
      eo.x >= 0 && eo.y >= 0 && eo.x + eo.y <= 1
    );
  }
  static getUV(e, n, r, i, s, o, a, l) {
    return (
      Wp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Wp = !0)),
      this.getInterpolation(e, n, r, i, s, o, a, l)
    );
  }
  static getInterpolation(e, n, r, i, s, o, a, l) {
    return (
      this.getBarycoord(e, n, r, i, eo),
      l.setScalar(0),
      l.addScaledVector(s, eo.x),
      l.addScaledVector(o, eo.y),
      l.addScaledVector(a, eo.z),
      l
    );
  }
  static isFrontFacing(e, n, r, i) {
    return Ji.subVectors(r, n), Qs.subVectors(e, n), Ji.cross(Qs).dot(i) < 0;
  }
  set(e, n, r) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, n, r, i) {
    return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, n, r, i) {
    return (
      this.a.fromBufferAttribute(e, n),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Ji.subVectors(this.c, this.b),
      Qs.subVectors(this.a, this.b),
      Ji.cross(Qs).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Zr.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Zr.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getUV(e, n, r, i, s) {
    return (
      Wp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Wp = !0)),
      Zr.getInterpolation(e, this.a, this.b, this.c, n, r, i, s)
    );
  }
  getInterpolation(e, n, r, i, s) {
    return Zr.getInterpolation(e, this.a, this.b, this.c, n, r, i, s);
  }
  containsPoint(e) {
    return Zr.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Zr.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const r = this.a,
      i = this.b,
      s = this.c;
    let o, a;
    cu.subVectors(i, r), fu.subVectors(s, r), Nx.subVectors(e, r);
    const l = cu.dot(Nx),
      f = fu.dot(Nx);
    if (l <= 0 && f <= 0) return n.copy(r);
    Ox.subVectors(e, i);
    const d = cu.dot(Ox),
      h = fu.dot(Ox);
    if (d >= 0 && h <= d) return n.copy(i);
    const p = l * h - d * f;
    if (p <= 0 && l >= 0 && d <= 0)
      return (o = l / (l - d)), n.copy(r).addScaledVector(cu, o);
    Dx.subVectors(e, s);
    const g = cu.dot(Dx),
      v = fu.dot(Dx);
    if (v >= 0 && g <= v) return n.copy(s);
    const _ = g * f - l * v;
    if (_ <= 0 && f >= 0 && v <= 0)
      return (a = f / (f - v)), n.copy(r).addScaledVector(fu, a);
    const x = d * v - g * h;
    if (x <= 0 && h - d >= 0 && g - v >= 0)
      return (
        MA.subVectors(s, i),
        (a = (h - d) / (h - d + (g - v))),
        n.copy(i).addScaledVector(MA, a)
      );
    const m = 1 / (x + _ + p);
    return (
      (o = _ * m),
      (a = p * m),
      n.copy(r).addScaledVector(cu, o).addScaledVector(fu, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const $I = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Vo = { h: 0, s: 0, l: 0 },
  Gp = { h: 0, s: 0, l: 0 };
function kx(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
class qe {
  constructor(e, n, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, n, r)
    );
  }
  set(e, n, r) {
    if (n === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, n, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, n = Wn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Wt.toWorkingColorSpace(this, n),
      this
    );
  }
  setRGB(e, n, r, i = Wt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = n),
      (this.b = r),
      Wt.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, n, r, i = Wt.workingColorSpace) {
    if (((e = eM(e, 1)), (n = Mn(n, 0, 1)), (r = Mn(r, 0, 1)), n === 0))
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + n) : r + n - r * n,
        o = 2 * r - s;
      (this.r = kx(o, s, e + 1 / 3)),
        (this.g = kx(o, s, e)),
        (this.b = kx(o, s, e - 1 / 3));
    }
    return Wt.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, n = Wn) {
    function r(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = i[1],
        a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                n
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                n
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                n
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          n
        );
      if (o === 6) return this.setHex(parseInt(s, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = Wn) {
    const r = $I[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, n)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ac(e.r)), (this.g = ac(e.g)), (this.b = ac(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Ex(e.r)), (this.g = Ex(e.g)), (this.b = Ex(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Wn) {
    return (
      Wt.fromWorkingColorSpace(wr.copy(this), e),
      Math.round(Mn(wr.r * 255, 0, 255)) * 65536 +
        Math.round(Mn(wr.g * 255, 0, 255)) * 256 +
        Math.round(Mn(wr.b * 255, 0, 255))
    );
  }
  getHexString(e = Wn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = Wt.workingColorSpace) {
    Wt.fromWorkingColorSpace(wr.copy(this), n);
    const r = wr.r,
      i = wr.g,
      s = wr.b,
      o = Math.max(r, i, s),
      a = Math.min(r, i, s);
    let l, f;
    const d = (a + o) / 2;
    if (a === o) (l = 0), (f = 0);
    else {
      const h = o - a;
      switch (((f = d <= 0.5 ? h / (o + a) : h / (2 - o - a)), o)) {
        case r:
          l = (i - s) / h + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - r) / h + 2;
          break;
        case s:
          l = (r - i) / h + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = f), (e.l = d), e;
  }
  getRGB(e, n = Wt.workingColorSpace) {
    return (
      Wt.fromWorkingColorSpace(wr.copy(this), n),
      (e.r = wr.r),
      (e.g = wr.g),
      (e.b = wr.b),
      e
    );
  }
  getStyle(e = Wn) {
    Wt.fromWorkingColorSpace(wr.copy(this), e);
    const n = wr.r,
      r = wr.g,
      i = wr.b;
    return e !== Wn
      ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, n, r) {
    return this.getHSL(Vo), this.setHSL(Vo.h + e, Vo.s + n, Vo.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, n) {
    return (
      (this.r = e.r + n.r), (this.g = e.g + n.g), (this.b = e.b + n.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, n) {
    return (
      (this.r += (e.r - this.r) * n),
      (this.g += (e.g - this.g) * n),
      (this.b += (e.b - this.b) * n),
      this
    );
  }
  lerpColors(e, n, r) {
    return (
      (this.r = e.r + (n.r - e.r) * r),
      (this.g = e.g + (n.g - e.g) * r),
      (this.b = e.b + (n.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, n) {
    this.getHSL(Vo), e.getHSL(Gp);
    const r = ed(Vo.h, Gp.h, n),
      i = ed(Vo.s, Gp.s, n),
      s = ed(Vo.l, Gp.l, n);
    return this.setHSL(r, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const n = this.r,
      r = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * n + s[3] * r + s[6] * i),
      (this.g = s[1] * n + s[4] * r + s[7] * i),
      (this.b = s[2] * n + s[5] * r + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return (this.r = e[n]), (this.g = e[n + 1]), (this.b = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.r), (e[n + 1] = this.g), (e[n + 2] = this.b), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.r = e.getX(n)), (this.g = e.getY(n)), (this.b = e.getZ(n)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const wr = new qe();
qe.NAMES = $I;
let jB = 0;
class Nr extends Ao {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: jB++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = yl),
      (this.side = _o),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Dg),
      (this.blendDst = kg),
      (this.blendEquation = Ko),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new qe(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Ad),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = n1),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = tl),
      (this.stencilZFail = tl),
      (this.stencilZPass = tl),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const r = e[n];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${n}' has value of undefined.`
          );
          continue;
        }
        const i = this[n];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[n] = r);
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== yl && (r.blending = this.blending),
      this.side !== _o && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== Dg && (r.blendSrc = this.blendSrc),
      this.blendDst !== kg && (r.blendDst = this.blendDst),
      this.blendEquation !== Ko && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== Ad && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== n1 && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== tl && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== tl && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== tl && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (n) {
      const s = i(e.textures),
        o = i(e.images);
      s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const n = e.clippingPlanes;
    let r = null;
    if (n !== null) {
      const i = n.length;
      r = new Array(i);
      for (let s = 0; s !== i; ++s) r[s] = n[s].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Ta extends Nr {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = rh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const lo = $B();
function $B() {
  const t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const f = l - 127;
    f < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : f < -14
      ? ((r[l] = 1024 >> (-f - 14)),
        (r[l | 256] = (1024 >> (-f - 14)) | 32768),
        (i[l] = -f - 1),
        (i[l | 256] = -f - 1))
      : f <= 15
      ? ((r[l] = (f + 15) << 10),
        (r[l | 256] = ((f + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : f < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let f = l << 13,
      d = 0;
    for (; !(f & 8388608); ) (f <<= 1), (d -= 8388608);
    (f &= -8388609), (d += 947912704), (s[l] = f | d);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function qr(t) {
  Math.abs(t) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (t = Mn(t, -65504, 65504)),
    (lo.floatView[0] = t);
  const e = lo.uint32View[0],
    n = (e >> 23) & 511;
  return lo.baseTable[n] + ((e & 8388607) >> lo.shiftTable[n]);
}
function Ff(t) {
  const e = t >> 10;
  return (
    (lo.uint32View[0] =
      lo.mantissaTable[lo.offsetTable[e] + (t & 1023)] + lo.exponentTable[e]),
    lo.floatView[0]
  );
}
const XB = { toHalfFloat: qr, fromHalfFloat: Ff },
  kn = new z(),
  jp = new _e();
class $t {
  constructor(e, n, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.normalized = r),
      (this.usage = Fd),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = ss),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        'THREE.BufferAttribute: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.itemSize), (r *= n.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, r = this.count; n < r; n++)
        jp.fromBufferAttribute(this, n),
          jp.applyMatrix3(e),
          this.setXY(n, jp.x, jp.y);
    else if (this.itemSize === 3)
      for (let n = 0, r = this.count; n < r; n++)
        kn.fromBufferAttribute(this, n),
          kn.applyMatrix3(e),
          this.setXYZ(n, kn.x, kn.y, kn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.count; n < r; n++)
      kn.fromBufferAttribute(this, n),
        kn.applyMatrix4(e),
        this.setXYZ(n, kn.x, kn.y, kn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      kn.fromBufferAttribute(this, n),
        kn.applyNormalMatrix(e),
        this.setXYZ(n, kn.x, kn.y, kn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      kn.fromBufferAttribute(this, n),
        kn.transformDirection(e),
        this.setXYZ(n, kn.x, kn.y, kn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let r = this.array[e * this.itemSize + n];
    return this.normalized && (r = Jr(r, this.array)), r;
  }
  setComponent(e, n, r) {
    return (
      this.normalized && (r = St(r, this.array)),
      (this.array[e * this.itemSize + n] = r),
      this
    );
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize] = n),
      this
    );
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 1] = n),
      this
    );
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 2] = n),
      this
    );
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 3] = n),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = St(n, this.array)), (r = St(r, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array)),
        (s = St(s, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Fd && (e.usage = this.usage),
      e
    );
  }
}
class YB extends $t {
  constructor(e, n, r) {
    super(new Int8Array(e), n, r);
  }
}
class qB extends $t {
  constructor(e, n, r) {
    super(new Uint8Array(e), n, r);
  }
}
class KB extends $t {
  constructor(e, n, r) {
    super(new Uint8ClampedArray(e), n, r);
  }
}
class ZB extends $t {
  constructor(e, n, r) {
    super(new Int16Array(e), n, r);
  }
}
class rM extends $t {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r);
  }
}
class JB extends $t {
  constructor(e, n, r) {
    super(new Int32Array(e), n, r);
  }
}
class iM extends $t {
  constructor(e, n, r) {
    super(new Uint32Array(e), n, r);
  }
}
class QB extends $t {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let n = Ff(this.array[e * this.itemSize]);
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize] = qr(n)),
      this
    );
  }
  getY(e) {
    let n = Ff(this.array[e * this.itemSize + 1]);
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 1] = qr(n)),
      this
    );
  }
  getZ(e) {
    let n = Ff(this.array[e * this.itemSize + 2]);
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 2] = qr(n)),
      this
    );
  }
  getW(e) {
    let n = Ff(this.array[e * this.itemSize + 3]);
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.array[e * this.itemSize + 3] = qr(n)),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = St(n, this.array)), (r = St(r, this.array))),
      (this.array[e + 0] = qr(n)),
      (this.array[e + 1] = qr(r)),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array))),
      (this.array[e + 0] = qr(n)),
      (this.array[e + 1] = qr(r)),
      (this.array[e + 2] = qr(i)),
      this
    );
  }
  setXYZW(e, n, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array)),
        (s = St(s, this.array))),
      (this.array[e + 0] = qr(n)),
      (this.array[e + 1] = qr(r)),
      (this.array[e + 2] = qr(i)),
      (this.array[e + 3] = qr(s)),
      this
    );
  }
}
class tt extends $t {
  constructor(e, n, r) {
    super(new Float32Array(e), n, r);
  }
}
class e4 extends $t {
  constructor(e, n, r) {
    super(new Float64Array(e), n, r);
  }
}
let t4 = 0;
const Di = new ht(),
  Ux = new Ft(),
  du = new z(),
  fi = new Vr(),
  yf = new Vr(),
  er = new z();
class bt extends Ao {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: t4++ }),
      (this.uuid = vi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (WI(e) ? iM : rM)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return (this.attributes[e] = n), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, r = 0) {
    this.groups.push({ start: e, count: n, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    (this.drawRange.start = e), (this.drawRange.count = n);
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), (n.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Et().getNormalMatrix(e);
      r.applyNormalMatrix(s), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Di.makeRotationFromQuaternion(e), this.applyMatrix4(Di), this;
  }
  rotateX(e) {
    return Di.makeRotationX(e), this.applyMatrix4(Di), this;
  }
  rotateY(e) {
    return Di.makeRotationY(e), this.applyMatrix4(Di), this;
  }
  rotateZ(e) {
    return Di.makeRotationZ(e), this.applyMatrix4(Di), this;
  }
  translate(e, n, r) {
    return Di.makeTranslation(e, n, r), this.applyMatrix4(Di), this;
  }
  scale(e, n, r) {
    return Di.makeScale(e, n, r), this.applyMatrix4(Di), this;
  }
  lookAt(e) {
    return Ux.lookAt(e), Ux.updateMatrix(), this.applyMatrix4(Ux.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(du).negate(),
      this.translate(du.x, du.y, du.z),
      this
    );
  }
  setFromPoints(e) {
    const n = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r];
      n.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new tt(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Vr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new z(-1 / 0, -1 / 0, -1 / 0),
          new z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), n))
        for (let r = 0, i = n.length; r < i; r++) {
          const s = n[r];
          fi.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (er.addVectors(this.boundingBox.min, fi.min),
                this.boundingBox.expandByPoint(er),
                er.addVectors(this.boundingBox.max, fi.max),
                this.boundingBox.expandByPoint(er))
              : (this.boundingBox.expandByPoint(fi.min),
                this.boundingBox.expandByPoint(fi.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new z(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((fi.setFromBufferAttribute(e), n))
        for (let s = 0, o = n.length; s < o; s++) {
          const a = n[s];
          yf.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (er.addVectors(fi.min, yf.min),
                fi.expandByPoint(er),
                er.addVectors(fi.max, yf.max),
                fi.expandByPoint(er))
              : (fi.expandByPoint(yf.min), fi.expandByPoint(yf.max));
        }
      fi.getCenter(r);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        er.fromBufferAttribute(e, s),
          (i = Math.max(i, r.distanceToSquared(er)));
      if (n)
        for (let s = 0, o = n.length; s < o; s++) {
          const a = n[s],
            l = this.morphTargetsRelative;
          for (let f = 0, d = a.count; f < d; f++)
            er.fromBufferAttribute(a, f),
              l && (du.fromBufferAttribute(e, f), er.add(du)),
              (i = Math.max(i, r.distanceToSquared(er)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      n = this.attributes;
    if (
      e === null ||
      n.position === void 0 ||
      n.normal === void 0 ||
      n.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = e.array,
      i = n.position.array,
      s = n.normal.array,
      o = n.uv.array,
      a = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new $t(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      f = [],
      d = [];
    for (let I = 0; I < a; I++) (f[I] = new z()), (d[I] = new z());
    const h = new z(),
      p = new z(),
      g = new z(),
      v = new _e(),
      _ = new _e(),
      x = new _e(),
      m = new z(),
      w = new z();
    function S(I, k, R) {
      h.fromArray(i, I * 3),
        p.fromArray(i, k * 3),
        g.fromArray(i, R * 3),
        v.fromArray(o, I * 2),
        _.fromArray(o, k * 2),
        x.fromArray(o, R * 2),
        p.sub(h),
        g.sub(h),
        _.sub(v),
        x.sub(v);
      const $ = 1 / (_.x * x.y - x.x * _.y);
      isFinite($) &&
        (m
          .copy(p)
          .multiplyScalar(x.y)
          .addScaledVector(g, -_.y)
          .multiplyScalar($),
        w
          .copy(g)
          .multiplyScalar(_.x)
          .addScaledVector(p, -x.x)
          .multiplyScalar($),
        f[I].add(m),
        f[k].add(m),
        f[R].add(m),
        d[I].add(w),
        d[k].add(w),
        d[R].add(w));
    }
    let E = this.groups;
    E.length === 0 && (E = [{ start: 0, count: r.length }]);
    for (let I = 0, k = E.length; I < k; ++I) {
      const R = E[I],
        $ = R.start,
        D = R.count;
      for (let W = $, Y = $ + D; W < Y; W += 3) S(r[W + 0], r[W + 1], r[W + 2]);
    }
    const T = new z(),
      A = new z(),
      L = new z(),
      N = new z();
    function C(I) {
      L.fromArray(s, I * 3), N.copy(L);
      const k = f[I];
      T.copy(k),
        T.sub(L.multiplyScalar(L.dot(k))).normalize(),
        A.crossVectors(N, k);
      const $ = A.dot(d[I]) < 0 ? -1 : 1;
      (l[I * 4] = T.x),
        (l[I * 4 + 1] = T.y),
        (l[I * 4 + 2] = T.z),
        (l[I * 4 + 3] = $);
    }
    for (let I = 0, k = E.length; I < k; ++I) {
      const R = E[I],
        $ = R.start,
        D = R.count;
      for (let W = $, Y = $ + D; W < Y; W += 3)
        C(r[W + 0]), C(r[W + 1]), C(r[W + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      n = this.getAttribute("position");
    if (n !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new $t(new Float32Array(n.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let p = 0, g = r.count; p < g; p++) r.setXYZ(p, 0, 0, 0);
      const i = new z(),
        s = new z(),
        o = new z(),
        a = new z(),
        l = new z(),
        f = new z(),
        d = new z(),
        h = new z();
      if (e)
        for (let p = 0, g = e.count; p < g; p += 3) {
          const v = e.getX(p + 0),
            _ = e.getX(p + 1),
            x = e.getX(p + 2);
          i.fromBufferAttribute(n, v),
            s.fromBufferAttribute(n, _),
            o.fromBufferAttribute(n, x),
            d.subVectors(o, s),
            h.subVectors(i, s),
            d.cross(h),
            a.fromBufferAttribute(r, v),
            l.fromBufferAttribute(r, _),
            f.fromBufferAttribute(r, x),
            a.add(d),
            l.add(d),
            f.add(d),
            r.setXYZ(v, a.x, a.y, a.z),
            r.setXYZ(_, l.x, l.y, l.z),
            r.setXYZ(x, f.x, f.y, f.z);
        }
      else
        for (let p = 0, g = n.count; p < g; p += 3)
          i.fromBufferAttribute(n, p + 0),
            s.fromBufferAttribute(n, p + 1),
            o.fromBufferAttribute(n, p + 2),
            d.subVectors(o, s),
            h.subVectors(i, s),
            d.cross(h),
            r.setXYZ(p + 0, d.x, d.y, d.z),
            r.setXYZ(p + 1, d.x, d.y, d.z),
            r.setXYZ(p + 2, d.x, d.y, d.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, r = e.count; n < r; n++)
      er.fromBufferAttribute(e, n),
        er.normalize(),
        e.setXYZ(n, er.x, er.y, er.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const f = a.array,
        d = a.itemSize,
        h = a.normalized,
        p = new f.constructor(l.length * d);
      let g = 0,
        v = 0;
      for (let _ = 0, x = l.length; _ < x; _++) {
        a.isInterleavedBufferAttribute
          ? (g = l[_] * a.data.stride + a.offset)
          : (g = l[_] * d);
        for (let m = 0; m < d; m++) p[v++] = f[g++];
      }
      return new $t(p, d, h);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const n = new bt(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        f = e(l, r);
      n.setAttribute(a, f);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        f = s[a];
      for (let d = 0, h = f.length; d < h; d++) {
        const p = f[d],
          g = e(p, r);
        l.push(g);
      }
      n.morphAttributes[a] = l;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const f = o[a];
      n.addGroup(f.start, f.count, f.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const f in l) l[f] !== void 0 && (e[f] = l[f]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null &&
      (e.data.index = {
        type: n.array.constructor.name,
        array: Array.prototype.slice.call(n.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const f = r[l];
      e.data.attributes[l] = f.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const f = this.morphAttributes[l],
        d = [];
      for (let h = 0, p = f.length; h < p; h++) {
        const g = f[h];
        d.push(g.toJSON(e.data));
      }
      d.length > 0 && ((i[l] = d), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const n = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(n));
    const i = e.attributes;
    for (const f in i) {
      const d = i[f];
      this.setAttribute(f, d.clone(n));
    }
    const s = e.morphAttributes;
    for (const f in s) {
      const d = [],
        h = s[f];
      for (let p = 0, g = h.length; p < g; p++) d.push(h[p].clone(n));
      this.morphAttributes[f] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let f = 0, d = o.length; f < d; f++) {
      const h = o[f];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const EA = new ht(),
  Ba = new kl(),
  $p = new Pr(),
  bA = new z(),
  hu = new z(),
  pu = new z(),
  mu = new z(),
  Fx = new z(),
  Xp = new z(),
  Yp = new _e(),
  qp = new _e(),
  Kp = new _e(),
  TA = new z(),
  AA = new z(),
  CA = new z(),
  Zp = new z(),
  Jp = new z();
class jn extends Ft {
  constructor(e = new bt(), n = new Ta()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const r = this.geometry,
      i = r.attributes.position,
      s = r.morphAttributes.position,
      o = r.morphTargetsRelative;
    n.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Xp.set(0, 0, 0);
      for (let l = 0, f = s.length; l < f; l++) {
        const d = a[l],
          h = s[l];
        d !== 0 &&
          (Fx.fromBufferAttribute(h, e),
          o ? Xp.addScaledVector(Fx, d) : Xp.addScaledVector(Fx.sub(n), d));
      }
      n.add(Xp);
    }
    return n;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      $p.copy(r.boundingSphere),
      $p.applyMatrix4(s),
      Ba.copy(e.ray).recast(e.near),
      !(
        $p.containsPoint(Ba.origin) === !1 &&
        (Ba.intersectSphere($p, bA) === null ||
          Ba.origin.distanceToSquared(bA) > (e.far - e.near) ** 2)
      ) &&
        (EA.copy(s).invert(),
        Ba.copy(e.ray).applyMatrix4(EA),
        !(r.boundingBox !== null && Ba.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, n, Ba)));
  }
  _computeIntersections(e, n, r) {
    let i;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      f = s.attributes.uv,
      d = s.attributes.uv1,
      h = s.attributes.normal,
      p = s.groups,
      g = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let v = 0, _ = p.length; v < _; v++) {
          const x = p[v],
            m = o[x.materialIndex],
            w = Math.max(x.start, g.start),
            S = Math.min(
              a.count,
              Math.min(x.start + x.count, g.start + g.count)
            );
          for (let E = w, T = S; E < T; E += 3) {
            const A = a.getX(E),
              L = a.getX(E + 1),
              N = a.getX(E + 2);
            (i = Qp(this, m, e, r, f, d, h, A, L, N)),
              i &&
                ((i.faceIndex = Math.floor(E / 3)),
                (i.face.materialIndex = x.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, g.start),
          _ = Math.min(a.count, g.start + g.count);
        for (let x = v, m = _; x < m; x += 3) {
          const w = a.getX(x),
            S = a.getX(x + 1),
            E = a.getX(x + 2);
          (i = Qp(this, o, e, r, f, d, h, w, S, E)),
            i && ((i.faceIndex = Math.floor(x / 3)), n.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let v = 0, _ = p.length; v < _; v++) {
          const x = p[v],
            m = o[x.materialIndex],
            w = Math.max(x.start, g.start),
            S = Math.min(
              l.count,
              Math.min(x.start + x.count, g.start + g.count)
            );
          for (let E = w, T = S; E < T; E += 3) {
            const A = E,
              L = E + 1,
              N = E + 2;
            (i = Qp(this, m, e, r, f, d, h, A, L, N)),
              i &&
                ((i.faceIndex = Math.floor(E / 3)),
                (i.face.materialIndex = x.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, g.start),
          _ = Math.min(l.count, g.start + g.count);
        for (let x = v, m = _; x < m; x += 3) {
          const w = x,
            S = x + 1,
            E = x + 2;
          (i = Qp(this, o, e, r, f, d, h, w, S, E)),
            i && ((i.faceIndex = Math.floor(x / 3)), n.push(i));
        }
      }
  }
}
function n4(t, e, n, r, i, s, o, a) {
  let l;
  if (
    (e.side === Hr
      ? (l = r.intersectTriangle(o, s, i, !0, a))
      : (l = r.intersectTriangle(i, s, o, e.side === _o, a)),
    l === null)
  )
    return null;
  Jp.copy(a), Jp.applyMatrix4(t.matrixWorld);
  const f = n.ray.origin.distanceTo(Jp);
  return f < n.near || f > n.far
    ? null
    : { distance: f, point: Jp.clone(), object: t };
}
function Qp(t, e, n, r, i, s, o, a, l, f) {
  t.getVertexPosition(a, hu),
    t.getVertexPosition(l, pu),
    t.getVertexPosition(f, mu);
  const d = n4(t, e, n, r, hu, pu, mu, Zp);
  if (d) {
    i &&
      (Yp.fromBufferAttribute(i, a),
      qp.fromBufferAttribute(i, l),
      Kp.fromBufferAttribute(i, f),
      (d.uv = Zr.getInterpolation(Zp, hu, pu, mu, Yp, qp, Kp, new _e()))),
      s &&
        (Yp.fromBufferAttribute(s, a),
        qp.fromBufferAttribute(s, l),
        Kp.fromBufferAttribute(s, f),
        (d.uv1 = Zr.getInterpolation(Zp, hu, pu, mu, Yp, qp, Kp, new _e())),
        (d.uv2 = d.uv1)),
      o &&
        (TA.fromBufferAttribute(o, a),
        AA.fromBufferAttribute(o, l),
        CA.fromBufferAttribute(o, f),
        (d.normal = Zr.getInterpolation(Zp, hu, pu, mu, TA, AA, CA, new z())),
        d.normal.dot(r.direction) > 0 && d.normal.multiplyScalar(-1));
    const h = { a, b: l, c: f, normal: new z(), materialIndex: 0 };
    Zr.getNormal(hu, pu, mu, h.normal), (d.face = h);
  }
  return d;
}
class Ul extends bt {
  constructor(e = 1, n = 1, r = 1, i = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: r,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      f = [],
      d = [],
      h = [];
    let p = 0,
      g = 0;
    v("z", "y", "x", -1, -1, r, n, e, o, s, 0),
      v("z", "y", "x", 1, -1, r, n, -e, o, s, 1),
      v("x", "z", "y", 1, 1, e, r, n, i, o, 2),
      v("x", "z", "y", 1, -1, e, r, -n, i, o, 3),
      v("x", "y", "z", 1, -1, e, n, r, i, s, 4),
      v("x", "y", "z", -1, -1, e, n, -r, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new tt(f, 3)),
      this.setAttribute("normal", new tt(d, 3)),
      this.setAttribute("uv", new tt(h, 2));
    function v(_, x, m, w, S, E, T, A, L, N, C) {
      const I = E / L,
        k = T / N,
        R = E / 2,
        $ = T / 2,
        D = A / 2,
        W = L + 1,
        Y = N + 1;
      let Z = 0,
        B = 0;
      const G = new z();
      for (let X = 0; X < Y; X++) {
        const te = X * k - $;
        for (let oe = 0; oe < W; oe++) {
          const J = oe * I - R;
          (G[_] = J * w),
            (G[x] = te * S),
            (G[m] = D),
            f.push(G.x, G.y, G.z),
            (G[_] = 0),
            (G[x] = 0),
            (G[m] = A > 0 ? 1 : -1),
            d.push(G.x, G.y, G.z),
            h.push(oe / L),
            h.push(1 - X / N),
            (Z += 1);
        }
      }
      for (let X = 0; X < N; X++)
        for (let te = 0; te < L; te++) {
          const oe = p + te + W * X,
            J = p + te + W * (X + 1),
            ae = p + (te + 1) + W * (X + 1),
            Se = p + (te + 1) + W * X;
          l.push(oe, J, Se), l.push(J, ae, Se), (B += 6);
        }
      a.addGroup(g, B, C), (g += B), (p += Z);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ul(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function wc(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const r in t[n]) {
      const i = t[n][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[n][r] = null))
          : (e[n][r] = i.clone())
        : Array.isArray(i)
        ? (e[n][r] = i.slice())
        : (e[n][r] = i);
    }
  }
  return e;
}
function Ur(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = wc(t[n]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function r4(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t[n].clone());
  return e;
}
function XI(t) {
  return t.getRenderTarget() === null
    ? t.outputColorSpace
    : Wt.workingColorSpace;
}
const YI = { clone: wc, merge: Ur };
var i4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  s4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Bs extends Nr {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = i4),
      (this.fragmentShader = s4),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = wc(e.uniforms)),
      (this.uniformsGroups = r4(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    (n.glslVersion = this.glslVersion), (n.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (n.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (n.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (n.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (n.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (n.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (n.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (n.uniforms[i] = { type: "m4", value: o.toArray() })
        : (n.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines),
      (n.vertexShader = this.vertexShader),
      (n.fragmentShader = this.fragmentShader),
      (n.lights = this.lights),
      (n.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (n.extensions = r), n;
  }
}
class oh extends Ft {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ht()),
      (this.projectionMatrix = new ht()),
      (this.projectionMatrixInverse = new ht()),
      (this.coordinateSystem = os);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Pn extends oh {
  constructor(e = 50, n = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = n),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const n = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Sc * 2 * Math.atan(n)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(xl * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Sc * 2 * Math.atan(Math.tan(xl * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, n, r, i, s, o) {
    (this.aspect = e / n),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = (e * Math.tan(xl * 0.5 * this.fov)) / this.zoom,
      r = 2 * n,
      i = this.aspect * r,
      s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        f = o.fullHeight;
      (s += (o.offsetX * i) / l),
        (n -= (o.offsetY * r) / f),
        (i *= o.width / l),
        (r *= o.height / f);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        n,
        n - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.fov = this.fov),
      (n.object.zoom = this.zoom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      (n.object.focus = this.focus),
      (n.object.aspect = this.aspect),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      (n.object.filmGauge = this.filmGauge),
      (n.object.filmOffset = this.filmOffset),
      n
    );
  }
}
const gu = -90,
  vu = 1;
class qI extends Ft {
  constructor(e, n, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Pn(gu, vu, e, n);
    (i.layers = this.layers), this.add(i);
    const s = new Pn(gu, vu, e, n);
    (s.layers = this.layers), this.add(s);
    const o = new Pn(gu, vu, e, n);
    (o.layers = this.layers), this.add(o);
    const a = new Pn(gu, vu, e, n);
    (a.layers = this.layers), this.add(a);
    const l = new Pn(gu, vu, e, n);
    (l.layers = this.layers), this.add(l);
    const f = new Pn(gu, vu, e, n);
    (f.layers = this.layers), this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      n = this.children.concat(),
      [r, i, s, o, a, l] = n;
    for (const f of n) this.remove(f);
    if (e === os)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === _c)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const f of n) this.add(f), f.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, f, d] = this.children,
      h = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      g = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(n, s),
      e.setRenderTarget(r, 1, i),
      e.render(n, o),
      e.setRenderTarget(r, 2, i),
      e.render(n, a),
      e.setRenderTarget(r, 3, i),
      e.render(n, l),
      e.setRenderTarget(r, 4, i),
      e.render(n, f),
      (r.texture.generateMipmaps = _),
      e.setRenderTarget(r, 5, i),
      e.render(n, d),
      e.setRenderTarget(h, p, g),
      (e.xr.enabled = v),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class ah extends Ln {
  constructor(e, n, r, i, s, o, a, l, f, d) {
    (e = e !== void 0 ? e : []),
      (n = n !== void 0 ? n : So),
      super(e, n, r, i, s, o, a, l, f, d),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class KI extends cs {
  constructor(e = 1, n = {}) {
    super(e, e, n), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    n.encoding !== void 0 &&
      (td(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (n.colorSpace = n.encoding === fa ? Wn : hi)),
      (this.texture = new ah(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Rn);
  }
  fromEquirectangularTexture(e, n) {
    (this.texture.type = n.type),
      (this.texture.colorSpace = n.colorSpace),
      (this.texture.generateMipmaps = n.generateMipmaps),
      (this.texture.minFilter = n.minFilter),
      (this.texture.magFilter = n.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Ul(5, 5, 5),
      s = new Bs({
        name: "CubemapFromEquirect",
        uniforms: wc(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Hr,
        blending: po,
      });
    s.uniforms.tEquirect.value = n;
    const o = new jn(i, s),
      a = n.minFilter;
    return (
      n.minFilter === xa && (n.minFilter = Rn),
      new qI(1, 10, this).update(e, o),
      (n.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, n, r, i) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(n, r, i);
    e.setRenderTarget(s);
  }
}
const zx = new z(),
  o4 = new z(),
  a4 = new Et();
class ao {
  constructor(e = new z(1, 0, 0), n = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = n);
  }
  set(e, n) {
    return this.normal.copy(e), (this.constant = n), this;
  }
  setComponents(e, n, r, i) {
    return this.normal.set(e, n, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), (this.constant = -n.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, n, r) {
    const i = zx.subVectors(r, n).cross(o4.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const r = e.delta(zx),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(r, s);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (n < 0 && r > 0) || (r < 0 && n > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const r = n || a4.getNormalMatrix(e),
      i = this.coplanarPoint(zx).applyMatrix4(e),
      s = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ha = new Pr(),
  em = new z();
class lh {
  constructor(
    e = new ao(),
    n = new ao(),
    r = new ao(),
    i = new ao(),
    s = new ao(),
    o = new ao()
  ) {
    this.planes = [e, n, r, i, s, o];
  }
  set(e, n, r, i, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(n),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, n = os) {
    const r = this.planes,
      i = e.elements,
      s = i[0],
      o = i[1],
      a = i[2],
      l = i[3],
      f = i[4],
      d = i[5],
      h = i[6],
      p = i[7],
      g = i[8],
      v = i[9],
      _ = i[10],
      x = i[11],
      m = i[12],
      w = i[13],
      S = i[14],
      E = i[15];
    if (
      (r[0].setComponents(l - s, p - f, x - g, E - m).normalize(),
      r[1].setComponents(l + s, p + f, x + g, E + m).normalize(),
      r[2].setComponents(l + o, p + d, x + v, E + w).normalize(),
      r[3].setComponents(l - o, p - d, x - v, E - w).normalize(),
      r[4].setComponents(l - a, p - h, x - _, E - S).normalize(),
      n === os)
    )
      r[5].setComponents(l + a, p + h, x + _, E + S).normalize();
    else if (n === _c) r[5].setComponents(a, h, _, S).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          n
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ha.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(),
        Ha.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ha);
  }
  intersectsSprite(e) {
    return (
      Ha.center.set(0, 0, 0),
      (Ha.radius = 0.7071067811865476),
      Ha.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ha)
    );
  }
  intersectsSphere(e) {
    const n = this.planes,
      r = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (n[s].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = n[r];
      if (
        ((em.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (em.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (em.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(em) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) if (n[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ZI() {
  let t = null,
    e = !1,
    n = null,
    r = null;
  function i(s, o) {
    n(s, o), (r = t.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((r = t.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (s) {
      n = s;
    },
    setContext: function (s) {
      t = s;
    },
  };
}
function l4(t, e) {
  const n = e.isWebGL2,
    r = new WeakMap();
  function i(f, d) {
    const h = f.array,
      p = f.usage,
      g = h.byteLength,
      v = t.createBuffer();
    t.bindBuffer(d, v), t.bufferData(d, h, p), f.onUploadCallback();
    let _;
    if (h instanceof Float32Array) _ = t.FLOAT;
    else if (h instanceof Uint16Array)
      if (f.isFloat16BufferAttribute)
        if (n) _ = t.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else _ = t.UNSIGNED_SHORT;
    else if (h instanceof Int16Array) _ = t.SHORT;
    else if (h instanceof Uint32Array) _ = t.UNSIGNED_INT;
    else if (h instanceof Int32Array) _ = t.INT;
    else if (h instanceof Int8Array) _ = t.BYTE;
    else if (h instanceof Uint8Array) _ = t.UNSIGNED_BYTE;
    else if (h instanceof Uint8ClampedArray) _ = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + h
      );
    return {
      buffer: v,
      type: _,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: f.version,
      size: g,
    };
  }
  function s(f, d, h) {
    const p = d.array,
      g = d._updateRange,
      v = d.updateRanges;
    if (
      (t.bindBuffer(h, f),
      g.count === -1 && v.length === 0 && t.bufferSubData(h, 0, p),
      v.length !== 0)
    ) {
      for (let _ = 0, x = v.length; _ < x; _++) {
        const m = v[_];
        n
          ? t.bufferSubData(
              h,
              m.start * p.BYTES_PER_ELEMENT,
              p,
              m.start,
              m.count
            )
          : t.bufferSubData(
              h,
              m.start * p.BYTES_PER_ELEMENT,
              p.subarray(m.start, m.start + m.count)
            );
      }
      d.clearUpdateRanges();
    }
    g.count !== -1 &&
      (n
        ? t.bufferSubData(
            h,
            g.offset * p.BYTES_PER_ELEMENT,
            p,
            g.offset,
            g.count
          )
        : t.bufferSubData(
            h,
            g.offset * p.BYTES_PER_ELEMENT,
            p.subarray(g.offset, g.offset + g.count)
          ),
      (g.count = -1)),
      d.onUploadCallback();
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), r.get(f);
  }
  function a(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    const d = r.get(f);
    d && (t.deleteBuffer(d.buffer), r.delete(f));
  }
  function l(f, d) {
    if (f.isGLBufferAttribute) {
      const p = r.get(f);
      (!p || p.version < f.version) &&
        r.set(f, {
          buffer: f.buffer,
          type: f.type,
          bytesPerElement: f.elementSize,
          version: f.version,
        });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    const h = r.get(f);
    if (h === void 0) r.set(f, i(f, d));
    else if (h.version < f.version) {
      if (h.size !== f.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      s(h.buffer, f, d), (h.version = f.version);
    }
  }
  return { get: o, remove: a, update: l };
}
class uh extends bt {
  constructor(e = 1, n = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        widthSegments: r,
        heightSegments: i,
      });
    const s = e / 2,
      o = n / 2,
      a = Math.floor(r),
      l = Math.floor(i),
      f = a + 1,
      d = l + 1,
      h = e / a,
      p = n / l,
      g = [],
      v = [],
      _ = [],
      x = [];
    for (let m = 0; m < d; m++) {
      const w = m * p - o;
      for (let S = 0; S < f; S++) {
        const E = S * h - s;
        v.push(E, -w, 0), _.push(0, 0, 1), x.push(S / a), x.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++)
      for (let w = 0; w < a; w++) {
        const S = w + f * m,
          E = w + f * (m + 1),
          T = w + 1 + f * (m + 1),
          A = w + 1 + f * m;
        g.push(S, E, A), g.push(E, T, A);
      }
    this.setIndex(g),
      this.setAttribute("position", new tt(v, 3)),
      this.setAttribute("normal", new tt(_, 3)),
      this.setAttribute("uv", new tt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new uh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var u4 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  c4 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  f4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  d4 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  h4 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  p4 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  m4 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  g4 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  v4 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  y4 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  x4 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  _4 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  S4 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  w4 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  M4 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  E4 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  b4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  T4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  A4 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  C4 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  R4 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  P4 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  L4 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  I4 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  N4 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  O4 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  D4 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  k4 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  U4 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  F4 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  z4 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  B4 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  H4 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  V4 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  W4 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  G4 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  j4 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  $4 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  X4 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  Y4 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  q4 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  K4 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Z4 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  J4 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Q4 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  e5 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  t5 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  n5 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  r5 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  i5 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  s5 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  o5 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  a5 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  l5 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  u5 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  c5 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  f5 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  d5 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  h5 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  p5 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  m5 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  g5 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  v5 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  y5 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  x5 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  _5 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  S5 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  w5 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  M5 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  E5 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  b5 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  T5 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  A5 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  C5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  R5 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  P5 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  L5 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  I5 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  N5 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  O5 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  D5 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  k5 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  U5 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  F5 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  z5 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  B5 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  H5 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  V5 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  W5 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  G5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  j5 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  $5 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  X5 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  Y5 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  q5 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  K5 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Z5 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  J5 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Q5 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  eH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  nH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  rH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  iH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  sH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  oH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  aH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const lH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  uH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  cH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  dH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  hH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  pH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  mH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  gH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  vH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  yH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  xH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  _H = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  SH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  wH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  MH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  EH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  bH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  TH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  AH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  CH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  RH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  PH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  LH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  IH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  NH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  DH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  UH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  FH = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  zH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  BH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  HH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  _t = {
    alphahash_fragment: u4,
    alphahash_pars_fragment: c4,
    alphamap_fragment: f4,
    alphamap_pars_fragment: d4,
    alphatest_fragment: h4,
    alphatest_pars_fragment: p4,
    aomap_fragment: m4,
    aomap_pars_fragment: g4,
    batching_pars_vertex: v4,
    batching_vertex: y4,
    begin_vertex: x4,
    beginnormal_vertex: _4,
    bsdfs: S4,
    iridescence_fragment: w4,
    bumpmap_pars_fragment: M4,
    clipping_planes_fragment: E4,
    clipping_planes_pars_fragment: b4,
    clipping_planes_pars_vertex: T4,
    clipping_planes_vertex: A4,
    color_fragment: C4,
    color_pars_fragment: R4,
    color_pars_vertex: P4,
    color_vertex: L4,
    common: I4,
    cube_uv_reflection_fragment: N4,
    defaultnormal_vertex: O4,
    displacementmap_pars_vertex: D4,
    displacementmap_vertex: k4,
    emissivemap_fragment: U4,
    emissivemap_pars_fragment: F4,
    colorspace_fragment: z4,
    colorspace_pars_fragment: B4,
    envmap_fragment: H4,
    envmap_common_pars_fragment: V4,
    envmap_pars_fragment: W4,
    envmap_pars_vertex: G4,
    envmap_physical_pars_fragment: n5,
    envmap_vertex: j4,
    fog_vertex: $4,
    fog_pars_vertex: X4,
    fog_fragment: Y4,
    fog_pars_fragment: q4,
    gradientmap_pars_fragment: K4,
    lightmap_fragment: Z4,
    lightmap_pars_fragment: J4,
    lights_lambert_fragment: Q4,
    lights_lambert_pars_fragment: e5,
    lights_pars_begin: t5,
    lights_toon_fragment: r5,
    lights_toon_pars_fragment: i5,
    lights_phong_fragment: s5,
    lights_phong_pars_fragment: o5,
    lights_physical_fragment: a5,
    lights_physical_pars_fragment: l5,
    lights_fragment_begin: u5,
    lights_fragment_maps: c5,
    lights_fragment_end: f5,
    logdepthbuf_fragment: d5,
    logdepthbuf_pars_fragment: h5,
    logdepthbuf_pars_vertex: p5,
    logdepthbuf_vertex: m5,
    map_fragment: g5,
    map_pars_fragment: v5,
    map_particle_fragment: y5,
    map_particle_pars_fragment: x5,
    metalnessmap_fragment: _5,
    metalnessmap_pars_fragment: S5,
    morphcolor_vertex: w5,
    morphnormal_vertex: M5,
    morphtarget_pars_vertex: E5,
    morphtarget_vertex: b5,
    normal_fragment_begin: T5,
    normal_fragment_maps: A5,
    normal_pars_fragment: C5,
    normal_pars_vertex: R5,
    normal_vertex: P5,
    normalmap_pars_fragment: L5,
    clearcoat_normal_fragment_begin: I5,
    clearcoat_normal_fragment_maps: N5,
    clearcoat_pars_fragment: O5,
    iridescence_pars_fragment: D5,
    opaque_fragment: k5,
    packing: U5,
    premultiplied_alpha_fragment: F5,
    project_vertex: z5,
    dithering_fragment: B5,
    dithering_pars_fragment: H5,
    roughnessmap_fragment: V5,
    roughnessmap_pars_fragment: W5,
    shadowmap_pars_fragment: G5,
    shadowmap_pars_vertex: j5,
    shadowmap_vertex: $5,
    shadowmask_pars_fragment: X5,
    skinbase_vertex: Y5,
    skinning_pars_vertex: q5,
    skinning_vertex: K5,
    skinnormal_vertex: Z5,
    specularmap_fragment: J5,
    specularmap_pars_fragment: Q5,
    tonemapping_fragment: eH,
    tonemapping_pars_fragment: tH,
    transmission_fragment: nH,
    transmission_pars_fragment: rH,
    uv_pars_fragment: iH,
    uv_pars_vertex: sH,
    uv_vertex: oH,
    worldpos_vertex: aH,
    background_vert: lH,
    background_frag: uH,
    backgroundCube_vert: cH,
    backgroundCube_frag: fH,
    cube_vert: dH,
    cube_frag: hH,
    depth_vert: pH,
    depth_frag: mH,
    distanceRGBA_vert: gH,
    distanceRGBA_frag: vH,
    equirect_vert: yH,
    equirect_frag: xH,
    linedashed_vert: _H,
    linedashed_frag: SH,
    meshbasic_vert: wH,
    meshbasic_frag: MH,
    meshlambert_vert: EH,
    meshlambert_frag: bH,
    meshmatcap_vert: TH,
    meshmatcap_frag: AH,
    meshnormal_vert: CH,
    meshnormal_frag: RH,
    meshphong_vert: PH,
    meshphong_frag: LH,
    meshphysical_vert: IH,
    meshphysical_frag: NH,
    meshtoon_vert: OH,
    meshtoon_frag: DH,
    points_vert: kH,
    points_frag: UH,
    shadow_vert: FH,
    shadow_frag: zH,
    sprite_vert: BH,
    sprite_frag: HH,
  },
  Ve = {
    common: {
      diffuse: { value: new qe(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Et() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Et() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Et() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Et() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Et() },
      normalScale: { value: new _e(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Et() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Et() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Et() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Et() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new qe(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new qe(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Et() },
    },
    sprite: {
      diffuse: { value: new qe(16777215) },
      opacity: { value: 1 },
      center: { value: new _e(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
    },
  },
  rs = {
    basic: {
      uniforms: Ur([
        Ve.common,
        Ve.specularmap,
        Ve.envmap,
        Ve.aomap,
        Ve.lightmap,
        Ve.fog,
      ]),
      vertexShader: _t.meshbasic_vert,
      fragmentShader: _t.meshbasic_frag,
    },
    lambert: {
      uniforms: Ur([
        Ve.common,
        Ve.specularmap,
        Ve.envmap,
        Ve.aomap,
        Ve.lightmap,
        Ve.emissivemap,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        Ve.fog,
        Ve.lights,
        { emissive: { value: new qe(0) } },
      ]),
      vertexShader: _t.meshlambert_vert,
      fragmentShader: _t.meshlambert_frag,
    },
    phong: {
      uniforms: Ur([
        Ve.common,
        Ve.specularmap,
        Ve.envmap,
        Ve.aomap,
        Ve.lightmap,
        Ve.emissivemap,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        Ve.fog,
        Ve.lights,
        {
          emissive: { value: new qe(0) },
          specular: { value: new qe(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: _t.meshphong_vert,
      fragmentShader: _t.meshphong_frag,
    },
    standard: {
      uniforms: Ur([
        Ve.common,
        Ve.envmap,
        Ve.aomap,
        Ve.lightmap,
        Ve.emissivemap,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        Ve.roughnessmap,
        Ve.metalnessmap,
        Ve.fog,
        Ve.lights,
        {
          emissive: { value: new qe(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: _t.meshphysical_vert,
      fragmentShader: _t.meshphysical_frag,
    },
    toon: {
      uniforms: Ur([
        Ve.common,
        Ve.aomap,
        Ve.lightmap,
        Ve.emissivemap,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        Ve.gradientmap,
        Ve.fog,
        Ve.lights,
        { emissive: { value: new qe(0) } },
      ]),
      vertexShader: _t.meshtoon_vert,
      fragmentShader: _t.meshtoon_frag,
    },
    matcap: {
      uniforms: Ur([
        Ve.common,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        Ve.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: _t.meshmatcap_vert,
      fragmentShader: _t.meshmatcap_frag,
    },
    points: {
      uniforms: Ur([Ve.points, Ve.fog]),
      vertexShader: _t.points_vert,
      fragmentShader: _t.points_frag,
    },
    dashed: {
      uniforms: Ur([
        Ve.common,
        Ve.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: _t.linedashed_vert,
      fragmentShader: _t.linedashed_frag,
    },
    depth: {
      uniforms: Ur([Ve.common, Ve.displacementmap]),
      vertexShader: _t.depth_vert,
      fragmentShader: _t.depth_frag,
    },
    normal: {
      uniforms: Ur([
        Ve.common,
        Ve.bumpmap,
        Ve.normalmap,
        Ve.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: _t.meshnormal_vert,
      fragmentShader: _t.meshnormal_frag,
    },
    sprite: {
      uniforms: Ur([Ve.sprite, Ve.fog]),
      vertexShader: _t.sprite_vert,
      fragmentShader: _t.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Et() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: _t.background_vert,
      fragmentShader: _t.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: _t.backgroundCube_vert,
      fragmentShader: _t.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: _t.cube_vert,
      fragmentShader: _t.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: _t.equirect_vert,
      fragmentShader: _t.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ur([
        Ve.common,
        Ve.displacementmap,
        {
          referencePosition: { value: new z() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: _t.distanceRGBA_vert,
      fragmentShader: _t.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ur([
        Ve.lights,
        Ve.fog,
        { color: { value: new qe(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: _t.shadow_vert,
      fragmentShader: _t.shadow_frag,
    },
  };
rs.physical = {
  uniforms: Ur([
    rs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Et() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Et() },
      clearcoatNormalScale: { value: new _e(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Et() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Et() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Et() },
      sheen: { value: 0 },
      sheenColor: { value: new qe(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Et() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Et() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Et() },
      transmissionSamplerSize: { value: new _e() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Et() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new qe(0) },
      specularColor: { value: new qe(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Et() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Et() },
      anisotropyVector: { value: new _e() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Et() },
    },
  ]),
  vertexShader: _t.meshphysical_vert,
  fragmentShader: _t.meshphysical_frag,
};
const tm = { r: 0, b: 0, g: 0 };
function VH(t, e, n, r, i, s, o) {
  const a = new qe(0);
  let l = s === !0 ? 0 : 1,
    f,
    d,
    h = null,
    p = 0,
    g = null;
  function v(x, m) {
    let w = !1,
      S = m.isScene === !0 ? m.background : null;
    S && S.isTexture && (S = (m.backgroundBlurriness > 0 ? n : e).get(S)),
      S === null ? _(a, l) : S && S.isColor && (_(S, 1), (w = !0));
    const E = t.xr.getEnvironmentBlendMode();
    E === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, o)
      : E === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, o),
      (t.autoClear || w) &&
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      S && (S.isCubeTexture || S.mapping === Ic)
        ? (d === void 0 &&
            ((d = new jn(
              new Ul(1, 1, 1),
              new Bs({
                name: "BackgroundCubeMaterial",
                uniforms: wc(rs.backgroundCube.uniforms),
                vertexShader: rs.backgroundCube.vertexShader,
                fragmentShader: rs.backgroundCube.fragmentShader,
                side: Hr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            d.geometry.deleteAttribute("normal"),
            d.geometry.deleteAttribute("uv"),
            (d.onBeforeRender = function (T, A, L) {
              this.matrixWorld.copyPosition(L.matrixWorld);
            }),
            Object.defineProperty(d.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(d)),
          (d.material.uniforms.envMap.value = S),
          (d.material.uniforms.flipEnvMap.value =
            S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
          (d.material.uniforms.backgroundBlurriness.value =
            m.backgroundBlurriness),
          (d.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (d.material.toneMapped = Wt.getTransfer(S.colorSpace) !== Jt),
          (h !== S || p !== S.version || g !== t.toneMapping) &&
            ((d.material.needsUpdate = !0),
            (h = S),
            (p = S.version),
            (g = t.toneMapping)),
          d.layers.enableAll(),
          x.unshift(d, d.geometry, d.material, 0, 0, null))
        : S &&
          S.isTexture &&
          (f === void 0 &&
            ((f = new jn(
              new uh(2, 2),
              new Bs({
                name: "BackgroundMaterial",
                uniforms: wc(rs.background.uniforms),
                vertexShader: rs.background.vertexShader,
                fragmentShader: rs.background.fragmentShader,
                side: _o,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            f.geometry.deleteAttribute("normal"),
            Object.defineProperty(f.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(f)),
          (f.material.uniforms.t2D.value = S),
          (f.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (f.material.toneMapped = Wt.getTransfer(S.colorSpace) !== Jt),
          S.matrixAutoUpdate === !0 && S.updateMatrix(),
          f.material.uniforms.uvTransform.value.copy(S.matrix),
          (h !== S || p !== S.version || g !== t.toneMapping) &&
            ((f.material.needsUpdate = !0),
            (h = S),
            (p = S.version),
            (g = t.toneMapping)),
          f.layers.enableAll(),
          x.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function _(x, m) {
    x.getRGB(tm, XI(t)), r.buffers.color.setClear(tm.r, tm.g, tm.b, m, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (x, m = 1) {
      a.set(x), (l = m), _(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (x) {
      (l = x), _(a, l);
    },
    render: v,
  };
}
function WH(t, e, n, r) {
  const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = r.isWebGL2 || s !== null,
    a = {},
    l = x(null);
  let f = l,
    d = !1;
  function h(D, W, Y, Z, B) {
    let G = !1;
    if (o) {
      const X = _(Z, Y, W);
      f !== X && ((f = X), g(f.object)),
        (G = m(D, Z, Y, B)),
        G && w(D, Z, Y, B);
    } else {
      const X = W.wireframe === !0;
      (f.geometry !== Z.id || f.program !== Y.id || f.wireframe !== X) &&
        ((f.geometry = Z.id), (f.program = Y.id), (f.wireframe = X), (G = !0));
    }
    B !== null && n.update(B, t.ELEMENT_ARRAY_BUFFER),
      (G || d) &&
        ((d = !1),
        N(D, W, Y, Z),
        B !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(B).buffer));
  }
  function p() {
    return r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES();
  }
  function g(D) {
    return r.isWebGL2 ? t.bindVertexArray(D) : s.bindVertexArrayOES(D);
  }
  function v(D) {
    return r.isWebGL2 ? t.deleteVertexArray(D) : s.deleteVertexArrayOES(D);
  }
  function _(D, W, Y) {
    const Z = Y.wireframe === !0;
    let B = a[D.id];
    B === void 0 && ((B = {}), (a[D.id] = B));
    let G = B[W.id];
    G === void 0 && ((G = {}), (B[W.id] = G));
    let X = G[Z];
    return X === void 0 && ((X = x(p())), (G[Z] = X)), X;
  }
  function x(D) {
    const W = [],
      Y = [],
      Z = [];
    for (let B = 0; B < i; B++) (W[B] = 0), (Y[B] = 0), (Z[B] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: W,
      enabledAttributes: Y,
      attributeDivisors: Z,
      object: D,
      attributes: {},
      index: null,
    };
  }
  function m(D, W, Y, Z) {
    const B = f.attributes,
      G = W.attributes;
    let X = 0;
    const te = Y.getAttributes();
    for (const oe in te)
      if (te[oe].location >= 0) {
        const ae = B[oe];
        let Se = G[oe];
        if (
          (Se === void 0 &&
            (oe === "instanceMatrix" &&
              D.instanceMatrix &&
              (Se = D.instanceMatrix),
            oe === "instanceColor" &&
              D.instanceColor &&
              (Se = D.instanceColor)),
          ae === void 0 || ae.attribute !== Se || (Se && ae.data !== Se.data))
        )
          return !0;
        X++;
      }
    return f.attributesNum !== X || f.index !== Z;
  }
  function w(D, W, Y, Z) {
    const B = {},
      G = W.attributes;
    let X = 0;
    const te = Y.getAttributes();
    for (const oe in te)
      if (te[oe].location >= 0) {
        let ae = G[oe];
        ae === void 0 &&
          (oe === "instanceMatrix" &&
            D.instanceMatrix &&
            (ae = D.instanceMatrix),
          oe === "instanceColor" && D.instanceColor && (ae = D.instanceColor));
        const Se = {};
        (Se.attribute = ae),
          ae && ae.data && (Se.data = ae.data),
          (B[oe] = Se),
          X++;
      }
    (f.attributes = B), (f.attributesNum = X), (f.index = Z);
  }
  function S() {
    const D = f.newAttributes;
    for (let W = 0, Y = D.length; W < Y; W++) D[W] = 0;
  }
  function E(D) {
    T(D, 0);
  }
  function T(D, W) {
    const Y = f.newAttributes,
      Z = f.enabledAttributes,
      B = f.attributeDivisors;
    (Y[D] = 1),
      Z[D] === 0 && (t.enableVertexAttribArray(D), (Z[D] = 1)),
      B[D] !== W &&
        ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](D, W),
        (B[D] = W));
  }
  function A() {
    const D = f.newAttributes,
      W = f.enabledAttributes;
    for (let Y = 0, Z = W.length; Y < Z; Y++)
      W[Y] !== D[Y] && (t.disableVertexAttribArray(Y), (W[Y] = 0));
  }
  function L(D, W, Y, Z, B, G, X) {
    X === !0
      ? t.vertexAttribIPointer(D, W, Y, B, G)
      : t.vertexAttribPointer(D, W, Y, Z, B, G);
  }
  function N(D, W, Y, Z) {
    if (
      r.isWebGL2 === !1 &&
      (D.isInstancedMesh || Z.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    S();
    const B = Z.attributes,
      G = Y.getAttributes(),
      X = W.defaultAttributeValues;
    for (const te in G) {
      const oe = G[te];
      if (oe.location >= 0) {
        let J = B[te];
        if (
          (J === void 0 &&
            (te === "instanceMatrix" &&
              D.instanceMatrix &&
              (J = D.instanceMatrix),
            te === "instanceColor" && D.instanceColor && (J = D.instanceColor)),
          J !== void 0)
        ) {
          const ae = J.normalized,
            Se = J.itemSize,
            Ie = n.get(J);
          if (Ie === void 0) continue;
          const Ce = Ie.buffer,
            et = Ie.type,
            We = Ie.bytesPerElement,
            Me =
              r.isWebGL2 === !0 &&
              (et === t.INT || et === t.UNSIGNED_INT || J.gpuType === Gw);
          if (J.isInterleavedBufferAttribute) {
            const Le = J.data,
              H = Le.stride,
              pe = J.offset;
            if (Le.isInstancedInterleavedBuffer) {
              for (let ie = 0; ie < oe.locationSize; ie++)
                T(oe.location + ie, Le.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                Z._maxInstanceCount === void 0 &&
                (Z._maxInstanceCount = Le.meshPerAttribute * Le.count);
            } else
              for (let ie = 0; ie < oe.locationSize; ie++) E(oe.location + ie);
            t.bindBuffer(t.ARRAY_BUFFER, Ce);
            for (let ie = 0; ie < oe.locationSize; ie++)
              L(
                oe.location + ie,
                Se / oe.locationSize,
                et,
                ae,
                H * We,
                (pe + (Se / oe.locationSize) * ie) * We,
                Me
              );
          } else {
            if (J.isInstancedBufferAttribute) {
              for (let Le = 0; Le < oe.locationSize; Le++)
                T(oe.location + Le, J.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                Z._maxInstanceCount === void 0 &&
                (Z._maxInstanceCount = J.meshPerAttribute * J.count);
            } else
              for (let Le = 0; Le < oe.locationSize; Le++) E(oe.location + Le);
            t.bindBuffer(t.ARRAY_BUFFER, Ce);
            for (let Le = 0; Le < oe.locationSize; Le++)
              L(
                oe.location + Le,
                Se / oe.locationSize,
                et,
                ae,
                Se * We,
                (Se / oe.locationSize) * Le * We,
                Me
              );
          }
        } else if (X !== void 0) {
          const ae = X[te];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                t.vertexAttrib2fv(oe.location, ae);
                break;
              case 3:
                t.vertexAttrib3fv(oe.location, ae);
                break;
              case 4:
                t.vertexAttrib4fv(oe.location, ae);
                break;
              default:
                t.vertexAttrib1fv(oe.location, ae);
            }
        }
      }
    }
    A();
  }
  function C() {
    R();
    for (const D in a) {
      const W = a[D];
      for (const Y in W) {
        const Z = W[Y];
        for (const B in Z) v(Z[B].object), delete Z[B];
        delete W[Y];
      }
      delete a[D];
    }
  }
  function I(D) {
    if (a[D.id] === void 0) return;
    const W = a[D.id];
    for (const Y in W) {
      const Z = W[Y];
      for (const B in Z) v(Z[B].object), delete Z[B];
      delete W[Y];
    }
    delete a[D.id];
  }
  function k(D) {
    for (const W in a) {
      const Y = a[W];
      if (Y[D.id] === void 0) continue;
      const Z = Y[D.id];
      for (const B in Z) v(Z[B].object), delete Z[B];
      delete Y[D.id];
    }
  }
  function R() {
    $(), (d = !0), f !== l && ((f = l), g(f.object));
  }
  function $() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: h,
    reset: R,
    resetDefaultState: $,
    dispose: C,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: k,
    initAttributes: S,
    enableAttribute: E,
    disableUnusedAttributes: A,
  };
}
function GH(t, e, n, r) {
  const i = r.isWebGL2;
  let s;
  function o(d) {
    s = d;
  }
  function a(d, h) {
    t.drawArrays(s, d, h), n.update(h, s, 1);
  }
  function l(d, h, p) {
    if (p === 0) return;
    let g, v;
    if (i) (g = t), (v = "drawArraysInstanced");
    else if (
      ((g = e.get("ANGLE_instanced_arrays")),
      (v = "drawArraysInstancedANGLE"),
      g === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    g[v](s, d, h, p), n.update(h, s, p);
  }
  function f(d, h, p) {
    if (p === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null) for (let v = 0; v < p; v++) this.render(d[v], h[v]);
    else {
      g.multiDrawArraysWEBGL(s, d, 0, h, 0, p);
      let v = 0;
      for (let _ = 0; _ < p; _++) v += h[_];
      n.update(v, s, 1);
    }
  }
  (this.setMode = o),
    (this.render = a),
    (this.renderInstances = l),
    (this.renderMultiDraw = f);
}
function jH(t, e, n) {
  let r;
  function i() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const L = e.get("EXT_texture_filter_anisotropic");
      r = t.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function s(L) {
    if (L === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      L = "mediump";
    }
    return L === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    t.constructor.name === "WebGL2RenderingContext";
  let a = n.precision !== void 0 ? n.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const f = o || e.has("WEBGL_draw_buffers"),
    d = n.logarithmicDepthBuffer === !0,
    h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    p = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    g = t.getParameter(t.MAX_TEXTURE_SIZE),
    v = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    _ = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    x = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    m = t.getParameter(t.MAX_VARYING_VECTORS),
    w = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    S = p > 0,
    E = o || e.has("OES_texture_float"),
    T = S && E,
    A = o ? t.getParameter(t.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: f,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: d,
    maxTextures: h,
    maxVertexTextures: p,
    maxTextureSize: g,
    maxCubemapSize: v,
    maxAttributes: _,
    maxVertexUniforms: x,
    maxVaryings: m,
    maxFragmentUniforms: w,
    vertexTextures: S,
    floatFragmentTextures: E,
    floatVertexTextures: T,
    maxSamples: A,
  };
}
function $H(t) {
  const e = this;
  let n = null,
    r = 0,
    i = !1,
    s = !1;
  const o = new ao(),
    a = new Et(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, p) {
      const g = h.length !== 0 || p || r !== 0 || i;
      return (i = p), (r = h.length), g;
    }),
    (this.beginShadows = function () {
      (s = !0), d(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, p) {
      n = d(h, p, 0);
    }),
    (this.setState = function (h, p, g) {
      const v = h.clippingPlanes,
        _ = h.clipIntersection,
        x = h.clipShadows,
        m = t.get(h);
      if (!i || v === null || v.length === 0 || (s && !x)) s ? d(null) : f();
      else {
        const w = s ? 0 : r,
          S = w * 4;
        let E = m.clippingState || null;
        (l.value = E), (E = d(v, p, S, g));
        for (let T = 0; T !== S; ++T) E[T] = n[T];
        (m.clippingState = E),
          (this.numIntersection = _ ? this.numPlanes : 0),
          (this.numPlanes += w);
      }
    });
  function f() {
    l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function d(h, p, g, v) {
    const _ = h !== null ? h.length : 0;
    let x = null;
    if (_ !== 0) {
      if (((x = l.value), v !== !0 || x === null)) {
        const m = g + _ * 4,
          w = p.matrixWorldInverse;
        a.getNormalMatrix(w),
          (x === null || x.length < m) && (x = new Float32Array(m));
        for (let S = 0, E = g; S !== _; ++S, E += 4)
          o.copy(h[S]).applyMatrix4(w, a),
            o.normal.toArray(x, E),
            (x[E + 3] = o.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = _), (e.numIntersection = 0), x;
  }
}
function XH(t) {
  let e = new WeakMap();
  function n(o, a) {
    return a === Cd ? (o.mapping = So) : a === Rd && (o.mapping = ya), o;
  }
  function r(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Cd || a === Rd)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return n(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const f = new KI(l.height / 2);
            return (
              f.fromEquirectangularTexture(t, o),
              e.set(o, f),
              o.addEventListener("dispose", i),
              n(f.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: r, dispose: s };
}
class da extends oh {
  constructor(e = -1, n = 1, r = 1, i = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = n),
      (this.top = r),
      (this.bottom = i),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, n, r, i, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      n = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = r - e,
      o = r + e,
      a = i + n,
      l = i - n;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom,
        d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += f * this.view.offsetX),
        (o = s + f * this.view.width),
        (a -= d * this.view.offsetY),
        (l = a - d * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.zoom = this.zoom),
      (n.object.left = this.left),
      (n.object.right = this.right),
      (n.object.top = this.top),
      (n.object.bottom = this.bottom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      n
    );
  }
}
const qu = 4,
  RA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  sl = 20,
  Bx = new da(),
  PA = new qe();
let Hx = null,
  Vx = 0,
  Wx = 0;
const nl = (1 + Math.sqrt(5)) / 2,
  yu = 1 / nl,
  LA = [
    new z(1, 1, 1),
    new z(-1, 1, 1),
    new z(1, 1, -1),
    new z(-1, 1, -1),
    new z(0, nl, yu),
    new z(0, nl, -yu),
    new z(yu, 0, nl),
    new z(-yu, 0, nl),
    new z(nl, yu, 0),
    new z(-nl, yu, 0),
  ];
class s1 {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, r = 0.1, i = 100) {
    (Hx = this._renderer.getRenderTarget()),
      (Vx = this._renderer.getActiveCubeFace()),
      (Wx = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, s),
      n > 0 && this._blur(s, 0, 0, n),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = OA()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = NA()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Hx, Vx, Wx),
      (e.scissorTest = !1),
      nm(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === So || e.mapping === ya
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Hx = this._renderer.getRenderTarget()),
      (Vx = this._renderer.getActiveCubeFace()),
      (Wx = this._renderer.getActiveMipmapLevel());
    const r = n || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      n = 4 * this._cubeSize,
      r = {
        magFilter: Rn,
        minFilter: Rn,
        generateMipmaps: !1,
        type: xc,
        format: zr,
        colorSpace: zs,
        depthBuffer: !1,
      },
      i = IA(e, n, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== n
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = IA(e, n, r));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = YH(s)),
        (this._blurMaterial = qH(s, e, n));
    }
    return i;
  }
  _compileMaterial(e) {
    const n = new jn(this._lodPlanes[0], e);
    this._renderer.compile(n, Bx);
  }
  _sceneToCubeUV(e, n, r, i) {
    const a = new Pn(90, 1, n, r),
      l = [1, -1, 1, 1, 1, 1],
      f = [1, 1, 1, -1, -1, -1],
      d = this._renderer,
      h = d.autoClear,
      p = d.toneMapping;
    d.getClearColor(PA), (d.toneMapping = Ds), (d.autoClear = !1);
    const g = new Ta({
        name: "PMREM.Background",
        side: Hr,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new jn(new Ul(), g);
    let _ = !1;
    const x = e.background;
    x
      ? x.isColor && (g.color.copy(x), (e.background = null), (_ = !0))
      : (g.color.copy(PA), (_ = !0));
    for (let m = 0; m < 6; m++) {
      const w = m % 3;
      w === 0
        ? (a.up.set(0, l[m], 0), a.lookAt(f[m], 0, 0))
        : w === 1
        ? (a.up.set(0, 0, l[m]), a.lookAt(0, f[m], 0))
        : (a.up.set(0, l[m], 0), a.lookAt(0, 0, f[m]));
      const S = this._cubeSize;
      nm(i, w * S, m > 2 ? S : 0, S, S),
        d.setRenderTarget(i),
        _ && d.render(v, a),
        d.render(e, a);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (d.toneMapping = p),
      (d.autoClear = h),
      (e.background = x);
  }
  _textureToCubeUV(e, n) {
    const r = this._renderer,
      i = e.mapping === So || e.mapping === ya;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = OA()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = NA());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new jn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    nm(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(o, Bx);
  }
  _applyPMREM(e) {
    const n = this._renderer,
      r = n.autoClear;
    n.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        o = LA[(i - 1) % LA.length];
      this._blur(e, i - 1, i, s, o);
    }
    n.autoClear = r;
  }
  _blur(e, n, r, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, n, r, i, "latitudinal", s),
      this._halfBlur(o, e, r, r, i, "longitudinal", s);
  }
  _halfBlur(e, n, r, i, s, o, a) {
    const l = this._renderer,
      f = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const d = 3,
      h = new jn(this._lodPlanes[i], f),
      p = f.uniforms,
      g = this._sizeLods[r] - 1,
      v = isFinite(s) ? Math.PI / (2 * g) : (2 * Math.PI) / (2 * sl - 1),
      _ = s / v,
      x = isFinite(s) ? 1 + Math.floor(d * _) : sl;
    x > sl &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${sl}`
      );
    const m = [];
    let w = 0;
    for (let L = 0; L < sl; ++L) {
      const N = L / _,
        C = Math.exp((-N * N) / 2);
      m.push(C), L === 0 ? (w += C) : L < x && (w += 2 * C);
    }
    for (let L = 0; L < m.length; L++) m[L] = m[L] / w;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = m),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: S } = this;
    (p.dTheta.value = v), (p.mipInt.value = S - r);
    const E = this._sizeLods[i],
      T = 3 * E * (i > S - qu ? i - S + qu : 0),
      A = 4 * (this._cubeSize - E);
    nm(n, T, A, 3 * E, 2 * E), l.setRenderTarget(n), l.render(h, Bx);
  }
}
function YH(t) {
  const e = [],
    n = [],
    r = [];
  let i = t;
  const s = t - qu + 1 + RA.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, i);
    n.push(a);
    let l = 1 / a;
    o > t - qu ? (l = RA[o - t + qu - 1]) : o === 0 && (l = 0), r.push(l);
    const f = 1 / (a - 2),
      d = -f,
      h = 1 + f,
      p = [d, d, h, d, h, h, d, d, h, h, d, h],
      g = 6,
      v = 6,
      _ = 3,
      x = 2,
      m = 1,
      w = new Float32Array(_ * v * g),
      S = new Float32Array(x * v * g),
      E = new Float32Array(m * v * g);
    for (let A = 0; A < g; A++) {
      const L = ((A % 3) * 2) / 3 - 1,
        N = A > 2 ? 0 : -1,
        C = [
          L,
          N,
          0,
          L + 2 / 3,
          N,
          0,
          L + 2 / 3,
          N + 1,
          0,
          L,
          N,
          0,
          L + 2 / 3,
          N + 1,
          0,
          L,
          N + 1,
          0,
        ];
      w.set(C, _ * v * A), S.set(p, x * v * A);
      const I = [A, A, A, A, A, A];
      E.set(I, m * v * A);
    }
    const T = new bt();
    T.setAttribute("position", new $t(w, _)),
      T.setAttribute("uv", new $t(S, x)),
      T.setAttribute("faceIndex", new $t(E, m)),
      e.push(T),
      i > qu && i--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: r };
}
function IA(t, e, n) {
  const r = new cs(t, e, n);
  return (
    (r.texture.mapping = Ic),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function nm(t, e, n, r, i) {
  t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
}
function qH(t, e, n) {
  const r = new Float32Array(sl),
    i = new z(0, 1, 0);
  return new Bs({
    name: "SphericalGaussianBlur",
    defines: {
      n: sl,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: sM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: po,
    depthTest: !1,
    depthWrite: !1,
  });
}
function NA() {
  return new Bs({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: sM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: po,
    depthTest: !1,
    depthWrite: !1,
  });
}
function OA() {
  return new Bs({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: sM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: po,
    depthTest: !1,
    depthWrite: !1,
  });
}
function sM() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function KH(t) {
  let e = new WeakMap(),
    n = null;
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        f = l === Cd || l === Rd,
        d = l === So || l === ya;
      if (f || d)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let h = e.get(a);
          return (
            n === null && (n = new s1(t)),
            (h = f ? n.fromEquirectangular(a, h) : n.fromCubemap(a, h)),
            e.set(a, h),
            h.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const h = a.image;
            if ((f && h && h.height > 0) || (d && h && i(h))) {
              n === null && (n = new s1(t));
              const p = f ? n.fromEquirectangular(a) : n.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const f = 6;
    for (let d = 0; d < f; d++) a[d] !== void 0 && l++;
    return l === f;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const f = e.get(l);
    f !== void 0 && (e.delete(l), f.dispose());
  }
  function o() {
    (e = new WeakMap()), n !== null && (n.dispose(), (n = null));
  }
  return { get: r, dispose: o };
}
function ZH(t) {
  const e = {};
  function n(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = t.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return n(r) !== null;
    },
    init: function (r) {
      r.isWebGL2
        ? n("EXT_color_buffer_float")
        : (n("WEBGL_depth_texture"),
          n("OES_texture_float"),
          n("OES_texture_half_float"),
          n("OES_texture_half_float_linear"),
          n("OES_standard_derivatives"),
          n("OES_element_index_uint"),
          n("OES_vertex_array_object"),
          n("ANGLE_instanced_arrays")),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      const i = n(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function JH(t, e, n, r) {
  const i = {},
    s = new WeakMap();
  function o(h) {
    const p = h.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    for (const v in p.morphAttributes) {
      const _ = p.morphAttributes[v];
      for (let x = 0, m = _.length; x < m; x++) e.remove(_[x]);
    }
    p.removeEventListener("dispose", o), delete i[p.id];
    const g = s.get(p);
    g && (e.remove(g), s.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      n.memory.geometries--;
  }
  function a(h, p) {
    return (
      i[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (i[p.id] = !0),
        n.memory.geometries++),
      p
    );
  }
  function l(h) {
    const p = h.attributes;
    for (const v in p) e.update(p[v], t.ARRAY_BUFFER);
    const g = h.morphAttributes;
    for (const v in g) {
      const _ = g[v];
      for (let x = 0, m = _.length; x < m; x++) e.update(_[x], t.ARRAY_BUFFER);
    }
  }
  function f(h) {
    const p = [],
      g = h.index,
      v = h.attributes.position;
    let _ = 0;
    if (g !== null) {
      const w = g.array;
      _ = g.version;
      for (let S = 0, E = w.length; S < E; S += 3) {
        const T = w[S + 0],
          A = w[S + 1],
          L = w[S + 2];
        p.push(T, A, A, L, L, T);
      }
    } else if (v !== void 0) {
      const w = v.array;
      _ = v.version;
      for (let S = 0, E = w.length / 3 - 1; S < E; S += 3) {
        const T = S + 0,
          A = S + 1,
          L = S + 2;
        p.push(T, A, A, L, L, T);
      }
    } else return;
    const x = new (WI(p) ? iM : rM)(p, 1);
    x.version = _;
    const m = s.get(h);
    m && e.remove(m), s.set(h, x);
  }
  function d(h) {
    const p = s.get(h);
    if (p) {
      const g = h.index;
      g !== null && p.version < g.version && f(h);
    } else f(h);
    return s.get(h);
  }
  return { get: a, update: l, getWireframeAttribute: d };
}
function QH(t, e, n, r) {
  const i = r.isWebGL2;
  let s;
  function o(g) {
    s = g;
  }
  let a, l;
  function f(g) {
    (a = g.type), (l = g.bytesPerElement);
  }
  function d(g, v) {
    t.drawElements(s, v, a, g * l), n.update(v, s, 1);
  }
  function h(g, v, _) {
    if (_ === 0) return;
    let x, m;
    if (i) (x = t), (m = "drawElementsInstanced");
    else if (
      ((x = e.get("ANGLE_instanced_arrays")),
      (m = "drawElementsInstancedANGLE"),
      x === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    x[m](s, v, a, g * l, _), n.update(v, s, _);
  }
  function p(g, v, _) {
    if (_ === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let m = 0; m < _; m++) this.render(g[m] / l, v[m]);
    else {
      x.multiDrawElementsWEBGL(s, v, 0, a, g, 0, _);
      let m = 0;
      for (let w = 0; w < _; w++) m += v[w];
      n.update(m, s, 1);
    }
  }
  (this.setMode = o),
    (this.setIndex = f),
    (this.render = d),
    (this.renderInstances = h),
    (this.renderMultiDraw = p);
}
function eV(t) {
  const e = { geometries: 0, textures: 0 },
    n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(s, o, a) {
    switch ((n.calls++, o)) {
      case t.TRIANGLES:
        n.triangles += a * (s / 3);
        break;
      case t.LINES:
        n.lines += a * (s / 2);
        break;
      case t.LINE_STRIP:
        n.lines += a * (s - 1);
        break;
      case t.LINE_LOOP:
        n.lines += a * s;
        break;
      case t.POINTS:
        n.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function tV(t, e) {
  return t[0] - e[0];
}
function nV(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function rV(t, e, n) {
  const r = {},
    i = new Float32Array(8),
    s = new WeakMap(),
    o = new Gt(),
    a = [];
  for (let f = 0; f < 8; f++) a[f] = [f, 0];
  function l(f, d, h) {
    const p = f.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const v =
          d.morphAttributes.position ||
          d.morphAttributes.normal ||
          d.morphAttributes.color,
        _ = v !== void 0 ? v.length : 0;
      let x = s.get(d);
      if (x === void 0 || x.count !== _) {
        let W = function () {
          $.dispose(), s.delete(d), d.removeEventListener("dispose", W);
        };
        var g = W;
        x !== void 0 && x.texture.dispose();
        const S = d.morphAttributes.position !== void 0,
          E = d.morphAttributes.normal !== void 0,
          T = d.morphAttributes.color !== void 0,
          A = d.morphAttributes.position || [],
          L = d.morphAttributes.normal || [],
          N = d.morphAttributes.color || [];
        let C = 0;
        S === !0 && (C = 1), E === !0 && (C = 2), T === !0 && (C = 3);
        let I = d.attributes.position.count * C,
          k = 1;
        I > e.maxTextureSize &&
          ((k = Math.ceil(I / e.maxTextureSize)), (I = e.maxTextureSize));
        const R = new Float32Array(I * k * 4 * _),
          $ = new z0(R, I, k, _);
        ($.type = ss), ($.needsUpdate = !0);
        const D = C * 4;
        for (let Y = 0; Y < _; Y++) {
          const Z = A[Y],
            B = L[Y],
            G = N[Y],
            X = I * k * 4 * Y;
          for (let te = 0; te < Z.count; te++) {
            const oe = te * D;
            S === !0 &&
              (o.fromBufferAttribute(Z, te),
              (R[X + oe + 0] = o.x),
              (R[X + oe + 1] = o.y),
              (R[X + oe + 2] = o.z),
              (R[X + oe + 3] = 0)),
              E === !0 &&
                (o.fromBufferAttribute(B, te),
                (R[X + oe + 4] = o.x),
                (R[X + oe + 5] = o.y),
                (R[X + oe + 6] = o.z),
                (R[X + oe + 7] = 0)),
              T === !0 &&
                (o.fromBufferAttribute(G, te),
                (R[X + oe + 8] = o.x),
                (R[X + oe + 9] = o.y),
                (R[X + oe + 10] = o.z),
                (R[X + oe + 11] = G.itemSize === 4 ? o.w : 1));
          }
        }
        (x = { count: _, texture: $, size: new _e(I, k) }),
          s.set(d, x),
          d.addEventListener("dispose", W);
      }
      let m = 0;
      for (let S = 0; S < p.length; S++) m += p[S];
      const w = d.morphTargetsRelative ? 1 : 1 - m;
      h.getUniforms().setValue(t, "morphTargetBaseInfluence", w),
        h.getUniforms().setValue(t, "morphTargetInfluences", p),
        h.getUniforms().setValue(t, "morphTargetsTexture", x.texture, n),
        h.getUniforms().setValue(t, "morphTargetsTextureSize", x.size);
    } else {
      const v = p === void 0 ? 0 : p.length;
      let _ = r[d.id];
      if (_ === void 0 || _.length !== v) {
        _ = [];
        for (let E = 0; E < v; E++) _[E] = [E, 0];
        r[d.id] = _;
      }
      for (let E = 0; E < v; E++) {
        const T = _[E];
        (T[0] = E), (T[1] = p[E]);
      }
      _.sort(nV);
      for (let E = 0; E < 8; E++)
        E < v && _[E][1]
          ? ((a[E][0] = _[E][0]), (a[E][1] = _[E][1]))
          : ((a[E][0] = Number.MAX_SAFE_INTEGER), (a[E][1] = 0));
      a.sort(tV);
      const x = d.morphAttributes.position,
        m = d.morphAttributes.normal;
      let w = 0;
      for (let E = 0; E < 8; E++) {
        const T = a[E],
          A = T[0],
          L = T[1];
        A !== Number.MAX_SAFE_INTEGER && L
          ? (x &&
              d.getAttribute("morphTarget" + E) !== x[A] &&
              d.setAttribute("morphTarget" + E, x[A]),
            m &&
              d.getAttribute("morphNormal" + E) !== m[A] &&
              d.setAttribute("morphNormal" + E, m[A]),
            (i[E] = L),
            (w += L))
          : (x &&
              d.hasAttribute("morphTarget" + E) === !0 &&
              d.deleteAttribute("morphTarget" + E),
            m &&
              d.hasAttribute("morphNormal" + E) === !0 &&
              d.deleteAttribute("morphNormal" + E),
            (i[E] = 0));
      }
      const S = d.morphTargetsRelative ? 1 : 1 - w;
      h.getUniforms().setValue(t, "morphTargetBaseInfluence", S),
        h.getUniforms().setValue(t, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function iV(t, e, n, r) {
  let i = new WeakMap();
  function s(l) {
    const f = r.render.frame,
      d = l.geometry,
      h = e.get(l, d);
    if (
      (i.get(h) !== f && (e.update(h), i.set(h, f)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== f &&
          (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
          i.set(l, f))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      i.get(p) !== f && (p.update(), i.set(p, f));
    }
    return h;
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const f = l.target;
    f.removeEventListener("dispose", a),
      n.remove(f.instanceMatrix),
      f.instanceColor !== null && n.remove(f.instanceColor);
  }
  return { update: s, dispose: o };
}
class oM extends Ln {
  constructor(e, n, r, i, s, o, a, l, f, d) {
    if (((d = d !== void 0 ? d : ca), d !== ca && d !== Rl))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && d === ca && (r = fo),
      r === void 0 && d === Rl && (r = ua),
      super(null, i, s, o, a, l, d, r, f),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: n }),
      (this.magFilter = a !== void 0 ? a : An),
      (this.minFilter = l !== void 0 ? l : An),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (n.compareFunction = this.compareFunction),
      n
    );
  }
}
const JI = new Ln(),
  QI = new oM(1, 1);
QI.compareFunction = Qw;
const e3 = new z0(),
  t3 = new nM(),
  n3 = new ah(),
  DA = [],
  kA = [],
  UA = new Float32Array(16),
  FA = new Float32Array(9),
  zA = new Float32Array(4);
function Nc(t, e, n) {
  const r = t[0];
  if (r <= 0 || r > 0) return t;
  const i = e * n;
  let s = DA[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (DA[i] = s)), e !== 0)) {
    r.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += n), t[o].toArray(s, a);
  }
  return s;
}
function $n(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Xn(t, e) {
  for (let n = 0, r = e.length; n < r; n++) t[n] = e[n];
}
function B0(t, e) {
  let n = kA[e];
  n === void 0 && ((n = new Int32Array(e)), (kA[e] = n));
  for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
  return n;
}
function sV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function oV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if ($n(n, e)) return;
    t.uniform2fv(this.addr, e), Xn(n, e);
  }
}
function aV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if ($n(n, e)) return;
    t.uniform3fv(this.addr, e), Xn(n, e);
  }
}
function lV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if ($n(n, e)) return;
    t.uniform4fv(this.addr, e), Xn(n, e);
  }
}
function uV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if ($n(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Xn(n, e);
  } else {
    if ($n(n, r)) return;
    zA.set(r), t.uniformMatrix2fv(this.addr, !1, zA), Xn(n, r);
  }
}
function cV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if ($n(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Xn(n, e);
  } else {
    if ($n(n, r)) return;
    FA.set(r), t.uniformMatrix3fv(this.addr, !1, FA), Xn(n, r);
  }
}
function fV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if ($n(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Xn(n, e);
  } else {
    if ($n(n, r)) return;
    UA.set(r), t.uniformMatrix4fv(this.addr, !1, UA), Xn(n, r);
  }
}
function dV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function hV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if ($n(n, e)) return;
    t.uniform2iv(this.addr, e), Xn(n, e);
  }
}
function pV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if ($n(n, e)) return;
    t.uniform3iv(this.addr, e), Xn(n, e);
  }
}
function mV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if ($n(n, e)) return;
    t.uniform4iv(this.addr, e), Xn(n, e);
  }
}
function gV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function vV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if ($n(n, e)) return;
    t.uniform2uiv(this.addr, e), Xn(n, e);
  }
}
function yV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if ($n(n, e)) return;
    t.uniform3uiv(this.addr, e), Xn(n, e);
  }
}
function xV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if ($n(n, e)) return;
    t.uniform4uiv(this.addr, e), Xn(n, e);
  }
}
function _V(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i));
  const s = this.type === t.SAMPLER_2D_SHADOW ? QI : JI;
  n.setTexture2D(e || s, i);
}
function SV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture3D(e || t3, i);
}
function wV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTextureCube(e || n3, i);
}
function MV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture2DArray(e || e3, i);
}
function EV(t) {
  switch (t) {
    case 5126:
      return sV;
    case 35664:
      return oV;
    case 35665:
      return aV;
    case 35666:
      return lV;
    case 35674:
      return uV;
    case 35675:
      return cV;
    case 35676:
      return fV;
    case 5124:
    case 35670:
      return dV;
    case 35667:
    case 35671:
      return hV;
    case 35668:
    case 35672:
      return pV;
    case 35669:
    case 35673:
      return mV;
    case 5125:
      return gV;
    case 36294:
      return vV;
    case 36295:
      return yV;
    case 36296:
      return xV;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return _V;
    case 35679:
    case 36299:
    case 36307:
      return SV;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return wV;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return MV;
  }
}
function bV(t, e) {
  t.uniform1fv(this.addr, e);
}
function TV(t, e) {
  const n = Nc(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function AV(t, e) {
  const n = Nc(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function CV(t, e) {
  const n = Nc(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function RV(t, e) {
  const n = Nc(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function PV(t, e) {
  const n = Nc(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function LV(t, e) {
  const n = Nc(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function IV(t, e) {
  t.uniform1iv(this.addr, e);
}
function NV(t, e) {
  t.uniform2iv(this.addr, e);
}
function OV(t, e) {
  t.uniform3iv(this.addr, e);
}
function DV(t, e) {
  t.uniform4iv(this.addr, e);
}
function kV(t, e) {
  t.uniform1uiv(this.addr, e);
}
function UV(t, e) {
  t.uniform2uiv(this.addr, e);
}
function FV(t, e) {
  t.uniform3uiv(this.addr, e);
}
function zV(t, e) {
  t.uniform4uiv(this.addr, e);
}
function BV(t, e, n) {
  const r = this.cache,
    i = e.length,
    s = B0(n, i);
  $n(r, s) || (t.uniform1iv(this.addr, s), Xn(r, s));
  for (let o = 0; o !== i; ++o) n.setTexture2D(e[o] || JI, s[o]);
}
function HV(t, e, n) {
  const r = this.cache,
    i = e.length,
    s = B0(n, i);
  $n(r, s) || (t.uniform1iv(this.addr, s), Xn(r, s));
  for (let o = 0; o !== i; ++o) n.setTexture3D(e[o] || t3, s[o]);
}
function VV(t, e, n) {
  const r = this.cache,
    i = e.length,
    s = B0(n, i);
  $n(r, s) || (t.uniform1iv(this.addr, s), Xn(r, s));
  for (let o = 0; o !== i; ++o) n.setTextureCube(e[o] || n3, s[o]);
}
function WV(t, e, n) {
  const r = this.cache,
    i = e.length,
    s = B0(n, i);
  $n(r, s) || (t.uniform1iv(this.addr, s), Xn(r, s));
  for (let o = 0; o !== i; ++o) n.setTexture2DArray(e[o] || e3, s[o]);
}
function GV(t) {
  switch (t) {
    case 5126:
      return bV;
    case 35664:
      return TV;
    case 35665:
      return AV;
    case 35666:
      return CV;
    case 35674:
      return RV;
    case 35675:
      return PV;
    case 35676:
      return LV;
    case 5124:
    case 35670:
      return IV;
    case 35667:
    case 35671:
      return NV;
    case 35668:
    case 35672:
      return OV;
    case 35669:
    case 35673:
      return DV;
    case 5125:
      return kV;
    case 36294:
      return UV;
    case 36295:
      return FV;
    case 36296:
      return zV;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return BV;
    case 35679:
    case 36299:
    case 36307:
      return HV;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return VV;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return WV;
  }
}
class jV {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.setValue = EV(n.type));
  }
}
class $V {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.size = n.size),
      (this.setValue = GV(n.type));
  }
}
class XV {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, n, r) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const a = i[s];
      a.setValue(e, n[a.id], r);
    }
  }
}
const Gx = /(\w+)(\])?(\[|\.)?/g;
function BA(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function YV(t, e, n) {
  const r = t.name,
    i = r.length;
  for (Gx.lastIndex = 0; ; ) {
    const s = Gx.exec(r),
      o = Gx.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      f = s[3];
    if ((l && (a = a | 0), f === void 0 || (f === "[" && o + 2 === i))) {
      BA(n, f === void 0 ? new jV(a, t, e) : new $V(a, t, e));
      break;
    } else {
      let h = n.map[a];
      h === void 0 && ((h = new XV(a)), BA(n, h)), (n = h);
    }
  }
}
class Qm {
  constructor(e, n) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const s = e.getActiveUniform(n, i),
        o = e.getUniformLocation(n, s.name);
      YV(s, o, this);
    }
  }
  setValue(e, n, r, i) {
    const s = this.map[n];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, n, r) {
    const i = n[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, n, r, i) {
    for (let s = 0, o = n.length; s !== o; ++s) {
      const a = n[s],
        l = r[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, n) {
    const r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in n && r.push(o);
    }
    return r;
  }
}
function HA(t, e, n) {
  const r = t.createShader(e);
  return t.shaderSource(r, n), t.compileShader(r), r;
}
const qV = 37297;
let KV = 0;
function ZV(t, e) {
  const n = t.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, n.length);
  for (let o = i; o < s; o++) {
    const a = o + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${n[o]}`);
  }
  return r.join(`
`);
}
function JV(t) {
  const e = Wt.getPrimaries(Wt.workingColorSpace),
    n = Wt.getPrimaries(t);
  let r;
  switch (
    (e === n
      ? (r = "")
      : e === Ud && n === kd
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === kd && n === Ud && (r = "LinearSRGBToLinearDisplayP3"),
    t)
  ) {
    case zs:
    case ih:
      return [r, "LinearTransferOETF"];
    case Wn:
    case F0:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", t),
        [r, "LinearTransferOETF"]
      );
  }
}
function VA(t, e, n) {
  const r = t.getShaderParameter(e, t.COMPILE_STATUS),
    i = t.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const o = parseInt(s[1]);
    return (
      n.toUpperCase() +
      `

` +
      i +
      `

` +
      ZV(t.getShaderSource(e), o)
    );
  } else return i;
}
function QV(t, e) {
  const n = JV(e);
  return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
}
function eW(t, e) {
  let n;
  switch (e) {
    case vI:
      n = "Linear";
      break;
    case yI:
      n = "Reinhard";
      break;
    case xI:
      n = "OptimizedCineon";
      break;
    case Vw:
      n = "ACESFilmic";
      break;
    case _I:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function tW(t) {
  return [
    t.extensionDerivatives ||
    t.envMapCubeUVHeight ||
    t.bumpMap ||
    t.normalMapTangentSpace ||
    t.clearcoatNormalMap ||
    t.flatShading ||
    t.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
    t.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
    t.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(zf).join(`
`);
}
function nW(t) {
  const e = [];
  for (const n in t) {
    const r = t[n];
    r !== !1 && e.push("#define " + n + " " + r);
  }
  return e.join(`
`);
}
function rW(t, e) {
  const n = {},
    r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const s = t.getActiveAttrib(e, i),
      o = s.name;
    let a = 1;
    s.type === t.FLOAT_MAT2 && (a = 2),
      s.type === t.FLOAT_MAT3 && (a = 3),
      s.type === t.FLOAT_MAT4 && (a = 4),
      (n[o] = {
        type: s.type,
        location: t.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return n;
}
function zf(t) {
  return t !== "";
}
function WA(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function GA(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const iW = /^[ \t]*#include +<([\w\d./]+)>/gm;
function o1(t) {
  return t.replace(iW, oW);
}
const sW = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function oW(t, e) {
  let n = _t[e];
  if (n === void 0) {
    const r = sW.get(e);
    if (r !== void 0)
      (n = _t[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return o1(n);
}
const aW =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function jA(t) {
  return t.replace(aW, lW);
}
function lW(t, e, n, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(n); s++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function $A(t) {
  let e =
    "precision " +
    t.precision +
    ` float;
precision ` +
    t.precision +
    " int;";
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function uW(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === O0
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === Jf
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === es && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function cW(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case So:
      case ya:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ic:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function fW(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case ya:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function dW(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case rh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case mI:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case gI:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function hW(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
    texelHeight: r,
    maxMip: n,
  };
}
function pW(t, e, n, r) {
  const i = t.getContext(),
    s = n.defines;
  let o = n.vertexShader,
    a = n.fragmentShader;
  const l = uW(n),
    f = cW(n),
    d = fW(n),
    h = dW(n),
    p = hW(n),
    g = n.isWebGL2 ? "" : tW(n),
    v = nW(s),
    _ = i.createProgram();
  let x,
    m,
    w = n.glslVersion
      ? "#version " +
        n.glslVersion +
        `
`
      : "";
  n.isRawShaderMaterial
    ? ((x = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
      ].filter(zf).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (m = [
        g,
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
      ].filter(zf).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((x = [
        $A(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
        n.batching ? "#define USE_BATCHING" : "",
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + d : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.mapUv ? "#define MAP_UV " + n.mapUv : "",
        n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
        n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
        n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
        n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
        n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
        n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
        n.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
          : "",
        n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
        n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
        n.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
          : "",
        n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
        n.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
          : "",
        n.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
          : "",
        n.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
          : "",
        n.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
          : "",
        n.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
          : "",
        n.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
          : "",
        n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
        n.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
          : "",
        n.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
          : "",
        n.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
          : "",
        n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && n.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(zf).join(`
`)),
      (m = [
        g,
        $A(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + f : "",
        n.envMap ? "#define " + d : "",
        n.envMap ? "#define " + h : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescence ? "#define USE_IRIDESCENCE" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        n.toneMapping !== Ds ? "#define TONE_MAPPING" : "",
        n.toneMapping !== Ds ? _t.tonemapping_pars_fragment : "",
        n.toneMapping !== Ds ? eW("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        n.opaque ? "#define OPAQUE" : "",
        _t.colorspace_pars_fragment,
        QV("linearToOutputTexel", n.outputColorSpace),
        n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        `
`,
      ].filter(zf).join(`
`))),
    (o = o1(o)),
    (o = WA(o, n)),
    (o = GA(o, n)),
    (a = o1(a)),
    (a = WA(a, n)),
    (a = GA(a, n)),
    (o = jA(o)),
    (a = jA(a)),
    n.isWebGL2 &&
      n.isRawShaderMaterial !== !0 &&
      ((w = `#version 300 es
`),
      (x =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (m =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          n.glslVersion === r1
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === r1 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        m));
  const S = w + x + o,
    E = w + m + a,
    T = HA(i, i.VERTEX_SHADER, S),
    A = HA(i, i.FRAGMENT_SHADER, E);
  i.attachShader(_, T),
    i.attachShader(_, A),
    n.index0AttributeName !== void 0
      ? i.bindAttribLocation(_, 0, n.index0AttributeName)
      : n.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"),
    i.linkProgram(_);
  function L(k) {
    if (t.debug.checkShaderErrors) {
      const R = i.getProgramInfoLog(_).trim(),
        $ = i.getShaderInfoLog(T).trim(),
        D = i.getShaderInfoLog(A).trim();
      let W = !0,
        Y = !0;
      if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
        if (((W = !1), typeof t.debug.onShaderError == "function"))
          t.debug.onShaderError(i, _, T, A);
        else {
          const Z = VA(i, T, "vertex"),
            B = VA(i, A, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(_, i.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              R +
              `
` +
              Z +
              `
` +
              B
          );
        }
      else
        R !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", R)
          : ($ === "" || D === "") && (Y = !1);
      Y &&
        (k.diagnostics = {
          runnable: W,
          programLog: R,
          vertexShader: { log: $, prefix: x },
          fragmentShader: { log: D, prefix: m },
        });
    }
    i.deleteShader(T), i.deleteShader(A), (N = new Qm(i, _)), (C = rW(i, _));
  }
  let N;
  this.getUniforms = function () {
    return N === void 0 && L(this), N;
  };
  let C;
  this.getAttributes = function () {
    return C === void 0 && L(this), C;
  };
  let I = n.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return I === !1 && (I = i.getProgramParameter(_, qV)), I;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(_),
        (this.program = void 0);
    }),
    (this.type = n.shaderType),
    (this.name = n.shaderName),
    (this.id = KV++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = _),
    (this.vertexShader = T),
    (this.fragmentShader = A),
    this
  );
}
let mW = 0;
class gW {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const n = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(n),
      s = this._getShaderStage(r),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const r of n)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let r = n.get(e);
    return r === void 0 && ((r = new Set()), n.set(e, r)), r;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let r = n.get(e);
    return r === void 0 && ((r = new vW(e)), n.set(e, r)), r;
  }
}
class vW {
  constructor(e) {
    (this.id = mW++), (this.code = e), (this.usedTimes = 0);
  }
}
function yW(t, e, n, r, i, s, o) {
  const a = new _l(),
    l = new gW(),
    f = [],
    d = i.isWebGL2,
    h = i.logarithmicDepthBuffer,
    p = i.vertexTextures;
  let g = i.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function _(C) {
    return C === 0 ? "uv" : `uv${C}`;
  }
  function x(C, I, k, R, $) {
    const D = R.fog,
      W = $.geometry,
      Y = C.isMeshStandardMaterial ? R.environment : null,
      Z = (C.isMeshStandardMaterial ? n : e).get(C.envMap || Y),
      B = Z && Z.mapping === Ic ? Z.image.height : null,
      G = v[C.type];
    C.precision !== null &&
      ((g = i.getMaxPrecision(C.precision)),
      g !== C.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          C.precision,
          "not supported, using",
          g,
          "instead."
        ));
    const X =
        W.morphAttributes.position ||
        W.morphAttributes.normal ||
        W.morphAttributes.color,
      te = X !== void 0 ? X.length : 0;
    let oe = 0;
    W.morphAttributes.position !== void 0 && (oe = 1),
      W.morphAttributes.normal !== void 0 && (oe = 2),
      W.morphAttributes.color !== void 0 && (oe = 3);
    let J, ae, Se, Ie;
    if (G) {
      const sn = rs[G];
      (J = sn.vertexShader), (ae = sn.fragmentShader);
    } else
      (J = C.vertexShader),
        (ae = C.fragmentShader),
        l.update(C),
        (Se = l.getVertexShaderID(C)),
        (Ie = l.getFragmentShaderID(C));
    const Ce = t.getRenderTarget(),
      et = $.isInstancedMesh === !0,
      We = $.isBatchedMesh === !0,
      Me = !!C.map,
      Le = !!C.matcap,
      H = !!Z,
      pe = !!C.aoMap,
      ie = !!C.lightMap,
      we = !!C.bumpMap,
      xe = !!C.normalMap,
      $e = !!C.displacementMap,
      Fe = !!C.emissiveMap,
      He = !!C.metalnessMap,
      Ze = !!C.roughnessMap,
      it = C.anisotropy > 0,
      Tt = C.clearcoat > 0,
      V = C.iridescence > 0,
      O = C.sheen > 0,
      se = C.transmission > 0,
      Re = it && !!C.anisotropyMap,
      Ee = Tt && !!C.clearcoatMap,
      Ae = Tt && !!C.clearcoatNormalMap,
      Ye = Tt && !!C.clearcoatRoughnessMap,
      Pe = V && !!C.iridescenceMap,
      Te = V && !!C.iridescenceThicknessMap,
      at = O && !!C.sheenColorMap,
      wt = O && !!C.sheenRoughnessMap,
      Ne = !!C.specularMap,
      Pt = !!C.specularColorMap,
      q = !!C.specularIntensityMap,
      me = se && !!C.transmissionMap,
      be = se && !!C.thicknessMap,
      ue = !!C.gradientMap,
      Be = !!C.alphaMap,
      K = C.alphaTest > 0,
      ze = !!C.alphaHash,
      ke = !!C.extensions,
      ye = !!W.attributes.uv1,
      Oe = !!W.attributes.uv2,
      nt = !!W.attributes.uv3;
    let xt = Ds;
    return (
      C.toneMapped &&
        (Ce === null || Ce.isXRRenderTarget === !0) &&
        (xt = t.toneMapping),
      {
        isWebGL2: d,
        shaderID: G,
        shaderType: C.type,
        shaderName: C.name,
        vertexShader: J,
        fragmentShader: ae,
        defines: C.defines,
        customVertexShaderID: Se,
        customFragmentShaderID: Ie,
        isRawShaderMaterial: C.isRawShaderMaterial === !0,
        glslVersion: C.glslVersion,
        precision: g,
        batching: We,
        instancing: et,
        instancingColor: et && $.instanceColor !== null,
        supportsVertexTextures: p,
        outputColorSpace:
          Ce === null
            ? t.outputColorSpace
            : Ce.isXRRenderTarget === !0
            ? Ce.texture.colorSpace
            : zs,
        map: Me,
        matcap: Le,
        envMap: H,
        envMapMode: H && Z.mapping,
        envMapCubeUVHeight: B,
        aoMap: pe,
        lightMap: ie,
        bumpMap: we,
        normalMap: xe,
        displacementMap: p && $e,
        emissiveMap: Fe,
        normalMapObjectSpace: xe && C.normalMapType === DI,
        normalMapTangentSpace: xe && C.normalMapType === ba,
        metalnessMap: He,
        roughnessMap: Ze,
        anisotropy: it,
        anisotropyMap: Re,
        clearcoat: Tt,
        clearcoatMap: Ee,
        clearcoatNormalMap: Ae,
        clearcoatRoughnessMap: Ye,
        iridescence: V,
        iridescenceMap: Pe,
        iridescenceThicknessMap: Te,
        sheen: O,
        sheenColorMap: at,
        sheenRoughnessMap: wt,
        specularMap: Ne,
        specularColorMap: Pt,
        specularIntensityMap: q,
        transmission: se,
        transmissionMap: me,
        thicknessMap: be,
        gradientMap: ue,
        opaque: C.transparent === !1 && C.blending === yl,
        alphaMap: Be,
        alphaTest: K,
        alphaHash: ze,
        combine: C.combine,
        mapUv: Me && _(C.map.channel),
        aoMapUv: pe && _(C.aoMap.channel),
        lightMapUv: ie && _(C.lightMap.channel),
        bumpMapUv: we && _(C.bumpMap.channel),
        normalMapUv: xe && _(C.normalMap.channel),
        displacementMapUv: $e && _(C.displacementMap.channel),
        emissiveMapUv: Fe && _(C.emissiveMap.channel),
        metalnessMapUv: He && _(C.metalnessMap.channel),
        roughnessMapUv: Ze && _(C.roughnessMap.channel),
        anisotropyMapUv: Re && _(C.anisotropyMap.channel),
        clearcoatMapUv: Ee && _(C.clearcoatMap.channel),
        clearcoatNormalMapUv: Ae && _(C.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: Ye && _(C.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Pe && _(C.iridescenceMap.channel),
        iridescenceThicknessMapUv: Te && _(C.iridescenceThicknessMap.channel),
        sheenColorMapUv: at && _(C.sheenColorMap.channel),
        sheenRoughnessMapUv: wt && _(C.sheenRoughnessMap.channel),
        specularMapUv: Ne && _(C.specularMap.channel),
        specularColorMapUv: Pt && _(C.specularColorMap.channel),
        specularIntensityMapUv: q && _(C.specularIntensityMap.channel),
        transmissionMapUv: me && _(C.transmissionMap.channel),
        thicknessMapUv: be && _(C.thicknessMap.channel),
        alphaMapUv: Be && _(C.alphaMap.channel),
        vertexTangents: !!W.attributes.tangent && (xe || it),
        vertexColors: C.vertexColors,
        vertexAlphas:
          C.vertexColors === !0 &&
          !!W.attributes.color &&
          W.attributes.color.itemSize === 4,
        vertexUv1s: ye,
        vertexUv2s: Oe,
        vertexUv3s: nt,
        pointsUvs: $.isPoints === !0 && !!W.attributes.uv && (Me || Be),
        fog: !!D,
        useFog: C.fog === !0,
        fogExp2: D && D.isFogExp2,
        flatShading: C.flatShading === !0,
        sizeAttenuation: C.sizeAttenuation === !0,
        logarithmicDepthBuffer: h,
        skinning: $.isSkinnedMesh === !0,
        morphTargets: W.morphAttributes.position !== void 0,
        morphNormals: W.morphAttributes.normal !== void 0,
        morphColors: W.morphAttributes.color !== void 0,
        morphTargetsCount: te,
        morphTextureStride: oe,
        numDirLights: I.directional.length,
        numPointLights: I.point.length,
        numSpotLights: I.spot.length,
        numSpotLightMaps: I.spotLightMap.length,
        numRectAreaLights: I.rectArea.length,
        numHemiLights: I.hemi.length,
        numDirLightShadows: I.directionalShadowMap.length,
        numPointLightShadows: I.pointShadowMap.length,
        numSpotLightShadows: I.spotShadowMap.length,
        numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
        numLightProbes: I.numLightProbes,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: C.dithering,
        shadowMapEnabled: t.shadowMap.enabled && k.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: xt,
        useLegacyLights: t._useLegacyLights,
        decodeVideoTexture:
          Me &&
          C.map.isVideoTexture === !0 &&
          Wt.getTransfer(C.map.colorSpace) === Jt,
        premultipliedAlpha: C.premultipliedAlpha,
        doubleSided: C.side === Ps,
        flipSided: C.side === Hr,
        useDepthPacking: C.depthPacking >= 0,
        depthPacking: C.depthPacking || 0,
        index0AttributeName: C.index0AttributeName,
        extensionDerivatives: ke && C.extensions.derivatives === !0,
        extensionFragDepth: ke && C.extensions.fragDepth === !0,
        extensionDrawBuffers: ke && C.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: ke && C.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: d || r.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: d || r.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: d || r.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: r.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: C.customProgramCacheKey(),
      }
    );
  }
  function m(C) {
    const I = [];
    if (
      (C.shaderID
        ? I.push(C.shaderID)
        : (I.push(C.customVertexShaderID), I.push(C.customFragmentShaderID)),
      C.defines !== void 0)
    )
      for (const k in C.defines) I.push(k), I.push(C.defines[k]);
    return (
      C.isRawShaderMaterial === !1 &&
        (w(I, C), S(I, C), I.push(t.outputColorSpace)),
      I.push(C.customProgramCacheKey),
      I.join()
    );
  }
  function w(C, I) {
    C.push(I.precision),
      C.push(I.outputColorSpace),
      C.push(I.envMapMode),
      C.push(I.envMapCubeUVHeight),
      C.push(I.mapUv),
      C.push(I.alphaMapUv),
      C.push(I.lightMapUv),
      C.push(I.aoMapUv),
      C.push(I.bumpMapUv),
      C.push(I.normalMapUv),
      C.push(I.displacementMapUv),
      C.push(I.emissiveMapUv),
      C.push(I.metalnessMapUv),
      C.push(I.roughnessMapUv),
      C.push(I.anisotropyMapUv),
      C.push(I.clearcoatMapUv),
      C.push(I.clearcoatNormalMapUv),
      C.push(I.clearcoatRoughnessMapUv),
      C.push(I.iridescenceMapUv),
      C.push(I.iridescenceThicknessMapUv),
      C.push(I.sheenColorMapUv),
      C.push(I.sheenRoughnessMapUv),
      C.push(I.specularMapUv),
      C.push(I.specularColorMapUv),
      C.push(I.specularIntensityMapUv),
      C.push(I.transmissionMapUv),
      C.push(I.thicknessMapUv),
      C.push(I.combine),
      C.push(I.fogExp2),
      C.push(I.sizeAttenuation),
      C.push(I.morphTargetsCount),
      C.push(I.morphAttributeCount),
      C.push(I.numDirLights),
      C.push(I.numPointLights),
      C.push(I.numSpotLights),
      C.push(I.numSpotLightMaps),
      C.push(I.numHemiLights),
      C.push(I.numRectAreaLights),
      C.push(I.numDirLightShadows),
      C.push(I.numPointLightShadows),
      C.push(I.numSpotLightShadows),
      C.push(I.numSpotLightShadowsWithMaps),
      C.push(I.numLightProbes),
      C.push(I.shadowMapType),
      C.push(I.toneMapping),
      C.push(I.numClippingPlanes),
      C.push(I.numClipIntersection),
      C.push(I.depthPacking);
  }
  function S(C, I) {
    a.disableAll(),
      I.isWebGL2 && a.enable(0),
      I.supportsVertexTextures && a.enable(1),
      I.instancing && a.enable(2),
      I.instancingColor && a.enable(3),
      I.matcap && a.enable(4),
      I.envMap && a.enable(5),
      I.normalMapObjectSpace && a.enable(6),
      I.normalMapTangentSpace && a.enable(7),
      I.clearcoat && a.enable(8),
      I.iridescence && a.enable(9),
      I.alphaTest && a.enable(10),
      I.vertexColors && a.enable(11),
      I.vertexAlphas && a.enable(12),
      I.vertexUv1s && a.enable(13),
      I.vertexUv2s && a.enable(14),
      I.vertexUv3s && a.enable(15),
      I.vertexTangents && a.enable(16),
      I.anisotropy && a.enable(17),
      I.alphaHash && a.enable(18),
      I.batching && a.enable(19),
      C.push(a.mask),
      a.disableAll(),
      I.fog && a.enable(0),
      I.useFog && a.enable(1),
      I.flatShading && a.enable(2),
      I.logarithmicDepthBuffer && a.enable(3),
      I.skinning && a.enable(4),
      I.morphTargets && a.enable(5),
      I.morphNormals && a.enable(6),
      I.morphColors && a.enable(7),
      I.premultipliedAlpha && a.enable(8),
      I.shadowMapEnabled && a.enable(9),
      I.useLegacyLights && a.enable(10),
      I.doubleSided && a.enable(11),
      I.flipSided && a.enable(12),
      I.useDepthPacking && a.enable(13),
      I.dithering && a.enable(14),
      I.transmission && a.enable(15),
      I.sheen && a.enable(16),
      I.opaque && a.enable(17),
      I.pointsUvs && a.enable(18),
      I.decodeVideoTexture && a.enable(19),
      C.push(a.mask);
  }
  function E(C) {
    const I = v[C.type];
    let k;
    if (I) {
      const R = rs[I];
      k = YI.clone(R.uniforms);
    } else k = C.uniforms;
    return k;
  }
  function T(C, I) {
    let k;
    for (let R = 0, $ = f.length; R < $; R++) {
      const D = f[R];
      if (D.cacheKey === I) {
        (k = D), ++k.usedTimes;
        break;
      }
    }
    return k === void 0 && ((k = new pW(t, I, C, s)), f.push(k)), k;
  }
  function A(C) {
    if (--C.usedTimes === 0) {
      const I = f.indexOf(C);
      (f[I] = f[f.length - 1]), f.pop(), C.destroy();
    }
  }
  function L(C) {
    l.remove(C);
  }
  function N() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: m,
    getUniforms: E,
    acquireProgram: T,
    releaseProgram: A,
    releaseShaderCache: L,
    programs: f,
    dispose: N,
  };
}
function xW() {
  let t = new WeakMap();
  function e(s) {
    let o = t.get(s);
    return o === void 0 && ((o = {}), t.set(s, o)), o;
  }
  function n(s) {
    t.delete(s);
  }
  function r(s, o, a) {
    t.get(s)[o] = a;
  }
  function i() {
    t = new WeakMap();
  }
  return { get: e, remove: n, update: r, dispose: i };
}
function _W(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function XA(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function YA() {
  const t = [];
  let e = 0;
  const n = [],
    r = [],
    i = [];
  function s() {
    (e = 0), (n.length = 0), (r.length = 0), (i.length = 0);
  }
  function o(h, p, g, v, _, x) {
    let m = t[e];
    return (
      m === void 0
        ? ((m = {
            id: h.id,
            object: h,
            geometry: p,
            material: g,
            groupOrder: v,
            renderOrder: h.renderOrder,
            z: _,
            group: x,
          }),
          (t[e] = m))
        : ((m.id = h.id),
          (m.object = h),
          (m.geometry = p),
          (m.material = g),
          (m.groupOrder = v),
          (m.renderOrder = h.renderOrder),
          (m.z = _),
          (m.group = x)),
      e++,
      m
    );
  }
  function a(h, p, g, v, _, x) {
    const m = o(h, p, g, v, _, x);
    g.transmission > 0
      ? r.push(m)
      : g.transparent === !0
      ? i.push(m)
      : n.push(m);
  }
  function l(h, p, g, v, _, x) {
    const m = o(h, p, g, v, _, x);
    g.transmission > 0
      ? r.unshift(m)
      : g.transparent === !0
      ? i.unshift(m)
      : n.unshift(m);
  }
  function f(h, p) {
    n.length > 1 && n.sort(h || _W),
      r.length > 1 && r.sort(p || XA),
      i.length > 1 && i.sort(p || XA);
  }
  function d() {
    for (let h = e, p = t.length; h < p; h++) {
      const g = t[h];
      if (g.id === null) break;
      (g.id = null),
        (g.object = null),
        (g.geometry = null),
        (g.material = null),
        (g.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: r,
    transparent: i,
    init: s,
    push: a,
    unshift: l,
    finish: d,
    sort: f,
  };
}
function SW() {
  let t = new WeakMap();
  function e(r, i) {
    const s = t.get(r);
    let o;
    return (
      s === void 0
        ? ((o = new YA()), t.set(r, [o]))
        : i >= s.length
        ? ((o = new YA()), s.push(o))
        : (o = s[i]),
      o
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
function wW() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new z(), color: new qe() };
          break;
        case "SpotLight":
          n = {
            position: new z(),
            direction: new z(),
            color: new qe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new z(), color: new qe(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = { direction: new z(), skyColor: new qe(), groundColor: new qe() };
          break;
        case "RectAreaLight":
          n = {
            color: new qe(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function MW() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new _e(),
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new _e(),
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new _e(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let EW = 0;
function bW(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function TW(t, e) {
  const n = new wW(),
    r = MW(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let d = 0; d < 9; d++) i.probe.push(new z());
  const s = new z(),
    o = new ht(),
    a = new ht();
  function l(d, h) {
    let p = 0,
      g = 0,
      v = 0;
    for (let R = 0; R < 9; R++) i.probe[R].set(0, 0, 0);
    let _ = 0,
      x = 0,
      m = 0,
      w = 0,
      S = 0,
      E = 0,
      T = 0,
      A = 0,
      L = 0,
      N = 0,
      C = 0;
    d.sort(bW);
    const I = h === !0 ? Math.PI : 1;
    for (let R = 0, $ = d.length; R < $; R++) {
      const D = d[R],
        W = D.color,
        Y = D.intensity,
        Z = D.distance,
        B = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        (p += W.r * Y * I), (g += W.g * Y * I), (v += W.b * Y * I);
      else if (D.isLightProbe) {
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(D.sh.coefficients[G], Y);
        C++;
      } else if (D.isDirectionalLight) {
        const G = n.get(D);
        if (
          (G.color.copy(D.color).multiplyScalar(D.intensity * I), D.castShadow)
        ) {
          const X = D.shadow,
            te = r.get(D);
          (te.shadowBias = X.bias),
            (te.shadowNormalBias = X.normalBias),
            (te.shadowRadius = X.radius),
            (te.shadowMapSize = X.mapSize),
            (i.directionalShadow[_] = te),
            (i.directionalShadowMap[_] = B),
            (i.directionalShadowMatrix[_] = D.shadow.matrix),
            E++;
        }
        (i.directional[_] = G), _++;
      } else if (D.isSpotLight) {
        const G = n.get(D);
        G.position.setFromMatrixPosition(D.matrixWorld),
          G.color.copy(W).multiplyScalar(Y * I),
          (G.distance = Z),
          (G.coneCos = Math.cos(D.angle)),
          (G.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (G.decay = D.decay),
          (i.spot[m] = G);
        const X = D.shadow;
        if (
          (D.map &&
            ((i.spotLightMap[L] = D.map),
            L++,
            X.updateMatrices(D),
            D.castShadow && N++),
          (i.spotLightMatrix[m] = X.matrix),
          D.castShadow)
        ) {
          const te = r.get(D);
          (te.shadowBias = X.bias),
            (te.shadowNormalBias = X.normalBias),
            (te.shadowRadius = X.radius),
            (te.shadowMapSize = X.mapSize),
            (i.spotShadow[m] = te),
            (i.spotShadowMap[m] = B),
            A++;
        }
        m++;
      } else if (D.isRectAreaLight) {
        const G = n.get(D);
        G.color.copy(W).multiplyScalar(Y),
          G.halfWidth.set(D.width * 0.5, 0, 0),
          G.halfHeight.set(0, D.height * 0.5, 0),
          (i.rectArea[w] = G),
          w++;
      } else if (D.isPointLight) {
        const G = n.get(D);
        if (
          (G.color.copy(D.color).multiplyScalar(D.intensity * I),
          (G.distance = D.distance),
          (G.decay = D.decay),
          D.castShadow)
        ) {
          const X = D.shadow,
            te = r.get(D);
          (te.shadowBias = X.bias),
            (te.shadowNormalBias = X.normalBias),
            (te.shadowRadius = X.radius),
            (te.shadowMapSize = X.mapSize),
            (te.shadowCameraNear = X.camera.near),
            (te.shadowCameraFar = X.camera.far),
            (i.pointShadow[x] = te),
            (i.pointShadowMap[x] = B),
            (i.pointShadowMatrix[x] = D.shadow.matrix),
            T++;
        }
        (i.point[x] = G), x++;
      } else if (D.isHemisphereLight) {
        const G = n.get(D);
        G.skyColor.copy(D.color).multiplyScalar(Y * I),
          G.groundColor.copy(D.groundColor).multiplyScalar(Y * I),
          (i.hemi[S] = G),
          S++;
      }
    }
    w > 0 &&
      (e.isWebGL2 || t.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ve.LTC_FLOAT_1), (i.rectAreaLTC2 = Ve.LTC_FLOAT_2))
        : t.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ve.LTC_HALF_1), (i.rectAreaLTC2 = Ve.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = p),
      (i.ambient[1] = g),
      (i.ambient[2] = v);
    const k = i.hash;
    (k.directionalLength !== _ ||
      k.pointLength !== x ||
      k.spotLength !== m ||
      k.rectAreaLength !== w ||
      k.hemiLength !== S ||
      k.numDirectionalShadows !== E ||
      k.numPointShadows !== T ||
      k.numSpotShadows !== A ||
      k.numSpotMaps !== L ||
      k.numLightProbes !== C) &&
      ((i.directional.length = _),
      (i.spot.length = m),
      (i.rectArea.length = w),
      (i.point.length = x),
      (i.hemi.length = S),
      (i.directionalShadow.length = E),
      (i.directionalShadowMap.length = E),
      (i.pointShadow.length = T),
      (i.pointShadowMap.length = T),
      (i.spotShadow.length = A),
      (i.spotShadowMap.length = A),
      (i.directionalShadowMatrix.length = E),
      (i.pointShadowMatrix.length = T),
      (i.spotLightMatrix.length = A + L - N),
      (i.spotLightMap.length = L),
      (i.numSpotLightShadowsWithMaps = N),
      (i.numLightProbes = C),
      (k.directionalLength = _),
      (k.pointLength = x),
      (k.spotLength = m),
      (k.rectAreaLength = w),
      (k.hemiLength = S),
      (k.numDirectionalShadows = E),
      (k.numPointShadows = T),
      (k.numSpotShadows = A),
      (k.numSpotMaps = L),
      (k.numLightProbes = C),
      (i.version = EW++));
  }
  function f(d, h) {
    let p = 0,
      g = 0,
      v = 0,
      _ = 0,
      x = 0;
    const m = h.matrixWorldInverse;
    for (let w = 0, S = d.length; w < S; w++) {
      const E = d[w];
      if (E.isDirectionalLight) {
        const T = i.directional[p];
        T.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(m),
          p++;
      } else if (E.isSpotLight) {
        const T = i.spot[v];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(m),
          T.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(m),
          v++;
      } else if (E.isRectAreaLight) {
        const T = i.rectArea[_];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(m),
          a.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(m),
          a.extractRotation(o),
          T.halfWidth.set(E.width * 0.5, 0, 0),
          T.halfHeight.set(0, E.height * 0.5, 0),
          T.halfWidth.applyMatrix4(a),
          T.halfHeight.applyMatrix4(a),
          _++;
      } else if (E.isPointLight) {
        const T = i.point[g];
        T.position.setFromMatrixPosition(E.matrixWorld),
          T.position.applyMatrix4(m),
          g++;
      } else if (E.isHemisphereLight) {
        const T = i.hemi[x];
        T.direction.setFromMatrixPosition(E.matrixWorld),
          T.direction.transformDirection(m),
          x++;
      }
    }
  }
  return { setup: l, setupView: f, state: i };
}
function qA(t, e) {
  const n = new TW(t, e),
    r = [],
    i = [];
  function s() {
    (r.length = 0), (i.length = 0);
  }
  function o(h) {
    r.push(h);
  }
  function a(h) {
    i.push(h);
  }
  function l(h) {
    n.setup(r, h);
  }
  function f(h) {
    n.setupView(r, h);
  }
  return {
    init: s,
    state: { lightsArray: r, shadowsArray: i, lights: n },
    setupLights: l,
    setupLightsView: f,
    pushLight: o,
    pushShadow: a,
  };
}
function AW(t, e) {
  let n = new WeakMap();
  function r(s, o = 0) {
    const a = n.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new qA(t, e)), n.set(s, [l]))
        : o >= a.length
        ? ((l = new qA(t, e)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function i() {
    n = new WeakMap();
  }
  return { get: r, dispose: i };
}
class aM extends Nr {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = NI),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class lM extends Nr {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const CW = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  RW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function PW(t, e, n) {
  let r = new lh();
  const i = new _e(),
    s = new _e(),
    o = new Gt(),
    a = new aM({ depthPacking: OI }),
    l = new lM(),
    f = {},
    d = n.maxTextureSize,
    h = { [_o]: Hr, [Hr]: _o, [Ps]: Ps },
    p = new Bs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new _e() },
        radius: { value: 4 },
      },
      vertexShader: CW,
      fragmentShader: RW,
    }),
    g = p.clone();
  g.defines.HORIZONTAL_PASS = 1;
  const v = new bt();
  v.setAttribute(
    "position",
    new $t(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const _ = new jn(v, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = O0);
  let m = this.type;
  this.render = function (T, A, L) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      T.length === 0
    )
      return;
    const N = t.getRenderTarget(),
      C = t.getActiveCubeFace(),
      I = t.getActiveMipmapLevel(),
      k = t.state;
    k.setBlending(po),
      k.buffers.color.setClear(1, 1, 1, 1),
      k.buffers.depth.setTest(!0),
      k.setScissorTest(!1);
    const R = m !== es && this.type === es,
      $ = m === es && this.type !== es;
    for (let D = 0, W = T.length; D < W; D++) {
      const Y = T[D],
        Z = Y.shadow;
      if (Z === void 0) {
        console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
        continue;
      }
      if (Z.autoUpdate === !1 && Z.needsUpdate === !1) continue;
      i.copy(Z.mapSize);
      const B = Z.getFrameExtents();
      if (
        (i.multiply(B),
        s.copy(Z.mapSize),
        (i.x > d || i.y > d) &&
          (i.x > d &&
            ((s.x = Math.floor(d / B.x)),
            (i.x = s.x * B.x),
            (Z.mapSize.x = s.x)),
          i.y > d &&
            ((s.y = Math.floor(d / B.y)),
            (i.y = s.y * B.y),
            (Z.mapSize.y = s.y))),
        Z.map === null || R === !0 || $ === !0)
      ) {
        const X = this.type !== es ? { minFilter: An, magFilter: An } : {};
        Z.map !== null && Z.map.dispose(),
          (Z.map = new cs(i.x, i.y, X)),
          (Z.map.texture.name = Y.name + ".shadowMap"),
          Z.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(Z.map), t.clear();
      const G = Z.getViewportCount();
      for (let X = 0; X < G; X++) {
        const te = Z.getViewport(X);
        o.set(s.x * te.x, s.y * te.y, s.x * te.z, s.y * te.w),
          k.viewport(o),
          Z.updateMatrices(Y, X),
          (r = Z.getFrustum()),
          E(A, L, Z.camera, Y, this.type);
      }
      Z.isPointLightShadow !== !0 && this.type === es && w(Z, L),
        (Z.needsUpdate = !1);
    }
    (m = this.type), (x.needsUpdate = !1), t.setRenderTarget(N, C, I);
  };
  function w(T, A) {
    const L = e.update(_);
    p.defines.VSM_SAMPLES !== T.blurSamples &&
      ((p.defines.VSM_SAMPLES = T.blurSamples),
      (g.defines.VSM_SAMPLES = T.blurSamples),
      (p.needsUpdate = !0),
      (g.needsUpdate = !0)),
      T.mapPass === null && (T.mapPass = new cs(i.x, i.y)),
      (p.uniforms.shadow_pass.value = T.map.texture),
      (p.uniforms.resolution.value = T.mapSize),
      (p.uniforms.radius.value = T.radius),
      t.setRenderTarget(T.mapPass),
      t.clear(),
      t.renderBufferDirect(A, null, L, p, _, null),
      (g.uniforms.shadow_pass.value = T.mapPass.texture),
      (g.uniforms.resolution.value = T.mapSize),
      (g.uniforms.radius.value = T.radius),
      t.setRenderTarget(T.map),
      t.clear(),
      t.renderBufferDirect(A, null, L, g, _, null);
  }
  function S(T, A, L, N) {
    let C = null;
    const I =
      L.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (I !== void 0) C = I;
    else if (
      ((C = L.isPointLight === !0 ? l : a),
      (t.localClippingEnabled &&
        A.clipShadows === !0 &&
        Array.isArray(A.clippingPlanes) &&
        A.clippingPlanes.length !== 0) ||
        (A.displacementMap && A.displacementScale !== 0) ||
        (A.alphaMap && A.alphaTest > 0) ||
        (A.map && A.alphaTest > 0))
    ) {
      const k = C.uuid,
        R = A.uuid;
      let $ = f[k];
      $ === void 0 && (($ = {}), (f[k] = $));
      let D = $[R];
      D === void 0 && ((D = C.clone()), ($[R] = D)), (C = D);
    }
    if (
      ((C.visible = A.visible),
      (C.wireframe = A.wireframe),
      N === es
        ? (C.side = A.shadowSide !== null ? A.shadowSide : A.side)
        : (C.side = A.shadowSide !== null ? A.shadowSide : h[A.side]),
      (C.alphaMap = A.alphaMap),
      (C.alphaTest = A.alphaTest),
      (C.map = A.map),
      (C.clipShadows = A.clipShadows),
      (C.clippingPlanes = A.clippingPlanes),
      (C.clipIntersection = A.clipIntersection),
      (C.displacementMap = A.displacementMap),
      (C.displacementScale = A.displacementScale),
      (C.displacementBias = A.displacementBias),
      (C.wireframeLinewidth = A.wireframeLinewidth),
      (C.linewidth = A.linewidth),
      L.isPointLight === !0 && C.isMeshDistanceMaterial === !0)
    ) {
      const k = t.properties.get(C);
      k.light = L;
    }
    return C;
  }
  function E(T, A, L, N, C) {
    if (T.visible === !1) return;
    if (
      T.layers.test(A.layers) &&
      (T.isMesh || T.isLine || T.isPoints) &&
      (T.castShadow || (T.receiveShadow && C === es)) &&
      (!T.frustumCulled || r.intersectsObject(T))
    ) {
      T.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, T.matrixWorld);
      const R = e.update(T),
        $ = T.material;
      if (Array.isArray($)) {
        const D = R.groups;
        for (let W = 0, Y = D.length; W < Y; W++) {
          const Z = D[W],
            B = $[Z.materialIndex];
          if (B && B.visible) {
            const G = S(T, B, N, C);
            T.onBeforeShadow(t, T, A, L, R, G, Z),
              t.renderBufferDirect(L, null, R, G, T, Z),
              T.onAfterShadow(t, T, A, L, R, G, Z);
          }
        }
      } else if ($.visible) {
        const D = S(T, $, N, C);
        T.onBeforeShadow(t, T, A, L, R, D, null),
          t.renderBufferDirect(L, null, R, D, T, null),
          T.onAfterShadow(t, T, A, L, R, D, null);
      }
    }
    const k = T.children;
    for (let R = 0, $ = k.length; R < $; R++) E(k[R], A, L, N, C);
  }
}
function LW(t, e, n) {
  const r = n.isWebGL2;
  function i() {
    let K = !1;
    const ze = new Gt();
    let ke = null;
    const ye = new Gt(0, 0, 0, 0);
    return {
      setMask: function (Oe) {
        ke !== Oe && !K && (t.colorMask(Oe, Oe, Oe, Oe), (ke = Oe));
      },
      setLocked: function (Oe) {
        K = Oe;
      },
      setClear: function (Oe, nt, xt, qt, sn) {
        sn === !0 && ((Oe *= qt), (nt *= qt), (xt *= qt)),
          ze.set(Oe, nt, xt, qt),
          ye.equals(ze) === !1 && (t.clearColor(Oe, nt, xt, qt), ye.copy(ze));
      },
      reset: function () {
        (K = !1), (ke = null), ye.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let K = !1,
      ze = null,
      ke = null,
      ye = null;
    return {
      setTest: function (Oe) {
        Oe ? We(t.DEPTH_TEST) : Me(t.DEPTH_TEST);
      },
      setMask: function (Oe) {
        ze !== Oe && !K && (t.depthMask(Oe), (ze = Oe));
      },
      setFunc: function (Oe) {
        if (ke !== Oe) {
          switch (Oe) {
            case lI:
              t.depthFunc(t.NEVER);
              break;
            case uI:
              t.depthFunc(t.ALWAYS);
              break;
            case cI:
              t.depthFunc(t.LESS);
              break;
            case Ad:
              t.depthFunc(t.LEQUAL);
              break;
            case fI:
              t.depthFunc(t.EQUAL);
              break;
            case dI:
              t.depthFunc(t.GEQUAL);
              break;
            case hI:
              t.depthFunc(t.GREATER);
              break;
            case pI:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          ke = Oe;
        }
      },
      setLocked: function (Oe) {
        K = Oe;
      },
      setClear: function (Oe) {
        ye !== Oe && (t.clearDepth(Oe), (ye = Oe));
      },
      reset: function () {
        (K = !1), (ze = null), (ke = null), (ye = null);
      },
    };
  }
  function o() {
    let K = !1,
      ze = null,
      ke = null,
      ye = null,
      Oe = null,
      nt = null,
      xt = null,
      qt = null,
      sn = null;
    return {
      setTest: function (It) {
        K || (It ? We(t.STENCIL_TEST) : Me(t.STENCIL_TEST));
      },
      setMask: function (It) {
        ze !== It && !K && (t.stencilMask(It), (ze = It));
      },
      setFunc: function (It, sr, Ei) {
        (ke !== It || ye !== sr || Oe !== Ei) &&
          (t.stencilFunc(It, sr, Ei), (ke = It), (ye = sr), (Oe = Ei));
      },
      setOp: function (It, sr, Ei) {
        (nt !== It || xt !== sr || qt !== Ei) &&
          (t.stencilOp(It, sr, Ei), (nt = It), (xt = sr), (qt = Ei));
      },
      setLocked: function (It) {
        K = It;
      },
      setClear: function (It) {
        sn !== It && (t.clearStencil(It), (sn = It));
      },
      reset: function () {
        (K = !1),
          (ze = null),
          (ke = null),
          (ye = null),
          (Oe = null),
          (nt = null),
          (xt = null),
          (qt = null),
          (sn = null);
      },
    };
  }
  const a = new i(),
    l = new s(),
    f = new o(),
    d = new WeakMap(),
    h = new WeakMap();
  let p = {},
    g = {},
    v = new WeakMap(),
    _ = [],
    x = null,
    m = !1,
    w = null,
    S = null,
    E = null,
    T = null,
    A = null,
    L = null,
    N = null,
    C = new qe(0, 0, 0),
    I = 0,
    k = !1,
    R = null,
    $ = null,
    D = null,
    W = null,
    Y = null;
  const Z = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let B = !1,
    G = 0;
  const X = t.getParameter(t.VERSION);
  X.indexOf("WebGL") !== -1
    ? ((G = parseFloat(/^WebGL (\d)/.exec(X)[1])), (B = G >= 1))
    : X.indexOf("OpenGL ES") !== -1 &&
      ((G = parseFloat(/^OpenGL ES (\d)/.exec(X)[1])), (B = G >= 2));
  let te = null,
    oe = {};
  const J = t.getParameter(t.SCISSOR_BOX),
    ae = t.getParameter(t.VIEWPORT),
    Se = new Gt().fromArray(J),
    Ie = new Gt().fromArray(ae);
  function Ce(K, ze, ke, ye) {
    const Oe = new Uint8Array(4),
      nt = t.createTexture();
    t.bindTexture(K, nt),
      t.texParameteri(K, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(K, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let xt = 0; xt < ke; xt++)
      r && (K === t.TEXTURE_3D || K === t.TEXTURE_2D_ARRAY)
        ? t.texImage3D(ze, 0, t.RGBA, 1, 1, ye, 0, t.RGBA, t.UNSIGNED_BYTE, Oe)
        : t.texImage2D(
            ze + xt,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            Oe
          );
    return nt;
  }
  const et = {};
  (et[t.TEXTURE_2D] = Ce(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (et[t.TEXTURE_CUBE_MAP] = Ce(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    r &&
      ((et[t.TEXTURE_2D_ARRAY] = Ce(
        t.TEXTURE_2D_ARRAY,
        t.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (et[t.TEXTURE_3D] = Ce(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    f.setClear(0),
    We(t.DEPTH_TEST),
    l.setFunc(Ad),
    Fe(!1),
    He(ES),
    We(t.CULL_FACE),
    xe(po);
  function We(K) {
    p[K] !== !0 && (t.enable(K), (p[K] = !0));
  }
  function Me(K) {
    p[K] !== !1 && (t.disable(K), (p[K] = !1));
  }
  function Le(K, ze) {
    return g[K] !== ze
      ? (t.bindFramebuffer(K, ze),
        (g[K] = ze),
        r &&
          (K === t.DRAW_FRAMEBUFFER && (g[t.FRAMEBUFFER] = ze),
          K === t.FRAMEBUFFER && (g[t.DRAW_FRAMEBUFFER] = ze)),
        !0)
      : !1;
  }
  function H(K, ze) {
    let ke = _,
      ye = !1;
    if (K)
      if (
        ((ke = v.get(ze)),
        ke === void 0 && ((ke = []), v.set(ze, ke)),
        K.isWebGLMultipleRenderTargets)
      ) {
        const Oe = K.texture;
        if (ke.length !== Oe.length || ke[0] !== t.COLOR_ATTACHMENT0) {
          for (let nt = 0, xt = Oe.length; nt < xt; nt++)
            ke[nt] = t.COLOR_ATTACHMENT0 + nt;
          (ke.length = Oe.length), (ye = !0);
        }
      } else
        ke[0] !== t.COLOR_ATTACHMENT0 &&
          ((ke[0] = t.COLOR_ATTACHMENT0), (ye = !0));
    else ke[0] !== t.BACK && ((ke[0] = t.BACK), (ye = !0));
    ye &&
      (n.isWebGL2
        ? t.drawBuffers(ke)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ke));
  }
  function pe(K) {
    return x !== K ? (t.useProgram(K), (x = K), !0) : !1;
  }
  const ie = {
    [Ko]: t.FUNC_ADD,
    [XL]: t.FUNC_SUBTRACT,
    [YL]: t.FUNC_REVERSE_SUBTRACT,
  };
  if (r) (ie[CS] = t.MIN), (ie[RS] = t.MAX);
  else {
    const K = e.get("EXT_blend_minmax");
    K !== null && ((ie[CS] = K.MIN_EXT), (ie[RS] = K.MAX_EXT));
  }
  const we = {
    [qL]: t.ZERO,
    [KL]: t.ONE,
    [ZL]: t.SRC_COLOR,
    [Dg]: t.SRC_ALPHA,
    [rI]: t.SRC_ALPHA_SATURATE,
    [tI]: t.DST_COLOR,
    [QL]: t.DST_ALPHA,
    [JL]: t.ONE_MINUS_SRC_COLOR,
    [kg]: t.ONE_MINUS_SRC_ALPHA,
    [nI]: t.ONE_MINUS_DST_COLOR,
    [eI]: t.ONE_MINUS_DST_ALPHA,
    [iI]: t.CONSTANT_COLOR,
    [sI]: t.ONE_MINUS_CONSTANT_COLOR,
    [oI]: t.CONSTANT_ALPHA,
    [aI]: t.ONE_MINUS_CONSTANT_ALPHA,
  };
  function xe(K, ze, ke, ye, Oe, nt, xt, qt, sn, It) {
    if (K === po) {
      m === !0 && (Me(t.BLEND), (m = !1));
      return;
    }
    if ((m === !1 && (We(t.BLEND), (m = !0)), K !== $L)) {
      if (K !== w || It !== k) {
        if (
          ((S !== Ko || A !== Ko) &&
            (t.blendEquation(t.FUNC_ADD), (S = Ko), (A = Ko)),
          It)
        )
          switch (K) {
            case yl:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case bS:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case TS:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case AS:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        else
          switch (K) {
            case yl:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case bS:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case TS:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case AS:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        (E = null),
          (T = null),
          (L = null),
          (N = null),
          C.set(0, 0, 0),
          (I = 0),
          (w = K),
          (k = It);
      }
      return;
    }
    (Oe = Oe || ze),
      (nt = nt || ke),
      (xt = xt || ye),
      (ze !== S || Oe !== A) &&
        (t.blendEquationSeparate(ie[ze], ie[Oe]), (S = ze), (A = Oe)),
      (ke !== E || ye !== T || nt !== L || xt !== N) &&
        (t.blendFuncSeparate(we[ke], we[ye], we[nt], we[xt]),
        (E = ke),
        (T = ye),
        (L = nt),
        (N = xt)),
      (qt.equals(C) === !1 || sn !== I) &&
        (t.blendColor(qt.r, qt.g, qt.b, sn), C.copy(qt), (I = sn)),
      (w = K),
      (k = !1);
  }
  function $e(K, ze) {
    K.side === Ps ? Me(t.CULL_FACE) : We(t.CULL_FACE);
    let ke = K.side === Hr;
    ze && (ke = !ke),
      Fe(ke),
      K.blending === yl && K.transparent === !1
        ? xe(po)
        : xe(
            K.blending,
            K.blendEquation,
            K.blendSrc,
            K.blendDst,
            K.blendEquationAlpha,
            K.blendSrcAlpha,
            K.blendDstAlpha,
            K.blendColor,
            K.blendAlpha,
            K.premultipliedAlpha
          ),
      l.setFunc(K.depthFunc),
      l.setTest(K.depthTest),
      l.setMask(K.depthWrite),
      a.setMask(K.colorWrite);
    const ye = K.stencilWrite;
    f.setTest(ye),
      ye &&
        (f.setMask(K.stencilWriteMask),
        f.setFunc(K.stencilFunc, K.stencilRef, K.stencilFuncMask),
        f.setOp(K.stencilFail, K.stencilZFail, K.stencilZPass)),
      it(K.polygonOffset, K.polygonOffsetFactor, K.polygonOffsetUnits),
      K.alphaToCoverage === !0
        ? We(t.SAMPLE_ALPHA_TO_COVERAGE)
        : Me(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Fe(K) {
    R !== K && (K ? t.frontFace(t.CW) : t.frontFace(t.CCW), (R = K));
  }
  function He(K) {
    K !== WL
      ? (We(t.CULL_FACE),
        K !== $ &&
          (K === ES
            ? t.cullFace(t.BACK)
            : K === GL
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : Me(t.CULL_FACE),
      ($ = K);
  }
  function Ze(K) {
    K !== D && (B && t.lineWidth(K), (D = K));
  }
  function it(K, ze, ke) {
    K
      ? (We(t.POLYGON_OFFSET_FILL),
        (W !== ze || Y !== ke) && (t.polygonOffset(ze, ke), (W = ze), (Y = ke)))
      : Me(t.POLYGON_OFFSET_FILL);
  }
  function Tt(K) {
    K ? We(t.SCISSOR_TEST) : Me(t.SCISSOR_TEST);
  }
  function V(K) {
    K === void 0 && (K = t.TEXTURE0 + Z - 1),
      te !== K && (t.activeTexture(K), (te = K));
  }
  function O(K, ze, ke) {
    ke === void 0 && (te === null ? (ke = t.TEXTURE0 + Z - 1) : (ke = te));
    let ye = oe[ke];
    ye === void 0 && ((ye = { type: void 0, texture: void 0 }), (oe[ke] = ye)),
      (ye.type !== K || ye.texture !== ze) &&
        (te !== ke && (t.activeTexture(ke), (te = ke)),
        t.bindTexture(K, ze || et[K]),
        (ye.type = K),
        (ye.texture = ze));
  }
  function se() {
    const K = oe[te];
    K !== void 0 &&
      K.type !== void 0 &&
      (t.bindTexture(K.type, null), (K.type = void 0), (K.texture = void 0));
  }
  function Re() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ee() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ae() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ye() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Pe() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Te() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function at() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function wt() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ne() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Pt() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function q(K) {
    Se.equals(K) === !1 && (t.scissor(K.x, K.y, K.z, K.w), Se.copy(K));
  }
  function me(K) {
    Ie.equals(K) === !1 && (t.viewport(K.x, K.y, K.z, K.w), Ie.copy(K));
  }
  function be(K, ze) {
    let ke = h.get(ze);
    ke === void 0 && ((ke = new WeakMap()), h.set(ze, ke));
    let ye = ke.get(K);
    ye === void 0 && ((ye = t.getUniformBlockIndex(ze, K.name)), ke.set(K, ye));
  }
  function ue(K, ze) {
    const ye = h.get(ze).get(K);
    d.get(ze) !== ye &&
      (t.uniformBlockBinding(ze, ye, K.__bindingPointIndex), d.set(ze, ye));
  }
  function Be() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      r === !0 &&
        (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (p = {}),
      (te = null),
      (oe = {}),
      (g = {}),
      (v = new WeakMap()),
      (_ = []),
      (x = null),
      (m = !1),
      (w = null),
      (S = null),
      (E = null),
      (T = null),
      (A = null),
      (L = null),
      (N = null),
      (C = new qe(0, 0, 0)),
      (I = 0),
      (k = !1),
      (R = null),
      ($ = null),
      (D = null),
      (W = null),
      (Y = null),
      Se.set(0, 0, t.canvas.width, t.canvas.height),
      Ie.set(0, 0, t.canvas.width, t.canvas.height),
      a.reset(),
      l.reset(),
      f.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: f },
    enable: We,
    disable: Me,
    bindFramebuffer: Le,
    drawBuffers: H,
    useProgram: pe,
    setBlending: xe,
    setMaterial: $e,
    setFlipSided: Fe,
    setCullFace: He,
    setLineWidth: Ze,
    setPolygonOffset: it,
    setScissorTest: Tt,
    activeTexture: V,
    bindTexture: O,
    unbindTexture: se,
    compressedTexImage2D: Re,
    compressedTexImage3D: Ee,
    texImage2D: Ne,
    texImage3D: Pt,
    updateUBOMapping: be,
    uniformBlockBinding: ue,
    texStorage2D: at,
    texStorage3D: wt,
    texSubImage2D: Ae,
    texSubImage3D: Ye,
    compressedTexSubImage2D: Pe,
    compressedTexSubImage3D: Te,
    scissor: q,
    viewport: me,
    reset: Be,
  };
}
function IW(t, e, n, r, i, s, o) {
  const a = i.isWebGL2,
    l = i.maxTextures,
    f = i.maxCubemapSize,
    d = i.maxTextureSize,
    h = i.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    g =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    v = new WeakMap();
  let _;
  const x = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function w(V, O) {
    return m ? new OffscreenCanvas(V, O) : zd("canvas");
  }
  function S(V, O, se, Re) {
    let Ee = 1;
    if (
      ((V.width > Re || V.height > Re) &&
        (Ee = Re / Math.max(V.width, V.height)),
      Ee < 1 || O === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && V instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && V instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && V instanceof ImageBitmap)
      ) {
        const Ae = O ? zg : Math.floor,
          Ye = Ae(Ee * V.width),
          Pe = Ae(Ee * V.height);
        _ === void 0 && (_ = w(Ye, Pe));
        const Te = se ? w(Ye, Pe) : _;
        return (
          (Te.width = Ye),
          (Te.height = Pe),
          Te.getContext("2d").drawImage(V, 0, 0, Ye, Pe),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              V.width +
              "x" +
              V.height +
              ") to (" +
              Ye +
              "x" +
              Pe +
              ")."
          ),
          Te
        );
      } else
        return (
          "data" in V &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                V.width +
                "x" +
                V.height +
                ")."
            ),
          V
        );
    return V;
  }
  function E(V) {
    return i1(V.width) && i1(V.height);
  }
  function T(V) {
    return a
      ? !1
      : V.wrapS !== Cr ||
          V.wrapT !== Cr ||
          (V.minFilter !== An && V.minFilter !== Rn);
  }
  function A(V, O) {
    return V.generateMipmaps && O && V.minFilter !== An && V.minFilter !== Rn;
  }
  function L(V) {
    t.generateMipmap(V);
  }
  function N(V, O, se, Re, Ee = !1) {
    if (a === !1) return O;
    if (V !== null) {
      if (t[V] !== void 0) return t[V];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          V +
          "'"
      );
    }
    let Ae = O;
    if (
      (O === t.RED &&
        (se === t.FLOAT && (Ae = t.R32F),
        se === t.HALF_FLOAT && (Ae = t.R16F),
        se === t.UNSIGNED_BYTE && (Ae = t.R8)),
      O === t.RED_INTEGER &&
        (se === t.UNSIGNED_BYTE && (Ae = t.R8UI),
        se === t.UNSIGNED_SHORT && (Ae = t.R16UI),
        se === t.UNSIGNED_INT && (Ae = t.R32UI),
        se === t.BYTE && (Ae = t.R8I),
        se === t.SHORT && (Ae = t.R16I),
        se === t.INT && (Ae = t.R32I)),
      O === t.RG &&
        (se === t.FLOAT && (Ae = t.RG32F),
        se === t.HALF_FLOAT && (Ae = t.RG16F),
        se === t.UNSIGNED_BYTE && (Ae = t.RG8)),
      O === t.RGBA)
    ) {
      const Ye = Ee ? Dd : Wt.getTransfer(Re);
      se === t.FLOAT && (Ae = t.RGBA32F),
        se === t.HALF_FLOAT && (Ae = t.RGBA16F),
        se === t.UNSIGNED_BYTE && (Ae = Ye === Jt ? t.SRGB8_ALPHA8 : t.RGBA8),
        se === t.UNSIGNED_SHORT_4_4_4_4 && (Ae = t.RGBA4),
        se === t.UNSIGNED_SHORT_5_5_5_1 && (Ae = t.RGB5_A1);
    }
    return (
      (Ae === t.R16F ||
        Ae === t.R32F ||
        Ae === t.RG16F ||
        Ae === t.RG32F ||
        Ae === t.RGBA16F ||
        Ae === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Ae
    );
  }
  function C(V, O, se) {
    return A(V, se) === !0 ||
      (V.isFramebufferTexture && V.minFilter !== An && V.minFilter !== Rn)
      ? Math.log2(Math.max(O.width, O.height)) + 1
      : V.mipmaps !== void 0 && V.mipmaps.length > 0
      ? V.mipmaps.length
      : V.isCompressedTexture && Array.isArray(V.image)
      ? O.mipmaps.length
      : 1;
  }
  function I(V) {
    return V === An || V === Ug || V === Qf ? t.NEAREST : t.LINEAR;
  }
  function k(V) {
    const O = V.target;
    O.removeEventListener("dispose", k), $(O), O.isVideoTexture && v.delete(O);
  }
  function R(V) {
    const O = V.target;
    O.removeEventListener("dispose", R), W(O);
  }
  function $(V) {
    const O = r.get(V);
    if (O.__webglInit === void 0) return;
    const se = V.source,
      Re = x.get(se);
    if (Re) {
      const Ee = Re[O.__cacheKey];
      Ee.usedTimes--,
        Ee.usedTimes === 0 && D(V),
        Object.keys(Re).length === 0 && x.delete(se);
    }
    r.remove(V);
  }
  function D(V) {
    const O = r.get(V);
    t.deleteTexture(O.__webglTexture);
    const se = V.source,
      Re = x.get(se);
    delete Re[O.__cacheKey], o.memory.textures--;
  }
  function W(V) {
    const O = V.texture,
      se = r.get(V),
      Re = r.get(O);
    if (
      (Re.__webglTexture !== void 0 &&
        (t.deleteTexture(Re.__webglTexture), o.memory.textures--),
      V.depthTexture && V.depthTexture.dispose(),
      V.isWebGLCubeRenderTarget)
    )
      for (let Ee = 0; Ee < 6; Ee++) {
        if (Array.isArray(se.__webglFramebuffer[Ee]))
          for (let Ae = 0; Ae < se.__webglFramebuffer[Ee].length; Ae++)
            t.deleteFramebuffer(se.__webglFramebuffer[Ee][Ae]);
        else t.deleteFramebuffer(se.__webglFramebuffer[Ee]);
        se.__webglDepthbuffer &&
          t.deleteRenderbuffer(se.__webglDepthbuffer[Ee]);
      }
    else {
      if (Array.isArray(se.__webglFramebuffer))
        for (let Ee = 0; Ee < se.__webglFramebuffer.length; Ee++)
          t.deleteFramebuffer(se.__webglFramebuffer[Ee]);
      else t.deleteFramebuffer(se.__webglFramebuffer);
      if (
        (se.__webglDepthbuffer && t.deleteRenderbuffer(se.__webglDepthbuffer),
        se.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(se.__webglMultisampledFramebuffer),
        se.__webglColorRenderbuffer)
      )
        for (let Ee = 0; Ee < se.__webglColorRenderbuffer.length; Ee++)
          se.__webglColorRenderbuffer[Ee] &&
            t.deleteRenderbuffer(se.__webglColorRenderbuffer[Ee]);
      se.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(se.__webglDepthRenderbuffer);
    }
    if (V.isWebGLMultipleRenderTargets)
      for (let Ee = 0, Ae = O.length; Ee < Ae; Ee++) {
        const Ye = r.get(O[Ee]);
        Ye.__webglTexture &&
          (t.deleteTexture(Ye.__webglTexture), o.memory.textures--),
          r.remove(O[Ee]);
      }
    r.remove(O), r.remove(V);
  }
  let Y = 0;
  function Z() {
    Y = 0;
  }
  function B() {
    const V = Y;
    return (
      V >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            V +
            " texture units while this GPU supports only " +
            l
        ),
      (Y += 1),
      V
    );
  }
  function G(V) {
    const O = [];
    return (
      O.push(V.wrapS),
      O.push(V.wrapT),
      O.push(V.wrapR || 0),
      O.push(V.magFilter),
      O.push(V.minFilter),
      O.push(V.anisotropy),
      O.push(V.internalFormat),
      O.push(V.format),
      O.push(V.type),
      O.push(V.generateMipmaps),
      O.push(V.premultiplyAlpha),
      O.push(V.flipY),
      O.push(V.unpackAlignment),
      O.push(V.colorSpace),
      O.join()
    );
  }
  function X(V, O) {
    const se = r.get(V);
    if (
      (V.isVideoTexture && it(V),
      V.isRenderTargetTexture === !1 &&
        V.version > 0 &&
        se.__version !== V.version)
    ) {
      const Re = V.image;
      if (Re === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Re.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        We(se, V, O);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, se.__webglTexture, t.TEXTURE0 + O);
  }
  function te(V, O) {
    const se = r.get(V);
    if (V.version > 0 && se.__version !== V.version) {
      We(se, V, O);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, se.__webglTexture, t.TEXTURE0 + O);
  }
  function oe(V, O) {
    const se = r.get(V);
    if (V.version > 0 && se.__version !== V.version) {
      We(se, V, O);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, se.__webglTexture, t.TEXTURE0 + O);
  }
  function J(V, O) {
    const se = r.get(V);
    if (V.version > 0 && se.__version !== V.version) {
      Me(se, V, O);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, se.__webglTexture, t.TEXTURE0 + O);
  }
  const ae = { [Pd]: t.REPEAT, [Cr]: t.CLAMP_TO_EDGE, [Ld]: t.MIRRORED_REPEAT },
    Se = {
      [An]: t.NEAREST,
      [Ug]: t.NEAREST_MIPMAP_NEAREST,
      [Qf]: t.NEAREST_MIPMAP_LINEAR,
      [Rn]: t.LINEAR,
      [Ww]: t.LINEAR_MIPMAP_NEAREST,
      [xa]: t.LINEAR_MIPMAP_LINEAR,
    },
    Ie = {
      [kI]: t.NEVER,
      [VI]: t.ALWAYS,
      [UI]: t.LESS,
      [Qw]: t.LEQUAL,
      [FI]: t.EQUAL,
      [HI]: t.GEQUAL,
      [zI]: t.GREATER,
      [BI]: t.NOTEQUAL,
    };
  function Ce(V, O, se) {
    if (
      (se
        ? (t.texParameteri(V, t.TEXTURE_WRAP_S, ae[O.wrapS]),
          t.texParameteri(V, t.TEXTURE_WRAP_T, ae[O.wrapT]),
          (V === t.TEXTURE_3D || V === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(V, t.TEXTURE_WRAP_R, ae[O.wrapR]),
          t.texParameteri(V, t.TEXTURE_MAG_FILTER, Se[O.magFilter]),
          t.texParameteri(V, t.TEXTURE_MIN_FILTER, Se[O.minFilter]))
        : (t.texParameteri(V, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(V, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          (V === t.TEXTURE_3D || V === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(V, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
          (O.wrapS !== Cr || O.wrapT !== Cr) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          t.texParameteri(V, t.TEXTURE_MAG_FILTER, I(O.magFilter)),
          t.texParameteri(V, t.TEXTURE_MIN_FILTER, I(O.minFilter)),
          O.minFilter !== An &&
            O.minFilter !== Rn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      O.compareFunction &&
        (t.texParameteri(V, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(V, t.TEXTURE_COMPARE_FUNC, Ie[O.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Re = e.get("EXT_texture_filter_anisotropic");
      if (
        O.magFilter === An ||
        (O.minFilter !== Qf && O.minFilter !== xa) ||
        (O.type === ss && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          O.type === xc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (O.anisotropy > 1 || r.get(O).__currentAnisotropy) &&
        (t.texParameterf(
          V,
          Re.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(O.anisotropy, i.getMaxAnisotropy())
        ),
        (r.get(O).__currentAnisotropy = O.anisotropy));
    }
  }
  function et(V, O) {
    let se = !1;
    V.__webglInit === void 0 &&
      ((V.__webglInit = !0), O.addEventListener("dispose", k));
    const Re = O.source;
    let Ee = x.get(Re);
    Ee === void 0 && ((Ee = {}), x.set(Re, Ee));
    const Ae = G(O);
    if (Ae !== V.__cacheKey) {
      Ee[Ae] === void 0 &&
        ((Ee[Ae] = { texture: t.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (se = !0)),
        Ee[Ae].usedTimes++;
      const Ye = Ee[V.__cacheKey];
      Ye !== void 0 &&
        (Ee[V.__cacheKey].usedTimes--, Ye.usedTimes === 0 && D(O)),
        (V.__cacheKey = Ae),
        (V.__webglTexture = Ee[Ae].texture);
    }
    return se;
  }
  function We(V, O, se) {
    let Re = t.TEXTURE_2D;
    (O.isDataArrayTexture || O.isCompressedArrayTexture) &&
      (Re = t.TEXTURE_2D_ARRAY),
      O.isData3DTexture && (Re = t.TEXTURE_3D);
    const Ee = et(V, O),
      Ae = O.source;
    n.bindTexture(Re, V.__webglTexture, t.TEXTURE0 + se);
    const Ye = r.get(Ae);
    if (Ae.version !== Ye.__version || Ee === !0) {
      n.activeTexture(t.TEXTURE0 + se);
      const Pe = Wt.getPrimaries(Wt.workingColorSpace),
        Te = O.colorSpace === hi ? null : Wt.getPrimaries(O.colorSpace),
        at =
          O.colorSpace === hi || Pe === Te ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, O.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, O.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, at);
      const wt = T(O) && E(O.image) === !1;
      let Ne = S(O.image, wt, !1, d);
      Ne = Tt(O, Ne);
      const Pt = E(Ne) || a,
        q = s.convert(O.format, O.colorSpace);
      let me = s.convert(O.type),
        be = N(O.internalFormat, q, me, O.colorSpace, O.isVideoTexture);
      Ce(Re, O, Pt);
      let ue;
      const Be = O.mipmaps,
        K = a && O.isVideoTexture !== !0 && be !== Kw,
        ze = Ye.__version === void 0 || Ee === !0,
        ke = C(O, Ne, Pt);
      if (O.isDepthTexture)
        (be = t.DEPTH_COMPONENT),
          a
            ? O.type === ss
              ? (be = t.DEPTH_COMPONENT32F)
              : O.type === fo
              ? (be = t.DEPTH_COMPONENT24)
              : O.type === ua
              ? (be = t.DEPTH24_STENCIL8)
              : (be = t.DEPTH_COMPONENT16)
            : O.type === ss &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          O.format === ca &&
            be === t.DEPTH_COMPONENT &&
            O.type !== k0 &&
            O.type !== fo &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (O.type = fo),
            (me = s.convert(O.type))),
          O.format === Rl &&
            be === t.DEPTH_COMPONENT &&
            ((be = t.DEPTH_STENCIL),
            O.type !== ua &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (O.type = ua),
              (me = s.convert(O.type)))),
          ze &&
            (K
              ? n.texStorage2D(t.TEXTURE_2D, 1, be, Ne.width, Ne.height)
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  be,
                  Ne.width,
                  Ne.height,
                  0,
                  q,
                  me,
                  null
                ));
      else if (O.isDataTexture)
        if (Be.length > 0 && Pt) {
          K &&
            ze &&
            n.texStorage2D(t.TEXTURE_2D, ke, be, Be[0].width, Be[0].height);
          for (let ye = 0, Oe = Be.length; ye < Oe; ye++)
            (ue = Be[ye]),
              K
                ? n.texSubImage2D(
                    t.TEXTURE_2D,
                    ye,
                    0,
                    0,
                    ue.width,
                    ue.height,
                    q,
                    me,
                    ue.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    ye,
                    be,
                    ue.width,
                    ue.height,
                    0,
                    q,
                    me,
                    ue.data
                  );
          O.generateMipmaps = !1;
        } else
          K
            ? (ze && n.texStorage2D(t.TEXTURE_2D, ke, be, Ne.width, Ne.height),
              n.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                Ne.width,
                Ne.height,
                q,
                me,
                Ne.data
              ))
            : n.texImage2D(
                t.TEXTURE_2D,
                0,
                be,
                Ne.width,
                Ne.height,
                0,
                q,
                me,
                Ne.data
              );
      else if (O.isCompressedTexture)
        if (O.isCompressedArrayTexture) {
          K &&
            ze &&
            n.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              ke,
              be,
              Be[0].width,
              Be[0].height,
              Ne.depth
            );
          for (let ye = 0, Oe = Be.length; ye < Oe; ye++)
            (ue = Be[ye]),
              O.format !== zr
                ? q !== null
                  ? K
                    ? n.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        ye,
                        0,
                        0,
                        0,
                        ue.width,
                        ue.height,
                        Ne.depth,
                        q,
                        ue.data,
                        0,
                        0
                      )
                    : n.compressedTexImage3D(
                        t.TEXTURE_2D_ARRAY,
                        ye,
                        be,
                        ue.width,
                        ue.height,
                        Ne.depth,
                        0,
                        ue.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : K
                ? n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    ye,
                    0,
                    0,
                    0,
                    ue.width,
                    ue.height,
                    Ne.depth,
                    q,
                    me,
                    ue.data
                  )
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    ye,
                    be,
                    ue.width,
                    ue.height,
                    Ne.depth,
                    0,
                    q,
                    me,
                    ue.data
                  );
        } else {
          K &&
            ze &&
            n.texStorage2D(t.TEXTURE_2D, ke, be, Be[0].width, Be[0].height);
          for (let ye = 0, Oe = Be.length; ye < Oe; ye++)
            (ue = Be[ye]),
              O.format !== zr
                ? q !== null
                  ? K
                    ? n.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        ye,
                        0,
                        0,
                        ue.width,
                        ue.height,
                        q,
                        ue.data
                      )
                    : n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        ye,
                        be,
                        ue.width,
                        ue.height,
                        0,
                        ue.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : K
                ? n.texSubImage2D(
                    t.TEXTURE_2D,
                    ye,
                    0,
                    0,
                    ue.width,
                    ue.height,
                    q,
                    me,
                    ue.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    ye,
                    be,
                    ue.width,
                    ue.height,
                    0,
                    q,
                    me,
                    ue.data
                  );
        }
      else if (O.isDataArrayTexture)
        K
          ? (ze &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                ke,
                be,
                Ne.width,
                Ne.height,
                Ne.depth
              ),
            n.texSubImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              Ne.width,
              Ne.height,
              Ne.depth,
              q,
              me,
              Ne.data
            ))
          : n.texImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              be,
              Ne.width,
              Ne.height,
              Ne.depth,
              0,
              q,
              me,
              Ne.data
            );
      else if (O.isData3DTexture)
        K
          ? (ze &&
              n.texStorage3D(
                t.TEXTURE_3D,
                ke,
                be,
                Ne.width,
                Ne.height,
                Ne.depth
              ),
            n.texSubImage3D(
              t.TEXTURE_3D,
              0,
              0,
              0,
              0,
              Ne.width,
              Ne.height,
              Ne.depth,
              q,
              me,
              Ne.data
            ))
          : n.texImage3D(
              t.TEXTURE_3D,
              0,
              be,
              Ne.width,
              Ne.height,
              Ne.depth,
              0,
              q,
              me,
              Ne.data
            );
      else if (O.isFramebufferTexture) {
        if (ze)
          if (K) n.texStorage2D(t.TEXTURE_2D, ke, be, Ne.width, Ne.height);
          else {
            let ye = Ne.width,
              Oe = Ne.height;
            for (let nt = 0; nt < ke; nt++)
              n.texImage2D(t.TEXTURE_2D, nt, be, ye, Oe, 0, q, me, null),
                (ye >>= 1),
                (Oe >>= 1);
          }
      } else if (Be.length > 0 && Pt) {
        K &&
          ze &&
          n.texStorage2D(t.TEXTURE_2D, ke, be, Be[0].width, Be[0].height);
        for (let ye = 0, Oe = Be.length; ye < Oe; ye++)
          (ue = Be[ye]),
            K
              ? n.texSubImage2D(t.TEXTURE_2D, ye, 0, 0, q, me, ue)
              : n.texImage2D(t.TEXTURE_2D, ye, be, q, me, ue);
        O.generateMipmaps = !1;
      } else
        K
          ? (ze && n.texStorage2D(t.TEXTURE_2D, ke, be, Ne.width, Ne.height),
            n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, q, me, Ne))
          : n.texImage2D(t.TEXTURE_2D, 0, be, q, me, Ne);
      A(O, Pt) && L(Re),
        (Ye.__version = Ae.version),
        O.onUpdate && O.onUpdate(O);
    }
    V.__version = O.version;
  }
  function Me(V, O, se) {
    if (O.image.length !== 6) return;
    const Re = et(V, O),
      Ee = O.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, V.__webglTexture, t.TEXTURE0 + se);
    const Ae = r.get(Ee);
    if (Ee.version !== Ae.__version || Re === !0) {
      n.activeTexture(t.TEXTURE0 + se);
      const Ye = Wt.getPrimaries(Wt.workingColorSpace),
        Pe = O.colorSpace === hi ? null : Wt.getPrimaries(O.colorSpace),
        Te =
          O.colorSpace === hi || Ye === Pe ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, O.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, O.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Te);
      const at = O.isCompressedTexture || O.image[0].isCompressedTexture,
        wt = O.image[0] && O.image[0].isDataTexture,
        Ne = [];
      for (let ye = 0; ye < 6; ye++)
        !at && !wt
          ? (Ne[ye] = S(O.image[ye], !1, !0, f))
          : (Ne[ye] = wt ? O.image[ye].image : O.image[ye]),
          (Ne[ye] = Tt(O, Ne[ye]));
      const Pt = Ne[0],
        q = E(Pt) || a,
        me = s.convert(O.format, O.colorSpace),
        be = s.convert(O.type),
        ue = N(O.internalFormat, me, be, O.colorSpace),
        Be = a && O.isVideoTexture !== !0,
        K = Ae.__version === void 0 || Re === !0;
      let ze = C(O, Pt, q);
      Ce(t.TEXTURE_CUBE_MAP, O, q);
      let ke;
      if (at) {
        Be &&
          K &&
          n.texStorage2D(t.TEXTURE_CUBE_MAP, ze, ue, Pt.width, Pt.height);
        for (let ye = 0; ye < 6; ye++) {
          ke = Ne[ye].mipmaps;
          for (let Oe = 0; Oe < ke.length; Oe++) {
            const nt = ke[Oe];
            O.format !== zr
              ? me !== null
                ? Be
                  ? n.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      Oe,
                      0,
                      0,
                      nt.width,
                      nt.height,
                      me,
                      nt.data
                    )
                  : n.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      Oe,
                      ue,
                      nt.width,
                      nt.height,
                      0,
                      nt.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Be
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  Oe,
                  0,
                  0,
                  nt.width,
                  nt.height,
                  me,
                  be,
                  nt.data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  Oe,
                  ue,
                  nt.width,
                  nt.height,
                  0,
                  me,
                  be,
                  nt.data
                );
          }
        }
      } else {
        (ke = O.mipmaps),
          Be &&
            K &&
            (ke.length > 0 && ze++,
            n.texStorage2D(
              t.TEXTURE_CUBE_MAP,
              ze,
              ue,
              Ne[0].width,
              Ne[0].height
            ));
        for (let ye = 0; ye < 6; ye++)
          if (wt) {
            Be
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  Ne[ye].width,
                  Ne[ye].height,
                  me,
                  be,
                  Ne[ye].data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  ue,
                  Ne[ye].width,
                  Ne[ye].height,
                  0,
                  me,
                  be,
                  Ne[ye].data
                );
            for (let Oe = 0; Oe < ke.length; Oe++) {
              const xt = ke[Oe].image[ye].image;
              Be
                ? n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    Oe + 1,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    me,
                    be,
                    xt.data
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    Oe + 1,
                    ue,
                    xt.width,
                    xt.height,
                    0,
                    me,
                    be,
                    xt.data
                  );
            }
          } else {
            Be
              ? n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  me,
                  be,
                  Ne[ye]
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  ue,
                  me,
                  be,
                  Ne[ye]
                );
            for (let Oe = 0; Oe < ke.length; Oe++) {
              const nt = ke[Oe];
              Be
                ? n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    Oe + 1,
                    0,
                    0,
                    me,
                    be,
                    nt.image[ye]
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    Oe + 1,
                    ue,
                    me,
                    be,
                    nt.image[ye]
                  );
            }
          }
      }
      A(O, q) && L(t.TEXTURE_CUBE_MAP),
        (Ae.__version = Ee.version),
        O.onUpdate && O.onUpdate(O);
    }
    V.__version = O.version;
  }
  function Le(V, O, se, Re, Ee, Ae) {
    const Ye = s.convert(se.format, se.colorSpace),
      Pe = s.convert(se.type),
      Te = N(se.internalFormat, Ye, Pe, se.colorSpace);
    if (!r.get(O).__hasExternalTextures) {
      const wt = Math.max(1, O.width >> Ae),
        Ne = Math.max(1, O.height >> Ae);
      Ee === t.TEXTURE_3D || Ee === t.TEXTURE_2D_ARRAY
        ? n.texImage3D(Ee, Ae, Te, wt, Ne, O.depth, 0, Ye, Pe, null)
        : n.texImage2D(Ee, Ae, Te, wt, Ne, 0, Ye, Pe, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, V),
      Ze(O)
        ? p.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            Re,
            Ee,
            r.get(se).__webglTexture,
            0,
            He(O)
          )
        : (Ee === t.TEXTURE_2D ||
            (Ee >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ee <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            Re,
            Ee,
            r.get(se).__webglTexture,
            Ae
          ),
      n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function H(V, O, se) {
    if (
      (t.bindRenderbuffer(t.RENDERBUFFER, V), O.depthBuffer && !O.stencilBuffer)
    ) {
      let Re = a === !0 ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
      if (se || Ze(O)) {
        const Ee = O.depthTexture;
        Ee &&
          Ee.isDepthTexture &&
          (Ee.type === ss
            ? (Re = t.DEPTH_COMPONENT32F)
            : Ee.type === fo && (Re = t.DEPTH_COMPONENT24));
        const Ae = He(O);
        Ze(O)
          ? p.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              Ae,
              Re,
              O.width,
              O.height
            )
          : t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              Ae,
              Re,
              O.width,
              O.height
            );
      } else t.renderbufferStorage(t.RENDERBUFFER, Re, O.width, O.height);
      t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        V
      );
    } else if (O.depthBuffer && O.stencilBuffer) {
      const Re = He(O);
      se && Ze(O) === !1
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Re,
            t.DEPTH24_STENCIL8,
            O.width,
            O.height
          )
        : Ze(O)
        ? p.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            Re,
            t.DEPTH24_STENCIL8,
            O.width,
            O.height
          )
        : t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            O.width,
            O.height
          ),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          V
        );
    } else {
      const Re =
        O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
      for (let Ee = 0; Ee < Re.length; Ee++) {
        const Ae = Re[Ee],
          Ye = s.convert(Ae.format, Ae.colorSpace),
          Pe = s.convert(Ae.type),
          Te = N(Ae.internalFormat, Ye, Pe, Ae.colorSpace),
          at = He(O);
        se && Ze(O) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              at,
              Te,
              O.width,
              O.height
            )
          : Ze(O)
          ? p.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              at,
              Te,
              O.width,
              O.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, Te, O.width, O.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function pe(V, O) {
    if (O && O.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (n.bindFramebuffer(t.FRAMEBUFFER, V),
      !(O.depthTexture && O.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(O.depthTexture).__webglTexture ||
      O.depthTexture.image.width !== O.width ||
      O.depthTexture.image.height !== O.height) &&
      ((O.depthTexture.image.width = O.width),
      (O.depthTexture.image.height = O.height),
      (O.depthTexture.needsUpdate = !0)),
      X(O.depthTexture, 0);
    const Re = r.get(O.depthTexture).__webglTexture,
      Ee = He(O);
    if (O.depthTexture.format === ca)
      Ze(O)
        ? p.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            Re,
            0,
            Ee
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            Re,
            0
          );
    else if (O.depthTexture.format === Rl)
      Ze(O)
        ? p.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            Re,
            0,
            Ee
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            Re,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function ie(V) {
    const O = r.get(V),
      se = V.isWebGLCubeRenderTarget === !0;
    if (V.depthTexture && !O.__autoAllocateDepthBuffer) {
      if (se)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      pe(O.__webglFramebuffer, V);
    } else if (se) {
      O.__webglDepthbuffer = [];
      for (let Re = 0; Re < 6; Re++)
        n.bindFramebuffer(t.FRAMEBUFFER, O.__webglFramebuffer[Re]),
          (O.__webglDepthbuffer[Re] = t.createRenderbuffer()),
          H(O.__webglDepthbuffer[Re], V, !1);
    } else
      n.bindFramebuffer(t.FRAMEBUFFER, O.__webglFramebuffer),
        (O.__webglDepthbuffer = t.createRenderbuffer()),
        H(O.__webglDepthbuffer, V, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function we(V, O, se) {
    const Re = r.get(V);
    O !== void 0 &&
      Le(
        Re.__webglFramebuffer,
        V,
        V.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      se !== void 0 && ie(V);
  }
  function xe(V) {
    const O = V.texture,
      se = r.get(V),
      Re = r.get(O);
    V.addEventListener("dispose", R),
      V.isWebGLMultipleRenderTargets !== !0 &&
        (Re.__webglTexture === void 0 &&
          (Re.__webglTexture = t.createTexture()),
        (Re.__version = O.version),
        o.memory.textures++);
    const Ee = V.isWebGLCubeRenderTarget === !0,
      Ae = V.isWebGLMultipleRenderTargets === !0,
      Ye = E(V) || a;
    if (Ee) {
      se.__webglFramebuffer = [];
      for (let Pe = 0; Pe < 6; Pe++)
        if (a && O.mipmaps && O.mipmaps.length > 0) {
          se.__webglFramebuffer[Pe] = [];
          for (let Te = 0; Te < O.mipmaps.length; Te++)
            se.__webglFramebuffer[Pe][Te] = t.createFramebuffer();
        } else se.__webglFramebuffer[Pe] = t.createFramebuffer();
    } else {
      if (a && O.mipmaps && O.mipmaps.length > 0) {
        se.__webglFramebuffer = [];
        for (let Pe = 0; Pe < O.mipmaps.length; Pe++)
          se.__webglFramebuffer[Pe] = t.createFramebuffer();
      } else se.__webglFramebuffer = t.createFramebuffer();
      if (Ae)
        if (i.drawBuffers) {
          const Pe = V.texture;
          for (let Te = 0, at = Pe.length; Te < at; Te++) {
            const wt = r.get(Pe[Te]);
            wt.__webglTexture === void 0 &&
              ((wt.__webglTexture = t.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && V.samples > 0 && Ze(V) === !1) {
        const Pe = Ae ? O : [O];
        (se.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (se.__webglColorRenderbuffer = []),
          n.bindFramebuffer(t.FRAMEBUFFER, se.__webglMultisampledFramebuffer);
        for (let Te = 0; Te < Pe.length; Te++) {
          const at = Pe[Te];
          (se.__webglColorRenderbuffer[Te] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, se.__webglColorRenderbuffer[Te]);
          const wt = s.convert(at.format, at.colorSpace),
            Ne = s.convert(at.type),
            Pt = N(
              at.internalFormat,
              wt,
              Ne,
              at.colorSpace,
              V.isXRRenderTarget === !0
            ),
            q = He(V);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            q,
            Pt,
            V.width,
            V.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Te,
              t.RENDERBUFFER,
              se.__webglColorRenderbuffer[Te]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          V.depthBuffer &&
            ((se.__webglDepthRenderbuffer = t.createRenderbuffer()),
            H(se.__webglDepthRenderbuffer, V, !0)),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (Ee) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, Re.__webglTexture),
        Ce(t.TEXTURE_CUBE_MAP, O, Ye);
      for (let Pe = 0; Pe < 6; Pe++)
        if (a && O.mipmaps && O.mipmaps.length > 0)
          for (let Te = 0; Te < O.mipmaps.length; Te++)
            Le(
              se.__webglFramebuffer[Pe][Te],
              V,
              O,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + Pe,
              Te
            );
        else
          Le(
            se.__webglFramebuffer[Pe],
            V,
            O,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + Pe,
            0
          );
      A(O, Ye) && L(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Ae) {
      const Pe = V.texture;
      for (let Te = 0, at = Pe.length; Te < at; Te++) {
        const wt = Pe[Te],
          Ne = r.get(wt);
        n.bindTexture(t.TEXTURE_2D, Ne.__webglTexture),
          Ce(t.TEXTURE_2D, wt, Ye),
          Le(
            se.__webglFramebuffer,
            V,
            wt,
            t.COLOR_ATTACHMENT0 + Te,
            t.TEXTURE_2D,
            0
          ),
          A(wt, Ye) && L(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Pe = t.TEXTURE_2D;
      if (
        ((V.isWebGL3DRenderTarget || V.isWebGLArrayRenderTarget) &&
          (a
            ? (Pe = V.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        n.bindTexture(Pe, Re.__webglTexture),
        Ce(Pe, O, Ye),
        a && O.mipmaps && O.mipmaps.length > 0)
      )
        for (let Te = 0; Te < O.mipmaps.length; Te++)
          Le(se.__webglFramebuffer[Te], V, O, t.COLOR_ATTACHMENT0, Pe, Te);
      else Le(se.__webglFramebuffer, V, O, t.COLOR_ATTACHMENT0, Pe, 0);
      A(O, Ye) && L(Pe), n.unbindTexture();
    }
    V.depthBuffer && ie(V);
  }
  function $e(V) {
    const O = E(V) || a,
      se = V.isWebGLMultipleRenderTargets === !0 ? V.texture : [V.texture];
    for (let Re = 0, Ee = se.length; Re < Ee; Re++) {
      const Ae = se[Re];
      if (A(Ae, O)) {
        const Ye = V.isWebGLCubeRenderTarget
            ? t.TEXTURE_CUBE_MAP
            : t.TEXTURE_2D,
          Pe = r.get(Ae).__webglTexture;
        n.bindTexture(Ye, Pe), L(Ye), n.unbindTexture();
      }
    }
  }
  function Fe(V) {
    if (a && V.samples > 0 && Ze(V) === !1) {
      const O = V.isWebGLMultipleRenderTargets ? V.texture : [V.texture],
        se = V.width,
        Re = V.height;
      let Ee = t.COLOR_BUFFER_BIT;
      const Ae = [],
        Ye = V.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        Pe = r.get(V),
        Te = V.isWebGLMultipleRenderTargets === !0;
      if (Te)
        for (let at = 0; at < O.length; at++)
          n.bindFramebuffer(t.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + at,
              t.RENDERBUFFER,
              null
            ),
            n.bindFramebuffer(t.FRAMEBUFFER, Pe.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + at,
              t.TEXTURE_2D,
              null,
              0
            );
      n.bindFramebuffer(t.READ_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Pe.__webglFramebuffer);
      for (let at = 0; at < O.length; at++) {
        Ae.push(t.COLOR_ATTACHMENT0 + at), V.depthBuffer && Ae.push(Ye);
        const wt =
          Pe.__ignoreDepthValues !== void 0 ? Pe.__ignoreDepthValues : !1;
        if (
          (wt === !1 &&
            (V.depthBuffer && (Ee |= t.DEPTH_BUFFER_BIT),
            V.stencilBuffer && (Ee |= t.STENCIL_BUFFER_BIT)),
          Te &&
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              Pe.__webglColorRenderbuffer[at]
            ),
          wt === !0 &&
            (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [Ye]),
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [Ye])),
          Te)
        ) {
          const Ne = r.get(O[at]).__webglTexture;
          t.framebufferTexture2D(
            t.DRAW_FRAMEBUFFER,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            Ne,
            0
          );
        }
        t.blitFramebuffer(0, 0, se, Re, 0, 0, se, Re, Ee, t.NEAREST),
          g && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, Ae);
      }
      if (
        (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        Te)
      )
        for (let at = 0; at < O.length; at++) {
          n.bindFramebuffer(t.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + at,
              t.RENDERBUFFER,
              Pe.__webglColorRenderbuffer[at]
            );
          const wt = r.get(O[at]).__webglTexture;
          n.bindFramebuffer(t.FRAMEBUFFER, Pe.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + at,
              t.TEXTURE_2D,
              wt,
              0
            );
        }
      n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer);
    }
  }
  function He(V) {
    return Math.min(h, V.samples);
  }
  function Ze(V) {
    const O = r.get(V);
    return (
      a &&
      V.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      O.__useRenderToTexture !== !1
    );
  }
  function it(V) {
    const O = o.render.frame;
    v.get(V) !== O && (v.set(V, O), V.update());
  }
  function Tt(V, O) {
    const se = V.colorSpace,
      Re = V.format,
      Ee = V.type;
    return (
      V.isCompressedTexture === !0 ||
        V.isVideoTexture === !0 ||
        V.format === Fg ||
        (se !== zs &&
          se !== hi &&
          (Wt.getTransfer(se) === Jt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Re === zr
                ? ((V.format = Fg),
                  (V.minFilter = Rn),
                  (V.generateMipmaps = !1))
                : (O = tM.sRGBToLinear(O))
              : (Re !== zr || Ee !== ks) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                se
              ))),
      O
    );
  }
  (this.allocateTextureUnit = B),
    (this.resetTextureUnits = Z),
    (this.setTexture2D = X),
    (this.setTexture2DArray = te),
    (this.setTexture3D = oe),
    (this.setTextureCube = J),
    (this.rebindTextures = we),
    (this.setupRenderTarget = xe),
    (this.updateRenderTargetMipmap = $e),
    (this.updateMultisampleRenderTarget = Fe),
    (this.setupDepthRenderbuffer = ie),
    (this.setupFrameBufferTexture = Le),
    (this.useMultisampledRTT = Ze);
}
function r3(t, e, n) {
  const r = n.isWebGL2;
  function i(s, o = hi) {
    let a;
    const l = Wt.getTransfer(o);
    if (s === ks) return t.UNSIGNED_BYTE;
    if (s === jw) return t.UNSIGNED_SHORT_4_4_4_4;
    if (s === $w) return t.UNSIGNED_SHORT_5_5_5_1;
    if (s === wI) return t.BYTE;
    if (s === MI) return t.SHORT;
    if (s === k0) return t.UNSIGNED_SHORT;
    if (s === Gw) return t.INT;
    if (s === fo) return t.UNSIGNED_INT;
    if (s === ss) return t.FLOAT;
    if (s === xc)
      return r
        ? t.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === EI) return t.ALPHA;
    if (s === zr) return t.RGBA;
    if (s === bI) return t.LUMINANCE;
    if (s === TI) return t.LUMINANCE_ALPHA;
    if (s === ca) return t.DEPTH_COMPONENT;
    if (s === Rl) return t.DEPTH_STENCIL;
    if (s === Fg)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === AI) return t.RED;
    if (s === Xw) return t.RED_INTEGER;
    if (s === CI) return t.RG;
    if (s === Yw) return t.RG_INTEGER;
    if (s === qw) return t.RGBA_INTEGER;
    if (s === Xm || s === Ym || s === qm || s === Km)
      if (l === Jt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === Xm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Ym) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === qm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Km) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === Xm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Ym) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === qm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Km) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === LS || s === IS || s === NS || s === OS)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === LS) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === IS) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === NS) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === OS) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === Kw)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === DS || s === kS)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === DS)
          return l === Jt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === kS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === US ||
      s === FS ||
      s === zS ||
      s === BS ||
      s === HS ||
      s === VS ||
      s === WS ||
      s === GS ||
      s === jS ||
      s === $S ||
      s === XS ||
      s === YS ||
      s === qS ||
      s === KS
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === US)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === FS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === zS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === BS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === HS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === VS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === WS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === GS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === jS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === $S)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === XS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === YS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === qS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === KS)
          return l === Jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === Zm || s === ZS || s === JS)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === Zm)
          return l === Jt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === ZS) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === JS) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === RI || s === QS || s === e1 || s === t1)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === Zm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === QS) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === e1) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === t1) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ua
      ? r
        ? t.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : t[s] !== void 0
      ? t[s]
      : null;
  }
  return { convert: i };
}
class i3 extends Pn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Ku extends Ft {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const NW = { type: "move" };
class jx {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Ku()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Ku()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Ku()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new z())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n) for (const r of e.hand.values()) this._getHandJoint(n, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, n, r) {
    let i = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      f = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        o = !0;
        for (const _ of e.hand.values()) {
          const x = n.getJointPose(_, r),
            m = this._getHandJoint(f, _);
          x !== null &&
            (m.matrix.fromArray(x.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.matrixWorldNeedsUpdate = !0),
            (m.jointRadius = x.radius)),
            (m.visible = x !== null);
        }
        const d = f.joints["index-finger-tip"],
          h = f.joints["thumb-tip"],
          p = d.position.distanceTo(h.position),
          g = 0.02,
          v = 0.005;
        f.inputState.pinching && p > g + v
          ? ((f.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !f.inputState.pinching &&
            p <= g - v &&
            ((f.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = n.getPose(e.gripSpace, r)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = n.getPose(e.targetRaySpace, r)),
        i === null && s !== null && (i = s),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(NW)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = s !== null),
      f !== null && (f.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const r = new Ku();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[n.jointName] = r),
        e.add(r);
    }
    return e.joints[n.jointName];
  }
}
class OW extends Ao {
  constructor(e, n) {
    super();
    const r = this;
    let i = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      f = null,
      d = null,
      h = null,
      p = null,
      g = null,
      v = null;
    const _ = n.getContextAttributes();
    let x = null,
      m = null;
    const w = [],
      S = [],
      E = new _e();
    let T = null;
    const A = new Pn();
    A.layers.enable(1), (A.viewport = new Gt());
    const L = new Pn();
    L.layers.enable(2), (L.viewport = new Gt());
    const N = [A, L],
      C = new i3();
    C.layers.enable(1), C.layers.enable(2);
    let I = null,
      k = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let ae = w[J];
        return (
          ae === void 0 && ((ae = new jx()), (w[J] = ae)),
          ae.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let ae = w[J];
        return (
          ae === void 0 && ((ae = new jx()), (w[J] = ae)), ae.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let ae = w[J];
        return (
          ae === void 0 && ((ae = new jx()), (w[J] = ae)), ae.getHandSpace()
        );
      });
    function R(J) {
      const ae = S.indexOf(J.inputSource);
      if (ae === -1) return;
      const Se = w[ae];
      Se !== void 0 &&
        (Se.update(J.inputSource, J.frame, f || o),
        Se.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function $() {
      i.removeEventListener("select", R),
        i.removeEventListener("selectstart", R),
        i.removeEventListener("selectend", R),
        i.removeEventListener("squeeze", R),
        i.removeEventListener("squeezestart", R),
        i.removeEventListener("squeezeend", R),
        i.removeEventListener("end", $),
        i.removeEventListener("inputsourceschange", D);
      for (let J = 0; J < w.length; J++) {
        const ae = S[J];
        ae !== null && ((S[J] = null), w[J].disconnect(ae));
      }
      (I = null),
        (k = null),
        e.setRenderTarget(x),
        (g = null),
        (p = null),
        (h = null),
        (i = null),
        (m = null),
        oe.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(T),
        e.setSize(E.width, E.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (J) {
      (s = J),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (J) {
        (a = J),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return f || o;
      }),
      (this.setReferenceSpace = function (J) {
        f = J;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : g;
      }),
      (this.getBinding = function () {
        return h;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (J) {
        if (((i = J), i !== null)) {
          if (
            ((x = e.getRenderTarget()),
            i.addEventListener("select", R),
            i.addEventListener("selectstart", R),
            i.addEventListener("selectend", R),
            i.addEventListener("squeeze", R),
            i.addEventListener("squeezestart", R),
            i.addEventListener("squeezeend", R),
            i.addEventListener("end", $),
            i.addEventListener("inputsourceschange", D),
            _.xrCompatible !== !0 && (await n.makeXRCompatible()),
            (T = e.getPixelRatio()),
            e.getSize(E),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ae = {
              antialias: i.renderState.layers === void 0 ? _.antialias : !0,
              alpha: !0,
              depth: _.depth,
              stencil: _.stencil,
              framebufferScaleFactor: s,
            };
            (g = new XRWebGLLayer(i, n, ae)),
              i.updateRenderState({ baseLayer: g }),
              e.setPixelRatio(1),
              e.setSize(g.framebufferWidth, g.framebufferHeight, !1),
              (m = new cs(g.framebufferWidth, g.framebufferHeight, {
                format: zr,
                type: ks,
                colorSpace: e.outputColorSpace,
                stencilBuffer: _.stencil,
              }));
          } else {
            let ae = null,
              Se = null,
              Ie = null;
            _.depth &&
              ((Ie = _.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (ae = _.stencil ? Rl : ca),
              (Se = _.stencil ? ua : fo));
            const Ce = {
              colorFormat: n.RGBA8,
              depthFormat: Ie,
              scaleFactor: s,
            };
            (h = new XRWebGLBinding(i, n)),
              (p = h.createProjectionLayer(Ce)),
              i.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (m = new cs(p.textureWidth, p.textureHeight, {
                format: zr,
                type: ks,
                depthTexture: new oM(
                  p.textureWidth,
                  p.textureHeight,
                  Se,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ae
                ),
                stencilBuffer: _.stencil,
                colorSpace: e.outputColorSpace,
                samples: _.antialias ? 4 : 0,
              }));
            const et = e.properties.get(m);
            et.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (m.isXRRenderTarget = !0),
            this.setFoveation(l),
            (f = null),
            (o = await i.requestReferenceSpace(a)),
            oe.setContext(i),
            oe.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function D(J) {
      for (let ae = 0; ae < J.removed.length; ae++) {
        const Se = J.removed[ae],
          Ie = S.indexOf(Se);
        Ie >= 0 && ((S[Ie] = null), w[Ie].disconnect(Se));
      }
      for (let ae = 0; ae < J.added.length; ae++) {
        const Se = J.added[ae];
        let Ie = S.indexOf(Se);
        if (Ie === -1) {
          for (let et = 0; et < w.length; et++)
            if (et >= S.length) {
              S.push(Se), (Ie = et);
              break;
            } else if (S[et] === null) {
              (S[et] = Se), (Ie = et);
              break;
            }
          if (Ie === -1) break;
        }
        const Ce = w[Ie];
        Ce && Ce.connect(Se);
      }
    }
    const W = new z(),
      Y = new z();
    function Z(J, ae, Se) {
      W.setFromMatrixPosition(ae.matrixWorld),
        Y.setFromMatrixPosition(Se.matrixWorld);
      const Ie = W.distanceTo(Y),
        Ce = ae.projectionMatrix.elements,
        et = Se.projectionMatrix.elements,
        We = Ce[14] / (Ce[10] - 1),
        Me = Ce[14] / (Ce[10] + 1),
        Le = (Ce[9] + 1) / Ce[5],
        H = (Ce[9] - 1) / Ce[5],
        pe = (Ce[8] - 1) / Ce[0],
        ie = (et[8] + 1) / et[0],
        we = We * pe,
        xe = We * ie,
        $e = Ie / (-pe + ie),
        Fe = $e * -pe;
      ae.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(Fe),
        J.translateZ($e),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const He = We + $e,
        Ze = Me + $e,
        it = we - Fe,
        Tt = xe + (Ie - Fe),
        V = ((Le * Me) / Ze) * He,
        O = ((H * Me) / Ze) * He;
      J.projectionMatrix.makePerspective(it, Tt, V, O, He, Ze),
        J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
    }
    function B(J, ae) {
      ae === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(ae.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function (J) {
      if (i === null) return;
      (C.near = L.near = A.near = J.near),
        (C.far = L.far = A.far = J.far),
        (I !== C.near || k !== C.far) &&
          (i.updateRenderState({ depthNear: C.near, depthFar: C.far }),
          (I = C.near),
          (k = C.far));
      const ae = J.parent,
        Se = C.cameras;
      B(C, ae);
      for (let Ie = 0; Ie < Se.length; Ie++) B(Se[Ie], ae);
      Se.length === 2
        ? Z(C, A, L)
        : C.projectionMatrix.copy(A.projectionMatrix),
        G(J, C, ae);
    };
    function G(J, ae, Se) {
      Se === null
        ? J.matrix.copy(ae.matrixWorld)
        : (J.matrix.copy(Se.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(ae.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(ae.projectionMatrix),
        J.projectionMatrixInverse.copy(ae.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = Sc * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1));
    }
    (this.getCamera = function () {
      return C;
    }),
      (this.getFoveation = function () {
        if (!(p === null && g === null)) return l;
      }),
      (this.setFoveation = function (J) {
        (l = J),
          p !== null && (p.fixedFoveation = J),
          g !== null && g.fixedFoveation !== void 0 && (g.fixedFoveation = J);
      });
    let X = null;
    function te(J, ae) {
      if (((d = ae.getViewerPose(f || o)), (v = ae), d !== null)) {
        const Se = d.views;
        g !== null &&
          (e.setRenderTargetFramebuffer(m, g.framebuffer),
          e.setRenderTarget(m));
        let Ie = !1;
        Se.length !== C.cameras.length && ((C.cameras.length = 0), (Ie = !0));
        for (let Ce = 0; Ce < Se.length; Ce++) {
          const et = Se[Ce];
          let We = null;
          if (g !== null) We = g.getViewport(et);
          else {
            const Le = h.getViewSubImage(p, et);
            (We = Le.viewport),
              Ce === 0 &&
                (e.setRenderTargetTextures(
                  m,
                  Le.colorTexture,
                  p.ignoreDepthValues ? void 0 : Le.depthStencilTexture
                ),
                e.setRenderTarget(m));
          }
          let Me = N[Ce];
          Me === void 0 &&
            ((Me = new Pn()),
            Me.layers.enable(Ce),
            (Me.viewport = new Gt()),
            (N[Ce] = Me)),
            Me.matrix.fromArray(et.transform.matrix),
            Me.matrix.decompose(Me.position, Me.quaternion, Me.scale),
            Me.projectionMatrix.fromArray(et.projectionMatrix),
            Me.projectionMatrixInverse.copy(Me.projectionMatrix).invert(),
            Me.viewport.set(We.x, We.y, We.width, We.height),
            Ce === 0 &&
              (C.matrix.copy(Me.matrix),
              C.matrix.decompose(C.position, C.quaternion, C.scale)),
            Ie === !0 && C.cameras.push(Me);
        }
      }
      for (let Se = 0; Se < w.length; Se++) {
        const Ie = S[Se],
          Ce = w[Se];
        Ie !== null && Ce !== void 0 && Ce.update(Ie, ae, f || o);
      }
      X && X(J, ae),
        ae.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: ae }),
        (v = null);
    }
    const oe = new ZI();
    oe.setAnimationLoop(te),
      (this.setAnimationLoop = function (J) {
        X = J;
      }),
      (this.dispose = function () {});
  }
}
function DW(t, e) {
  function n(x, m) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), m.value.copy(x.matrix);
  }
  function r(x, m) {
    m.color.getRGB(x.fogColor.value, XI(t)),
      m.isFog
        ? ((x.fogNear.value = m.near), (x.fogFar.value = m.far))
        : m.isFogExp2 && (x.fogDensity.value = m.density);
  }
  function i(x, m, w, S, E) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? s(x, m)
      : m.isMeshToonMaterial
      ? (s(x, m), h(x, m))
      : m.isMeshPhongMaterial
      ? (s(x, m), d(x, m))
      : m.isMeshStandardMaterial
      ? (s(x, m), p(x, m), m.isMeshPhysicalMaterial && g(x, m, E))
      : m.isMeshMatcapMaterial
      ? (s(x, m), v(x, m))
      : m.isMeshDepthMaterial
      ? s(x, m)
      : m.isMeshDistanceMaterial
      ? (s(x, m), _(x, m))
      : m.isMeshNormalMaterial
      ? s(x, m)
      : m.isLineBasicMaterial
      ? (o(x, m), m.isLineDashedMaterial && a(x, m))
      : m.isPointsMaterial
      ? l(x, m, w, S)
      : m.isSpriteMaterial
      ? f(x, m)
      : m.isShadowMaterial
      ? (x.color.value.copy(m.color), (x.opacity.value = m.opacity))
      : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function s(x, m) {
    (x.opacity.value = m.opacity),
      m.color && x.diffuse.value.copy(m.color),
      m.emissive &&
        x.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((x.map.value = m.map), n(m.map, x.mapTransform)),
      m.alphaMap &&
        ((x.alphaMap.value = m.alphaMap), n(m.alphaMap, x.alphaMapTransform)),
      m.bumpMap &&
        ((x.bumpMap.value = m.bumpMap),
        n(m.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = m.bumpScale),
        m.side === Hr && (x.bumpScale.value *= -1)),
      m.normalMap &&
        ((x.normalMap.value = m.normalMap),
        n(m.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(m.normalScale),
        m.side === Hr && x.normalScale.value.negate()),
      m.displacementMap &&
        ((x.displacementMap.value = m.displacementMap),
        n(m.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = m.displacementScale),
        (x.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((x.emissiveMap.value = m.emissiveMap),
        n(m.emissiveMap, x.emissiveMapTransform)),
      m.specularMap &&
        ((x.specularMap.value = m.specularMap),
        n(m.specularMap, x.specularMapTransform)),
      m.alphaTest > 0 && (x.alphaTest.value = m.alphaTest);
    const w = e.get(m).envMap;
    if (
      (w &&
        ((x.envMap.value = w),
        (x.flipEnvMap.value =
          w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1),
        (x.reflectivity.value = m.reflectivity),
        (x.ior.value = m.ior),
        (x.refractionRatio.value = m.refractionRatio)),
      m.lightMap)
    ) {
      x.lightMap.value = m.lightMap;
      const S = t._useLegacyLights === !0 ? Math.PI : 1;
      (x.lightMapIntensity.value = m.lightMapIntensity * S),
        n(m.lightMap, x.lightMapTransform);
    }
    m.aoMap &&
      ((x.aoMap.value = m.aoMap),
      (x.aoMapIntensity.value = m.aoMapIntensity),
      n(m.aoMap, x.aoMapTransform));
  }
  function o(x, m) {
    x.diffuse.value.copy(m.color),
      (x.opacity.value = m.opacity),
      m.map && ((x.map.value = m.map), n(m.map, x.mapTransform));
  }
  function a(x, m) {
    (x.dashSize.value = m.dashSize),
      (x.totalSize.value = m.dashSize + m.gapSize),
      (x.scale.value = m.scale);
  }
  function l(x, m, w, S) {
    x.diffuse.value.copy(m.color),
      (x.opacity.value = m.opacity),
      (x.size.value = m.size * w),
      (x.scale.value = S * 0.5),
      m.map && ((x.map.value = m.map), n(m.map, x.uvTransform)),
      m.alphaMap &&
        ((x.alphaMap.value = m.alphaMap), n(m.alphaMap, x.alphaMapTransform)),
      m.alphaTest > 0 && (x.alphaTest.value = m.alphaTest);
  }
  function f(x, m) {
    x.diffuse.value.copy(m.color),
      (x.opacity.value = m.opacity),
      (x.rotation.value = m.rotation),
      m.map && ((x.map.value = m.map), n(m.map, x.mapTransform)),
      m.alphaMap &&
        ((x.alphaMap.value = m.alphaMap), n(m.alphaMap, x.alphaMapTransform)),
      m.alphaTest > 0 && (x.alphaTest.value = m.alphaTest);
  }
  function d(x, m) {
    x.specular.value.copy(m.specular),
      (x.shininess.value = Math.max(m.shininess, 1e-4));
  }
  function h(x, m) {
    m.gradientMap && (x.gradientMap.value = m.gradientMap);
  }
  function p(x, m) {
    (x.metalness.value = m.metalness),
      m.metalnessMap &&
        ((x.metalnessMap.value = m.metalnessMap),
        n(m.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = m.roughness),
      m.roughnessMap &&
        ((x.roughnessMap.value = m.roughnessMap),
        n(m.roughnessMap, x.roughnessMapTransform)),
      e.get(m).envMap && (x.envMapIntensity.value = m.envMapIntensity);
  }
  function g(x, m, w) {
    (x.ior.value = m.ior),
      m.sheen > 0 &&
        (x.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (x.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((x.sheenColorMap.value = m.sheenColorMap),
          n(m.sheenColorMap, x.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = m.sheenRoughnessMap),
          n(m.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((x.clearcoat.value = m.clearcoat),
        (x.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((x.clearcoatMap.value = m.clearcoatMap),
          n(m.clearcoatMap, x.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          n(m.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = m.clearcoatNormalMap),
          n(m.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === Hr && x.clearcoatNormalScale.value.negate())),
      m.iridescence > 0 &&
        ((x.iridescence.value = m.iridescence),
        (x.iridescenceIOR.value = m.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((x.iridescenceMap.value = m.iridescenceMap),
          n(m.iridescenceMap, x.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          n(m.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((x.transmission.value = m.transmission),
        (x.transmissionSamplerMap.value = w.texture),
        x.transmissionSamplerSize.value.set(w.width, w.height),
        m.transmissionMap &&
          ((x.transmissionMap.value = m.transmissionMap),
          n(m.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = m.thickness),
        m.thicknessMap &&
          ((x.thicknessMap.value = m.thicknessMap),
          n(m.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = m.attenuationDistance),
        x.attenuationColor.value.copy(m.attenuationColor)),
      m.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          m.anisotropy * Math.cos(m.anisotropyRotation),
          m.anisotropy * Math.sin(m.anisotropyRotation)
        ),
        m.anisotropyMap &&
          ((x.anisotropyMap.value = m.anisotropyMap),
          n(m.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = m.specularIntensity),
      x.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((x.specularColorMap.value = m.specularColorMap),
        n(m.specularColorMap, x.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((x.specularIntensityMap.value = m.specularIntensityMap),
        n(m.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function v(x, m) {
    m.matcap && (x.matcap.value = m.matcap);
  }
  function _(x, m) {
    const w = e.get(m).light;
    x.referencePosition.value.setFromMatrixPosition(w.matrixWorld),
      (x.nearDistance.value = w.shadow.camera.near),
      (x.farDistance.value = w.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function kW(t, e, n, r) {
  let i = {},
    s = {},
    o = [];
  const a = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(w, S) {
    const E = S.program;
    r.uniformBlockBinding(w, E);
  }
  function f(w, S) {
    let E = i[w.id];
    E === void 0 &&
      (v(w), (E = d(w)), (i[w.id] = E), w.addEventListener("dispose", x));
    const T = S.program;
    r.updateUBOMapping(w, T);
    const A = e.render.frame;
    s[w.id] !== A && (p(w), (s[w.id] = A));
  }
  function d(w) {
    const S = h();
    w.__bindingPointIndex = S;
    const E = t.createBuffer(),
      T = w.__size,
      A = w.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, E),
      t.bufferData(t.UNIFORM_BUFFER, T, A),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, S, E),
      E
    );
  }
  function h() {
    for (let w = 0; w < a; w++) if (o.indexOf(w) === -1) return o.push(w), w;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(w) {
    const S = i[w.id],
      E = w.uniforms,
      T = w.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, S);
    for (let A = 0, L = E.length; A < L; A++) {
      const N = E[A];
      if (g(N, A, T) === !0) {
        const C = N.__offset,
          I = Array.isArray(N.value) ? N.value : [N.value];
        let k = 0;
        for (let R = 0; R < I.length; R++) {
          const $ = I[R],
            D = _($);
          typeof $ == "number"
            ? ((N.__data[0] = $),
              t.bufferSubData(t.UNIFORM_BUFFER, C + k, N.__data))
            : $.isMatrix3
            ? ((N.__data[0] = $.elements[0]),
              (N.__data[1] = $.elements[1]),
              (N.__data[2] = $.elements[2]),
              (N.__data[3] = $.elements[0]),
              (N.__data[4] = $.elements[3]),
              (N.__data[5] = $.elements[4]),
              (N.__data[6] = $.elements[5]),
              (N.__data[7] = $.elements[0]),
              (N.__data[8] = $.elements[6]),
              (N.__data[9] = $.elements[7]),
              (N.__data[10] = $.elements[8]),
              (N.__data[11] = $.elements[0]))
            : ($.toArray(N.__data, k),
              (k += D.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        t.bufferSubData(t.UNIFORM_BUFFER, C, N.__data);
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function g(w, S, E) {
    const T = w.value;
    if (E[S] === void 0) {
      if (typeof T == "number") E[S] = T;
      else {
        const A = Array.isArray(T) ? T : [T],
          L = [];
        for (let N = 0; N < A.length; N++) L.push(A[N].clone());
        E[S] = L;
      }
      return !0;
    } else if (typeof T == "number") {
      if (E[S] !== T) return (E[S] = T), !0;
    } else {
      const A = Array.isArray(E[S]) ? E[S] : [E[S]],
        L = Array.isArray(T) ? T : [T];
      for (let N = 0; N < A.length; N++) {
        const C = A[N];
        if (C.equals(L[N]) === !1) return C.copy(L[N]), !0;
      }
    }
    return !1;
  }
  function v(w) {
    const S = w.uniforms;
    let E = 0;
    const T = 16;
    let A = 0;
    for (let L = 0, N = S.length; L < N; L++) {
      const C = S[L],
        I = { boundary: 0, storage: 0 },
        k = Array.isArray(C.value) ? C.value : [C.value];
      for (let R = 0, $ = k.length; R < $; R++) {
        const D = k[R],
          W = _(D);
        (I.boundary += W.boundary), (I.storage += W.storage);
      }
      if (
        ((C.__data = new Float32Array(
          I.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (C.__offset = E),
        L > 0)
      ) {
        A = E % T;
        const R = T - A;
        A !== 0 && R - I.boundary < 0 && ((E += T - A), (C.__offset = E));
      }
      E += I.storage;
    }
    return (
      (A = E % T), A > 0 && (E += T - A), (w.__size = E), (w.__cache = {}), this
    );
  }
  function _(w) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof w == "number"
        ? ((S.boundary = 4), (S.storage = 4))
        : w.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : w.isVector3 || w.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : w.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : w.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : w.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : w.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            w
          ),
      S
    );
  }
  function x(w) {
    const S = w.target;
    S.removeEventListener("dispose", x);
    const E = o.indexOf(S.__bindingPointIndex);
    o.splice(E, 1), t.deleteBuffer(i[S.id]), delete i[S.id], delete s[S.id];
  }
  function m() {
    for (const w in i) t.deleteBuffer(i[w]);
    (o = []), (i = {}), (s = {});
  }
  return { bind: l, update: f, dispose: m };
}
class uM {
  constructor(e = {}) {
    const {
      canvas: n = GI(),
      context: r = null,
      depth: i = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    r !== null ? (p = r.getContextAttributes().alpha) : (p = o);
    const g = new Uint32Array(4),
      v = new Int32Array(4);
    let _ = null,
      x = null;
    const m = [],
      w = [];
    (this.domElement = n),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Wn),
      (this._useLegacyLights = !1),
      (this.toneMapping = Ds),
      (this.toneMappingExposure = 1);
    const S = this;
    let E = !1,
      T = 0,
      A = 0,
      L = null,
      N = -1,
      C = null;
    const I = new Gt(),
      k = new Gt();
    let R = null;
    const $ = new qe(0);
    let D = 0,
      W = n.width,
      Y = n.height,
      Z = 1,
      B = null,
      G = null;
    const X = new Gt(0, 0, W, Y),
      te = new Gt(0, 0, W, Y);
    let oe = !1;
    const J = new lh();
    let ae = !1,
      Se = !1,
      Ie = null;
    const Ce = new ht(),
      et = new _e(),
      We = new z(),
      Me = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Le() {
      return L === null ? Z : 1;
    }
    let H = r;
    function pe(F, re) {
      for (let fe = 0; fe < F.length; fe++) {
        const he = F[fe],
          ce = n.getContext(he, re);
        if (ce !== null) return ce;
      }
      return null;
    }
    try {
      const F = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: f,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in n &&
          n.setAttribute("data-engine", `three.js r${N0}`),
        n.addEventListener("webglcontextlost", Be, !1),
        n.addEventListener("webglcontextrestored", K, !1),
        n.addEventListener("webglcontextcreationerror", ze, !1),
        H === null)
      ) {
        const re = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (S.isWebGL1Renderer === !0 && re.shift(), (H = pe(re, F)), H === null)
        )
          throw pe(re)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        H instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        H.getShaderPrecisionFormat === void 0 &&
          (H.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (F) {
      throw (console.error("THREE.WebGLRenderer: " + F.message), F);
    }
    let ie,
      we,
      xe,
      $e,
      Fe,
      He,
      Ze,
      it,
      Tt,
      V,
      O,
      se,
      Re,
      Ee,
      Ae,
      Ye,
      Pe,
      Te,
      at,
      wt,
      Ne,
      Pt,
      q,
      me;
    function be() {
      (ie = new ZH(H)),
        (we = new jH(H, ie, e)),
        ie.init(we),
        (Pt = new r3(H, ie, we)),
        (xe = new LW(H, ie, we)),
        ($e = new eV(H)),
        (Fe = new xW()),
        (He = new IW(H, ie, xe, Fe, we, Pt, $e)),
        (Ze = new XH(S)),
        (it = new KH(S)),
        (Tt = new l4(H, we)),
        (q = new WH(H, ie, Tt, we)),
        (V = new JH(H, Tt, $e, q)),
        (O = new iV(H, V, Tt, $e)),
        (at = new rV(H, we, He)),
        (Ye = new $H(Fe)),
        (se = new yW(S, Ze, it, ie, we, q, Ye)),
        (Re = new DW(S, Fe)),
        (Ee = new SW()),
        (Ae = new AW(ie, we)),
        (Te = new VH(S, Ze, it, xe, O, p, l)),
        (Pe = new PW(S, O, we)),
        (me = new kW(H, $e, we, xe)),
        (wt = new GH(H, ie, $e, we)),
        (Ne = new QH(H, ie, $e, we)),
        ($e.programs = se.programs),
        (S.capabilities = we),
        (S.extensions = ie),
        (S.properties = Fe),
        (S.renderLists = Ee),
        (S.shadowMap = Pe),
        (S.state = xe),
        (S.info = $e);
    }
    be();
    const ue = new OW(S, H);
    (this.xr = ue),
      (this.getContext = function () {
        return H;
      }),
      (this.getContextAttributes = function () {
        return H.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const F = ie.get("WEBGL_lose_context");
        F && F.loseContext();
      }),
      (this.forceContextRestore = function () {
        const F = ie.get("WEBGL_lose_context");
        F && F.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Z;
      }),
      (this.setPixelRatio = function (F) {
        F !== void 0 && ((Z = F), this.setSize(W, Y, !1));
      }),
      (this.getSize = function (F) {
        return F.set(W, Y);
      }),
      (this.setSize = function (F, re, fe = !0) {
        if (ue.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (W = F),
          (Y = re),
          (n.width = Math.floor(F * Z)),
          (n.height = Math.floor(re * Z)),
          fe === !0 &&
            ((n.style.width = F + "px"), (n.style.height = re + "px")),
          this.setViewport(0, 0, F, re);
      }),
      (this.getDrawingBufferSize = function (F) {
        return F.set(W * Z, Y * Z).floor();
      }),
      (this.setDrawingBufferSize = function (F, re, fe) {
        (W = F),
          (Y = re),
          (Z = fe),
          (n.width = Math.floor(F * fe)),
          (n.height = Math.floor(re * fe)),
          this.setViewport(0, 0, F, re);
      }),
      (this.getCurrentViewport = function (F) {
        return F.copy(I);
      }),
      (this.getViewport = function (F) {
        return F.copy(X);
      }),
      (this.setViewport = function (F, re, fe, he) {
        F.isVector4 ? X.set(F.x, F.y, F.z, F.w) : X.set(F, re, fe, he),
          xe.viewport(I.copy(X).multiplyScalar(Z).floor());
      }),
      (this.getScissor = function (F) {
        return F.copy(te);
      }),
      (this.setScissor = function (F, re, fe, he) {
        F.isVector4 ? te.set(F.x, F.y, F.z, F.w) : te.set(F, re, fe, he),
          xe.scissor(k.copy(te).multiplyScalar(Z).floor());
      }),
      (this.getScissorTest = function () {
        return oe;
      }),
      (this.setScissorTest = function (F) {
        xe.setScissorTest((oe = F));
      }),
      (this.setOpaqueSort = function (F) {
        B = F;
      }),
      (this.setTransparentSort = function (F) {
        G = F;
      }),
      (this.getClearColor = function (F) {
        return F.copy(Te.getClearColor());
      }),
      (this.setClearColor = function () {
        Te.setClearColor.apply(Te, arguments);
      }),
      (this.getClearAlpha = function () {
        return Te.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Te.setClearAlpha.apply(Te, arguments);
      }),
      (this.clear = function (F = !0, re = !0, fe = !0) {
        let he = 0;
        if (F) {
          let ce = !1;
          if (L !== null) {
            const Xe = L.texture.format;
            ce = Xe === qw || Xe === Yw || Xe === Xw;
          }
          if (ce) {
            const Xe = L.texture.type,
              st =
                Xe === ks ||
                Xe === fo ||
                Xe === k0 ||
                Xe === ua ||
                Xe === jw ||
                Xe === $w,
              ct = Te.getClearColor(),
              ft = Te.getClearAlpha(),
              mt = ct.r,
              pt = ct.g,
              gt = ct.b;
            st
              ? ((g[0] = mt),
                (g[1] = pt),
                (g[2] = gt),
                (g[3] = ft),
                H.clearBufferuiv(H.COLOR, 0, g))
              : ((v[0] = mt),
                (v[1] = pt),
                (v[2] = gt),
                (v[3] = ft),
                H.clearBufferiv(H.COLOR, 0, v));
          } else he |= H.COLOR_BUFFER_BIT;
        }
        re && (he |= H.DEPTH_BUFFER_BIT),
          fe &&
            ((he |= H.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          H.clear(he);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", Be, !1),
          n.removeEventListener("webglcontextrestored", K, !1),
          n.removeEventListener("webglcontextcreationerror", ze, !1),
          Ee.dispose(),
          Ae.dispose(),
          Fe.dispose(),
          Ze.dispose(),
          it.dispose(),
          O.dispose(),
          q.dispose(),
          me.dispose(),
          se.dispose(),
          ue.dispose(),
          ue.removeEventListener("sessionstart", sn),
          ue.removeEventListener("sessionend", It),
          Ie && (Ie.dispose(), (Ie = null)),
          sr.stop();
      });
    function Be(F) {
      F.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (E = !0);
    }
    function K() {
      console.log("THREE.WebGLRenderer: Context Restored."), (E = !1);
      const F = $e.autoReset,
        re = Pe.enabled,
        fe = Pe.autoUpdate,
        he = Pe.needsUpdate,
        ce = Pe.type;
      be(),
        ($e.autoReset = F),
        (Pe.enabled = re),
        (Pe.autoUpdate = fe),
        (Pe.needsUpdate = he),
        (Pe.type = ce);
    }
    function ze(F) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        F.statusMessage
      );
    }
    function ke(F) {
      const re = F.target;
      re.removeEventListener("dispose", ke), ye(re);
    }
    function ye(F) {
      Oe(F), Fe.remove(F);
    }
    function Oe(F) {
      const re = Fe.get(F).programs;
      re !== void 0 &&
        (re.forEach(function (fe) {
          se.releaseProgram(fe);
        }),
        F.isShaderMaterial && se.releaseShaderCache(F));
    }
    this.renderBufferDirect = function (F, re, fe, he, ce, Xe) {
      re === null && (re = Me);
      const st = ce.isMesh && ce.matrixWorld.determinant() < 0,
        ct = kv(F, re, fe, he, ce);
      xe.setMaterial(he, st);
      let ft = fe.index,
        mt = 1;
      if (he.wireframe === !0) {
        if (((ft = V.getWireframeAttribute(fe)), ft === void 0)) return;
        mt = 2;
      }
      const pt = fe.drawRange,
        gt = fe.attributes.position;
      let cn = pt.start * mt,
        or = (pt.start + pt.count) * mt;
      Xe !== null &&
        ((cn = Math.max(cn, Xe.start * mt)),
        (or = Math.min(or, (Xe.start + Xe.count) * mt))),
        ft !== null
          ? ((cn = Math.max(cn, 0)), (or = Math.min(or, ft.count)))
          : gt != null &&
            ((cn = Math.max(cn, 0)), (or = Math.min(or, gt.count)));
      const tn = or - cn;
      if (tn < 0 || tn === 1 / 0) return;
      q.setup(ce, he, ct, fe, ft);
      let qn,
        dt = wt;
      if (
        (ft !== null && ((qn = Tt.get(ft)), (dt = Ne), dt.setIndex(qn)),
        ce.isMesh)
      )
        he.wireframe === !0
          ? (xe.setLineWidth(he.wireframeLinewidth * Le()), dt.setMode(H.LINES))
          : dt.setMode(H.TRIANGLES);
      else if (ce.isLine) {
        let Je = he.linewidth;
        Je === void 0 && (Je = 1),
          xe.setLineWidth(Je * Le()),
          ce.isLineSegments
            ? dt.setMode(H.LINES)
            : ce.isLineLoop
            ? dt.setMode(H.LINE_LOOP)
            : dt.setMode(H.LINE_STRIP);
      } else
        ce.isPoints
          ? dt.setMode(H.POINTS)
          : ce.isSprite && dt.setMode(H.TRIANGLES);
      if (ce.isBatchedMesh)
        dt.renderMultiDraw(
          ce._multiDrawStarts,
          ce._multiDrawCounts,
          ce._multiDrawCount
        );
      else if (ce.isInstancedMesh) dt.renderInstances(cn, tn, ce.count);
      else if (fe.isInstancedBufferGeometry) {
        const Je =
            fe._maxInstanceCount !== void 0 ? fe._maxInstanceCount : 1 / 0,
          bi = Math.min(fe.instanceCount, Je);
        dt.renderInstances(cn, tn, bi);
      } else dt.render(cn, tn);
    };
    function nt(F, re, fe) {
      F.transparent === !0 && F.side === Ps && F.forceSinglePass === !1
        ? ((F.side = Hr),
          (F.needsUpdate = !0),
          Vl(F, re, fe),
          (F.side = _o),
          (F.needsUpdate = !0),
          Vl(F, re, fe),
          (F.side = Ps))
        : Vl(F, re, fe);
    }
    (this.compile = function (F, re, fe = null) {
      fe === null && (fe = F),
        (x = Ae.get(fe)),
        x.init(),
        w.push(x),
        fe.traverseVisible(function (ce) {
          ce.isLight &&
            ce.layers.test(re.layers) &&
            (x.pushLight(ce), ce.castShadow && x.pushShadow(ce));
        }),
        F !== fe &&
          F.traverseVisible(function (ce) {
            ce.isLight &&
              ce.layers.test(re.layers) &&
              (x.pushLight(ce), ce.castShadow && x.pushShadow(ce));
          }),
        x.setupLights(S._useLegacyLights);
      const he = new Set();
      return (
        F.traverse(function (ce) {
          const Xe = ce.material;
          if (Xe)
            if (Array.isArray(Xe))
              for (let st = 0; st < Xe.length; st++) {
                const ct = Xe[st];
                nt(ct, fe, ce), he.add(ct);
              }
            else nt(Xe, fe, ce), he.add(Xe);
        }),
        w.pop(),
        (x = null),
        he
      );
    }),
      (this.compileAsync = function (F, re, fe = null) {
        const he = this.compile(F, re, fe);
        return new Promise((ce) => {
          function Xe() {
            if (
              (he.forEach(function (st) {
                Fe.get(st).currentProgram.isReady() && he.delete(st);
              }),
              he.size === 0)
            ) {
              ce(F);
              return;
            }
            setTimeout(Xe, 10);
          }
          ie.get("KHR_parallel_shader_compile") !== null
            ? Xe()
            : setTimeout(Xe, 10);
        });
      });
    let xt = null;
    function qt(F) {
      xt && xt(F);
    }
    function sn() {
      sr.stop();
    }
    function It() {
      sr.start();
    }
    const sr = new ZI();
    sr.setAnimationLoop(qt),
      typeof self < "u" && sr.setContext(self),
      (this.setAnimationLoop = function (F) {
        (xt = F), ue.setAnimationLoop(F), F === null ? sr.stop() : sr.start();
      }),
      ue.addEventListener("sessionstart", sn),
      ue.addEventListener("sessionend", It),
      (this.render = function (F, re) {
        if (re !== void 0 && re.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (E === !0) return;
        F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(),
          re.parent === null &&
            re.matrixWorldAutoUpdate === !0 &&
            re.updateMatrixWorld(),
          ue.enabled === !0 &&
            ue.isPresenting === !0 &&
            (ue.cameraAutoUpdate === !0 && ue.updateCamera(re),
            (re = ue.getCamera())),
          F.isScene === !0 && F.onBeforeRender(S, F, re, L),
          (x = Ae.get(F, w.length)),
          x.init(),
          w.push(x),
          Ce.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse),
          J.setFromProjectionMatrix(Ce),
          (Se = this.localClippingEnabled),
          (ae = Ye.init(this.clippingPlanes, Se)),
          (_ = Ee.get(F, m.length)),
          _.init(),
          m.push(_),
          Ei(F, re, 0, S.sortObjects),
          _.finish(),
          S.sortObjects === !0 && _.sort(B, G),
          this.info.render.frame++,
          ae === !0 && Ye.beginShadows();
        const fe = x.state.shadowsArray;
        if (
          (Pe.render(fe, F, re),
          ae === !0 && Ye.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Te.render(_, F),
          x.setupLights(S._useLegacyLights),
          re.isArrayCamera)
        ) {
          const he = re.cameras;
          for (let ce = 0, Xe = he.length; ce < Xe; ce++) {
            const st = he[ce];
            zc(_, F, st, st.viewport);
          }
        } else zc(_, F, re);
        L !== null &&
          (He.updateMultisampleRenderTarget(L), He.updateRenderTargetMipmap(L)),
          F.isScene === !0 && F.onAfterRender(S, F, re),
          q.resetDefaultState(),
          (N = -1),
          (C = null),
          w.pop(),
          w.length > 0 ? (x = w[w.length - 1]) : (x = null),
          m.pop(),
          m.length > 0 ? (_ = m[m.length - 1]) : (_ = null);
      });
    function Ei(F, re, fe, he) {
      if (F.visible === !1) return;
      if (F.layers.test(re.layers)) {
        if (F.isGroup) fe = F.renderOrder;
        else if (F.isLOD) F.autoUpdate === !0 && F.update(re);
        else if (F.isLight) x.pushLight(F), F.castShadow && x.pushShadow(F);
        else if (F.isSprite) {
          if (!F.frustumCulled || J.intersectsSprite(F)) {
            he && We.setFromMatrixPosition(F.matrixWorld).applyMatrix4(Ce);
            const st = O.update(F),
              ct = F.material;
            ct.visible && _.push(F, st, ct, fe, We.z, null);
          }
        } else if (
          (F.isMesh || F.isLine || F.isPoints) &&
          (!F.frustumCulled || J.intersectsObject(F))
        ) {
          const st = O.update(F),
            ct = F.material;
          if (
            (he &&
              (F.boundingSphere !== void 0
                ? (F.boundingSphere === null && F.computeBoundingSphere(),
                  We.copy(F.boundingSphere.center))
                : (st.boundingSphere === null && st.computeBoundingSphere(),
                  We.copy(st.boundingSphere.center)),
              We.applyMatrix4(F.matrixWorld).applyMatrix4(Ce)),
            Array.isArray(ct))
          ) {
            const ft = st.groups;
            for (let mt = 0, pt = ft.length; mt < pt; mt++) {
              const gt = ft[mt],
                cn = ct[gt.materialIndex];
              cn && cn.visible && _.push(F, st, cn, fe, We.z, gt);
            }
          } else ct.visible && _.push(F, st, ct, fe, We.z, null);
        }
      }
      const Xe = F.children;
      for (let st = 0, ct = Xe.length; st < ct; st++) Ei(Xe[st], re, fe, he);
    }
    function zc(F, re, fe, he) {
      const ce = F.opaque,
        Xe = F.transmissive,
        st = F.transparent;
      x.setupLightsView(fe),
        ae === !0 && Ye.setGlobalState(S.clippingPlanes, fe),
        Xe.length > 0 && Bc(ce, Xe, re, fe),
        he && xe.viewport(I.copy(he)),
        ce.length > 0 && Hl(ce, re, fe),
        Xe.length > 0 && Hl(Xe, re, fe),
        st.length > 0 && Hl(st, re, fe),
        xe.buffers.depth.setTest(!0),
        xe.buffers.depth.setMask(!0),
        xe.buffers.color.setMask(!0),
        xe.setPolygonOffset(!1);
    }
    function Bc(F, re, fe, he) {
      if ((fe.isScene === !0 ? fe.overrideMaterial : null) !== null) return;
      const Xe = we.isWebGL2;
      Ie === null &&
        (Ie = new cs(1, 1, {
          generateMipmaps: !0,
          type: ie.has("EXT_color_buffer_half_float") ? xc : ks,
          minFilter: xa,
          samples: Xe ? 4 : 0,
        })),
        S.getDrawingBufferSize(et),
        Xe ? Ie.setSize(et.x, et.y) : Ie.setSize(zg(et.x), zg(et.y));
      const st = S.getRenderTarget();
      S.setRenderTarget(Ie),
        S.getClearColor($),
        (D = S.getClearAlpha()),
        D < 1 && S.setClearColor(16777215, 0.5),
        S.clear();
      const ct = S.toneMapping;
      (S.toneMapping = Ds),
        Hl(F, fe, he),
        He.updateMultisampleRenderTarget(Ie),
        He.updateRenderTargetMipmap(Ie);
      let ft = !1;
      for (let mt = 0, pt = re.length; mt < pt; mt++) {
        const gt = re[mt],
          cn = gt.object,
          or = gt.geometry,
          tn = gt.material,
          qn = gt.group;
        if (tn.side === Ps && cn.layers.test(he.layers)) {
          const dt = tn.side;
          (tn.side = Hr),
            (tn.needsUpdate = !0),
            Co(cn, fe, he, or, tn, qn),
            (tn.side = dt),
            (tn.needsUpdate = !0),
            (ft = !0);
        }
      }
      ft === !0 &&
        (He.updateMultisampleRenderTarget(Ie), He.updateRenderTargetMipmap(Ie)),
        S.setRenderTarget(st),
        S.setClearColor($, D),
        (S.toneMapping = ct);
    }
    function Hl(F, re, fe) {
      const he = re.isScene === !0 ? re.overrideMaterial : null;
      for (let ce = 0, Xe = F.length; ce < Xe; ce++) {
        const st = F[ce],
          ct = st.object,
          ft = st.geometry,
          mt = he === null ? st.material : he,
          pt = st.group;
        ct.layers.test(fe.layers) && Co(ct, re, fe, ft, mt, pt);
      }
    }
    function Co(F, re, fe, he, ce, Xe) {
      F.onBeforeRender(S, re, fe, he, ce, Xe),
        F.modelViewMatrix.multiplyMatrices(
          fe.matrixWorldInverse,
          F.matrixWorld
        ),
        F.normalMatrix.getNormalMatrix(F.modelViewMatrix),
        ce.onBeforeRender(S, re, fe, he, F, Xe),
        ce.transparent === !0 && ce.side === Ps && ce.forceSinglePass === !1
          ? ((ce.side = Hr),
            (ce.needsUpdate = !0),
            S.renderBufferDirect(fe, re, he, ce, F, Xe),
            (ce.side = _o),
            (ce.needsUpdate = !0),
            S.renderBufferDirect(fe, re, he, ce, F, Xe),
            (ce.side = Ps))
          : S.renderBufferDirect(fe, re, he, ce, F, Xe),
        F.onAfterRender(S, re, fe, he, ce, Xe);
    }
    function Vl(F, re, fe) {
      re.isScene !== !0 && (re = Me);
      const he = Fe.get(F),
        ce = x.state.lights,
        Xe = x.state.shadowsArray,
        st = ce.state.version,
        ct = se.getParameters(F, ce.state, Xe, re, fe),
        ft = se.getProgramCacheKey(ct);
      let mt = he.programs;
      (he.environment = F.isMeshStandardMaterial ? re.environment : null),
        (he.fog = re.fog),
        (he.envMap = (F.isMeshStandardMaterial ? it : Ze).get(
          F.envMap || he.environment
        )),
        mt === void 0 &&
          (F.addEventListener("dispose", ke),
          (mt = new Map()),
          (he.programs = mt));
      let pt = mt.get(ft);
      if (pt !== void 0) {
        if (he.currentProgram === pt && he.lightsStateVersion === st)
          return wh(F, ct), pt;
      } else
        (ct.uniforms = se.getUniforms(F)),
          F.onBuild(fe, ct, S),
          F.onBeforeCompile(ct, S),
          (pt = se.acquireProgram(ct, ft)),
          mt.set(ft, pt),
          (he.uniforms = ct.uniforms);
      const gt = he.uniforms;
      return (
        ((!F.isShaderMaterial && !F.isRawShaderMaterial) ||
          F.clipping === !0) &&
          (gt.clippingPlanes = Ye.uniform),
        wh(F, ct),
        (he.needsLights = Fv(F)),
        (he.lightsStateVersion = st),
        he.needsLights &&
          ((gt.ambientLightColor.value = ce.state.ambient),
          (gt.lightProbe.value = ce.state.probe),
          (gt.directionalLights.value = ce.state.directional),
          (gt.directionalLightShadows.value = ce.state.directionalShadow),
          (gt.spotLights.value = ce.state.spot),
          (gt.spotLightShadows.value = ce.state.spotShadow),
          (gt.rectAreaLights.value = ce.state.rectArea),
          (gt.ltc_1.value = ce.state.rectAreaLTC1),
          (gt.ltc_2.value = ce.state.rectAreaLTC2),
          (gt.pointLights.value = ce.state.point),
          (gt.pointLightShadows.value = ce.state.pointShadow),
          (gt.hemisphereLights.value = ce.state.hemi),
          (gt.directionalShadowMap.value = ce.state.directionalShadowMap),
          (gt.directionalShadowMatrix.value = ce.state.directionalShadowMatrix),
          (gt.spotShadowMap.value = ce.state.spotShadowMap),
          (gt.spotLightMatrix.value = ce.state.spotLightMatrix),
          (gt.spotLightMap.value = ce.state.spotLightMap),
          (gt.pointShadowMap.value = ce.state.pointShadowMap),
          (gt.pointShadowMatrix.value = ce.state.pointShadowMatrix)),
        (he.currentProgram = pt),
        (he.uniformsList = null),
        pt
      );
    }
    function Sh(F) {
      if (F.uniformsList === null) {
        const re = F.currentProgram.getUniforms();
        F.uniformsList = Qm.seqWithValue(re.seq, F.uniforms);
      }
      return F.uniformsList;
    }
    function wh(F, re) {
      const fe = Fe.get(F);
      (fe.outputColorSpace = re.outputColorSpace),
        (fe.batching = re.batching),
        (fe.instancing = re.instancing),
        (fe.instancingColor = re.instancingColor),
        (fe.skinning = re.skinning),
        (fe.morphTargets = re.morphTargets),
        (fe.morphNormals = re.morphNormals),
        (fe.morphColors = re.morphColors),
        (fe.morphTargetsCount = re.morphTargetsCount),
        (fe.numClippingPlanes = re.numClippingPlanes),
        (fe.numIntersection = re.numClipIntersection),
        (fe.vertexAlphas = re.vertexAlphas),
        (fe.vertexTangents = re.vertexTangents),
        (fe.toneMapping = re.toneMapping);
    }
    function kv(F, re, fe, he, ce) {
      re.isScene !== !0 && (re = Me), He.resetTextureUnits();
      const Xe = re.fog,
        st = he.isMeshStandardMaterial ? re.environment : null,
        ct =
          L === null
            ? S.outputColorSpace
            : L.isXRRenderTarget === !0
            ? L.texture.colorSpace
            : zs,
        ft = (he.isMeshStandardMaterial ? it : Ze).get(he.envMap || st),
        mt =
          he.vertexColors === !0 &&
          !!fe.attributes.color &&
          fe.attributes.color.itemSize === 4,
        pt = !!fe.attributes.tangent && (!!he.normalMap || he.anisotropy > 0),
        gt = !!fe.morphAttributes.position,
        cn = !!fe.morphAttributes.normal,
        or = !!fe.morphAttributes.color;
      let tn = Ds;
      he.toneMapped &&
        (L === null || L.isXRRenderTarget === !0) &&
        (tn = S.toneMapping);
      const qn =
          fe.morphAttributes.position ||
          fe.morphAttributes.normal ||
          fe.morphAttributes.color,
        dt = qn !== void 0 ? qn.length : 0,
        Je = Fe.get(he),
        bi = x.state.lights;
      if (ae === !0 && (Se === !0 || F !== C)) {
        const ar = F === C && he.id === N;
        Ye.setState(he, F, ar);
      }
      let At = !1;
      he.version === Je.__version
        ? ((Je.needsLights && Je.lightsStateVersion !== bi.state.version) ||
            Je.outputColorSpace !== ct ||
            (ce.isBatchedMesh && Je.batching === !1) ||
            (!ce.isBatchedMesh && Je.batching === !0) ||
            (ce.isInstancedMesh && Je.instancing === !1) ||
            (!ce.isInstancedMesh && Je.instancing === !0) ||
            (ce.isSkinnedMesh && Je.skinning === !1) ||
            (!ce.isSkinnedMesh && Je.skinning === !0) ||
            (ce.isInstancedMesh &&
              Je.instancingColor === !0 &&
              ce.instanceColor === null) ||
            (ce.isInstancedMesh &&
              Je.instancingColor === !1 &&
              ce.instanceColor !== null) ||
            Je.envMap !== ft ||
            (he.fog === !0 && Je.fog !== Xe) ||
            (Je.numClippingPlanes !== void 0 &&
              (Je.numClippingPlanes !== Ye.numPlanes ||
                Je.numIntersection !== Ye.numIntersection)) ||
            Je.vertexAlphas !== mt ||
            Je.vertexTangents !== pt ||
            Je.morphTargets !== gt ||
            Je.morphNormals !== cn ||
            Je.morphColors !== or ||
            Je.toneMapping !== tn ||
            (we.isWebGL2 === !0 && Je.morphTargetsCount !== dt)) &&
          (At = !0)
        : ((At = !0), (Je.__version = he.version));
      let vn = Je.currentProgram;
      At === !0 && (vn = Vl(he, re, ce));
      let ps = !1,
        Ti = !1,
        Kn = !1;
      const En = vn.getUniforms(),
        ms = Je.uniforms;
      if (
        (xe.useProgram(vn.program) && ((ps = !0), (Ti = !0), (Kn = !0)),
        he.id !== N && ((N = he.id), (Ti = !0)),
        ps || C !== F)
      ) {
        En.setValue(H, "projectionMatrix", F.projectionMatrix),
          En.setValue(H, "viewMatrix", F.matrixWorldInverse);
        const ar = En.map.cameraPosition;
        ar !== void 0 &&
          ar.setValue(H, We.setFromMatrixPosition(F.matrixWorld)),
          we.logarithmicDepthBuffer &&
            En.setValue(
              H,
              "logDepthBufFC",
              2 / (Math.log(F.far + 1) / Math.LN2)
            ),
          (he.isMeshPhongMaterial ||
            he.isMeshToonMaterial ||
            he.isMeshLambertMaterial ||
            he.isMeshBasicMaterial ||
            he.isMeshStandardMaterial ||
            he.isShaderMaterial) &&
            En.setValue(H, "isOrthographic", F.isOrthographicCamera === !0),
          C !== F && ((C = F), (Ti = !0), (Kn = !0));
      }
      if (ce.isSkinnedMesh) {
        En.setOptional(H, ce, "bindMatrix"),
          En.setOptional(H, ce, "bindMatrixInverse");
        const ar = ce.skeleton;
        ar &&
          (we.floatVertexTextures
            ? (ar.boneTexture === null && ar.computeBoneTexture(),
              En.setValue(H, "boneTexture", ar.boneTexture, He))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      ce.isBatchedMesh &&
        (En.setOptional(H, ce, "batchingTexture"),
        En.setValue(H, "batchingTexture", ce._matricesTexture, He));
      const Wl = fe.morphAttributes;
      if (
        ((Wl.position !== void 0 ||
          Wl.normal !== void 0 ||
          (Wl.color !== void 0 && we.isWebGL2 === !0)) &&
          at.update(ce, fe, vn),
        (Ti || Je.receiveShadow !== ce.receiveShadow) &&
          ((Je.receiveShadow = ce.receiveShadow),
          En.setValue(H, "receiveShadow", ce.receiveShadow)),
        he.isMeshGouraudMaterial &&
          he.envMap !== null &&
          ((ms.envMap.value = ft),
          (ms.flipEnvMap.value =
            ft.isCubeTexture && ft.isRenderTargetTexture === !1 ? -1 : 1)),
        Ti &&
          (En.setValue(H, "toneMappingExposure", S.toneMappingExposure),
          Je.needsLights && Uv(ms, Kn),
          Xe && he.fog === !0 && Re.refreshFogUniforms(ms, Xe),
          Re.refreshMaterialUniforms(ms, he, Z, Y, Ie),
          Qm.upload(H, Sh(Je), ms, He)),
        he.isShaderMaterial &&
          he.uniformsNeedUpdate === !0 &&
          (Qm.upload(H, Sh(Je), ms, He), (he.uniformsNeedUpdate = !1)),
        he.isSpriteMaterial && En.setValue(H, "center", ce.center),
        En.setValue(H, "modelViewMatrix", ce.modelViewMatrix),
        En.setValue(H, "normalMatrix", ce.normalMatrix),
        En.setValue(H, "modelMatrix", ce.matrixWorld),
        he.isShaderMaterial || he.isRawShaderMaterial)
      ) {
        const ar = he.uniformsGroups;
        for (let Gl = 0, si = ar.length; Gl < si; Gl++)
          if (we.isWebGL2) {
            const Mh = ar[Gl];
            me.update(Mh, vn), me.bind(Mh, vn);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return vn;
    }
    function Uv(F, re) {
      (F.ambientLightColor.needsUpdate = re),
        (F.lightProbe.needsUpdate = re),
        (F.directionalLights.needsUpdate = re),
        (F.directionalLightShadows.needsUpdate = re),
        (F.pointLights.needsUpdate = re),
        (F.pointLightShadows.needsUpdate = re),
        (F.spotLights.needsUpdate = re),
        (F.spotLightShadows.needsUpdate = re),
        (F.rectAreaLights.needsUpdate = re),
        (F.hemisphereLights.needsUpdate = re);
    }
    function Fv(F) {
      return (
        F.isMeshLambertMaterial ||
        F.isMeshToonMaterial ||
        F.isMeshPhongMaterial ||
        F.isMeshStandardMaterial ||
        F.isShadowMaterial ||
        (F.isShaderMaterial && F.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return A;
      }),
      (this.getRenderTarget = function () {
        return L;
      }),
      (this.setRenderTargetTextures = function (F, re, fe) {
        (Fe.get(F.texture).__webglTexture = re),
          (Fe.get(F.depthTexture).__webglTexture = fe);
        const he = Fe.get(F);
        (he.__hasExternalTextures = !0),
          he.__hasExternalTextures &&
            ((he.__autoAllocateDepthBuffer = fe === void 0),
            he.__autoAllocateDepthBuffer ||
              (ie.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (he.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (F, re) {
        const fe = Fe.get(F);
        (fe.__webglFramebuffer = re),
          (fe.__useDefaultFramebuffer = re === void 0);
      }),
      (this.setRenderTarget = function (F, re = 0, fe = 0) {
        (L = F), (T = re), (A = fe);
        let he = !0,
          ce = null,
          Xe = !1,
          st = !1;
        if (F) {
          const ft = Fe.get(F);
          ft.__useDefaultFramebuffer !== void 0
            ? (xe.bindFramebuffer(H.FRAMEBUFFER, null), (he = !1))
            : ft.__webglFramebuffer === void 0
            ? He.setupRenderTarget(F)
            : ft.__hasExternalTextures &&
              He.rebindTextures(
                F,
                Fe.get(F.texture).__webglTexture,
                Fe.get(F.depthTexture).__webglTexture
              );
          const mt = F.texture;
          (mt.isData3DTexture ||
            mt.isDataArrayTexture ||
            mt.isCompressedArrayTexture) &&
            (st = !0);
          const pt = Fe.get(F).__webglFramebuffer;
          F.isWebGLCubeRenderTarget
            ? (Array.isArray(pt[re]) ? (ce = pt[re][fe]) : (ce = pt[re]),
              (Xe = !0))
            : we.isWebGL2 && F.samples > 0 && He.useMultisampledRTT(F) === !1
            ? (ce = Fe.get(F).__webglMultisampledFramebuffer)
            : Array.isArray(pt)
            ? (ce = pt[fe])
            : (ce = pt),
            I.copy(F.viewport),
            k.copy(F.scissor),
            (R = F.scissorTest);
        } else
          I.copy(X).multiplyScalar(Z).floor(),
            k.copy(te).multiplyScalar(Z).floor(),
            (R = oe);
        if (
          (xe.bindFramebuffer(H.FRAMEBUFFER, ce) &&
            we.drawBuffers &&
            he &&
            xe.drawBuffers(F, ce),
          xe.viewport(I),
          xe.scissor(k),
          xe.setScissorTest(R),
          Xe)
        ) {
          const ft = Fe.get(F.texture);
          H.framebufferTexture2D(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            H.TEXTURE_CUBE_MAP_POSITIVE_X + re,
            ft.__webglTexture,
            fe
          );
        } else if (st) {
          const ft = Fe.get(F.texture),
            mt = re || 0;
          H.framebufferTextureLayer(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            ft.__webglTexture,
            fe || 0,
            mt
          );
        }
        N = -1;
      }),
      (this.readRenderTargetPixels = function (F, re, fe, he, ce, Xe, st) {
        if (!(F && F.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let ct = Fe.get(F).__webglFramebuffer;
        if ((F.isWebGLCubeRenderTarget && st !== void 0 && (ct = ct[st]), ct)) {
          xe.bindFramebuffer(H.FRAMEBUFFER, ct);
          try {
            const ft = F.texture,
              mt = ft.format,
              pt = ft.type;
            if (
              mt !== zr &&
              Pt.convert(mt) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const gt =
              pt === xc &&
              (ie.has("EXT_color_buffer_half_float") ||
                (we.isWebGL2 && ie.has("EXT_color_buffer_float")));
            if (
              pt !== ks &&
              Pt.convert(pt) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                pt === ss &&
                (we.isWebGL2 ||
                  ie.has("OES_texture_float") ||
                  ie.has("WEBGL_color_buffer_float"))
              ) &&
              !gt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            re >= 0 &&
              re <= F.width - he &&
              fe >= 0 &&
              fe <= F.height - ce &&
              H.readPixels(re, fe, he, ce, Pt.convert(mt), Pt.convert(pt), Xe);
          } finally {
            const ft = L !== null ? Fe.get(L).__webglFramebuffer : null;
            xe.bindFramebuffer(H.FRAMEBUFFER, ft);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (F, re, fe = 0) {
        const he = Math.pow(2, -fe),
          ce = Math.floor(re.image.width * he),
          Xe = Math.floor(re.image.height * he);
        He.setTexture2D(re, 0),
          H.copyTexSubImage2D(H.TEXTURE_2D, fe, 0, 0, F.x, F.y, ce, Xe),
          xe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (F, re, fe, he = 0) {
        const ce = re.image.width,
          Xe = re.image.height,
          st = Pt.convert(fe.format),
          ct = Pt.convert(fe.type);
        He.setTexture2D(fe, 0),
          H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, fe.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, fe.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, fe.unpackAlignment),
          re.isDataTexture
            ? H.texSubImage2D(
                H.TEXTURE_2D,
                he,
                F.x,
                F.y,
                ce,
                Xe,
                st,
                ct,
                re.image.data
              )
            : re.isCompressedTexture
            ? H.compressedTexSubImage2D(
                H.TEXTURE_2D,
                he,
                F.x,
                F.y,
                re.mipmaps[0].width,
                re.mipmaps[0].height,
                st,
                re.mipmaps[0].data
              )
            : H.texSubImage2D(H.TEXTURE_2D, he, F.x, F.y, st, ct, re.image),
          he === 0 && fe.generateMipmaps && H.generateMipmap(H.TEXTURE_2D),
          xe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (F, re, fe, he, ce = 0) {
        if (S.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Xe = F.max.x - F.min.x + 1,
          st = F.max.y - F.min.y + 1,
          ct = F.max.z - F.min.z + 1,
          ft = Pt.convert(he.format),
          mt = Pt.convert(he.type);
        let pt;
        if (he.isData3DTexture) He.setTexture3D(he, 0), (pt = H.TEXTURE_3D);
        else if (he.isDataArrayTexture)
          He.setTexture2DArray(he, 0), (pt = H.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, he.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, he.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, he.unpackAlignment);
        const gt = H.getParameter(H.UNPACK_ROW_LENGTH),
          cn = H.getParameter(H.UNPACK_IMAGE_HEIGHT),
          or = H.getParameter(H.UNPACK_SKIP_PIXELS),
          tn = H.getParameter(H.UNPACK_SKIP_ROWS),
          qn = H.getParameter(H.UNPACK_SKIP_IMAGES),
          dt = fe.isCompressedTexture ? fe.mipmaps[0] : fe.image;
        H.pixelStorei(H.UNPACK_ROW_LENGTH, dt.width),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, dt.height),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, F.min.x),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, F.min.y),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, F.min.z),
          fe.isDataTexture || fe.isData3DTexture
            ? H.texSubImage3D(
                pt,
                ce,
                re.x,
                re.y,
                re.z,
                Xe,
                st,
                ct,
                ft,
                mt,
                dt.data
              )
            : fe.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              H.compressedTexSubImage3D(
                pt,
                ce,
                re.x,
                re.y,
                re.z,
                Xe,
                st,
                ct,
                ft,
                dt.data
              ))
            : H.texSubImage3D(pt, ce, re.x, re.y, re.z, Xe, st, ct, ft, mt, dt),
          H.pixelStorei(H.UNPACK_ROW_LENGTH, gt),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, cn),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, or),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, tn),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, qn),
          ce === 0 && he.generateMipmaps && H.generateMipmap(pt),
          xe.unbindTexture();
      }),
      (this.initTexture = function (F) {
        F.isCubeTexture
          ? He.setTextureCube(F, 0)
          : F.isData3DTexture
          ? He.setTexture3D(F, 0)
          : F.isDataArrayTexture || F.isCompressedArrayTexture
          ? He.setTexture2DArray(F, 0)
          : He.setTexture2D(F, 0),
          xe.unbindTexture();
      }),
      (this.resetState = function () {
        (T = 0), (A = 0), (L = null), xe.reset(), q.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return os;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    (n.drawingBufferColorSpace = e === F0 ? "display-p3" : "srgb"),
      (n.unpackColorSpace =
        Wt.workingColorSpace === ih ? "display-p3" : "srgb");
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Wn ? fa : Jw
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === fa ? Wn : zs);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class s3 extends uM {}
s3.prototype.isWebGL1Renderer = !0;
class H0 {
  constructor(e, n = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new qe(e)),
      (this.density = n);
  }
  clone() {
    return new H0(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class V0 {
  constructor(e, n = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new qe(e)),
      (this.near = n),
      (this.far = r);
  }
  clone() {
    return new V0(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class cM extends Ft {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.fog !== null && (n.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (n.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (n.object.backgroundIntensity = this.backgroundIntensity),
      n
    );
  }
}
class W0 {
  constructor(e, n) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.usage = Fd),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = vi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        'THREE.InterleavedBuffer: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.stride), (r *= n.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(n, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const kr = new z();
class Pl {
  constructor(e, n, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = n),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.data.count; n < r; n++)
      kr.fromBufferAttribute(this, n),
        kr.applyMatrix4(e),
        this.setXYZ(n, kr.x, kr.y, kr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      kr.fromBufferAttribute(this, n),
        kr.applyNormalMatrix(e),
        this.setXYZ(n, kr.x, kr.y, kr.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      kr.fromBufferAttribute(this, n),
        kr.transformDirection(e),
        this.setXYZ(n, kr.x, kr.y, kr.z);
    return this;
  }
  setX(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = n),
      this
    );
  }
  setY(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = n),
      this
    );
  }
  setZ(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = n),
      this
    );
  }
  setW(e, n) {
    return (
      this.normalized && (n = St(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = n),
      this
    );
  }
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = Jr(n, this.array)), n;
  }
  setXY(e, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((n = St(n, this.array)), (r = St(r, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = St(n, this.array)),
        (r = St(r, this.array)),
        (i = St(i, this.array)),
        (s = St(s, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s]);
      }
      return new $t(
        new this.array.constructor(n),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Pl(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class fM extends Nr {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let xu;
const xf = new z(),
  _u = new z(),
  Su = new z(),
  wu = new _e(),
  _f = new _e(),
  o3 = new ht(),
  rm = new z(),
  Sf = new z(),
  im = new z(),
  KA = new _e(),
  $x = new _e(),
  ZA = new _e();
class a3 extends Ft {
  constructor(e = new fM()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), xu === void 0)
    ) {
      xu = new bt();
      const n = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new W0(n, 5);
      xu.setIndex([0, 1, 2, 0, 2, 3]),
        xu.setAttribute("position", new Pl(r, 3, 0, !1)),
        xu.setAttribute("uv", new Pl(r, 2, 3, !1));
    }
    (this.geometry = xu), (this.material = e), (this.center = new _e(0.5, 0.5));
  }
  raycast(e, n) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _u.setFromMatrixScale(this.matrixWorld),
      o3.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Su.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _u.multiplyScalar(-Su.z);
    const r = this.material.rotation;
    let i, s;
    r !== 0 && ((s = Math.cos(r)), (i = Math.sin(r)));
    const o = this.center;
    sm(rm.set(-0.5, -0.5, 0), Su, o, _u, i, s),
      sm(Sf.set(0.5, -0.5, 0), Su, o, _u, i, s),
      sm(im.set(0.5, 0.5, 0), Su, o, _u, i, s),
      KA.set(0, 0),
      $x.set(1, 0),
      ZA.set(1, 1);
    let a = e.ray.intersectTriangle(rm, Sf, im, !1, xf);
    if (
      a === null &&
      (sm(Sf.set(-0.5, 0.5, 0), Su, o, _u, i, s),
      $x.set(0, 1),
      (a = e.ray.intersectTriangle(rm, im, Sf, !1, xf)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(xf);
    l < e.near ||
      l > e.far ||
      n.push({
        distance: l,
        point: xf.clone(),
        uv: Zr.getInterpolation(xf, rm, Sf, im, KA, $x, ZA, new _e()),
        face: null,
        object: this,
      });
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function sm(t, e, n, r, i, s) {
  wu.subVectors(t, n).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((_f.x = s * wu.x - i * wu.y), (_f.y = i * wu.x + s * wu.y))
      : _f.copy(wu),
    t.copy(e),
    (t.x += _f.x),
    (t.y += _f.y),
    t.applyMatrix4(o3);
}
const om = new z(),
  JA = new z();
class l3 extends Ft {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const n = e.levels;
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, n = 0, r = 0) {
    n = Math.abs(n);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(n < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: n, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const n = this.levels;
    if (n.length > 0) {
      let r, i;
      for (r = 1, i = n.length; r < i; r++) {
        let s = n[r].distance;
        if ((n[r].object.visible && (s -= s * n[r].hysteresis), e < s)) break;
      }
      return n[r - 1].object;
    }
    return null;
  }
  raycast(e, n) {
    if (this.levels.length > 0) {
      om.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(om);
      this.getObjectForDistance(i).raycast(e, n);
    }
  }
  update(e) {
    const n = this.levels;
    if (n.length > 1) {
      om.setFromMatrixPosition(e.matrixWorld),
        JA.setFromMatrixPosition(this.matrixWorld);
      const r = om.distanceTo(JA) / e.zoom;
      n[0].object.visible = !0;
      let i, s;
      for (i = 1, s = n.length; i < s; i++) {
        let o = n[i].distance;
        if ((n[i].object.visible && (o -= o * n[i].hysteresis), r >= o))
          (n[i - 1].object.visible = !1), (n[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) n[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const n = super.toJSON(e);
    this.autoUpdate === !1 && (n.object.autoUpdate = !1),
      (n.object.levels = []);
    const r = this.levels;
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i];
      n.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return n;
  }
}
const QA = new z(),
  eC = new Gt(),
  tC = new Gt(),
  UW = new z(),
  nC = new ht(),
  am = new z(),
  Xx = new Pr(),
  rC = new ht(),
  Yx = new kl();
class u3 extends jn {
  constructor(e, n) {
    super(e, n),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = PS),
      (this.bindMatrix = new ht()),
      (this.bindMatrixInverse = new ht()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Vr()),
      this.boundingBox.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, am), this.boundingBox.expandByPoint(am);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Pr()),
      this.boundingSphere.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, am), this.boundingSphere.expandByPoint(am);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, n) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Xx.copy(this.boundingSphere),
      Xx.applyMatrix4(i),
      e.ray.intersectsSphere(Xx) !== !1 &&
        (rC.copy(i).invert(),
        Yx.copy(e.ray).applyMatrix4(rC),
        !(
          this.boundingBox !== null && Yx.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, n, Yx)));
  }
  getVertexPosition(e, n) {
    return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n;
  }
  bind(e, n) {
    (this.skeleton = e),
      n === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (n = this.matrixWorld)),
      this.bindMatrix.copy(n),
      this.bindMatrixInverse.copy(n).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Gt(),
      n = this.geometry.attributes.skinWeight;
    for (let r = 0, i = n.count; r < i; r++) {
      e.fromBufferAttribute(n, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        n.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === PS
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === SI
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, n) {
    const r = this.skeleton,
      i = this.geometry;
    eC.fromBufferAttribute(i.attributes.skinIndex, e),
      tC.fromBufferAttribute(i.attributes.skinWeight, e),
      QA.copy(n).applyMatrix4(this.bindMatrix),
      n.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = tC.getComponent(s);
      if (o !== 0) {
        const a = eC.getComponent(s);
        nC.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          n.addScaledVector(UW.copy(QA).applyMatrix4(nC), o);
      }
    }
    return n.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, n) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, n)
    );
  }
}
class dM extends Ft {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Sl extends Ln {
  constructor(e = null, n = 1, r = 1, i, s, o, a, l, f = An, d = An, h, p) {
    super(null, o, a, l, f, d, i, s, h, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: n, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const iC = new ht(),
  FW = new ht();
class G0 {
  constructor(e = [], n = []) {
    (this.uuid = vi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = n),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      n = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), n.length === 0))
      this.calculateInverses();
    else if (e.length !== n.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new ht());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = new ht();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      n = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : FW;
      iC.multiplyMatrices(a, n[s]), iC.toArray(r, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new G0(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4);
    n.set(this.boneMatrices);
    const r = new Sl(n, e, e, zr, ss);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = n),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let n = 0, r = this.bones.length; n < r; n++) {
      const i = this.bones[n];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, n) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const s = e.bones[r];
      let o = n[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new dM())),
        this.bones.push(o),
        this.boneInverses.push(new ht().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const n = this.bones,
      r = this.boneInverses;
    for (let i = 0, s = n.length; i < s; i++) {
      const o = n[i];
      e.bones.push(o.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Mc extends $t {
  constructor(e, n, r, i = 1) {
    super(e, n, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Mu = new ht(),
  sC = new ht(),
  lm = [],
  oC = new Vr(),
  zW = new ht(),
  wf = new jn(),
  Mf = new Pr();
class c3 extends jn {
  constructor(e, n, r) {
    super(e, n),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Mc(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, zW);
  }
  computeBoundingBox() {
    const e = this.geometry,
      n = this.count;
    this.boundingBox === null && (this.boundingBox = new Vr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, Mu),
        oC.copy(e.boundingBox).applyMatrix4(Mu),
        this.boundingBox.union(oC);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      n = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Pr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, Mu),
        Mf.copy(e.boundingSphere).applyMatrix4(Mu),
        this.boundingSphere.union(Mf);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, n) {
    n.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, n) {
    n.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, n) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((wf.geometry = this.geometry),
      (wf.material = this.material),
      wf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Mf.copy(this.boundingSphere),
        Mf.applyMatrix4(r),
        e.ray.intersectsSphere(Mf) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, Mu),
          sC.multiplyMatrices(r, Mu),
          (wf.matrixWorld = sC),
          wf.raycast(e, lm);
        for (let o = 0, a = lm.length; o < a; o++) {
          const l = lm[o];
          (l.instanceId = s), (l.object = this), n.push(l);
        }
        lm.length = 0;
      }
  }
  setColorAt(e, n) {
    this.instanceColor === null &&
      (this.instanceColor = new Mc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      n.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, n) {
    n.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function BW(t, e) {
  return t.z - e.z;
}
function HW(t, e) {
  return e.z - t.z;
}
class VW {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, n) {
    const r = this.pool,
      i = this.list;
    this.index >= r.length && r.push({ start: -1, count: -1, z: -1 });
    const s = r[this.index];
    i.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = n);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Eu = "batchId",
  Wo = new ht(),
  aC = new ht(),
  WW = new ht(),
  lC = new ht(),
  qx = new lh(),
  um = new Vr(),
  Va = new Pr(),
  Ef = new z(),
  Kx = new VW(),
  Mr = new jn(),
  cm = [];
function GW(t, e, n = 0) {
  const r = e.itemSize;
  if (
    t.isInterleavedBufferAttribute ||
    t.array.constructor !== e.array.constructor
  ) {
    const i = t.count;
    for (let s = 0; s < i; s++)
      for (let o = 0; o < r; o++)
        e.setComponent(s + n, o, t.getComponent(s, o));
  } else e.array.set(t.array, n * r);
  e.needsUpdate = !0;
}
class f3 extends jn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, n, r = n * 2, i) {
    super(new bt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = n),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4),
      r = new Sl(n, e, e, zr, ss);
    this._matricesTexture = r;
  }
  _initializeGeometry(e) {
    const n = this.geometry,
      r = this._maxVertexCount,
      i = this._maxGeometryCount,
      s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a),
          { array: f, itemSize: d, normalized: h } = l,
          p = new f.constructor(r * d),
          g = new l.constructor(p, d, h);
        g.setUsage(l.usage), n.setAttribute(a, g);
      }
      if (e.getIndex() !== null) {
        const a = r > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        n.setIndex(new $t(a, 1));
      }
      const o = i > 65536 ? new Uint32Array(r) : new Uint16Array(r);
      n.setAttribute(Eu, new $t(o, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(Eu))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${Eu}"`);
    const n = this.geometry;
    if (!!e.getIndex() != !!n.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in n.attributes) {
      if (r === Eu) continue;
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        s = n.getAttribute(r);
      if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Vr());
    const e = this._geometryCount,
      n = this.boundingBox,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, Wo),
        this.getBoundingBoxAt(i, um).applyMatrix4(Wo),
        n.union(um));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pr());
    const e = this._geometryCount,
      n = this.boundingSphere,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, Wo),
        this.getBoundingSphereAt(i, Va).applyMatrix4(Wo),
        n.union(Va));
  }
  addGeometry(e, n = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let s = null;
    const o = this._reservedRanges,
      a = this._drawRanges,
      l = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]),
      n === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = n),
      s === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = s.vertexStart + s.vertexCount);
    const f = e.getIndex(),
      d = f !== null;
    if (
      (d &&
        (r === -1 ? (i.indexCount = f.count) : (i.indexCount = r),
        s === null
          ? (i.indexStart = 0)
          : (i.indexStart = s.indexStart + s.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const h = this._visibility,
      p = this._active,
      g = this._matricesTexture,
      v = this._matricesTexture.image.data;
    h.push(!0), p.push(!0);
    const _ = this._geometryCount;
    this._geometryCount++,
      WW.toArray(v, _ * 16),
      (g.needsUpdate = !0),
      o.push(i),
      a.push({ start: d ? i.indexStart : i.vertexStart, count: -1 }),
      l.push({
        boxInitialized: !1,
        box: new Vr(),
        sphereInitialized: !1,
        sphere: new Pr(),
      });
    const x = this.geometry.getAttribute(Eu);
    for (let m = 0; m < i.vertexCount; m++) x.setX(i.vertexStart + m, _);
    return (x.needsUpdate = !0), this.setGeometryAt(_, e), _;
  }
  setGeometryAt(e, n) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(n);
    const r = this.geometry,
      i = r.getIndex() !== null,
      s = r.getIndex(),
      o = n.getIndex(),
      a = this._reservedRanges[e];
    if (
      (i && o.count > a.indexCount) ||
      n.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = a.vertexStart,
      f = a.vertexCount;
    for (const g in r.attributes) {
      if (g === Eu) continue;
      const v = n.getAttribute(g),
        _ = r.getAttribute(g);
      GW(v, _, l);
      const x = v.itemSize;
      for (let m = v.count, w = f; m < w; m++) {
        const S = l + m;
        for (let E = 0; E < x; E++) _.setComponent(S, E, 0);
      }
      _.needsUpdate = !0;
    }
    if (i) {
      const g = a.indexStart;
      for (let v = 0; v < o.count; v++) s.setX(g + v, l + o.getX(v));
      for (let v = o.count, _ = a.indexCount; v < _; v++) s.setX(g + v, l);
      s.needsUpdate = !0;
    }
    const d = this._bounds[e];
    n.boundingBox !== null
      ? (d.box.copy(n.boundingBox), (d.boxInitialized = !0))
      : (d.boxInitialized = !1),
      n.boundingSphere !== null
        ? (d.sphere.copy(n.boundingSphere), (d.sphereInitialized = !0))
        : (d.sphereInitialized = !1);
    const h = this._drawRanges[e],
      p = n.getAttribute("position");
    return (h.count = i ? o.count : p.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const n = this._active;
    return e >= n.length || n[e] === !1
      ? this
      : ((n[e] = !1), (this._visibilityChanged = !0), this);
  }
  getBoundingBoxAt(e, n) {
    if (this._active[e] === !1) return this;
    const i = this._bounds[e],
      s = i.box,
      o = this.geometry;
    if (i.boxInitialized === !1) {
      s.makeEmpty();
      const a = o.index,
        l = o.attributes.position,
        f = this._drawRanges[e];
      for (let d = f.start, h = f.start + f.count; d < h; d++) {
        let p = d;
        a && (p = a.getX(p)), s.expandByPoint(Ef.fromBufferAttribute(l, p));
      }
      i.boxInitialized = !0;
    }
    return n.copy(s), n;
  }
  getBoundingSphereAt(e, n) {
    if (this._active[e] === !1) return this;
    const i = this._bounds[e],
      s = i.sphere,
      o = this.geometry;
    if (i.sphereInitialized === !1) {
      s.makeEmpty(), this.getBoundingBoxAt(e, um), um.getCenter(s.center);
      const a = o.index,
        l = o.attributes.position,
        f = this._drawRanges[e];
      let d = 0;
      for (let h = f.start, p = f.start + f.count; h < p; h++) {
        let g = h;
        a && (g = a.getX(g)),
          Ef.fromBufferAttribute(l, g),
          (d = Math.max(d, s.center.distanceToSquared(Ef)));
      }
      (s.radius = Math.sqrt(d)), (i.sphereInitialized = !0);
    }
    return n.copy(s), n;
  }
  setMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture,
      s = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || r[e] === !1
      ? this
      : (n.toArray(s, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture.image.data,
      s = this._geometryCount;
    return e >= s || r[e] === !1 ? null : n.fromArray(i, e * 16);
  }
  setVisibleAt(e, n) {
    const r = this._visibility,
      i = this._active,
      s = this._geometryCount;
    return e >= s || i[e] === !1 || r[e] === n
      ? this
      : ((r[e] = n), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const n = this._visibility,
      r = this._active,
      i = this._geometryCount;
    return e >= i || r[e] === !1 ? !1 : n[e];
  }
  raycast(e, n) {
    const r = this._visibility,
      i = this._active,
      s = this._drawRanges,
      o = this._geometryCount,
      a = this.matrixWorld,
      l = this.geometry;
    (Mr.material = this.material),
      (Mr.geometry.index = l.index),
      (Mr.geometry.attributes = l.attributes),
      Mr.geometry.boundingBox === null && (Mr.geometry.boundingBox = new Vr()),
      Mr.geometry.boundingSphere === null &&
        (Mr.geometry.boundingSphere = new Pr());
    for (let f = 0; f < o; f++) {
      if (!r[f] || !i[f]) continue;
      const d = s[f];
      Mr.geometry.setDrawRange(d.start, d.count),
        this.getMatrixAt(f, Mr.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(f, Mr.geometry.boundingBox),
        this.getBoundingSphereAt(f, Mr.geometry.boundingSphere),
        Mr.raycast(e, cm);
      for (let h = 0, p = cm.length; h < p; h++) {
        const g = cm[h];
        (g.object = this), (g.batchId = f), n.push(g);
      }
      cm.length = 0;
    }
    (Mr.material = null),
      (Mr.geometry.index = null),
      (Mr.geometry.attributes = {}),
      Mr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((n) => ({ ...n }))),
      (this._reservedRanges = e._reservedRanges.map((n) => ({ ...n }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((n) => ({
        boxInitialized: n.boxInitialized,
        box: n.box.clone(),
        sphereInitialized: n.sphereInitialized,
        sphere: n.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, n, r, i, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = i.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      l = this._visibility,
      f = this._multiDrawStarts,
      d = this._multiDrawCounts,
      h = this._drawRanges,
      p = this.perObjectFrustumCulled;
    p &&
      (lC
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      qx.setFromProjectionMatrix(lC, e.isWebGPURenderer ? _c : os));
    let g = 0;
    if (this.sortObjects) {
      aC.copy(this.matrixWorld).invert(),
        Ef.setFromMatrixPosition(r.matrixWorld).applyMatrix4(aC);
      for (let x = 0, m = l.length; x < m; x++)
        if (l[x]) {
          this.getMatrixAt(x, Wo),
            this.getBoundingSphereAt(x, Va).applyMatrix4(Wo);
          let w = !1;
          if ((p && (w = !qx.intersectsSphere(Va)), !w)) {
            const S = Ef.distanceTo(Va.center);
            Kx.push(h[x], S);
          }
        }
      const v = Kx.list,
        _ = this.customSort;
      _ === null ? v.sort(s.transparent ? HW : BW) : _.call(this, v, r);
      for (let x = 0, m = v.length; x < m; x++) {
        const w = v[x];
        (f[g] = w.start * a), (d[g] = w.count), g++;
      }
      Kx.reset();
    } else
      for (let v = 0, _ = l.length; v < _; v++)
        if (l[v]) {
          let x = !1;
          if (
            (p &&
              (this.getMatrixAt(v, Wo),
              this.getBoundingSphereAt(v, Va).applyMatrix4(Wo),
              (x = !qx.intersectsSphere(Va))),
            !x)
          ) {
            const m = h[v];
            (f[g] = m.start * a), (d[g] = m.count), g++;
          }
        }
    (this._multiDrawCount = g), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, n, r, i, s, o) {
    this.onBeforeRender(e, null, i, s, o);
  }
}
class jr extends Nr {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const uC = new z(),
  cC = new z(),
  fC = new ht(),
  Zx = new kl(),
  fm = new Pr();
class _a extends Ft {
  constructor(e = new bt(), n = new jr()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [0];
      for (let i = 1, s = n.count; i < s; i++)
        uC.fromBufferAttribute(n, i - 1),
          cC.fromBufferAttribute(n, i),
          (r[i] = r[i - 1]),
          (r[i] += uC.distanceTo(cC));
      e.setAttribute("lineDistance", new tt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      fm.copy(r.boundingSphere),
      fm.applyMatrix4(i),
      (fm.radius += s),
      e.ray.intersectsSphere(fm) === !1)
    )
      return;
    fC.copy(i).invert(), Zx.copy(e.ray).applyMatrix4(fC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      f = new z(),
      d = new z(),
      h = new z(),
      p = new z(),
      g = this.isLineSegments ? 2 : 1,
      v = r.index,
      x = r.attributes.position;
    if (v !== null) {
      const m = Math.max(0, o.start),
        w = Math.min(v.count, o.start + o.count);
      for (let S = m, E = w - 1; S < E; S += g) {
        const T = v.getX(S),
          A = v.getX(S + 1);
        if (
          (f.fromBufferAttribute(x, T),
          d.fromBufferAttribute(x, A),
          Zx.distanceSqToSegment(f, d, p, h) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const N = e.ray.origin.distanceTo(p);
        N < e.near ||
          N > e.far ||
          n.push({
            distance: N,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const m = Math.max(0, o.start),
        w = Math.min(x.count, o.start + o.count);
      for (let S = m, E = w - 1; S < E; S += g) {
        if (
          (f.fromBufferAttribute(x, S),
          d.fromBufferAttribute(x, S + 1),
          Zx.distanceSqToSegment(f, d, p, h) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const A = e.ray.origin.distanceTo(p);
        A < e.near ||
          A > e.far ||
          n.push({
            distance: A,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const dC = new z(),
  hC = new z();
class Hs extends _a {
  constructor(e, n) {
    super(e, n), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [];
      for (let i = 0, s = n.count; i < s; i += 2)
        dC.fromBufferAttribute(n, i),
          hC.fromBufferAttribute(n, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + dC.distanceTo(hC));
      e.setAttribute("lineDistance", new tt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class d3 extends _a {
  constructor(e, n) {
    super(e, n), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class hM extends Nr {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const pC = new ht(),
  a1 = new kl(),
  dm = new Pr(),
  hm = new z();
class h3 extends Ft {
  constructor(e = new bt(), n = new hM()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      dm.copy(r.boundingSphere),
      dm.applyMatrix4(i),
      (dm.radius += s),
      e.ray.intersectsSphere(dm) === !1)
    )
      return;
    pC.copy(i).invert(), a1.copy(e.ray).applyMatrix4(pC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      f = r.index,
      h = r.attributes.position;
    if (f !== null) {
      const p = Math.max(0, o.start),
        g = Math.min(f.count, o.start + o.count);
      for (let v = p, _ = g; v < _; v++) {
        const x = f.getX(v);
        hm.fromBufferAttribute(h, x), mC(hm, x, l, i, e, n, this);
      }
    } else {
      const p = Math.max(0, o.start),
        g = Math.min(h.count, o.start + o.count);
      for (let v = p, _ = g; v < _; v++)
        hm.fromBufferAttribute(h, v), mC(hm, v, l, i, e, n, this);
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function mC(t, e, n, r, i, s, o) {
  const a = a1.distanceSqToPoint(t);
  if (a < n) {
    const l = new z();
    a1.closestPointToPoint(t, l), l.applyMatrix4(r);
    const f = i.ray.origin.distanceTo(l);
    if (f < i.near || f > i.far) return;
    s.push({
      distance: f,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class jW extends Ln {
  constructor(e, n, r, i, s, o, a, l, f) {
    super(e, n, r, i, s, o, a, l, f),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : Rn),
      (this.magFilter = s !== void 0 ? s : Rn),
      (this.generateMipmaps = !1);
    const d = this;
    function h() {
      (d.needsUpdate = !0), e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class $W extends Ln {
  constructor(e, n) {
    super({ width: e, height: n }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = An),
      (this.minFilter = An),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class j0 extends Ln {
  constructor(e, n, r, i, s, o, a, l, f, d, h, p) {
    super(null, o, a, l, f, d, i, s, h, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: n, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class XW extends j0 {
  constructor(e, n, r, i, s, o) {
    super(e, n, r, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Cr);
  }
}
class YW extends j0 {
  constructor(e, n, r) {
    super(void 0, e[0].width, e[0].height, n, r, So),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class qW extends Ln {
  constructor(e, n, r, i, s, o, a, l, f) {
    super(e, n, r, i, s, o, a, l, f),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class ds {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, n);
  }
  getPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return n;
  }
  getSpacedPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
    return n;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let r,
      i = this.getPoint(0),
      s = 0;
    n.push(0);
    for (let o = 1; o <= e; o++)
      (r = this.getPoint(o / e)), (s += r.distanceTo(i)), n.push(s), (i = r);
    return (this.cacheArcLengths = n), n;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, n) {
    const r = this.getLengths();
    let i = 0;
    const s = r.length;
    let o;
    n ? (o = n) : (o = e * r[s - 1]);
    let a = 0,
      l = s - 1,
      f;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (f = r[i] - o), f < 0)) a = i + 1;
      else if (f > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === o)) return i / (s - 1);
    const d = r[i],
      p = r[i + 1] - d,
      g = (o - d) / p;
    return (i + g) / (s - 1);
  }
  getTangent(e, n) {
    let i = e - 1e-4,
      s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const o = this.getPoint(i),
      a = this.getPoint(s),
      l = n || (o.isVector2 ? new _e() : new z());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, n);
  }
  computeFrenetFrames(e, n) {
    const r = new z(),
      i = [],
      s = [],
      o = [],
      a = new z(),
      l = new ht();
    for (let g = 0; g <= e; g++) {
      const v = g / e;
      i[g] = this.getTangentAt(v, new z());
    }
    (s[0] = new z()), (o[0] = new z());
    let f = Number.MAX_VALUE;
    const d = Math.abs(i[0].x),
      h = Math.abs(i[0].y),
      p = Math.abs(i[0].z);
    d <= f && ((f = d), r.set(1, 0, 0)),
      h <= f && ((f = h), r.set(0, 1, 0)),
      p <= f && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      s[0].crossVectors(i[0], a),
      o[0].crossVectors(i[0], s[0]);
    for (let g = 1; g <= e; g++) {
      if (
        ((s[g] = s[g - 1].clone()),
        (o[g] = o[g - 1].clone()),
        a.crossVectors(i[g - 1], i[g]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const v = Math.acos(Mn(i[g - 1].dot(i[g]), -1, 1));
        s[g].applyMatrix4(l.makeRotationAxis(a, v));
      }
      o[g].crossVectors(i[g], s[g]);
    }
    if (n === !0) {
      let g = Math.acos(Mn(s[0].dot(s[e]), -1, 1));
      (g /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (g = -g);
      for (let v = 1; v <= e; v++)
        s[v].applyMatrix4(l.makeRotationAxis(i[v], g * v)),
          o[v].crossVectors(i[v], s[v]);
    }
    return { tangents: i, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class $0 extends ds {
  constructor(
    e = 0,
    n = 0,
    r = 1,
    i = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = n),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, n) {
    const r = n || new _e(),
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (o ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !o && (s === i ? (s = -i) : (s = s - i));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      f = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation),
        h = Math.sin(this.aRotation),
        p = l - this.aX,
        g = f - this.aY;
      (l = p * d - g * h + this.aX), (f = p * h + g * d + this.aY);
    }
    return r.set(l, f);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class p3 extends $0 {
  constructor(e, n, r, i, s, o) {
    super(e, n, r, r, i, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function pM() {
  let t = 0,
    e = 0,
    n = 0,
    r = 0;
  function i(s, o, a, l) {
    (t = s),
      (e = a),
      (n = -3 * s + 3 * o - 2 * a - l),
      (r = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, f) {
      i(o, a, f * (a - s), f * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, f, d, h) {
      let p = (o - s) / f - (a - s) / (f + d) + (a - o) / d,
        g = (a - o) / d - (l - o) / (d + h) + (l - a) / h;
      (p *= d), (g *= d), i(o, a, p, g);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return t + e * s + n * o + r * a;
    },
  };
}
const pm = new z(),
  Jx = new pM(),
  Qx = new pM(),
  e_ = new pM();
class m3 extends ds {
  constructor(e = [], n = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = n),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, n = new z()) {
    const r = n,
      i = this.points,
      s = i.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let f, d;
    this.closed || a > 0
      ? (f = i[(a - 1) % s])
      : (pm.subVectors(i[0], i[1]).add(i[0]), (f = pm));
    const h = i[a % s],
      p = i[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (d = i[(a + 2) % s])
        : (pm.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (d = pm)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const g = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(f.distanceToSquared(h), g),
        _ = Math.pow(h.distanceToSquared(p), g),
        x = Math.pow(p.distanceToSquared(d), g);
      _ < 1e-4 && (_ = 1),
        v < 1e-4 && (v = _),
        x < 1e-4 && (x = _),
        Jx.initNonuniformCatmullRom(f.x, h.x, p.x, d.x, v, _, x),
        Qx.initNonuniformCatmullRom(f.y, h.y, p.y, d.y, v, _, x),
        e_.initNonuniformCatmullRom(f.z, h.z, p.z, d.z, v, _, x);
    } else
      this.curveType === "catmullrom" &&
        (Jx.initCatmullRom(f.x, h.x, p.x, d.x, this.tension),
        Qx.initCatmullRom(f.y, h.y, p.y, d.y, this.tension),
        e_.initCatmullRom(f.z, h.z, p.z, d.z, this.tension));
    return r.set(Jx.calc(l), Qx.calc(l), e_.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new z().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function gC(t, e, n, r, i) {
  const s = (r - e) * 0.5,
    o = (i - n) * 0.5,
    a = t * t,
    l = t * a;
  return (
    (2 * n - 2 * r + s + o) * l + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n
  );
}
function KW(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function ZW(t, e) {
  return 2 * (1 - t) * t * e;
}
function JW(t, e) {
  return t * t * e;
}
function nd(t, e, n, r) {
  return KW(t, e) + ZW(t, n) + JW(t, r);
}
function QW(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function e6(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function t6(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function n6(t, e) {
  return t * t * t * e;
}
function rd(t, e, n, r, i) {
  return QW(t, e) + e6(t, n) + t6(t, r) + n6(t, i);
}
class mM extends ds {
  constructor(e = new _e(), n = new _e(), r = new _e(), i = new _e()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new _e()) {
    const r = n,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return r.set(rd(e, i.x, s.x, o.x, a.x), rd(e, i.y, s.y, o.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class g3 extends ds {
  constructor(e = new z(), n = new z(), r = new z(), i = new z()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new z()) {
    const r = n,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      r.set(
        rd(e, i.x, s.x, o.x, a.x),
        rd(e, i.y, s.y, o.y, a.y),
        rd(e, i.z, s.z, o.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class gM extends ds {
  constructor(e = new _e(), n = new _e()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new _e()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new _e()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class v3 extends ds {
  constructor(e = new z(), n = new z()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new z()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new z()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class vM extends ds {
  constructor(e = new _e(), n = new _e(), r = new _e()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new _e()) {
    const r = n,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return r.set(nd(e, i.x, s.x, o.x), nd(e, i.y, s.y, o.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class yM extends ds {
  constructor(e = new z(), n = new z(), r = new z()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new z()) {
    const r = n,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      r.set(nd(e, i.x, s.x, o.x), nd(e, i.y, s.y, o.y), nd(e, i.z, s.z, o.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class xM extends ds {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, n = new _e()) {
    const r = n,
      i = this.points,
      s = (i.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = i[o === 0 ? o : o - 1],
      f = i[o],
      d = i[o > i.length - 2 ? i.length - 1 : o + 1],
      h = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return r.set(gC(a, l.x, f.x, d.x, h.x), gC(a, l.y, f.y, d.y, h.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new _e().fromArray(i));
    }
    return this;
  }
}
var Bg = Object.freeze({
  __proto__: null,
  ArcCurve: p3,
  CatmullRomCurve3: m3,
  CubicBezierCurve: mM,
  CubicBezierCurve3: g3,
  EllipseCurve: $0,
  LineCurve: gM,
  LineCurve3: v3,
  QuadraticBezierCurve: vM,
  QuadraticBezierCurve3: yM,
  SplineCurve: xM,
});
class y3 extends ds {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Bg[r](n, e));
    }
    return this;
  }
  getPoint(e, n) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= r) {
        const o = i[s] - r,
          a = this.curves[s],
          l = a.getLength(),
          f = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(f, n);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (n += this.curves[r].getLength()), e.push(n);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let r;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const o = s[i],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let f = 0; f < l.length; f++) {
        const d = l[f];
        (r && r.equals(d)) || (n.push(d), (r = d));
      }
    }
    return (
      this.autoClose &&
        n.length > 1 &&
        !n[n.length - 1].equals(n[0]) &&
        n.push(n[0]),
      n
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let n = 0, r = this.curves.length; n < r; n++) {
      const i = this.curves[n];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(new Bg[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Bd extends y3 {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new _e()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const r = new gM(this.currentPoint.clone(), new _e(e, n));
    return this.curves.push(r), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    const s = new vM(this.currentPoint.clone(), new _e(e, n), new _e(r, i));
    return this.curves.push(s), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, n, r, i, s, o) {
    const a = new mM(
      this.currentPoint.clone(),
      new _e(e, n),
      new _e(r, i),
      new _e(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e),
      r = new xM(n);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, r, i, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, n + l, r, i, s, o), this;
  }
  absarc(e, n, r, i, s, o) {
    return this.absellipse(e, n, r, r, i, s, o), this;
  }
  ellipse(e, n, r, i, s, o, a, l) {
    const f = this.currentPoint.x,
      d = this.currentPoint.y;
    return this.absellipse(e + f, n + d, r, i, s, o, a, l), this;
  }
  absellipse(e, n, r, i, s, o, a, l) {
    const f = new $0(e, n, r, i, s, o, a, l);
    if (this.curves.length > 0) {
      const h = f.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(f);
    const d = f.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class ch extends bt {
  constructor(
    e = [new _e(0, -0.5), new _e(0.5, 0), new _e(0, 0.5)],
    n = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: n, phiStart: r, phiLength: i }),
      (n = Math.floor(n)),
      (i = Mn(i, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      f = [],
      d = 1 / n,
      h = new z(),
      p = new _e(),
      g = new z(),
      v = new z(),
      _ = new z();
    let x = 0,
      m = 0;
    for (let w = 0; w <= e.length - 1; w++)
      switch (w) {
        case 0:
          (x = e[w + 1].x - e[w].x),
            (m = e[w + 1].y - e[w].y),
            (g.x = m * 1),
            (g.y = -x),
            (g.z = m * 0),
            _.copy(g),
            g.normalize(),
            l.push(g.x, g.y, g.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          (x = e[w + 1].x - e[w].x),
            (m = e[w + 1].y - e[w].y),
            (g.x = m * 1),
            (g.y = -x),
            (g.z = m * 0),
            v.copy(g),
            (g.x += _.x),
            (g.y += _.y),
            (g.z += _.z),
            g.normalize(),
            l.push(g.x, g.y, g.z),
            _.copy(v);
      }
    for (let w = 0; w <= n; w++) {
      const S = r + w * d * i,
        E = Math.sin(S),
        T = Math.cos(S);
      for (let A = 0; A <= e.length - 1; A++) {
        (h.x = e[A].x * E),
          (h.y = e[A].y),
          (h.z = e[A].x * T),
          o.push(h.x, h.y, h.z),
          (p.x = w / n),
          (p.y = A / (e.length - 1)),
          a.push(p.x, p.y);
        const L = l[3 * A + 0] * E,
          N = l[3 * A + 1],
          C = l[3 * A + 0] * T;
        f.push(L, N, C);
      }
    }
    for (let w = 0; w < n; w++)
      for (let S = 0; S < e.length - 1; S++) {
        const E = S + w * e.length,
          T = E,
          A = E + e.length,
          L = E + e.length + 1,
          N = E + 1;
        s.push(T, A, N), s.push(L, N, A);
      }
    this.setIndex(s),
      this.setAttribute("position", new tt(o, 3)),
      this.setAttribute("uv", new tt(a, 2)),
      this.setAttribute("normal", new tt(f, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ch(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class X0 extends ch {
  constructor(e = 1, n = 1, r = 4, i = 8) {
    const s = new Bd();
    s.absarc(0, -n / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, n / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: n,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new X0(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Y0 extends bt {
  constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: n,
        thetaStart: r,
        thetaLength: i,
      }),
      (n = Math.max(3, n));
    const s = [],
      o = [],
      a = [],
      l = [],
      f = new z(),
      d = new _e();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let h = 0, p = 3; h <= n; h++, p += 3) {
      const g = r + (h / n) * i;
      (f.x = e * Math.cos(g)),
        (f.y = e * Math.sin(g)),
        o.push(f.x, f.y, f.z),
        a.push(0, 0, 1),
        (d.x = (o[p] / e + 1) / 2),
        (d.y = (o[p + 1] / e + 1) / 2),
        l.push(d.x, d.y);
    }
    for (let h = 1; h <= n; h++) s.push(h, h + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new tt(o, 3)),
      this.setAttribute("normal", new tt(a, 3)),
      this.setAttribute("uv", new tt(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Y0(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Oc extends bt {
  constructor(
    e = 1,
    n = 1,
    r = 1,
    i = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: n,
        height: r,
        radialSegments: i,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const f = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const d = [],
      h = [],
      p = [],
      g = [];
    let v = 0;
    const _ = [],
      x = r / 2;
    let m = 0;
    w(),
      o === !1 && (e > 0 && S(!0), n > 0 && S(!1)),
      this.setIndex(d),
      this.setAttribute("position", new tt(h, 3)),
      this.setAttribute("normal", new tt(p, 3)),
      this.setAttribute("uv", new tt(g, 2));
    function w() {
      const E = new z(),
        T = new z();
      let A = 0;
      const L = (n - e) / r;
      for (let N = 0; N <= s; N++) {
        const C = [],
          I = N / s,
          k = I * (n - e) + e;
        for (let R = 0; R <= i; R++) {
          const $ = R / i,
            D = $ * l + a,
            W = Math.sin(D),
            Y = Math.cos(D);
          (T.x = k * W),
            (T.y = -I * r + x),
            (T.z = k * Y),
            h.push(T.x, T.y, T.z),
            E.set(W, L, Y).normalize(),
            p.push(E.x, E.y, E.z),
            g.push($, 1 - I),
            C.push(v++);
        }
        _.push(C);
      }
      for (let N = 0; N < i; N++)
        for (let C = 0; C < s; C++) {
          const I = _[C][N],
            k = _[C + 1][N],
            R = _[C + 1][N + 1],
            $ = _[C][N + 1];
          d.push(I, k, $), d.push(k, R, $), (A += 6);
        }
      f.addGroup(m, A, 0), (m += A);
    }
    function S(E) {
      const T = v,
        A = new _e(),
        L = new z();
      let N = 0;
      const C = E === !0 ? e : n,
        I = E === !0 ? 1 : -1;
      for (let R = 1; R <= i; R++)
        h.push(0, x * I, 0), p.push(0, I, 0), g.push(0.5, 0.5), v++;
      const k = v;
      for (let R = 0; R <= i; R++) {
        const D = (R / i) * l + a,
          W = Math.cos(D),
          Y = Math.sin(D);
        (L.x = C * Y),
          (L.y = x * I),
          (L.z = C * W),
          h.push(L.x, L.y, L.z),
          p.push(0, I, 0),
          (A.x = W * 0.5 + 0.5),
          (A.y = Y * 0.5 * I + 0.5),
          g.push(A.x, A.y),
          v++;
      }
      for (let R = 0; R < i; R++) {
        const $ = T + R,
          D = k + R;
        E === !0 ? d.push(D, D + 1, $) : d.push(D + 1, D, $), (N += 3);
      }
      f.addGroup(m, N, E === !0 ? 1 : 2), (m += N);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Oc(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class q0 extends Oc {
  constructor(e = 1, n = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, n, r, i, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: n,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new q0(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Aa extends bt {
  constructor(e = [], n = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: n, radius: r, detail: i });
    const s = [],
      o = [];
    a(i),
      f(r),
      d(),
      this.setAttribute("position", new tt(s, 3)),
      this.setAttribute("normal", new tt(s.slice(), 3)),
      this.setAttribute("uv", new tt(o, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(w) {
      const S = new z(),
        E = new z(),
        T = new z();
      for (let A = 0; A < n.length; A += 3)
        g(n[A + 0], S), g(n[A + 1], E), g(n[A + 2], T), l(S, E, T, w);
    }
    function l(w, S, E, T) {
      const A = T + 1,
        L = [];
      for (let N = 0; N <= A; N++) {
        L[N] = [];
        const C = w.clone().lerp(E, N / A),
          I = S.clone().lerp(E, N / A),
          k = A - N;
        for (let R = 0; R <= k; R++)
          R === 0 && N === A
            ? (L[N][R] = C)
            : (L[N][R] = C.clone().lerp(I, R / k));
      }
      for (let N = 0; N < A; N++)
        for (let C = 0; C < 2 * (A - N) - 1; C++) {
          const I = Math.floor(C / 2);
          C % 2 === 0
            ? (p(L[N][I + 1]), p(L[N + 1][I]), p(L[N][I]))
            : (p(L[N][I + 1]), p(L[N + 1][I + 1]), p(L[N + 1][I]));
        }
    }
    function f(w) {
      const S = new z();
      for (let E = 0; E < s.length; E += 3)
        (S.x = s[E + 0]),
          (S.y = s[E + 1]),
          (S.z = s[E + 2]),
          S.normalize().multiplyScalar(w),
          (s[E + 0] = S.x),
          (s[E + 1] = S.y),
          (s[E + 2] = S.z);
    }
    function d() {
      const w = new z();
      for (let S = 0; S < s.length; S += 3) {
        (w.x = s[S + 0]), (w.y = s[S + 1]), (w.z = s[S + 2]);
        const E = x(w) / 2 / Math.PI + 0.5,
          T = m(w) / Math.PI + 0.5;
        o.push(E, 1 - T);
      }
      v(), h();
    }
    function h() {
      for (let w = 0; w < o.length; w += 6) {
        const S = o[w + 0],
          E = o[w + 2],
          T = o[w + 4],
          A = Math.max(S, E, T),
          L = Math.min(S, E, T);
        A > 0.9 &&
          L < 0.1 &&
          (S < 0.2 && (o[w + 0] += 1),
          E < 0.2 && (o[w + 2] += 1),
          T < 0.2 && (o[w + 4] += 1));
      }
    }
    function p(w) {
      s.push(w.x, w.y, w.z);
    }
    function g(w, S) {
      const E = w * 3;
      (S.x = e[E + 0]), (S.y = e[E + 1]), (S.z = e[E + 2]);
    }
    function v() {
      const w = new z(),
        S = new z(),
        E = new z(),
        T = new z(),
        A = new _e(),
        L = new _e(),
        N = new _e();
      for (let C = 0, I = 0; C < s.length; C += 9, I += 6) {
        w.set(s[C + 0], s[C + 1], s[C + 2]),
          S.set(s[C + 3], s[C + 4], s[C + 5]),
          E.set(s[C + 6], s[C + 7], s[C + 8]),
          A.set(o[I + 0], o[I + 1]),
          L.set(o[I + 2], o[I + 3]),
          N.set(o[I + 4], o[I + 5]),
          T.copy(w).add(S).add(E).divideScalar(3);
        const k = x(T);
        _(A, I + 0, w, k), _(L, I + 2, S, k), _(N, I + 4, E, k);
      }
    }
    function _(w, S, E, T) {
      T < 0 && w.x === 1 && (o[S] = w.x - 1),
        E.x === 0 && E.z === 0 && (o[S] = T / 2 / Math.PI + 0.5);
    }
    function x(w) {
      return Math.atan2(w.z, -w.x);
    }
    function m(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Aa(e.vertices, e.indices, e.radius, e.details);
  }
}
class K0 extends Aa {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, n),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new K0(e.radius, e.detail);
  }
}
const mm = new z(),
  gm = new z(),
  t_ = new z(),
  vm = new Zr();
class x3 extends bt {
  constructor(e = null, n = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: n }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        s = Math.cos(xl * n),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        f = [0, 0, 0],
        d = ["a", "b", "c"],
        h = new Array(3),
        p = {},
        g = [];
      for (let v = 0; v < l; v += 3) {
        o
          ? ((f[0] = o.getX(v)), (f[1] = o.getX(v + 1)), (f[2] = o.getX(v + 2)))
          : ((f[0] = v), (f[1] = v + 1), (f[2] = v + 2));
        const { a: _, b: x, c: m } = vm;
        if (
          (_.fromBufferAttribute(a, f[0]),
          x.fromBufferAttribute(a, f[1]),
          m.fromBufferAttribute(a, f[2]),
          vm.getNormal(t_),
          (h[0] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(
            _.z * i
          )}`),
          (h[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (h[2] = `${Math.round(m.x * i)},${Math.round(m.y * i)},${Math.round(
            m.z * i
          )}`),
          !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
        )
          for (let w = 0; w < 3; w++) {
            const S = (w + 1) % 3,
              E = h[w],
              T = h[S],
              A = vm[d[w]],
              L = vm[d[S]],
              N = `${E}_${T}`,
              C = `${T}_${E}`;
            C in p && p[C]
              ? (t_.dot(p[C].normal) <= s &&
                  (g.push(A.x, A.y, A.z), g.push(L.x, L.y, L.z)),
                (p[C] = null))
              : N in p ||
                (p[N] = { index0: f[w], index1: f[S], normal: t_.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: _, index1: x } = p[v];
          mm.fromBufferAttribute(a, _),
            gm.fromBufferAttribute(a, x),
            g.push(mm.x, mm.y, mm.z),
            g.push(gm.x, gm.y, gm.z);
        }
      this.setAttribute("position", new tt(g, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class wl extends Bd {
  constructor(e) {
    super(e), (this.uuid = vi()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const n = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      n[r] = this.holes[r].getPoints(e);
    return n;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let n = 0, r = this.holes.length; n < r; n++) {
      const i = this.holes[n];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(new Bd().fromJSON(i));
    }
    return this;
  }
}
const r6 = {
  triangulate: function (t, e, n = 2) {
    const r = e && e.length,
      i = r ? e[0] * n : t.length;
    let s = _3(t, 0, i, n, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, f, d, h, p, g;
    if ((r && (s = l6(t, e, s, n)), t.length > 80 * n)) {
      (a = f = t[0]), (l = d = t[1]);
      for (let v = n; v < i; v += n)
        (h = t[v]),
          (p = t[v + 1]),
          h < a && (a = h),
          p < l && (l = p),
          h > f && (f = h),
          p > d && (d = p);
      (g = Math.max(f - a, d - l)), (g = g !== 0 ? 32767 / g : 0);
    }
    return Hd(s, o, n, a, l, g, 0), o;
  },
};
function _3(t, e, n, r, i) {
  let s, o;
  if (i === x6(t, e, n, r) > 0)
    for (s = e; s < n; s += r) o = vC(s, t[s], t[s + 1], o);
  else for (s = n - r; s >= e; s -= r) o = vC(s, t[s], t[s + 1], o);
  return o && Z0(o, o.next) && (Wd(o), (o = o.next)), o;
}
function Ll(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t,
    r;
  do
    if (
      ((r = !1), !n.steiner && (Z0(n, n.next) || hn(n.prev, n, n.next) === 0))
    ) {
      if ((Wd(n), (n = e = n.prev), n === n.next)) break;
      r = !0;
    } else n = n.next;
  while (r || n !== e);
  return e;
}
function Hd(t, e, n, r, i, s, o) {
  if (!t) return;
  !o && s && h6(t, r, i, s);
  let a = t,
    l,
    f;
  for (; t.prev !== t.next; ) {
    if (((l = t.prev), (f = t.next), s ? s6(t, r, i, s) : i6(t))) {
      e.push((l.i / n) | 0),
        e.push((t.i / n) | 0),
        e.push((f.i / n) | 0),
        Wd(t),
        (t = f.next),
        (a = f.next);
      continue;
    }
    if (((t = f), t === a)) {
      o
        ? o === 1
          ? ((t = o6(Ll(t), e, n)), Hd(t, e, n, r, i, s, 2))
          : o === 2 && a6(t, e, n, r, i, s)
        : Hd(Ll(t), e, n, r, i, s, 1);
      break;
    }
  }
}
function i6(t) {
  const e = t.prev,
    n = t,
    r = t.next;
  if (hn(e, n, r) >= 0) return !1;
  const i = e.x,
    s = n.x,
    o = r.x,
    a = e.y,
    l = n.y,
    f = r.y,
    d = i < s ? (i < o ? i : o) : s < o ? s : o,
    h = a < l ? (a < f ? a : f) : l < f ? l : f,
    p = i > s ? (i > o ? i : o) : s > o ? s : o,
    g = a > l ? (a > f ? a : f) : l > f ? l : f;
  let v = r.next;
  for (; v !== e; ) {
    if (
      v.x >= d &&
      v.x <= p &&
      v.y >= h &&
      v.y <= g &&
      Zu(i, a, s, l, o, f, v.x, v.y) &&
      hn(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function s6(t, e, n, r) {
  const i = t.prev,
    s = t,
    o = t.next;
  if (hn(i, s, o) >= 0) return !1;
  const a = i.x,
    l = s.x,
    f = o.x,
    d = i.y,
    h = s.y,
    p = o.y,
    g = a < l ? (a < f ? a : f) : l < f ? l : f,
    v = d < h ? (d < p ? d : p) : h < p ? h : p,
    _ = a > l ? (a > f ? a : f) : l > f ? l : f,
    x = d > h ? (d > p ? d : p) : h > p ? h : p,
    m = l1(g, v, e, n, r),
    w = l1(_, x, e, n, r);
  let S = t.prevZ,
    E = t.nextZ;
  for (; S && S.z >= m && E && E.z <= w; ) {
    if (
      (S.x >= g &&
        S.x <= _ &&
        S.y >= v &&
        S.y <= x &&
        S !== i &&
        S !== o &&
        Zu(a, d, l, h, f, p, S.x, S.y) &&
        hn(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      E.x >= g &&
        E.x <= _ &&
        E.y >= v &&
        E.y <= x &&
        E !== i &&
        E !== o &&
        Zu(a, d, l, h, f, p, E.x, E.y) &&
        hn(E.prev, E, E.next) >= 0)
    )
      return !1;
    E = E.nextZ;
  }
  for (; S && S.z >= m; ) {
    if (
      S.x >= g &&
      S.x <= _ &&
      S.y >= v &&
      S.y <= x &&
      S !== i &&
      S !== o &&
      Zu(a, d, l, h, f, p, S.x, S.y) &&
      hn(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; E && E.z <= w; ) {
    if (
      E.x >= g &&
      E.x <= _ &&
      E.y >= v &&
      E.y <= x &&
      E !== i &&
      E !== o &&
      Zu(a, d, l, h, f, p, E.x, E.y) &&
      hn(E.prev, E, E.next) >= 0
    )
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function o6(t, e, n) {
  let r = t;
  do {
    const i = r.prev,
      s = r.next.next;
    !Z0(i, s) &&
      S3(i, r, r.next, s) &&
      Vd(i, s) &&
      Vd(s, i) &&
      (e.push((i.i / n) | 0),
      e.push((r.i / n) | 0),
      e.push((s.i / n) | 0),
      Wd(r),
      Wd(r.next),
      (r = t = s)),
      (r = r.next);
  } while (r !== t);
  return Ll(r);
}
function a6(t, e, n, r, i, s) {
  let o = t;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && g6(o, a)) {
        let l = w3(o, a);
        (o = Ll(o, o.next)),
          (l = Ll(l, l.next)),
          Hd(o, e, n, r, i, s, 0),
          Hd(l, e, n, r, i, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== t);
}
function l6(t, e, n, r) {
  const i = [];
  let s, o, a, l, f;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * r),
      (l = s < o - 1 ? e[s + 1] * r : t.length),
      (f = _3(t, a, l, r, !1)),
      f === f.next && (f.steiner = !0),
      i.push(m6(f));
  for (i.sort(u6), s = 0; s < i.length; s++) n = c6(i[s], n);
  return n;
}
function u6(t, e) {
  return t.x - e.x;
}
function c6(t, e) {
  const n = f6(t, e);
  if (!n) return e;
  const r = w3(n, t);
  return Ll(r, r.next), Ll(n, n.next);
}
function f6(t, e) {
  let n = e,
    r = -1 / 0,
    i;
  const s = t.x,
    o = t.y;
  do {
    if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
      const p = n.x + ((o - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
      if (
        p <= s &&
        p > r &&
        ((r = p), (i = n.x < n.next.x ? n : n.next), p === s)
      )
        return i;
    }
    n = n.next;
  } while (n !== e);
  if (!i) return null;
  const a = i,
    l = i.x,
    f = i.y;
  let d = 1 / 0,
    h;
  n = i;
  do
    s >= n.x &&
      n.x >= l &&
      s !== n.x &&
      Zu(o < f ? s : r, o, l, f, o < f ? r : s, o, n.x, n.y) &&
      ((h = Math.abs(o - n.y) / (s - n.x)),
      Vd(n, t) &&
        (h < d || (h === d && (n.x > i.x || (n.x === i.x && d6(i, n))))) &&
        ((i = n), (d = h))),
      (n = n.next);
  while (n !== a);
  return i;
}
function d6(t, e) {
  return hn(t.prev, t, e.prev) < 0 && hn(e.next, t, t.next) < 0;
}
function h6(t, e, n, r) {
  let i = t;
  do
    i.z === 0 && (i.z = l1(i.x, i.y, e, n, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== t);
  (i.prevZ.nextZ = null), (i.prevZ = null), p6(i);
}
function p6(t) {
  let e,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    f = 1;
  do {
    for (n = t, t = null, s = null, o = 0; n; ) {
      for (o++, r = n, a = 0, e = 0; e < f && (a++, (r = r.nextZ), !!r); e++);
      for (l = f; a > 0 || (l > 0 && r); )
        a !== 0 && (l === 0 || !r || n.z <= r.z)
          ? ((i = n), (n = n.nextZ), a--)
          : ((i = r), (r = r.nextZ), l--),
          s ? (s.nextZ = i) : (t = i),
          (i.prevZ = s),
          (s = i);
      n = r;
    }
    (s.nextZ = null), (f *= 2);
  } while (o > 1);
  return t;
}
function l1(t, e, n, r, i) {
  return (
    (t = ((t - n) * i) | 0),
    (e = ((e - r) * i) | 0),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    t | (e << 1)
  );
}
function m6(t) {
  let e = t,
    n = t;
  do (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
  while (e !== t);
  return n;
}
function Zu(t, e, n, r, i, s, o, a) {
  return (
    (i - o) * (e - a) >= (t - o) * (s - a) &&
    (t - o) * (r - a) >= (n - o) * (e - a) &&
    (n - o) * (s - a) >= (i - o) * (r - a)
  );
}
function g6(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !v6(t, e) &&
    ((Vd(t, e) &&
      Vd(e, t) &&
      y6(t, e) &&
      (hn(t.prev, t, e.prev) || hn(t, e.prev, e))) ||
      (Z0(t, e) && hn(t.prev, t, t.next) > 0 && hn(e.prev, e, e.next) > 0))
  );
}
function hn(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function Z0(t, e) {
  return t.x === e.x && t.y === e.y;
}
function S3(t, e, n, r) {
  const i = xm(hn(t, e, n)),
    s = xm(hn(t, e, r)),
    o = xm(hn(n, r, t)),
    a = xm(hn(n, r, e));
  return !!(
    (i !== s && o !== a) ||
    (i === 0 && ym(t, n, e)) ||
    (s === 0 && ym(t, r, e)) ||
    (o === 0 && ym(n, t, r)) ||
    (a === 0 && ym(n, e, r))
  );
}
function ym(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  );
}
function xm(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function v6(t, e) {
  let n = t;
  do {
    if (
      n.i !== t.i &&
      n.next.i !== t.i &&
      n.i !== e.i &&
      n.next.i !== e.i &&
      S3(n, n.next, t, e)
    )
      return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function Vd(t, e) {
  return hn(t.prev, t, t.next) < 0
    ? hn(t, e, t.next) >= 0 && hn(t, t.prev, e) >= 0
    : hn(t, e, t.prev) < 0 || hn(t, t.next, e) < 0;
}
function y6(t, e) {
  let n = t,
    r = !1;
  const i = (t.x + e.x) / 2,
    s = (t.y + e.y) / 2;
  do
    n.y > s != n.next.y > s &&
      n.next.y !== n.y &&
      i < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
      (r = !r),
      (n = n.next);
  while (n !== t);
  return r;
}
function w3(t, e) {
  const n = new u1(t.i, t.x, t.y),
    r = new u1(e.i, e.x, e.y),
    i = t.next,
    s = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = i),
    (i.prev = n),
    (r.next = n),
    (n.prev = r),
    (s.next = r),
    (r.prev = s),
    r
  );
}
function vC(t, e, n, r) {
  const i = new u1(t, e, n);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Wd(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function u1(t, e, n) {
  (this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function x6(t, e, n, r) {
  let i = 0;
  for (let s = e, o = n - r; s < n; s += r)
    (i += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
  return i;
}
class Us {
  static area(e) {
    const n = e.length;
    let r = 0;
    for (let i = n - 1, s = 0; s < n; i = s++)
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Us.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const r = [],
      i = [],
      s = [];
    yC(e), xC(r, e);
    let o = e.length;
    n.forEach(yC);
    for (let l = 0; l < n.length; l++)
      i.push(o), (o += n[l].length), xC(r, n[l]);
    const a = r6.triangulate(r, i);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function yC(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function xC(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}
class J0 extends bt {
  constructor(
    e = new wl([
      new _e(0.5, 0.5),
      new _e(-0.5, 0.5),
      new _e(-0.5, -0.5),
      new _e(0.5, -0.5),
    ]),
    n = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: n }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const f = e[a];
      o(f);
    }
    this.setAttribute("position", new tt(i, 3)),
      this.setAttribute("uv", new tt(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        f = n.curveSegments !== void 0 ? n.curveSegments : 12,
        d = n.steps !== void 0 ? n.steps : 1,
        h = n.depth !== void 0 ? n.depth : 1;
      let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
        g = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2,
        v = n.bevelSize !== void 0 ? n.bevelSize : g - 0.1,
        _ = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
        x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const m = n.extrudePath,
        w = n.UVGenerator !== void 0 ? n.UVGenerator : _6;
      let S,
        E = !1,
        T,
        A,
        L,
        N;
      m &&
        ((S = m.getSpacedPoints(d)),
        (E = !0),
        (p = !1),
        (T = m.computeFrenetFrames(d, !1)),
        (A = new z()),
        (L = new z()),
        (N = new z())),
        p || ((x = 0), (g = 0), (v = 0), (_ = 0));
      const C = a.extractPoints(f);
      let I = C.shape;
      const k = C.holes;
      if (!Us.isClockWise(I)) {
        I = I.reverse();
        for (let H = 0, pe = k.length; H < pe; H++) {
          const ie = k[H];
          Us.isClockWise(ie) && (k[H] = ie.reverse());
        }
      }
      const $ = Us.triangulateShape(I, k),
        D = I;
      for (let H = 0, pe = k.length; H < pe; H++) {
        const ie = k[H];
        I = I.concat(ie);
      }
      function W(H, pe, ie) {
        return (
          pe || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          H.clone().addScaledVector(pe, ie)
        );
      }
      const Y = I.length,
        Z = $.length;
      function B(H, pe, ie) {
        let we, xe, $e;
        const Fe = H.x - pe.x,
          He = H.y - pe.y,
          Ze = ie.x - H.x,
          it = ie.y - H.y,
          Tt = Fe * Fe + He * He,
          V = Fe * it - He * Ze;
        if (Math.abs(V) > Number.EPSILON) {
          const O = Math.sqrt(Tt),
            se = Math.sqrt(Ze * Ze + it * it),
            Re = pe.x - He / O,
            Ee = pe.y + Fe / O,
            Ae = ie.x - it / se,
            Ye = ie.y + Ze / se,
            Pe = ((Ae - Re) * it - (Ye - Ee) * Ze) / (Fe * it - He * Ze);
          (we = Re + Fe * Pe - H.x), (xe = Ee + He * Pe - H.y);
          const Te = we * we + xe * xe;
          if (Te <= 2) return new _e(we, xe);
          $e = Math.sqrt(Te / 2);
        } else {
          let O = !1;
          Fe > Number.EPSILON
            ? Ze > Number.EPSILON && (O = !0)
            : Fe < -Number.EPSILON
            ? Ze < -Number.EPSILON && (O = !0)
            : Math.sign(He) === Math.sign(it) && (O = !0),
            O
              ? ((we = -He), (xe = Fe), ($e = Math.sqrt(Tt)))
              : ((we = Fe), (xe = He), ($e = Math.sqrt(Tt / 2)));
        }
        return new _e(we / $e, xe / $e);
      }
      const G = [];
      for (
        let H = 0, pe = D.length, ie = pe - 1, we = H + 1;
        H < pe;
        H++, ie++, we++
      )
        ie === pe && (ie = 0),
          we === pe && (we = 0),
          (G[H] = B(D[H], D[ie], D[we]));
      const X = [];
      let te,
        oe = G.concat();
      for (let H = 0, pe = k.length; H < pe; H++) {
        const ie = k[H];
        te = [];
        for (
          let we = 0, xe = ie.length, $e = xe - 1, Fe = we + 1;
          we < xe;
          we++, $e++, Fe++
        )
          $e === xe && ($e = 0),
            Fe === xe && (Fe = 0),
            (te[we] = B(ie[we], ie[$e], ie[Fe]));
        X.push(te), (oe = oe.concat(te));
      }
      for (let H = 0; H < x; H++) {
        const pe = H / x,
          ie = g * Math.cos((pe * Math.PI) / 2),
          we = v * Math.sin((pe * Math.PI) / 2) + _;
        for (let xe = 0, $e = D.length; xe < $e; xe++) {
          const Fe = W(D[xe], G[xe], we);
          Ce(Fe.x, Fe.y, -ie);
        }
        for (let xe = 0, $e = k.length; xe < $e; xe++) {
          const Fe = k[xe];
          te = X[xe];
          for (let He = 0, Ze = Fe.length; He < Ze; He++) {
            const it = W(Fe[He], te[He], we);
            Ce(it.x, it.y, -ie);
          }
        }
      }
      const J = v + _;
      for (let H = 0; H < Y; H++) {
        const pe = p ? W(I[H], oe[H], J) : I[H];
        E
          ? (L.copy(T.normals[0]).multiplyScalar(pe.x),
            A.copy(T.binormals[0]).multiplyScalar(pe.y),
            N.copy(S[0]).add(L).add(A),
            Ce(N.x, N.y, N.z))
          : Ce(pe.x, pe.y, 0);
      }
      for (let H = 1; H <= d; H++)
        for (let pe = 0; pe < Y; pe++) {
          const ie = p ? W(I[pe], oe[pe], J) : I[pe];
          E
            ? (L.copy(T.normals[H]).multiplyScalar(ie.x),
              A.copy(T.binormals[H]).multiplyScalar(ie.y),
              N.copy(S[H]).add(L).add(A),
              Ce(N.x, N.y, N.z))
            : Ce(ie.x, ie.y, (h / d) * H);
        }
      for (let H = x - 1; H >= 0; H--) {
        const pe = H / x,
          ie = g * Math.cos((pe * Math.PI) / 2),
          we = v * Math.sin((pe * Math.PI) / 2) + _;
        for (let xe = 0, $e = D.length; xe < $e; xe++) {
          const Fe = W(D[xe], G[xe], we);
          Ce(Fe.x, Fe.y, h + ie);
        }
        for (let xe = 0, $e = k.length; xe < $e; xe++) {
          const Fe = k[xe];
          te = X[xe];
          for (let He = 0, Ze = Fe.length; He < Ze; He++) {
            const it = W(Fe[He], te[He], we);
            E
              ? Ce(it.x, it.y + S[d - 1].y, S[d - 1].x + ie)
              : Ce(it.x, it.y, h + ie);
          }
        }
      }
      ae(), Se();
      function ae() {
        const H = i.length / 3;
        if (p) {
          let pe = 0,
            ie = Y * pe;
          for (let we = 0; we < Z; we++) {
            const xe = $[we];
            et(xe[2] + ie, xe[1] + ie, xe[0] + ie);
          }
          (pe = d + x * 2), (ie = Y * pe);
          for (let we = 0; we < Z; we++) {
            const xe = $[we];
            et(xe[0] + ie, xe[1] + ie, xe[2] + ie);
          }
        } else {
          for (let pe = 0; pe < Z; pe++) {
            const ie = $[pe];
            et(ie[2], ie[1], ie[0]);
          }
          for (let pe = 0; pe < Z; pe++) {
            const ie = $[pe];
            et(ie[0] + Y * d, ie[1] + Y * d, ie[2] + Y * d);
          }
        }
        r.addGroup(H, i.length / 3 - H, 0);
      }
      function Se() {
        const H = i.length / 3;
        let pe = 0;
        Ie(D, pe), (pe += D.length);
        for (let ie = 0, we = k.length; ie < we; ie++) {
          const xe = k[ie];
          Ie(xe, pe), (pe += xe.length);
        }
        r.addGroup(H, i.length / 3 - H, 1);
      }
      function Ie(H, pe) {
        let ie = H.length;
        for (; --ie >= 0; ) {
          const we = ie;
          let xe = ie - 1;
          xe < 0 && (xe = H.length - 1);
          for (let $e = 0, Fe = d + x * 2; $e < Fe; $e++) {
            const He = Y * $e,
              Ze = Y * ($e + 1),
              it = pe + we + He,
              Tt = pe + xe + He,
              V = pe + xe + Ze,
              O = pe + we + Ze;
            We(it, Tt, V, O);
          }
        }
      }
      function Ce(H, pe, ie) {
        l.push(H), l.push(pe), l.push(ie);
      }
      function et(H, pe, ie) {
        Me(H), Me(pe), Me(ie);
        const we = i.length / 3,
          xe = w.generateTopUV(r, i, we - 3, we - 2, we - 1);
        Le(xe[0]), Le(xe[1]), Le(xe[2]);
      }
      function We(H, pe, ie, we) {
        Me(H), Me(pe), Me(we), Me(pe), Me(ie), Me(we);
        const xe = i.length / 3,
          $e = w.generateSideWallUV(r, i, xe - 6, xe - 3, xe - 2, xe - 1);
        Le($e[0]), Le($e[1]), Le($e[3]), Le($e[1]), Le($e[2]), Le($e[3]);
      }
      function Me(H) {
        i.push(l[H * 3 + 0]), i.push(l[H * 3 + 1]), i.push(l[H * 3 + 2]);
      }
      function Le(H) {
        s.push(H.x), s.push(H.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes,
      r = this.parameters.options;
    return S6(n, r, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = n[e.shapes[s]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new Bg[i.type]().fromJSON(i)),
      new J0(r, e.options)
    );
  }
}
const _6 = {
  generateTopUV: function (t, e, n, r, i) {
    const s = e[n * 3],
      o = e[n * 3 + 1],
      a = e[r * 3],
      l = e[r * 3 + 1],
      f = e[i * 3],
      d = e[i * 3 + 1];
    return [new _e(s, o), new _e(a, l), new _e(f, d)];
  },
  generateSideWallUV: function (t, e, n, r, i, s) {
    const o = e[n * 3],
      a = e[n * 3 + 1],
      l = e[n * 3 + 2],
      f = e[r * 3],
      d = e[r * 3 + 1],
      h = e[r * 3 + 2],
      p = e[i * 3],
      g = e[i * 3 + 1],
      v = e[i * 3 + 2],
      _ = e[s * 3],
      x = e[s * 3 + 1],
      m = e[s * 3 + 2];
    return Math.abs(a - d) < Math.abs(o - f)
      ? [new _e(o, 1 - l), new _e(f, 1 - h), new _e(p, 1 - v), new _e(_, 1 - m)]
      : [
          new _e(a, 1 - l),
          new _e(d, 1 - h),
          new _e(g, 1 - v),
          new _e(x, 1 - m),
        ];
  },
};
function S6(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      n.shapes.push(s.uuid);
    }
  else n.shapes.push(t.uuid);
  return (
    (n.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  );
}
class Q0 extends Aa {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, n),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new Q0(e.radius, e.detail);
  }
}
class fh extends Aa {
  constructor(e = 1, n = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, n),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new fh(e.radius, e.detail);
  }
}
class ev extends bt {
  constructor(e = 0.5, n = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: n,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: s,
        thetaLength: o,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      l = [],
      f = [],
      d = [];
    let h = e;
    const p = (n - e) / i,
      g = new z(),
      v = new _e();
    for (let _ = 0; _ <= i; _++) {
      for (let x = 0; x <= r; x++) {
        const m = s + (x / r) * o;
        (g.x = h * Math.cos(m)),
          (g.y = h * Math.sin(m)),
          l.push(g.x, g.y, g.z),
          f.push(0, 0, 1),
          (v.x = (g.x / n + 1) / 2),
          (v.y = (g.y / n + 1) / 2),
          d.push(v.x, v.y);
      }
      h += p;
    }
    for (let _ = 0; _ < i; _++) {
      const x = _ * (r + 1);
      for (let m = 0; m < r; m++) {
        const w = m + x,
          S = w,
          E = w + r + 1,
          T = w + r + 2,
          A = w + 1;
        a.push(S, E, A), a.push(E, T, A);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new tt(l, 3)),
      this.setAttribute("normal", new tt(f, 3)),
      this.setAttribute("uv", new tt(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ev(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class tv extends bt {
  constructor(
    e = new wl([new _e(0, 0.5), new _e(-0.5, -0.5), new _e(0.5, -0.5)]),
    n = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: n });
    const r = [],
      i = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) f(e);
    else
      for (let d = 0; d < e.length; d++)
        f(e[d]), this.addGroup(a, l, d), (a += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new tt(i, 3)),
      this.setAttribute("normal", new tt(s, 3)),
      this.setAttribute("uv", new tt(o, 2));
    function f(d) {
      const h = i.length / 3,
        p = d.extractPoints(n);
      let g = p.shape;
      const v = p.holes;
      Us.isClockWise(g) === !1 && (g = g.reverse());
      for (let x = 0, m = v.length; x < m; x++) {
        const w = v[x];
        Us.isClockWise(w) === !0 && (v[x] = w.reverse());
      }
      const _ = Us.triangulateShape(g, v);
      for (let x = 0, m = v.length; x < m; x++) {
        const w = v[x];
        g = g.concat(w);
      }
      for (let x = 0, m = g.length; x < m; x++) {
        const w = g[x];
        i.push(w.x, w.y, 0), s.push(0, 0, 1), o.push(w.x, w.y);
      }
      for (let x = 0, m = _.length; x < m; x++) {
        const w = _[x],
          S = w[0] + h,
          E = w[1] + h,
          T = w[2] + h;
        r.push(S, E, T), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes;
    return w6(n, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const o = n[e.shapes[i]];
      r.push(o);
    }
    return new tv(r, e.curveSegments);
  }
}
function w6(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, r = t.length; n < r; n++) {
      const i = t[n];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(t.uuid);
  return e;
}
class dh extends bt {
  constructor(
    e = 1,
    n = 32,
    r = 16,
    i = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: n,
        heightSegments: r,
        phiStart: i,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (n = Math.max(3, Math.floor(n))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(o + a, Math.PI);
    let f = 0;
    const d = [],
      h = new z(),
      p = new z(),
      g = [],
      v = [],
      _ = [],
      x = [];
    for (let m = 0; m <= r; m++) {
      const w = [],
        S = m / r;
      let E = 0;
      m === 0 && o === 0
        ? (E = 0.5 / n)
        : m === r && l === Math.PI && (E = -0.5 / n);
      for (let T = 0; T <= n; T++) {
        const A = T / n;
        (h.x = -e * Math.cos(i + A * s) * Math.sin(o + S * a)),
          (h.y = e * Math.cos(o + S * a)),
          (h.z = e * Math.sin(i + A * s) * Math.sin(o + S * a)),
          v.push(h.x, h.y, h.z),
          p.copy(h).normalize(),
          _.push(p.x, p.y, p.z),
          x.push(A + E, 1 - S),
          w.push(f++);
      }
      d.push(w);
    }
    for (let m = 0; m < r; m++)
      for (let w = 0; w < n; w++) {
        const S = d[m][w + 1],
          E = d[m][w],
          T = d[m + 1][w],
          A = d[m + 1][w + 1];
        (m !== 0 || o > 0) && g.push(S, E, A),
          (m !== r - 1 || l < Math.PI) && g.push(E, T, A);
      }
    this.setIndex(g),
      this.setAttribute("position", new tt(v, 3)),
      this.setAttribute("normal", new tt(_, 3)),
      this.setAttribute("uv", new tt(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new dh(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class nv extends Aa {
  constructor(e = 1, n = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, n),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new nv(e.radius, e.detail);
  }
}
class rv extends bt {
  constructor(e = 1, n = 0.4, r = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        radialSegments: r,
        tubularSegments: i,
        arc: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const o = [],
      a = [],
      l = [],
      f = [],
      d = new z(),
      h = new z(),
      p = new z();
    for (let g = 0; g <= r; g++)
      for (let v = 0; v <= i; v++) {
        const _ = (v / i) * s,
          x = (g / r) * Math.PI * 2;
        (h.x = (e + n * Math.cos(x)) * Math.cos(_)),
          (h.y = (e + n * Math.cos(x)) * Math.sin(_)),
          (h.z = n * Math.sin(x)),
          a.push(h.x, h.y, h.z),
          (d.x = e * Math.cos(_)),
          (d.y = e * Math.sin(_)),
          p.subVectors(h, d).normalize(),
          l.push(p.x, p.y, p.z),
          f.push(v / i),
          f.push(g / r);
      }
    for (let g = 1; g <= r; g++)
      for (let v = 1; v <= i; v++) {
        const _ = (i + 1) * g + v - 1,
          x = (i + 1) * (g - 1) + v - 1,
          m = (i + 1) * (g - 1) + v,
          w = (i + 1) * g + v;
        o.push(_, x, w), o.push(x, m, w);
      }
    this.setIndex(o),
      this.setAttribute("position", new tt(a, 3)),
      this.setAttribute("normal", new tt(l, 3)),
      this.setAttribute("uv", new tt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new rv(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class iv extends bt {
  constructor(e = 1, n = 0.4, r = 64, i = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        tubularSegments: r,
        radialSegments: i,
        p: s,
        q: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      f = [],
      d = [],
      h = new z(),
      p = new z(),
      g = new z(),
      v = new z(),
      _ = new z(),
      x = new z(),
      m = new z();
    for (let S = 0; S <= r; ++S) {
      const E = (S / r) * s * Math.PI * 2;
      w(E, s, o, e, g),
        w(E + 0.01, s, o, e, v),
        x.subVectors(v, g),
        m.addVectors(v, g),
        _.crossVectors(x, m),
        m.crossVectors(_, x),
        _.normalize(),
        m.normalize();
      for (let T = 0; T <= i; ++T) {
        const A = (T / i) * Math.PI * 2,
          L = -n * Math.cos(A),
          N = n * Math.sin(A);
        (h.x = g.x + (L * m.x + N * _.x)),
          (h.y = g.y + (L * m.y + N * _.y)),
          (h.z = g.z + (L * m.z + N * _.z)),
          l.push(h.x, h.y, h.z),
          p.subVectors(h, g).normalize(),
          f.push(p.x, p.y, p.z),
          d.push(S / r),
          d.push(T / i);
      }
    }
    for (let S = 1; S <= r; S++)
      for (let E = 1; E <= i; E++) {
        const T = (i + 1) * (S - 1) + (E - 1),
          A = (i + 1) * S + (E - 1),
          L = (i + 1) * S + E,
          N = (i + 1) * (S - 1) + E;
        a.push(T, A, N), a.push(A, L, N);
      }
    this.setIndex(a),
      this.setAttribute("position", new tt(l, 3)),
      this.setAttribute("normal", new tt(f, 3)),
      this.setAttribute("uv", new tt(d, 2));
    function w(S, E, T, A, L) {
      const N = Math.cos(S),
        C = Math.sin(S),
        I = (T / E) * S,
        k = Math.cos(I);
      (L.x = A * (2 + k) * 0.5 * N),
        (L.y = A * (2 + k) * C * 0.5),
        (L.z = A * Math.sin(I) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new iv(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class sv extends bt {
  constructor(
    e = new yM(new z(-1, -1, 0), new z(-1, 1, 0), new z(1, 1, 0)),
    n = 64,
    r = 1,
    i = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: n,
        radius: r,
        radialSegments: i,
        closed: s,
      });
    const o = e.computeFrenetFrames(n, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new z(),
      l = new z(),
      f = new _e();
    let d = new z();
    const h = [],
      p = [],
      g = [],
      v = [];
    _(),
      this.setIndex(v),
      this.setAttribute("position", new tt(h, 3)),
      this.setAttribute("normal", new tt(p, 3)),
      this.setAttribute("uv", new tt(g, 2));
    function _() {
      for (let S = 0; S < n; S++) x(S);
      x(s === !1 ? n : 0), w(), m();
    }
    function x(S) {
      d = e.getPointAt(S / n, d);
      const E = o.normals[S],
        T = o.binormals[S];
      for (let A = 0; A <= i; A++) {
        const L = (A / i) * Math.PI * 2,
          N = Math.sin(L),
          C = -Math.cos(L);
        (l.x = C * E.x + N * T.x),
          (l.y = C * E.y + N * T.y),
          (l.z = C * E.z + N * T.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = d.x + r * l.x),
          (a.y = d.y + r * l.y),
          (a.z = d.z + r * l.z),
          h.push(a.x, a.y, a.z);
      }
    }
    function m() {
      for (let S = 1; S <= n; S++)
        for (let E = 1; E <= i; E++) {
          const T = (i + 1) * (S - 1) + (E - 1),
            A = (i + 1) * S + (E - 1),
            L = (i + 1) * S + E,
            N = (i + 1) * (S - 1) + E;
          v.push(T, A, N), v.push(A, L, N);
        }
    }
    function w() {
      for (let S = 0; S <= n; S++)
        for (let E = 0; E <= i; E++)
          (f.x = S / n), (f.y = E / i), g.push(f.x, f.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new sv(
      new Bg[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class M3 extends bt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const n = [],
        r = new Set(),
        i = new z(),
        s = new z();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let f = 0, d = l.length; f < d; ++f) {
          const h = l[f],
            p = h.start,
            g = h.count;
          for (let v = p, _ = p + g; v < _; v += 3)
            for (let x = 0; x < 3; x++) {
              const m = a.getX(v + x),
                w = a.getX(v + ((x + 1) % 3));
              i.fromBufferAttribute(o, m),
                s.fromBufferAttribute(o, w),
                _C(i, s, r) === !0 &&
                  (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let f = 0; f < 3; f++) {
            const d = 3 * a + f,
              h = 3 * a + ((f + 1) % 3);
            i.fromBufferAttribute(o, d),
              s.fromBufferAttribute(o, h),
              _C(i, s, r) === !0 &&
                (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new tt(n, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function _C(t, e, n) {
  const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
  return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0);
}
var SC = Object.freeze({
  __proto__: null,
  BoxGeometry: Ul,
  CapsuleGeometry: X0,
  CircleGeometry: Y0,
  ConeGeometry: q0,
  CylinderGeometry: Oc,
  DodecahedronGeometry: K0,
  EdgesGeometry: x3,
  ExtrudeGeometry: J0,
  IcosahedronGeometry: Q0,
  LatheGeometry: ch,
  OctahedronGeometry: fh,
  PlaneGeometry: uh,
  PolyhedronGeometry: Aa,
  RingGeometry: ev,
  ShapeGeometry: tv,
  SphereGeometry: dh,
  TetrahedronGeometry: nv,
  TorusGeometry: rv,
  TorusKnotGeometry: iv,
  TubeGeometry: sv,
  WireframeGeometry: M3,
});
class E3 extends Nr {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new qe(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class b3 extends Bs {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class _M extends Nr {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new qe(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class T3 extends _M {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new _e(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Mn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (n) {
          this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new qe(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new qe(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new qe(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class A3 extends Nr {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new qe(16777215)),
      (this.specular = new qe(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = rh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class C3 extends Nr {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class R3 extends Nr {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class P3 extends Nr {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new qe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = rh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class L3 extends Nr {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new qe(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new _e(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class I3 extends jr {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function hl(t, e, n) {
  return !t || (!n && t.constructor === e)
    ? t
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(t)
    : Array.prototype.slice.call(t);
}
function N3(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function O3(t) {
  function e(i, s) {
    return t[i] - t[s];
  }
  const n = t.length,
    r = new Array(n);
  for (let i = 0; i !== n; ++i) r[i] = i;
  return r.sort(e), r;
}
function c1(t, e, n) {
  const r = t.length,
    i = new t.constructor(r);
  for (let s = 0, o = 0; o !== r; ++s) {
    const a = n[s] * e;
    for (let l = 0; l !== e; ++l) i[o++] = t[a + l];
  }
  return i;
}
function SM(t, e, n, r) {
  let i = 1,
    s = t[0];
  for (; s !== void 0 && s[r] === void 0; ) s = t[i++];
  if (s === void 0) return;
  let o = s[r];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), n.push.apply(n, o)),
          (s = t[i++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), o.toArray(n, n.length)),
          (s = t[i++]);
      while (s !== void 0);
    else
      do (o = s[r]), o !== void 0 && (e.push(s.time), n.push(o)), (s = t[i++]);
      while (s !== void 0);
}
function M6(t, e, n, r, i = 30) {
  const s = t.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const f = s.tracks[l],
      d = f.getValueSize(),
      h = [],
      p = [];
    for (let g = 0; g < f.times.length; ++g) {
      const v = f.times[g] * i;
      if (!(v < n || v >= r)) {
        h.push(f.times[g]);
        for (let _ = 0; _ < d; ++_) p.push(f.values[g * d + _]);
      }
    }
    h.length !== 0 &&
      ((f.times = hl(h, f.times.constructor)),
      (f.values = hl(p, f.values.constructor)),
      o.push(f));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function E6(t, e = 0, n = t, r = 30) {
  r <= 0 && (r = 30);
  const i = n.tracks.length,
    s = e / r;
  for (let o = 0; o < i; ++o) {
    const a = n.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const f = t.tracks.find(function (m) {
      return m.name === a.name && m.ValueTypeName === l;
    });
    if (f === void 0) continue;
    let d = 0;
    const h = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (d = h / 3);
    let p = 0;
    const g = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = g / 3);
    const v = a.times.length - 1;
    let _;
    if (s <= a.times[0]) {
      const m = d,
        w = h - d;
      _ = a.values.slice(m, w);
    } else if (s >= a.times[v]) {
      const m = v * h + d,
        w = m + h - d;
      _ = a.values.slice(m, w);
    } else {
      const m = a.createInterpolant(),
        w = d,
        S = h - d;
      m.evaluate(s), (_ = m.resultBuffer.slice(w, S));
    }
    l === "quaternion" &&
      new Rr().fromArray(_).normalize().conjugate().toArray(_);
    const x = f.times.length;
    for (let m = 0; m < x; ++m) {
      const w = m * g + p;
      if (l === "quaternion")
        Rr.multiplyQuaternionsFlat(f.values, w, _, 0, f.values, w);
      else {
        const S = g - p * 2;
        for (let E = 0; E < S; ++E) f.values[w + E] -= _[E];
      }
    }
  }
  return (t.blendMode = Zw), t;
}
const b6 = {
  convertArray: hl,
  isTypedArray: N3,
  getKeyframeOrder: O3,
  sortedArray: c1,
  flattenJSON: SM,
  subclip: M6,
  makeClipAdditive: E6,
};
class hh {
  constructor(e, n, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new n.constructor(r)),
      (this.sampleValues = n),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const n = this.parameterPositions;
    let r = this._cachedIndex,
      i = n[r],
      s = n[r - 1];
    e: {
      t: {
        let o;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < s) break r;
                return (
                  (r = n.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((s = i), (i = n[++r]), e < i)) break t;
            }
            o = n.length;
            break n;
          }
          if (!(e >= s)) {
            const a = n[1];
            e < a && ((r = 2), (s = a));
            for (let l = r - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = s), (s = n[--r - 1]), e >= s)) break t;
            }
            (o = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < o; ) {
          const a = (r + o) >>> 1;
          e < n[a] ? (o = a) : (r = a + 1);
        }
        if (((i = n[r]), (s = n[r - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = n.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, s, i);
    }
    return this.interpolate_(r, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const n = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let o = 0; o !== i; ++o) n[o] = r[s + o];
    return n;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class D3 extends hh {
  constructor(e, n, r, i) {
    super(e, n, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: cl, endingEnd: cl });
  }
  intervalChanged_(e, n, r) {
    const i = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = i[s],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case fl:
          (s = e), (a = 2 * n - r);
          break;
        case Od:
          (s = i.length - 2), (a = n + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (a = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case fl:
          (o = e), (l = 2 * r - n);
          break;
        case Od:
          (o = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = n);
      }
    const f = (r - n) * 0.5,
      d = this.valueSize;
    (this._weightPrev = f / (n - a)),
      (this._weightNext = f / (l - r)),
      (this._offsetPrev = s * d),
      (this._offsetNext = o * d);
  }
  interpolate_(e, n, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      f = l - a,
      d = this._offsetPrev,
      h = this._offsetNext,
      p = this._weightPrev,
      g = this._weightNext,
      v = (r - n) / (i - n),
      _ = v * v,
      x = _ * v,
      m = -p * x + 2 * p * _ - p * v,
      w = (1 + p) * x + (-1.5 - 2 * p) * _ + (-0.5 + p) * v + 1,
      S = (-1 - g) * x + (1.5 + g) * _ + 0.5 * v,
      E = g * x - g * _;
    for (let T = 0; T !== a; ++T)
      s[T] = m * o[d + T] + w * o[f + T] + S * o[l + T] + E * o[h + T];
    return s;
  }
}
class wM extends hh {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      f = l - a,
      d = (r - n) / (i - n),
      h = 1 - d;
    for (let p = 0; p !== a; ++p) s[p] = o[f + p] * h + o[l + p] * d;
    return s;
  }
}
class k3 extends hh {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class hs {
  constructor(e, n, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = hl(n, this.TimeBufferType)),
      (this.values = hl(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const n = e.constructor;
    let r;
    if (n.toJSON !== this.toJSON) r = n.toJSON(e);
    else {
      r = {
        name: e.name,
        times: hl(e.times, Array),
        values: hl(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new k3(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new wM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new D3(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let n;
    switch (e) {
      case Id:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Nd:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case Jm:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = n), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Id;
      case this.InterpolantFactoryMethodLinear:
        return Nd;
      case this.InterpolantFactoryMethodSmooth:
        return Jm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] *= e;
    }
    return this;
  }
  trim(e, n) {
    const r = this.times,
      i = r.length;
    let s = 0,
      o = i - 1;
    for (; s !== i && r[s] < e; ) ++s;
    for (; o !== -1 && r[o] > n; ) --o;
    if ((++o, s !== 0 || o !== i)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = r.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      s = r.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = r[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && N3(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const f = i[a];
        if (isNaN(f)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            f
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === Jm,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const f = e[a],
        d = e[a + 1];
      if (f !== d && (a !== 1 || f !== e[0]))
        if (i) l = !0;
        else {
          const h = a * r,
            p = h - r,
            g = h + r;
          for (let v = 0; v !== r; ++v) {
            const _ = n[h + v];
            if (_ !== n[p + v] || _ !== n[g + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const h = a * r,
            p = o * r;
          for (let g = 0; g !== r; ++g) n[p + g] = n[h + g];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * r, l = o * r, f = 0; f !== r; ++f) n[l + f] = n[a + f];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = n.slice(0, o * r)))
        : ((this.times = e), (this.values = n)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, n);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
hs.prototype.TimeBufferType = Float32Array;
hs.prototype.ValueBufferType = Float32Array;
hs.prototype.DefaultInterpolation = Nd;
class Fl extends hs {}
Fl.prototype.ValueTypeName = "bool";
Fl.prototype.ValueBufferType = Array;
Fl.prototype.DefaultInterpolation = Id;
Fl.prototype.InterpolantFactoryMethodLinear = void 0;
Fl.prototype.InterpolantFactoryMethodSmooth = void 0;
class MM extends hs {}
MM.prototype.ValueTypeName = "color";
class Gd extends hs {}
Gd.prototype.ValueTypeName = "number";
class U3 extends hh {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (r - n) / (i - n);
    let f = e * a;
    for (let d = f + a; f !== d; f += 4) Rr.slerpFlat(s, 0, o, f - a, o, f, l);
    return s;
  }
}
class Dc extends hs {
  InterpolantFactoryMethodLinear(e) {
    return new U3(this.times, this.values, this.getValueSize(), e);
  }
}
Dc.prototype.ValueTypeName = "quaternion";
Dc.prototype.DefaultInterpolation = Nd;
Dc.prototype.InterpolantFactoryMethodSmooth = void 0;
class zl extends hs {}
zl.prototype.ValueTypeName = "string";
zl.prototype.ValueBufferType = Array;
zl.prototype.DefaultInterpolation = Id;
zl.prototype.InterpolantFactoryMethodLinear = void 0;
zl.prototype.InterpolantFactoryMethodSmooth = void 0;
class jd extends hs {}
jd.prototype.ValueTypeName = "vector";
class $d {
  constructor(e, n = -1, r, i = U0) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = n),
      (this.blendMode = i),
      (this.uuid = vi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const n = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = r.length; o !== a; ++o) n.push(A6(r[o]).scale(i));
    const s = new this(e.name, e.duration, n, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const n = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: n,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = r.length; s !== o; ++s) n.push(hs.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, n, r, i) {
    const s = n.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        f = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
      const d = O3(l);
      (l = c1(l, 1, d)),
        (f = c1(f, 1, d)),
        !i && l[0] === 0 && (l.push(s), f.push(f[0])),
        o.push(
          new Gd(".morphTargetInfluences[" + n[a].name + "]", l, f).scale(1 / r)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, n) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === n) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, n, r) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const f = e[a],
        d = f.name.match(s);
      if (d && d.length > 1) {
        const h = d[1];
        let p = i[h];
        p || (i[h] = p = []), p.push(f);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], n, r));
    return o;
  }
  static parseAnimation(e, n) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (h, p, g, v, _) {
        if (g.length !== 0) {
          const x = [],
            m = [];
          SM(g, x, m, v), x.length !== 0 && _.push(new h(p, x, m));
        }
      },
      i = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const f = e.hierarchy || [];
    for (let h = 0; h < f.length; h++) {
      const p = f[h].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const g = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let _ = 0; _ < p[v].morphTargets.length; _++)
                g[p[v].morphTargets[_]] = -1;
          for (const _ in g) {
            const x = [],
              m = [];
            for (let w = 0; w !== p[v].morphTargets.length; ++w) {
              const S = p[v];
              x.push(S.time), m.push(S.morphTarget === _ ? 1 : 0);
            }
            i.push(new Gd(".morphTargetInfluence[" + _ + "]", x, m));
          }
          l = g.length * o;
        } else {
          const g = ".bones[" + n[h].name + "]";
          r(jd, g + ".position", p, "pos", i),
            r(Dc, g + ".quaternion", p, "rot", i),
            r(jd, g + ".scale", p, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const s = this.tracks[r];
      n = Math.max(n, s.times[s.times.length - 1]);
    }
    return (this.duration = n), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function T6(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Gd;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return jd;
    case "color":
      return MM;
    case "quaternion":
      return Dc;
    case "bool":
    case "boolean":
      return Fl;
    case "string":
      return zl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function A6(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = T6(t.type);
  if (t.times === void 0) {
    const n = [],
      r = [];
    SM(t.keys, n, r, "value"), (t.times = n), (t.values = r);
  }
  return e.parse !== void 0
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
const Il = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
class EM {
  constructor(e, n, r) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const f = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = n),
      (this.onError = r),
      (this.itemStart = function (d) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(d, o, a), (s = !0);
      }),
      (this.itemEnd = function (d) {
        o++,
          i.onProgress !== void 0 && i.onProgress(d, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (d) {
        i.onError !== void 0 && i.onError(d);
      }),
      (this.resolveURL = function (d) {
        return l ? l(d) : d;
      }),
      (this.setURLModifier = function (d) {
        return (l = d), this;
      }),
      (this.addHandler = function (d, h) {
        return f.push(d, h), this;
      }),
      (this.removeHandler = function (d) {
        const h = f.indexOf(d);
        return h !== -1 && f.splice(h, 2), this;
      }),
      (this.getHandler = function (d) {
        for (let h = 0, p = f.length; h < p; h += 2) {
          const g = f[h],
            v = f[h + 1];
          if ((g.global && (g.lastIndex = 0), g.test(d))) return v;
        }
        return null;
      });
  }
}
const F3 = new EM();
class ii {
  constructor(e) {
    (this.manager = e !== void 0 ? e : F3),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, n) {
    const r = this;
    return new Promise(function (i, s) {
      r.load(e, i, n, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
ii.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const to = {};
class C6 extends Error {
  constructor(e, n) {
    super(e), (this.response = n);
  }
}
class wo extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Il.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          n && n(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (to[e] !== void 0) {
      to[e].push({ onLoad: n, onProgress: r, onError: i });
      return;
    }
    (to[e] = []), to[e].push({ onLoad: n, onProgress: r, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((f) => {
        if (f.status === 200 || f.status === 0) {
          if (
            (f.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              f.body === void 0 ||
              f.body.getReader === void 0)
          )
            return f;
          const d = to[e],
            h = f.body.getReader(),
            p = f.headers.get("Content-Length") || f.headers.get("X-File-Size"),
            g = p ? parseInt(p) : 0,
            v = g !== 0;
          let _ = 0;
          const x = new ReadableStream({
            start(m) {
              w();
              function w() {
                h.read().then(({ done: S, value: E }) => {
                  if (S) m.close();
                  else {
                    _ += E.byteLength;
                    const T = new ProgressEvent("progress", {
                      lengthComputable: v,
                      loaded: _,
                      total: g,
                    });
                    for (let A = 0, L = d.length; A < L; A++) {
                      const N = d[A];
                      N.onProgress && N.onProgress(T);
                    }
                    m.enqueue(E), w();
                  }
                });
              }
            },
          });
          return new Response(x);
        } else
          throw new C6(
            `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
            f
          );
      })
      .then((f) => {
        switch (l) {
          case "arraybuffer":
            return f.arrayBuffer();
          case "blob":
            return f.blob();
          case "document":
            return f.text().then((d) => new DOMParser().parseFromString(d, a));
          case "json":
            return f.json();
          default:
            if (a === void 0) return f.text();
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(a),
                p = h && h[1] ? h[1].toLowerCase() : void 0,
                g = new TextDecoder(p);
              return f.arrayBuffer().then((v) => g.decode(v));
            }
        }
      })
      .then((f) => {
        Il.add(e, f);
        const d = to[e];
        delete to[e];
        for (let h = 0, p = d.length; h < p; h++) {
          const g = d[h];
          g.onLoad && g.onLoad(f);
        }
      })
      .catch((f) => {
        const d = to[e];
        if (d === void 0) throw (this.manager.itemError(e), f);
        delete to[e];
        for (let h = 0, p = d.length; h < p; h++) {
          const g = d[h];
          g.onError && g.onError(f);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class R6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = new wo(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            n(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = $d.parse(e[r]);
      n.push(i);
    }
    return n;
  }
}
class P6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = [],
      a = new j0(),
      l = new wo(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let f = 0;
    function d(h) {
      l.load(
        e[h],
        function (p) {
          const g = s.parse(p, !0);
          (o[h] = {
            width: g.width,
            height: g.height,
            format: g.format,
            mipmaps: g.mipmaps,
          }),
            (f += 1),
            f === 6 &&
              (g.mipmapCount === 1 && (a.minFilter = Rn),
              (a.image = o),
              (a.format = g.format),
              (a.needsUpdate = !0),
              n && n(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let h = 0, p = e.length; h < p; ++h) d(h);
    else
      l.load(
        e,
        function (h) {
          const p = s.parse(h, !0);
          if (p.isCubemap) {
            const g = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < g; v++) {
              o[v] = { mipmaps: [] };
              for (let _ = 0; _ < p.mipmapCount; _++)
                o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + _]),
                  (o[v].format = p.format),
                  (o[v].width = p.width),
                  (o[v].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = Rn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            n && n(a);
        },
        r,
        i
      );
    return a;
  }
}
class Xd extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Il.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          n && n(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = zd("img");
    function l() {
      d(), Il.add(e, this), n && n(this), s.manager.itemEnd(e);
    }
    function f(h) {
      d(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function d() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", f, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", f, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class L6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = new ah();
    s.colorSpace = Wn;
    const o = new Xd(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(f) {
      o.load(
        e[f],
        function (d) {
          (s.images[f] = d), a++, a === 6 && ((s.needsUpdate = !0), n && n(s));
        },
        void 0,
        i
      );
    }
    for (let f = 0; f < e.length; ++f) l(f);
    return s;
  }
}
class I6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = new Sl(),
      a = new wo(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let f;
          try {
            f = s.parse(l);
          } catch (d) {
            if (i !== void 0) i(d);
            else {
              console.error(d);
              return;
            }
          }
          f.image !== void 0
            ? (o.image = f.image)
            : f.data !== void 0 &&
              ((o.image.width = f.width),
              (o.image.height = f.height),
              (o.image.data = f.data)),
            (o.wrapS = f.wrapS !== void 0 ? f.wrapS : Cr),
            (o.wrapT = f.wrapT !== void 0 ? f.wrapT : Cr),
            (o.magFilter = f.magFilter !== void 0 ? f.magFilter : Rn),
            (o.minFilter = f.minFilter !== void 0 ? f.minFilter : Rn),
            (o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1),
            f.colorSpace !== void 0
              ? (o.colorSpace = f.colorSpace)
              : f.encoding !== void 0 && (o.encoding = f.encoding),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 &&
              ((o.mipmaps = f.mipmaps), (o.minFilter = xa)),
            f.mipmapCount === 1 && (o.minFilter = Rn),
            f.generateMipmaps !== void 0 &&
              (o.generateMipmaps = f.generateMipmaps),
            (o.needsUpdate = !0),
            n && n(o, f);
        },
        r,
        i
      ),
      o
    );
  }
}
class z3 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = new Ln(),
      o = new Xd(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), n !== void 0 && n(s);
        },
        r,
        i
      ),
      s
    );
  }
}
class Ca extends Ft {
  constructor(e, n = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new qe(e)),
      (this.intensity = n);
  }
  dispose() {}
  copy(e, n) {
    return (
      super.copy(e, n),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.color = this.color.getHex()),
      (n.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (n.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (n.object.distance = this.distance),
      this.angle !== void 0 && (n.object.angle = this.angle),
      this.decay !== void 0 && (n.object.decay = this.decay),
      this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
      n
    );
  }
}
class B3 extends Ca {
  constructor(e, n, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new qe(n));
  }
  copy(e, n) {
    return super.copy(e, n), this.groundColor.copy(e.groundColor), this;
  }
}
const n_ = new ht(),
  wC = new z(),
  MC = new z();
class bM {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new _e(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ht()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new lh()),
      (this._frameExtents = new _e(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Gt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera,
      r = this.matrix;
    wC.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(wC),
      MC.setFromMatrixPosition(e.target.matrixWorld),
      n.lookAt(MC),
      n.updateMatrixWorld(),
      n_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(n_),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(n_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class N6 extends bM {
  constructor() {
    super(new Pn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const n = this.camera,
      r = Sc * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || n.far;
    (r !== n.fov || i !== n.aspect || s !== n.far) &&
      ((n.fov = r), (n.aspect = i), (n.far = s), n.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class H3 extends Ca {
  constructor(e, n, r = 0, i = Math.PI / 3, s = 0, o = 2) {
    super(e, n),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new N6());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const EC = new ht(),
  bf = new z(),
  r_ = new z();
class O6 extends bM {
  constructor() {
    super(new Pn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new _e(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Gt(2, 1, 1, 1),
        new Gt(0, 1, 1, 1),
        new Gt(3, 1, 1, 1),
        new Gt(1, 1, 1, 1),
        new Gt(3, 0, 1, 1),
        new Gt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new z(1, 0, 0),
        new z(-1, 0, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
        new z(0, 1, 0),
        new z(0, -1, 0),
      ]),
      (this._cubeUps = [
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
      ]);
  }
  updateMatrices(e, n = 0) {
    const r = this.camera,
      i = this.matrix,
      s = e.distance || r.far;
    s !== r.far && ((r.far = s), r.updateProjectionMatrix()),
      bf.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(bf),
      r_.copy(r.position),
      r_.add(this._cubeDirections[n]),
      r.up.copy(this._cubeUps[n]),
      r.lookAt(r_),
      r.updateMatrixWorld(),
      i.makeTranslation(-bf.x, -bf.y, -bf.z),
      EC.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(EC);
  }
}
class V3 extends Ca {
  constructor(e, n, r = 0, i = 2) {
    super(e, n),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new O6());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class D6 extends bM {
  constructor() {
    super(new da(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class W3 extends Ca {
  constructor(e, n) {
    super(e, n),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.shadow = new D6());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class G3 extends Ca {
  constructor(e, n) {
    super(e, n), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class j3 extends Ca {
  constructor(e, n, r = 10, i = 10) {
    super(e, n),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.width = this.width), (n.object.height = this.height), n;
  }
}
class $3 {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new z());
  }
  set(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, n) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      n.copy(o[0]).multiplyScalar(0.282095),
      n.addScaledVector(o[1], 0.488603 * i),
      n.addScaledVector(o[2], 0.488603 * s),
      n.addScaledVector(o[3], 0.488603 * r),
      n.addScaledVector(o[4], 1.092548 * (r * i)),
      n.addScaledVector(o[5], 1.092548 * (i * s)),
      n.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      n.addScaledVector(o[7], 1.092548 * (r * s)),
      n.addScaledVector(o[8], 0.546274 * (r * r - i * i)),
      n
    );
  }
  getIrradianceAt(e, n) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      n.copy(o[0]).multiplyScalar(0.886227),
      n.addScaledVector(o[1], 2 * 0.511664 * i),
      n.addScaledVector(o[2], 2 * 0.511664 * s),
      n.addScaledVector(o[3], 2 * 0.511664 * r),
      n.addScaledVector(o[4], 2 * 0.429043 * r * i),
      n.addScaledVector(o[5], 2 * 0.429043 * i * s),
      n.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      n.addScaledVector(o[7], 2 * 0.429043 * r * s),
      n.addScaledVector(o[8], 0.429043 * (r * r - i * i)),
      n
    );
  }
  add(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  addScaledSH(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], n);
    return this;
  }
  scale(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
    return this;
  }
  lerp(e, n) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
    return this;
  }
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, n + i * 3);
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, n + i * 3);
    return e;
  }
  static getBasisAt(e, n) {
    const r = e.x,
      i = e.y,
      s = e.z;
    (n[0] = 0.282095),
      (n[1] = 0.488603 * i),
      (n[2] = 0.488603 * s),
      (n[3] = 0.488603 * r),
      (n[4] = 1.092548 * r * i),
      (n[5] = 1.092548 * i * s),
      (n[6] = 0.315392 * (3 * s * s - 1)),
      (n[7] = 1.092548 * r * s),
      (n[8] = 0.546274 * (r * r - i * i));
  }
}
class X3 extends Ca {
  constructor(e = new $3(), n = 1) {
    super(void 0, n), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.sh = this.sh.toArray()), n;
  }
}
class ov extends ii {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, n, r, i) {
    const s = this,
      o = new wo(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            n(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = this.textures;
    function r(s) {
      return (
        n[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        n[s]
      );
    }
    const i = ov.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new qe().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((i.uniforms[s] = {}), o.type)) {
          case "t":
            i.uniforms[s].value = r(o.value);
            break;
          case "c":
            i.uniforms[s].value = new qe().setHex(o.value);
            break;
          case "v2":
            i.uniforms[s].value = new _e().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[s].value = new z().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[s].value = new Gt().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[s].value = new Et().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[s].value = new ht().fromArray(o.value);
            break;
          default:
            i.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new _e().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new _e().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const n = {
      ShadowMaterial: E3,
      SpriteMaterial: fM,
      RawShaderMaterial: b3,
      ShaderMaterial: Bs,
      PointsMaterial: hM,
      MeshPhysicalMaterial: T3,
      MeshStandardMaterial: _M,
      MeshPhongMaterial: A3,
      MeshToonMaterial: C3,
      MeshNormalMaterial: R3,
      MeshLambertMaterial: P3,
      MeshDepthMaterial: aM,
      MeshDistanceMaterial: lM,
      MeshBasicMaterial: Ta,
      MeshMatcapMaterial: L3,
      LineDashedMaterial: I3,
      LineBasicMaterial: jr,
      Material: Nr,
    };
    return new n[e]();
  }
}
class f1 {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let n = "";
    for (let r = 0, i = e.length; r < i; r++) n += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(n));
    } catch {
      return n;
    }
  }
  static extractUrlBase(e) {
    const n = e.lastIndexOf("/");
    return n === -1 ? "./" : e.slice(0, n + 1);
  }
  static resolveURL(e, n) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(n) &&
          /^\//.test(e) &&
          (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : n + e);
  }
}
class Y3 extends bt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class q3 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = new wo(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            n(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = {},
      r = {};
    function i(g, v) {
      if (n[v] !== void 0) return n[v];
      const x = g.interleavedBuffers[v],
        m = s(g, x.buffer),
        w = Yu(x.type, m),
        S = new W0(w, x.stride);
      return (S.uuid = x.uuid), (n[v] = S), S;
    }
    function s(g, v) {
      if (r[v] !== void 0) return r[v];
      const x = g.arrayBuffers[v],
        m = new Uint32Array(x).buffer;
      return (r[v] = m), m;
    }
    const o = e.isInstancedBufferGeometry ? new Y3() : new bt(),
      a = e.data.index;
    if (a !== void 0) {
      const g = Yu(a.type, a.array);
      o.setIndex(new $t(g, 1));
    }
    const l = e.data.attributes;
    for (const g in l) {
      const v = l[g];
      let _;
      if (v.isInterleavedBufferAttribute) {
        const x = i(e.data, v.data);
        _ = new Pl(x, v.itemSize, v.offset, v.normalized);
      } else {
        const x = Yu(v.type, v.array),
          m = v.isInstancedBufferAttribute ? Mc : $t;
        _ = new m(x, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (_.name = v.name),
        v.usage !== void 0 && _.setUsage(v.usage),
        o.setAttribute(g, _);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const g in f) {
        const v = f[g],
          _ = [];
        for (let x = 0, m = v.length; x < m; x++) {
          const w = v[x];
          let S;
          if (w.isInterleavedBufferAttribute) {
            const E = i(e.data, w.data);
            S = new Pl(E, w.itemSize, w.offset, w.normalized);
          } else {
            const E = Yu(w.type, w.array);
            S = new $t(E, w.itemSize, w.normalized);
          }
          w.name !== void 0 && (S.name = w.name), _.push(S);
        }
        o.morphAttributes[g] = _;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let g = 0, v = h.length; g !== v; ++g) {
        const _ = h[g];
        o.addGroup(_.start, _.count, _.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const g = new z();
      p.center !== void 0 && g.fromArray(p.center),
        (o.boundingSphere = new Pr(g, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class k6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = this.path === "" ? f1.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new wo(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let f = null;
          try {
            f = JSON.parse(l);
          } catch (h) {
            i !== void 0 && i(h),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                h.message
              );
            return;
          }
          const d = f.metadata;
          if (
            d === void 0 ||
            d.type === void 0 ||
            d.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(f, n);
        },
        r,
        i
      );
  }
  async loadAsync(e, n) {
    const r = this,
      i = this.path === "" ? f1.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new wo(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, n),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, n) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      o = this.parseImages(e.images, function () {
        n !== void 0 && n(f);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      f = this.parseObject(e.object, s, l, a, r),
      d = this.parseSkeletons(e.skeletons, f);
    if ((this.bindSkeletons(f, d), n !== void 0)) {
      let h = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && n(f);
    }
    return f;
  }
  async parseAsync(e) {
    const n = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, i, a, o, n),
      f = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, f), l;
  }
  parseShapes(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const s = new wl().fromJSON(e[r]);
        n[s.uuid] = s;
      }
    return n;
  }
  parseSkeletons(e, n) {
    const r = {},
      i = {};
    if (
      (n.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new G0().fromJSON(e[s], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, n) {
    const r = {};
    if (e !== void 0) {
      const i = new q3();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in SC
              ? (a = SC[l.type].fromJSON(l, n))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (r[l.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, n) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const s = new ov();
      s.setTextures(n);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          s = $d.parse(i);
        n[s.uuid] = s;
      }
    return n;
  }
  parseImages(e, n) {
    const r = this,
      i = {};
    let s;
    function o(l) {
      return (
        r.manager.itemStart(l),
        s.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const f = l,
          d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : r.resourcePath + f;
        return o(d);
      } else
        return l.data
          ? { data: Yu(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new EM(n);
      (s = new Xd(l)), s.setCrossOrigin(this.crossOrigin);
      for (let f = 0, d = e.length; f < d; f++) {
        const h = e[f],
          p = h.url;
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const x = p[v],
              m = a(x);
            m !== null &&
              (m instanceof HTMLImageElement
                ? g.push(m)
                : g.push(new Sl(m.data, m.width, m.height)));
          }
          i[h.uuid] = new dl(g);
        } else {
          const g = a(h.url);
          i[h.uuid] = new dl(g);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const n = this,
      r = {};
    let i;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : n.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return o.data
          ? { data: Yu(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Xd(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          f = l.url;
        if (Array.isArray(f)) {
          const d = [];
          for (let h = 0, p = f.length; h < p; h++) {
            const g = f[h],
              v = await s(g);
            v !== null &&
              (v instanceof HTMLImageElement
                ? d.push(v)
                : d.push(new Sl(v.data, v.width, v.height)));
          }
          r[l.uuid] = new dl(d);
        } else {
          const d = await s(l.url);
          r[l.uuid] = new dl(d);
        }
      }
    }
    return r;
  }
  parseTextures(e, n) {
    function r(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          n[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = n[a.image],
          f = l.data;
        let d;
        Array.isArray(f)
          ? ((d = new ah()), f.length === 6 && (d.needsUpdate = !0))
          : (f && f.data ? (d = new Sl()) : (d = new Ln()),
            f && (d.needsUpdate = !0)),
          (d.source = l),
          (d.uuid = a.uuid),
          a.name !== void 0 && (d.name = a.name),
          a.mapping !== void 0 && (d.mapping = r(a.mapping, U6)),
          a.channel !== void 0 && (d.channel = a.channel),
          a.offset !== void 0 && d.offset.fromArray(a.offset),
          a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
          a.center !== void 0 && d.center.fromArray(a.center),
          a.rotation !== void 0 && (d.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((d.wrapS = r(a.wrap[0], bC)), (d.wrapT = r(a.wrap[1], bC))),
          a.format !== void 0 && (d.format = a.format),
          a.internalFormat !== void 0 && (d.internalFormat = a.internalFormat),
          a.type !== void 0 && (d.type = a.type),
          a.colorSpace !== void 0 && (d.colorSpace = a.colorSpace),
          a.encoding !== void 0 && (d.encoding = a.encoding),
          a.minFilter !== void 0 && (d.minFilter = r(a.minFilter, TC)),
          a.magFilter !== void 0 && (d.magFilter = r(a.magFilter, TC)),
          a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (d.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (d.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (d.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (d.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (d.compareFunction = a.compareFunction),
          a.userData !== void 0 && (d.userData = a.userData),
          (i[a.uuid] = d);
      }
    return i;
  }
  parseObject(e, n, r, i, s) {
    let o;
    function a(p) {
      return (
        n[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        n[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const x = p[v];
            r[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              g.push(r[x]);
          }
          return g;
        }
        return (
          r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          r[p]
        );
      }
    }
    function f(p) {
      return (
        i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        i[p]
      );
    }
    let d, h;
    switch (e.type) {
      case "Scene":
        (o = new cM()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new qe(e.background))
              : (o.background = f(e.background))),
          e.environment !== void 0 && (o.environment = f(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new V0(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new H0(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new Pn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new da(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new G3(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new W3(e.color, e.intensity);
        break;
      case "PointLight":
        o = new V3(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new j3(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new H3(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new B3(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new X3().fromJSON(e);
        break;
      case "SkinnedMesh":
        (d = a(e.geometry)),
          (h = l(e.material)),
          (o = new u3(d, h)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (d = a(e.geometry)), (h = l(e.material)), (o = new jn(d, h));
        break;
      case "InstancedMesh":
        (d = a(e.geometry)), (h = l(e.material));
        const p = e.count,
          g = e.instanceMatrix,
          v = e.instanceColor;
        (o = new c3(d, h, p)),
          (o.instanceMatrix = new Mc(new Float32Array(g.array), 16)),
          v !== void 0 &&
            (o.instanceColor = new Mc(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        (d = a(e.geometry)),
          (h = l(e.material)),
          (o = new f3(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            h
          )),
          (o.geometry = d),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((_) => {
            const x = new Vr();
            x.min.fromArray(_.boxMin), x.max.fromArray(_.boxMax);
            const m = new Pr();
            return (
              (m.radius = _.sphereRadius),
              m.center.fromArray(_.sphereCenter),
              {
                boxInitialized: _.boxInitialized,
                box: x,
                sphereInitialized: _.sphereInitialized,
                sphere: m,
              }
            );
          })),
          (o._maxGeometryCount = e.maxGeometryCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = f(e.matricesTexture.uuid));
        break;
      case "LOD":
        o = new l3();
        break;
      case "Line":
        o = new _a(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new d3(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new Hs(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new h3(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new a3(l(e.material));
        break;
      case "Group":
        o = new Ku();
        break;
      case "Bone":
        o = new dM();
        break;
      default:
        o = new Ft();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let g = 0; g < p.length; g++)
        o.add(this.parseObject(p[g], n, r, i, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let g = 0; g < p.length; g++) {
        const v = p[g];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let g = 0; g < p.length; g++) {
        const v = p[g],
          _ = o.getObjectByProperty("uuid", v.object);
        _ !== void 0 && o.addLevel(_, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, n) {
    Object.keys(n).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = n[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
}
const U6 = {
    UVMapping: D0,
    CubeReflectionMapping: So,
    CubeRefractionMapping: ya,
    EquirectangularReflectionMapping: Cd,
    EquirectangularRefractionMapping: Rd,
    CubeUVReflectionMapping: Ic,
  },
  bC = {
    RepeatWrapping: Pd,
    ClampToEdgeWrapping: Cr,
    MirroredRepeatWrapping: Ld,
  },
  TC = {
    NearestFilter: An,
    NearestMipmapNearestFilter: Ug,
    NearestMipmapLinearFilter: Qf,
    LinearFilter: Rn,
    LinearMipmapNearestFilter: Ww,
    LinearMipmapLinearFilter: xa,
  };
class F6 extends ii {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Il.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          n && n(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          Il.add(e, l), n && n(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
let _m;
class TM {
  static getContext() {
    return (
      _m === void 0 &&
        (_m = new (window.AudioContext || window.webkitAudioContext)()),
      _m
    );
  }
  static setContext(e) {
    _m = e;
  }
}
class z6 extends ii {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const s = this,
      o = new wo(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const f = l.slice(0);
            TM.getContext()
              .decodeAudioData(f, function (h) {
                n(h);
              })
              .catch(a);
          } catch (f) {
            a(f);
          }
        },
        r,
        i
      );
    function a(l) {
      i ? i(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
const AC = new ht(),
  CC = new ht(),
  Wa = new ht();
class B6 {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Pn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Pn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const n = this._cache;
    if (
      n.focus !== e.focus ||
      n.fov !== e.fov ||
      n.aspect !== e.aspect * this.aspect ||
      n.near !== e.near ||
      n.far !== e.far ||
      n.zoom !== e.zoom ||
      n.eyeSep !== this.eyeSep
    ) {
      (n.focus = e.focus),
        (n.fov = e.fov),
        (n.aspect = e.aspect * this.aspect),
        (n.near = e.near),
        (n.far = e.far),
        (n.zoom = e.zoom),
        (n.eyeSep = this.eyeSep),
        Wa.copy(e.projectionMatrix);
      const i = n.eyeSep / 2,
        s = (i * n.near) / n.focus,
        o = (n.near * Math.tan(xl * n.fov * 0.5)) / n.zoom;
      let a, l;
      (CC.elements[12] = -i),
        (AC.elements[12] = i),
        (a = -o * n.aspect + s),
        (l = o * n.aspect + s),
        (Wa.elements[0] = (2 * n.near) / (l - a)),
        (Wa.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(Wa),
        (a = -o * n.aspect - s),
        (l = o * n.aspect - s),
        (Wa.elements[0] = (2 * n.near) / (l - a)),
        (Wa.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(Wa);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(CC),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(AC);
  }
}
class AM {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = RC()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const n = RC();
      (e = (n - this.oldTime) / 1e3),
        (this.oldTime = n),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function RC() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Ga = new z(),
  PC = new Rr(),
  H6 = new z(),
  ja = new z();
class V6 extends Ft {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = TM.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new AM());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const n = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Ga, PC, H6),
      ja.set(0, 0, -1).applyQuaternion(PC),
      n.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      n.positionX.linearRampToValueAtTime(Ga.x, i),
        n.positionY.linearRampToValueAtTime(Ga.y, i),
        n.positionZ.linearRampToValueAtTime(Ga.z, i),
        n.forwardX.linearRampToValueAtTime(ja.x, i),
        n.forwardY.linearRampToValueAtTime(ja.y, i),
        n.forwardZ.linearRampToValueAtTime(ja.z, i),
        n.upX.linearRampToValueAtTime(r.x, i),
        n.upY.linearRampToValueAtTime(r.y, i),
        n.upZ.linearRampToValueAtTime(r.z, i);
    } else
      n.setPosition(Ga.x, Ga.y, Ga.z),
        n.setOrientation(ja.x, ja.y, ja.z, r.x, r.y, r.z);
  }
}
class K3 extends Ft {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const n = this.context.createBufferSource();
    return (
      (n.buffer = this.buffer),
      (n.loop = this.loop),
      (n.loopStart = this.loopStart),
      (n.loopEnd = this.loopEnd),
      (n.onended = this.onEnded.bind(this)),
      n.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = n),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, n = this.filters.length; e < n; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, n = this.filters.length; e < n; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const $a = new z(),
  LC = new Rr(),
  W6 = new z(),
  Xa = new z();
class G6 extends K3 {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, n, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = n),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose($a, LC, W6), Xa.set(0, 0, 1).applyQuaternion(LC);
    const n = this.panner;
    if (n.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      n.positionX.linearRampToValueAtTime($a.x, r),
        n.positionY.linearRampToValueAtTime($a.y, r),
        n.positionZ.linearRampToValueAtTime($a.z, r),
        n.orientationX.linearRampToValueAtTime(Xa.x, r),
        n.orientationY.linearRampToValueAtTime(Xa.y, r),
        n.orientationZ.linearRampToValueAtTime(Xa.z, r);
    } else n.setPosition($a.x, $a.y, $a.z), n.setOrientation(Xa.x, Xa.y, Xa.z);
  }
}
class j6 {
  constructor(e, n = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = n),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const n = this.getFrequencyData();
    for (let r = 0; r < n.length; r++) e += n[r];
    return e / n.length;
  }
}
class Z3 {
  constructor(e, n, r) {
    (this.binding = e), (this.valueSize = r);
    let i, s, o;
    switch (n) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, n) {
    const r = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a) r[s + a] = r[a];
      o = n;
    } else {
      o += n;
      const a = n / o;
      this._mixBufferRegion(r, s, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const n = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(n, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const n = this.valueSize,
      r = this.buffer,
      i = e * n + n,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = n * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - s, n);
    }
    o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n);
    for (let l = n, f = n + n; l !== f; ++l)
      if (r[l] !== r[l + n]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      n = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(n, i);
    for (let s = r, o = i; s !== o; ++s) n[s] = n[i + (s % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      n = e + this.valueSize;
    for (let r = e; r < n; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      n = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[n + r] = this.buffer[e + r];
  }
  _select(e, n, r, i, s) {
    if (i >= 0.5) for (let o = 0; o !== s; ++o) e[n + o] = e[r + o];
  }
  _slerp(e, n, r, i) {
    Rr.slerpFlat(e, n, e, n, e, r, i);
  }
  _slerpAdditive(e, n, r, i, s) {
    const o = this._workIndex * s;
    Rr.multiplyQuaternionsFlat(e, o, e, n, e, r),
      Rr.slerpFlat(e, n, e, n, e, o, i);
  }
  _lerp(e, n, r, i, s) {
    const o = 1 - i;
    for (let a = 0; a !== s; ++a) {
      const l = n + a;
      e[l] = e[l] * o + e[r + a] * i;
    }
  }
  _lerpAdditive(e, n, r, i, s) {
    for (let o = 0; o !== s; ++o) {
      const a = n + o;
      e[a] = e[a] + e[r + o] * i;
    }
  }
}
const CM = "\\[\\]\\.:\\/",
  $6 = new RegExp("[" + CM + "]", "g"),
  RM = "[^" + CM + "]",
  X6 = "[^" + CM.replace("\\.", "") + "]",
  Y6 = /((?:WC+[\/:])*)/.source.replace("WC", RM),
  q6 = /(WCOD+)?/.source.replace("WCOD", X6),
  K6 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", RM),
  Z6 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", RM),
  J6 = new RegExp("^" + Y6 + q6 + K6 + Z6 + "$"),
  Q6 = ["material", "materials", "bones", "map"];
class eG {
  constructor(e, n, r) {
    const i = r || Nt.parseTrackName(n);
    (this._targetGroup = e), (this._bindings = e.subscribe_(n, i));
  }
  getValue(e, n) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, n);
  }
  setValue(e, n) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
      r[i].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].unbind();
  }
}
class Nt {
  constructor(e, n, r) {
    (this.path = n),
      (this.parsedPath = r || Nt.parseTrackName(n)),
      (this.node = Nt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, n, r) {
    return e && e.isAnimationObjectGroup
      ? new Nt.Composite(e, n, r)
      : new Nt(e, n, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace($6, "");
  }
  static parseTrackName(e) {
    const n = J6.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: n[2],
        objectName: n[3],
        objectIndex: n[4],
        propertyName: n[5],
        propertyIndex: n[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = r.nodeName.substring(i + 1);
      Q6.indexOf(s) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = s));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, n) {
    if (
      n === void 0 ||
      n === "" ||
      n === "." ||
      n === -1 ||
      n === e.name ||
      n === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(n);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === n || a.uuid === n) return a;
            const l = r(a.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) e[n++] = r[i];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  bind() {
    let e = this.node;
    const n = this.parsedPath,
      r = n.objectName,
      i = n.propertyName;
    let s = n.propertyIndex;
    if (
      (e || ((e = Nt.findNode(this.rootNode, n.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let f = n.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let d = 0; d < e.length; d++)
            if (e[d].name === f) {
              f = d;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[f];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const f = n.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          f +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Nt.Composite = eG;
Nt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Nt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Nt.prototype.GetterByBindingType = [
  Nt.prototype._getValue_direct,
  Nt.prototype._getValue_array,
  Nt.prototype._getValue_arrayElement,
  Nt.prototype._getValue_toArray,
];
Nt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Nt.prototype._setValue_direct,
    Nt.prototype._setValue_direct_setNeedsUpdate,
    Nt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_array,
    Nt.prototype._setValue_array_setNeedsUpdate,
    Nt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_arrayElement,
    Nt.prototype._setValue_arrayElement_setNeedsUpdate,
    Nt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_fromArray,
    Nt.prototype._setValue_fromArray_setNeedsUpdate,
    Nt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class tG {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = vi()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return n._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      f = this.nCachedObjects_;
    for (let d = 0, h = arguments.length; d !== h; ++d) {
      const p = arguments[d],
        g = p.uuid;
      let v = n[g];
      if (v === void 0) {
        (v = l++), (n[g] = v), e.push(p);
        for (let _ = 0, x = o; _ !== x; ++_) s[_].push(new Nt(p, r[_], i[_]));
      } else if (v < f) {
        a = e[v];
        const _ = --f,
          x = e[_];
        (n[x.uuid] = v), (e[v] = x), (n[g] = _), (e[_] = p);
        for (let m = 0, w = o; m !== w; ++m) {
          const S = s[m],
            E = S[_];
          let T = S[v];
          (S[v] = E), T === void 0 && (T = new Nt(p, r[m], i[m])), (S[_] = T);
        }
      } else
        e[v] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        f = l.uuid,
        d = n[f];
      if (d !== void 0 && d >= s) {
        const h = s++,
          p = e[h];
        (n[p.uuid] = d), (e[d] = p), (n[f] = h), (e[h] = l);
        for (let g = 0, v = i; g !== v; ++g) {
          const _ = r[g],
            x = _[h],
            m = _[d];
          (_[d] = x), (_[h] = m);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const f = arguments[a],
        d = f.uuid,
        h = n[d];
      if (h !== void 0)
        if ((delete n[d], h < s)) {
          const p = --s,
            g = e[p],
            v = --o,
            _ = e[v];
          (n[g.uuid] = h), (e[h] = g), (n[_.uuid] = p), (e[p] = _), e.pop();
          for (let x = 0, m = i; x !== m; ++x) {
            const w = r[x],
              S = w[p],
              E = w[v];
            (w[h] = S), (w[p] = E), w.pop();
          }
        } else {
          const p = --o,
            g = e[p];
          p > 0 && (n[g.uuid] = h), (e[h] = g), e.pop();
          for (let v = 0, _ = i; v !== _; ++v) {
            const x = r[v];
            (x[h] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, n) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      f = l.length,
      d = this.nCachedObjects_,
      h = new Array(f);
    (i = s.length), (r[e] = i), o.push(e), a.push(n), s.push(h);
    for (let p = d, g = l.length; p !== g; ++p) {
      const v = l[p];
      h[p] = new Nt(v, e, n);
    }
    return h;
  }
  unsubscribe_(e) {
    const n = this._bindingsIndicesByPath,
      r = n[e];
    if (r !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        f = e[a];
      (n[f] = r),
        (o[r] = l),
        o.pop(),
        (s[r] = s[a]),
        s.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class J3 {
  constructor(e, n, r = null, i = n.blendMode) {
    (this._mixer = e),
      (this._clip = n),
      (this._localRoot = r),
      (this.blendMode = i);
    const s = n.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: cl, endingEnd: cl };
    for (let f = 0; f !== o; ++f) {
      const d = s[f].createInterpolant(null);
      (a[f] = d), (d.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LI),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, n) {
    return (this.loop = e), (this.repetitions = n), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, n, r) {
    if ((e.fadeOut(n), this.fadeIn(n), r)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        o = s / i,
        a = i / s;
      e.warp(1, o, n), this.warp(a, 1, n);
    }
    return this;
  }
  crossFadeTo(e, n, r) {
    return e.crossFadeFrom(this, n, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, n, r) {
    const i = this._mixer,
      s = i.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      f = a.sampleValues;
    return (l[0] = s), (l[1] = s + r), (f[0] = e / o), (f[1] = n / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, n, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * r;
      l < 0 || r === 0 ? (n = 0) : ((this._startTime = null), (n = r * l));
    }
    n *= this._updateTimeScale(e);
    const o = this._updateTime(n),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        f = this._propertyBindings;
      switch (this.blendMode) {
        case Zw:
          for (let d = 0, h = l.length; d !== h; ++d)
            l[d].evaluate(o), f[d].accumulateAdditive(a);
          break;
        case U0:
        default:
          for (let d = 0, h = l.length; d !== h; ++d)
            l[d].evaluate(o), f[d].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = n), n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            n === 0 ? (this.paused = !0) : (this.timeScale = n));
      }
    }
    return (this._effectiveTimeScale = n), n;
  }
  _updateTime(e) {
    const n = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const o = r === II;
    if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? n - i : i;
    if (r === PI) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= n) i = n;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= n || i < 0)
      ) {
        const a = Math.floor(i / n);
        (i -= n * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? n : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const f = e < 0;
            this._setEndings(f, !f, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (o && (s & 1) === 1) return n - i;
    }
    return i;
  }
  _setEndings(e, n, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = fl), (i.endingEnd = fl))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? fl : cl)
          : (i.endingStart = Od),
        n ? (i.endingEnd = this.zeroSlopeAtEnd ? fl : cl) : (i.endingEnd = Od));
  }
  _scheduleFading(e, n, r) {
    const i = this._mixer,
      s = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = n), (a[1] = s + e), (l[1] = r), this;
  }
}
const nG = new Float32Array(1);
class rG extends Ao {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, n) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = r.uuid,
      f = this._bindingsByRootAndName;
    let d = f[l];
    d === void 0 && ((d = {}), (f[l] = d));
    for (let h = 0; h !== s; ++h) {
      const p = i[h],
        g = p.name;
      let v = d[g];
      if (v !== void 0) ++v.referenceCount, (o[h] = v);
      else {
        if (((v = o[h]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, g));
          continue;
        }
        const _ = n && n._propertyBindings[h].binding.parsedPath;
        (v = new Z3(Nt.create(r, g, _), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, g),
          (o[h] = v);
      }
      a[h].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const s = n[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const s = n[r];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const n = e._cacheIndex;
    return n !== null && n < this._nActiveActions;
  }
  _addInactiveAction(e, n, r) {
    const i = this._actions,
      s = this._actionsByClip;
    let o = s[n];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[n] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const n = this._actions,
      r = n[n.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (n[i] = r), n.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      f = l[l.length - 1],
      d = e._byClipCacheIndex;
    (f._byClipCacheIndex = d),
      (l[d] = f),
      l.pop(),
      (e._byClipCacheIndex = null);
    const h = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete h[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const n = e._propertyBindings;
    for (let r = 0, i = n.length; r !== i; ++r) {
      const s = n[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      s = n[i];
    (e._cacheIndex = i), (n[i] = e), (s._cacheIndex = r), (n[r] = s);
  }
  _takeBackAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      s = n[i];
    (e._cacheIndex = i), (n[i] = e), (s._cacheIndex = r), (n[r] = s);
  }
  _addInactiveBinding(e, n, r) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let o = i[n];
    o === void 0 && ((o = {}), (i[n] = o)),
      (o[r] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const n = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      s = r.path,
      o = this._bindingsByRootAndName,
      a = o[i],
      l = n[n.length - 1],
      f = e._cacheIndex;
    (l._cacheIndex = f),
      (n[f] = l),
      n.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      s = n[i];
    (e._cacheIndex = i), (n[i] = e), (s._cacheIndex = r), (n[r] = s);
  }
  _takeBackBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      s = n[i];
    (e._cacheIndex = i), (n[i] = e), (s._cacheIndex = r), (n[r] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      n = this._nActiveControlInterpolants++;
    let r = e[n];
    return (
      r === void 0 &&
        ((r = new wM(new Float32Array(2), new Float32Array(2), 1, nG)),
        (r.__cacheIndex = n),
        (e[n] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const n = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = n[i];
    (e.__cacheIndex = i), (n[i] = e), (s.__cacheIndex = r), (n[r] = s);
  }
  clipAction(e, n, r) {
    const i = n || this._root,
      s = i.uuid;
    let o = typeof e == "string" ? $d.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let f = null;
    if (
      (r === void 0 && (o !== null ? (r = o.blendMode) : (r = U0)),
      l !== void 0)
    ) {
      const h = l.actionByRoot[s];
      if (h !== void 0 && h.blendMode === r) return h;
      (f = l.knownActions[0]), o === null && (o = f._clip);
    }
    if (o === null) return null;
    const d = new J3(this, o, n, r);
    return this._bindAction(d, f), this._addInactiveAction(d, a, s), d;
  }
  existingAction(e, n) {
    const r = n || this._root,
      i = r.uuid,
      s = typeof e == "string" ? $d.findByName(r, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      n = this._nActiveActions;
    for (let r = n - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const n = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let f = 0; f !== r; ++f) n[f]._update(i, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let f = 0; f !== l; ++f) a[f].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const n = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      s = i[r];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const f = o[a];
        this._deactivateAction(f);
        const d = f._cacheIndex,
          h = n[n.length - 1];
        (f._cacheIndex = null),
          (f._byClipCacheIndex = null),
          (h._cacheIndex = d),
          (n[d] = h),
          n.pop(),
          this._removeInactiveBindingsForAction(f);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const n = e.uuid,
      r = this._actionsByClip;
    for (const o in r) {
      const a = r[o].actionByRoot,
        l = a[n];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      s = i[n];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, n) {
    const r = this.existingAction(e, n);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class PM {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new PM(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let iG = 0;
class sG extends Ao {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: iG++ }),
      (this.name = ""),
      (this.usage = Fd),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const n = this.uniforms.indexOf(e);
    return n !== -1 && this.uniforms.splice(n, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const n = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = n.length; r < i; r++) this.uniforms.push(n[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class oG extends W0 {
  constructor(e, n, r = 1) {
    super(e, n),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const n = super.clone(e);
    return (n.meshPerAttribute = this.meshPerAttribute), n;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.isInstancedInterleavedBuffer = !0),
      (n.meshPerAttribute = this.meshPerAttribute),
      n
    );
  }
}
class aG {
  constructor(e, n, r, i, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = n),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, n) {
    return (this.type = e), (this.elementSize = n), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class Q3 {
  constructor(e, n, r = 0, i = 1 / 0) {
    (this.ray = new kl(e, n)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new _l()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(n)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = n))
      : n.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (n.near + n.far) / (n.near - n.far))
          .unproject(n),
        this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld),
        (this.camera = n))
      : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  intersectObject(e, n = !0, r = []) {
    return d1(e, this, r, n), r.sort(IC), r;
  }
  intersectObjects(e, n = !0, r = []) {
    for (let i = 0, s = e.length; i < s; i++) d1(e[i], this, r, n);
    return r.sort(IC), r;
  }
}
function IC(t, e) {
  return t.distance - e.distance;
}
function d1(t, e, n, r) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), r === !0)) {
    const i = t.children;
    for (let s = 0, o = i.length; s < o; s++) d1(i[s], e, n, !0);
  }
}
class h1 {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + n * n + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Mn(n / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class lG {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const NC = new _e();
class uG {
  constructor(e = new _e(1 / 0, 1 / 0), n = new _e(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = NC.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, NC).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const OC = new z(),
  Sm = new z();
class cG {
  constructor(e = new z(), n = new z()) {
    (this.start = e), (this.end = n);
  }
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, n) {
    return this.delta(n).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, n) {
    OC.subVectors(e, this.start), Sm.subVectors(this.end, this.start);
    const r = Sm.dot(Sm);
    let s = Sm.dot(OC) / r;
    return n && (s = Mn(s, 0, 1)), s;
  }
  closestPointToPoint(e, n, r) {
    const i = this.closestPointToPointParameter(e, n);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const DC = new z();
class fG extends Ft {
  constructor(e, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "SpotLightHelper");
    const r = new bt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const f = (o / l) * Math.PI * 2,
        d = (a / l) * Math.PI * 2;
      i.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1);
    }
    r.setAttribute("position", new tt(i, 3));
    const s = new jr({ fog: !1, toneMapped: !1 });
    (this.cone = new Hs(r, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e),
      DC.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(DC),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Go = new z(),
  wm = new ht(),
  i_ = new ht();
class dG extends Hs {
  constructor(e) {
    const n = eN(e),
      r = new bt(),
      i = [],
      s = [],
      o = new qe(0, 0, 1),
      a = new qe(0, 1, 0);
    for (let f = 0; f < n.length; f++) {
      const d = n[f];
      d.parent &&
        d.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    r.setAttribute("position", new tt(i, 3)),
      r.setAttribute("color", new tt(s, 3));
    const l = new jr({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = n),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const n = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    i_.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < n.length; s++) {
      const a = n[s];
      a.parent &&
        a.parent.isBone &&
        (wm.multiplyMatrices(i_, a.matrixWorld),
        Go.setFromMatrixPosition(wm),
        i.setXYZ(o, Go.x, Go.y, Go.z),
        wm.multiplyMatrices(i_, a.parent.matrixWorld),
        Go.setFromMatrixPosition(wm),
        i.setXYZ(o + 1, Go.x, Go.y, Go.z),
        (o += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function eN(t) {
  const e = [];
  t.isBone === !0 && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, eN(t.children[n]));
  return e;
}
class hG extends jn {
  constructor(e, n, r) {
    const i = new dh(n, 4, 2),
      s = new Ta({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const pG = new z(),
  kC = new qe(),
  UC = new qe();
class mG extends Ft {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new fh(n);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Ta({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    i.setAttribute("color", new $t(o, 3)),
      this.add(new jn(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const n = e.geometry.getAttribute("color");
      kC.copy(this.light.color), UC.copy(this.light.groundColor);
      for (let r = 0, i = n.count; r < i; r++) {
        const s = r < i / 2 ? kC : UC;
        n.setXYZ(r, s.r, s.g, s.b);
      }
      n.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(pG.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class gG extends Hs {
  constructor(e = 10, n = 10, r = 4473924, i = 8947848) {
    (r = new qe(r)), (i = new qe(i));
    const s = n / 2,
      o = e / n,
      a = e / 2,
      l = [],
      f = [];
    for (let p = 0, g = 0, v = -a; p <= n; p++, v += o) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const _ = p === s ? r : i;
      _.toArray(f, g),
        (g += 3),
        _.toArray(f, g),
        (g += 3),
        _.toArray(f, g),
        (g += 3),
        _.toArray(f, g),
        (g += 3);
    }
    const d = new bt();
    d.setAttribute("position", new tt(l, 3)),
      d.setAttribute("color", new tt(f, 3));
    const h = new jr({ vertexColors: !0, toneMapped: !1 });
    super(d, h), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class vG extends Hs {
  constructor(e = 10, n = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
    (s = new qe(s)), (o = new qe(o));
    const a = [],
      l = [];
    if (n > 1)
      for (let h = 0; h < n; h++) {
        const p = (h / n) * (Math.PI * 2),
          g = Math.sin(p) * e,
          v = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(g, 0, v);
        const _ = h & 1 ? s : o;
        l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b);
      }
    for (let h = 0; h < r; h++) {
      const p = h & 1 ? s : o,
        g = e - (e / r) * h;
      for (let v = 0; v < i; v++) {
        let _ = (v / i) * (Math.PI * 2),
          x = Math.sin(_) * g,
          m = Math.cos(_) * g;
        a.push(x, 0, m),
          l.push(p.r, p.g, p.b),
          (_ = ((v + 1) / i) * (Math.PI * 2)),
          (x = Math.sin(_) * g),
          (m = Math.cos(_) * g),
          a.push(x, 0, m),
          l.push(p.r, p.g, p.b);
      }
    }
    const f = new bt();
    f.setAttribute("position", new tt(a, 3)),
      f.setAttribute("color", new tt(l, 3));
    const d = new jr({ vertexColors: !0, toneMapped: !1 });
    super(f, d), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const FC = new z(),
  Mm = new z(),
  zC = new z();
class yG extends Ft {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      n === void 0 && (n = 1);
    let i = new bt();
    i.setAttribute(
      "position",
      new tt([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3)
    );
    const s = new jr({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new _a(i, s)),
      this.add(this.lightPlane),
      (i = new bt()),
      i.setAttribute("position", new tt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new _a(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      FC.setFromMatrixPosition(this.light.matrixWorld),
      Mm.setFromMatrixPosition(this.light.target.matrixWorld),
      zC.subVectors(Mm, FC),
      this.lightPlane.lookAt(Mm),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Mm),
      (this.targetLine.scale.z = zC.length());
  }
}
const Em = new z(),
  xn = new oh();
class xG extends Hs {
  constructor(e) {
    const n = new bt(),
      r = new jr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(v, _) {
      l(v), l(_);
    }
    function l(v) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        o[v] === void 0 && (o[v] = []),
        o[v].push(i.length / 3 - 1);
    }
    n.setAttribute("position", new tt(i, 3)),
      n.setAttribute("color", new tt(s, 3)),
      super(n, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const f = new qe(16755200),
      d = new qe(16711680),
      h = new qe(43775),
      p = new qe(16777215),
      g = new qe(3355443);
    this.setColors(f, d, h, p, g);
  }
  setColors(e, n, r, i, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, n.r, n.g, n.b),
      a.setXYZ(25, n.r, n.g, n.b),
      a.setXYZ(26, n.r, n.g, n.b),
      a.setXYZ(27, n.r, n.g, n.b),
      a.setXYZ(28, n.r, n.g, n.b),
      a.setXYZ(29, n.r, n.g, n.b),
      a.setXYZ(30, n.r, n.g, n.b),
      a.setXYZ(31, n.r, n.g, n.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      n = this.pointMap,
      r = 1,
      i = 1;
    xn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Tn("c", n, e, xn, 0, 0, -1),
      Tn("t", n, e, xn, 0, 0, 1),
      Tn("n1", n, e, xn, -r, -i, -1),
      Tn("n2", n, e, xn, r, -i, -1),
      Tn("n3", n, e, xn, -r, i, -1),
      Tn("n4", n, e, xn, r, i, -1),
      Tn("f1", n, e, xn, -r, -i, 1),
      Tn("f2", n, e, xn, r, -i, 1),
      Tn("f3", n, e, xn, -r, i, 1),
      Tn("f4", n, e, xn, r, i, 1),
      Tn("u1", n, e, xn, r * 0.7, i * 1.1, -1),
      Tn("u2", n, e, xn, -r * 0.7, i * 1.1, -1),
      Tn("u3", n, e, xn, 0, i * 2, -1),
      Tn("cf1", n, e, xn, -r, 0, 1),
      Tn("cf2", n, e, xn, r, 0, 1),
      Tn("cf3", n, e, xn, 0, -i, 1),
      Tn("cf4", n, e, xn, 0, i, 1),
      Tn("cn1", n, e, xn, -r, 0, -1),
      Tn("cn2", n, e, xn, r, 0, -1),
      Tn("cn3", n, e, xn, 0, -i, -1),
      Tn("cn4", n, e, xn, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Tn(t, e, n, r, i, s, o) {
  Em.set(i, s, o).unproject(r);
  const a = e[t];
  if (a !== void 0) {
    const l = n.getAttribute("position");
    for (let f = 0, d = a.length; f < d; f++) l.setXYZ(a[f], Em.x, Em.y, Em.z);
  }
}
const bm = new Vr();
class _G extends Hs {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new bt();
    s.setIndex(new $t(r, 1)),
      s.setAttribute("position", new $t(i, 3)),
      super(s, new jr({ color: n, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && bm.setFromObject(this.object),
      bm.isEmpty())
    )
      return;
    const n = bm.min,
      r = bm.max,
      i = this.geometry.attributes.position,
      s = i.array;
    (s[0] = r.x),
      (s[1] = r.y),
      (s[2] = r.z),
      (s[3] = n.x),
      (s[4] = r.y),
      (s[5] = r.z),
      (s[6] = n.x),
      (s[7] = n.y),
      (s[8] = r.z),
      (s[9] = r.x),
      (s[10] = n.y),
      (s[11] = r.z),
      (s[12] = r.x),
      (s[13] = r.y),
      (s[14] = n.z),
      (s[15] = n.x),
      (s[16] = r.y),
      (s[17] = n.z),
      (s[18] = n.x),
      (s[19] = n.y),
      (s[20] = n.z),
      (s[21] = r.x),
      (s[22] = n.y),
      (s[23] = n.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, n) {
    return super.copy(e, n), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class SG extends Hs {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new bt();
    s.setIndex(new $t(r, 1)),
      s.setAttribute("position", new tt(i, 3)),
      super(s, new jr({ color: n, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const n = this.box;
    n.isEmpty() ||
      (n.getCenter(this.position),
      n.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class wG extends _a {
  constructor(e, n = 1, r = 16776960) {
    const i = r,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new bt();
    o.setAttribute("position", new tt(s, 3)),
      o.computeBoundingSphere(),
      super(o, new jr({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = n);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new bt();
    l.setAttribute("position", new tt(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new jn(
          l,
          new Ta({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const BC = new z();
let Tm, s_;
class MG extends Ft {
  constructor(
    e = new z(0, 0, 1),
    n = new z(0, 0, 0),
    r = 1,
    i = 16776960,
    s = r * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Tm === void 0 &&
        ((Tm = new bt()),
        Tm.setAttribute("position", new tt([0, 0, 0, 0, 1, 0], 3)),
        (s_ = new Oc(0, 0.5, 1, 5, 1)),
        s_.translate(0, -0.5, 0)),
      this.position.copy(n),
      (this.line = new _a(Tm, new jr({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new jn(s_, new Ta({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      BC.set(e.z, 0, -e.x).normalize();
      const n = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(BC, n);
    }
  }
  setLength(e, n = e * 0.2, r = n * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - n), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, n, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class EG extends Hs {
  constructor(e = 1) {
    const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new bt();
    i.setAttribute("position", new tt(n, 3)),
      i.setAttribute("color", new tt(r, 3));
    const s = new jr({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, n, r) {
    const i = new qe(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(n),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(r),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class bG {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new qe()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, n) {
    return (
      (this.currentPath = new Bd()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, n),
      this
    );
  }
  lineTo(e, n) {
    return this.currentPath.lineTo(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    return this.currentPath.quadraticCurveTo(e, n, r, i), this;
  }
  bezierCurveTo(e, n, r, i, s, o) {
    return this.currentPath.bezierCurveTo(e, n, r, i, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function n(m) {
      const w = [];
      for (let S = 0, E = m.length; S < E; S++) {
        const T = m[S],
          A = new wl();
        (A.curves = T.curves), w.push(A);
      }
      return w;
    }
    function r(m, w) {
      const S = w.length;
      let E = !1;
      for (let T = S - 1, A = 0; A < S; T = A++) {
        let L = w[T],
          N = w[A],
          C = N.x - L.x,
          I = N.y - L.y;
        if (Math.abs(I) > Number.EPSILON) {
          if (
            (I < 0 && ((L = w[A]), (C = -C), (N = w[T]), (I = -I)),
            m.y < L.y || m.y > N.y)
          )
            continue;
          if (m.y === L.y) {
            if (m.x === L.x) return !0;
          } else {
            const k = I * (m.x - L.x) - C * (m.y - L.y);
            if (k === 0) return !0;
            if (k < 0) continue;
            E = !E;
          }
        } else {
          if (m.y !== L.y) continue;
          if ((N.x <= m.x && m.x <= L.x) || (L.x <= m.x && m.x <= N.x))
            return !0;
        }
      }
      return E;
    }
    const i = Us.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const f = [];
    if (s.length === 1)
      return (a = s[0]), (l = new wl()), (l.curves = a.curves), f.push(l), f;
    let d = !i(s[0].getPoints());
    d = e ? !d : d;
    const h = [],
      p = [];
    let g = [],
      v = 0,
      _;
    (p[v] = void 0), (g[v] = []);
    for (let m = 0, w = s.length; m < w; m++)
      (a = s[m]),
        (_ = a.getPoints()),
        (o = i(_)),
        (o = e ? !o : o),
        o
          ? (!d && p[v] && v++,
            (p[v] = { s: new wl(), p: _ }),
            (p[v].s.curves = a.curves),
            d && v++,
            (g[v] = []))
          : g[v].push({ h: a, p: _[0] });
    if (!p[0]) return n(s);
    if (p.length > 1) {
      let m = !1,
        w = 0;
      for (let S = 0, E = p.length; S < E; S++) h[S] = [];
      for (let S = 0, E = p.length; S < E; S++) {
        const T = g[S];
        for (let A = 0; A < T.length; A++) {
          const L = T[A];
          let N = !0;
          for (let C = 0; C < p.length; C++)
            r(L.p, p[C].p) &&
              (S !== C && w++, N ? ((N = !1), h[C].push(L)) : (m = !0));
          N && h[S].push(L);
        }
      }
      w > 0 && m === !1 && (g = h);
    }
    let x;
    for (let m = 0, w = p.length; m < w; m++) {
      (l = p[m].s), f.push(l), (x = g[m]);
      for (let S = 0, E = x.length; S < E; S++) l.holes.push(x[S].h);
    }
    return f;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: N0 } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = N0));
const TG = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: Vw,
      AddEquation: Ko,
      AddOperation: gI,
      AdditiveAnimationBlendMode: Zw,
      AdditiveBlending: bS,
      AlphaFormat: EI,
      AlwaysCompare: VI,
      AlwaysDepth: uI,
      AlwaysStencilFunc: n1,
      AmbientLight: G3,
      AnimationAction: J3,
      AnimationClip: $d,
      AnimationLoader: R6,
      AnimationMixer: rG,
      AnimationObjectGroup: tG,
      AnimationUtils: b6,
      ArcCurve: p3,
      ArrayCamera: i3,
      ArrowHelper: MG,
      AttachedBindMode: PS,
      Audio: K3,
      AudioAnalyser: j6,
      AudioContext: TM,
      AudioListener: V6,
      AudioLoader: z6,
      AxesHelper: EG,
      BackSide: Hr,
      BasicDepthPacking: NI,
      BasicShadowMap: jL,
      BatchedMesh: f3,
      Bone: dM,
      BooleanKeyframeTrack: Fl,
      Box2: uG,
      Box3: Vr,
      Box3Helper: SG,
      BoxGeometry: Ul,
      BoxHelper: _G,
      BufferAttribute: $t,
      BufferGeometry: bt,
      BufferGeometryLoader: q3,
      ByteType: wI,
      Cache: Il,
      Camera: oh,
      CameraHelper: xG,
      CanvasTexture: qW,
      CapsuleGeometry: X0,
      CatmullRomCurve3: m3,
      CineonToneMapping: xI,
      CircleGeometry: Y0,
      ClampToEdgeWrapping: Cr,
      Clock: AM,
      Color: qe,
      ColorKeyframeTrack: MM,
      ColorManagement: Wt,
      CompressedArrayTexture: XW,
      CompressedCubeTexture: YW,
      CompressedTexture: j0,
      CompressedTextureLoader: P6,
      ConeGeometry: q0,
      ConstantAlphaFactor: oI,
      ConstantColorFactor: iI,
      CubeCamera: qI,
      CubeReflectionMapping: So,
      CubeRefractionMapping: ya,
      CubeTexture: ah,
      CubeTextureLoader: L6,
      CubeUVReflectionMapping: Ic,
      CubicBezierCurve: mM,
      CubicBezierCurve3: g3,
      CubicInterpolant: D3,
      CullFaceBack: ES,
      CullFaceFront: GL,
      CullFaceFrontBack: Uz,
      CullFaceNone: WL,
      Curve: ds,
      CurvePath: y3,
      CustomBlending: $L,
      CustomToneMapping: _I,
      CylinderGeometry: Oc,
      Cylindrical: lG,
      Data3DTexture: nM,
      DataArrayTexture: z0,
      DataTexture: Sl,
      DataTextureLoader: I6,
      DataUtils: XB,
      DecrementStencilOp: qz,
      DecrementWrapStencilOp: Zz,
      DefaultLoadingManager: F3,
      DepthFormat: ca,
      DepthStencilFormat: Rl,
      DepthTexture: oM,
      DetachedBindMode: SI,
      DirectionalLight: W3,
      DirectionalLightHelper: yG,
      DiscreteInterpolant: k3,
      DisplayP3ColorSpace: F0,
      DodecahedronGeometry: K0,
      DoubleSide: Ps,
      DstAlphaFactor: QL,
      DstColorFactor: tI,
      DynamicCopyUsage: dB,
      DynamicDrawUsage: oB,
      DynamicReadUsage: uB,
      EdgesGeometry: x3,
      EllipseCurve: $0,
      EqualCompare: FI,
      EqualDepth: fI,
      EqualStencilFunc: tB,
      EquirectangularReflectionMapping: Cd,
      EquirectangularRefractionMapping: Rd,
      Euler: sh,
      EventDispatcher: Ao,
      ExtrudeGeometry: J0,
      FileLoader: wo,
      Float16BufferAttribute: QB,
      Float32BufferAttribute: tt,
      Float64BufferAttribute: e4,
      FloatType: ss,
      Fog: V0,
      FogExp2: H0,
      FramebufferTexture: $W,
      FrontSide: _o,
      Frustum: lh,
      GLBufferAttribute: aG,
      GLSL1: pB,
      GLSL3: r1,
      GreaterCompare: zI,
      GreaterDepth: hI,
      GreaterEqualCompare: HI,
      GreaterEqualDepth: dI,
      GreaterEqualStencilFunc: sB,
      GreaterStencilFunc: rB,
      GridHelper: gG,
      Group: Ku,
      HalfFloatType: xc,
      HemisphereLight: B3,
      HemisphereLightHelper: mG,
      IcosahedronGeometry: Q0,
      ImageBitmapLoader: F6,
      ImageLoader: Xd,
      ImageUtils: tM,
      IncrementStencilOp: Yz,
      IncrementWrapStencilOp: Kz,
      InstancedBufferAttribute: Mc,
      InstancedBufferGeometry: Y3,
      InstancedInterleavedBuffer: oG,
      InstancedMesh: c3,
      Int16BufferAttribute: ZB,
      Int32BufferAttribute: JB,
      Int8BufferAttribute: YB,
      IntType: Gw,
      InterleavedBuffer: W0,
      InterleavedBufferAttribute: Pl,
      Interpolant: hh,
      InterpolateDiscrete: Id,
      InterpolateLinear: Nd,
      InterpolateSmooth: Jm,
      InvertStencilOp: Jz,
      KeepStencilOp: tl,
      KeyframeTrack: hs,
      LOD: l3,
      LatheGeometry: ch,
      Layers: _l,
      LessCompare: UI,
      LessDepth: cI,
      LessEqualCompare: Qw,
      LessEqualDepth: Ad,
      LessEqualStencilFunc: nB,
      LessStencilFunc: eB,
      Light: Ca,
      LightProbe: X3,
      Line: _a,
      Line3: cG,
      LineBasicMaterial: jr,
      LineCurve: gM,
      LineCurve3: v3,
      LineDashedMaterial: I3,
      LineLoop: d3,
      LineSegments: Hs,
      LinearDisplayP3ColorSpace: ih,
      LinearEncoding: Jw,
      LinearFilter: Rn,
      LinearInterpolant: wM,
      LinearMipMapLinearFilter: Vz,
      LinearMipMapNearestFilter: Hz,
      LinearMipmapLinearFilter: xa,
      LinearMipmapNearestFilter: Ww,
      LinearSRGBColorSpace: zs,
      LinearToneMapping: vI,
      LinearTransfer: Dd,
      Loader: ii,
      LoaderUtils: f1,
      LoadingManager: EM,
      LoopOnce: PI,
      LoopPingPong: II,
      LoopRepeat: LI,
      LuminanceAlphaFormat: TI,
      LuminanceFormat: bI,
      MOUSE: Qa,
      Material: Nr,
      MaterialLoader: ov,
      MathUtils: RB,
      Matrix3: Et,
      Matrix4: ht,
      MaxEquation: RS,
      Mesh: jn,
      MeshBasicMaterial: Ta,
      MeshDepthMaterial: aM,
      MeshDistanceMaterial: lM,
      MeshLambertMaterial: P3,
      MeshMatcapMaterial: L3,
      MeshNormalMaterial: R3,
      MeshPhongMaterial: A3,
      MeshPhysicalMaterial: T3,
      MeshStandardMaterial: _M,
      MeshToonMaterial: C3,
      MinEquation: CS,
      MirroredRepeatWrapping: Ld,
      MixOperation: mI,
      MultiplyBlending: AS,
      MultiplyOperation: rh,
      NearestFilter: An,
      NearestMipMapLinearFilter: Bz,
      NearestMipMapNearestFilter: zz,
      NearestMipmapLinearFilter: Qf,
      NearestMipmapNearestFilter: Ug,
      NeverCompare: kI,
      NeverDepth: lI,
      NeverStencilFunc: Qz,
      NoBlending: po,
      NoColorSpace: hi,
      NoToneMapping: Ds,
      NormalAnimationBlendMode: U0,
      NormalBlending: yl,
      NotEqualCompare: BI,
      NotEqualDepth: pI,
      NotEqualStencilFunc: iB,
      NumberKeyframeTrack: Gd,
      Object3D: Ft,
      ObjectLoader: k6,
      ObjectSpaceNormalMap: DI,
      OctahedronGeometry: fh,
      OneFactor: KL,
      OneMinusConstantAlphaFactor: aI,
      OneMinusConstantColorFactor: sI,
      OneMinusDstAlphaFactor: eI,
      OneMinusDstColorFactor: nI,
      OneMinusSrcAlphaFactor: kg,
      OneMinusSrcColorFactor: JL,
      OrthographicCamera: da,
      P3Primaries: Ud,
      PCFShadowMap: O0,
      PCFSoftShadowMap: Jf,
      PMREMGenerator: s1,
      Path: Bd,
      PerspectiveCamera: Pn,
      Plane: ao,
      PlaneGeometry: uh,
      PlaneHelper: wG,
      PointLight: V3,
      PointLightHelper: hG,
      Points: h3,
      PointsMaterial: hM,
      PolarGridHelper: vG,
      PolyhedronGeometry: Aa,
      PositionalAudio: G6,
      PropertyBinding: Nt,
      PropertyMixer: Z3,
      QuadraticBezierCurve: vM,
      QuadraticBezierCurve3: yM,
      Quaternion: Rr,
      QuaternionKeyframeTrack: Dc,
      QuaternionLinearInterpolant: U3,
      RED_GREEN_RGTC2_Format: e1,
      RED_RGTC1_Format: RI,
      REVISION: N0,
      RGBADepthPacking: OI,
      RGBAFormat: zr,
      RGBAIntegerFormat: qw,
      RGBA_ASTC_10x10_Format: YS,
      RGBA_ASTC_10x5_Format: jS,
      RGBA_ASTC_10x6_Format: $S,
      RGBA_ASTC_10x8_Format: XS,
      RGBA_ASTC_12x10_Format: qS,
      RGBA_ASTC_12x12_Format: KS,
      RGBA_ASTC_4x4_Format: US,
      RGBA_ASTC_5x4_Format: FS,
      RGBA_ASTC_5x5_Format: zS,
      RGBA_ASTC_6x5_Format: BS,
      RGBA_ASTC_6x6_Format: HS,
      RGBA_ASTC_8x5_Format: VS,
      RGBA_ASTC_8x6_Format: WS,
      RGBA_ASTC_8x8_Format: GS,
      RGBA_BPTC_Format: Zm,
      RGBA_ETC2_EAC_Format: kS,
      RGBA_PVRTC_2BPPV1_Format: OS,
      RGBA_PVRTC_4BPPV1_Format: NS,
      RGBA_S3TC_DXT1_Format: Ym,
      RGBA_S3TC_DXT3_Format: qm,
      RGBA_S3TC_DXT5_Format: Km,
      RGB_BPTC_SIGNED_Format: ZS,
      RGB_BPTC_UNSIGNED_Format: JS,
      RGB_ETC1_Format: Kw,
      RGB_ETC2_Format: DS,
      RGB_PVRTC_2BPPV1_Format: IS,
      RGB_PVRTC_4BPPV1_Format: LS,
      RGB_S3TC_DXT1_Format: Xm,
      RGFormat: CI,
      RGIntegerFormat: Yw,
      RawShaderMaterial: b3,
      Ray: kl,
      Raycaster: Q3,
      Rec709Primaries: kd,
      RectAreaLight: j3,
      RedFormat: AI,
      RedIntegerFormat: Xw,
      ReinhardToneMapping: yI,
      RenderTarget: jI,
      RepeatWrapping: Pd,
      ReplaceStencilOp: Xz,
      ReverseSubtractEquation: YL,
      RingGeometry: ev,
      SIGNED_RED_GREEN_RGTC2_Format: t1,
      SIGNED_RED_RGTC1_Format: QS,
      SRGBColorSpace: Wn,
      SRGBTransfer: Jt,
      Scene: cM,
      ShaderChunk: _t,
      ShaderLib: rs,
      ShaderMaterial: Bs,
      ShadowMaterial: E3,
      Shape: wl,
      ShapeGeometry: tv,
      ShapePath: bG,
      ShapeUtils: Us,
      ShortType: MI,
      Skeleton: G0,
      SkeletonHelper: dG,
      SkinnedMesh: u3,
      Source: dl,
      Sphere: Pr,
      SphereGeometry: dh,
      Spherical: h1,
      SphericalHarmonics3: $3,
      SplineCurve: xM,
      SpotLight: H3,
      SpotLightHelper: fG,
      Sprite: a3,
      SpriteMaterial: fM,
      SrcAlphaFactor: Dg,
      SrcAlphaSaturateFactor: rI,
      SrcColorFactor: ZL,
      StaticCopyUsage: fB,
      StaticDrawUsage: Fd,
      StaticReadUsage: lB,
      StereoCamera: B6,
      StreamCopyUsage: hB,
      StreamDrawUsage: aB,
      StreamReadUsage: cB,
      StringKeyframeTrack: zl,
      SubtractEquation: XL,
      SubtractiveBlending: TS,
      TOUCH: el,
      TangentSpaceNormalMap: ba,
      TetrahedronGeometry: nv,
      Texture: Ln,
      TextureLoader: z3,
      TorusGeometry: rv,
      TorusKnotGeometry: iv,
      Triangle: Zr,
      TriangleFanDrawMode: jz,
      TriangleStripDrawMode: Gz,
      TrianglesDrawMode: Wz,
      TubeGeometry: sv,
      TwoPassDoubleSide: Fz,
      UVMapping: D0,
      Uint16BufferAttribute: rM,
      Uint32BufferAttribute: iM,
      Uint8BufferAttribute: qB,
      Uint8ClampedBufferAttribute: KB,
      Uniform: PM,
      UniformsGroup: sG,
      UniformsLib: Ve,
      UniformsUtils: YI,
      UnsignedByteType: ks,
      UnsignedInt248Type: ua,
      UnsignedIntType: fo,
      UnsignedShort4444Type: jw,
      UnsignedShort5551Type: $w,
      UnsignedShortType: k0,
      VSMShadowMap: es,
      Vector2: _e,
      Vector3: z,
      Vector4: Gt,
      VectorKeyframeTrack: jd,
      VideoTexture: jW,
      WebGL1Renderer: s3,
      WebGL3DRenderTarget: DB,
      WebGLArrayRenderTarget: OB,
      WebGLCoordinateSystem: os,
      WebGLCubeRenderTarget: KI,
      WebGLMultipleRenderTargets: kB,
      WebGLRenderTarget: cs,
      WebGLRenderer: uM,
      WebGLUtils: r3,
      WebGPUCoordinateSystem: _c,
      WireframeGeometry: M3,
      WrapAroundEnding: Od,
      ZeroCurvatureEnding: cl,
      ZeroFactor: qL,
      ZeroSlopeEnding: fl,
      ZeroStencilOp: $z,
      _SRGBAFormat: Fg,
      createCanvasElement: GI,
      sRGBEncoding: fa,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var tN = { exports: {} },
  Bl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Bl.ConcurrentRoot = 1;
Bl.ContinuousEventPriority = 4;
Bl.DefaultEventPriority = 16;
Bl.DiscreteEventPriority = 1;
Bl.IdleEventPriority = 536870912;
Bl.LegacyRoot = 0;
tN.exports = Bl;
var Ju = tN.exports;
function AG(t) {
  let e;
  const n = new Set(),
    r = (f, d) => {
      const h = typeof f == "function" ? f(e) : f;
      if (h !== e) {
        const p = e;
        (e = d ? h : Object.assign({}, e, h)), n.forEach((g) => g(e, p));
      }
    },
    i = () => e,
    s = (f, d = i, h = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = d(e);
      function g() {
        const v = d(e);
        if (!h(p, v)) {
          const _ = p;
          f((p = v), _);
        }
      }
      return n.add(g), () => n.delete(g);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (f, d, h) =>
        d || h ? s(f, d, h) : (n.add(f), () => n.delete(f)),
      destroy: () => n.clear(),
    };
  return (e = t(r, i, l)), l;
}
const CG =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  HC = CG ? U.useEffect : U.useLayoutEffect;
function RG(t) {
  const e = typeof t == "function" ? AG(t) : t,
    n = (r = e.getState, i = Object.is) => {
      const [, s] = U.useReducer((x) => x + 1, 0),
        o = e.getState(),
        a = U.useRef(o),
        l = U.useRef(r),
        f = U.useRef(i),
        d = U.useRef(!1),
        h = U.useRef();
      h.current === void 0 && (h.current = r(o));
      let p,
        g = !1;
      (a.current !== o || l.current !== r || f.current !== i || d.current) &&
        ((p = r(o)), (g = !i(h.current, p))),
        HC(() => {
          g && (h.current = p),
            (a.current = o),
            (l.current = r),
            (f.current = i),
            (d.current = !1);
        });
      const v = U.useRef(o);
      HC(() => {
        const x = () => {
            try {
              const w = e.getState(),
                S = l.current(w);
              f.current(h.current, S) ||
                ((a.current = w), (h.current = S), s());
            } catch {
              (d.current = !0), s();
            }
          },
          m = e.subscribe(x);
        return e.getState() !== v.current && x(), m;
      }, []);
      const _ = g ? p : h.current;
      return U.useDebugValue(_), _;
    };
  return (
    Object.assign(n, e),
    (n[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [n, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    n
  );
}
const PG = (t) => typeof t == "object" && typeof t.then == "function",
  pl = [];
function nN(t, e, n = (r, i) => r === i) {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = t.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!n(t[i], e[i])) return !1;
  return !0;
}
function rN(t, e = null, n = !1, r = {}) {
  e === null && (e = [t]);
  for (const s of pl)
    if (nN(e, s.keys, s.equal)) {
      if (n) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, r.lifespan))),
          s.response
        );
      if (!n) throw s.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const s = pl.indexOf(i);
      s !== -1 && pl.splice(s, 1);
    },
    promise: (PG(t) ? t : t(...e))
      .then((s) => {
        (i.response = s),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((s) => (i.error = s)),
  };
  if ((pl.push(i), !n)) throw i.promise;
}
const LG = (t, e, n) => rN(t, e, !1, n),
  IG = (t, e, n) => void rN(t, e, !0, n),
  NG = (t) => {
    if (t === void 0 || t.length === 0) pl.splice(0, pl.length);
    else {
      const e = pl.find((n) => nN(t, n.keys, n.equal));
      e && e.remove();
    }
  };
var iN = { exports: {} },
  sN = { exports: {} },
  oN = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(B, G) {
    var X = B.length;
    B.push(G);
    e: for (; 0 < X; ) {
      var te = (X - 1) >>> 1,
        oe = B[te];
      if (0 < i(oe, G)) (B[te] = G), (B[X] = oe), (X = te);
      else break e;
    }
  }
  function n(B) {
    return B.length === 0 ? null : B[0];
  }
  function r(B) {
    if (B.length === 0) return null;
    var G = B[0],
      X = B.pop();
    if (X !== G) {
      B[0] = X;
      e: for (var te = 0, oe = B.length, J = oe >>> 1; te < J; ) {
        var ae = 2 * (te + 1) - 1,
          Se = B[ae],
          Ie = ae + 1,
          Ce = B[Ie];
        if (0 > i(Se, X))
          Ie < oe && 0 > i(Ce, Se)
            ? ((B[te] = Ce), (B[Ie] = X), (te = Ie))
            : ((B[te] = Se), (B[ae] = X), (te = ae));
        else if (Ie < oe && 0 > i(Ce, X)) (B[te] = Ce), (B[Ie] = X), (te = Ie);
        else break e;
      }
    }
    return G;
  }
  function i(B, G) {
    var X = B.sortIndex - G.sortIndex;
    return X !== 0 ? X : B.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    t.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    f = [],
    d = 1,
    h = null,
    p = 3,
    g = !1,
    v = !1,
    _ = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    m = typeof clearTimeout == "function" ? clearTimeout : null,
    w = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(B) {
    for (var G = n(f); G !== null; ) {
      if (G.callback === null) r(f);
      else if (G.startTime <= B)
        r(f), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = n(f);
    }
  }
  function E(B) {
    if (((_ = !1), S(B), !v))
      if (n(l) !== null) (v = !0), Y(T);
      else {
        var G = n(f);
        G !== null && Z(E, G.startTime - B);
      }
  }
  function T(B, G) {
    (v = !1), _ && ((_ = !1), m(N), (N = -1)), (g = !0);
    var X = p;
    try {
      for (
        S(G), h = n(l);
        h !== null && (!(h.expirationTime > G) || (B && !k()));

      ) {
        var te = h.callback;
        if (typeof te == "function") {
          (h.callback = null), (p = h.priorityLevel);
          var oe = te(h.expirationTime <= G);
          (G = t.unstable_now()),
            typeof oe == "function" ? (h.callback = oe) : h === n(l) && r(l),
            S(G);
        } else r(l);
        h = n(l);
      }
      if (h !== null) var J = !0;
      else {
        var ae = n(f);
        ae !== null && Z(E, ae.startTime - G), (J = !1);
      }
      return J;
    } finally {
      (h = null), (p = X), (g = !1);
    }
  }
  var A = !1,
    L = null,
    N = -1,
    C = 5,
    I = -1;
  function k() {
    return !(t.unstable_now() - I < C);
  }
  function R() {
    if (L !== null) {
      var B = t.unstable_now();
      I = B;
      var G = !0;
      try {
        G = L(!0, B);
      } finally {
        G ? $() : ((A = !1), (L = null));
      }
    } else A = !1;
  }
  var $;
  if (typeof w == "function")
    $ = function () {
      w(R);
    };
  else if (typeof MessageChannel < "u") {
    var D = new MessageChannel(),
      W = D.port2;
    (D.port1.onmessage = R),
      ($ = function () {
        W.postMessage(null);
      });
  } else
    $ = function () {
      x(R, 0);
    };
  function Y(B) {
    (L = B), A || ((A = !0), $());
  }
  function Z(B, G) {
    N = x(function () {
      B(t.unstable_now());
    }, G);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (B) {
      B.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || g || ((v = !0), Y(T));
    }),
    (t.unstable_forceFrameRate = function (B) {
      0 > B || 125 < B
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (C = 0 < B ? Math.floor(1e3 / B) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (B) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var X = p;
      p = G;
      try {
        return B();
      } finally {
        p = X;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (B, G) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var X = p;
      p = B;
      try {
        return G();
      } finally {
        p = X;
      }
    }),
    (t.unstable_scheduleCallback = function (B, G, X) {
      var te = t.unstable_now();
      switch (
        (typeof X == "object" && X !== null
          ? ((X = X.delay), (X = typeof X == "number" && 0 < X ? te + X : te))
          : (X = te),
        B)
      ) {
        case 1:
          var oe = -1;
          break;
        case 2:
          oe = 250;
          break;
        case 5:
          oe = 1073741823;
          break;
        case 4:
          oe = 1e4;
          break;
        default:
          oe = 5e3;
      }
      return (
        (oe = X + oe),
        (B = {
          id: d++,
          callback: G,
          priorityLevel: B,
          startTime: X,
          expirationTime: oe,
          sortIndex: -1,
        }),
        X > te
          ? ((B.sortIndex = X),
            e(f, B),
            n(l) === null &&
              B === n(f) &&
              (_ ? (m(N), (N = -1)) : (_ = !0), Z(E, X - te)))
          : ((B.sortIndex = oe), e(l, B), v || g || ((v = !0), Y(T))),
        B
      );
    }),
    (t.unstable_shouldYield = k),
    (t.unstable_wrapCallback = function (B) {
      var G = p;
      return function () {
        var X = p;
        p = G;
        try {
          return B.apply(this, arguments);
        } finally {
          p = X;
        }
      };
    });
})(oN);
sN.exports = oN;
var p1 = sN.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var OG = function (e) {
  var n = {},
    r = U,
    i = p1,
    s = Object.assign;
  function o(u) {
    for (
      var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + u,
        y = 1;
      y < arguments.length;
      y++
    )
      c += "&args[]=" + encodeURIComponent(arguments[y]);
    return (
      "Minified React error #" +
      u +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    f = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    h = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    _ = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    m = Symbol.for("react.suspense_list"),
    w = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    E = Symbol.for("react.offscreen"),
    T = Symbol.iterator;
  function A(u) {
    return u === null || typeof u != "object"
      ? null
      : ((u = (T && u[T]) || u["@@iterator"]),
        typeof u == "function" ? u : null);
  }
  function L(u) {
    if (u == null) return null;
    if (typeof u == "function") return u.displayName || u.name || null;
    if (typeof u == "string") return u;
    switch (u) {
      case d:
        return "Fragment";
      case f:
        return "Portal";
      case p:
        return "Profiler";
      case h:
        return "StrictMode";
      case x:
        return "Suspense";
      case m:
        return "SuspenseList";
    }
    if (typeof u == "object")
      switch (u.$$typeof) {
        case v:
          return (u.displayName || "Context") + ".Consumer";
        case g:
          return (u._context.displayName || "Context") + ".Provider";
        case _:
          var c = u.render;
          return (
            (u = u.displayName),
            u ||
              ((u = c.displayName || c.name || ""),
              (u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef")),
            u
          );
        case w:
          return (
            (c = u.displayName || null), c !== null ? c : L(u.type) || "Memo"
          );
        case S:
          (c = u._payload), (u = u._init);
          try {
            return L(u(c));
          } catch {}
      }
    return null;
  }
  function N(u) {
    var c = u.type;
    switch (u.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (u = c.render),
          (u = u.displayName || u.name || ""),
          c.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return L(c);
      case 8:
        return c === h ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function C(u) {
    var c = u,
      y = u;
    if (u.alternate) for (; c.return; ) c = c.return;
    else {
      u = c;
      do (c = u), c.flags & 4098 && (y = c.return), (u = c.return);
      while (u);
    }
    return c.tag === 3 ? y : null;
  }
  function I(u) {
    if (C(u) !== u) throw Error(o(188));
  }
  function k(u) {
    var c = u.alternate;
    if (!c) {
      if (((c = C(u)), c === null)) throw Error(o(188));
      return c !== u ? null : u;
    }
    for (var y = u, M = c; ; ) {
      var b = y.return;
      if (b === null) break;
      var P = b.alternate;
      if (P === null) {
        if (((M = b.return), M !== null)) {
          y = M;
          continue;
        }
        break;
      }
      if (b.child === P.child) {
        for (P = b.child; P; ) {
          if (P === y) return I(b), u;
          if (P === M) return I(b), c;
          P = P.sibling;
        }
        throw Error(o(188));
      }
      if (y.return !== M.return) (y = b), (M = P);
      else {
        for (var j = !1, ee = b.child; ee; ) {
          if (ee === y) {
            (j = !0), (y = b), (M = P);
            break;
          }
          if (ee === M) {
            (j = !0), (M = b), (y = P);
            break;
          }
          ee = ee.sibling;
        }
        if (!j) {
          for (ee = P.child; ee; ) {
            if (ee === y) {
              (j = !0), (y = P), (M = b);
              break;
            }
            if (ee === M) {
              (j = !0), (M = P), (y = b);
              break;
            }
            ee = ee.sibling;
          }
          if (!j) throw Error(o(189));
        }
      }
      if (y.alternate !== M) throw Error(o(190));
    }
    if (y.tag !== 3) throw Error(o(188));
    return y.stateNode.current === y ? u : c;
  }
  function R(u) {
    return (u = k(u)), u !== null ? $(u) : null;
  }
  function $(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      var c = $(u);
      if (c !== null) return c;
      u = u.sibling;
    }
    return null;
  }
  function D(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      if (u.tag !== 4) {
        var c = D(u);
        if (c !== null) return c;
      }
      u = u.sibling;
    }
    return null;
  }
  var W = Array.isArray,
    Y = e.getPublicInstance,
    Z = e.getRootHostContext,
    B = e.getChildHostContext,
    G = e.prepareForCommit,
    X = e.resetAfterCommit,
    te = e.createInstance,
    oe = e.appendInitialChild,
    J = e.finalizeInitialChildren,
    ae = e.prepareUpdate,
    Se = e.shouldSetTextContent,
    Ie = e.createTextInstance,
    Ce = e.scheduleTimeout,
    et = e.cancelTimeout,
    We = e.noTimeout,
    Me = e.isPrimaryRenderer,
    Le = e.supportsMutation,
    H = e.supportsPersistence,
    pe = e.supportsHydration,
    ie = e.getInstanceFromNode,
    we = e.preparePortalMount,
    xe = e.getCurrentEventPriority,
    $e = e.detachDeletedInstance,
    Fe = e.supportsMicrotasks,
    He = e.scheduleMicrotask,
    Ze = e.supportsTestSelectors,
    it = e.findFiberRoot,
    Tt = e.getBoundingRect,
    V = e.getTextContent,
    O = e.isHiddenSubtree,
    se = e.matchAccessibilityRole,
    Re = e.setFocusIfFocusable,
    Ee = e.setupIntersectionObserver,
    Ae = e.appendChild,
    Ye = e.appendChildToContainer,
    Pe = e.commitTextUpdate,
    Te = e.commitMount,
    at = e.commitUpdate,
    wt = e.insertBefore,
    Ne = e.insertInContainerBefore,
    Pt = e.removeChild,
    q = e.removeChildFromContainer,
    me = e.resetTextContent,
    be = e.hideInstance,
    ue = e.hideTextInstance,
    Be = e.unhideInstance,
    K = e.unhideTextInstance,
    ze = e.clearContainer,
    ke = e.cloneInstance,
    ye = e.createContainerChildSet,
    Oe = e.appendChildToContainerChildSet,
    nt = e.finalizeContainerChildren,
    xt = e.replaceContainerChildren,
    qt = e.cloneHiddenInstance,
    sn = e.cloneHiddenTextInstance,
    It = e.canHydrateInstance,
    sr = e.canHydrateTextInstance,
    Ei = e.canHydrateSuspenseInstance,
    zc = e.isSuspenseInstancePending,
    Bc = e.isSuspenseInstanceFallback,
    Hl = e.registerSuspenseInstanceRetry,
    Co = e.getNextHydratableSibling,
    Vl = e.getFirstHydratableChild,
    Sh = e.getFirstHydratableChildWithinContainer,
    wh = e.getFirstHydratableChildWithinSuspenseInstance,
    kv = e.hydrateInstance,
    Uv = e.hydrateTextInstance,
    Fv = e.hydrateSuspenseInstance,
    F = e.getNextHydratableInstanceAfterSuspenseInstance,
    re = e.commitHydratedContainer,
    fe = e.commitHydratedSuspenseInstance,
    he = e.clearSuspenseBoundary,
    ce = e.clearSuspenseBoundaryFromContainer,
    Xe = e.shouldDeleteUnhydratedTailInstances,
    st = e.didNotMatchHydratedContainerTextInstance,
    ct = e.didNotMatchHydratedTextInstance,
    ft;
  function mt(u) {
    if (ft === void 0)
      try {
        throw Error();
      } catch (y) {
        var c = y.stack.trim().match(/\n( *(at )?)/);
        ft = (c && c[1]) || "";
      }
    return (
      `
` +
      ft +
      u
    );
  }
  var pt = !1;
  function gt(u, c) {
    if (!u || pt) return "";
    pt = !0;
    var y = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (
          ((c = function () {
            throw Error();
          }),
          Object.defineProperty(c.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(c, []);
          } catch (Ue) {
            var M = Ue;
          }
          Reflect.construct(u, [], c);
        } else {
          try {
            c.call();
          } catch (Ue) {
            M = Ue;
          }
          u.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ue) {
          M = Ue;
        }
        u();
      }
    } catch (Ue) {
      if (Ue && M && typeof Ue.stack == "string") {
        for (
          var b = Ue.stack.split(`
`),
            P = M.stack.split(`
`),
            j = b.length - 1,
            ee = P.length - 1;
          1 <= j && 0 <= ee && b[j] !== P[ee];

        )
          ee--;
        for (; 1 <= j && 0 <= ee; j--, ee--)
          if (b[j] !== P[ee]) {
            if (j !== 1 || ee !== 1)
              do
                if ((j--, ee--, 0 > ee || b[j] !== P[ee])) {
                  var ge =
                    `
` + b[j].replace(" at new ", " at ");
                  return (
                    u.displayName &&
                      ge.includes("<anonymous>") &&
                      (ge = ge.replace("<anonymous>", u.displayName)),
                    ge
                  );
                }
              while (1 <= j && 0 <= ee);
            break;
          }
      }
    } finally {
      (pt = !1), (Error.prepareStackTrace = y);
    }
    return (u = u ? u.displayName || u.name : "") ? mt(u) : "";
  }
  var cn = Object.prototype.hasOwnProperty,
    or = [],
    tn = -1;
  function qn(u) {
    return { current: u };
  }
  function dt(u) {
    0 > tn || ((u.current = or[tn]), (or[tn] = null), tn--);
  }
  function Je(u, c) {
    tn++, (or[tn] = u.current), (u.current = c);
  }
  var bi = {},
    At = qn(bi),
    vn = qn(!1),
    ps = bi;
  function Ti(u, c) {
    var y = u.type.contextTypes;
    if (!y) return bi;
    var M = u.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === c)
      return M.__reactInternalMemoizedMaskedChildContext;
    var b = {},
      P;
    for (P in y) b[P] = c[P];
    return (
      M &&
        ((u = u.stateNode),
        (u.__reactInternalMemoizedUnmaskedChildContext = c),
        (u.__reactInternalMemoizedMaskedChildContext = b)),
      b
    );
  }
  function Kn(u) {
    return (u = u.childContextTypes), u != null;
  }
  function En() {
    dt(vn), dt(At);
  }
  function ms(u, c, y) {
    if (At.current !== bi) throw Error(o(168));
    Je(At, c), Je(vn, y);
  }
  function Wl(u, c, y) {
    var M = u.stateNode;
    if (((c = c.childContextTypes), typeof M.getChildContext != "function"))
      return y;
    M = M.getChildContext();
    for (var b in M) if (!(b in c)) throw Error(o(108, N(u) || "Unknown", b));
    return s({}, y, M);
  }
  function ar(u) {
    return (
      (u =
        ((u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext) ||
        bi),
      (ps = At.current),
      Je(At, u),
      Je(vn, vn.current),
      !0
    );
  }
  function Gl(u, c, y) {
    var M = u.stateNode;
    if (!M) throw Error(o(169));
    y
      ? ((u = Wl(u, c, ps)),
        (M.__reactInternalMemoizedMergedChildContext = u),
        dt(vn),
        dt(At),
        Je(At, u))
      : dt(vn),
      Je(vn, y);
  }
  var si = Math.clz32 ? Math.clz32 : xO,
    Mh = Math.log,
    yO = Math.LN2;
  function xO(u) {
    return (u >>>= 0), u === 0 ? 32 : (31 - ((Mh(u) / yO) | 0)) | 0;
  }
  var Eh = 64,
    bh = 4194304;
  function Hc(u) {
    switch (u & -u) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return u & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return u;
    }
  }
  function Th(u, c) {
    var y = u.pendingLanes;
    if (y === 0) return 0;
    var M = 0,
      b = u.suspendedLanes,
      P = u.pingedLanes,
      j = y & 268435455;
    if (j !== 0) {
      var ee = j & ~b;
      ee !== 0 ? (M = Hc(ee)) : ((P &= j), P !== 0 && (M = Hc(P)));
    } else (j = y & ~b), j !== 0 ? (M = Hc(j)) : P !== 0 && (M = Hc(P));
    if (M === 0) return 0;
    if (
      c !== 0 &&
      c !== M &&
      !(c & b) &&
      ((b = M & -M), (P = c & -c), b >= P || (b === 16 && (P & 4194240) !== 0))
    )
      return c;
    if ((M & 4 && (M |= y & 16), (c = u.entangledLanes), c !== 0))
      for (u = u.entanglements, c &= M; 0 < c; )
        (y = 31 - si(c)), (b = 1 << y), (M |= u[y]), (c &= ~b);
    return M;
  }
  function _O(u, c) {
    switch (u) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function SO(u, c) {
    for (
      var y = u.suspendedLanes,
        M = u.pingedLanes,
        b = u.expirationTimes,
        P = u.pendingLanes;
      0 < P;

    ) {
      var j = 31 - si(P),
        ee = 1 << j,
        ge = b[j];
      ge === -1
        ? (!(ee & y) || ee & M) && (b[j] = _O(ee, c))
        : ge <= c && (u.expiredLanes |= ee),
        (P &= ~ee);
    }
  }
  function zv(u) {
    return (
      (u = u.pendingLanes & -1073741825),
      u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    );
  }
  function Bv(u) {
    for (var c = [], y = 0; 31 > y; y++) c.push(u);
    return c;
  }
  function Vc(u, c, y) {
    (u.pendingLanes |= c),
      c !== 536870912 && ((u.suspendedLanes = 0), (u.pingedLanes = 0)),
      (u = u.eventTimes),
      (c = 31 - si(c)),
      (u[c] = y);
  }
  function wO(u, c) {
    var y = u.pendingLanes & ~c;
    (u.pendingLanes = c),
      (u.suspendedLanes = 0),
      (u.pingedLanes = 0),
      (u.expiredLanes &= c),
      (u.mutableReadLanes &= c),
      (u.entangledLanes &= c),
      (c = u.entanglements);
    var M = u.eventTimes;
    for (u = u.expirationTimes; 0 < y; ) {
      var b = 31 - si(y),
        P = 1 << b;
      (c[b] = 0), (M[b] = -1), (u[b] = -1), (y &= ~P);
    }
  }
  function Hv(u, c) {
    var y = (u.entangledLanes |= c);
    for (u = u.entanglements; y; ) {
      var M = 31 - si(y),
        b = 1 << M;
      (b & c) | (u[M] & c) && (u[M] |= c), (y &= ~b);
    }
  }
  var Dt = 0;
  function aE(u) {
    return (
      (u &= -u), 1 < u ? (4 < u ? (u & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var Vv = i.unstable_scheduleCallback,
    lE = i.unstable_cancelCallback,
    MO = i.unstable_shouldYield,
    EO = i.unstable_requestPaint,
    Zn = i.unstable_now,
    Wv = i.unstable_ImmediatePriority,
    bO = i.unstable_UserBlockingPriority,
    Gv = i.unstable_NormalPriority,
    TO = i.unstable_IdlePriority,
    Ah = null,
    gs = null;
  function AO(u) {
    if (gs && typeof gs.onCommitFiberRoot == "function")
      try {
        gs.onCommitFiberRoot(Ah, u, void 0, (u.current.flags & 128) === 128);
      } catch {}
  }
  function CO(u, c) {
    return (u === c && (u !== 0 || 1 / u === 1 / c)) || (u !== u && c !== c);
  }
  var vs = typeof Object.is == "function" ? Object.is : CO,
    Gs = null,
    Ch = !1,
    jv = !1;
  function uE(u) {
    Gs === null ? (Gs = [u]) : Gs.push(u);
  }
  function RO(u) {
    (Ch = !0), uE(u);
  }
  function ys() {
    if (!jv && Gs !== null) {
      jv = !0;
      var u = 0,
        c = Dt;
      try {
        var y = Gs;
        for (Dt = 1; u < y.length; u++) {
          var M = y[u];
          do M = M(!0);
          while (M !== null);
        }
        (Gs = null), (Ch = !1);
      } catch (b) {
        throw (Gs !== null && (Gs = Gs.slice(u + 1)), Vv(Wv, ys), b);
      } finally {
        (Dt = c), (jv = !1);
      }
    }
    return null;
  }
  var PO = a.ReactCurrentBatchConfig;
  function Rh(u, c) {
    if (vs(u, c)) return !0;
    if (
      typeof u != "object" ||
      u === null ||
      typeof c != "object" ||
      c === null
    )
      return !1;
    var y = Object.keys(u),
      M = Object.keys(c);
    if (y.length !== M.length) return !1;
    for (M = 0; M < y.length; M++) {
      var b = y[M];
      if (!cn.call(c, b) || !vs(u[b], c[b])) return !1;
    }
    return !0;
  }
  function LO(u) {
    switch (u.tag) {
      case 5:
        return mt(u.type);
      case 16:
        return mt("Lazy");
      case 13:
        return mt("Suspense");
      case 19:
        return mt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (u = gt(u.type, !1)), u;
      case 11:
        return (u = gt(u.type.render, !1)), u;
      case 1:
        return (u = gt(u.type, !0)), u;
      default:
        return "";
    }
  }
  function Xi(u, c) {
    if (u && u.defaultProps) {
      (c = s({}, c)), (u = u.defaultProps);
      for (var y in u) c[y] === void 0 && (c[y] = u[y]);
      return c;
    }
    return c;
  }
  var Ph = qn(null),
    Lh = null,
    jl = null,
    $v = null;
  function Xv() {
    $v = jl = Lh = null;
  }
  function cE(u, c, y) {
    Me
      ? (Je(Ph, c._currentValue), (c._currentValue = y))
      : (Je(Ph, c._currentValue2), (c._currentValue2 = y));
  }
  function Yv(u) {
    var c = Ph.current;
    dt(Ph), Me ? (u._currentValue = c) : (u._currentValue2 = c);
  }
  function qv(u, c, y) {
    for (; u !== null; ) {
      var M = u.alternate;
      if (
        ((u.childLanes & c) !== c
          ? ((u.childLanes |= c), M !== null && (M.childLanes |= c))
          : M !== null && (M.childLanes & c) !== c && (M.childLanes |= c),
        u === y)
      )
        break;
      u = u.return;
    }
  }
  function $l(u, c) {
    (Lh = u),
      ($v = jl = null),
      (u = u.dependencies),
      u !== null &&
        u.firstContext !== null &&
        (u.lanes & c && (li = !0), (u.firstContext = null));
  }
  function Ai(u) {
    var c = Me ? u._currentValue : u._currentValue2;
    if ($v !== u)
      if (((u = { context: u, memoizedValue: c, next: null }), jl === null)) {
        if (Lh === null) throw Error(o(308));
        (jl = u), (Lh.dependencies = { lanes: 0, firstContext: u });
      } else jl = jl.next = u;
    return c;
  }
  var xs = null,
    Ro = !1;
  function Kv(u) {
    u.updateQueue = {
      baseState: u.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function fE(u, c) {
    (u = u.updateQueue),
      c.updateQueue === u &&
        (c.updateQueue = {
          baseState: u.baseState,
          firstBaseUpdate: u.firstBaseUpdate,
          lastBaseUpdate: u.lastBaseUpdate,
          shared: u.shared,
          effects: u.effects,
        });
  }
  function js(u, c) {
    return {
      eventTime: u,
      lane: c,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Po(u, c) {
    var y = u.updateQueue;
    y !== null &&
      ((y = y.shared),
      On !== null && u.mode & 1 && !(Ct & 2)
        ? ((u = y.interleaved),
          u === null
            ? ((c.next = c), xs === null ? (xs = [y]) : xs.push(y))
            : ((c.next = u.next), (u.next = c)),
          (y.interleaved = c))
        : ((u = y.pending),
          u === null ? (c.next = c) : ((c.next = u.next), (u.next = c)),
          (y.pending = c)));
  }
  function Ih(u, c, y) {
    if (
      ((c = c.updateQueue), c !== null && ((c = c.shared), (y & 4194240) !== 0))
    ) {
      var M = c.lanes;
      (M &= u.pendingLanes), (y |= M), (c.lanes = y), Hv(u, y);
    }
  }
  function dE(u, c) {
    var y = u.updateQueue,
      M = u.alternate;
    if (M !== null && ((M = M.updateQueue), y === M)) {
      var b = null,
        P = null;
      if (((y = y.firstBaseUpdate), y !== null)) {
        do {
          var j = {
            eventTime: y.eventTime,
            lane: y.lane,
            tag: y.tag,
            payload: y.payload,
            callback: y.callback,
            next: null,
          };
          P === null ? (b = P = j) : (P = P.next = j), (y = y.next);
        } while (y !== null);
        P === null ? (b = P = c) : (P = P.next = c);
      } else b = P = c;
      (y = {
        baseState: M.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: P,
        shared: M.shared,
        effects: M.effects,
      }),
        (u.updateQueue = y);
      return;
    }
    (u = y.lastBaseUpdate),
      u === null ? (y.firstBaseUpdate = c) : (u.next = c),
      (y.lastBaseUpdate = c);
  }
  function Nh(u, c, y, M) {
    var b = u.updateQueue;
    Ro = !1;
    var P = b.firstBaseUpdate,
      j = b.lastBaseUpdate,
      ee = b.shared.pending;
    if (ee !== null) {
      b.shared.pending = null;
      var ge = ee,
        Ue = ge.next;
      (ge.next = null), j === null ? (P = Ue) : (j.next = Ue), (j = ge);
      var Qe = u.alternate;
      Qe !== null &&
        ((Qe = Qe.updateQueue),
        (ee = Qe.lastBaseUpdate),
        ee !== j &&
          (ee === null ? (Qe.firstBaseUpdate = Ue) : (ee.next = Ue),
          (Qe.lastBaseUpdate = ge)));
    }
    if (P !== null) {
      var vt = b.baseState;
      (j = 0), (Qe = Ue = ge = null), (ee = P);
      do {
        var lt = ee.lane,
          Kt = ee.eventTime;
        if ((M & lt) === lt) {
          Qe !== null &&
            (Qe = Qe.next =
              {
                eventTime: Kt,
                lane: 0,
                tag: ee.tag,
                payload: ee.payload,
                callback: ee.callback,
                next: null,
              });
          e: {
            var ot = u,
              yr = ee;
            switch (((lt = c), (Kt = y), yr.tag)) {
              case 1:
                if (((ot = yr.payload), typeof ot == "function")) {
                  vt = ot.call(Kt, vt, lt);
                  break e;
                }
                vt = ot;
                break e;
              case 3:
                ot.flags = (ot.flags & -65537) | 128;
              case 0:
                if (
                  ((ot = yr.payload),
                  (lt = typeof ot == "function" ? ot.call(Kt, vt, lt) : ot),
                  lt == null)
                )
                  break e;
                vt = s({}, vt, lt);
                break e;
              case 2:
                Ro = !0;
            }
          }
          ee.callback !== null &&
            ee.lane !== 0 &&
            ((u.flags |= 64),
            (lt = b.effects),
            lt === null ? (b.effects = [ee]) : lt.push(ee));
        } else
          (Kt = {
            eventTime: Kt,
            lane: lt,
            tag: ee.tag,
            payload: ee.payload,
            callback: ee.callback,
            next: null,
          }),
            Qe === null ? ((Ue = Qe = Kt), (ge = vt)) : (Qe = Qe.next = Kt),
            (j |= lt);
        if (((ee = ee.next), ee === null)) {
          if (((ee = b.shared.pending), ee === null)) break;
          (lt = ee),
            (ee = lt.next),
            (lt.next = null),
            (b.lastBaseUpdate = lt),
            (b.shared.pending = null);
        }
      } while (!0);
      if (
        (Qe === null && (ge = vt),
        (b.baseState = ge),
        (b.firstBaseUpdate = Ue),
        (b.lastBaseUpdate = Qe),
        (c = b.shared.interleaved),
        c !== null)
      ) {
        b = c;
        do (j |= b.lane), (b = b.next);
        while (b !== c);
      } else P === null && (b.shared.lanes = 0);
      (tu |= j), (u.lanes = j), (u.memoizedState = vt);
    }
  }
  function hE(u, c, y) {
    if (((u = c.effects), (c.effects = null), u !== null))
      for (c = 0; c < u.length; c++) {
        var M = u[c],
          b = M.callback;
        if (b !== null) {
          if (((M.callback = null), (M = y), typeof b != "function"))
            throw Error(o(191, b));
          b.call(M);
        }
      }
  }
  var pE = new r.Component().refs;
  function Zv(u, c, y, M) {
    (c = u.memoizedState),
      (y = y(M, c)),
      (y = y == null ? c : s({}, c, y)),
      (u.memoizedState = y),
      u.lanes === 0 && (u.updateQueue.baseState = y);
  }
  var Oh = {
    isMounted: function (u) {
      return (u = u._reactInternals) ? C(u) === u : !1;
    },
    enqueueSetState: function (u, c, y) {
      u = u._reactInternals;
      var M = Dr(),
        b = No(u),
        P = js(M, b);
      (P.payload = c),
        y != null && (P.callback = y),
        Po(u, P),
        (c = Ii(u, b, M)),
        c !== null && Ih(c, u, b);
    },
    enqueueReplaceState: function (u, c, y) {
      u = u._reactInternals;
      var M = Dr(),
        b = No(u),
        P = js(M, b);
      (P.tag = 1),
        (P.payload = c),
        y != null && (P.callback = y),
        Po(u, P),
        (c = Ii(u, b, M)),
        c !== null && Ih(c, u, b);
    },
    enqueueForceUpdate: function (u, c) {
      u = u._reactInternals;
      var y = Dr(),
        M = No(u),
        b = js(y, M);
      (b.tag = 2),
        c != null && (b.callback = c),
        Po(u, b),
        (c = Ii(u, M, y)),
        c !== null && Ih(c, u, M);
    },
  };
  function mE(u, c, y, M, b, P, j) {
    return (
      (u = u.stateNode),
      typeof u.shouldComponentUpdate == "function"
        ? u.shouldComponentUpdate(M, P, j)
        : c.prototype && c.prototype.isPureReactComponent
        ? !Rh(y, M) || !Rh(b, P)
        : !0
    );
  }
  function gE(u, c, y) {
    var M = !1,
      b = bi,
      P = c.contextType;
    return (
      typeof P == "object" && P !== null
        ? (P = Ai(P))
        : ((b = Kn(c) ? ps : At.current),
          (M = c.contextTypes),
          (P = (M = M != null) ? Ti(u, b) : bi)),
      (c = new c(y, P)),
      (u.memoizedState =
        c.state !== null && c.state !== void 0 ? c.state : null),
      (c.updater = Oh),
      (u.stateNode = c),
      (c._reactInternals = u),
      M &&
        ((u = u.stateNode),
        (u.__reactInternalMemoizedUnmaskedChildContext = b),
        (u.__reactInternalMemoizedMaskedChildContext = P)),
      c
    );
  }
  function vE(u, c, y, M) {
    (u = c.state),
      typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(y, M),
      typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(y, M),
      c.state !== u && Oh.enqueueReplaceState(c, c.state, null);
  }
  function Jv(u, c, y, M) {
    var b = u.stateNode;
    (b.props = y), (b.state = u.memoizedState), (b.refs = pE), Kv(u);
    var P = c.contextType;
    typeof P == "object" && P !== null
      ? (b.context = Ai(P))
      : ((P = Kn(c) ? ps : At.current), (b.context = Ti(u, P))),
      (b.state = u.memoizedState),
      (P = c.getDerivedStateFromProps),
      typeof P == "function" && (Zv(u, c, P, y), (b.state = u.memoizedState)),
      typeof c.getDerivedStateFromProps == "function" ||
        typeof b.getSnapshotBeforeUpdate == "function" ||
        (typeof b.UNSAFE_componentWillMount != "function" &&
          typeof b.componentWillMount != "function") ||
        ((c = b.state),
        typeof b.componentWillMount == "function" && b.componentWillMount(),
        typeof b.UNSAFE_componentWillMount == "function" &&
          b.UNSAFE_componentWillMount(),
        c !== b.state && Oh.enqueueReplaceState(b, b.state, null),
        Nh(u, y, b, M),
        (b.state = u.memoizedState)),
      typeof b.componentDidMount == "function" && (u.flags |= 4194308);
  }
  var Xl = [],
    Yl = 0,
    Dh = null,
    kh = 0,
    Ci = [],
    Ri = 0,
    Ra = null,
    $s = 1,
    Xs = "";
  function Pa(u, c) {
    (Xl[Yl++] = kh), (Xl[Yl++] = Dh), (Dh = u), (kh = c);
  }
  function yE(u, c, y) {
    (Ci[Ri++] = $s), (Ci[Ri++] = Xs), (Ci[Ri++] = Ra), (Ra = u);
    var M = $s;
    u = Xs;
    var b = 32 - si(M) - 1;
    (M &= ~(1 << b)), (y += 1);
    var P = 32 - si(c) + b;
    if (30 < P) {
      var j = b - (b % 5);
      (P = (M & ((1 << j) - 1)).toString(32)),
        (M >>= j),
        (b -= j),
        ($s = (1 << (32 - si(c) + b)) | (y << b) | M),
        (Xs = P + u);
    } else ($s = (1 << P) | (y << b) | M), (Xs = u);
  }
  function Qv(u) {
    u.return !== null && (Pa(u, 1), yE(u, 1, 0));
  }
  function ey(u) {
    for (; u === Dh; )
      (Dh = Xl[--Yl]), (Xl[Yl] = null), (kh = Xl[--Yl]), (Xl[Yl] = null);
    for (; u === Ra; )
      (Ra = Ci[--Ri]),
        (Ci[Ri] = null),
        (Xs = Ci[--Ri]),
        (Ci[Ri] = null),
        ($s = Ci[--Ri]),
        (Ci[Ri] = null);
  }
  var oi = null,
    ai = null,
    on = !1,
    Wc = !1,
    Yi = null;
  function xE(u, c) {
    var y = Ni(5, null, null, 0);
    (y.elementType = "DELETED"),
      (y.stateNode = c),
      (y.return = u),
      (c = u.deletions),
      c === null ? ((u.deletions = [y]), (u.flags |= 16)) : c.push(y);
  }
  function _E(u, c) {
    switch (u.tag) {
      case 5:
        return (
          (c = It(c, u.type, u.pendingProps)),
          c !== null ? ((u.stateNode = c), (oi = u), (ai = Vl(c)), !0) : !1
        );
      case 6:
        return (
          (c = sr(c, u.pendingProps)),
          c !== null ? ((u.stateNode = c), (oi = u), (ai = null), !0) : !1
        );
      case 13:
        if (((c = Ei(c)), c !== null)) {
          var y = Ra !== null ? { id: $s, overflow: Xs } : null;
          return (
            (u.memoizedState = {
              dehydrated: c,
              treeContext: y,
              retryLane: 1073741824,
            }),
            (y = Ni(18, null, null, 0)),
            (y.stateNode = c),
            (y.return = u),
            (u.child = y),
            (oi = u),
            (ai = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function ty(u) {
    return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
  }
  function ny(u) {
    if (on) {
      var c = ai;
      if (c) {
        var y = c;
        if (!_E(u, c)) {
          if (ty(u)) throw Error(o(418));
          c = Co(y);
          var M = oi;
          c && _E(u, c)
            ? xE(M, y)
            : ((u.flags = (u.flags & -4097) | 2), (on = !1), (oi = u));
        }
      } else {
        if (ty(u)) throw Error(o(418));
        (u.flags = (u.flags & -4097) | 2), (on = !1), (oi = u);
      }
    }
  }
  function SE(u) {
    for (
      u = u.return;
      u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13;

    )
      u = u.return;
    oi = u;
  }
  function Gc(u) {
    if (!pe || u !== oi) return !1;
    if (!on) return SE(u), (on = !0), !1;
    if (
      u.tag !== 3 &&
      (u.tag !== 5 || (Xe(u.type) && !Se(u.type, u.memoizedProps)))
    ) {
      var c = ai;
      if (c) {
        if (ty(u)) {
          for (u = ai; u; ) u = Co(u);
          throw Error(o(418));
        }
        for (; c; ) xE(u, c), (c = Co(c));
      }
    }
    if ((SE(u), u.tag === 13)) {
      if (!pe) throw Error(o(316));
      if (((u = u.memoizedState), (u = u !== null ? u.dehydrated : null), !u))
        throw Error(o(317));
      ai = F(u);
    } else ai = oi ? Co(u.stateNode) : null;
    return !0;
  }
  function ql() {
    pe && ((ai = oi = null), (Wc = on = !1));
  }
  function ry(u) {
    Yi === null ? (Yi = [u]) : Yi.push(u);
  }
  function jc(u, c, y) {
    if (
      ((u = y.ref),
      u !== null && typeof u != "function" && typeof u != "object")
    ) {
      if (y._owner) {
        if (((y = y._owner), y)) {
          if (y.tag !== 1) throw Error(o(309));
          var M = y.stateNode;
        }
        if (!M) throw Error(o(147, u));
        var b = M,
          P = "" + u;
        return c !== null &&
          c.ref !== null &&
          typeof c.ref == "function" &&
          c.ref._stringRef === P
          ? c.ref
          : ((c = function (j) {
              var ee = b.refs;
              ee === pE && (ee = b.refs = {}),
                j === null ? delete ee[P] : (ee[P] = j);
            }),
            (c._stringRef = P),
            c);
      }
      if (typeof u != "string") throw Error(o(284));
      if (!y._owner) throw Error(o(290, u));
    }
    return u;
  }
  function Uh(u, c) {
    throw (
      ((u = Object.prototype.toString.call(c)),
      Error(
        o(
          31,
          u === "[object Object]"
            ? "object with keys {" + Object.keys(c).join(", ") + "}"
            : u
        )
      ))
    );
  }
  function wE(u) {
    var c = u._init;
    return c(u._payload);
  }
  function ME(u) {
    function c(le, ne) {
      if (u) {
        var de = le.deletions;
        de === null ? ((le.deletions = [ne]), (le.flags |= 16)) : de.push(ne);
      }
    }
    function y(le, ne) {
      if (!u) return null;
      for (; ne !== null; ) c(le, ne), (ne = ne.sibling);
      return null;
    }
    function M(le, ne) {
      for (le = new Map(); ne !== null; )
        ne.key !== null ? le.set(ne.key, ne) : le.set(ne.index, ne),
          (ne = ne.sibling);
      return le;
    }
    function b(le, ne) {
      return (le = Do(le, ne)), (le.index = 0), (le.sibling = null), le;
    }
    function P(le, ne, de) {
      return (
        (le.index = de),
        u
          ? ((de = le.alternate),
            de !== null
              ? ((de = de.index), de < ne ? ((le.flags |= 2), ne) : de)
              : ((le.flags |= 2), ne))
          : ((le.flags |= 1048576), ne)
      );
    }
    function j(le) {
      return u && le.alternate === null && (le.flags |= 2), le;
    }
    function ee(le, ne, de, je) {
      return ne === null || ne.tag !== 6
        ? ((ne = By(de, le.mode, je)), (ne.return = le), ne)
        : ((ne = b(ne, de)), (ne.return = le), ne);
    }
    function ge(le, ne, de, je) {
      var rt = de.type;
      return rt === d
        ? Qe(le, ne, de.props.children, je, de.key)
        : ne !== null &&
          (ne.elementType === rt ||
            (typeof rt == "object" &&
              rt !== null &&
              rt.$$typeof === S &&
              wE(rt) === ne.type))
        ? ((je = b(ne, de.props)),
          (je.ref = jc(le, ne, de)),
          (je.return = le),
          je)
        : ((je = pp(de.type, de.key, de.props, null, le.mode, je)),
          (je.ref = jc(le, ne, de)),
          (je.return = le),
          je);
    }
    function Ue(le, ne, de, je) {
      return ne === null ||
        ne.tag !== 4 ||
        ne.stateNode.containerInfo !== de.containerInfo ||
        ne.stateNode.implementation !== de.implementation
        ? ((ne = Hy(de, le.mode, je)), (ne.return = le), ne)
        : ((ne = b(ne, de.children || [])), (ne.return = le), ne);
    }
    function Qe(le, ne, de, je, rt) {
      return ne === null || ne.tag !== 7
        ? ((ne = Ua(de, le.mode, je, rt)), (ne.return = le), ne)
        : ((ne = b(ne, de)), (ne.return = le), ne);
    }
    function vt(le, ne, de) {
      if ((typeof ne == "string" && ne !== "") || typeof ne == "number")
        return (ne = By("" + ne, le.mode, de)), (ne.return = le), ne;
      if (typeof ne == "object" && ne !== null) {
        switch (ne.$$typeof) {
          case l:
            return (
              (de = pp(ne.type, ne.key, ne.props, null, le.mode, de)),
              (de.ref = jc(le, null, ne)),
              (de.return = le),
              de
            );
          case f:
            return (ne = Hy(ne, le.mode, de)), (ne.return = le), ne;
          case S:
            var je = ne._init;
            return vt(le, je(ne._payload), de);
        }
        if (W(ne) || A(ne))
          return (ne = Ua(ne, le.mode, de, null)), (ne.return = le), ne;
        Uh(le, ne);
      }
      return null;
    }
    function lt(le, ne, de, je) {
      var rt = ne !== null ? ne.key : null;
      if ((typeof de == "string" && de !== "") || typeof de == "number")
        return rt !== null ? null : ee(le, ne, "" + de, je);
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case l:
            return de.key === rt ? ge(le, ne, de, je) : null;
          case f:
            return de.key === rt ? Ue(le, ne, de, je) : null;
          case S:
            return (rt = de._init), lt(le, ne, rt(de._payload), je);
        }
        if (W(de) || A(de))
          return rt !== null ? null : Qe(le, ne, de, je, null);
        Uh(le, de);
      }
      return null;
    }
    function Kt(le, ne, de, je, rt) {
      if ((typeof je == "string" && je !== "") || typeof je == "number")
        return (le = le.get(de) || null), ee(ne, le, "" + je, rt);
      if (typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case l:
            return (
              (le = le.get(je.key === null ? de : je.key) || null),
              ge(ne, le, je, rt)
            );
          case f:
            return (
              (le = le.get(je.key === null ? de : je.key) || null),
              Ue(ne, le, je, rt)
            );
          case S:
            var Mt = je._init;
            return Kt(le, ne, de, Mt(je._payload), rt);
        }
        if (W(je) || A(je))
          return (le = le.get(de) || null), Qe(ne, le, je, rt, null);
        Uh(ne, je);
      }
      return null;
    }
    function ot(le, ne, de, je) {
      for (
        var rt = null, Mt = null, yt = ne, kt = (ne = 0), Qn = null;
        yt !== null && kt < de.length;
        kt++
      ) {
        yt.index > kt ? ((Qn = yt), (yt = null)) : (Qn = yt.sibling);
        var Ut = lt(le, yt, de[kt], je);
        if (Ut === null) {
          yt === null && (yt = Qn);
          break;
        }
        u && yt && Ut.alternate === null && c(le, yt),
          (ne = P(Ut, ne, kt)),
          Mt === null ? (rt = Ut) : (Mt.sibling = Ut),
          (Mt = Ut),
          (yt = Qn);
      }
      if (kt === de.length) return y(le, yt), on && Pa(le, kt), rt;
      if (yt === null) {
        for (; kt < de.length; kt++)
          (yt = vt(le, de[kt], je)),
            yt !== null &&
              ((ne = P(yt, ne, kt)),
              Mt === null ? (rt = yt) : (Mt.sibling = yt),
              (Mt = yt));
        return on && Pa(le, kt), rt;
      }
      for (yt = M(le, yt); kt < de.length; kt++)
        (Qn = Kt(yt, le, kt, de[kt], je)),
          Qn !== null &&
            (u &&
              Qn.alternate !== null &&
              yt.delete(Qn.key === null ? kt : Qn.key),
            (ne = P(Qn, ne, kt)),
            Mt === null ? (rt = Qn) : (Mt.sibling = Qn),
            (Mt = Qn));
      return (
        u &&
          yt.forEach(function (ko) {
            return c(le, ko);
          }),
        on && Pa(le, kt),
        rt
      );
    }
    function yr(le, ne, de, je) {
      var rt = A(de);
      if (typeof rt != "function") throw Error(o(150));
      if (((de = rt.call(de)), de == null)) throw Error(o(151));
      for (
        var Mt = (rt = null), yt = ne, kt = (ne = 0), Qn = null, Ut = de.next();
        yt !== null && !Ut.done;
        kt++, Ut = de.next()
      ) {
        yt.index > kt ? ((Qn = yt), (yt = null)) : (Qn = yt.sibling);
        var ko = lt(le, yt, Ut.value, je);
        if (ko === null) {
          yt === null && (yt = Qn);
          break;
        }
        u && yt && ko.alternate === null && c(le, yt),
          (ne = P(ko, ne, kt)),
          Mt === null ? (rt = ko) : (Mt.sibling = ko),
          (Mt = ko),
          (yt = Qn);
      }
      if (Ut.done) return y(le, yt), on && Pa(le, kt), rt;
      if (yt === null) {
        for (; !Ut.done; kt++, Ut = de.next())
          (Ut = vt(le, Ut.value, je)),
            Ut !== null &&
              ((ne = P(Ut, ne, kt)),
              Mt === null ? (rt = Ut) : (Mt.sibling = Ut),
              (Mt = Ut));
        return on && Pa(le, kt), rt;
      }
      for (yt = M(le, yt); !Ut.done; kt++, Ut = de.next())
        (Ut = Kt(yt, le, kt, Ut.value, je)),
          Ut !== null &&
            (u &&
              Ut.alternate !== null &&
              yt.delete(Ut.key === null ? kt : Ut.key),
            (ne = P(Ut, ne, kt)),
            Mt === null ? (rt = Ut) : (Mt.sibling = Ut),
            (Mt = Ut));
      return (
        u &&
          yt.forEach(function (aD) {
            return c(le, aD);
          }),
        on && Pa(le, kt),
        rt
      );
    }
    function Oi(le, ne, de, je) {
      if (
        (typeof de == "object" &&
          de !== null &&
          de.type === d &&
          de.key === null &&
          (de = de.props.children),
        typeof de == "object" && de !== null)
      ) {
        switch (de.$$typeof) {
          case l:
            e: {
              for (var rt = de.key, Mt = ne; Mt !== null; ) {
                if (Mt.key === rt) {
                  if (((rt = de.type), rt === d)) {
                    if (Mt.tag === 7) {
                      y(le, Mt.sibling),
                        (ne = b(Mt, de.props.children)),
                        (ne.return = le),
                        (le = ne);
                      break e;
                    }
                  } else if (
                    Mt.elementType === rt ||
                    (typeof rt == "object" &&
                      rt !== null &&
                      rt.$$typeof === S &&
                      wE(rt) === Mt.type)
                  ) {
                    y(le, Mt.sibling),
                      (ne = b(Mt, de.props)),
                      (ne.ref = jc(le, Mt, de)),
                      (ne.return = le),
                      (le = ne);
                    break e;
                  }
                  y(le, Mt);
                  break;
                } else c(le, Mt);
                Mt = Mt.sibling;
              }
              de.type === d
                ? ((ne = Ua(de.props.children, le.mode, je, de.key)),
                  (ne.return = le),
                  (le = ne))
                : ((je = pp(de.type, de.key, de.props, null, le.mode, je)),
                  (je.ref = jc(le, ne, de)),
                  (je.return = le),
                  (le = je));
            }
            return j(le);
          case f:
            e: {
              for (Mt = de.key; ne !== null; ) {
                if (ne.key === Mt)
                  if (
                    ne.tag === 4 &&
                    ne.stateNode.containerInfo === de.containerInfo &&
                    ne.stateNode.implementation === de.implementation
                  ) {
                    y(le, ne.sibling),
                      (ne = b(ne, de.children || [])),
                      (ne.return = le),
                      (le = ne);
                    break e;
                  } else {
                    y(le, ne);
                    break;
                  }
                else c(le, ne);
                ne = ne.sibling;
              }
              (ne = Hy(de, le.mode, je)), (ne.return = le), (le = ne);
            }
            return j(le);
          case S:
            return (Mt = de._init), Oi(le, ne, Mt(de._payload), je);
        }
        if (W(de)) return ot(le, ne, de, je);
        if (A(de)) return yr(le, ne, de, je);
        Uh(le, de);
      }
      return (typeof de == "string" && de !== "") || typeof de == "number"
        ? ((de = "" + de),
          ne !== null && ne.tag === 6
            ? (y(le, ne.sibling), (ne = b(ne, de)), (ne.return = le), (le = ne))
            : (y(le, ne),
              (ne = By(de, le.mode, je)),
              (ne.return = le),
              (le = ne)),
          j(le))
        : y(le, ne);
    }
    return Oi;
  }
  var Kl = ME(!0),
    EE = ME(!1),
    $c = {},
    Pi = qn($c),
    Xc = qn($c),
    Zl = qn($c);
  function _s(u) {
    if (u === $c) throw Error(o(174));
    return u;
  }
  function iy(u, c) {
    Je(Zl, c), Je(Xc, u), Je(Pi, $c), (u = Z(c)), dt(Pi), Je(Pi, u);
  }
  function Jl() {
    dt(Pi), dt(Xc), dt(Zl);
  }
  function bE(u) {
    var c = _s(Zl.current),
      y = _s(Pi.current);
    (c = B(y, u.type, c)), y !== c && (Je(Xc, u), Je(Pi, c));
  }
  function sy(u) {
    Xc.current === u && (dt(Pi), dt(Xc));
  }
  var fn = qn(0);
  function Fh(u) {
    for (var c = u; c !== null; ) {
      if (c.tag === 13) {
        var y = c.memoizedState;
        if (y !== null && ((y = y.dehydrated), y === null || zc(y) || Bc(y)))
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128) return c;
      } else if (c.child !== null) {
        (c.child.return = c), (c = c.child);
        continue;
      }
      if (c === u) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === u) return null;
        c = c.return;
      }
      (c.sibling.return = c.return), (c = c.sibling);
    }
    return null;
  }
  var oy = [];
  function ay() {
    for (var u = 0; u < oy.length; u++) {
      var c = oy[u];
      Me
        ? (c._workInProgressVersionPrimary = null)
        : (c._workInProgressVersionSecondary = null);
    }
    oy.length = 0;
  }
  var zh = a.ReactCurrentDispatcher,
    Li = a.ReactCurrentBatchConfig,
    Ql = 0,
    yn = null,
    mr = null,
    Jn = null,
    Bh = !1,
    Yc = !1,
    qc = 0,
    IO = 0;
  function gr() {
    throw Error(o(321));
  }
  function ly(u, c) {
    if (c === null) return !1;
    for (var y = 0; y < c.length && y < u.length; y++)
      if (!vs(u[y], c[y])) return !1;
    return !0;
  }
  function uy(u, c, y, M, b, P) {
    if (
      ((Ql = P),
      (yn = c),
      (c.memoizedState = null),
      (c.updateQueue = null),
      (c.lanes = 0),
      (zh.current = u === null || u.memoizedState === null ? kO : UO),
      (u = y(M, b)),
      Yc)
    ) {
      P = 0;
      do {
        if (((Yc = !1), (qc = 0), 25 <= P)) throw Error(o(301));
        (P += 1),
          (Jn = mr = null),
          (c.updateQueue = null),
          (zh.current = FO),
          (u = y(M, b));
      } while (Yc);
    }
    if (
      ((zh.current = jh),
      (c = mr !== null && mr.next !== null),
      (Ql = 0),
      (Jn = mr = yn = null),
      (Bh = !1),
      c)
    )
      throw Error(o(300));
    return u;
  }
  function cy() {
    var u = qc !== 0;
    return (qc = 0), u;
  }
  function Ys() {
    var u = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Jn === null ? (yn.memoizedState = Jn = u) : (Jn = Jn.next = u), Jn;
  }
  function Ss() {
    if (mr === null) {
      var u = yn.alternate;
      u = u !== null ? u.memoizedState : null;
    } else u = mr.next;
    var c = Jn === null ? yn.memoizedState : Jn.next;
    if (c !== null) (Jn = c), (mr = u);
    else {
      if (u === null) throw Error(o(310));
      (mr = u),
        (u = {
          memoizedState: mr.memoizedState,
          baseState: mr.baseState,
          baseQueue: mr.baseQueue,
          queue: mr.queue,
          next: null,
        }),
        Jn === null ? (yn.memoizedState = Jn = u) : (Jn = Jn.next = u);
    }
    return Jn;
  }
  function La(u, c) {
    return typeof c == "function" ? c(u) : c;
  }
  function Hh(u) {
    var c = Ss(),
      y = c.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = u;
    var M = mr,
      b = M.baseQueue,
      P = y.pending;
    if (P !== null) {
      if (b !== null) {
        var j = b.next;
        (b.next = P.next), (P.next = j);
      }
      (M.baseQueue = b = P), (y.pending = null);
    }
    if (b !== null) {
      (P = b.next), (M = M.baseState);
      var ee = (j = null),
        ge = null,
        Ue = P;
      do {
        var Qe = Ue.lane;
        if ((Ql & Qe) === Qe)
          ge !== null &&
            (ge = ge.next =
              {
                lane: 0,
                action: Ue.action,
                hasEagerState: Ue.hasEagerState,
                eagerState: Ue.eagerState,
                next: null,
              }),
            (M = Ue.hasEagerState ? Ue.eagerState : u(M, Ue.action));
        else {
          var vt = {
            lane: Qe,
            action: Ue.action,
            hasEagerState: Ue.hasEagerState,
            eagerState: Ue.eagerState,
            next: null,
          };
          ge === null ? ((ee = ge = vt), (j = M)) : (ge = ge.next = vt),
            (yn.lanes |= Qe),
            (tu |= Qe);
        }
        Ue = Ue.next;
      } while (Ue !== null && Ue !== P);
      ge === null ? (j = M) : (ge.next = ee),
        vs(M, c.memoizedState) || (li = !0),
        (c.memoizedState = M),
        (c.baseState = j),
        (c.baseQueue = ge),
        (y.lastRenderedState = M);
    }
    if (((u = y.interleaved), u !== null)) {
      b = u;
      do (P = b.lane), (yn.lanes |= P), (tu |= P), (b = b.next);
      while (b !== u);
    } else b === null && (y.lanes = 0);
    return [c.memoizedState, y.dispatch];
  }
  function Vh(u) {
    var c = Ss(),
      y = c.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = u;
    var M = y.dispatch,
      b = y.pending,
      P = c.memoizedState;
    if (b !== null) {
      y.pending = null;
      var j = (b = b.next);
      do (P = u(P, j.action)), (j = j.next);
      while (j !== b);
      vs(P, c.memoizedState) || (li = !0),
        (c.memoizedState = P),
        c.baseQueue === null && (c.baseState = P),
        (y.lastRenderedState = P);
    }
    return [P, M];
  }
  function TE() {}
  function AE(u, c) {
    var y = yn,
      M = Ss(),
      b = c(),
      P = !vs(M.memoizedState, b);
    if (
      (P && ((M.memoizedState = b), (li = !0)),
      (M = M.queue),
      Zc(PE.bind(null, y, M, u), [u]),
      M.getSnapshot !== c || P || (Jn !== null && Jn.memoizedState.tag & 1))
    ) {
      if (
        ((y.flags |= 2048),
        Kc(9, RE.bind(null, y, M, b, c), void 0, null),
        On === null)
      )
        throw Error(o(349));
      Ql & 30 || CE(y, c, b);
    }
    return b;
  }
  function CE(u, c, y) {
    (u.flags |= 16384),
      (u = { getSnapshot: c, value: y }),
      (c = yn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (yn.updateQueue = c),
          (c.stores = [u]))
        : ((y = c.stores), y === null ? (c.stores = [u]) : y.push(u));
  }
  function RE(u, c, y, M) {
    (c.value = y), (c.getSnapshot = M), LE(c) && Ii(u, 1, -1);
  }
  function PE(u, c, y) {
    return y(function () {
      LE(c) && Ii(u, 1, -1);
    });
  }
  function LE(u) {
    var c = u.getSnapshot;
    u = u.value;
    try {
      var y = c();
      return !vs(u, y);
    } catch {
      return !0;
    }
  }
  function fy(u) {
    var c = Ys();
    return (
      typeof u == "function" && (u = u()),
      (c.memoizedState = c.baseState = u),
      (u = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: La,
        lastRenderedState: u,
      }),
      (c.queue = u),
      (u = u.dispatch = DO.bind(null, yn, u)),
      [c.memoizedState, u]
    );
  }
  function Kc(u, c, y, M) {
    return (
      (u = { tag: u, create: c, destroy: y, deps: M, next: null }),
      (c = yn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (yn.updateQueue = c),
          (c.lastEffect = u.next = u))
        : ((y = c.lastEffect),
          y === null
            ? (c.lastEffect = u.next = u)
            : ((M = y.next), (y.next = u), (u.next = M), (c.lastEffect = u))),
      u
    );
  }
  function IE() {
    return Ss().memoizedState;
  }
  function Wh(u, c, y, M) {
    var b = Ys();
    (yn.flags |= u),
      (b.memoizedState = Kc(1 | c, y, void 0, M === void 0 ? null : M));
  }
  function Gh(u, c, y, M) {
    var b = Ss();
    M = M === void 0 ? null : M;
    var P = void 0;
    if (mr !== null) {
      var j = mr.memoizedState;
      if (((P = j.destroy), M !== null && ly(M, j.deps))) {
        b.memoizedState = Kc(c, y, P, M);
        return;
      }
    }
    (yn.flags |= u), (b.memoizedState = Kc(1 | c, y, P, M));
  }
  function dy(u, c) {
    return Wh(8390656, 8, u, c);
  }
  function Zc(u, c) {
    return Gh(2048, 8, u, c);
  }
  function NE(u, c) {
    return Gh(4, 2, u, c);
  }
  function OE(u, c) {
    return Gh(4, 4, u, c);
  }
  function DE(u, c) {
    if (typeof c == "function")
      return (
        (u = u()),
        c(u),
        function () {
          c(null);
        }
      );
    if (c != null)
      return (
        (u = u()),
        (c.current = u),
        function () {
          c.current = null;
        }
      );
  }
  function kE(u, c, y) {
    return (
      (y = y != null ? y.concat([u]) : null), Gh(4, 4, DE.bind(null, c, u), y)
    );
  }
  function hy() {}
  function UE(u, c) {
    var y = Ss();
    c = c === void 0 ? null : c;
    var M = y.memoizedState;
    return M !== null && c !== null && ly(c, M[1])
      ? M[0]
      : ((y.memoizedState = [u, c]), u);
  }
  function FE(u, c) {
    var y = Ss();
    c = c === void 0 ? null : c;
    var M = y.memoizedState;
    return M !== null && c !== null && ly(c, M[1])
      ? M[0]
      : ((u = u()), (y.memoizedState = [u, c]), u);
  }
  function NO(u, c) {
    var y = Dt;
    (Dt = y !== 0 && 4 > y ? y : 4), u(!0);
    var M = Li.transition;
    Li.transition = {};
    try {
      u(!1), c();
    } finally {
      (Dt = y), (Li.transition = M);
    }
  }
  function zE() {
    return Ss().memoizedState;
  }
  function OO(u, c, y) {
    var M = No(u);
    (y = {
      lane: M,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      BE(u)
        ? HE(c, y)
        : (VE(u, c, y),
          (y = Dr()),
          (u = Ii(u, M, y)),
          u !== null && WE(u, c, M));
  }
  function DO(u, c, y) {
    var M = No(u),
      b = {
        lane: M,
        action: y,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (BE(u)) HE(c, b);
    else {
      VE(u, c, b);
      var P = u.alternate;
      if (
        u.lanes === 0 &&
        (P === null || P.lanes === 0) &&
        ((P = c.lastRenderedReducer), P !== null)
      )
        try {
          var j = c.lastRenderedState,
            ee = P(j, y);
          if (((b.hasEagerState = !0), (b.eagerState = ee), vs(ee, j))) return;
        } catch {
        } finally {
        }
      (y = Dr()), (u = Ii(u, M, y)), u !== null && WE(u, c, M);
    }
  }
  function BE(u) {
    var c = u.alternate;
    return u === yn || (c !== null && c === yn);
  }
  function HE(u, c) {
    Yc = Bh = !0;
    var y = u.pending;
    y === null ? (c.next = c) : ((c.next = y.next), (y.next = c)),
      (u.pending = c);
  }
  function VE(u, c, y) {
    On !== null && u.mode & 1 && !(Ct & 2)
      ? ((u = c.interleaved),
        u === null
          ? ((y.next = y), xs === null ? (xs = [c]) : xs.push(c))
          : ((y.next = u.next), (u.next = y)),
        (c.interleaved = y))
      : ((u = c.pending),
        u === null ? (y.next = y) : ((y.next = u.next), (u.next = y)),
        (c.pending = y));
  }
  function WE(u, c, y) {
    if (y & 4194240) {
      var M = c.lanes;
      (M &= u.pendingLanes), (y |= M), (c.lanes = y), Hv(u, y);
    }
  }
  var jh = {
      readContext: Ai,
      useCallback: gr,
      useContext: gr,
      useEffect: gr,
      useImperativeHandle: gr,
      useInsertionEffect: gr,
      useLayoutEffect: gr,
      useMemo: gr,
      useReducer: gr,
      useRef: gr,
      useState: gr,
      useDebugValue: gr,
      useDeferredValue: gr,
      useTransition: gr,
      useMutableSource: gr,
      useSyncExternalStore: gr,
      useId: gr,
      unstable_isNewReconciler: !1,
    },
    kO = {
      readContext: Ai,
      useCallback: function (u, c) {
        return (Ys().memoizedState = [u, c === void 0 ? null : c]), u;
      },
      useContext: Ai,
      useEffect: dy,
      useImperativeHandle: function (u, c, y) {
        return (
          (y = y != null ? y.concat([u]) : null),
          Wh(4194308, 4, DE.bind(null, c, u), y)
        );
      },
      useLayoutEffect: function (u, c) {
        return Wh(4194308, 4, u, c);
      },
      useInsertionEffect: function (u, c) {
        return Wh(4, 2, u, c);
      },
      useMemo: function (u, c) {
        var y = Ys();
        return (
          (c = c === void 0 ? null : c),
          (u = u()),
          (y.memoizedState = [u, c]),
          u
        );
      },
      useReducer: function (u, c, y) {
        var M = Ys();
        return (
          (c = y !== void 0 ? y(c) : c),
          (M.memoizedState = M.baseState = c),
          (u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: u,
            lastRenderedState: c,
          }),
          (M.queue = u),
          (u = u.dispatch = OO.bind(null, yn, u)),
          [M.memoizedState, u]
        );
      },
      useRef: function (u) {
        var c = Ys();
        return (u = { current: u }), (c.memoizedState = u);
      },
      useState: fy,
      useDebugValue: hy,
      useDeferredValue: function (u) {
        var c = fy(u),
          y = c[0],
          M = c[1];
        return (
          dy(
            function () {
              var b = Li.transition;
              Li.transition = {};
              try {
                M(u);
              } finally {
                Li.transition = b;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = fy(!1),
          c = u[0];
        return (u = NO.bind(null, u[1])), (Ys().memoizedState = u), [c, u];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (u, c, y) {
        var M = yn,
          b = Ys();
        if (on) {
          if (y === void 0) throw Error(o(407));
          y = y();
        } else {
          if (((y = c()), On === null)) throw Error(o(349));
          Ql & 30 || CE(M, c, y);
        }
        b.memoizedState = y;
        var P = { value: y, getSnapshot: c };
        return (
          (b.queue = P),
          dy(PE.bind(null, M, P, u), [u]),
          (M.flags |= 2048),
          Kc(9, RE.bind(null, M, P, y, c), void 0, null),
          y
        );
      },
      useId: function () {
        var u = Ys(),
          c = On.identifierPrefix;
        if (on) {
          var y = Xs,
            M = $s;
          (y = (M & ~(1 << (32 - si(M) - 1))).toString(32) + y),
            (c = ":" + c + "R" + y),
            (y = qc++),
            0 < y && (c += "H" + y.toString(32)),
            (c += ":");
        } else (y = IO++), (c = ":" + c + "r" + y.toString(32) + ":");
        return (u.memoizedState = c);
      },
      unstable_isNewReconciler: !1,
    },
    UO = {
      readContext: Ai,
      useCallback: UE,
      useContext: Ai,
      useEffect: Zc,
      useImperativeHandle: kE,
      useInsertionEffect: NE,
      useLayoutEffect: OE,
      useMemo: FE,
      useReducer: Hh,
      useRef: IE,
      useState: function () {
        return Hh(La);
      },
      useDebugValue: hy,
      useDeferredValue: function (u) {
        var c = Hh(La),
          y = c[0],
          M = c[1];
        return (
          Zc(
            function () {
              var b = Li.transition;
              Li.transition = {};
              try {
                M(u);
              } finally {
                Li.transition = b;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = Hh(La)[0],
          c = Ss().memoizedState;
        return [u, c];
      },
      useMutableSource: TE,
      useSyncExternalStore: AE,
      useId: zE,
      unstable_isNewReconciler: !1,
    },
    FO = {
      readContext: Ai,
      useCallback: UE,
      useContext: Ai,
      useEffect: Zc,
      useImperativeHandle: kE,
      useInsertionEffect: NE,
      useLayoutEffect: OE,
      useMemo: FE,
      useReducer: Vh,
      useRef: IE,
      useState: function () {
        return Vh(La);
      },
      useDebugValue: hy,
      useDeferredValue: function (u) {
        var c = Vh(La),
          y = c[0],
          M = c[1];
        return (
          Zc(
            function () {
              var b = Li.transition;
              Li.transition = {};
              try {
                M(u);
              } finally {
                Li.transition = b;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = Vh(La)[0],
          c = Ss().memoizedState;
        return [u, c];
      },
      useMutableSource: TE,
      useSyncExternalStore: AE,
      useId: zE,
      unstable_isNewReconciler: !1,
    };
  function py(u, c) {
    try {
      var y = "",
        M = c;
      do (y += LO(M)), (M = M.return);
      while (M);
      var b = y;
    } catch (P) {
      b =
        `
Error generating stack: ` +
        P.message +
        `
` +
        P.stack;
    }
    return { value: u, source: c, stack: b };
  }
  function my(u, c) {
    try {
      console.error(c.value);
    } catch (y) {
      setTimeout(function () {
        throw y;
      });
    }
  }
  var zO = typeof WeakMap == "function" ? WeakMap : Map;
  function GE(u, c, y) {
    (y = js(-1, y)), (y.tag = 3), (y.payload = { element: null });
    var M = c.value;
    return (
      (y.callback = function () {
        ap || ((ap = !0), (Ny = M)), my(u, c);
      }),
      y
    );
  }
  function jE(u, c, y) {
    (y = js(-1, y)), (y.tag = 3);
    var M = u.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var b = c.value;
      (y.payload = function () {
        return M(b);
      }),
        (y.callback = function () {
          my(u, c);
        });
    }
    var P = u.stateNode;
    return (
      P !== null &&
        typeof P.componentDidCatch == "function" &&
        (y.callback = function () {
          my(u, c),
            typeof M != "function" &&
              (Lo === null ? (Lo = new Set([this])) : Lo.add(this));
          var j = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: j !== null ? j : "",
          });
        }),
      y
    );
  }
  function $E(u, c, y) {
    var M = u.pingCache;
    if (M === null) {
      M = u.pingCache = new zO();
      var b = new Set();
      M.set(c, b);
    } else (b = M.get(c)), b === void 0 && ((b = new Set()), M.set(c, b));
    b.has(y) || (b.add(y), (u = QO.bind(null, u, c, y)), c.then(u, u));
  }
  function XE(u) {
    do {
      var c;
      if (
        ((c = u.tag === 13) &&
          ((c = u.memoizedState),
          (c = c !== null ? c.dehydrated !== null : !0)),
        c)
      )
        return u;
      u = u.return;
    } while (u !== null);
    return null;
  }
  function YE(u, c, y, M, b) {
    return u.mode & 1
      ? ((u.flags |= 65536), (u.lanes = b), u)
      : (u === c
          ? (u.flags |= 65536)
          : ((u.flags |= 128),
            (y.flags |= 131072),
            (y.flags &= -52805),
            y.tag === 1 &&
              (y.alternate === null
                ? (y.tag = 17)
                : ((c = js(-1, 1)), (c.tag = 2), Po(y, c))),
            (y.lanes |= 1)),
        u);
  }
  function ws(u) {
    u.flags |= 4;
  }
  function qE(u, c) {
    if (u !== null && u.child === c.child) return !0;
    if (c.flags & 16) return !1;
    for (u = c.child; u !== null; ) {
      if (u.flags & 12854 || u.subtreeFlags & 12854) return !1;
      u = u.sibling;
    }
    return !0;
  }
  var Jc, Qc, $h, Xh;
  if (Le)
    (Jc = function (u, c) {
      for (var y = c.child; y !== null; ) {
        if (y.tag === 5 || y.tag === 6) oe(u, y.stateNode);
        else if (y.tag !== 4 && y.child !== null) {
          (y.child.return = y), (y = y.child);
          continue;
        }
        if (y === c) break;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === c) return;
          y = y.return;
        }
        (y.sibling.return = y.return), (y = y.sibling);
      }
    }),
      (Qc = function () {}),
      ($h = function (u, c, y, M, b) {
        if (((u = u.memoizedProps), u !== M)) {
          var P = c.stateNode,
            j = _s(Pi.current);
          (y = ae(P, y, u, M, b, j)), (c.updateQueue = y) && ws(c);
        }
      }),
      (Xh = function (u, c, y, M) {
        y !== M && ws(c);
      });
  else if (H) {
    Jc = function (u, c, y, M) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var P = b.stateNode;
          y && M && (P = qt(P, b.type, b.memoizedProps, b)), oe(u, P);
        } else if (b.tag === 6)
          (P = b.stateNode),
            y && M && (P = sn(P, b.memoizedProps, b)),
            oe(u, P);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null)
            (P = b.child), P !== null && (P.return = b), Jc(u, b, !0, !0);
          else if (b.child !== null) {
            (b.child.return = b), (b = b.child);
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      }
    };
    var KE = function (u, c, y, M) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var P = b.stateNode;
          y && M && (P = qt(P, b.type, b.memoizedProps, b)), Oe(u, P);
        } else if (b.tag === 6)
          (P = b.stateNode),
            y && M && (P = sn(P, b.memoizedProps, b)),
            Oe(u, P);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null)
            (P = b.child), P !== null && (P.return = b), KE(u, b, !0, !0);
          else if (b.child !== null) {
            (b.child.return = b), (b = b.child);
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      }
    };
    (Qc = function (u, c) {
      var y = c.stateNode;
      if (!qE(u, c)) {
        u = y.containerInfo;
        var M = ye(u);
        KE(M, c, !1, !1), (y.pendingChildren = M), ws(c), nt(u, M);
      }
    }),
      ($h = function (u, c, y, M, b) {
        var P = u.stateNode,
          j = u.memoizedProps;
        if ((u = qE(u, c)) && j === M) c.stateNode = P;
        else {
          var ee = c.stateNode,
            ge = _s(Pi.current),
            Ue = null;
          j !== M && (Ue = ae(ee, y, j, M, b, ge)),
            u && Ue === null
              ? (c.stateNode = P)
              : ((P = ke(P, Ue, y, j, M, c, u, ee)),
                J(P, y, M, b, ge) && ws(c),
                (c.stateNode = P),
                u ? ws(c) : Jc(P, c, !1, !1));
        }
      }),
      (Xh = function (u, c, y, M) {
        y !== M
          ? ((u = _s(Zl.current)),
            (y = _s(Pi.current)),
            (c.stateNode = Ie(M, u, y, c)),
            ws(c))
          : (c.stateNode = u.stateNode);
      });
  } else (Qc = function () {}), ($h = function () {}), (Xh = function () {});
  function ef(u, c) {
    if (!on)
      switch (u.tailMode) {
        case "hidden":
          c = u.tail;
          for (var y = null; c !== null; )
            c.alternate !== null && (y = c), (c = c.sibling);
          y === null ? (u.tail = null) : (y.sibling = null);
          break;
        case "collapsed":
          y = u.tail;
          for (var M = null; y !== null; )
            y.alternate !== null && (M = y), (y = y.sibling);
          M === null
            ? c || u.tail === null
              ? (u.tail = null)
              : (u.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function vr(u) {
    var c = u.alternate !== null && u.alternate.child === u.child,
      y = 0,
      M = 0;
    if (c)
      for (var b = u.child; b !== null; )
        (y |= b.lanes | b.childLanes),
          (M |= b.subtreeFlags & 14680064),
          (M |= b.flags & 14680064),
          (b.return = u),
          (b = b.sibling);
    else
      for (b = u.child; b !== null; )
        (y |= b.lanes | b.childLanes),
          (M |= b.subtreeFlags),
          (M |= b.flags),
          (b.return = u),
          (b = b.sibling);
    return (u.subtreeFlags |= M), (u.childLanes = y), c;
  }
  function BO(u, c, y) {
    var M = c.pendingProps;
    switch ((ey(c), c.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return vr(c), null;
      case 1:
        return Kn(c.type) && En(), vr(c), null;
      case 3:
        return (
          (M = c.stateNode),
          Jl(),
          dt(vn),
          dt(At),
          ay(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (u === null || u.child === null) &&
            (Gc(c)
              ? ws(c)
              : u === null ||
                (u.memoizedState.isDehydrated && !(c.flags & 256)) ||
                ((c.flags |= 1024), Yi !== null && (ky(Yi), (Yi = null)))),
          Qc(u, c),
          vr(c),
          null
        );
      case 5:
        sy(c), (y = _s(Zl.current));
        var b = c.type;
        if (u !== null && c.stateNode != null)
          $h(u, c, b, M, y),
            u.ref !== c.ref && ((c.flags |= 512), (c.flags |= 2097152));
        else {
          if (!M) {
            if (c.stateNode === null) throw Error(o(166));
            return vr(c), null;
          }
          if (((u = _s(Pi.current)), Gc(c))) {
            if (!pe) throw Error(o(175));
            (u = kv(c.stateNode, c.type, c.memoizedProps, y, u, c, !Wc)),
              (c.updateQueue = u),
              u !== null && ws(c);
          } else {
            var P = te(b, M, y, u, c);
            Jc(P, c, !1, !1), (c.stateNode = P), J(P, b, M, y, u) && ws(c);
          }
          c.ref !== null && ((c.flags |= 512), (c.flags |= 2097152));
        }
        return vr(c), null;
      case 6:
        if (u && c.stateNode != null) Xh(u, c, u.memoizedProps, M);
        else {
          if (typeof M != "string" && c.stateNode === null) throw Error(o(166));
          if (((u = _s(Zl.current)), (y = _s(Pi.current)), Gc(c))) {
            if (!pe) throw Error(o(176));
            if (
              ((u = c.stateNode),
              (M = c.memoizedProps),
              (y = Uv(u, M, c, !Wc)) && ((b = oi), b !== null))
            )
              switch (((P = (b.mode & 1) !== 0), b.tag)) {
                case 3:
                  st(b.stateNode.containerInfo, u, M, P);
                  break;
                case 5:
                  ct(b.type, b.memoizedProps, b.stateNode, u, M, P);
              }
            y && ws(c);
          } else c.stateNode = Ie(M, u, y, c);
        }
        return vr(c), null;
      case 13:
        if (
          (dt(fn),
          (M = c.memoizedState),
          on && ai !== null && c.mode & 1 && !(c.flags & 128))
        ) {
          for (u = ai; u; ) u = Co(u);
          return ql(), (c.flags |= 98560), c;
        }
        if (M !== null && M.dehydrated !== null) {
          if (((M = Gc(c)), u === null)) {
            if (!M) throw Error(o(318));
            if (!pe) throw Error(o(344));
            if (
              ((u = c.memoizedState),
              (u = u !== null ? u.dehydrated : null),
              !u)
            )
              throw Error(o(317));
            Fv(u, c);
          } else
            ql(), !(c.flags & 128) && (c.memoizedState = null), (c.flags |= 4);
          return vr(c), null;
        }
        return (
          Yi !== null && (ky(Yi), (Yi = null)),
          c.flags & 128
            ? ((c.lanes = y), c)
            : ((M = M !== null),
              (y = !1),
              u === null ? Gc(c) : (y = u.memoizedState !== null),
              M &&
                !y &&
                ((c.child.flags |= 8192),
                c.mode & 1 &&
                  (u === null || fn.current & 1 ? Hn === 0 && (Hn = 3) : Fy())),
              c.updateQueue !== null && (c.flags |= 4),
              vr(c),
              null)
        );
      case 4:
        return (
          Jl(),
          Qc(u, c),
          u === null && we(c.stateNode.containerInfo),
          vr(c),
          null
        );
      case 10:
        return Yv(c.type._context), vr(c), null;
      case 17:
        return Kn(c.type) && En(), vr(c), null;
      case 19:
        if ((dt(fn), (b = c.memoizedState), b === null)) return vr(c), null;
        if (((M = (c.flags & 128) !== 0), (P = b.rendering), P === null))
          if (M) ef(b, !1);
          else {
            if (Hn !== 0 || (u !== null && u.flags & 128))
              for (u = c.child; u !== null; ) {
                if (((P = Fh(u)), P !== null)) {
                  for (
                    c.flags |= 128,
                      ef(b, !1),
                      u = P.updateQueue,
                      u !== null && ((c.updateQueue = u), (c.flags |= 4)),
                      c.subtreeFlags = 0,
                      u = y,
                      M = c.child;
                    M !== null;

                  )
                    (y = M),
                      (b = u),
                      (y.flags &= 14680066),
                      (P = y.alternate),
                      P === null
                        ? ((y.childLanes = 0),
                          (y.lanes = b),
                          (y.child = null),
                          (y.subtreeFlags = 0),
                          (y.memoizedProps = null),
                          (y.memoizedState = null),
                          (y.updateQueue = null),
                          (y.dependencies = null),
                          (y.stateNode = null))
                        : ((y.childLanes = P.childLanes),
                          (y.lanes = P.lanes),
                          (y.child = P.child),
                          (y.subtreeFlags = 0),
                          (y.deletions = null),
                          (y.memoizedProps = P.memoizedProps),
                          (y.memoizedState = P.memoizedState),
                          (y.updateQueue = P.updateQueue),
                          (y.type = P.type),
                          (b = P.dependencies),
                          (y.dependencies =
                            b === null
                              ? null
                              : {
                                  lanes: b.lanes,
                                  firstContext: b.firstContext,
                                })),
                      (M = M.sibling);
                  return Je(fn, (fn.current & 1) | 2), c.child;
                }
                u = u.sibling;
              }
            b.tail !== null &&
              Zn() > Iy &&
              ((c.flags |= 128), (M = !0), ef(b, !1), (c.lanes = 4194304));
          }
        else {
          if (!M)
            if (((u = Fh(P)), u !== null)) {
              if (
                ((c.flags |= 128),
                (M = !0),
                (u = u.updateQueue),
                u !== null && ((c.updateQueue = u), (c.flags |= 4)),
                ef(b, !0),
                b.tail === null &&
                  b.tailMode === "hidden" &&
                  !P.alternate &&
                  !on)
              )
                return vr(c), null;
            } else
              2 * Zn() - b.renderingStartTime > Iy &&
                y !== 1073741824 &&
                ((c.flags |= 128), (M = !0), ef(b, !1), (c.lanes = 4194304));
          b.isBackwards
            ? ((P.sibling = c.child), (c.child = P))
            : ((u = b.last),
              u !== null ? (u.sibling = P) : (c.child = P),
              (b.last = P));
        }
        return b.tail !== null
          ? ((c = b.tail),
            (b.rendering = c),
            (b.tail = c.sibling),
            (b.renderingStartTime = Zn()),
            (c.sibling = null),
            (u = fn.current),
            Je(fn, M ? (u & 1) | 2 : u & 1),
            c)
          : (vr(c), null);
      case 22:
      case 23:
        return (
          Uy(),
          (M = c.memoizedState !== null),
          u !== null && (u.memoizedState !== null) !== M && (c.flags |= 8192),
          M && c.mode & 1
            ? ui & 1073741824 &&
              (vr(c), Le && c.subtreeFlags & 6 && (c.flags |= 8192))
            : vr(c),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, c.tag));
  }
  var HO = a.ReactCurrentOwner,
    li = !1;
  function Or(u, c, y, M) {
    c.child = u === null ? EE(c, null, y, M) : Kl(c, u.child, y, M);
  }
  function ZE(u, c, y, M, b) {
    y = y.render;
    var P = c.ref;
    return (
      $l(c, b),
      (M = uy(u, c, y, M, P, b)),
      (y = cy()),
      u !== null && !li
        ? ((c.updateQueue = u.updateQueue),
          (c.flags &= -2053),
          (u.lanes &= ~b),
          qs(u, c, b))
        : (on && y && Qv(c), (c.flags |= 1), Or(u, c, M, b), c.child)
    );
  }
  function JE(u, c, y, M, b) {
    if (u === null) {
      var P = y.type;
      return typeof P == "function" &&
        !zy(P) &&
        P.defaultProps === void 0 &&
        y.compare === null &&
        y.defaultProps === void 0
        ? ((c.tag = 15), (c.type = P), QE(u, c, P, M, b))
        : ((u = pp(y.type, null, M, c, c.mode, b)),
          (u.ref = c.ref),
          (u.return = c),
          (c.child = u));
    }
    if (((P = u.child), !(u.lanes & b))) {
      var j = P.memoizedProps;
      if (
        ((y = y.compare), (y = y !== null ? y : Rh), y(j, M) && u.ref === c.ref)
      )
        return qs(u, c, b);
    }
    return (
      (c.flags |= 1),
      (u = Do(P, M)),
      (u.ref = c.ref),
      (u.return = c),
      (c.child = u)
    );
  }
  function QE(u, c, y, M, b) {
    if (u !== null && Rh(u.memoizedProps, M) && u.ref === c.ref)
      if (((li = !1), (u.lanes & b) !== 0)) u.flags & 131072 && (li = !0);
      else return (c.lanes = u.lanes), qs(u, c, b);
    return gy(u, c, y, M, b);
  }
  function eb(u, c, y) {
    var M = c.pendingProps,
      b = M.children,
      P = u !== null ? u.memoizedState : null;
    if (M.mode === "hidden")
      if (!(c.mode & 1))
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          Je(eu, ui),
          (ui |= y);
      else if (y & 1073741824)
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          (M = P !== null ? P.baseLanes : y),
          Je(eu, ui),
          (ui |= M);
      else
        return (
          (u = P !== null ? P.baseLanes | y : y),
          (c.lanes = c.childLanes = 1073741824),
          (c.memoizedState = { baseLanes: u, cachePool: null }),
          (c.updateQueue = null),
          Je(eu, ui),
          (ui |= u),
          null
        );
    else
      P !== null ? ((M = P.baseLanes | y), (c.memoizedState = null)) : (M = y),
        Je(eu, ui),
        (ui |= M);
    return Or(u, c, b, y), c.child;
  }
  function tb(u, c) {
    var y = c.ref;
    ((u === null && y !== null) || (u !== null && u.ref !== y)) &&
      ((c.flags |= 512), (c.flags |= 2097152));
  }
  function gy(u, c, y, M, b) {
    var P = Kn(y) ? ps : At.current;
    return (
      (P = Ti(c, P)),
      $l(c, b),
      (y = uy(u, c, y, M, P, b)),
      (M = cy()),
      u !== null && !li
        ? ((c.updateQueue = u.updateQueue),
          (c.flags &= -2053),
          (u.lanes &= ~b),
          qs(u, c, b))
        : (on && M && Qv(c), (c.flags |= 1), Or(u, c, y, b), c.child)
    );
  }
  function nb(u, c, y, M, b) {
    if (Kn(y)) {
      var P = !0;
      ar(c);
    } else P = !1;
    if (($l(c, b), c.stateNode === null))
      u !== null &&
        ((u.alternate = null), (c.alternate = null), (c.flags |= 2)),
        gE(c, y, M),
        Jv(c, y, M, b),
        (M = !0);
    else if (u === null) {
      var j = c.stateNode,
        ee = c.memoizedProps;
      j.props = ee;
      var ge = j.context,
        Ue = y.contextType;
      typeof Ue == "object" && Ue !== null
        ? (Ue = Ai(Ue))
        : ((Ue = Kn(y) ? ps : At.current), (Ue = Ti(c, Ue)));
      var Qe = y.getDerivedStateFromProps,
        vt =
          typeof Qe == "function" ||
          typeof j.getSnapshotBeforeUpdate == "function";
      vt ||
        (typeof j.UNSAFE_componentWillReceiveProps != "function" &&
          typeof j.componentWillReceiveProps != "function") ||
        ((ee !== M || ge !== Ue) && vE(c, j, M, Ue)),
        (Ro = !1);
      var lt = c.memoizedState;
      (j.state = lt),
        Nh(c, M, j, b),
        (ge = c.memoizedState),
        ee !== M || lt !== ge || vn.current || Ro
          ? (typeof Qe == "function" &&
              (Zv(c, y, Qe, M), (ge = c.memoizedState)),
            (ee = Ro || mE(c, y, ee, M, lt, ge, Ue))
              ? (vt ||
                  (typeof j.UNSAFE_componentWillMount != "function" &&
                    typeof j.componentWillMount != "function") ||
                  (typeof j.componentWillMount == "function" &&
                    j.componentWillMount(),
                  typeof j.UNSAFE_componentWillMount == "function" &&
                    j.UNSAFE_componentWillMount()),
                typeof j.componentDidMount == "function" &&
                  (c.flags |= 4194308))
              : (typeof j.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                (c.memoizedProps = M),
                (c.memoizedState = ge)),
            (j.props = M),
            (j.state = ge),
            (j.context = Ue),
            (M = ee))
          : (typeof j.componentDidMount == "function" && (c.flags |= 4194308),
            (M = !1));
    } else {
      (j = c.stateNode),
        fE(u, c),
        (ee = c.memoizedProps),
        (Ue = c.type === c.elementType ? ee : Xi(c.type, ee)),
        (j.props = Ue),
        (vt = c.pendingProps),
        (lt = j.context),
        (ge = y.contextType),
        typeof ge == "object" && ge !== null
          ? (ge = Ai(ge))
          : ((ge = Kn(y) ? ps : At.current), (ge = Ti(c, ge)));
      var Kt = y.getDerivedStateFromProps;
      (Qe =
        typeof Kt == "function" ||
        typeof j.getSnapshotBeforeUpdate == "function") ||
        (typeof j.UNSAFE_componentWillReceiveProps != "function" &&
          typeof j.componentWillReceiveProps != "function") ||
        ((ee !== vt || lt !== ge) && vE(c, j, M, ge)),
        (Ro = !1),
        (lt = c.memoizedState),
        (j.state = lt),
        Nh(c, M, j, b);
      var ot = c.memoizedState;
      ee !== vt || lt !== ot || vn.current || Ro
        ? (typeof Kt == "function" && (Zv(c, y, Kt, M), (ot = c.memoizedState)),
          (Ue = Ro || mE(c, y, Ue, M, lt, ot, ge) || !1)
            ? (Qe ||
                (typeof j.UNSAFE_componentWillUpdate != "function" &&
                  typeof j.componentWillUpdate != "function") ||
                (typeof j.componentWillUpdate == "function" &&
                  j.componentWillUpdate(M, ot, ge),
                typeof j.UNSAFE_componentWillUpdate == "function" &&
                  j.UNSAFE_componentWillUpdate(M, ot, ge)),
              typeof j.componentDidUpdate == "function" && (c.flags |= 4),
              typeof j.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
            : (typeof j.componentDidUpdate != "function" ||
                (ee === u.memoizedProps && lt === u.memoizedState) ||
                (c.flags |= 4),
              typeof j.getSnapshotBeforeUpdate != "function" ||
                (ee === u.memoizedProps && lt === u.memoizedState) ||
                (c.flags |= 1024),
              (c.memoizedProps = M),
              (c.memoizedState = ot)),
          (j.props = M),
          (j.state = ot),
          (j.context = ge),
          (M = Ue))
        : (typeof j.componentDidUpdate != "function" ||
            (ee === u.memoizedProps && lt === u.memoizedState) ||
            (c.flags |= 4),
          typeof j.getSnapshotBeforeUpdate != "function" ||
            (ee === u.memoizedProps && lt === u.memoizedState) ||
            (c.flags |= 1024),
          (M = !1));
    }
    return vy(u, c, y, M, P, b);
  }
  function vy(u, c, y, M, b, P) {
    tb(u, c);
    var j = (c.flags & 128) !== 0;
    if (!M && !j) return b && Gl(c, y, !1), qs(u, c, P);
    (M = c.stateNode), (HO.current = c);
    var ee =
      j && typeof y.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (c.flags |= 1),
      u !== null && j
        ? ((c.child = Kl(c, u.child, null, P)), (c.child = Kl(c, null, ee, P)))
        : Or(u, c, ee, P),
      (c.memoizedState = M.state),
      b && Gl(c, y, !0),
      c.child
    );
  }
  function rb(u) {
    var c = u.stateNode;
    c.pendingContext
      ? ms(u, c.pendingContext, c.pendingContext !== c.context)
      : c.context && ms(u, c.context, !1),
      iy(u, c.containerInfo);
  }
  function ib(u, c, y, M, b) {
    return ql(), ry(b), (c.flags |= 256), Or(u, c, y, M), c.child;
  }
  var Yh = { dehydrated: null, treeContext: null, retryLane: 0 };
  function qh(u) {
    return { baseLanes: u, cachePool: null };
  }
  function sb(u, c, y) {
    var M = c.pendingProps,
      b = fn.current,
      P = !1,
      j = (c.flags & 128) !== 0,
      ee;
    if (
      ((ee = j) ||
        (ee = u !== null && u.memoizedState === null ? !1 : (b & 2) !== 0),
      ee
        ? ((P = !0), (c.flags &= -129))
        : (u === null || u.memoizedState !== null) && (b |= 1),
      Je(fn, b & 1),
      u === null)
    )
      return (
        ny(c),
        (u = c.memoizedState),
        u !== null && ((u = u.dehydrated), u !== null)
          ? (c.mode & 1
              ? Bc(u)
                ? (c.lanes = 8)
                : (c.lanes = 1073741824)
              : (c.lanes = 1),
            null)
          : ((b = M.children),
            (u = M.fallback),
            P
              ? ((M = c.mode),
                (P = c.child),
                (b = { mode: "hidden", children: b }),
                !(M & 1) && P !== null
                  ? ((P.childLanes = 0), (P.pendingProps = b))
                  : (P = mp(b, M, 0, null)),
                (u = Ua(u, M, y, null)),
                (P.return = c),
                (u.return = c),
                (P.sibling = u),
                (c.child = P),
                (c.child.memoizedState = qh(y)),
                (c.memoizedState = Yh),
                u)
              : yy(c, b))
      );
    if (((b = u.memoizedState), b !== null)) {
      if (((ee = b.dehydrated), ee !== null)) {
        if (j)
          return c.flags & 256
            ? ((c.flags &= -257), Kh(u, c, y, Error(o(422))))
            : c.memoizedState !== null
            ? ((c.child = u.child), (c.flags |= 128), null)
            : ((P = M.fallback),
              (b = c.mode),
              (M = mp({ mode: "visible", children: M.children }, b, 0, null)),
              (P = Ua(P, b, y, null)),
              (P.flags |= 2),
              (M.return = c),
              (P.return = c),
              (M.sibling = P),
              (c.child = M),
              c.mode & 1 && Kl(c, u.child, null, y),
              (c.child.memoizedState = qh(y)),
              (c.memoizedState = Yh),
              P);
        if (!(c.mode & 1)) c = Kh(u, c, y, null);
        else if (Bc(ee)) c = Kh(u, c, y, Error(o(419)));
        else if (((M = (y & u.childLanes) !== 0), li || M)) {
          if (((M = On), M !== null)) {
            switch (y & -y) {
              case 4:
                P = 2;
                break;
              case 16:
                P = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                P = 32;
                break;
              case 536870912:
                P = 268435456;
                break;
              default:
                P = 0;
            }
            (M = P & (M.suspendedLanes | y) ? 0 : P),
              M !== 0 && M !== b.retryLane && ((b.retryLane = M), Ii(u, M, -1));
          }
          Fy(), (c = Kh(u, c, y, Error(o(421))));
        } else
          zc(ee)
            ? ((c.flags |= 128),
              (c.child = u.child),
              (c = eD.bind(null, u)),
              Hl(ee, c),
              (c = null))
            : ((y = b.treeContext),
              pe &&
                ((ai = wh(ee)),
                (oi = c),
                (on = !0),
                (Yi = null),
                (Wc = !1),
                y !== null &&
                  ((Ci[Ri++] = $s),
                  (Ci[Ri++] = Xs),
                  (Ci[Ri++] = Ra),
                  ($s = y.id),
                  (Xs = y.overflow),
                  (Ra = c))),
              (c = yy(c, c.pendingProps.children)),
              (c.flags |= 4096));
        return c;
      }
      return P
        ? ((M = ab(u, c, M.children, M.fallback, y)),
          (P = c.child),
          (b = u.child.memoizedState),
          (P.memoizedState =
            b === null
              ? qh(y)
              : { baseLanes: b.baseLanes | y, cachePool: null }),
          (P.childLanes = u.childLanes & ~y),
          (c.memoizedState = Yh),
          M)
        : ((y = ob(u, c, M.children, y)), (c.memoizedState = null), y);
    }
    return P
      ? ((M = ab(u, c, M.children, M.fallback, y)),
        (P = c.child),
        (b = u.child.memoizedState),
        (P.memoizedState =
          b === null ? qh(y) : { baseLanes: b.baseLanes | y, cachePool: null }),
        (P.childLanes = u.childLanes & ~y),
        (c.memoizedState = Yh),
        M)
      : ((y = ob(u, c, M.children, y)), (c.memoizedState = null), y);
  }
  function yy(u, c) {
    return (
      (c = mp({ mode: "visible", children: c }, u.mode, 0, null)),
      (c.return = u),
      (u.child = c)
    );
  }
  function ob(u, c, y, M) {
    var b = u.child;
    return (
      (u = b.sibling),
      (y = Do(b, { mode: "visible", children: y })),
      !(c.mode & 1) && (y.lanes = M),
      (y.return = c),
      (y.sibling = null),
      u !== null &&
        ((M = c.deletions),
        M === null ? ((c.deletions = [u]), (c.flags |= 16)) : M.push(u)),
      (c.child = y)
    );
  }
  function ab(u, c, y, M, b) {
    var P = c.mode;
    u = u.child;
    var j = u.sibling,
      ee = { mode: "hidden", children: y };
    return (
      !(P & 1) && c.child !== u
        ? ((y = c.child),
          (y.childLanes = 0),
          (y.pendingProps = ee),
          (c.deletions = null))
        : ((y = Do(u, ee)), (y.subtreeFlags = u.subtreeFlags & 14680064)),
      j !== null ? (M = Do(j, M)) : ((M = Ua(M, P, b, null)), (M.flags |= 2)),
      (M.return = c),
      (y.return = c),
      (y.sibling = M),
      (c.child = y),
      M
    );
  }
  function Kh(u, c, y, M) {
    return (
      M !== null && ry(M),
      Kl(c, u.child, null, y),
      (u = yy(c, c.pendingProps.children)),
      (u.flags |= 2),
      (c.memoizedState = null),
      u
    );
  }
  function lb(u, c, y) {
    u.lanes |= c;
    var M = u.alternate;
    M !== null && (M.lanes |= c), qv(u.return, c, y);
  }
  function xy(u, c, y, M, b) {
    var P = u.memoizedState;
    P === null
      ? (u.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: y,
          tailMode: b,
        })
      : ((P.isBackwards = c),
        (P.rendering = null),
        (P.renderingStartTime = 0),
        (P.last = M),
        (P.tail = y),
        (P.tailMode = b));
  }
  function ub(u, c, y) {
    var M = c.pendingProps,
      b = M.revealOrder,
      P = M.tail;
    if ((Or(u, c, M.children, y), (M = fn.current), M & 2))
      (M = (M & 1) | 2), (c.flags |= 128);
    else {
      if (u !== null && u.flags & 128)
        e: for (u = c.child; u !== null; ) {
          if (u.tag === 13) u.memoizedState !== null && lb(u, y, c);
          else if (u.tag === 19) lb(u, y, c);
          else if (u.child !== null) {
            (u.child.return = u), (u = u.child);
            continue;
          }
          if (u === c) break e;
          for (; u.sibling === null; ) {
            if (u.return === null || u.return === c) break e;
            u = u.return;
          }
          (u.sibling.return = u.return), (u = u.sibling);
        }
      M &= 1;
    }
    if ((Je(fn, M), !(c.mode & 1))) c.memoizedState = null;
    else
      switch (b) {
        case "forwards":
          for (y = c.child, b = null; y !== null; )
            (u = y.alternate),
              u !== null && Fh(u) === null && (b = y),
              (y = y.sibling);
          (y = b),
            y === null
              ? ((b = c.child), (c.child = null))
              : ((b = y.sibling), (y.sibling = null)),
            xy(c, !1, b, y, P);
          break;
        case "backwards":
          for (y = null, b = c.child, c.child = null; b !== null; ) {
            if (((u = b.alternate), u !== null && Fh(u) === null)) {
              c.child = b;
              break;
            }
            (u = b.sibling), (b.sibling = y), (y = b), (b = u);
          }
          xy(c, !0, y, null, P);
          break;
        case "together":
          xy(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function qs(u, c, y) {
    if (
      (u !== null && (c.dependencies = u.dependencies),
      (tu |= c.lanes),
      !(y & c.childLanes))
    )
      return null;
    if (u !== null && c.child !== u.child) throw Error(o(153));
    if (c.child !== null) {
      for (
        u = c.child, y = Do(u, u.pendingProps), c.child = y, y.return = c;
        u.sibling !== null;

      )
        (u = u.sibling),
          (y = y.sibling = Do(u, u.pendingProps)),
          (y.return = c);
      y.sibling = null;
    }
    return c.child;
  }
  function VO(u, c, y) {
    switch (c.tag) {
      case 3:
        rb(c), ql();
        break;
      case 5:
        bE(c);
        break;
      case 1:
        Kn(c.type) && ar(c);
        break;
      case 4:
        iy(c, c.stateNode.containerInfo);
        break;
      case 10:
        cE(c, c.type._context, c.memoizedProps.value);
        break;
      case 13:
        var M = c.memoizedState;
        if (M !== null)
          return M.dehydrated !== null
            ? (Je(fn, fn.current & 1), (c.flags |= 128), null)
            : y & c.child.childLanes
            ? sb(u, c, y)
            : (Je(fn, fn.current & 1),
              (u = qs(u, c, y)),
              u !== null ? u.sibling : null);
        Je(fn, fn.current & 1);
        break;
      case 19:
        if (((M = (y & c.childLanes) !== 0), u.flags & 128)) {
          if (M) return ub(u, c, y);
          c.flags |= 128;
        }
        var b = c.memoizedState;
        if (
          (b !== null &&
            ((b.rendering = null), (b.tail = null), (b.lastEffect = null)),
          Je(fn, fn.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return (c.lanes = 0), eb(u, c, y);
    }
    return qs(u, c, y);
  }
  function WO(u, c) {
    switch ((ey(c), c.tag)) {
      case 1:
        return (
          Kn(c.type) && En(),
          (u = c.flags),
          u & 65536 ? ((c.flags = (u & -65537) | 128), c) : null
        );
      case 3:
        return (
          Jl(),
          dt(vn),
          dt(At),
          ay(),
          (u = c.flags),
          u & 65536 && !(u & 128) ? ((c.flags = (u & -65537) | 128), c) : null
        );
      case 5:
        return sy(c), null;
      case 13:
        if (
          (dt(fn), (u = c.memoizedState), u !== null && u.dehydrated !== null)
        ) {
          if (c.alternate === null) throw Error(o(340));
          ql();
        }
        return (
          (u = c.flags), u & 65536 ? ((c.flags = (u & -65537) | 128), c) : null
        );
      case 19:
        return dt(fn), null;
      case 4:
        return Jl(), null;
      case 10:
        return Yv(c.type._context), null;
      case 22:
      case 23:
        return Uy(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Zh = !1,
    Ia = !1,
    GO = typeof WeakSet == "function" ? WeakSet : Set,
    Ge = null;
  function Jh(u, c) {
    var y = u.ref;
    if (y !== null)
      if (typeof y == "function")
        try {
          y(null);
        } catch (M) {
          Yr(u, c, M);
        }
      else y.current = null;
  }
  function _y(u, c, y) {
    try {
      y();
    } catch (M) {
      Yr(u, c, M);
    }
  }
  var cb = !1;
  function jO(u, c) {
    for (G(u.containerInfo), Ge = c; Ge !== null; )
      if (
        ((u = Ge), (c = u.child), (u.subtreeFlags & 1028) !== 0 && c !== null)
      )
        (c.return = u), (Ge = c);
      else
        for (; Ge !== null; ) {
          u = Ge;
          try {
            var y = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var M = y.memoizedProps,
                      b = y.memoizedState,
                      P = u.stateNode,
                      j = P.getSnapshotBeforeUpdate(
                        u.elementType === u.type ? M : Xi(u.type, M),
                        b
                      );
                    P.__reactInternalSnapshotBeforeUpdate = j;
                  }
                  break;
                case 3:
                  Le && ze(u.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (ee) {
            Yr(u, u.return, ee);
          }
          if (((c = u.sibling), c !== null)) {
            (c.return = u.return), (Ge = c);
            break;
          }
          Ge = u.return;
        }
    return (y = cb), (cb = !1), y;
  }
  function Na(u, c, y) {
    var M = c.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var b = (M = M.next);
      do {
        if ((b.tag & u) === u) {
          var P = b.destroy;
          (b.destroy = void 0), P !== void 0 && _y(c, y, P);
        }
        b = b.next;
      } while (b !== M);
    }
  }
  function tf(u, c) {
    if (
      ((c = c.updateQueue), (c = c !== null ? c.lastEffect : null), c !== null)
    ) {
      var y = (c = c.next);
      do {
        if ((y.tag & u) === u) {
          var M = y.create;
          y.destroy = M();
        }
        y = y.next;
      } while (y !== c);
    }
  }
  function Sy(u) {
    var c = u.ref;
    if (c !== null) {
      var y = u.stateNode;
      switch (u.tag) {
        case 5:
          u = Y(y);
          break;
        default:
          u = y;
      }
      typeof c == "function" ? c(u) : (c.current = u);
    }
  }
  function fb(u, c, y) {
    if (gs && typeof gs.onCommitFiberUnmount == "function")
      try {
        gs.onCommitFiberUnmount(Ah, c);
      } catch {}
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((u = c.updateQueue), u !== null && ((u = u.lastEffect), u !== null))
        ) {
          var M = (u = u.next);
          do {
            var b = M,
              P = b.destroy;
            (b = b.tag),
              P !== void 0 && (b & 2 || b & 4) && _y(c, y, P),
              (M = M.next);
          } while (M !== u);
        }
        break;
      case 1:
        if (
          (Jh(c, y),
          (u = c.stateNode),
          typeof u.componentWillUnmount == "function")
        )
          try {
            (u.props = c.memoizedProps),
              (u.state = c.memoizedState),
              u.componentWillUnmount();
          } catch (j) {
            Yr(c, y, j);
          }
        break;
      case 5:
        Jh(c, y);
        break;
      case 4:
        Le
          ? vb(u, c, y)
          : H && H && ((c = c.stateNode.containerInfo), (y = ye(c)), xt(c, y));
    }
  }
  function db(u, c, y) {
    for (var M = c; ; )
      if ((fb(u, M, y), M.child === null || (Le && M.tag === 4))) {
        if (M === c) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === c) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      } else (M.child.return = M), (M = M.child);
  }
  function hb(u) {
    var c = u.alternate;
    c !== null && ((u.alternate = null), hb(c)),
      (u.child = null),
      (u.deletions = null),
      (u.sibling = null),
      u.tag === 5 && ((c = u.stateNode), c !== null && $e(c)),
      (u.stateNode = null),
      (u.return = null),
      (u.dependencies = null),
      (u.memoizedProps = null),
      (u.memoizedState = null),
      (u.pendingProps = null),
      (u.stateNode = null),
      (u.updateQueue = null);
  }
  function pb(u) {
    return u.tag === 5 || u.tag === 3 || u.tag === 4;
  }
  function mb(u) {
    e: for (;;) {
      for (; u.sibling === null; ) {
        if (u.return === null || pb(u.return)) return null;
        u = u.return;
      }
      for (
        u.sibling.return = u.return, u = u.sibling;
        u.tag !== 5 && u.tag !== 6 && u.tag !== 18;

      ) {
        if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
        (u.child.return = u), (u = u.child);
      }
      if (!(u.flags & 2)) return u.stateNode;
    }
  }
  function gb(u) {
    if (Le) {
      e: {
        for (var c = u.return; c !== null; ) {
          if (pb(c)) break e;
          c = c.return;
        }
        throw Error(o(160));
      }
      var y = c;
      switch (y.tag) {
        case 5:
          (c = y.stateNode),
            y.flags & 32 && (me(c), (y.flags &= -33)),
            (y = mb(u)),
            My(u, y, c);
          break;
        case 3:
        case 4:
          (c = y.stateNode.containerInfo), (y = mb(u)), wy(u, y, c);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function wy(u, c, y) {
    var M = u.tag;
    if (M === 5 || M === 6) (u = u.stateNode), c ? Ne(y, u, c) : Ye(y, u);
    else if (M !== 4 && ((u = u.child), u !== null))
      for (wy(u, c, y), u = u.sibling; u !== null; )
        wy(u, c, y), (u = u.sibling);
  }
  function My(u, c, y) {
    var M = u.tag;
    if (M === 5 || M === 6) (u = u.stateNode), c ? wt(y, u, c) : Ae(y, u);
    else if (M !== 4 && ((u = u.child), u !== null))
      for (My(u, c, y), u = u.sibling; u !== null; )
        My(u, c, y), (u = u.sibling);
  }
  function vb(u, c, y) {
    for (var M = c, b = !1, P, j; ; ) {
      if (!b) {
        b = M.return;
        e: for (;;) {
          if (b === null) throw Error(o(160));
          switch (((P = b.stateNode), b.tag)) {
            case 5:
              j = !1;
              break e;
            case 3:
              (P = P.containerInfo), (j = !0);
              break e;
            case 4:
              (P = P.containerInfo), (j = !0);
              break e;
          }
          b = b.return;
        }
        b = !0;
      }
      if (M.tag === 5 || M.tag === 6)
        db(u, M, y), j ? q(P, M.stateNode) : Pt(P, M.stateNode);
      else if (M.tag === 18) j ? ce(P, M.stateNode) : he(P, M.stateNode);
      else if (M.tag === 4) {
        if (M.child !== null) {
          (P = M.stateNode.containerInfo),
            (j = !0),
            (M.child.return = M),
            (M = M.child);
          continue;
        }
      } else if ((fb(u, M, y), M.child !== null)) {
        (M.child.return = M), (M = M.child);
        continue;
      }
      if (M === c) break;
      for (; M.sibling === null; ) {
        if (M.return === null || M.return === c) return;
        (M = M.return), M.tag === 4 && (b = !1);
      }
      (M.sibling.return = M.return), (M = M.sibling);
    }
  }
  function Ey(u, c) {
    if (Le) {
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Na(3, c, c.return), tf(3, c), Na(5, c, c.return);
          return;
        case 1:
          return;
        case 5:
          var y = c.stateNode;
          if (y != null) {
            var M = c.memoizedProps;
            u = u !== null ? u.memoizedProps : M;
            var b = c.type,
              P = c.updateQueue;
            (c.updateQueue = null), P !== null && at(y, P, b, u, M, c);
          }
          return;
        case 6:
          if (c.stateNode === null) throw Error(o(162));
          (y = c.memoizedProps),
            Pe(c.stateNode, u !== null ? u.memoizedProps : y, y);
          return;
        case 3:
          pe &&
            u !== null &&
            u.memoizedState.isDehydrated &&
            re(c.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Qh(c);
          return;
        case 19:
          Qh(c);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Na(3, c, c.return), tf(3, c), Na(5, c, c.return);
        return;
      case 12:
        return;
      case 13:
        Qh(c);
        return;
      case 19:
        Qh(c);
        return;
      case 3:
        pe &&
          u !== null &&
          u.memoizedState.isDehydrated &&
          re(c.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (H) {
      switch (c.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (c = c.stateNode), xt(c.containerInfo, c.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Qh(u) {
    var c = u.updateQueue;
    if (c !== null) {
      u.updateQueue = null;
      var y = u.stateNode;
      y === null && (y = u.stateNode = new GO()),
        c.forEach(function (M) {
          var b = tD.bind(null, u, M);
          y.has(M) || (y.add(M), M.then(b, b));
        });
    }
  }
  function $O(u, c) {
    for (Ge = c; Ge !== null; ) {
      c = Ge;
      var y = c.deletions;
      if (y !== null)
        for (var M = 0; M < y.length; M++) {
          var b = y[M];
          try {
            var P = u;
            Le ? vb(P, b, c) : db(P, b, c);
            var j = b.alternate;
            j !== null && (j.return = null), (b.return = null);
          } catch (rt) {
            Yr(b, c, rt);
          }
        }
      if (((y = c.child), c.subtreeFlags & 12854 && y !== null))
        (y.return = c), (Ge = y);
      else
        for (; Ge !== null; ) {
          c = Ge;
          try {
            var ee = c.flags;
            if ((ee & 32 && Le && me(c.stateNode), ee & 512)) {
              var ge = c.alternate;
              if (ge !== null) {
                var Ue = ge.ref;
                Ue !== null &&
                  (typeof Ue == "function" ? Ue(null) : (Ue.current = null));
              }
            }
            if (ee & 8192)
              switch (c.tag) {
                case 13:
                  if (c.memoizedState !== null) {
                    var Qe = c.alternate;
                    (Qe === null || Qe.memoizedState === null) && (Ly = Zn());
                  }
                  break;
                case 22:
                  var vt = c.memoizedState !== null,
                    lt = c.alternate,
                    Kt = lt !== null && lt.memoizedState !== null;
                  if (((y = c), Le)) {
                    e: if (((M = y), (b = vt), (P = null), Le))
                      for (var ot = M; ; ) {
                        if (ot.tag === 5) {
                          if (P === null) {
                            P = ot;
                            var yr = ot.stateNode;
                            b ? be(yr) : Be(ot.stateNode, ot.memoizedProps);
                          }
                        } else if (ot.tag === 6) {
                          if (P === null) {
                            var Oi = ot.stateNode;
                            b ? ue(Oi) : K(Oi, ot.memoizedProps);
                          }
                        } else if (
                          ((ot.tag !== 22 && ot.tag !== 23) ||
                            ot.memoizedState === null ||
                            ot === M) &&
                          ot.child !== null
                        ) {
                          (ot.child.return = ot), (ot = ot.child);
                          continue;
                        }
                        if (ot === M) break;
                        for (; ot.sibling === null; ) {
                          if (ot.return === null || ot.return === M) break e;
                          P === ot && (P = null), (ot = ot.return);
                        }
                        P === ot && (P = null),
                          (ot.sibling.return = ot.return),
                          (ot = ot.sibling);
                      }
                  }
                  if (vt && !Kt && y.mode & 1) {
                    Ge = y;
                    for (var le = y.child; le !== null; ) {
                      for (y = Ge = le; Ge !== null; ) {
                        M = Ge;
                        var ne = M.child;
                        switch (M.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Na(4, M, M.return);
                            break;
                          case 1:
                            Jh(M, M.return);
                            var de = M.stateNode;
                            if (typeof de.componentWillUnmount == "function") {
                              var je = M.return;
                              try {
                                (de.props = M.memoizedProps),
                                  (de.state = M.memoizedState),
                                  de.componentWillUnmount();
                              } catch (rt) {
                                Yr(M, je, rt);
                              }
                            }
                            break;
                          case 5:
                            Jh(M, M.return);
                            break;
                          case 22:
                            if (M.memoizedState !== null) {
                              _b(y);
                              continue;
                            }
                        }
                        ne !== null ? ((ne.return = M), (Ge = ne)) : _b(y);
                      }
                      le = le.sibling;
                    }
                  }
              }
            switch (ee & 4102) {
              case 2:
                gb(c), (c.flags &= -3);
                break;
              case 6:
                gb(c), (c.flags &= -3), Ey(c.alternate, c);
                break;
              case 4096:
                c.flags &= -4097;
                break;
              case 4100:
                (c.flags &= -4097), Ey(c.alternate, c);
                break;
              case 4:
                Ey(c.alternate, c);
            }
          } catch (rt) {
            Yr(c, c.return, rt);
          }
          if (((y = c.sibling), y !== null)) {
            (y.return = c.return), (Ge = y);
            break;
          }
          Ge = c.return;
        }
    }
  }
  function XO(u, c, y) {
    (Ge = u), yb(u);
  }
  function yb(u, c, y) {
    for (var M = (u.mode & 1) !== 0; Ge !== null; ) {
      var b = Ge,
        P = b.child;
      if (b.tag === 22 && M) {
        var j = b.memoizedState !== null || Zh;
        if (!j) {
          var ee = b.alternate,
            ge = (ee !== null && ee.memoizedState !== null) || Ia;
          ee = Zh;
          var Ue = Ia;
          if (((Zh = j), (Ia = ge) && !Ue))
            for (Ge = b; Ge !== null; )
              (j = Ge),
                (ge = j.child),
                j.tag === 22 && j.memoizedState !== null
                  ? Sb(b)
                  : ge !== null
                  ? ((ge.return = j), (Ge = ge))
                  : Sb(b);
          for (; P !== null; ) (Ge = P), yb(P), (P = P.sibling);
          (Ge = b), (Zh = ee), (Ia = Ue);
        }
        xb(u);
      } else
        b.subtreeFlags & 8772 && P !== null
          ? ((P.return = b), (Ge = P))
          : xb(u);
    }
  }
  function xb(u) {
    for (; Ge !== null; ) {
      var c = Ge;
      if (c.flags & 8772) {
        var y = c.alternate;
        try {
          if (c.flags & 8772)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                Ia || tf(5, c);
                break;
              case 1:
                var M = c.stateNode;
                if (c.flags & 4 && !Ia)
                  if (y === null) M.componentDidMount();
                  else {
                    var b =
                      c.elementType === c.type
                        ? y.memoizedProps
                        : Xi(c.type, y.memoizedProps);
                    M.componentDidUpdate(
                      b,
                      y.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var P = c.updateQueue;
                P !== null && hE(c, P, M);
                break;
              case 3:
                var j = c.updateQueue;
                if (j !== null) {
                  if (((y = null), c.child !== null))
                    switch (c.child.tag) {
                      case 5:
                        y = Y(c.child.stateNode);
                        break;
                      case 1:
                        y = c.child.stateNode;
                    }
                  hE(c, j, y);
                }
                break;
              case 5:
                var ee = c.stateNode;
                y === null && c.flags & 4 && Te(ee, c.type, c.memoizedProps, c);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (pe && c.memoizedState === null) {
                  var ge = c.alternate;
                  if (ge !== null) {
                    var Ue = ge.memoizedState;
                    if (Ue !== null) {
                      var Qe = Ue.dehydrated;
                      Qe !== null && fe(Qe);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          Ia || (c.flags & 512 && Sy(c));
        } catch (vt) {
          Yr(c, c.return, vt);
        }
      }
      if (c === u) {
        Ge = null;
        break;
      }
      if (((y = c.sibling), y !== null)) {
        (y.return = c.return), (Ge = y);
        break;
      }
      Ge = c.return;
    }
  }
  function _b(u) {
    for (; Ge !== null; ) {
      var c = Ge;
      if (c === u) {
        Ge = null;
        break;
      }
      var y = c.sibling;
      if (y !== null) {
        (y.return = c.return), (Ge = y);
        break;
      }
      Ge = c.return;
    }
  }
  function Sb(u) {
    for (; Ge !== null; ) {
      var c = Ge;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var y = c.return;
            try {
              tf(4, c);
            } catch (ge) {
              Yr(c, y, ge);
            }
            break;
          case 1:
            var M = c.stateNode;
            if (typeof M.componentDidMount == "function") {
              var b = c.return;
              try {
                M.componentDidMount();
              } catch (ge) {
                Yr(c, b, ge);
              }
            }
            var P = c.return;
            try {
              Sy(c);
            } catch (ge) {
              Yr(c, P, ge);
            }
            break;
          case 5:
            var j = c.return;
            try {
              Sy(c);
            } catch (ge) {
              Yr(c, j, ge);
            }
        }
      } catch (ge) {
        Yr(c, c.return, ge);
      }
      if (c === u) {
        Ge = null;
        break;
      }
      var ee = c.sibling;
      if (ee !== null) {
        (ee.return = c.return), (Ge = ee);
        break;
      }
      Ge = c.return;
    }
  }
  var ep = 0,
    tp = 1,
    np = 2,
    rp = 3,
    ip = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var nf = Symbol.for;
    (ep = nf("selector.component")),
      (tp = nf("selector.has_pseudo_class")),
      (np = nf("selector.role")),
      (rp = nf("selector.test_id")),
      (ip = nf("selector.text"));
  }
  function by(u) {
    var c = ie(u);
    if (c != null) {
      if (typeof c.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return c;
    }
    if (((u = it(u)), u === null)) throw Error(o(362));
    return u.stateNode.current;
  }
  function Ty(u, c) {
    switch (c.$$typeof) {
      case ep:
        if (u.type === c.value) return !0;
        break;
      case tp:
        e: {
          (c = c.value), (u = [u, 0]);
          for (var y = 0; y < u.length; ) {
            var M = u[y++],
              b = u[y++],
              P = c[b];
            if (M.tag !== 5 || !O(M)) {
              for (; P != null && Ty(M, P); ) b++, (P = c[b]);
              if (b === c.length) {
                c = !0;
                break e;
              } else
                for (M = M.child; M !== null; ) u.push(M, b), (M = M.sibling);
            }
          }
          c = !1;
        }
        return c;
      case np:
        if (u.tag === 5 && se(u.stateNode, c.value)) return !0;
        break;
      case ip:
        if (
          (u.tag === 5 || u.tag === 6) &&
          ((u = V(u)), u !== null && 0 <= u.indexOf(c.value))
        )
          return !0;
        break;
      case rp:
        if (
          u.tag === 5 &&
          ((u = u.memoizedProps["data-testname"]),
          typeof u == "string" && u.toLowerCase() === c.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function Ay(u) {
    switch (u.$$typeof) {
      case ep:
        return "<" + (L(u.value) || "Unknown") + ">";
      case tp:
        return ":has(" + (Ay(u) || "") + ")";
      case np:
        return '[role="' + u.value + '"]';
      case ip:
        return '"' + u.value + '"';
      case rp:
        return '[data-testname="' + u.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function wb(u, c) {
    var y = [];
    u = [u, 0];
    for (var M = 0; M < u.length; ) {
      var b = u[M++],
        P = u[M++],
        j = c[P];
      if (b.tag !== 5 || !O(b)) {
        for (; j != null && Ty(b, j); ) P++, (j = c[P]);
        if (P === c.length) y.push(b);
        else for (b = b.child; b !== null; ) u.push(b, P), (b = b.sibling);
      }
    }
    return y;
  }
  function Cy(u, c) {
    if (!Ze) throw Error(o(363));
    (u = by(u)), (u = wb(u, c)), (c = []), (u = Array.from(u));
    for (var y = 0; y < u.length; ) {
      var M = u[y++];
      if (M.tag === 5) O(M) || c.push(M.stateNode);
      else for (M = M.child; M !== null; ) u.push(M), (M = M.sibling);
    }
    return c;
  }
  var YO = Math.ceil,
    sp = a.ReactCurrentDispatcher,
    Ry = a.ReactCurrentOwner,
    bn = a.ReactCurrentBatchConfig,
    Ct = 0,
    On = null,
    Dn = null,
    lr = 0,
    ui = 0,
    eu = qn(0),
    Hn = 0,
    rf = null,
    tu = 0,
    op = 0,
    Py = 0,
    sf = null,
    $r = null,
    Ly = 0,
    Iy = 1 / 0;
  function nu() {
    Iy = Zn() + 500;
  }
  var ap = !1,
    Ny = null,
    Lo = null,
    lp = !1,
    Io = null,
    up = 0,
    of = 0,
    Oy = null,
    cp = -1,
    fp = 0;
  function Dr() {
    return Ct & 6 ? Zn() : cp !== -1 ? cp : (cp = Zn());
  }
  function No(u) {
    return u.mode & 1
      ? Ct & 2 && lr !== 0
        ? lr & -lr
        : PO.transition !== null
        ? (fp === 0 &&
            ((u = Eh), (Eh <<= 1), !(Eh & 4194240) && (Eh = 64), (fp = u)),
          fp)
        : ((u = Dt), u !== 0 ? u : xe())
      : 1;
  }
  function Ii(u, c, y) {
    if (50 < of) throw ((of = 0), (Oy = null), Error(o(185)));
    var M = dp(u, c);
    return M === null
      ? null
      : (Vc(M, c, y),
        (!(Ct & 2) || M !== On) &&
          (M === On && (!(Ct & 2) && (op |= c), Hn === 4 && Oo(M, lr)),
          Xr(M, y),
          c === 1 && Ct === 0 && !(u.mode & 1) && (nu(), Ch && ys())),
        M);
  }
  function dp(u, c) {
    u.lanes |= c;
    var y = u.alternate;
    for (y !== null && (y.lanes |= c), y = u, u = u.return; u !== null; )
      (u.childLanes |= c),
        (y = u.alternate),
        y !== null && (y.childLanes |= c),
        (y = u),
        (u = u.return);
    return y.tag === 3 ? y.stateNode : null;
  }
  function Xr(u, c) {
    var y = u.callbackNode;
    SO(u, c);
    var M = Th(u, u === On ? lr : 0);
    if (M === 0)
      y !== null && lE(y), (u.callbackNode = null), (u.callbackPriority = 0);
    else if (((c = M & -M), u.callbackPriority !== c)) {
      if ((y != null && lE(y), c === 1))
        u.tag === 0 ? RO(Eb.bind(null, u)) : uE(Eb.bind(null, u)),
          Fe
            ? He(function () {
                Ct === 0 && ys();
              })
            : Vv(Wv, ys),
          (y = null);
      else {
        switch (aE(M)) {
          case 1:
            y = Wv;
            break;
          case 4:
            y = bO;
            break;
          case 16:
            y = Gv;
            break;
          case 536870912:
            y = TO;
            break;
          default:
            y = Gv;
        }
        y = Nb(y, Mb.bind(null, u));
      }
      (u.callbackPriority = c), (u.callbackNode = y);
    }
  }
  function Mb(u, c) {
    if (((cp = -1), (fp = 0), Ct & 6)) throw Error(o(327));
    var y = u.callbackNode;
    if (ka() && u.callbackNode !== y) return null;
    var M = Th(u, u === On ? lr : 0);
    if (M === 0) return null;
    if (M & 30 || M & u.expiredLanes || c) c = hp(u, M);
    else {
      c = M;
      var b = Ct;
      Ct |= 2;
      var P = Ab();
      (On !== u || lr !== c) && (nu(), Oa(u, c));
      do
        try {
          ZO();
          break;
        } catch (ee) {
          Tb(u, ee);
        }
      while (!0);
      Xv(),
        (sp.current = P),
        (Ct = b),
        Dn !== null ? (c = 0) : ((On = null), (lr = 0), (c = Hn));
    }
    if (c !== 0) {
      if (
        (c === 2 && ((b = zv(u)), b !== 0 && ((M = b), (c = Dy(u, b)))),
        c === 1)
      )
        throw ((y = rf), Oa(u, 0), Oo(u, M), Xr(u, Zn()), y);
      if (c === 6) Oo(u, M);
      else {
        if (
          ((b = u.current.alternate),
          !(M & 30) &&
            !qO(b) &&
            ((c = hp(u, M)),
            c === 2 && ((P = zv(u)), P !== 0 && ((M = P), (c = Dy(u, P)))),
            c === 1))
        )
          throw ((y = rf), Oa(u, 0), Oo(u, M), Xr(u, Zn()), y);
        switch (((u.finishedWork = b), (u.finishedLanes = M), c)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            Da(u, $r);
            break;
          case 3:
            if (
              (Oo(u, M),
              (M & 130023424) === M && ((c = Ly + 500 - Zn()), 10 < c))
            ) {
              if (Th(u, 0) !== 0) break;
              if (((b = u.suspendedLanes), (b & M) !== M)) {
                Dr(), (u.pingedLanes |= u.suspendedLanes & b);
                break;
              }
              u.timeoutHandle = Ce(Da.bind(null, u, $r), c);
              break;
            }
            Da(u, $r);
            break;
          case 4:
            if ((Oo(u, M), (M & 4194240) === M)) break;
            for (c = u.eventTimes, b = -1; 0 < M; ) {
              var j = 31 - si(M);
              (P = 1 << j), (j = c[j]), j > b && (b = j), (M &= ~P);
            }
            if (
              ((M = b),
              (M = Zn() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                  ? 480
                  : 1080 > M
                  ? 1080
                  : 1920 > M
                  ? 1920
                  : 3e3 > M
                  ? 3e3
                  : 4320 > M
                  ? 4320
                  : 1960 * YO(M / 1960)) - M),
              10 < M)
            ) {
              u.timeoutHandle = Ce(Da.bind(null, u, $r), M);
              break;
            }
            Da(u, $r);
            break;
          case 5:
            Da(u, $r);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Xr(u, Zn()), u.callbackNode === y ? Mb.bind(null, u) : null;
  }
  function Dy(u, c) {
    var y = sf;
    return (
      u.current.memoizedState.isDehydrated && (Oa(u, c).flags |= 256),
      (u = hp(u, c)),
      u !== 2 && ((c = $r), ($r = y), c !== null && ky(c)),
      u
    );
  }
  function ky(u) {
    $r === null ? ($r = u) : $r.push.apply($r, u);
  }
  function qO(u) {
    for (var c = u; ; ) {
      if (c.flags & 16384) {
        var y = c.updateQueue;
        if (y !== null && ((y = y.stores), y !== null))
          for (var M = 0; M < y.length; M++) {
            var b = y[M],
              P = b.getSnapshot;
            b = b.value;
            try {
              if (!vs(P(), b)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((y = c.child), c.subtreeFlags & 16384 && y !== null))
        (y.return = c), (c = y);
      else {
        if (c === u) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === u) return !0;
          c = c.return;
        }
        (c.sibling.return = c.return), (c = c.sibling);
      }
    }
    return !0;
  }
  function Oo(u, c) {
    for (
      c &= ~Py,
        c &= ~op,
        u.suspendedLanes |= c,
        u.pingedLanes &= ~c,
        u = u.expirationTimes;
      0 < c;

    ) {
      var y = 31 - si(c),
        M = 1 << y;
      (u[y] = -1), (c &= ~M);
    }
  }
  function Eb(u) {
    if (Ct & 6) throw Error(o(327));
    ka();
    var c = Th(u, 0);
    if (!(c & 1)) return Xr(u, Zn()), null;
    var y = hp(u, c);
    if (u.tag !== 0 && y === 2) {
      var M = zv(u);
      M !== 0 && ((c = M), (y = Dy(u, M)));
    }
    if (y === 1) throw ((y = rf), Oa(u, 0), Oo(u, c), Xr(u, Zn()), y);
    if (y === 6) throw Error(o(345));
    return (
      (u.finishedWork = u.current.alternate),
      (u.finishedLanes = c),
      Da(u, $r),
      Xr(u, Zn()),
      null
    );
  }
  function bb(u) {
    Io !== null && Io.tag === 0 && !(Ct & 6) && ka();
    var c = Ct;
    Ct |= 1;
    var y = bn.transition,
      M = Dt;
    try {
      if (((bn.transition = null), (Dt = 1), u)) return u();
    } finally {
      (Dt = M), (bn.transition = y), (Ct = c), !(Ct & 6) && ys();
    }
  }
  function Uy() {
    (ui = eu.current), dt(eu);
  }
  function Oa(u, c) {
    (u.finishedWork = null), (u.finishedLanes = 0);
    var y = u.timeoutHandle;
    if ((y !== We && ((u.timeoutHandle = We), et(y)), Dn !== null))
      for (y = Dn.return; y !== null; ) {
        var M = y;
        switch ((ey(M), M.tag)) {
          case 1:
            (M = M.type.childContextTypes), M != null && En();
            break;
          case 3:
            Jl(), dt(vn), dt(At), ay();
            break;
          case 5:
            sy(M);
            break;
          case 4:
            Jl();
            break;
          case 13:
            dt(fn);
            break;
          case 19:
            dt(fn);
            break;
          case 10:
            Yv(M.type._context);
            break;
          case 22:
          case 23:
            Uy();
        }
        y = y.return;
      }
    if (
      ((On = u),
      (Dn = u = Do(u.current, null)),
      (lr = ui = c),
      (Hn = 0),
      (rf = null),
      (Py = op = tu = 0),
      ($r = sf = null),
      xs !== null)
    ) {
      for (c = 0; c < xs.length; c++)
        if (((y = xs[c]), (M = y.interleaved), M !== null)) {
          y.interleaved = null;
          var b = M.next,
            P = y.pending;
          if (P !== null) {
            var j = P.next;
            (P.next = b), (M.next = j);
          }
          y.pending = M;
        }
      xs = null;
    }
    return u;
  }
  function Tb(u, c) {
    do {
      var y = Dn;
      try {
        if ((Xv(), (zh.current = jh), Bh)) {
          for (var M = yn.memoizedState; M !== null; ) {
            var b = M.queue;
            b !== null && (b.pending = null), (M = M.next);
          }
          Bh = !1;
        }
        if (
          ((Ql = 0),
          (Jn = mr = yn = null),
          (Yc = !1),
          (qc = 0),
          (Ry.current = null),
          y === null || y.return === null)
        ) {
          (Hn = 1), (rf = c), (Dn = null);
          break;
        }
        e: {
          var P = u,
            j = y.return,
            ee = y,
            ge = c;
          if (
            ((c = lr),
            (ee.flags |= 32768),
            ge !== null &&
              typeof ge == "object" &&
              typeof ge.then == "function")
          ) {
            var Ue = ge,
              Qe = ee,
              vt = Qe.tag;
            if (!(Qe.mode & 1) && (vt === 0 || vt === 11 || vt === 15)) {
              var lt = Qe.alternate;
              lt
                ? ((Qe.updateQueue = lt.updateQueue),
                  (Qe.memoizedState = lt.memoizedState),
                  (Qe.lanes = lt.lanes))
                : ((Qe.updateQueue = null), (Qe.memoizedState = null));
            }
            var Kt = XE(j);
            if (Kt !== null) {
              (Kt.flags &= -257),
                YE(Kt, j, ee, P, c),
                Kt.mode & 1 && $E(P, Ue, c),
                (c = Kt),
                (ge = Ue);
              var ot = c.updateQueue;
              if (ot === null) {
                var yr = new Set();
                yr.add(ge), (c.updateQueue = yr);
              } else ot.add(ge);
              break e;
            } else {
              if (!(c & 1)) {
                $E(P, Ue, c), Fy();
                break e;
              }
              ge = Error(o(426));
            }
          } else if (on && ee.mode & 1) {
            var Oi = XE(j);
            if (Oi !== null) {
              !(Oi.flags & 65536) && (Oi.flags |= 256),
                YE(Oi, j, ee, P, c),
                ry(ge);
              break e;
            }
          }
          (P = ge),
            Hn !== 4 && (Hn = 2),
            sf === null ? (sf = [P]) : sf.push(P),
            (ge = py(ge, ee)),
            (ee = j);
          do {
            switch (ee.tag) {
              case 3:
                (ee.flags |= 65536), (c &= -c), (ee.lanes |= c);
                var le = GE(ee, ge, c);
                dE(ee, le);
                break e;
              case 1:
                P = ge;
                var ne = ee.type,
                  de = ee.stateNode;
                if (
                  !(ee.flags & 128) &&
                  (typeof ne.getDerivedStateFromError == "function" ||
                    (de !== null &&
                      typeof de.componentDidCatch == "function" &&
                      (Lo === null || !Lo.has(de))))
                ) {
                  (ee.flags |= 65536), (c &= -c), (ee.lanes |= c);
                  var je = jE(ee, P, c);
                  dE(ee, je);
                  break e;
                }
            }
            ee = ee.return;
          } while (ee !== null);
        }
        Rb(y);
      } catch (rt) {
        (c = rt), Dn === y && y !== null && (Dn = y = y.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Ab() {
    var u = sp.current;
    return (sp.current = jh), u === null ? jh : u;
  }
  function Fy() {
    (Hn === 0 || Hn === 3 || Hn === 2) && (Hn = 4),
      On === null || (!(tu & 268435455) && !(op & 268435455)) || Oo(On, lr);
  }
  function hp(u, c) {
    var y = Ct;
    Ct |= 2;
    var M = Ab();
    (On === u && lr === c) || Oa(u, c);
    do
      try {
        KO();
        break;
      } catch (b) {
        Tb(u, b);
      }
    while (!0);
    if ((Xv(), (Ct = y), (sp.current = M), Dn !== null)) throw Error(o(261));
    return (On = null), (lr = 0), Hn;
  }
  function KO() {
    for (; Dn !== null; ) Cb(Dn);
  }
  function ZO() {
    for (; Dn !== null && !MO(); ) Cb(Dn);
  }
  function Cb(u) {
    var c = Ib(u.alternate, u, ui);
    (u.memoizedProps = u.pendingProps),
      c === null ? Rb(u) : (Dn = c),
      (Ry.current = null);
  }
  function Rb(u) {
    var c = u;
    do {
      var y = c.alternate;
      if (((u = c.return), c.flags & 32768)) {
        if (((y = WO(y, c)), y !== null)) {
          (y.flags &= 32767), (Dn = y);
          return;
        }
        if (u !== null)
          (u.flags |= 32768), (u.subtreeFlags = 0), (u.deletions = null);
        else {
          (Hn = 6), (Dn = null);
          return;
        }
      } else if (((y = BO(y, c, ui)), y !== null)) {
        Dn = y;
        return;
      }
      if (((c = c.sibling), c !== null)) {
        Dn = c;
        return;
      }
      Dn = c = u;
    } while (c !== null);
    Hn === 0 && (Hn = 5);
  }
  function Da(u, c) {
    var y = Dt,
      M = bn.transition;
    try {
      (bn.transition = null), (Dt = 1), JO(u, c, y);
    } finally {
      (bn.transition = M), (Dt = y);
    }
    return null;
  }
  function JO(u, c, y) {
    do ka();
    while (Io !== null);
    if (Ct & 6) throw Error(o(327));
    var M = u.finishedWork,
      b = u.finishedLanes;
    if (M === null) return null;
    if (((u.finishedWork = null), (u.finishedLanes = 0), M === u.current))
      throw Error(o(177));
    (u.callbackNode = null), (u.callbackPriority = 0);
    var P = M.lanes | M.childLanes;
    if (
      (wO(u, P),
      u === On && ((Dn = On = null), (lr = 0)),
      (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
        lp ||
        ((lp = !0),
        Nb(Gv, function () {
          return ka(), null;
        })),
      (P = (M.flags & 15990) !== 0),
      M.subtreeFlags & 15990 || P)
    ) {
      (P = bn.transition), (bn.transition = null);
      var j = Dt;
      Dt = 1;
      var ee = Ct;
      (Ct |= 4),
        (Ry.current = null),
        jO(u, M),
        $O(u, M),
        X(u.containerInfo),
        (u.current = M),
        XO(M),
        EO(),
        (Ct = ee),
        (Dt = j),
        (bn.transition = P);
    } else u.current = M;
    if (
      (lp && ((lp = !1), (Io = u), (up = b)),
      (P = u.pendingLanes),
      P === 0 && (Lo = null),
      AO(M.stateNode),
      Xr(u, Zn()),
      c !== null)
    )
      for (y = u.onRecoverableError, M = 0; M < c.length; M++) y(c[M]);
    if (ap) throw ((ap = !1), (u = Ny), (Ny = null), u);
    return (
      up & 1 && u.tag !== 0 && ka(),
      (P = u.pendingLanes),
      P & 1 ? (u === Oy ? of++ : ((of = 0), (Oy = u))) : (of = 0),
      ys(),
      null
    );
  }
  function ka() {
    if (Io !== null) {
      var u = aE(up),
        c = bn.transition,
        y = Dt;
      try {
        if (((bn.transition = null), (Dt = 16 > u ? 16 : u), Io === null))
          var M = !1;
        else {
          if (((u = Io), (Io = null), (up = 0), Ct & 6)) throw Error(o(331));
          var b = Ct;
          for (Ct |= 4, Ge = u.current; Ge !== null; ) {
            var P = Ge,
              j = P.child;
            if (Ge.flags & 16) {
              var ee = P.deletions;
              if (ee !== null) {
                for (var ge = 0; ge < ee.length; ge++) {
                  var Ue = ee[ge];
                  for (Ge = Ue; Ge !== null; ) {
                    var Qe = Ge;
                    switch (Qe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Na(8, Qe, P);
                    }
                    var vt = Qe.child;
                    if (vt !== null) (vt.return = Qe), (Ge = vt);
                    else
                      for (; Ge !== null; ) {
                        Qe = Ge;
                        var lt = Qe.sibling,
                          Kt = Qe.return;
                        if ((hb(Qe), Qe === Ue)) {
                          Ge = null;
                          break;
                        }
                        if (lt !== null) {
                          (lt.return = Kt), (Ge = lt);
                          break;
                        }
                        Ge = Kt;
                      }
                  }
                }
                var ot = P.alternate;
                if (ot !== null) {
                  var yr = ot.child;
                  if (yr !== null) {
                    ot.child = null;
                    do {
                      var Oi = yr.sibling;
                      (yr.sibling = null), (yr = Oi);
                    } while (yr !== null);
                  }
                }
                Ge = P;
              }
            }
            if (P.subtreeFlags & 2064 && j !== null) (j.return = P), (Ge = j);
            else
              e: for (; Ge !== null; ) {
                if (((P = Ge), P.flags & 2048))
                  switch (P.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Na(9, P, P.return);
                  }
                var le = P.sibling;
                if (le !== null) {
                  (le.return = P.return), (Ge = le);
                  break e;
                }
                Ge = P.return;
              }
          }
          var ne = u.current;
          for (Ge = ne; Ge !== null; ) {
            j = Ge;
            var de = j.child;
            if (j.subtreeFlags & 2064 && de !== null)
              (de.return = j), (Ge = de);
            else
              e: for (j = ne; Ge !== null; ) {
                if (((ee = Ge), ee.flags & 2048))
                  try {
                    switch (ee.tag) {
                      case 0:
                      case 11:
                      case 15:
                        tf(9, ee);
                    }
                  } catch (rt) {
                    Yr(ee, ee.return, rt);
                  }
                if (ee === j) {
                  Ge = null;
                  break e;
                }
                var je = ee.sibling;
                if (je !== null) {
                  (je.return = ee.return), (Ge = je);
                  break e;
                }
                Ge = ee.return;
              }
          }
          if (
            ((Ct = b),
            ys(),
            gs && typeof gs.onPostCommitFiberRoot == "function")
          )
            try {
              gs.onPostCommitFiberRoot(Ah, u);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        (Dt = y), (bn.transition = c);
      }
    }
    return !1;
  }
  function Pb(u, c, y) {
    (c = py(y, c)),
      (c = GE(u, c, 1)),
      Po(u, c),
      (c = Dr()),
      (u = dp(u, 1)),
      u !== null && (Vc(u, 1, c), Xr(u, c));
  }
  function Yr(u, c, y) {
    if (u.tag === 3) Pb(u, u, y);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          Pb(c, u, y);
          break;
        } else if (c.tag === 1) {
          var M = c.stateNode;
          if (
            typeof c.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (Lo === null || !Lo.has(M)))
          ) {
            (u = py(y, u)),
              (u = jE(c, u, 1)),
              Po(c, u),
              (u = Dr()),
              (c = dp(c, 1)),
              c !== null && (Vc(c, 1, u), Xr(c, u));
            break;
          }
        }
        c = c.return;
      }
  }
  function QO(u, c, y) {
    var M = u.pingCache;
    M !== null && M.delete(c),
      (c = Dr()),
      (u.pingedLanes |= u.suspendedLanes & y),
      On === u &&
        (lr & y) === y &&
        (Hn === 4 || (Hn === 3 && (lr & 130023424) === lr && 500 > Zn() - Ly)
          ? Oa(u, 0)
          : (Py |= y)),
      Xr(u, c);
  }
  function Lb(u, c) {
    c === 0 &&
      (u.mode & 1
        ? ((c = bh), (bh <<= 1), !(bh & 130023424) && (bh = 4194304))
        : (c = 1));
    var y = Dr();
    (u = dp(u, c)), u !== null && (Vc(u, c, y), Xr(u, y));
  }
  function eD(u) {
    var c = u.memoizedState,
      y = 0;
    c !== null && (y = c.retryLane), Lb(u, y);
  }
  function tD(u, c) {
    var y = 0;
    switch (u.tag) {
      case 13:
        var M = u.stateNode,
          b = u.memoizedState;
        b !== null && (y = b.retryLane);
        break;
      case 19:
        M = u.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    M !== null && M.delete(c), Lb(u, y);
  }
  var Ib;
  Ib = function (u, c, y) {
    if (u !== null)
      if (u.memoizedProps !== c.pendingProps || vn.current) li = !0;
      else {
        if (!(u.lanes & y) && !(c.flags & 128)) return (li = !1), VO(u, c, y);
        li = !!(u.flags & 131072);
      }
    else (li = !1), on && c.flags & 1048576 && yE(c, kh, c.index);
    switch (((c.lanes = 0), c.tag)) {
      case 2:
        var M = c.type;
        u !== null &&
          ((u.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (u = c.pendingProps);
        var b = Ti(c, At.current);
        $l(c, y), (b = uy(null, c, M, u, b, y));
        var P = cy();
        return (
          (c.flags |= 1),
          typeof b == "object" &&
          b !== null &&
          typeof b.render == "function" &&
          b.$$typeof === void 0
            ? ((c.tag = 1),
              (c.memoizedState = null),
              (c.updateQueue = null),
              Kn(M) ? ((P = !0), ar(c)) : (P = !1),
              (c.memoizedState =
                b.state !== null && b.state !== void 0 ? b.state : null),
              Kv(c),
              (b.updater = Oh),
              (c.stateNode = b),
              (b._reactInternals = c),
              Jv(c, M, u, y),
              (c = vy(null, c, M, !0, P, y)))
            : ((c.tag = 0), on && P && Qv(c), Or(null, c, b, y), (c = c.child)),
          c
        );
      case 16:
        M = c.elementType;
        e: {
          switch (
            (u !== null &&
              ((u.alternate = null), (c.alternate = null), (c.flags |= 2)),
            (u = c.pendingProps),
            (b = M._init),
            (M = b(M._payload)),
            (c.type = M),
            (b = c.tag = rD(M)),
            (u = Xi(M, u)),
            b)
          ) {
            case 0:
              c = gy(null, c, M, u, y);
              break e;
            case 1:
              c = nb(null, c, M, u, y);
              break e;
            case 11:
              c = ZE(null, c, M, u, y);
              break e;
            case 14:
              c = JE(null, c, M, Xi(M.type, u), y);
              break e;
          }
          throw Error(o(306, M, ""));
        }
        return c;
      case 0:
        return (
          (M = c.type),
          (b = c.pendingProps),
          (b = c.elementType === M ? b : Xi(M, b)),
          gy(u, c, M, b, y)
        );
      case 1:
        return (
          (M = c.type),
          (b = c.pendingProps),
          (b = c.elementType === M ? b : Xi(M, b)),
          nb(u, c, M, b, y)
        );
      case 3:
        e: {
          if ((rb(c), u === null)) throw Error(o(387));
          (M = c.pendingProps),
            (P = c.memoizedState),
            (b = P.element),
            fE(u, c),
            Nh(c, M, null, y);
          var j = c.memoizedState;
          if (((M = j.element), pe && P.isDehydrated))
            if (
              ((P = {
                element: M,
                isDehydrated: !1,
                cache: j.cache,
                transitions: j.transitions,
              }),
              (c.updateQueue.baseState = P),
              (c.memoizedState = P),
              c.flags & 256)
            ) {
              (b = Error(o(423))), (c = ib(u, c, M, y, b));
              break e;
            } else if (M !== b) {
              (b = Error(o(424))), (c = ib(u, c, M, y, b));
              break e;
            } else
              for (
                pe &&
                  ((ai = Sh(c.stateNode.containerInfo)),
                  (oi = c),
                  (on = !0),
                  (Yi = null),
                  (Wc = !1)),
                  y = EE(c, null, M, y),
                  c.child = y;
                y;

              )
                (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
          else {
            if ((ql(), M === b)) {
              c = qs(u, c, y);
              break e;
            }
            Or(u, c, M, y);
          }
          c = c.child;
        }
        return c;
      case 5:
        return (
          bE(c),
          u === null && ny(c),
          (M = c.type),
          (b = c.pendingProps),
          (P = u !== null ? u.memoizedProps : null),
          (j = b.children),
          Se(M, b) ? (j = null) : P !== null && Se(M, P) && (c.flags |= 32),
          tb(u, c),
          Or(u, c, j, y),
          c.child
        );
      case 6:
        return u === null && ny(c), null;
      case 13:
        return sb(u, c, y);
      case 4:
        return (
          iy(c, c.stateNode.containerInfo),
          (M = c.pendingProps),
          u === null ? (c.child = Kl(c, null, M, y)) : Or(u, c, M, y),
          c.child
        );
      case 11:
        return (
          (M = c.type),
          (b = c.pendingProps),
          (b = c.elementType === M ? b : Xi(M, b)),
          ZE(u, c, M, b, y)
        );
      case 7:
        return Or(u, c, c.pendingProps, y), c.child;
      case 8:
        return Or(u, c, c.pendingProps.children, y), c.child;
      case 12:
        return Or(u, c, c.pendingProps.children, y), c.child;
      case 10:
        e: {
          if (
            ((M = c.type._context),
            (b = c.pendingProps),
            (P = c.memoizedProps),
            (j = b.value),
            cE(c, M, j),
            P !== null)
          )
            if (vs(P.value, j)) {
              if (P.children === b.children && !vn.current) {
                c = qs(u, c, y);
                break e;
              }
            } else
              for (P = c.child, P !== null && (P.return = c); P !== null; ) {
                var ee = P.dependencies;
                if (ee !== null) {
                  j = P.child;
                  for (var ge = ee.firstContext; ge !== null; ) {
                    if (ge.context === M) {
                      if (P.tag === 1) {
                        (ge = js(-1, y & -y)), (ge.tag = 2);
                        var Ue = P.updateQueue;
                        if (Ue !== null) {
                          Ue = Ue.shared;
                          var Qe = Ue.pending;
                          Qe === null
                            ? (ge.next = ge)
                            : ((ge.next = Qe.next), (Qe.next = ge)),
                            (Ue.pending = ge);
                        }
                      }
                      (P.lanes |= y),
                        (ge = P.alternate),
                        ge !== null && (ge.lanes |= y),
                        qv(P.return, y, c),
                        (ee.lanes |= y);
                      break;
                    }
                    ge = ge.next;
                  }
                } else if (P.tag === 10) j = P.type === c.type ? null : P.child;
                else if (P.tag === 18) {
                  if (((j = P.return), j === null)) throw Error(o(341));
                  (j.lanes |= y),
                    (ee = j.alternate),
                    ee !== null && (ee.lanes |= y),
                    qv(j, y, c),
                    (j = P.sibling);
                } else j = P.child;
                if (j !== null) j.return = P;
                else
                  for (j = P; j !== null; ) {
                    if (j === c) {
                      j = null;
                      break;
                    }
                    if (((P = j.sibling), P !== null)) {
                      (P.return = j.return), (j = P);
                      break;
                    }
                    j = j.return;
                  }
                P = j;
              }
          Or(u, c, b.children, y), (c = c.child);
        }
        return c;
      case 9:
        return (
          (b = c.type),
          (M = c.pendingProps.children),
          $l(c, y),
          (b = Ai(b)),
          (M = M(b)),
          (c.flags |= 1),
          Or(u, c, M, y),
          c.child
        );
      case 14:
        return (
          (M = c.type),
          (b = Xi(M, c.pendingProps)),
          (b = Xi(M.type, b)),
          JE(u, c, M, b, y)
        );
      case 15:
        return QE(u, c, c.type, c.pendingProps, y);
      case 17:
        return (
          (M = c.type),
          (b = c.pendingProps),
          (b = c.elementType === M ? b : Xi(M, b)),
          u !== null &&
            ((u.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (c.tag = 1),
          Kn(M) ? ((u = !0), ar(c)) : (u = !1),
          $l(c, y),
          gE(c, M, b),
          Jv(c, M, b, y),
          vy(null, c, M, !0, u, y)
        );
      case 19:
        return ub(u, c, y);
      case 22:
        return eb(u, c, y);
    }
    throw Error(o(156, c.tag));
  };
  function Nb(u, c) {
    return Vv(u, c);
  }
  function nD(u, c, y, M) {
    (this.tag = u),
      (this.key = y),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = c),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Ni(u, c, y, M) {
    return new nD(u, c, y, M);
  }
  function zy(u) {
    return (u = u.prototype), !(!u || !u.isReactComponent);
  }
  function rD(u) {
    if (typeof u == "function") return zy(u) ? 1 : 0;
    if (u != null) {
      if (((u = u.$$typeof), u === _)) return 11;
      if (u === w) return 14;
    }
    return 2;
  }
  function Do(u, c) {
    var y = u.alternate;
    return (
      y === null
        ? ((y = Ni(u.tag, c, u.key, u.mode)),
          (y.elementType = u.elementType),
          (y.type = u.type),
          (y.stateNode = u.stateNode),
          (y.alternate = u),
          (u.alternate = y))
        : ((y.pendingProps = c),
          (y.type = u.type),
          (y.flags = 0),
          (y.subtreeFlags = 0),
          (y.deletions = null)),
      (y.flags = u.flags & 14680064),
      (y.childLanes = u.childLanes),
      (y.lanes = u.lanes),
      (y.child = u.child),
      (y.memoizedProps = u.memoizedProps),
      (y.memoizedState = u.memoizedState),
      (y.updateQueue = u.updateQueue),
      (c = u.dependencies),
      (y.dependencies =
        c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (y.sibling = u.sibling),
      (y.index = u.index),
      (y.ref = u.ref),
      y
    );
  }
  function pp(u, c, y, M, b, P) {
    var j = 2;
    if (((M = u), typeof u == "function")) zy(u) && (j = 1);
    else if (typeof u == "string") j = 5;
    else
      e: switch (u) {
        case d:
          return Ua(y.children, b, P, c);
        case h:
          (j = 8), (b |= 8);
          break;
        case p:
          return (
            (u = Ni(12, y, c, b | 2)), (u.elementType = p), (u.lanes = P), u
          );
        case x:
          return (u = Ni(13, y, c, b)), (u.elementType = x), (u.lanes = P), u;
        case m:
          return (u = Ni(19, y, c, b)), (u.elementType = m), (u.lanes = P), u;
        case E:
          return mp(y, b, P, c);
        default:
          if (typeof u == "object" && u !== null)
            switch (u.$$typeof) {
              case g:
                j = 10;
                break e;
              case v:
                j = 9;
                break e;
              case _:
                j = 11;
                break e;
              case w:
                j = 14;
                break e;
              case S:
                (j = 16), (M = null);
                break e;
            }
          throw Error(o(130, u == null ? u : typeof u, ""));
      }
    return (
      (c = Ni(j, y, c, b)), (c.elementType = u), (c.type = M), (c.lanes = P), c
    );
  }
  function Ua(u, c, y, M) {
    return (u = Ni(7, u, M, c)), (u.lanes = y), u;
  }
  function mp(u, c, y, M) {
    return (
      (u = Ni(22, u, M, c)),
      (u.elementType = E),
      (u.lanes = y),
      (u.stateNode = {}),
      u
    );
  }
  function By(u, c, y) {
    return (u = Ni(6, u, null, c)), (u.lanes = y), u;
  }
  function Hy(u, c, y) {
    return (
      (c = Ni(4, u.children !== null ? u.children : [], u.key, c)),
      (c.lanes = y),
      (c.stateNode = {
        containerInfo: u.containerInfo,
        pendingChildren: null,
        implementation: u.implementation,
      }),
      c
    );
  }
  function iD(u, c, y, M, b) {
    (this.tag = c),
      (this.containerInfo = u),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = We),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Bv(0)),
      (this.expirationTimes = Bv(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Bv(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = b),
      pe && (this.mutableSourceEagerHydrationData = null);
  }
  function Ob(u, c, y, M, b, P, j, ee, ge) {
    return (
      (u = new iD(u, c, y, ee, ge)),
      c === 1 ? ((c = 1), P === !0 && (c |= 8)) : (c = 0),
      (P = Ni(3, null, null, c)),
      (u.current = P),
      (P.stateNode = u),
      (P.memoizedState = {
        element: M,
        isDehydrated: y,
        cache: null,
        transitions: null,
      }),
      Kv(P),
      u
    );
  }
  function Db(u) {
    if (!u) return bi;
    u = u._reactInternals;
    e: {
      if (C(u) !== u || u.tag !== 1) throw Error(o(170));
      var c = u;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (Kn(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(o(171));
    }
    if (u.tag === 1) {
      var y = u.type;
      if (Kn(y)) return Wl(u, y, c);
    }
    return c;
  }
  function kb(u) {
    var c = u._reactInternals;
    if (c === void 0)
      throw typeof u.render == "function"
        ? Error(o(188))
        : ((u = Object.keys(u).join(",")), Error(o(268, u)));
    return (u = R(c)), u === null ? null : u.stateNode;
  }
  function Ub(u, c) {
    if (((u = u.memoizedState), u !== null && u.dehydrated !== null)) {
      var y = u.retryLane;
      u.retryLane = y !== 0 && y < c ? y : c;
    }
  }
  function Vy(u, c) {
    Ub(u, c), (u = u.alternate) && Ub(u, c);
  }
  function sD(u) {
    return (u = R(u)), u === null ? null : u.stateNode;
  }
  function oD() {
    return null;
  }
  return (
    (n.attemptContinuousHydration = function (u) {
      if (u.tag === 13) {
        var c = Dr();
        Ii(u, 134217728, c), Vy(u, 134217728);
      }
    }),
    (n.attemptHydrationAtCurrentPriority = function (u) {
      if (u.tag === 13) {
        var c = Dr(),
          y = No(u);
        Ii(u, y, c), Vy(u, y);
      }
    }),
    (n.attemptSynchronousHydration = function (u) {
      switch (u.tag) {
        case 3:
          var c = u.stateNode;
          if (c.current.memoizedState.isDehydrated) {
            var y = Hc(c.pendingLanes);
            y !== 0 && (Hv(c, y | 1), Xr(c, Zn()), !(Ct & 6) && (nu(), ys()));
          }
          break;
        case 13:
          var M = Dr();
          bb(function () {
            return Ii(u, 1, M);
          }),
            Vy(u, 1);
      }
    }),
    (n.batchedUpdates = function (u, c) {
      var y = Ct;
      Ct |= 1;
      try {
        return u(c);
      } finally {
        (Ct = y), Ct === 0 && (nu(), Ch && ys());
      }
    }),
    (n.createComponentSelector = function (u) {
      return { $$typeof: ep, value: u };
    }),
    (n.createContainer = function (u, c, y, M, b, P, j) {
      return Ob(u, c, !1, null, y, M, b, P, j);
    }),
    (n.createHasPseudoClassSelector = function (u) {
      return { $$typeof: tp, value: u };
    }),
    (n.createHydrationContainer = function (u, c, y, M, b, P, j, ee, ge) {
      return (
        (u = Ob(y, M, !0, u, b, P, j, ee, ge)),
        (u.context = Db(null)),
        (y = u.current),
        (M = Dr()),
        (b = No(y)),
        (P = js(M, b)),
        (P.callback = c ?? null),
        Po(y, P),
        (u.current.lanes = b),
        Vc(u, b, M),
        Xr(u, M),
        u
      );
    }),
    (n.createPortal = function (u, c, y) {
      var M =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: f,
        key: M == null ? null : "" + M,
        children: u,
        containerInfo: c,
        implementation: y,
      };
    }),
    (n.createRoleSelector = function (u) {
      return { $$typeof: np, value: u };
    }),
    (n.createTestNameSelector = function (u) {
      return { $$typeof: rp, value: u };
    }),
    (n.createTextSelector = function (u) {
      return { $$typeof: ip, value: u };
    }),
    (n.deferredUpdates = function (u) {
      var c = Dt,
        y = bn.transition;
      try {
        return (bn.transition = null), (Dt = 16), u();
      } finally {
        (Dt = c), (bn.transition = y);
      }
    }),
    (n.discreteUpdates = function (u, c, y, M, b) {
      var P = Dt,
        j = bn.transition;
      try {
        return (bn.transition = null), (Dt = 1), u(c, y, M, b);
      } finally {
        (Dt = P), (bn.transition = j), Ct === 0 && nu();
      }
    }),
    (n.findAllNodes = Cy),
    (n.findBoundingRects = function (u, c) {
      if (!Ze) throw Error(o(363));
      (c = Cy(u, c)), (u = []);
      for (var y = 0; y < c.length; y++) u.push(Tt(c[y]));
      for (c = u.length - 1; 0 < c; c--) {
        y = u[c];
        for (
          var M = y.x, b = M + y.width, P = y.y, j = P + y.height, ee = c - 1;
          0 <= ee;
          ee--
        )
          if (c !== ee) {
            var ge = u[ee],
              Ue = ge.x,
              Qe = Ue + ge.width,
              vt = ge.y,
              lt = vt + ge.height;
            if (M >= Ue && P >= vt && b <= Qe && j <= lt) {
              u.splice(c, 1);
              break;
            } else if (M !== Ue || y.width !== ge.width || lt < P || vt > j) {
              if (!(P !== vt || y.height !== ge.height || Qe < M || Ue > b)) {
                Ue > M && ((ge.width += Ue - M), (ge.x = M)),
                  Qe < b && (ge.width = b - Ue),
                  u.splice(c, 1);
                break;
              }
            } else {
              vt > P && ((ge.height += vt - P), (ge.y = P)),
                lt < j && (ge.height = j - vt),
                u.splice(c, 1);
              break;
            }
          }
      }
      return u;
    }),
    (n.findHostInstance = kb),
    (n.findHostInstanceWithNoPortals = function (u) {
      return (
        (u = k(u)),
        (u = u !== null ? D(u) : null),
        u === null ? null : u.stateNode
      );
    }),
    (n.findHostInstanceWithWarning = function (u) {
      return kb(u);
    }),
    (n.flushControlled = function (u) {
      var c = Ct;
      Ct |= 1;
      var y = bn.transition,
        M = Dt;
      try {
        (bn.transition = null), (Dt = 1), u();
      } finally {
        (Dt = M), (bn.transition = y), (Ct = c), Ct === 0 && (nu(), ys());
      }
    }),
    (n.flushPassiveEffects = ka),
    (n.flushSync = bb),
    (n.focusWithin = function (u, c) {
      if (!Ze) throw Error(o(363));
      for (u = by(u), c = wb(u, c), c = Array.from(c), u = 0; u < c.length; ) {
        var y = c[u++];
        if (!O(y)) {
          if (y.tag === 5 && Re(y.stateNode)) return !0;
          for (y = y.child; y !== null; ) c.push(y), (y = y.sibling);
        }
      }
      return !1;
    }),
    (n.getCurrentUpdatePriority = function () {
      return Dt;
    }),
    (n.getFindAllNodesFailureDescription = function (u, c) {
      if (!Ze) throw Error(o(363));
      var y = 0,
        M = [];
      u = [by(u), 0];
      for (var b = 0; b < u.length; ) {
        var P = u[b++],
          j = u[b++],
          ee = c[j];
        if (
          (P.tag !== 5 || !O(P)) &&
          (Ty(P, ee) && (M.push(Ay(ee)), j++, j > y && (y = j)), j < c.length)
        )
          for (P = P.child; P !== null; ) u.push(P, j), (P = P.sibling);
      }
      if (y < c.length) {
        for (u = []; y < c.length; y++) u.push(Ay(c[y]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (M.join(" > ") +
            `

No matching component was found for:
  `) +
          u.join(" > ")
        );
      }
      return null;
    }),
    (n.getPublicRootInstance = function (u) {
      if (((u = u.current), !u.child)) return null;
      switch (u.child.tag) {
        case 5:
          return Y(u.child.stateNode);
        default:
          return u.child.stateNode;
      }
    }),
    (n.injectIntoDevTools = function (u) {
      if (
        ((u = {
          bundleType: u.bundleType,
          version: u.version,
          rendererPackageName: u.rendererPackageName,
          rendererConfig: u.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: sD,
          findFiberByHostInstance: u.findFiberByHostInstance || oD,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        u = !1;
      else {
        var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (c.isDisabled || !c.supportsFiber) u = !0;
        else {
          try {
            (Ah = c.inject(u)), (gs = c);
          } catch {}
          u = !!c.checkDCE;
        }
      }
      return u;
    }),
    (n.isAlreadyRendering = function () {
      return !1;
    }),
    (n.observeVisibleRects = function (u, c, y, M) {
      if (!Ze) throw Error(o(363));
      u = Cy(u, c);
      var b = Ee(u, y, M).disconnect;
      return {
        disconnect: function () {
          b();
        },
      };
    }),
    (n.registerMutableSourceForHydration = function (u, c) {
      var y = c._getVersion;
      (y = y(c._source)),
        u.mutableSourceEagerHydrationData == null
          ? (u.mutableSourceEagerHydrationData = [c, y])
          : u.mutableSourceEagerHydrationData.push(c, y);
    }),
    (n.runWithPriority = function (u, c) {
      var y = Dt;
      try {
        return (Dt = u), c();
      } finally {
        Dt = y;
      }
    }),
    (n.shouldError = function () {
      return null;
    }),
    (n.shouldSuspend = function () {
      return !1;
    }),
    (n.updateContainer = function (u, c, y, M) {
      var b = c.current,
        P = Dr(),
        j = No(b);
      return (
        (y = Db(y)),
        c.context === null ? (c.context = y) : (c.pendingContext = y),
        (c = js(P, j)),
        (c.payload = { element: u }),
        (M = M === void 0 ? null : M),
        M !== null && (c.callback = M),
        Po(b, c),
        (u = Ii(b, j, P)),
        u !== null && Ih(u, b, j),
        j
      );
    }),
    n
  );
};
iN.exports = OG;
var DG = iN.exports;
const kG = N1(DG),
  LM = {},
  UG = (t) => void Object.assign(LM, t);
function FG(t, e) {
  function n(d, { args: h = [], attach: p, ...g }, v) {
    let _ = `${d[0].toUpperCase()}${d.slice(1)}`,
      x;
    if (d === "primitive") {
      if (g.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const m = g.object;
      x = Nu(m, { type: d, root: v, attach: p, primitive: !0 });
    } else {
      const m = LM[_];
      if (!m)
        throw new Error(
          `R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(h))
        throw new Error("R3F: The args prop must be an array!");
      x = Nu(new m(...h), {
        type: d,
        root: v,
        attach: p,
        memoizedProps: { args: h },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x.isBufferGeometry
          ? (x.__r3f.attach = "geometry")
          : x.isMaterial && (x.__r3f.attach = "material")),
      _ !== "inject" && l_(x, g),
      x
    );
  }
  function r(d, h) {
    let p = !1;
    if (h) {
      var g, v;
      (g = h.__r3f) != null && g.attach
        ? a_(d, h, h.__r3f.attach)
        : h.isObject3D && d.isObject3D && (d.add(h), (p = !0)),
        p || (v = d.__r3f) == null || v.objects.push(h),
        h.__r3f || Nu(h, {}),
        (h.__r3f.parent = d),
        g1(h),
        Ou(h);
    }
  }
  function i(d, h, p) {
    let g = !1;
    if (h) {
      var v, _;
      if ((v = h.__r3f) != null && v.attach) a_(d, h, h.__r3f.attach);
      else if (h.isObject3D && d.isObject3D) {
        (h.parent = d),
          h.dispatchEvent({ type: "added" }),
          d.dispatchEvent({ type: "childadded", child: h });
        const x = d.children.filter((w) => w !== h),
          m = x.indexOf(p);
        (d.children = [...x.slice(0, m), h, ...x.slice(m)]), (g = !0);
      }
      g || (_ = d.__r3f) == null || _.objects.push(h),
        h.__r3f || Nu(h, {}),
        (h.__r3f.parent = d),
        g1(h),
        Ou(h);
    }
  }
  function s(d, h, p = !1) {
    d && [...d].forEach((g) => o(h, g, p));
  }
  function o(d, h, p) {
    if (h) {
      var g, v, _;
      if (
        (h.__r3f && (h.__r3f.parent = null),
        (g = d.__r3f) != null &&
          g.objects &&
          (d.__r3f.objects = d.__r3f.objects.filter((E) => E !== h)),
        (v = h.__r3f) != null && v.attach)
      )
        $C(d, h, h.__r3f.attach);
      else if (h.isObject3D && d.isObject3D) {
        var x;
        d.remove(h), (x = h.__r3f) != null && x.root && $G(eg(h), h);
      }
      const w = (_ = h.__r3f) == null ? void 0 : _.primitive,
        S = !w && (p === void 0 ? h.dispose !== null : p);
      if (!w) {
        var m;
        s((m = h.__r3f) == null ? void 0 : m.objects, h, S),
          s(h.children, h, S);
      }
      if ((delete h.__r3f, S && h.dispose && h.type !== "Scene")) {
        const E = () => {
          try {
            h.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? p1.unstable_scheduleCallback(p1.unstable_IdlePriority, E)
          : E();
      }
      Ou(d);
    }
  }
  function a(d, h, p, g) {
    var v;
    const _ = (v = d.__r3f) == null ? void 0 : v.parent;
    if (!_) return;
    const x = n(h, p, d.__r3f.root);
    if (d.children) {
      for (const m of d.children) m.__r3f && r(x, m);
      d.children = d.children.filter((m) => !m.__r3f);
    }
    d.__r3f.objects.forEach((m) => r(x, m)),
      (d.__r3f.objects = []),
      d.__r3f.autoRemovedBeforeAppend || o(_, d),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      r(_, x),
      x.raycast &&
        x.__r3f.eventCount &&
        eg(x).getState().internal.interaction.push(x),
      [g, g.alternate].forEach((m) => {
        m !== null &&
          ((m.stateNode = x),
          m.ref &&
            (typeof m.ref == "function" ? m.ref(x) : (m.ref.current = x)));
      });
  }
  const l = () => {};
  return {
    reconciler: kG({
      createInstance: n,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (d, h) => {
        if (!h) return;
        const p = d.getState().scene;
        p.__r3f && ((p.__r3f.root = d), r(p, h));
      },
      removeChildFromContainer: (d, h) => {
        h && o(d.getState().scene, h);
      },
      insertInContainerBefore: (d, h, p) => {
        if (!h || !p) return;
        const g = d.getState().scene;
        g.__r3f && i(g, h, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (d) => d,
      finalizeInitialChildren(d) {
        var h;
        return !!((h = d == null ? void 0 : d.__r3f) != null ? h : {}).handlers;
      },
      prepareUpdate(d, h, p, g) {
        var v;
        if (
          ((v = d == null ? void 0 : d.__r3f) != null ? v : {}).primitive &&
          g.object &&
          g.object !== d
        )
          return [!0];
        {
          const { args: x = [], children: m, ...w } = g,
            { args: S = [], children: E, ...T } = p;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((L, N) => L !== S[N])) return [!0];
          const A = hN(d, w, T, !0);
          return A.changes.length ? [!1, A] : null;
        }
      },
      commitUpdate(d, [h, p], g, v, _, x) {
        h ? a(d, g, _, x) : l_(d, p);
      },
      commitMount(d, h, p, g) {
        var v;
        const _ = (v = d.__r3f) != null ? v : {};
        d.raycast &&
          _.handlers &&
          _.eventCount &&
          eg(d).getState().internal.interaction.push(d);
      },
      getPublicInstance: (d) => d,
      prepareForCommit: () => null,
      preparePortalMount: (d) => Nu(d.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(d) {
        var h;
        const { attach: p, parent: g } = (h = d.__r3f) != null ? h : {};
        p && g && $C(g, d, p), d.isObject3D && (d.visible = !1), Ou(d);
      },
      unhideInstance(d, h) {
        var p;
        const { attach: g, parent: v } = (p = d.__r3f) != null ? p : {};
        g && v && a_(v, d, g),
          ((d.isObject3D && h.visible == null) || h.visible) &&
            (d.visible = !0),
          Ou(d);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Ju.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Qt.fun(performance.now)
          ? performance.now
          : Qt.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Qt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Qt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: l_,
  };
}
var VC, WC;
const o_ = (t) => "colorSpace" in t || "outputColorSpace" in t,
  aN = () => {
    var t;
    return (t = LM.ColorManagement) != null ? t : null;
  },
  lN = (t) => t && t.isOrthographicCamera,
  zG = (t) => t && t.hasOwnProperty("current"),
  ph =
    typeof window < "u" &&
    (((VC = window.document) != null && VC.createElement) ||
      ((WC = window.navigator) == null ? void 0 : WC.product) === "ReactNative")
      ? U.useLayoutEffect
      : U.useEffect;
function uN(t) {
  const e = U.useRef(t);
  return ph(() => void (e.current = t), [t]), e;
}
function BG({ set: t }) {
  return ph(() => (t(new Promise(() => null)), () => t(!1)), [t]), null;
}
class cN extends U.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
cN.getDerivedStateFromError = () => ({ error: !0 });
const fN = "__default",
  GC = new Map(),
  HG = (t) => t && !!t.memoized && !!t.changes;
function dN(t) {
  var e;
  const n =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t;
}
const Tf = (t) => {
  var e;
  return (e = t.__r3f) == null ? void 0 : e.root.getState();
};
function eg(t) {
  let e = t.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Qt = {
  obj: (t) => t === Object(t) && !Qt.arr(t) && typeof t != "function",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  boo: (t) => typeof t == "boolean",
  und: (t) => t === void 0,
  arr: (t) => Array.isArray(t),
  equ(
    t,
    e,
    { arrays: n = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof t != typeof e || !!t != !!e) return !1;
    if (Qt.str(t) || Qt.num(t) || Qt.boo(t)) return t === e;
    const s = Qt.obj(t);
    if (s && r === "reference") return t === e;
    const o = Qt.arr(t);
    if (o && n === "reference") return t === e;
    if ((o || s) && t === e) return !0;
    let a;
    for (a in t) if (!(a in e)) return !1;
    if (s && n === "shallow" && r === "shallow") {
      for (a in i ? e : t)
        if (!Qt.equ(t[a], e[a], { strict: i, objects: "reference" })) return !1;
    } else for (a in i ? e : t) if (t[a] !== e[a]) return !1;
    if (Qt.und(a)) {
      if (
        (o && t.length === 0 && e.length === 0) ||
        (s && Object.keys(t).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (t !== e) return !1;
    }
    return !0;
  },
};
function VG(t) {
  const e = { nodes: {}, materials: {} };
  return (
    t &&
      t.traverse((n) => {
        n.name && (e.nodes[n.name] = n),
          n.material &&
            !e.materials[n.material.name] &&
            (e.materials[n.material.name] = n.material);
      }),
    e
  );
}
function WG(t) {
  t.dispose && t.type !== "Scene" && t.dispose();
  for (const e in t) e.dispose == null || e.dispose(), delete t[e];
}
function Nu(t, e) {
  const n = t;
  return (
    (n.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    t
  );
}
function m1(t, e) {
  let n = t;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (n = r.reduce((s, o) => s[o], t)), { target: n, key: i };
  } else return { target: n, key: e };
}
const jC = /-\d+$/;
function a_(t, e, n) {
  if (Qt.str(n)) {
    if (jC.test(n)) {
      const s = n.replace(jC, ""),
        { target: o, key: a } = m1(t, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: r, key: i } = m1(t, n);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = n(t, e);
}
function $C(t, e, n) {
  var r, i;
  if (Qt.str(n)) {
    const { target: s, key: o } = m1(t, n),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function hN(
  t,
  { children: e, key: n, ref: r, ...i },
  { children: s, key: o, ref: a, ...l } = {},
  f = !1
) {
  const d = t.__r3f,
    h = Object.entries(i),
    p = [];
  if (f) {
    const v = Object.keys(l);
    for (let _ = 0; _ < v.length; _++)
      i.hasOwnProperty(v[_]) || h.unshift([v[_], fN + "remove"]);
  }
  h.forEach(([v, _]) => {
    var x;
    if (
      ((x = t.__r3f) != null && x.primitive && v === "object") ||
      Qt.equ(_, l[v])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
      return p.push([v, _, !0, []]);
    let m = [];
    v.includes("-") && (m = v.split("-")), p.push([v, _, !1, m]);
    for (const w in i) {
      const S = i[w];
      w.startsWith(`${v}-`) && p.push([w, S, !1, w.split("-")]);
    }
  });
  const g = { ...i };
  return (
    d != null &&
      d.memoizedProps &&
      d != null &&
      d.memoizedProps.args &&
      (g.args = d.memoizedProps.args),
    d != null &&
      d.memoizedProps &&
      d != null &&
      d.memoizedProps.attach &&
      (g.attach = d.memoizedProps.attach),
    { memoized: g, changes: p }
  );
}
function l_(t, e) {
  var n;
  const r = t.__r3f,
    i = r == null ? void 0 : r.root,
    s = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: o, changes: a } = HG(e) ? e : hN(t, e),
    l = r == null ? void 0 : r.eventCount;
  t.__r3f && (t.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [g, v, _, x] = a[p];
    if (o_(t)) {
      const E = "srgb",
        T = "srgb-linear";
      g === "encoding"
        ? ((g = "colorSpace"), (v = v === 3001 ? E : T))
        : g === "outputEncoding" &&
          ((g = "outputColorSpace"), (v = v === 3001 ? E : T));
    }
    let m = t,
      w = m[g];
    if (x.length && ((w = x.reduce((S, E) => S[E], t)), !(w && w.set))) {
      const [S, ...E] = x.reverse();
      (m = E.reverse().reduce((T, A) => T[A], t)), (g = S);
    }
    if (v === fN + "remove")
      if (m.constructor) {
        let S = GC.get(m.constructor);
        S || ((S = new m.constructor()), GC.set(m.constructor, S)), (v = S[g]);
      } else v = 0;
    if (_ && r)
      v ? (r.handlers[g] = v) : delete r.handlers[g],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (w && w.set && (w.copy || w instanceof _l)) {
      if (Array.isArray(v)) w.fromArray ? w.fromArray(v) : w.set(...v);
      else if (w.copy && v && v.constructor && w.constructor === v.constructor)
        w.copy(v);
      else if (v !== void 0) {
        var f;
        const S = (f = w) == null ? void 0 : f.isColor;
        !S && w.setScalar
          ? w.setScalar(v)
          : w instanceof _l && v instanceof _l
          ? (w.mask = v.mask)
          : w.set(v),
          !aN() && s && !s.linear && S && w.convertSRGBToLinear();
      }
    } else {
      var d;
      if (
        ((m[g] = v),
        (d = m[g]) != null &&
          d.isTexture &&
          m[g].format === zr &&
          m[g].type === ks &&
          s)
      ) {
        const S = m[g];
        o_(S) && o_(s.gl)
          ? (S.colorSpace = s.gl.outputColorSpace)
          : (S.encoding = s.gl.outputEncoding);
      }
    }
    Ou(t);
  }
  if (r && r.parent && t.raycast && l !== r.eventCount) {
    const p = eg(t).getState().internal,
      g = p.interaction.indexOf(t);
    g > -1 && p.interaction.splice(g, 1), r.eventCount && p.interaction.push(t);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (n = t.__r3f) != null &&
      n.parent &&
      g1(t),
    t
  );
}
function Ou(t) {
  var e, n;
  const r =
    (e = t.__r3f) == null || (n = e.root) == null || n.getState == null
      ? void 0
      : n.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function g1(t) {
  t.onUpdate == null || t.onUpdate(t);
}
function GG(t, e) {
  t.manual ||
    (lN(t)
      ? ((t.left = e.width / -2),
        (t.right = e.width / 2),
        (t.top = e.height / 2),
        (t.bottom = e.height / -2))
      : (t.aspect = e.width / e.height),
    t.updateProjectionMatrix(),
    t.updateMatrixWorld());
}
function Am(t) {
  return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId;
}
function jG() {
  var t;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Ju.DefaultEventPriority;
  switch ((t = e.event) == null ? void 0 : t.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Ju.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Ju.ContinuousEventPriority;
    default:
      return Ju.DefaultEventPriority;
  }
}
function pN(t, e, n, r) {
  const i = n.get(e);
  i &&
    (n.delete(e),
    n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r)));
}
function $G(t, e) {
  const { internal: n } = t.getState();
  (n.interaction = n.interaction.filter((r) => r !== e)),
    (n.initialHits = n.initialHits.filter((r) => r !== e)),
    n.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && n.hovered.delete(i);
    }),
    n.capturedMap.forEach((r, i) => {
      pN(n.capturedMap, e, r, i);
    });
}
function XG(t) {
  function e(l) {
    const { internal: f } = t.getState(),
      d = l.offsetX - f.initialClick[0],
      h = l.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(d * d + h * h));
  }
  function n(l) {
    return l.filter((f) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((d) => {
        var h;
        return (h = f.__r3f) == null ? void 0 : h.handlers["onPointer" + d];
      })
    );
  }
  function r(l, f) {
    const d = t.getState(),
      h = new Set(),
      p = [],
      g = f ? f(d.internal.interaction) : d.internal.interaction;
    for (let m = 0; m < g.length; m++) {
      const w = Tf(g[m]);
      w && (w.raycaster.camera = void 0);
    }
    d.previousRoot || d.events.compute == null || d.events.compute(l, d);
    function v(m) {
      const w = Tf(m);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var S;
        w.events.compute == null ||
          w.events.compute(
            l,
            w,
            (S = w.previousRoot) == null ? void 0 : S.getState()
          ),
          w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(m, !0) : [];
    }
    let _ = g
      .flatMap(v)
      .sort((m, w) => {
        const S = Tf(m.object),
          E = Tf(w.object);
        return !S || !E
          ? m.distance - w.distance
          : E.events.priority - S.events.priority || m.distance - w.distance;
      })
      .filter((m) => {
        const w = Am(m);
        return h.has(w) ? !1 : (h.add(w), !0);
      });
    d.events.filter && (_ = d.events.filter(_, d));
    for (const m of _) {
      let w = m.object;
      for (; w; ) {
        var x;
        (x = w.__r3f) != null &&
          x.eventCount &&
          p.push({ ...m, eventObject: w }),
          (w = w.parent);
      }
    }
    if ("pointerId" in l && d.internal.capturedMap.has(l.pointerId))
      for (let m of d.internal.capturedMap.get(l.pointerId).values())
        h.has(Am(m.intersection)) || p.push(m.intersection);
    return p;
  }
  function i(l, f, d, h) {
    const p = t.getState();
    if (l.length) {
      const g = { stopped: !1 };
      for (const v of l) {
        const _ = Tf(v.object) || p,
          { raycaster: x, pointer: m, camera: w, internal: S } = _,
          E = new z(m.x, m.y, 0).unproject(w),
          T = (I) => {
            var k, R;
            return (k =
              (R = S.capturedMap.get(I)) == null
                ? void 0
                : R.has(v.eventObject)) != null
              ? k
              : !1;
          },
          A = (I) => {
            const k = { intersection: v, target: f.target };
            S.capturedMap.has(I)
              ? S.capturedMap.get(I).set(v.eventObject, k)
              : S.capturedMap.set(I, new Map([[v.eventObject, k]])),
              f.target.setPointerCapture(I);
          },
          L = (I) => {
            const k = S.capturedMap.get(I);
            k && pN(S.capturedMap, v.eventObject, k, I);
          };
        let N = {};
        for (let I in f) {
          let k = f[I];
          typeof k != "function" && (N[I] = k);
        }
        let C = {
          ...v,
          ...N,
          pointer: m,
          intersections: l,
          stopped: g.stopped,
          delta: d,
          unprojectedPoint: E,
          ray: x.ray,
          camera: w,
          stopPropagation() {
            const I = "pointerId" in f && S.capturedMap.get(f.pointerId);
            if (
              (!I || I.has(v.eventObject)) &&
              ((C.stopped = g.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (k) => k.eventObject === v.eventObject
                ))
            ) {
              const k = l.slice(0, l.indexOf(v));
              s([...k, v]);
            }
          },
          target: {
            hasPointerCapture: T,
            setPointerCapture: A,
            releasePointerCapture: L,
          },
          currentTarget: {
            hasPointerCapture: T,
            setPointerCapture: A,
            releasePointerCapture: L,
          },
          nativeEvent: f,
        };
        if ((h(C), g.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: f } = t.getState();
    for (const d of f.hovered.values())
      if (
        !l.length ||
        !l.find(
          (h) =>
            h.object === d.object &&
            h.index === d.index &&
            h.instanceId === d.instanceId
        )
      ) {
        const p = d.eventObject.__r3f,
          g = p == null ? void 0 : p.handlers;
        if ((f.hovered.delete(Am(d)), p != null && p.eventCount)) {
          const v = { ...d, intersections: l };
          g.onPointerOut == null || g.onPointerOut(v),
            g.onPointerLeave == null || g.onPointerLeave(v);
        }
      }
  }
  function o(l, f) {
    for (let d = 0; d < f.length; d++) {
      const h = f[d].__r3f;
      h == null ||
        h.handlers.onPointerMissed == null ||
        h.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: d } = t.getState();
          "pointerId" in f &&
            d.capturedMap.has(f.pointerId) &&
            requestAnimationFrame(() => {
              d.capturedMap.has(f.pointerId) &&
                (d.capturedMap.delete(f.pointerId), s([]));
            });
        };
    }
    return function (d) {
      const { onPointerMissed: h, internal: p } = t.getState();
      p.lastEvent.current = d;
      const g = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = r(d, g ? n : void 0),
        m = v ? e(d) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [d.offsetX, d.offsetY]),
        (p.initialHits = x.map((S) => S.eventObject))),
        v && !x.length && m <= 2 && (o(d, p.interaction), h && h(d)),
        g && s(x);
      function w(S) {
        const E = S.eventObject,
          T = E.__r3f,
          A = T == null ? void 0 : T.handlers;
        if (T != null && T.eventCount)
          if (g) {
            if (
              A.onPointerOver ||
              A.onPointerEnter ||
              A.onPointerOut ||
              A.onPointerLeave
            ) {
              const L = Am(S),
                N = p.hovered.get(L);
              N
                ? N.stopped && S.stopPropagation()
                : (p.hovered.set(L, S),
                  A.onPointerOver == null || A.onPointerOver(S),
                  A.onPointerEnter == null || A.onPointerEnter(S));
            }
            A.onPointerMove == null || A.onPointerMove(S);
          } else {
            const L = A[l];
            L
              ? (!v || p.initialHits.includes(E)) &&
                (o(
                  d,
                  p.interaction.filter((N) => !p.initialHits.includes(N))
                ),
                L(S))
              : v &&
                p.initialHits.includes(E) &&
                o(
                  d,
                  p.interaction.filter((N) => !p.initialHits.includes(N))
                );
          }
      }
      i(x, d, m, w);
    };
  }
  return { handlePointer: a };
}
const mN = (t) => !!(t != null && t.render),
  gN = U.createContext(null),
  YG = (t, e) => {
    const n = RG((a, l) => {
        const f = new z(),
          d = new z(),
          h = new z();
        function p(m = l().camera, w = d, S = l().size) {
          const { width: E, height: T, top: A, left: L } = S,
            N = E / T;
          w.isVector3 ? h.copy(w) : h.set(...w);
          const C = m.getWorldPosition(f).distanceTo(h);
          if (lN(m))
            return {
              width: E / m.zoom,
              height: T / m.zoom,
              top: A,
              left: L,
              factor: 1,
              distance: C,
              aspect: N,
            };
          {
            const I = (m.fov * Math.PI) / 180,
              k = 2 * Math.tan(I / 2) * C,
              R = k * (E / T);
            return {
              width: R,
              height: k,
              top: A,
              left: L,
              factor: E / R,
              distance: C,
              aspect: N,
            };
          }
        }
        let g;
        const v = (m) =>
            a((w) => ({ performance: { ...w.performance, current: m } })),
          _ = new _e();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (m = 1) => t(l(), m),
          advance: (m, w) => e(m, w, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new AM(),
          pointer: _,
          mouse: _,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const m = l();
              g && clearTimeout(g),
                m.performance.current !== m.performance.min &&
                  v(m.performance.min),
                (g = setTimeout(
                  () => v(l().performance.max),
                  m.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (m) => a((w) => ({ ...w, events: { ...w.events, ...m } })),
          setSize: (m, w, S, E, T) => {
            const A = l().camera,
              L = {
                width: m,
                height: w,
                top: E || 0,
                left: T || 0,
                updateStyle: S,
              };
            a((N) => ({ size: L, viewport: { ...N.viewport, ...p(A, d, L) } }));
          },
          setDpr: (m) =>
            a((w) => {
              const S = dN(m);
              return {
                viewport: {
                  ...w.viewport,
                  dpr: S,
                  initialDpr: w.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (m = "always") => {
            const w = l().clock;
            w.stop(),
              (w.elapsedTime = 0),
              m !== "never" && (w.start(), (w.elapsedTime = 0)),
              a(() => ({ frameloop: m }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: U.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (m, w, S) => {
              const E = l().internal;
              return (
                (E.priority = E.priority + (w > 0 ? 1 : 0)),
                E.subscribers.push({ ref: m, priority: w, store: S }),
                (E.subscribers = E.subscribers.sort(
                  (T, A) => T.priority - A.priority
                )),
                () => {
                  const T = l().internal;
                  T != null &&
                    T.subscribers &&
                    ((T.priority = T.priority - (w > 0 ? 1 : 0)),
                    (T.subscribers = T.subscribers.filter((A) => A.ref !== m)));
                }
              );
            },
          },
        };
      }),
      r = n.getState();
    let i = r.size,
      s = r.viewport.dpr,
      o = r.camera;
    return (
      n.subscribe(() => {
        const { camera: a, size: l, viewport: f, gl: d, set: h } = n.getState();
        if (l.width !== i.width || l.height !== i.height || f.dpr !== s) {
          var p;
          (i = l), (s = f.dpr), GG(a, l), d.setPixelRatio(f.dpr);
          const g =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                d.domElement instanceof HTMLCanvasElement;
          d.setSize(l.width, l.height, g);
        }
        a !== o &&
          ((o = a),
          h((g) => ({
            viewport: { ...g.viewport, ...g.viewport.getCurrentViewport(a) },
          })));
      }),
      n.subscribe((a) => t(a)),
      n
    );
  };
let Cm,
  qG = new Set(),
  KG = new Set(),
  ZG = new Set();
function u_(t, e) {
  if (t.size) for (const { callback: n } of t.values()) n(e);
}
function Af(t, e) {
  switch (t) {
    case "before":
      return u_(qG, e);
    case "after":
      return u_(KG, e);
    case "tail":
      return u_(ZG, e);
  }
}
let c_, f_;
function d_(t, e, n) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof t == "number" &&
      ((r = t - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = t)),
      c_ = e.internal.subscribers,
      Cm = 0;
    Cm < c_.length;
    Cm++
  )
    (f_ = c_[Cm]), f_.ref.current(f_.store.getState(), r, n);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function JG(t) {
  let e = !1,
    n = !1,
    r,
    i,
    s;
  function o(f) {
    (i = requestAnimationFrame(o)),
      (e = !0),
      (r = 0),
      Af("before", f),
      (n = !0);
    for (const h of t.values()) {
      var d;
      (s = h.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((d = s.gl.xr) != null && d.isPresenting) &&
          (r += d_(f, s));
    }
    if (((n = !1), Af("after", f), r === 0))
      return Af("tail", f), (e = !1), cancelAnimationFrame(i);
  }
  function a(f, d = 1) {
    var h;
    if (!f) return t.forEach((p) => a(p.store.getState(), d));
    ((h = f.gl.xr) != null && h.isPresenting) ||
      !f.internal.active ||
      f.frameloop === "never" ||
      (d > 1
        ? (f.internal.frames = Math.min(60, f.internal.frames + d))
        : n
        ? (f.internal.frames = 2)
        : (f.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)));
  }
  function l(f, d = !0, h, p) {
    if ((d && Af("before", f), h)) d_(f, h, p);
    else for (const g of t.values()) d_(f, g.store.getState());
    d && Af("after", f);
  }
  return { loop: o, invalidate: a, advance: l };
}
function vN() {
  const t = U.useContext(gN);
  if (!t)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return t;
}
function io(t = (n) => n, e) {
  return vN()(t, e);
}
function yN(t, e = 0) {
  const n = vN(),
    r = n.getState().internal.subscribe,
    i = uN(t);
  return ph(() => r(i, e, n), [e, r, n]), null;
}
const XC = new WeakMap();
function xN(t, e) {
  return function (n, ...r) {
    let i = XC.get(n);
    return (
      i || ((i = new n()), XC.set(n, i)),
      t && t(i),
      Promise.all(
        r.map(
          (s) =>
            new Promise((o, a) =>
              i.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, VG(l.scene)), o(l);
                },
                e,
                (l) =>
                  a(
                    new Error(
                      `Could not load ${s}: ${l == null ? void 0 : l.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function IM(t, e, n, r) {
  const i = Array.isArray(e) ? e : [e],
    s = LG(xN(n, r), [t, ...i], { equal: Qt.equ });
  return Array.isArray(e) ? s : s[0];
}
IM.preload = function (t, e, n) {
  const r = Array.isArray(e) ? e : [e];
  return IG(xN(n), [t, ...r]);
};
IM.clear = function (t, e) {
  const n = Array.isArray(e) ? e : [e];
  return NG([t, ...n]);
};
const Ec = new Map(),
  { invalidate: YC, advance: qC } = JG(Ec),
  { reconciler: Hg, applyProps: bu } = FG(Ec, jG),
  Tu = { objects: "shallow", strict: !1 },
  QG = (t, e) => {
    const n = typeof t == "function" ? t(e) : t;
    return mN(n)
      ? n
      : new uM({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...t,
        });
  };
function e8(t, e) {
  const n = typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: s, left: o, updateStyle: a = n } = e;
    return { width: r, height: i, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    t instanceof HTMLCanvasElement &&
    t.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: s,
      left: o,
    } = t.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: s, left: o, updateStyle: n };
  } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
    return {
      width: t.width,
      height: t.height,
      top: 0,
      left: 0,
      updateStyle: n,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function t8(t) {
  const e = Ec.get(t),
    n = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    s = r || YG(YC, qC),
    o =
      n ||
      Hg.createContainer(s, Ju.ConcurrentRoot, null, !1, null, "", i, null);
  e || Ec.set(t, { fiber: o, store: s });
  let a,
    l = !1,
    f;
  return {
    configure(d = {}) {
      let {
          gl: h,
          size: p,
          scene: g,
          events: v,
          onCreated: _,
          shadows: x = !1,
          linear: m = !1,
          flat: w = !1,
          legacy: S = !1,
          orthographic: E = !1,
          frameloop: T = "always",
          dpr: A = [1, 2],
          performance: L,
          raycaster: N,
          camera: C,
          onPointerMissed: I,
        } = d,
        k = s.getState(),
        R = k.gl;
      k.gl || k.set({ gl: (R = QG(h, t)) });
      let $ = k.raycaster;
      $ || k.set({ raycaster: ($ = new Q3()) });
      const { params: D, ...W } = N || {};
      if (
        (Qt.equ(W, $, Tu) || bu($, { ...W }),
        Qt.equ(D, $.params, Tu) || bu($, { params: { ...$.params, ...D } }),
        !k.camera || (k.camera === f && !Qt.equ(f, C, Tu)))
      ) {
        f = C;
        const X = C instanceof oh,
          te = X
            ? C
            : E
            ? new da(0, 0, 0, 0, 0.1, 1e3)
            : new Pn(75, 0, 0.1, 1e3);
        X ||
          ((te.position.z = 5),
          C &&
            (bu(te, C),
            ("aspect" in C ||
              "left" in C ||
              "right" in C ||
              "bottom" in C ||
              "top" in C) &&
              ((te.manual = !0), te.updateProjectionMatrix())),
          !k.camera && !(C != null && C.rotation) && te.lookAt(0, 0, 0)),
          k.set({ camera: te }),
          ($.camera = te);
      }
      if (!k.scene) {
        let X;
        g != null && g.isScene ? (X = g) : ((X = new cM()), g && bu(X, g)),
          k.set({ scene: Nu(X) });
      }
      if (!k.xr) {
        var Y;
        const X = (J, ae) => {
            const Se = s.getState();
            Se.frameloop !== "never" && qC(J, !0, Se, ae);
          },
          te = () => {
            const J = s.getState();
            (J.gl.xr.enabled = J.gl.xr.isPresenting),
              J.gl.xr.setAnimationLoop(J.gl.xr.isPresenting ? X : null),
              J.gl.xr.isPresenting || YC(J);
          },
          oe = {
            connect() {
              const J = s.getState().gl;
              J.xr.addEventListener("sessionstart", te),
                J.xr.addEventListener("sessionend", te);
            },
            disconnect() {
              const J = s.getState().gl;
              J.xr.removeEventListener("sessionstart", te),
                J.xr.removeEventListener("sessionend", te);
            },
          };
        typeof ((Y = R.xr) == null ? void 0 : Y.addEventListener) ==
          "function" && oe.connect(),
          k.set({ xr: oe });
      }
      if (R.shadowMap) {
        const X = R.shadowMap.enabled,
          te = R.shadowMap.type;
        if (((R.shadowMap.enabled = !!x), Qt.boo(x))) R.shadowMap.type = Jf;
        else if (Qt.str(x)) {
          var Z;
          const oe = { basic: jL, percentage: O0, soft: Jf, variance: es };
          R.shadowMap.type = (Z = oe[x]) != null ? Z : Jf;
        } else Qt.obj(x) && Object.assign(R.shadowMap, x);
        (X !== R.shadowMap.enabled || te !== R.shadowMap.type) &&
          (R.shadowMap.needsUpdate = !0);
      }
      const B = aN();
      B &&
        ("enabled" in B
          ? (B.enabled = !S)
          : "legacyMode" in B && (B.legacyMode = S)),
        l ||
          bu(R, { outputEncoding: m ? 3e3 : 3001, toneMapping: w ? Ds : Vw }),
        k.legacy !== S && k.set(() => ({ legacy: S })),
        k.linear !== m && k.set(() => ({ linear: m })),
        k.flat !== w && k.set(() => ({ flat: w })),
        h && !Qt.fun(h) && !mN(h) && !Qt.equ(h, R, Tu) && bu(R, h),
        v && !k.events.handlers && k.set({ events: v(s) });
      const G = e8(t, p);
      return (
        Qt.equ(G, k.size, Tu) ||
          k.setSize(G.width, G.height, G.updateStyle, G.top, G.left),
        A && k.viewport.dpr !== dN(A) && k.setDpr(A),
        k.frameloop !== T && k.setFrameloop(T),
        k.onPointerMissed || k.set({ onPointerMissed: I }),
        L &&
          !Qt.equ(L, k.performance, Tu) &&
          k.set((X) => ({ performance: { ...X.performance, ...L } })),
        (a = _),
        (l = !0),
        this
      );
    },
    render(d) {
      return (
        l || this.configure(),
        Hg.updateContainer(
          Q.jsx(n8, { store: s, children: d, onCreated: a, rootElement: t }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      _N(t);
    },
  };
}
function n8({ store: t, children: e, onCreated: n, rootElement: r }) {
  return (
    ph(() => {
      const i = t.getState();
      i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        n && n(i),
        t.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    Q.jsx(gN.Provider, { value: t, children: e })
  );
}
function _N(t, e) {
  const n = Ec.get(t),
    r = n == null ? void 0 : n.fiber;
  if (r) {
    const i = n == null ? void 0 : n.store.getState();
    i && (i.internal.active = !1),
      Hg.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              i.events.disconnect == null || i.events.disconnect(),
                (s = i.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                WG(i),
                Ec.delete(t);
            } catch {}
          }, 500);
      });
  }
}
Hg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: U.version,
});
const h_ = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function r8(t) {
  const { handlePointer: e } = XG(t);
  return {
    priority: 1,
    enabled: !0,
    compute(n, r, i) {
      r.pointer.set(
        (n.offsetX / r.size.width) * 2 - 1,
        -(n.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(h_).reduce((n, r) => ({ ...n, [r]: e(r) }), {}),
    update: () => {
      var n;
      const { events: r, internal: i } = t.getState();
      (n = i.lastEvent) != null &&
        n.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (n) => {
      var r;
      const { set: i, events: s } = t.getState();
      s.disconnect == null || s.disconnect(),
        i((o) => ({ events: { ...o.events, connected: n } })),
        Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
          const [l, f] = h_[o];
          n.addEventListener(l, a, { passive: f });
        });
    },
    disconnect: () => {
      const { set: n, events: r } = t.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = h_[s];
            r.connected.removeEventListener(a, o);
          }
        }),
          n((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
function KC(t, e) {
  let n;
  return (...r) => {
    window.clearTimeout(n), (n = window.setTimeout(() => t(...r), e));
  };
}
function i8(
  { debounce: t, scroll: e, polyfill: n, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = n || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [s, o] = U.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = U.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    l = t ? (typeof t == "number" ? t : t.scroll) : null,
    f = t ? (typeof t == "number" ? t : t.resize) : null,
    d = U.useRef(!1);
  U.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [h, p, g] = U.useMemo(() => {
    const m = () => {
      if (!a.current.element) return;
      const {
          left: w,
          top: S,
          width: E,
          height: T,
          bottom: A,
          right: L,
          x: N,
          y: C,
        } = a.current.element.getBoundingClientRect(),
        I = {
          left: w,
          top: S,
          width: E,
          height: T,
          bottom: A,
          right: L,
          x: N,
          y: C,
        };
      a.current.element instanceof HTMLElement &&
        r &&
        ((I.height = a.current.element.offsetHeight),
        (I.width = a.current.element.offsetWidth)),
        Object.freeze(I),
        d.current &&
          !l8(a.current.lastBounds, I) &&
          o((a.current.lastBounds = I));
    };
    return [m, f ? KC(m, f) : m, l ? KC(m, l) : m];
  }, [o, r, l, f]);
  function v() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((m) =>
        m.removeEventListener("scroll", g, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function _() {
    a.current.element &&
      ((a.current.resizeObserver = new i(g)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((m) =>
          m.addEventListener("scroll", g, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        g();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const x = (m) => {
    !m ||
      m === a.current.element ||
      (v(), (a.current.element = m), (a.current.scrollContainers = SN(m)), _());
  };
  return (
    o8(g, !!e),
    s8(p),
    U.useEffect(() => {
      v(), _();
    }, [e, g, p]),
    U.useEffect(() => v, []),
    [x, s, h]
  );
}
function s8(t) {
  U.useEffect(() => {
    const e = t;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [t]);
}
function o8(t, e) {
  U.useEffect(() => {
    if (e) {
      const n = t;
      return (
        window.addEventListener("scroll", n, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", n, !0)
      );
    }
  }, [t, e]);
}
function SN(t) {
  const e = [];
  if (!t || t === document.body) return e;
  const {
    overflow: n,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(t);
  return (
    [n, r, i].some((s) => s === "auto" || s === "scroll") && e.push(t),
    [...e, ...SN(t.parentElement)]
  );
}
const a8 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  l8 = (t, e) => a8.every((n) => t[n] === e[n]);
var u8 = Object.defineProperty,
  c8 = Object.defineProperties,
  f8 = Object.getOwnPropertyDescriptors,
  ZC = Object.getOwnPropertySymbols,
  d8 = Object.prototype.hasOwnProperty,
  h8 = Object.prototype.propertyIsEnumerable,
  JC = (t, e, n) =>
    e in t
      ? u8(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  QC = (t, e) => {
    for (var n in e || (e = {})) d8.call(e, n) && JC(t, n, e[n]);
    if (ZC) for (var n of ZC(e)) h8.call(e, n) && JC(t, n, e[n]);
    return t;
  },
  p8 = (t, e) => c8(t, f8(e)),
  eR,
  tR;
typeof window < "u" &&
(((eR = window.document) != null && eR.createElement) ||
  ((tR = window.navigator) == null ? void 0 : tR.product) === "ReactNative")
  ? U.useLayoutEffect
  : U.useEffect;
function wN(t, e, n) {
  if (!t) return;
  if (n(t) === !0) return t;
  let r = t.child;
  for (; r; ) {
    const i = wN(r, e, n);
    if (i) return i;
    r = r.sibling;
  }
}
function MN(t) {
  try {
    return Object.defineProperties(t, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return t;
  }
}
const nR = console.error;
console.error = function () {
  const t = [...arguments].join("");
  if (t != null && t.startsWith("Warning:") && t.includes("useContext")) {
    console.error = nR;
    return;
  }
  return nR.apply(this, arguments);
};
const NM = MN(U.createContext(null));
class EN extends U.Component {
  render() {
    return U.createElement(
      NM.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function m8() {
  const t = U.useContext(NM);
  if (t === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = U.useId();
  return U.useMemo(() => {
    for (const r of [t, t == null ? void 0 : t.alternate]) {
      if (!r) continue;
      const i = wN(r, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (i) return i;
    }
  }, [t, e]);
}
function g8() {
  const t = m8(),
    [e] = U.useState(() => new Map());
  e.clear();
  let n = t;
  for (; n; ) {
    if (n.type && typeof n.type == "object") {
      const i =
        n.type._context === void 0 && n.type.Provider === n.type
          ? n.type
          : n.type._context;
      i && i !== NM && !e.has(i) && e.set(i, U.useContext(MN(i)));
    }
    n = n.return;
  }
  return e;
}
function v8() {
  const t = g8();
  return U.useMemo(
    () =>
      Array.from(t.keys()).reduce(
        (e, n) => (r) =>
          U.createElement(
            e,
            null,
            U.createElement(n.Provider, p8(QC({}, r), { value: t.get(n) }))
          ),
        (e) => U.createElement(EN, QC({}, e))
      ),
    [t]
  );
}
const y8 = U.forwardRef(function (
    {
      children: e,
      fallback: n,
      resize: r,
      style: i,
      gl: s,
      events: o = r8,
      eventSource: a,
      eventPrefix: l,
      shadows: f,
      linear: d,
      flat: h,
      legacy: p,
      orthographic: g,
      frameloop: v,
      dpr: _,
      performance: x,
      raycaster: m,
      camera: w,
      scene: S,
      onPointerMissed: E,
      onCreated: T,
      ...A
    },
    L
  ) {
    U.useMemo(() => UG(TG), []);
    const N = v8(),
      [C, I] = i8({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      k = U.useRef(null),
      R = U.useRef(null);
    U.useImperativeHandle(L, () => k.current);
    const $ = uN(E),
      [D, W] = U.useState(!1),
      [Y, Z] = U.useState(!1);
    if (D) throw D;
    if (Y) throw Y;
    const B = U.useRef(null);
    ph(() => {
      const X = k.current;
      I.width > 0 &&
        I.height > 0 &&
        X &&
        (B.current || (B.current = t8(X)),
        B.current.configure({
          gl: s,
          events: o,
          shadows: f,
          linear: d,
          flat: h,
          legacy: p,
          orthographic: g,
          frameloop: v,
          dpr: _,
          performance: x,
          raycaster: m,
          camera: w,
          scene: S,
          size: I,
          onPointerMissed: (...te) =>
            $.current == null ? void 0 : $.current(...te),
          onCreated: (te) => {
            te.events.connect == null ||
              te.events.connect(a ? (zG(a) ? a.current : a) : R.current),
              l &&
                te.setEvents({
                  compute: (oe, J) => {
                    const ae = oe[l + "X"],
                      Se = oe[l + "Y"];
                    J.pointer.set(
                      (ae / J.size.width) * 2 - 1,
                      -(Se / J.size.height) * 2 + 1
                    ),
                      J.raycaster.setFromCamera(J.pointer, J.camera);
                  },
                }),
              T == null || T(te);
          },
        }),
        B.current.render(
          Q.jsx(N, {
            children: Q.jsx(cN, {
              set: Z,
              children: Q.jsx(U.Suspense, {
                fallback: Q.jsx(BG, { set: W }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      U.useEffect(() => {
        const X = k.current;
        if (X) return () => _N(X);
      }, []);
    const G = a ? "none" : "auto";
    return Q.jsx("div", {
      ref: R,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: G,
        ...i,
      },
      ...A,
      children: Q.jsx("div", {
        ref: C,
        style: { width: "100%", height: "100%" },
        children: Q.jsx("canvas", {
          ref: k,
          style: { display: "block" },
          children: n,
        }),
      }),
    });
  }),
  x8 = U.forwardRef(function (e, n) {
    return Q.jsx(EN, { children: Q.jsx(y8, { ...e, ref: n }) });
  });
var _8 = Object.defineProperty,
  S8 = (t, e, n) =>
    e in t
      ? _8(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  w8 = (t, e, n) => (S8(t, e + "", n), n);
class M8 {
  constructor() {
    w8(this, "_listeners");
  }
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(n);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
var E8 = Object.defineProperty,
  b8 = (t, e, n) =>
    e in t
      ? E8(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ut = (t, e, n) => (b8(t, typeof e != "symbol" ? e + "" : e, n), n);
const Rm = new kl(),
  rR = new ao(),
  T8 = Math.cos(70 * (Math.PI / 180)),
  iR = (t, e) => ((t % e) + e) % e;
let A8 = class extends M8 {
  constructor(e, n) {
    super(),
      ut(this, "object"),
      ut(this, "domElement"),
      ut(this, "enabled", !0),
      ut(this, "target", new z()),
      ut(this, "minDistance", 0),
      ut(this, "maxDistance", 1 / 0),
      ut(this, "minZoom", 0),
      ut(this, "maxZoom", 1 / 0),
      ut(this, "minPolarAngle", 0),
      ut(this, "maxPolarAngle", Math.PI),
      ut(this, "minAzimuthAngle", -1 / 0),
      ut(this, "maxAzimuthAngle", 1 / 0),
      ut(this, "enableDamping", !1),
      ut(this, "dampingFactor", 0.05),
      ut(this, "enableZoom", !0),
      ut(this, "zoomSpeed", 1),
      ut(this, "enableRotate", !0),
      ut(this, "rotateSpeed", 1),
      ut(this, "enablePan", !0),
      ut(this, "panSpeed", 1),
      ut(this, "screenSpacePanning", !0),
      ut(this, "keyPanSpeed", 7),
      ut(this, "zoomToCursor", !1),
      ut(this, "autoRotate", !1),
      ut(this, "autoRotateSpeed", 2),
      ut(this, "reverseOrbit", !1),
      ut(this, "reverseHorizontalOrbit", !1),
      ut(this, "reverseVerticalOrbit", !1),
      ut(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      ut(this, "mouseButtons", {
        LEFT: Qa.ROTATE,
        MIDDLE: Qa.DOLLY,
        RIGHT: Qa.PAN,
      }),
      ut(this, "touches", { ONE: el.ROTATE, TWO: el.DOLLY_PAN }),
      ut(this, "target0"),
      ut(this, "position0"),
      ut(this, "zoom0"),
      ut(this, "_domElementKeyEvents", null),
      ut(this, "getPolarAngle"),
      ut(this, "getAzimuthalAngle"),
      ut(this, "setPolarAngle"),
      ut(this, "setAzimuthalAngle"),
      ut(this, "getDistance"),
      ut(this, "getZoomScale"),
      ut(this, "listenToKeyEvents"),
      ut(this, "stopListenToKeyEvents"),
      ut(this, "saveState"),
      ut(this, "reset"),
      ut(this, "update"),
      ut(this, "connect"),
      ut(this, "dispose"),
      ut(this, "dollyIn"),
      ut(this, "dollyOut"),
      ut(this, "getScale"),
      ut(this, "setScale"),
      (this.object = e),
      (this.domElement = n),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => d.phi),
      (this.getAzimuthalAngle = () => d.theta),
      (this.setPolarAngle = (q) => {
        let me = iR(q, 2 * Math.PI),
          be = d.phi;
        be < 0 && (be += 2 * Math.PI), me < 0 && (me += 2 * Math.PI);
        let ue = Math.abs(me - be);
        2 * Math.PI - ue < ue &&
          (me < be ? (me += 2 * Math.PI) : (be += 2 * Math.PI)),
          (h.phi = me - be),
          r.update();
      }),
      (this.setAzimuthalAngle = (q) => {
        let me = iR(q, 2 * Math.PI),
          be = d.theta;
        be < 0 && (be += 2 * Math.PI), me < 0 && (me += 2 * Math.PI);
        let ue = Math.abs(me - be);
        2 * Math.PI - ue < ue &&
          (me < be ? (me += 2 * Math.PI) : (be += 2 * Math.PI)),
          (h.theta = me - be),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (q) => {
        q.addEventListener("keydown", Ae), (this._domElementKeyEvents = q);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Ae),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const q = new z(),
          me = new z(0, 1, 0),
          be = new Rr().setFromUnitVectors(e.up, me),
          ue = be.clone().invert(),
          Be = new z(),
          K = new Rr(),
          ze = 2 * Math.PI;
        return function () {
          const ye = r.object.position;
          be.setFromUnitVectors(e.up, me),
            ue.copy(be).invert(),
            q.copy(ye).sub(r.target),
            q.applyQuaternion(be),
            d.setFromVector3(q),
            r.autoRotate && l === a.NONE && D(R()),
            r.enableDamping
              ? ((d.theta += h.theta * r.dampingFactor),
                (d.phi += h.phi * r.dampingFactor))
              : ((d.theta += h.theta), (d.phi += h.phi));
          let Oe = r.minAzimuthAngle,
            nt = r.maxAzimuthAngle;
          isFinite(Oe) &&
            isFinite(nt) &&
            (Oe < -Math.PI ? (Oe += ze) : Oe > Math.PI && (Oe -= ze),
            nt < -Math.PI ? (nt += ze) : nt > Math.PI && (nt -= ze),
            Oe <= nt
              ? (d.theta = Math.max(Oe, Math.min(nt, d.theta)))
              : (d.theta =
                  d.theta > (Oe + nt) / 2
                    ? Math.max(Oe, d.theta)
                    : Math.min(nt, d.theta))),
            (d.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, d.phi)
            )),
            d.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(g, r.dampingFactor)
              : r.target.add(g),
            (r.zoomToCursor && C) || r.object.isOrthographicCamera
              ? (d.radius = J(d.radius))
              : (d.radius = J(d.radius * p)),
            q.setFromSpherical(d),
            q.applyQuaternion(ue),
            ye.copy(r.target).add(q),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((h.theta *= 1 - r.dampingFactor),
                (h.phi *= 1 - r.dampingFactor),
                g.multiplyScalar(1 - r.dampingFactor))
              : (h.set(0, 0, 0), g.set(0, 0, 0));
          let xt = !1;
          if (r.zoomToCursor && C) {
            let qt = null;
            if (r.object instanceof Pn && r.object.isPerspectiveCamera) {
              const sn = q.length();
              qt = J(sn * p);
              const It = sn - qt;
              r.object.position.addScaledVector(L, It),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const sn = new z(N.x, N.y, 0);
              sn.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix(),
                (xt = !0);
              const It = new z(N.x, N.y, 0);
              It.unproject(r.object),
                r.object.position.sub(It).add(sn),
                r.object.updateMatrixWorld(),
                (qt = q.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            qt !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(qt)
                    .add(r.object.position)
                : (Rm.origin.copy(r.object.position),
                  Rm.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Rm.direction)) < T8
                    ? e.lookAt(r.target)
                    : (rR.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Rm.intersectPlane(rR, r.target))));
          } else
            r.object instanceof da &&
              r.object.isOrthographicCamera &&
              ((xt = p !== 1),
              xt &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (p = 1),
            (C = !1),
            xt ||
            Be.distanceToSquared(r.object.position) > f ||
            8 * (1 - K.dot(r.object.quaternion)) > f
              ? (r.dispatchEvent(i),
                Be.copy(r.object.position),
                K.copy(r.object.quaternion),
                (xt = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (q) => {
        (r.domElement = q),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", Te),
          r.domElement.addEventListener("pointerdown", Tt),
          r.domElement.addEventListener("pointercancel", O),
          r.domElement.addEventListener("wheel", Ee);
      }),
      (this.dispose = () => {
        var q, me, be, ue, Be, K;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (q = r.domElement) == null ||
            q.removeEventListener("contextmenu", Te),
          (me = r.domElement) == null ||
            me.removeEventListener("pointerdown", Tt),
          (be = r.domElement) == null ||
            be.removeEventListener("pointercancel", O),
          (ue = r.domElement) == null || ue.removeEventListener("wheel", Ee),
          (Be = r.domElement) == null ||
            Be.ownerDocument.removeEventListener("pointermove", V),
          (K = r.domElement) == null ||
            K.ownerDocument.removeEventListener("pointerup", O),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Ae);
      });
    const r = this,
      i = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const f = 1e-6,
      d = new h1(),
      h = new h1();
    let p = 1;
    const g = new z(),
      v = new _e(),
      _ = new _e(),
      x = new _e(),
      m = new _e(),
      w = new _e(),
      S = new _e(),
      E = new _e(),
      T = new _e(),
      A = new _e(),
      L = new z(),
      N = new _e();
    let C = !1;
    const I = [],
      k = {};
    function R() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function $() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function D(q) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (h.theta += q)
        : (h.theta -= q);
    }
    function W(q) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (h.phi += q) : (h.phi -= q);
    }
    const Y = (() => {
        const q = new z();
        return function (be, ue) {
          q.setFromMatrixColumn(ue, 0), q.multiplyScalar(-be), g.add(q);
        };
      })(),
      Z = (() => {
        const q = new z();
        return function (be, ue) {
          r.screenSpacePanning === !0
            ? q.setFromMatrixColumn(ue, 1)
            : (q.setFromMatrixColumn(ue, 0), q.crossVectors(r.object.up, q)),
            q.multiplyScalar(be),
            g.add(q);
        };
      })(),
      B = (() => {
        const q = new z();
        return function (be, ue) {
          const Be = r.domElement;
          if (Be && r.object instanceof Pn && r.object.isPerspectiveCamera) {
            const K = r.object.position;
            q.copy(K).sub(r.target);
            let ze = q.length();
            (ze *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              Y((2 * be * ze) / Be.clientHeight, r.object.matrix),
              Z((2 * ue * ze) / Be.clientHeight, r.object.matrix);
          } else
            Be && r.object instanceof da && r.object.isOrthographicCamera
              ? (Y(
                  (be * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Be.clientWidth,
                  r.object.matrix
                ),
                Z(
                  (ue * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Be.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function G(q) {
      (r.object instanceof Pn && r.object.isPerspectiveCamera) ||
      (r.object instanceof da && r.object.isOrthographicCamera)
        ? (p = q)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function X(q) {
      G(p / q);
    }
    function te(q) {
      G(p * q);
    }
    function oe(q) {
      if (!r.zoomToCursor || !r.domElement) return;
      C = !0;
      const me = r.domElement.getBoundingClientRect(),
        be = q.clientX - me.left,
        ue = q.clientY - me.top,
        Be = me.width,
        K = me.height;
      (N.x = (be / Be) * 2 - 1),
        (N.y = -(ue / K) * 2 + 1),
        L.set(N.x, N.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function J(q) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, q));
    }
    function ae(q) {
      v.set(q.clientX, q.clientY);
    }
    function Se(q) {
      oe(q), E.set(q.clientX, q.clientY);
    }
    function Ie(q) {
      m.set(q.clientX, q.clientY);
    }
    function Ce(q) {
      _.set(q.clientX, q.clientY),
        x.subVectors(_, v).multiplyScalar(r.rotateSpeed);
      const me = r.domElement;
      me &&
        (D((2 * Math.PI * x.x) / me.clientHeight),
        W((2 * Math.PI * x.y) / me.clientHeight)),
        v.copy(_),
        r.update();
    }
    function et(q) {
      T.set(q.clientX, q.clientY),
        A.subVectors(T, E),
        A.y > 0 ? X($()) : A.y < 0 && te($()),
        E.copy(T),
        r.update();
    }
    function We(q) {
      w.set(q.clientX, q.clientY),
        S.subVectors(w, m).multiplyScalar(r.panSpeed),
        B(S.x, S.y),
        m.copy(w),
        r.update();
    }
    function Me(q) {
      oe(q), q.deltaY < 0 ? te($()) : q.deltaY > 0 && X($()), r.update();
    }
    function Le(q) {
      let me = !1;
      switch (q.code) {
        case r.keys.UP:
          B(0, r.keyPanSpeed), (me = !0);
          break;
        case r.keys.BOTTOM:
          B(0, -r.keyPanSpeed), (me = !0);
          break;
        case r.keys.LEFT:
          B(r.keyPanSpeed, 0), (me = !0);
          break;
        case r.keys.RIGHT:
          B(-r.keyPanSpeed, 0), (me = !0);
          break;
      }
      me && (q.preventDefault(), r.update());
    }
    function H() {
      if (I.length == 1) v.set(I[0].pageX, I[0].pageY);
      else {
        const q = 0.5 * (I[0].pageX + I[1].pageX),
          me = 0.5 * (I[0].pageY + I[1].pageY);
        v.set(q, me);
      }
    }
    function pe() {
      if (I.length == 1) m.set(I[0].pageX, I[0].pageY);
      else {
        const q = 0.5 * (I[0].pageX + I[1].pageX),
          me = 0.5 * (I[0].pageY + I[1].pageY);
        m.set(q, me);
      }
    }
    function ie() {
      const q = I[0].pageX - I[1].pageX,
        me = I[0].pageY - I[1].pageY,
        be = Math.sqrt(q * q + me * me);
      E.set(0, be);
    }
    function we() {
      r.enableZoom && ie(), r.enablePan && pe();
    }
    function xe() {
      r.enableZoom && ie(), r.enableRotate && H();
    }
    function $e(q) {
      if (I.length == 1) _.set(q.pageX, q.pageY);
      else {
        const be = Pt(q),
          ue = 0.5 * (q.pageX + be.x),
          Be = 0.5 * (q.pageY + be.y);
        _.set(ue, Be);
      }
      x.subVectors(_, v).multiplyScalar(r.rotateSpeed);
      const me = r.domElement;
      me &&
        (D((2 * Math.PI * x.x) / me.clientHeight),
        W((2 * Math.PI * x.y) / me.clientHeight)),
        v.copy(_);
    }
    function Fe(q) {
      if (I.length == 1) w.set(q.pageX, q.pageY);
      else {
        const me = Pt(q),
          be = 0.5 * (q.pageX + me.x),
          ue = 0.5 * (q.pageY + me.y);
        w.set(be, ue);
      }
      S.subVectors(w, m).multiplyScalar(r.panSpeed), B(S.x, S.y), m.copy(w);
    }
    function He(q) {
      const me = Pt(q),
        be = q.pageX - me.x,
        ue = q.pageY - me.y,
        Be = Math.sqrt(be * be + ue * ue);
      T.set(0, Be),
        A.set(0, Math.pow(T.y / E.y, r.zoomSpeed)),
        X(A.y),
        E.copy(T);
    }
    function Ze(q) {
      r.enableZoom && He(q), r.enablePan && Fe(q);
    }
    function it(q) {
      r.enableZoom && He(q), r.enableRotate && $e(q);
    }
    function Tt(q) {
      var me, be;
      r.enabled !== !1 &&
        (I.length === 0 &&
          ((me = r.domElement) == null ||
            me.ownerDocument.addEventListener("pointermove", V),
          (be = r.domElement) == null ||
            be.ownerDocument.addEventListener("pointerup", O)),
        at(q),
        q.pointerType === "touch" ? Ye(q) : se(q));
    }
    function V(q) {
      r.enabled !== !1 && (q.pointerType === "touch" ? Pe(q) : Re(q));
    }
    function O(q) {
      var me, be, ue;
      wt(q),
        I.length === 0 &&
          ((me = r.domElement) == null || me.releasePointerCapture(q.pointerId),
          (be = r.domElement) == null ||
            be.ownerDocument.removeEventListener("pointermove", V),
          (ue = r.domElement) == null ||
            ue.ownerDocument.removeEventListener("pointerup", O)),
        r.dispatchEvent(o),
        (l = a.NONE);
    }
    function se(q) {
      let me;
      switch (q.button) {
        case 0:
          me = r.mouseButtons.LEFT;
          break;
        case 1:
          me = r.mouseButtons.MIDDLE;
          break;
        case 2:
          me = r.mouseButtons.RIGHT;
          break;
        default:
          me = -1;
      }
      switch (me) {
        case Qa.DOLLY:
          if (r.enableZoom === !1) return;
          Se(q), (l = a.DOLLY);
          break;
        case Qa.ROTATE:
          if (q.ctrlKey || q.metaKey || q.shiftKey) {
            if (r.enablePan === !1) return;
            Ie(q), (l = a.PAN);
          } else {
            if (r.enableRotate === !1) return;
            ae(q), (l = a.ROTATE);
          }
          break;
        case Qa.PAN:
          if (q.ctrlKey || q.metaKey || q.shiftKey) {
            if (r.enableRotate === !1) return;
            ae(q), (l = a.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            Ie(q), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(s);
    }
    function Re(q) {
      if (r.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (r.enableRotate === !1) return;
            Ce(q);
            break;
          case a.DOLLY:
            if (r.enableZoom === !1) return;
            et(q);
            break;
          case a.PAN:
            if (r.enablePan === !1) return;
            We(q);
            break;
        }
    }
    function Ee(q) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (q.preventDefault(), r.dispatchEvent(s), Me(q), r.dispatchEvent(o));
    }
    function Ae(q) {
      r.enabled === !1 || r.enablePan === !1 || Le(q);
    }
    function Ye(q) {
      switch ((Ne(q), I.length)) {
        case 1:
          switch (r.touches.ONE) {
            case el.ROTATE:
              if (r.enableRotate === !1) return;
              H(), (l = a.TOUCH_ROTATE);
              break;
            case el.PAN:
              if (r.enablePan === !1) return;
              pe(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case el.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              we(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case el.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              xe(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(s);
    }
    function Pe(q) {
      switch ((Ne(q), l)) {
        case a.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          $e(q), r.update();
          break;
        case a.TOUCH_PAN:
          if (r.enablePan === !1) return;
          Fe(q), r.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          Ze(q), r.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          it(q), r.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function Te(q) {
      r.enabled !== !1 && q.preventDefault();
    }
    function at(q) {
      I.push(q);
    }
    function wt(q) {
      delete k[q.pointerId];
      for (let me = 0; me < I.length; me++)
        if (I[me].pointerId == q.pointerId) {
          I.splice(me, 1);
          return;
        }
    }
    function Ne(q) {
      let me = k[q.pointerId];
      me === void 0 && ((me = new _e()), (k[q.pointerId] = me)),
        me.set(q.pageX, q.pageY);
    }
    function Pt(q) {
      const me = q.pointerId === I[0].pointerId ? I[1] : I[0];
      return k[me.pointerId];
    }
    (this.dollyIn = (q = $()) => {
      te(q), r.update();
    }),
      (this.dollyOut = (q = $()) => {
        X(q), r.update();
      }),
      (this.getScale = () => p),
      (this.setScale = (q) => {
        G(q), r.update();
      }),
      (this.getZoomScale = () => $()),
      n !== void 0 && this.connect(n),
      this.update();
  }
};
const C8 = U.forwardRef(
    (
      {
        makeDefault: t,
        camera: e,
        regress: n,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: a,
        onEnd: l,
        ...f
      },
      d
    ) => {
      const h = io((A) => A.invalidate),
        p = io((A) => A.camera),
        g = io((A) => A.gl),
        v = io((A) => A.events),
        _ = io((A) => A.setEvents),
        x = io((A) => A.set),
        m = io((A) => A.get),
        w = io((A) => A.performance),
        S = e || p,
        E = r || v.connected || g.domElement,
        T = U.useMemo(() => new A8(S), [S]);
      return (
        yN(() => {
          T.enabled && T.update();
        }, -1),
        U.useEffect(
          () => (
            s && T.connect(s === !0 ? E : s),
            T.connect(E),
            () => void T.dispose()
          ),
          [s, E, n, T, h]
        ),
        U.useEffect(() => {
          const A = (C) => {
              h(), n && w.regress(), o && o(C);
            },
            L = (C) => {
              a && a(C);
            },
            N = (C) => {
              l && l(C);
            };
          return (
            T.addEventListener("change", A),
            T.addEventListener("start", L),
            T.addEventListener("end", N),
            () => {
              T.removeEventListener("start", L),
                T.removeEventListener("end", N),
                T.removeEventListener("change", A);
            }
          );
        }, [o, a, l, T, h, _]),
        U.useEffect(() => {
          if (t) {
            const A = m().controls;
            return x({ controls: T }), () => x({ controls: A });
          }
        }, [t, T]),
        U.createElement(
          "primitive",
          Rg({ ref: d, object: T, enableDamping: i }, f)
        )
      );
    }
  ),
  R8 = "images/attacker-BFJ4Doun.jpg",
  L8 = "images/attackerWallet-CzjUpKyb.jpg",
  P8 = "images/merchant-EJXIfwrZ.jpg",
  I8 = "images/merchantCoin-DqFz-cb6.png",
  Yd = { black: "#000", white: "#fff" },
  Au = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828",
  },
  Cu = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2",
  },
  Ru = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0",
  },
  Pu = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b",
  },
  Lu = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
  },
  Cf = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100",
  },
  N8 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  };
function Mo(t, ...e) {
  const n = new URL(`https://mui.com/production-error/?code=${t}`);
  return (
    e.forEach((r) => n.searchParams.append("args[]", r)),
    `Minified MUI error #${t}; visit ${n} for the full message.`
  );
}
const OM = "$$material";
function O8(t) {
  if (t.sheet) return t.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e];
}
function D8(t) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", t.key),
    t.nonce !== void 0 && e.setAttribute("nonce", t.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var k8 = (function () {
    function t(n) {
      var r = this;
      (this._insertTag = function (i) {
        var s;
        r.tags.length === 0
          ? r.insertionPoint
            ? (s = r.insertionPoint.nextSibling)
            : r.prepend
            ? (s = r.container.firstChild)
            : (s = r.before)
          : (s = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(i, s),
          r.tags.push(i);
      }),
        (this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = n.nonce),
        (this.key = n.key),
        (this.container = n.container),
        (this.prepend = n.prepend),
        (this.insertionPoint = n.insertionPoint),
        (this.before = null);
    }
    var e = t.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(D8(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var s = O8(i);
          try {
            s.insertRule(r, s.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          var i;
          return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      t
    );
  })(),
  Er = "-ms-",
  Vg = "-moz-",
  zt = "-webkit-",
  bN = "comm",
  DM = "rule",
  kM = "decl",
  U8 = "@import",
  TN = "@keyframes",
  F8 = "@layer",
  z8 = Math.abs,
  av = String.fromCharCode,
  B8 = Object.assign;
function H8(t, e) {
  return cr(t, 0) ^ 45
    ? (((((((e << 2) ^ cr(t, 0)) << 2) ^ cr(t, 1)) << 2) ^ cr(t, 2)) << 2) ^
        cr(t, 3)
    : 0;
}
function AN(t) {
  return t.trim();
}
function V8(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function Bt(t, e, n) {
  return t.replace(e, n);
}
function v1(t, e) {
  return t.indexOf(e);
}
function cr(t, e) {
  return t.charCodeAt(e) | 0;
}
function qd(t, e, n) {
  return t.slice(e, n);
}
function As(t) {
  return t.length;
}
function UM(t) {
  return t.length;
}
function Pm(t, e) {
  return e.push(t), t;
}
function W8(t, e) {
  return t.map(e).join("");
}
var lv = 1,
  bc = 1,
  CN = 0,
  ri = 0,
  Un = 0,
  kc = "";
function uv(t, e, n, r, i, s, o) {
  return {
    value: t,
    root: e,
    parent: n,
    type: r,
    props: i,
    children: s,
    line: lv,
    column: bc,
    length: o,
    return: "",
  };
}
function Rf(t, e) {
  return B8(uv("", null, null, "", null, null, 0), t, { length: -t.length }, e);
}
function G8() {
  return Un;
}
function j8() {
  return (
    (Un = ri > 0 ? cr(kc, --ri) : 0), bc--, Un === 10 && ((bc = 1), lv--), Un
  );
}
function yi() {
  return (
    (Un = ri < CN ? cr(kc, ri++) : 0), bc++, Un === 10 && ((bc = 1), lv++), Un
  );
}
function Fs() {
  return cr(kc, ri);
}
function tg() {
  return ri;
}
function mh(t, e) {
  return qd(kc, t, e);
}
function Kd(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function RN(t) {
  return (lv = bc = 1), (CN = As((kc = t))), (ri = 0), [];
}
function PN(t) {
  return (kc = ""), t;
}
function ng(t) {
  return AN(mh(ri - 1, y1(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function $8(t) {
  for (; (Un = Fs()) && Un < 33; ) yi();
  return Kd(t) > 2 || Kd(Un) > 3 ? "" : " ";
}
function X8(t, e) {
  for (
    ;
    --e &&
    yi() &&
    !(Un < 48 || Un > 102 || (Un > 57 && Un < 65) || (Un > 70 && Un < 97));

  );
  return mh(t, tg() + (e < 6 && Fs() == 32 && yi() == 32));
}
function y1(t) {
  for (; yi(); )
    switch (Un) {
      case t:
        return ri;
      case 34:
      case 39:
        t !== 34 && t !== 39 && y1(Un);
        break;
      case 40:
        t === 41 && y1(t);
        break;
      case 92:
        yi();
        break;
    }
  return ri;
}
function Y8(t, e) {
  for (; yi() && t + Un !== 57; ) if (t + Un === 84 && Fs() === 47) break;
  return "/*" + mh(e, ri - 1) + "*" + av(t === 47 ? t : yi());
}
function q8(t) {
  for (; !Kd(Fs()); ) yi();
  return mh(t, ri);
}
function K8(t) {
  return PN(rg("", null, null, null, [""], (t = RN(t)), 0, [0], t));
}
function rg(t, e, n, r, i, s, o, a, l) {
  for (
    var f = 0,
      d = 0,
      h = o,
      p = 0,
      g = 0,
      v = 0,
      _ = 1,
      x = 1,
      m = 1,
      w = 0,
      S = "",
      E = i,
      T = s,
      A = r,
      L = S;
    x;

  )
    switch (((v = w), (w = yi()))) {
      case 40:
        if (v != 108 && cr(L, h - 1) == 58) {
          v1((L += Bt(ng(w), "&", "&\f")), "&\f") != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        L += ng(w);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        L += $8(v);
        break;
      case 92:
        L += X8(tg() - 1, 7);
        continue;
      case 47:
        switch (Fs()) {
          case 42:
          case 47:
            Pm(Z8(Y8(yi(), tg()), e, n), l);
            break;
          default:
            L += "/";
        }
        break;
      case 123 * _:
        a[f++] = As(L) * m;
      case 125 * _:
      case 59:
      case 0:
        switch (w) {
          case 0:
          case 125:
            x = 0;
          case 59 + d:
            m == -1 && (L = Bt(L, /\f/g, "")),
              g > 0 &&
                As(L) - h &&
                Pm(
                  g > 32
                    ? oR(L + ";", r, n, h - 1)
                    : oR(Bt(L, " ", "") + ";", r, n, h - 2),
                  l
                );
            break;
          case 59:
            L += ";";
          default:
            if (
              (Pm((A = sR(L, e, n, f, d, i, a, S, (E = []), (T = []), h)), s),
              w === 123)
            )
              if (d === 0) rg(L, e, A, A, E, s, h, a, T);
              else
                switch (p === 99 && cr(L, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    rg(
                      t,
                      A,
                      A,
                      r && Pm(sR(t, A, A, 0, 0, i, a, S, i, (E = []), h), T),
                      i,
                      T,
                      h,
                      a,
                      r ? E : T
                    );
                    break;
                  default:
                    rg(L, A, A, A, [""], T, 0, a, T);
                }
        }
        (f = d = g = 0), (_ = m = 1), (S = L = ""), (h = o);
        break;
      case 58:
        (h = 1 + As(L)), (g = v);
      default:
        if (_ < 1) {
          if (w == 123) --_;
          else if (w == 125 && _++ == 0 && j8() == 125) continue;
        }
        switch (((L += av(w)), w * _)) {
          case 38:
            m = d > 0 ? 1 : ((L += "\f"), -1);
            break;
          case 44:
            (a[f++] = (As(L) - 1) * m), (m = 1);
            break;
          case 64:
            Fs() === 45 && (L += ng(yi())),
              (p = Fs()),
              (d = h = As((S = L += q8(tg())))),
              w++;
            break;
          case 45:
            v === 45 && As(L) == 2 && (_ = 0);
        }
    }
  return s;
}
function sR(t, e, n, r, i, s, o, a, l, f, d) {
  for (
    var h = i - 1, p = i === 0 ? s : [""], g = UM(p), v = 0, _ = 0, x = 0;
    v < r;
    ++v
  )
    for (var m = 0, w = qd(t, h + 1, (h = z8((_ = o[v])))), S = t; m < g; ++m)
      (S = AN(_ > 0 ? p[m] + " " + w : Bt(w, /&\f/g, p[m]))) && (l[x++] = S);
  return uv(t, e, n, i === 0 ? DM : a, l, f, d);
}
function Z8(t, e, n) {
  return uv(t, e, n, bN, av(G8()), qd(t, 2, -2), 0);
}
function oR(t, e, n, r) {
  return uv(t, e, n, kM, qd(t, 0, r), qd(t, r + 1, -1), r);
}
function lc(t, e) {
  for (var n = "", r = UM(t), i = 0; i < r; i++) n += e(t[i], i, t, e) || "";
  return n;
}
function J8(t, e, n, r) {
  switch (t.type) {
    case F8:
      if (t.children.length) break;
    case U8:
    case kM:
      return (t.return = t.return || t.value);
    case bN:
      return "";
    case TN:
      return (t.return = t.value + "{" + lc(t.children, r) + "}");
    case DM:
      t.value = t.props.join(",");
  }
  return As((n = lc(t.children, r)))
    ? (t.return = t.value + "{" + n + "}")
    : "";
}
function Q8(t) {
  var e = UM(t);
  return function (n, r, i, s) {
    for (var o = "", a = 0; a < e; a++) o += t[a](n, r, i, s) || "";
    return o;
  };
}
function e9(t) {
  return function (e) {
    e.root || ((e = e.return) && t(e));
  };
}
function LN(t) {
  var e = Object.create(null);
  return function (n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var t9 = function (e, n, r) {
    for (
      var i = 0, s = 0;
      (i = s), (s = Fs()), i === 38 && s === 12 && (n[r] = 1), !Kd(s);

    )
      yi();
    return mh(e, ri);
  },
  n9 = function (e, n) {
    var r = -1,
      i = 44;
    do
      switch (Kd(i)) {
        case 0:
          i === 38 && Fs() === 12 && (n[r] = 1), (e[r] += t9(ri - 1, n, r));
          break;
        case 2:
          e[r] += ng(i);
          break;
        case 4:
          if (i === 44) {
            (e[++r] = Fs() === 58 ? "&\f" : ""), (n[r] = e[r].length);
            break;
          }
        default:
          e[r] += av(i);
      }
    while ((i = yi()));
    return e;
  },
  r9 = function (e, n) {
    return PN(n9(RN(e), n));
  },
  aR = new WeakMap(),
  i9 = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var n = e.value,
          r = e.parent,
          i = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && n.charCodeAt(0) !== 58 && !aR.get(r)) &&
        !i
      ) {
        aR.set(e, !0);
        for (
          var s = [], o = r9(n, s), a = r.props, l = 0, f = 0;
          l < o.length;
          l++
        )
          for (var d = 0; d < a.length; d++, f++)
            e.props[f] = s[l] ? o[l].replace(/&\f/g, a[d]) : a[d] + " " + o[l];
      }
    }
  },
  s9 = function (e) {
    if (e.type === "decl") {
      var n = e.value;
      n.charCodeAt(0) === 108 &&
        n.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function IN(t, e) {
  switch (H8(t, e)) {
    case 5103:
      return zt + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return zt + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return zt + t + Vg + t + Er + t + t;
    case 6828:
    case 4268:
      return zt + t + Er + t + t;
    case 6165:
      return zt + t + Er + "flex-" + t + t;
    case 5187:
      return (
        zt + t + Bt(t, /(\w+).+(:[^]+)/, zt + "box-$1$2" + Er + "flex-$1$2") + t
      );
    case 5443:
      return zt + t + Er + "flex-item-" + Bt(t, /flex-|-self/, "") + t;
    case 4675:
      return (
        zt +
        t +
        Er +
        "flex-line-pack" +
        Bt(t, /align-content|flex-|-self/, "") +
        t
      );
    case 5548:
      return zt + t + Er + Bt(t, "shrink", "negative") + t;
    case 5292:
      return zt + t + Er + Bt(t, "basis", "preferred-size") + t;
    case 6060:
      return (
        zt +
        "box-" +
        Bt(t, "-grow", "") +
        zt +
        t +
        Er +
        Bt(t, "grow", "positive") +
        t
      );
    case 4554:
      return zt + Bt(t, /([^-])(transform)/g, "$1" + zt + "$2") + t;
    case 6187:
      return (
        Bt(
          Bt(Bt(t, /(zoom-|grab)/, zt + "$1"), /(image-set)/, zt + "$1"),
          t,
          ""
        ) + t
      );
    case 5495:
    case 3959:
      return Bt(t, /(image-set\([^]*)/, zt + "$1$`$1");
    case 4968:
      return (
        Bt(
          Bt(t, /(.+:)(flex-)?(.*)/, zt + "box-pack:$3" + Er + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        zt +
        t +
        t
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Bt(t, /(.+)-inline(.+)/, zt + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (As(t) - 1 - e > 6)
        switch (cr(t, e + 1)) {
          case 109:
            if (cr(t, e + 4) !== 45) break;
          case 102:
            return (
              Bt(
                t,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  zt +
                  "$2-$3$1" +
                  Vg +
                  (cr(t, e + 3) == 108 ? "$3" : "$2-$3")
              ) + t
            );
          case 115:
            return ~v1(t, "stretch")
              ? IN(Bt(t, "stretch", "fill-available"), e) + t
              : t;
        }
      break;
    case 4949:
      if (cr(t, e + 1) !== 115) break;
    case 6444:
      switch (cr(t, As(t) - 3 - (~v1(t, "!important") && 10))) {
        case 107:
          return Bt(t, ":", ":" + zt) + t;
        case 101:
          return (
            Bt(
              t,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                zt +
                (cr(t, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                zt +
                "$2$3$1" +
                Er +
                "$2box$3"
            ) + t
          );
      }
      break;
    case 5936:
      switch (cr(t, e + 11)) {
        case 114:
          return zt + t + Er + Bt(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return zt + t + Er + Bt(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return zt + t + Er + Bt(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
      return zt + t + Er + t + t;
  }
  return t;
}
var o9 = function (e, n, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case kM:
          e.return = IN(e.value, e.length);
          break;
        case TN:
          return lc([Rf(e, { value: Bt(e.value, "@", "@" + zt) })], i);
        case DM:
          if (e.length)
            return W8(e.props, function (s) {
              switch (V8(s, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return lc(
                    [Rf(e, { props: [Bt(s, /:(read-\w+)/, ":" + Vg + "$1")] })],
                    i
                  );
                case "::placeholder":
                  return lc(
                    [
                      Rf(e, {
                        props: [Bt(s, /:(plac\w+)/, ":" + zt + "input-$1")],
                      }),
                      Rf(e, { props: [Bt(s, /:(plac\w+)/, ":" + Vg + "$1")] }),
                      Rf(e, { props: [Bt(s, /:(plac\w+)/, Er + "input-$1")] }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  a9 = [o9],
  l9 = function (e) {
    var n = e.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (_) {
        var x = _.getAttribute("data-emotion");
        x.indexOf(" ") !== -1 &&
          (document.head.appendChild(_), _.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || a9,
      s = {},
      o,
      a = [];
    (o = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
        function (_) {
          for (
            var x = _.getAttribute("data-emotion").split(" "), m = 1;
            m < x.length;
            m++
          )
            s[x[m]] = !0;
          a.push(_);
        }
      );
    var l,
      f = [i9, s9];
    {
      var d,
        h = [
          J8,
          e9(function (_) {
            d.insert(_);
          }),
        ],
        p = Q8(f.concat(i, h)),
        g = function (x) {
          return lc(K8(x), p);
        };
      l = function (x, m, w, S) {
        (d = w),
          g(x ? x + "{" + m.styles + "}" : m.styles),
          S && (v.inserted[m.name] = !0);
      };
    }
    var v = {
      key: n,
      sheet: new k8({
        key: n,
        container: o,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: s,
      registered: {},
      insert: l,
    };
    return v.sheet.hydrate(a), v;
  },
  u9 = !0;
function NN(t, e, n) {
  var r = "";
  return (
    n.split(" ").forEach(function (i) {
      t[i] !== void 0 ? e.push(t[i] + ";") : i && (r += i + " ");
    }),
    r
  );
}
var FM = function (e, n, r) {
    var i = e.key + "-" + n.name;
    (r === !1 || u9 === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = n.styles);
  },
  zM = function (e, n, r) {
    FM(e, n, r);
    var i = e.key + "-" + n.name;
    if (e.inserted[n.name] === void 0) {
      var s = n;
      do e.insert(n === s ? "." + i : "", s, e.sheet, !0), (s = s.next);
      while (s !== void 0);
    }
  };
function c9(t) {
  for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
    (n =
      (t.charCodeAt(r) & 255) |
      ((t.charCodeAt(++r) & 255) << 8) |
      ((t.charCodeAt(++r) & 255) << 16) |
      ((t.charCodeAt(++r) & 255) << 24)),
      (n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
      (n ^= n >>> 24),
      (e =
        ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= t.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var f9 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  d9 = /[A-Z]|^ms/g,
  h9 = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  ON = function (e) {
    return e.charCodeAt(1) === 45;
  },
  lR = function (e) {
    return e != null && typeof e != "boolean";
  },
  p_ = LN(function (t) {
    return ON(t) ? t : t.replace(d9, "-$&").toLowerCase();
  }),
  uR = function (e, n) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(h9, function (r, i, s) {
            return (Cs = { name: i, styles: s, next: Cs }), i;
          });
    }
    return f9[e] !== 1 && !ON(e) && typeof n == "number" && n !== 0
      ? n + "px"
      : n;
  };
function Zd(t, e, n) {
  if (n == null) return "";
  var r = n;
  if (r.__emotion_styles !== void 0) return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return (Cs = { name: i.name, styles: i.styles, next: Cs }), i.name;
      var s = n;
      if (s.styles !== void 0) {
        var o = s.next;
        if (o !== void 0)
          for (; o !== void 0; )
            (Cs = { name: o.name, styles: o.styles, next: Cs }), (o = o.next);
        var a = s.styles + ";";
        return a;
      }
      return p9(t, e, n);
    }
    case "function": {
      if (t !== void 0) {
        var l = Cs,
          f = n(t);
        return (Cs = l), Zd(t, e, f);
      }
      break;
    }
  }
  var d = n;
  if (e == null) return d;
  var h = e[d];
  return h !== void 0 ? h : d;
}
function p9(t, e, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++) r += Zd(t, e, n[i]) + ";";
  else
    for (var s in n) {
      var o = n[s];
      if (typeof o != "object") {
        var a = o;
        e != null && e[a] !== void 0
          ? (r += s + "{" + e[a] + "}")
          : lR(a) && (r += p_(s) + ":" + uR(s, a) + ";");
      } else if (
        Array.isArray(o) &&
        typeof o[0] == "string" &&
        (e == null || e[o[0]] === void 0)
      )
        for (var l = 0; l < o.length; l++)
          lR(o[l]) && (r += p_(s) + ":" + uR(s, o[l]) + ";");
      else {
        var f = Zd(t, e, o);
        switch (s) {
          case "animation":
          case "animationName": {
            r += p_(s) + ":" + f + ";";
            break;
          }
          default:
            r += s + "{" + f + "}";
        }
      }
    }
  return r;
}
var cR = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Cs;
function cv(t, e, n) {
  if (
    t.length === 1 &&
    typeof t[0] == "object" &&
    t[0] !== null &&
    t[0].styles !== void 0
  )
    return t[0];
  var r = !0,
    i = "";
  Cs = void 0;
  var s = t[0];
  if (s == null || s.raw === void 0) (r = !1), (i += Zd(n, e, s));
  else {
    var o = s;
    i += o[0];
  }
  for (var a = 1; a < t.length; a++)
    if (((i += Zd(n, e, t[a])), r)) {
      var l = s;
      i += l[a];
    }
  cR.lastIndex = 0;
  for (var f = "", d; (d = cR.exec(i)) !== null; ) f += "-" + d[1];
  var h = c9(i) + f;
  return { name: h, styles: i, next: Cs };
}
var m9 = function (e) {
    return e();
  },
  DN = b_.useInsertionEffect ? b_.useInsertionEffect : !1,
  kN = DN || m9,
  fR = DN || U.useLayoutEffect,
  UN = U.createContext(typeof HTMLElement < "u" ? l9({ key: "css" }) : null);
UN.Provider;
var BM = function (e) {
    return U.forwardRef(function (n, r) {
      var i = U.useContext(UN);
      return e(n, i, r);
    });
  },
  fv = U.createContext({}),
  HM = {}.hasOwnProperty,
  x1 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__",
  g9 = function (e, n) {
    var r = {};
    for (var i in n) HM.call(n, i) && (r[i] = n[i]);
    return (r[x1] = e), r;
  },
  v9 = function (e) {
    var n = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      FM(n, r, i),
      kN(function () {
        return zM(n, r, i);
      }),
      null
    );
  },
  y9 = BM(function (t, e, n) {
    var r = t.css;
    typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
    var i = t[x1],
      s = [r],
      o = "";
    typeof t.className == "string"
      ? (o = NN(e.registered, s, t.className))
      : t.className != null && (o = t.className + " ");
    var a = cv(s, void 0, U.useContext(fv));
    o += e.key + "-" + a.name;
    var l = {};
    for (var f in t) HM.call(t, f) && f !== "css" && f !== x1 && (l[f] = t[f]);
    return (
      (l.className = o),
      n && (l.ref = n),
      U.createElement(
        U.Fragment,
        null,
        U.createElement(v9, {
          cache: e,
          serialized: a,
          isStringTag: typeof i == "string",
        }),
        U.createElement(i, l)
      )
    );
  }),
  x9 = y9,
  dR = function (e, n) {
    var r = arguments;
    if (n == null || !HM.call(n, "css"))
      return U.createElement.apply(void 0, r);
    var i = r.length,
      s = new Array(i);
    (s[0] = x9), (s[1] = g9(e, n));
    for (var o = 2; o < i; o++) s[o] = r[o];
    return U.createElement.apply(null, s);
  };
(function (t) {
  var e;
  e || (e = t.JSX || (t.JSX = {}));
})(dR || (dR = {}));
var _9 = BM(function (t, e) {
    var n = t.styles,
      r = cv([n], void 0, U.useContext(fv)),
      i = U.useRef();
    return (
      fR(
        function () {
          var s = e.key + "-global",
            o = new e.sheet.constructor({
              key: s,
              nonce: e.sheet.nonce,
              container: e.sheet.container,
              speedy: e.sheet.isSpeedy,
            }),
            a = !1,
            l = document.querySelector(
              'style[data-emotion="' + s + " " + r.name + '"]'
            );
          return (
            e.sheet.tags.length && (o.before = e.sheet.tags[0]),
            l !== null &&
              ((a = !0), l.setAttribute("data-emotion", s), o.hydrate([l])),
            (i.current = [o, a]),
            function () {
              o.flush();
            }
          );
        },
        [e]
      ),
      fR(
        function () {
          var s = i.current,
            o = s[0],
            a = s[1];
          if (a) {
            s[1] = !1;
            return;
          }
          if ((r.next !== void 0 && zM(e, r.next, !0), o.tags.length)) {
            var l = o.tags[o.tags.length - 1].nextElementSibling;
            (o.before = l), o.flush();
          }
          e.insert("", r, o, !1);
        },
        [e, r.name]
      ),
      null
    );
  }),
  S9 =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  w9 = LN(function (t) {
    return (
      S9.test(t) ||
      (t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        t.charCodeAt(2) < 91)
    );
  }),
  M9 = w9,
  E9 = function (e) {
    return e !== "theme";
  },
  hR = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? M9 : E9;
  },
  pR = function (e, n, r) {
    var i;
    if (n) {
      var s = n.shouldForwardProp;
      i =
        e.__emotion_forwardProp && s
          ? function (o) {
              return e.__emotion_forwardProp(o) && s(o);
            }
          : s;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  },
  b9 = function (e) {
    var n = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      FM(n, r, i),
      kN(function () {
        return zM(n, r, i);
      }),
      null
    );
  },
  T9 = function t(e, n) {
    var r = e.__emotion_real === e,
      i = (r && e.__emotion_base) || e,
      s,
      o;
    n !== void 0 && ((s = n.label), (o = n.target));
    var a = pR(e, n, r),
      l = a || hR(i),
      f = !l("as");
    return function () {
      var d = arguments,
        h =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (s !== void 0 && h.push("label:" + s + ";"),
        d[0] == null || d[0].raw === void 0)
      )
        h.push.apply(h, d);
      else {
        var p = d[0];
        h.push(p[0]);
        for (var g = d.length, v = 1; v < g; v++) h.push(d[v], p[v]);
      }
      var _ = BM(function (x, m, w) {
        var S = (f && x.as) || i,
          E = "",
          T = [],
          A = x;
        if (x.theme == null) {
          A = {};
          for (var L in x) A[L] = x[L];
          A.theme = U.useContext(fv);
        }
        typeof x.className == "string"
          ? (E = NN(m.registered, T, x.className))
          : x.className != null && (E = x.className + " ");
        var N = cv(h.concat(T), m.registered, A);
        (E += m.key + "-" + N.name), o !== void 0 && (E += " " + o);
        var C = f && a === void 0 ? hR(S) : l,
          I = {};
        for (var k in x) (f && k === "as") || (C(k) && (I[k] = x[k]));
        return (
          (I.className = E),
          w && (I.ref = w),
          U.createElement(
            U.Fragment,
            null,
            U.createElement(b9, {
              cache: m,
              serialized: N,
              isStringTag: typeof S == "string",
            }),
            U.createElement(S, I)
          )
        );
      });
      return (
        (_.displayName =
          s !== void 0
            ? s
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (_.defaultProps = e.defaultProps),
        (_.__emotion_real = _),
        (_.__emotion_base = i),
        (_.__emotion_styles = h),
        (_.__emotion_forwardProp = a),
        Object.defineProperty(_, "toString", {
          value: function () {
            return "." + o;
          },
        }),
        (_.withComponent = function (x, m) {
          var w = t(x, Rg({}, n, m, { shouldForwardProp: pR(_, m, !0) }));
          return w.apply(void 0, h);
        }),
        _
      );
    };
  },
  A9 = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  _1 = T9.bind(null);
A9.forEach(function (t) {
  _1[t] = _1(t);
});
function C9(t) {
  return t == null || Object.keys(t).length === 0;
}
function R9(t) {
  const { styles: e, defaultTheme: n = {} } = t,
    r = typeof e == "function" ? (i) => e(C9(i) ? n : i) : e;
  return Q.jsx(_9, { styles: r });
}
function P9(t, e) {
  return _1(t, e);
}
function L9(t, e) {
  Array.isArray(t.__emotion_styles) &&
    (t.__emotion_styles = e(t.__emotion_styles));
}
const mR = [];
function ha(t) {
  return (mR[0] = t), cv(mR);
}
var FN = { exports: {} },
  Zt = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var VM = Symbol.for("react.transitional.element"),
  WM = Symbol.for("react.portal"),
  dv = Symbol.for("react.fragment"),
  hv = Symbol.for("react.strict_mode"),
  pv = Symbol.for("react.profiler"),
  mv = Symbol.for("react.consumer"),
  gv = Symbol.for("react.context"),
  vv = Symbol.for("react.forward_ref"),
  yv = Symbol.for("react.suspense"),
  xv = Symbol.for("react.suspense_list"),
  _v = Symbol.for("react.memo"),
  Sv = Symbol.for("react.lazy"),
  I9 = Symbol.for("react.view_transition"),
  N9 = Symbol.for("react.client.reference");
function Gi(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case VM:
        switch (((t = t.type), t)) {
          case dv:
          case pv:
          case hv:
          case yv:
          case xv:
          case I9:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case gv:
              case vv:
              case Sv:
              case _v:
                return t;
              case mv:
                return t;
              default:
                return e;
            }
        }
      case WM:
        return e;
    }
  }
}
Zt.ContextConsumer = mv;
Zt.ContextProvider = gv;
Zt.Element = VM;
Zt.ForwardRef = vv;
Zt.Fragment = dv;
Zt.Lazy = Sv;
Zt.Memo = _v;
Zt.Portal = WM;
Zt.Profiler = pv;
Zt.StrictMode = hv;
Zt.Suspense = yv;
Zt.SuspenseList = xv;
Zt.isContextConsumer = function (t) {
  return Gi(t) === mv;
};
Zt.isContextProvider = function (t) {
  return Gi(t) === gv;
};
Zt.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === VM;
};
Zt.isForwardRef = function (t) {
  return Gi(t) === vv;
};
Zt.isFragment = function (t) {
  return Gi(t) === dv;
};
Zt.isLazy = function (t) {
  return Gi(t) === Sv;
};
Zt.isMemo = function (t) {
  return Gi(t) === _v;
};
Zt.isPortal = function (t) {
  return Gi(t) === WM;
};
Zt.isProfiler = function (t) {
  return Gi(t) === pv;
};
Zt.isStrictMode = function (t) {
  return Gi(t) === hv;
};
Zt.isSuspense = function (t) {
  return Gi(t) === yv;
};
Zt.isSuspenseList = function (t) {
  return Gi(t) === xv;
};
Zt.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === dv ||
    t === pv ||
    t === hv ||
    t === yv ||
    t === xv ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === Sv ||
        t.$$typeof === _v ||
        t.$$typeof === gv ||
        t.$$typeof === mv ||
        t.$$typeof === vv ||
        t.$$typeof === N9 ||
        t.getModuleId !== void 0))
  );
};
Zt.typeOf = Gi;
FN.exports = Zt;
var zN = FN.exports;
function Ls(t) {
  if (typeof t != "object" || t === null) return !1;
  const e = Object.getPrototypeOf(t);
  return (
    (e === null ||
      e === Object.prototype ||
      Object.getPrototypeOf(e) === null) &&
    !(Symbol.toStringTag in t) &&
    !(Symbol.iterator in t)
  );
}
function BN(t) {
  if (U.isValidElement(t) || zN.isValidElementType(t) || !Ls(t)) return t;
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      e[n] = BN(t[n]);
    }),
    e
  );
}
function Lr(t, e, n = { clone: !0 }) {
  const r = n.clone ? { ...t } : t;
  return (
    Ls(t) &&
      Ls(e) &&
      Object.keys(e).forEach((i) => {
        U.isValidElement(e[i]) || zN.isValidElementType(e[i])
          ? (r[i] = e[i])
          : Ls(e[i]) && Object.prototype.hasOwnProperty.call(t, i) && Ls(t[i])
          ? (r[i] = Lr(t[i], e[i], n))
          : n.clone
          ? (r[i] = Ls(e[i]) ? BN(e[i]) : e[i])
          : (r[i] = e[i]);
      }),
    r
  );
}
const O9 = (t) => {
  const e = Object.keys(t).map((n) => ({ key: n, val: t[n] })) || [];
  return (
    e.sort((n, r) => n.val - r.val),
    e.reduce((n, r) => ({ ...n, [r.key]: r.val }), {})
  );
};
function D9(t) {
  const {
      values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: n = "px",
      step: r = 5,
      ...i
    } = t,
    s = O9(e),
    o = Object.keys(s);
  function a(p) {
    return `@media (min-width:${typeof e[p] == "number" ? e[p] : p}${n})`;
  }
  function l(p) {
    return `@media (max-width:${
      (typeof e[p] == "number" ? e[p] : p) - r / 100
    }${n})`;
  }
  function f(p, g) {
    const v = o.indexOf(g);
    return `@media (min-width:${
      typeof e[p] == "number" ? e[p] : p
    }${n}) and (max-width:${
      (v !== -1 && typeof e[o[v]] == "number" ? e[o[v]] : g) - r / 100
    }${n})`;
  }
  function d(p) {
    return o.indexOf(p) + 1 < o.length ? f(p, o[o.indexOf(p) + 1]) : a(p);
  }
  function h(p) {
    const g = o.indexOf(p);
    return g === 0
      ? a(o[1])
      : g === o.length - 1
      ? l(o[g])
      : f(p, o[o.indexOf(p) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: o,
    values: s,
    up: a,
    down: l,
    between: f,
    only: d,
    not: h,
    unit: n,
    ...i,
  };
}
function gR(t, e) {
  if (!t.containerQueries) return e;
  const n = Object.keys(e)
    .filter((r) => r.startsWith("@container"))
    .sort((r, i) => {
      var o, a;
      const s = /min-width:\s*([0-9.]+)/;
      return (
        +(((o = r.match(s)) == null ? void 0 : o[1]) || 0) -
        +(((a = i.match(s)) == null ? void 0 : a[1]) || 0)
      );
    });
  return n.length
    ? n.reduce(
        (r, i) => {
          const s = e[i];
          return delete r[i], (r[i] = s), r;
        },
        { ...e }
      )
    : e;
}
function k9(t, e) {
  return (
    e === "@" ||
    (e.startsWith("@") &&
      (t.some((n) => e.startsWith(`@${n}`)) || !!e.match(/^@\d/)))
  );
}
function U9(t, e) {
  const n = e.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n) return null;
  const [, r, i] = n,
    s = Number.isNaN(+r) ? r || 0 : +r;
  return t.containerQueries(i).up(s);
}
function F9(t) {
  const e = (s, o) => s.replace("@media", o ? `@container ${o}` : "@container");
  function n(s, o) {
    (s.up = (...a) => e(t.breakpoints.up(...a), o)),
      (s.down = (...a) => e(t.breakpoints.down(...a), o)),
      (s.between = (...a) => e(t.breakpoints.between(...a), o)),
      (s.only = (...a) => e(t.breakpoints.only(...a), o)),
      (s.not = (...a) => {
        const l = e(t.breakpoints.not(...a), o);
        return l.includes("not all and")
          ? l
              .replace("not all and ", "")
              .replace("min-width:", "width<")
              .replace("max-width:", "width>")
              .replace("and", "or")
          : l;
      });
  }
  const r = {},
    i = (s) => (n(r, s), r);
  return n(i), { ...t, containerQueries: i };
}
const z9 = { borderRadius: 4 };
function id(t, e) {
  return e ? Lr(t, e, { clone: !1 }) : t;
}
const wv = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  vR = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (t) => `@media (min-width:${wv[t]}px)`,
  },
  B9 = {
    containerQueries: (t) => ({
      up: (e) => {
        let n = typeof e == "number" ? e : wv[e] || e;
        return (
          typeof n == "number" && (n = `${n}px`),
          t ? `@container ${t} (min-width:${n})` : `@container (min-width:${n})`
        );
      },
    }),
  };
function Eo(t, e, n) {
  const r = t.theme || {};
  if (Array.isArray(e)) {
    const s = r.breakpoints || vR;
    return e.reduce((o, a, l) => ((o[s.up(s.keys[l])] = n(e[l])), o), {});
  }
  if (typeof e == "object") {
    const s = r.breakpoints || vR;
    return Object.keys(e).reduce((o, a) => {
      if (k9(s.keys, a)) {
        const l = U9(r.containerQueries ? r : B9, a);
        l && (o[l] = n(e[a], a));
      } else if (Object.keys(s.values || wv).includes(a)) {
        const l = s.up(a);
        o[l] = n(e[a], a);
      } else {
        const l = a;
        o[l] = e[l];
      }
      return o;
    }, {});
  }
  return n(e);
}
function H9(t = {}) {
  var n;
  return (
    ((n = t.keys) == null
      ? void 0
      : n.reduce((r, i) => {
          const s = t.up(i);
          return (r[s] = {}), r;
        }, {})) || {}
  );
}
function yR(t, e) {
  return t.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, e);
}
function gn(t) {
  if (typeof t != "string") throw new Error(Mo(7));
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function Mv(t, e, n = !0) {
  if (!e || typeof e != "string") return null;
  if (t && t.vars && n) {
    const r = `vars.${e}`
      .split(".")
      .reduce((i, s) => (i && i[s] ? i[s] : null), t);
    if (r != null) return r;
  }
  return e.split(".").reduce((r, i) => (r && r[i] != null ? r[i] : null), t);
}
function Wg(t, e, n, r = n) {
  let i;
  return (
    typeof t == "function"
      ? (i = t(n))
      : Array.isArray(t)
      ? (i = t[n] || r)
      : (i = Mv(t, n) || r),
    e && (i = e(i, r, t)),
    i
  );
}
function Nn(t) {
  const { prop: e, cssProperty: n = t.prop, themeKey: r, transform: i } = t,
    s = (o) => {
      if (o[e] == null) return null;
      const a = o[e],
        l = o.theme,
        f = Mv(l, r) || {};
      return Eo(o, a, (h) => {
        let p = Wg(f, i, h);
        return (
          h === p &&
            typeof h == "string" &&
            (p = Wg(f, i, `${e}${h === "default" ? "" : gn(h)}`, h)),
          n === !1 ? p : { [n]: p }
        );
      });
    };
  return (s.propTypes = {}), (s.filterProps = [e]), s;
}
function V9(t) {
  const e = {};
  return (n) => (e[n] === void 0 && (e[n] = t(n)), e[n]);
}
const W9 = { m: "margin", p: "padding" },
  G9 = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  xR = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  j9 = V9((t) => {
    if (t.length > 2)
      if (xR[t]) t = xR[t];
      else return [t];
    const [e, n] = t.split(""),
      r = W9[e],
      i = G9[n] || "";
    return Array.isArray(i) ? i.map((s) => r + s) : [r + i];
  }),
  GM = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  jM = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...GM, ...jM];
function gh(t, e, n, r) {
  const i = Mv(t, e, !0) ?? n;
  return typeof i == "number" || typeof i == "string"
    ? (s) =>
        typeof s == "string"
          ? s
          : typeof i == "string"
          ? i.startsWith("var(") && s === 0
            ? 0
            : i.startsWith("var(") && s === 1
            ? i
            : `calc(${s} * ${i})`
          : i * s
    : Array.isArray(i)
    ? (s) => {
        if (typeof s == "string") return s;
        const o = Math.abs(s),
          a = i[o];
        return s >= 0
          ? a
          : typeof a == "number"
          ? -a
          : typeof a == "string" && a.startsWith("var(")
          ? `calc(-1 * ${a})`
          : `-${a}`;
      }
    : typeof i == "function"
    ? i
    : () => {};
}
function $M(t) {
  return gh(t, "spacing", 8);
}
function vh(t, e) {
  return typeof e == "string" || e == null ? e : t(e);
}
function $9(t, e) {
  return (n) => t.reduce((r, i) => ((r[i] = vh(e, n)), r), {});
}
function X9(t, e, n, r) {
  if (!e.includes(n)) return null;
  const i = j9(n),
    s = $9(i, r),
    o = t[n];
  return Eo(t, o, s);
}
function HN(t, e) {
  const n = $M(t.theme);
  return Object.keys(t)
    .map((r) => X9(t, e, r, n))
    .reduce(id, {});
}
function _n(t) {
  return HN(t, GM);
}
_n.propTypes = {};
_n.filterProps = GM;
function Sn(t) {
  return HN(t, jM);
}
Sn.propTypes = {};
Sn.filterProps = jM;
function VN(t = 8, e = $M({ spacing: t })) {
  if (t.mui) return t;
  const n = (...r) =>
    (r.length === 0 ? [1] : r)
      .map((s) => {
        const o = e(s);
        return typeof o == "number" ? `${o}px` : o;
      })
      .join(" ");
  return (n.mui = !0), n;
}
function Ev(...t) {
  const e = t.reduce(
      (r, i) => (
        i.filterProps.forEach((s) => {
          r[s] = i;
        }),
        r
      ),
      {}
    ),
    n = (r) => Object.keys(r).reduce((i, s) => (e[s] ? id(i, e[s](r)) : i), {});
  return (
    (n.propTypes = {}),
    (n.filterProps = t.reduce((r, i) => r.concat(i.filterProps), [])),
    n
  );
}
function Fi(t) {
  return typeof t != "number" ? t : `${t}px solid`;
}
function ji(t, e) {
  return Nn({ prop: t, themeKey: "borders", transform: e });
}
const Y9 = ji("border", Fi),
  q9 = ji("borderTop", Fi),
  K9 = ji("borderRight", Fi),
  Z9 = ji("borderBottom", Fi),
  J9 = ji("borderLeft", Fi),
  Q9 = ji("borderColor"),
  e7 = ji("borderTopColor"),
  t7 = ji("borderRightColor"),
  n7 = ji("borderBottomColor"),
  r7 = ji("borderLeftColor"),
  i7 = ji("outline", Fi),
  s7 = ji("outlineColor"),
  bv = (t) => {
    if (t.borderRadius !== void 0 && t.borderRadius !== null) {
      const e = gh(t.theme, "shape.borderRadius", 4),
        n = (r) => ({ borderRadius: vh(e, r) });
      return Eo(t, t.borderRadius, n);
    }
    return null;
  };
bv.propTypes = {};
bv.filterProps = ["borderRadius"];
Ev(Y9, q9, K9, Z9, J9, Q9, e7, t7, n7, r7, bv, i7, s7);
const Tv = (t) => {
  if (t.gap !== void 0 && t.gap !== null) {
    const e = gh(t.theme, "spacing", 8),
      n = (r) => ({ gap: vh(e, r) });
    return Eo(t, t.gap, n);
  }
  return null;
};
Tv.propTypes = {};
Tv.filterProps = ["gap"];
const Av = (t) => {
  if (t.columnGap !== void 0 && t.columnGap !== null) {
    const e = gh(t.theme, "spacing", 8),
      n = (r) => ({ columnGap: vh(e, r) });
    return Eo(t, t.columnGap, n);
  }
  return null;
};
Av.propTypes = {};
Av.filterProps = ["columnGap"];
const Cv = (t) => {
  if (t.rowGap !== void 0 && t.rowGap !== null) {
    const e = gh(t.theme, "spacing", 8),
      n = (r) => ({ rowGap: vh(e, r) });
    return Eo(t, t.rowGap, n);
  }
  return null;
};
Cv.propTypes = {};
Cv.filterProps = ["rowGap"];
const o7 = Nn({ prop: "gridColumn" }),
  a7 = Nn({ prop: "gridRow" }),
  l7 = Nn({ prop: "gridAutoFlow" }),
  u7 = Nn({ prop: "gridAutoColumns" }),
  c7 = Nn({ prop: "gridAutoRows" }),
  f7 = Nn({ prop: "gridTemplateColumns" }),
  d7 = Nn({ prop: "gridTemplateRows" }),
  h7 = Nn({ prop: "gridTemplateAreas" }),
  p7 = Nn({ prop: "gridArea" });
Ev(Tv, Av, Cv, o7, a7, l7, u7, c7, f7, d7, h7, p7);
function uc(t, e) {
  return e === "grey" ? e : t;
}
const m7 = Nn({ prop: "color", themeKey: "palette", transform: uc }),
  g7 = Nn({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: uc,
  }),
  v7 = Nn({ prop: "backgroundColor", themeKey: "palette", transform: uc });
Ev(m7, g7, v7);
function pi(t) {
  return t <= 1 && t !== 0 ? `${t * 100}%` : t;
}
const y7 = Nn({ prop: "width", transform: pi }),
  XM = (t) => {
    if (t.maxWidth !== void 0 && t.maxWidth !== null) {
      const e = (n) => {
        var i, s, o, a, l;
        const r =
          ((o =
            (s = (i = t.theme) == null ? void 0 : i.breakpoints) == null
              ? void 0
              : s.values) == null
            ? void 0
            : o[n]) || wv[n];
        return r
          ? ((l = (a = t.theme) == null ? void 0 : a.breakpoints) == null
              ? void 0
              : l.unit) !== "px"
            ? { maxWidth: `${r}${t.theme.breakpoints.unit}` }
            : { maxWidth: r }
          : { maxWidth: pi(n) };
      };
      return Eo(t, t.maxWidth, e);
    }
    return null;
  };
XM.filterProps = ["maxWidth"];
const x7 = Nn({ prop: "minWidth", transform: pi }),
  _7 = Nn({ prop: "height", transform: pi }),
  S7 = Nn({ prop: "maxHeight", transform: pi }),
  w7 = Nn({ prop: "minHeight", transform: pi });
Nn({ prop: "size", cssProperty: "width", transform: pi });
Nn({ prop: "size", cssProperty: "height", transform: pi });
const M7 = Nn({ prop: "boxSizing" });
Ev(y7, XM, x7, _7, S7, w7, M7);
const yh = {
  border: { themeKey: "borders", transform: Fi },
  borderTop: { themeKey: "borders", transform: Fi },
  borderRight: { themeKey: "borders", transform: Fi },
  borderBottom: { themeKey: "borders", transform: Fi },
  borderLeft: { themeKey: "borders", transform: Fi },
  borderColor: { themeKey: "palette" },
  borderTopColor: { themeKey: "palette" },
  borderRightColor: { themeKey: "palette" },
  borderBottomColor: { themeKey: "palette" },
  borderLeftColor: { themeKey: "palette" },
  outline: { themeKey: "borders", transform: Fi },
  outlineColor: { themeKey: "palette" },
  borderRadius: { themeKey: "shape.borderRadius", style: bv },
  color: { themeKey: "palette", transform: uc },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: uc,
  },
  backgroundColor: { themeKey: "palette", transform: uc },
  p: { style: Sn },
  pt: { style: Sn },
  pr: { style: Sn },
  pb: { style: Sn },
  pl: { style: Sn },
  px: { style: Sn },
  py: { style: Sn },
  padding: { style: Sn },
  paddingTop: { style: Sn },
  paddingRight: { style: Sn },
  paddingBottom: { style: Sn },
  paddingLeft: { style: Sn },
  paddingX: { style: Sn },
  paddingY: { style: Sn },
  paddingInline: { style: Sn },
  paddingInlineStart: { style: Sn },
  paddingInlineEnd: { style: Sn },
  paddingBlock: { style: Sn },
  paddingBlockStart: { style: Sn },
  paddingBlockEnd: { style: Sn },
  m: { style: _n },
  mt: { style: _n },
  mr: { style: _n },
  mb: { style: _n },
  ml: { style: _n },
  mx: { style: _n },
  my: { style: _n },
  margin: { style: _n },
  marginTop: { style: _n },
  marginRight: { style: _n },
  marginBottom: { style: _n },
  marginLeft: { style: _n },
  marginX: { style: _n },
  marginY: { style: _n },
  marginInline: { style: _n },
  marginInlineStart: { style: _n },
  marginInlineEnd: { style: _n },
  marginBlock: { style: _n },
  marginBlockStart: { style: _n },
  marginBlockEnd: { style: _n },
  displayPrint: {
    cssProperty: !1,
    transform: (t) => ({ "@media print": { display: t } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: Tv },
  rowGap: { style: Cv },
  columnGap: { style: Av },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: "zIndex" },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: "shadows" },
  width: { transform: pi },
  maxWidth: { style: XM },
  minWidth: { transform: pi },
  height: { transform: pi },
  maxHeight: { transform: pi },
  minHeight: { transform: pi },
  boxSizing: {},
  font: { themeKey: "font" },
  fontFamily: { themeKey: "typography" },
  fontSize: { themeKey: "typography" },
  fontStyle: { themeKey: "typography" },
  fontWeight: { themeKey: "typography" },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: "typography" },
};
function E7(...t) {
  const e = t.reduce((r, i) => r.concat(Object.keys(i)), []),
    n = new Set(e);
  return t.every((r) => n.size === Object.keys(r).length);
}
function b7(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function T7() {
  function t(n, r, i, s) {
    const o = { [n]: r, theme: i },
      a = s[n];
    if (!a) return { [n]: r };
    const { cssProperty: l = n, themeKey: f, transform: d, style: h } = a;
    if (r == null) return null;
    if (f === "typography" && r === "inherit") return { [n]: r };
    const p = Mv(i, f) || {};
    return h
      ? h(o)
      : Eo(o, r, (v) => {
          let _ = Wg(p, d, v);
          return (
            v === _ &&
              typeof v == "string" &&
              (_ = Wg(p, d, `${n}${v === "default" ? "" : gn(v)}`, v)),
            l === !1 ? _ : { [l]: _ }
          );
        });
  }
  function e(n) {
    const { sx: r, theme: i = {}, nested: s } = n || {};
    if (!r) return null;
    const o = i.unstable_sxConfig ?? yh;
    function a(l) {
      let f = l;
      if (typeof l == "function") f = l(i);
      else if (typeof l != "object") return l;
      if (!f) return null;
      const d = H9(i.breakpoints),
        h = Object.keys(d);
      let p = d;
      return (
        Object.keys(f).forEach((g) => {
          const v = b7(f[g], i);
          if (v != null)
            if (typeof v == "object")
              if (o[g]) p = id(p, t(g, v, i, o));
              else {
                const _ = Eo({ theme: i }, v, (x) => ({ [g]: x }));
                E7(_, v)
                  ? (p[g] = e({ sx: v, theme: i, nested: !0 }))
                  : (p = id(p, _));
              }
            else p = id(p, t(g, v, i, o));
        }),
        !s && i.modularCssLayers
          ? { "@layer sx": gR(i, yR(h, p)) }
          : gR(i, yR(h, p))
      );
    }
    return Array.isArray(r) ? r.map(a) : a(r);
  }
  return e;
}
const Tc = T7();
Tc.filterProps = ["sx"];
function A7(t, e) {
  var r;
  const n = this;
  if (n.vars) {
    if (
      !((r = n.colorSchemes) != null && r[t]) ||
      typeof n.getColorSchemeSelector != "function"
    )
      return {};
    let i = n.getColorSchemeSelector(t);
    return i === "&"
      ? e
      : ((i.includes("data-") || i.includes(".")) &&
          (i = `*:where(${i.replace(/\s*&$/, "")}) &`),
        { [i]: e });
  }
  return n.palette.mode === t ? e : {};
}
function YM(t = {}, ...e) {
  const {
      breakpoints: n = {},
      palette: r = {},
      spacing: i,
      shape: s = {},
      ...o
    } = t,
    a = D9(n),
    l = VN(i);
  let f = Lr(
    {
      breakpoints: a,
      direction: "ltr",
      components: {},
      palette: { mode: "light", ...r },
      spacing: l,
      shape: { ...z9, ...s },
    },
    o
  );
  return (
    (f = F9(f)),
    (f.applyStyles = A7),
    (f = e.reduce((d, h) => Lr(d, h), f)),
    (f.unstable_sxConfig = {
      ...yh,
      ...(o == null ? void 0 : o.unstable_sxConfig),
    }),
    (f.unstable_sx = function (h) {
      return Tc({ sx: h, theme: this });
    }),
    f
  );
}
function C7(t) {
  return Object.keys(t).length === 0;
}
function R7(t = null) {
  const e = U.useContext(fv);
  return !e || C7(e) ? t : e;
}
const P7 = YM();
function WN(t = P7) {
  return R7(t);
}
function m_(t) {
  const e = ha(t);
  return t !== e && e.styles
    ? (e.styles.match(/^@layer\s+[^{]*$/) ||
        (e.styles = `@layer global{${e.styles}}`),
      e)
    : t;
}
function L7({ styles: t, themeId: e, defaultTheme: n = {} }) {
  const r = WN(n),
    i = (e && r[e]) || r;
  let s = typeof t == "function" ? t(i) : t;
  return (
    i.modularCssLayers &&
      (Array.isArray(s)
        ? (s = s.map((o) => m_(typeof o == "function" ? o(i) : o)))
        : (s = m_(s))),
    Q.jsx(R9, { styles: s })
  );
}
const I7 = (t) => {
  var r;
  const e = { systemProps: {}, otherProps: {} },
    n =
      ((r = t == null ? void 0 : t.theme) == null
        ? void 0
        : r.unstable_sxConfig) ?? yh;
  return (
    Object.keys(t).forEach((i) => {
      n[i] ? (e.systemProps[i] = t[i]) : (e.otherProps[i] = t[i]);
    }),
    e
  );
};
function N7(t) {
  const { sx: e, ...n } = t,
    { systemProps: r, otherProps: i } = I7(n);
  let s;
  return (
    Array.isArray(e)
      ? (s = [r, ...e])
      : typeof e == "function"
      ? (s = (...o) => {
          const a = e(...o);
          return Ls(a) ? { ...r, ...a } : r;
        })
      : (s = { ...r, ...e }),
    { ...i, sx: s }
  );
}
const _R = (t) => t,
  O7 = () => {
    let t = _R;
    return {
      configure(e) {
        t = e;
      },
      generate(e) {
        return t(e);
      },
      reset() {
        t = _R;
      },
    };
  },
  D7 = O7(),
  k7 = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected",
  };
function zn(t, e, n = "Mui") {
  const r = k7[e];
  return r ? `${n}-${r}` : `${D7.generate(t)}-${e}`;
}
function Yn(t, e, n = "Mui") {
  const r = {};
  return (
    e.forEach((i) => {
      r[i] = zn(t, i, n);
    }),
    r
  );
}
function GN(t) {
  const { variants: e, ...n } = t,
    r = { variants: e, style: ha(n), isProcessed: !0 };
  return (
    r.style === n ||
      (e &&
        e.forEach((i) => {
          typeof i.style != "function" && (i.style = ha(i.style));
        })),
    r
  );
}
const U7 = YM();
function g_(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
function ml(t, e) {
  return (
    e &&
      t &&
      typeof t == "object" &&
      t.styles &&
      !t.styles.startsWith("@layer") &&
      (t.styles = `@layer ${e}{${String(t.styles)}}`),
    t
  );
}
function F7(t) {
  return t ? (e, n) => n[t] : null;
}
function z7(t, e, n) {
  t.theme = V7(t.theme) ? n : t.theme[e] || t.theme;
}
function ig(t, e, n) {
  const r = typeof e == "function" ? e(t) : e;
  if (Array.isArray(r)) return r.flatMap((i) => ig(t, i, n));
  if (Array.isArray(r == null ? void 0 : r.variants)) {
    let i;
    if (r.isProcessed) i = n ? ml(r.style, n) : r.style;
    else {
      const { variants: s, ...o } = r;
      i = n ? ml(ha(o), n) : o;
    }
    return jN(t, r.variants, [i], n);
  }
  return r != null && r.isProcessed
    ? n
      ? ml(ha(r.style), n)
      : r.style
    : n
    ? ml(ha(r), n)
    : r;
}
function jN(t, e, n = [], r = void 0) {
  var s;
  let i;
  e: for (let o = 0; o < e.length; o += 1) {
    const a = e[o];
    if (typeof a.props == "function") {
      if (
        (i ?? (i = { ...t, ...t.ownerState, ownerState: t.ownerState }),
        !a.props(i))
      )
        continue;
    } else
      for (const l in a.props)
        if (
          t[l] !== a.props[l] &&
          ((s = t.ownerState) == null ? void 0 : s[l]) !== a.props[l]
        )
          continue e;
    typeof a.style == "function"
      ? (i ?? (i = { ...t, ...t.ownerState, ownerState: t.ownerState }),
        n.push(r ? ml(ha(a.style(i)), r) : a.style(i)))
      : n.push(r ? ml(ha(a.style), r) : a.style);
  }
  return n;
}
function B7(t = {}) {
  const {
    themeId: e,
    defaultTheme: n = U7,
    rootShouldForwardProp: r = g_,
    slotShouldForwardProp: i = g_,
  } = t;
  function s(a) {
    z7(a, e, n);
  }
  return (a, l = {}) => {
    L9(a, (A) => A.filter((L) => L !== Tc));
    const {
        name: f,
        slot: d,
        skipVariantsResolver: h,
        skipSx: p,
        overridesResolver: g = F7(G7(d)),
        ...v
      } = l,
      _ = (f && f.startsWith("Mui")) || d ? "components" : "custom",
      x = h !== void 0 ? h : (d && d !== "Root" && d !== "root") || !1,
      m = p || !1;
    let w = g_;
    d === "Root" || d === "root"
      ? (w = r)
      : d
      ? (w = i)
      : W7(a) && (w = void 0);
    const S = P9(a, { shouldForwardProp: w, label: H7(), ...v }),
      E = (A) => {
        if (A.__emotion_real === A) return A;
        if (typeof A == "function")
          return function (N) {
            return ig(N, A, N.theme.modularCssLayers ? _ : void 0);
          };
        if (Ls(A)) {
          const L = GN(A);
          return function (C) {
            return L.variants
              ? ig(C, L, C.theme.modularCssLayers ? _ : void 0)
              : C.theme.modularCssLayers
              ? ml(L.style, _)
              : L.style;
          };
        }
        return A;
      },
      T = (...A) => {
        const L = [],
          N = A.map(E),
          C = [];
        if (
          (L.push(s),
          f &&
            g &&
            C.push(function ($) {
              var Z, B;
              const W =
                (B = (Z = $.theme.components) == null ? void 0 : Z[f]) == null
                  ? void 0
                  : B.styleOverrides;
              if (!W) return null;
              const Y = {};
              for (const G in W)
                Y[G] = ig($, W[G], $.theme.modularCssLayers ? "theme" : void 0);
              return g($, Y);
            }),
          f &&
            !x &&
            C.push(function ($) {
              var Y, Z;
              const D = $.theme,
                W =
                  (Z =
                    (Y = D == null ? void 0 : D.components) == null
                      ? void 0
                      : Y[f]) == null
                    ? void 0
                    : Z.variants;
              return W
                ? jN($, W, [], $.theme.modularCssLayers ? "theme" : void 0)
                : null;
            }),
          m || C.push(Tc),
          Array.isArray(N[0]))
        ) {
          const R = N.shift(),
            $ = new Array(L.length).fill(""),
            D = new Array(C.length).fill("");
          let W;
          (W = [...$, ...R, ...D]),
            (W.raw = [...$, ...R.raw, ...D]),
            L.unshift(W);
        }
        const I = [...L, ...N, ...C],
          k = S(...I);
        return a.muiName && (k.muiName = a.muiName), k;
      };
    return S.withConfig && (T.withConfig = S.withConfig), T;
  };
}
function H7(t, e) {
  return void 0;
}
function V7(t) {
  for (const e in t) return !1;
  return !0;
}
function W7(t) {
  return typeof t == "string" && t.charCodeAt(0) > 96;
}
function G7(t) {
  return t && t.charAt(0).toLowerCase() + t.slice(1);
}
function $N(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++)
        t[e] && (n = $N(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function S1() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
    (t = arguments[n]) && (e = $N(t)) && (r && (r += " "), (r += e));
  return r;
}
function w1(t, e, n = !1) {
  const r = { ...e };
  for (const i in t)
    if (Object.prototype.hasOwnProperty.call(t, i)) {
      const s = i;
      if (s === "components" || s === "slots") r[s] = { ...t[s], ...r[s] };
      else if (s === "componentsProps" || s === "slotProps") {
        const o = t[s],
          a = e[s];
        if (!a) r[s] = o || {};
        else if (!o) r[s] = a;
        else {
          r[s] = { ...a };
          for (const l in o)
            if (Object.prototype.hasOwnProperty.call(o, l)) {
              const f = l;
              r[s][f] = w1(o[f], a[f], n);
            }
        }
      } else
        s === "className" && n && e.className
          ? (r.className = S1(
              t == null ? void 0 : t.className,
              e == null ? void 0 : e.className
            ))
          : s === "style" && n && e.style
          ? (r.style = {
              ...(t == null ? void 0 : t.style),
              ...(e == null ? void 0 : e.style),
            })
          : r[s] === void 0 && (r[s] = t[s]);
    }
  return r;
}
const Nl = typeof window < "u" ? U.useLayoutEffect : U.useEffect;
function j7(t, e = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(t, n));
}
function qM(t, e = 0, n = 1) {
  return j7(t, e, n);
}
function $7(t) {
  t = t.slice(1);
  const e = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let n = t.match(e);
  return (
    n && n[0].length === 1 && (n = n.map((r) => r + r)),
    n
      ? `rgb${n.length === 4 ? "a" : ""}(${n
          .map((r, i) =>
            i < 3
              ? parseInt(r, 16)
              : Math.round((parseInt(r, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function Sa(t) {
  if (t.type) return t;
  if (t.charAt(0) === "#") return Sa($7(t));
  const e = t.indexOf("("),
    n = t.substring(0, e);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Mo(9, t));
  let r = t.substring(e + 1, t.length - 1),
    i;
  if (n === "color") {
    if (
      ((r = r.split(" ")),
      (i = r.shift()),
      r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
      !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(
        i
      ))
    )
      throw new Error(Mo(10, i));
  } else r = r.split(",");
  return (
    (r = r.map((s) => parseFloat(s))), { type: n, values: r, colorSpace: i }
  );
}
const X7 = (t) => {
    const e = Sa(t);
    return e.values
      .slice(0, 3)
      .map((n, r) => (e.type.includes("hsl") && r !== 0 ? `${n}%` : n))
      .join(" ");
  },
  Bf = (t, e) => {
    try {
      return X7(t);
    } catch {
      return t;
    }
  };
function Rv(t) {
  const { type: e, colorSpace: n } = t;
  let { values: r } = t;
  return (
    e.includes("rgb")
      ? (r = r.map((i, s) => (s < 3 ? parseInt(i, 10) : i)))
      : e.includes("hsl") && ((r[1] = `${r[1]}%`), (r[2] = `${r[2]}%`)),
    e.includes("color") ? (r = `${n} ${r.join(" ")}`) : (r = `${r.join(", ")}`),
    `${e}(${r})`
  );
}
function XN(t) {
  t = Sa(t);
  const { values: e } = t,
    n = e[0],
    r = e[1] / 100,
    i = e[2] / 100,
    s = r * Math.min(i, 1 - i),
    o = (f, d = (f + n / 30) % 12) =>
      i - s * Math.max(Math.min(d - 3, 9 - d, 1), -1);
  let a = "rgb";
  const l = [
    Math.round(o(0) * 255),
    Math.round(o(8) * 255),
    Math.round(o(4) * 255),
  ];
  return (
    t.type === "hsla" && ((a += "a"), l.push(e[3])), Rv({ type: a, values: l })
  );
}
function M1(t) {
  t = Sa(t);
  let e = t.type === "hsl" || t.type === "hsla" ? Sa(XN(t)).values : t.values;
  return (
    (e = e.map(
      (n) => (
        t.type !== "color" && (n /= 255),
        n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4
      )
    )),
    Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3))
  );
}
function Y7(t, e) {
  const n = M1(t),
    r = M1(e);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Gg(t, e) {
  return (
    (t = Sa(t)),
    (e = qM(e)),
    (t.type === "rgb" || t.type === "hsl") && (t.type += "a"),
    t.type === "color" ? (t.values[3] = `/${e}`) : (t.values[3] = e),
    Rv(t)
  );
}
function Ya(t, e, n) {
  try {
    return Gg(t, e);
  } catch {
    return t;
  }
}
function Pv(t, e) {
  if (((t = Sa(t)), (e = qM(e)), t.type.includes("hsl"))) t.values[2] *= 1 - e;
  else if (t.type.includes("rgb") || t.type.includes("color"))
    for (let n = 0; n < 3; n += 1) t.values[n] *= 1 - e;
  return Rv(t);
}
function Ht(t, e, n) {
  try {
    return Pv(t, e);
  } catch {
    return t;
  }
}
function Lv(t, e) {
  if (((t = Sa(t)), (e = qM(e)), t.type.includes("hsl")))
    t.values[2] += (100 - t.values[2]) * e;
  else if (t.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1) t.values[n] += (255 - t.values[n]) * e;
  else if (t.type.includes("color"))
    for (let n = 0; n < 3; n += 1) t.values[n] += (1 - t.values[n]) * e;
  return Rv(t);
}
function Vt(t, e, n) {
  try {
    return Lv(t, e);
  } catch {
    return t;
  }
}
function q7(t, e = 0.15) {
  return M1(t) > 0.5 ? Pv(t, e) : Lv(t, e);
}
function Lm(t, e, n) {
  try {
    return q7(t, e);
  } catch {
    return t;
  }
}
const K7 = U.createContext(),
  Z7 = () => U.useContext(K7) ?? !1,
  J7 = U.createContext(void 0);
function Q7(t) {
  const { theme: e, name: n, props: r } = t;
  if (!e || !e.components || !e.components[n]) return r;
  const i = e.components[n];
  return i.defaultProps
    ? w1(i.defaultProps, r, e.components.mergeClassNameAndStyle)
    : !i.styleOverrides && !i.variants
    ? w1(i, r, e.components.mergeClassNameAndStyle)
    : r;
}
function ej({ props: t, name: e }) {
  const n = U.useContext(J7);
  return Q7({ props: t, name: e, theme: { components: n } });
}
let SR = 0;
function tj(t) {
  const [e, n] = U.useState(t),
    r = t || e;
  return (
    U.useEffect(() => {
      e == null && ((SR += 1), n(`mui-${SR}`));
    }, [e]),
    r
  );
}
const nj = { ...b_ },
  wR = nj.useId;
function YN(t) {
  if (wR !== void 0) {
    const e = wR();
    return t ?? e;
  }
  return tj(t);
}
const MR = { theme: void 0 };
function rj(t) {
  let e, n;
  return function (i) {
    let s = e;
    return (
      (s === void 0 || i.theme !== n) &&
        ((MR.theme = i.theme), (s = GN(t(MR))), (e = s), (n = i.theme)),
      s
    );
  };
}
function ij(t = "") {
  function e(...r) {
    if (!r.length) return "";
    const i = r[0];
    return typeof i == "string" &&
      !i.match(
        /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
      )
      ? `, var(--${t ? `${t}-` : ""}${i}${e(...r.slice(1))})`
      : `, ${i}`;
  }
  return (r, ...i) => `var(--${t ? `${t}-` : ""}${r}${e(...i)})`;
}
const ER = (t, e, n, r = []) => {
    let i = t;
    e.forEach((s, o) => {
      o === e.length - 1
        ? Array.isArray(i)
          ? (i[Number(s)] = n)
          : i && typeof i == "object" && (i[s] = n)
        : i &&
          typeof i == "object" &&
          (i[s] || (i[s] = r.includes(s) ? [] : {}), (i = i[s]));
    });
  },
  sj = (t, e, n) => {
    function r(i, s = [], o = []) {
      Object.entries(i).forEach(([a, l]) => {
        (!n || (n && !n([...s, a]))) &&
          l != null &&
          (typeof l == "object" && Object.keys(l).length > 0
            ? r(l, [...s, a], Array.isArray(l) ? [...o, a] : o)
            : e([...s, a], l, o));
      });
    }
    r(t);
  },
  oj = (t, e) =>
    typeof e == "number"
      ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) =>
          t.includes(r)
        ) || t[t.length - 1].toLowerCase().includes("opacity")
        ? e
        : `${e}px`
      : e;
function v_(t, e) {
  const { prefix: n, shouldSkipGeneratingVar: r } = e || {},
    i = {},
    s = {},
    o = {};
  return (
    sj(
      t,
      (a, l, f) => {
        if (
          (typeof l == "string" || typeof l == "number") &&
          (!r || !r(a, l))
        ) {
          const d = `--${n ? `${n}-` : ""}${a.join("-")}`,
            h = oj(a, l);
          Object.assign(i, { [d]: h }),
            ER(s, a, `var(${d})`, f),
            ER(o, a, `var(${d}, ${h})`, f);
        }
      },
      (a) => a[0] === "vars"
    ),
    { css: i, vars: s, varsWithDefaults: o }
  );
}
function aj(t, e = {}) {
  const {
      getSelector: n = m,
      disableCssColorScheme: r,
      colorSchemeSelector: i,
      enableContrastVars: s,
    } = e,
    {
      colorSchemes: o = {},
      components: a,
      defaultColorScheme: l = "light",
      ...f
    } = t,
    { vars: d, css: h, varsWithDefaults: p } = v_(f, e);
  let g = p;
  const v = {},
    { [l]: _, ...x } = o;
  if (
    (Object.entries(x || {}).forEach(([E, T]) => {
      const { vars: A, css: L, varsWithDefaults: N } = v_(T, e);
      (g = Lr(g, N)), (v[E] = { css: L, vars: A });
    }),
    _)
  ) {
    const { css: E, vars: T, varsWithDefaults: A } = v_(_, e);
    (g = Lr(g, A)), (v[l] = { css: E, vars: T });
  }
  function m(E, T) {
    var L, N;
    let A = i;
    if (
      (i === "class" && (A = ".%s"),
      i === "data" && (A = "[data-%s]"),
      i != null &&
        i.startsWith("data-") &&
        !i.includes("%s") &&
        (A = `[${i}="%s"]`),
      E)
    ) {
      if (A === "media")
        return t.defaultColorScheme === E
          ? ":root"
          : {
              [`@media (prefers-color-scheme: ${
                ((N = (L = o[E]) == null ? void 0 : L.palette) == null
                  ? void 0
                  : N.mode) || E
              })`]: { ":root": T },
            };
      if (A)
        return t.defaultColorScheme === E
          ? `:root, ${A.replace("%s", String(E))}`
          : A.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let E = { ...d };
      return (
        Object.entries(v).forEach(([, { vars: T }]) => {
          E = Lr(E, T);
        }),
        E
      );
    },
    generateStyleSheets: () => {
      var C, I;
      const E = [],
        T = t.defaultColorScheme || "light";
      function A(k, R) {
        Object.keys(R).length &&
          E.push(typeof k == "string" ? { [k]: { ...R } } : k);
      }
      A(n(void 0, { ...h }), h);
      const { [T]: L, ...N } = v;
      if (L) {
        const { css: k } = L,
          R =
            (I = (C = o[T]) == null ? void 0 : C.palette) == null
              ? void 0
              : I.mode,
          $ = !r && R ? { colorScheme: R, ...k } : { ...k };
        A(n(T, { ...$ }), $);
      }
      return (
        Object.entries(N).forEach(([k, { css: R }]) => {
          var W, Y;
          const $ =
              (Y = (W = o[k]) == null ? void 0 : W.palette) == null
                ? void 0
                : Y.mode,
            D = !r && $ ? { colorScheme: $, ...R } : { ...R };
          A(n(k, { ...D }), D);
        }),
        s &&
          E.push({
            ":root": {
              "--__l-threshold": "0.7",
              "--__l":
                "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
              "--__a":
                "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)",
            },
          }),
        E
      );
    },
  };
}
function lj(t) {
  return function (n) {
    return t === "media"
      ? `@media (prefers-color-scheme: ${n})`
      : t
      ? t.startsWith("data-") && !t.includes("%s")
        ? `[${t}="${n}"] &`
        : t === "class"
        ? `.${n} &`
        : t === "data"
        ? `[data-${n}] &`
        : `${t.replace("%s", n)} &`
      : "&";
  };
}
function Bn(t, e, n = void 0) {
  const r = {};
  for (const i in t) {
    const s = t[i];
    let o = "",
      a = !0;
    for (let l = 0; l < s.length; l += 1) {
      const f = s[l];
      f &&
        ((o += (a === !0 ? "" : " ") + e(f)),
        (a = !1),
        n && n[f] && (o += " " + n[f]));
    }
    r[i] = o;
  }
  return r;
}
function y_(t, e) {
  var n, r, i;
  return (
    U.isValidElement(t) &&
    e.indexOf(
      t.type.muiName ??
        ((i =
          (r = (n = t.type) == null ? void 0 : n._payload) == null
            ? void 0
            : r.value) == null
          ? void 0
          : i.muiName)
    ) !== -1
  );
}
function qN() {
  return {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: Yd.white, default: Yd.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  };
}
const KN = qN();
function ZN() {
  return {
    text: {
      primary: Yd.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: Yd.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
}
const E1 = ZN();
function bR(t, e, n, r) {
  const i = r.light || r,
    s = r.dark || r * 1.5;
  t[e] ||
    (t.hasOwnProperty(n)
      ? (t[e] = t[n])
      : e === "light"
      ? (t.light = Lv(t.main, i))
      : e === "dark" && (t.dark = Pv(t.main, s)));
}
function TR(t, e, n, r, i) {
  const s = i.light || i,
    o = i.dark || i * 1.5;
  e[n] ||
    (e.hasOwnProperty(r)
      ? (e[n] = e[r])
      : n === "light"
      ? (e.light = `color-mix(in ${t}, ${e.main}, #fff ${(s * 100).toFixed(
          0
        )}%)`)
      : n === "dark" &&
        (e.dark = `color-mix(in ${t}, ${e.main}, #000 ${(o * 100).toFixed(
          0
        )}%)`));
}
function uj(t = "light") {
  return t === "dark"
    ? { main: Ru[200], light: Ru[50], dark: Ru[400] }
    : { main: Ru[700], light: Ru[400], dark: Ru[800] };
}
function cj(t = "light") {
  return t === "dark"
    ? { main: Cu[200], light: Cu[50], dark: Cu[400] }
    : { main: Cu[500], light: Cu[300], dark: Cu[700] };
}
function fj(t = "light") {
  return t === "dark"
    ? { main: Au[500], light: Au[300], dark: Au[700] }
    : { main: Au[700], light: Au[400], dark: Au[800] };
}
function dj(t = "light") {
  return t === "dark"
    ? { main: Pu[400], light: Pu[300], dark: Pu[700] }
    : { main: Pu[700], light: Pu[500], dark: Pu[900] };
}
function hj(t = "light") {
  return t === "dark"
    ? { main: Lu[400], light: Lu[300], dark: Lu[700] }
    : { main: Lu[800], light: Lu[500], dark: Lu[900] };
}
function pj(t = "light") {
  return t === "dark"
    ? { main: Cf[400], light: Cf[300], dark: Cf[700] }
    : { main: "#ed6c02", light: Cf[500], dark: Cf[900] };
}
function mj(t) {
  return `oklch(from ${t} var(--__l) 0 h / var(--__a))`;
}
function KM(t) {
  const {
      mode: e = "light",
      contrastThreshold: n = 3,
      tonalOffset: r = 0.2,
      colorSpace: i,
      ...s
    } = t,
    o = t.primary || uj(e),
    a = t.secondary || cj(e),
    l = t.error || fj(e),
    f = t.info || dj(e),
    d = t.success || hj(e),
    h = t.warning || pj(e);
  function p(x) {
    return i
      ? mj(x)
      : Y7(x, E1.text.primary) >= n
      ? E1.text.primary
      : KN.text.primary;
  }
  const g = ({
    color: x,
    name: m,
    mainShade: w = 500,
    lightShade: S = 300,
    darkShade: E = 700,
  }) => {
    if (
      ((x = { ...x }),
      !x.main && x[w] && (x.main = x[w]),
      !x.hasOwnProperty("main"))
    )
      throw new Error(Mo(11, m ? ` (${m})` : "", w));
    if (typeof x.main != "string")
      throw new Error(Mo(12, m ? ` (${m})` : "", JSON.stringify(x.main)));
    return (
      i
        ? (TR(i, x, "light", S, r), TR(i, x, "dark", E, r))
        : (bR(x, "light", S, r), bR(x, "dark", E, r)),
      x.contrastText || (x.contrastText = p(x.main)),
      x
    );
  };
  let v;
  return (
    e === "light" ? (v = qN()) : e === "dark" && (v = ZN()),
    Lr(
      {
        common: { ...Yd },
        mode: e,
        primary: g({ color: o, name: "primary" }),
        secondary: g({
          color: a,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: g({ color: l, name: "error" }),
        warning: g({ color: h, name: "warning" }),
        info: g({ color: f, name: "info" }),
        success: g({ color: d, name: "success" }),
        grey: N8,
        contrastThreshold: n,
        getContrastText: p,
        augmentColor: g,
        tonalOffset: r,
        ...v,
      },
      s
    )
  );
}
function gj(t) {
  const e = {};
  return (
    Object.entries(t).forEach((r) => {
      const [i, s] = r;
      typeof s == "object" &&
        (e[i] = `${s.fontStyle ? `${s.fontStyle} ` : ""}${
          s.fontVariant ? `${s.fontVariant} ` : ""
        }${s.fontWeight ? `${s.fontWeight} ` : ""}${
          s.fontStretch ? `${s.fontStretch} ` : ""
        }${s.fontSize || ""}${s.lineHeight ? `/${s.lineHeight} ` : ""}${
          s.fontFamily || ""
        }`);
    }),
    e
  );
}
function vj(t, e) {
  return {
    toolbar: {
      minHeight: 56,
      [t.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
      [t.up("sm")]: { minHeight: 64 },
    },
    ...e,
  };
}
function yj(t) {
  return Math.round(t * 1e5) / 1e5;
}
const AR = { textTransform: "uppercase" },
  CR = '"Roboto", "Helvetica", "Arial", sans-serif';
function xj(t, e) {
  const {
      fontFamily: n = CR,
      fontSize: r = 14,
      fontWeightLight: i = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: o = 500,
      fontWeightBold: a = 700,
      htmlFontSize: l = 16,
      allVariants: f,
      pxToRem: d,
      ...h
    } = typeof e == "function" ? e(t) : e,
    p = r / 14,
    g = d || ((x) => `${(x / l) * p}rem`),
    v = (x, m, w, S, E) => ({
      fontFamily: n,
      fontWeight: x,
      fontSize: g(m),
      lineHeight: w,
      ...(n === CR ? { letterSpacing: `${yj(S / m)}em` } : {}),
      ...E,
      ...f,
    }),
    _ = {
      h1: v(i, 96, 1.167, -1.5),
      h2: v(i, 60, 1.2, -0.5),
      h3: v(s, 48, 1.167, 0),
      h4: v(s, 34, 1.235, 0.25),
      h5: v(s, 24, 1.334, 0),
      h6: v(o, 20, 1.6, 0.15),
      subtitle1: v(s, 16, 1.75, 0.15),
      subtitle2: v(o, 14, 1.57, 0.1),
      body1: v(s, 16, 1.5, 0.15),
      body2: v(s, 14, 1.43, 0.15),
      button: v(o, 14, 1.75, 0.4, AR),
      caption: v(s, 12, 1.66, 0.4),
      overline: v(s, 12, 2.66, 1, AR),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return Lr(
    {
      htmlFontSize: l,
      pxToRem: g,
      fontFamily: n,
      fontSize: r,
      fontWeightLight: i,
      fontWeightRegular: s,
      fontWeightMedium: o,
      fontWeightBold: a,
      ..._,
    },
    h,
    { clone: !1 }
  );
}
const _j = 0.2,
  Sj = 0.14,
  wj = 0.12;
function an(...t) {
  return [
    `${t[0]}px ${t[1]}px ${t[2]}px ${t[3]}px rgba(0,0,0,${_j})`,
    `${t[4]}px ${t[5]}px ${t[6]}px ${t[7]}px rgba(0,0,0,${Sj})`,
    `${t[8]}px ${t[9]}px ${t[10]}px ${t[11]}px rgba(0,0,0,${wj})`,
  ].join(",");
}
const Mj = [
    "none",
    an(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    an(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    an(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    an(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    an(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    an(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    an(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    an(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    an(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    an(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    an(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    an(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    an(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    an(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    an(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    an(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    an(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    an(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    an(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    an(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    an(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    an(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    an(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    an(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  Ej = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  bj = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function RR(t) {
  return `${Math.round(t)}ms`;
}
function Tj(t) {
  if (!t) return 0;
  const e = t / 36;
  return Math.min(Math.round((4 + 15 * e ** 0.25 + e / 5) * 10), 3e3);
}
function Aj(t) {
  const e = { ...Ej, ...t.easing },
    n = { ...bj, ...t.duration };
  return {
    getAutoHeightDuration: Tj,
    create: (i = ["all"], s = {}) => {
      const {
        duration: o = n.standard,
        easing: a = e.easeInOut,
        delay: l = 0,
        ...f
      } = s;
      return (Array.isArray(i) ? i : [i])
        .map(
          (d) =>
            `${d} ${typeof o == "string" ? o : RR(o)} ${a} ${
              typeof l == "string" ? l : RR(l)
            }`
        )
        .join(",");
    },
    ...t,
    easing: e,
    duration: n,
  };
}
const Cj = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500,
};
function Rj(t) {
  return (
    Ls(t) ||
    typeof t > "u" ||
    typeof t == "string" ||
    typeof t == "boolean" ||
    typeof t == "number" ||
    Array.isArray(t)
  );
}
function JN(t = {}) {
  const e = { ...t };
  function n(r) {
    const i = Object.entries(r);
    for (let s = 0; s < i.length; s++) {
      const [o, a] = i[s];
      !Rj(a) || o.startsWith("unstable_")
        ? delete r[o]
        : Ls(a) && ((r[o] = { ...a }), n(r[o]));
    }
  }
  return (
    n(e),
    `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(e, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`
  );
}
function PR(t) {
  return typeof t == "number"
    ? `${(t * 100).toFixed(0)}%`
    : `calc((${t}) * 100%)`;
}
const Pj = (t) => {
  if (!Number.isNaN(+t)) return +t;
  const e = t.match(/\d*\.?\d+/g);
  if (!e) return 0;
  let n = 0;
  for (let r = 0; r < e.length; r += 1) n += +e[r];
  return n;
};
function Lj(t) {
  Object.assign(t, {
    alpha(e, n) {
      const r = this || t;
      return r.colorSpace
        ? `oklch(from ${e} l c h / ${typeof n == "string" ? `calc(${n})` : n})`
        : r.vars
        ? `rgba(${e.replace(
            /var\(--([^,\s)]+)(?:,[^)]+)?\)+/g,
            "var(--$1Channel)"
          )} / ${typeof n == "string" ? `calc(${n})` : n})`
        : Gg(e, Pj(n));
    },
    lighten(e, n) {
      const r = this || t;
      return r.colorSpace
        ? `color-mix(in ${r.colorSpace}, ${e}, #fff ${PR(n)})`
        : Lv(e, n);
    },
    darken(e, n) {
      const r = this || t;
      return r.colorSpace
        ? `color-mix(in ${r.colorSpace}, ${e}, #000 ${PR(n)})`
        : Pv(e, n);
    },
  });
}
function b1(t = {}, ...e) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: s = {},
    transitions: o = {},
    typography: a = {},
    shape: l,
    colorSpace: f,
    ...d
  } = t;
  if (t.vars && t.generateThemeVars === void 0) throw new Error(Mo(20));
  const h = KM({ ...s, colorSpace: f }),
    p = YM(t);
  let g = Lr(p, {
    mixins: vj(p.breakpoints, r),
    palette: h,
    shadows: Mj.slice(),
    typography: xj(h, a),
    transitions: Aj(o),
    zIndex: { ...Cj },
  });
  return (
    (g = Lr(g, d)),
    (g = e.reduce((v, _) => Lr(v, _), g)),
    (g.unstable_sxConfig = {
      ...yh,
      ...(d == null ? void 0 : d.unstable_sxConfig),
    }),
    (g.unstable_sx = function (_) {
      return Tc({ sx: _, theme: this });
    }),
    (g.toRuntimeSource = JN),
    Lj(g),
    g
  );
}
function T1(t) {
  let e;
  return (
    t < 1 ? (e = 5.11916 * t ** 2) : (e = 4.5 * Math.log(t + 1) + 2),
    Math.round(e * 10) / 1e3
  );
}
const Ij = [...Array(25)].map((t, e) => {
  if (e === 0) return "none";
  const n = T1(e);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function QN(t) {
  return {
    inputPlaceholder: t === "dark" ? 0.5 : 0.42,
    inputUnderline: t === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: t === "dark" ? 0.2 : 0.12,
    switchTrack: t === "dark" ? 0.3 : 0.38,
  };
}
function eO(t) {
  return t === "dark" ? Ij : [];
}
function Nj(t) {
  const {
      palette: e = { mode: "light" },
      opacity: n,
      overlays: r,
      colorSpace: i,
      ...s
    } = t,
    o = KM({ ...e, colorSpace: i });
  return {
    palette: o,
    opacity: { ...QN(o.mode), ...n },
    overlays: r || eO(o.mode),
    ...s,
  };
}
function Oj(t) {
  var e;
  return (
    !!t[0].match(
      /(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/
    ) ||
    !!t[0].match(/sxConfig$/) ||
    (t[0] === "palette" &&
      !!((e = t[1]) != null && e.match(/(mode|contrastThreshold|tonalOffset)/)))
  );
}
const Dj = (t) => [
    ...[...Array(25)].map((e, n) => `--${t ? `${t}-` : ""}overlays-${n}`),
    `--${t ? `${t}-` : ""}palette-AppBar-darkBg`,
    `--${t ? `${t}-` : ""}palette-AppBar-darkColor`,
  ],
  kj = (t) => (e, n) => {
    const r = t.rootSelector || ":root",
      i = t.colorSchemeSelector;
    let s = i;
    if (
      (i === "class" && (s = ".%s"),
      i === "data" && (s = "[data-%s]"),
      i != null &&
        i.startsWith("data-") &&
        !i.includes("%s") &&
        (s = `[${i}="%s"]`),
      t.defaultColorScheme === e)
    ) {
      if (e === "dark") {
        const o = {};
        return (
          Dj(t.cssVarPrefix).forEach((a) => {
            (o[a] = n[a]), delete n[a];
          }),
          s === "media"
            ? { [r]: n, "@media (prefers-color-scheme: dark)": { [r]: o } }
            : s
            ? { [s.replace("%s", e)]: o, [`${r}, ${s.replace("%s", e)}`]: n }
            : { [r]: { ...n, ...o } }
        );
      }
      if (s && s !== "media") return `${r}, ${s.replace("%s", String(e))}`;
    } else if (e) {
      if (s === "media")
        return { [`@media (prefers-color-scheme: ${String(e)})`]: { [r]: n } };
      if (s) return s.replace("%s", String(e));
    }
    return r;
  };
function Uj(t, e) {
  e.forEach((n) => {
    t[n] || (t[n] = {});
  });
}
function ve(t, e, n) {
  !t[e] && n && (t[e] = n);
}
function Hf(t) {
  return typeof t != "string" || !t.startsWith("hsl") ? t : XN(t);
}
function no(t, e) {
  `${e}Channel` in t || (t[`${e}Channel`] = Bf(Hf(t[e])));
}
function Fj(t) {
  return typeof t == "number"
    ? `${t}px`
    : typeof t == "string" || typeof t == "function" || Array.isArray(t)
    ? t
    : "8px";
}
const Es = (t) => {
    try {
      return t();
    } catch {}
  },
  zj = (t = "mui") => ij(t);
function x_(t, e, n, r, i) {
  if (!n) return;
  n = n === !0 ? {} : n;
  const s = i === "dark" ? "dark" : "light";
  if (!r) {
    e[i] = Nj({
      ...n,
      palette: { mode: s, ...(n == null ? void 0 : n.palette) },
      colorSpace: t,
    });
    return;
  }
  const { palette: o, ...a } = b1({
    ...r,
    palette: { mode: s, ...(n == null ? void 0 : n.palette) },
    colorSpace: t,
  });
  return (
    (e[i] = {
      ...n,
      palette: o,
      opacity: { ...QN(s), ...(n == null ? void 0 : n.opacity) },
      overlays: (n == null ? void 0 : n.overlays) || eO(s),
    }),
    a
  );
}
function Bj(t = {}, ...e) {
  const {
      colorSchemes: n = { light: !0 },
      defaultColorScheme: r,
      disableCssColorScheme: i = !1,
      cssVarPrefix: s = "mui",
      nativeColor: o = !1,
      shouldSkipGeneratingVar: a = Oj,
      colorSchemeSelector: l = n.light && n.dark ? "media" : void 0,
      rootSelector: f = ":root",
      ...d
    } = t,
    h = Object.keys(n)[0],
    p = r || (n.light && h !== "light" ? "light" : h),
    g = zj(s),
    { [p]: v, light: _, dark: x, ...m } = n,
    w = { ...m };
  let S = v;
  if (
    (((p === "dark" && !("dark" in n)) || (p === "light" && !("light" in n))) &&
      (S = !0),
    !S)
  )
    throw new Error(Mo(21, p));
  let E;
  o && (E = "oklch");
  const T = x_(E, w, S, d, p);
  _ && !w.light && x_(E, w, _, void 0, "light"),
    x && !w.dark && x_(E, w, x, void 0, "dark");
  let A = {
    defaultColorScheme: p,
    ...T,
    cssVarPrefix: s,
    colorSchemeSelector: l,
    rootSelector: f,
    getCssVar: g,
    colorSchemes: w,
    font: { ...gj(T.typography), ...T.font },
    spacing: Fj(d.spacing),
  };
  Object.keys(A.colorSchemes).forEach((k) => {
    const R = A.colorSchemes[k].palette,
      $ = (W) => {
        const Y = W.split("-"),
          Z = Y[1],
          B = Y[2];
        return g(W, R[Z][B]);
      };
    R.mode === "light" &&
      (ve(R.common, "background", "#fff"),
      ve(R.common, "onBackground", "#000")),
      R.mode === "dark" &&
        (ve(R.common, "background", "#000"),
        ve(R.common, "onBackground", "#fff"));
    function D(W, Y, Z) {
      if (E) {
        let B;
        return (
          W === Ya && (B = `transparent ${((1 - Z) * 100).toFixed(0)}%`),
          W === Ht && (B = `#000 ${(Z * 100).toFixed(0)}%`),
          W === Vt && (B = `#fff ${(Z * 100).toFixed(0)}%`),
          `color-mix(in ${E}, ${Y}, ${B})`
        );
      }
      return W(Y, Z);
    }
    if (
      (Uj(R, [
        "Alert",
        "AppBar",
        "Avatar",
        "Button",
        "Chip",
        "FilledInput",
        "LinearProgress",
        "Skeleton",
        "Slider",
        "SnackbarContent",
        "SpeedDialAction",
        "StepConnector",
        "StepContent",
        "Switch",
        "TableCell",
        "Tooltip",
      ]),
      R.mode === "light")
    ) {
      ve(R.Alert, "errorColor", D(Ht, R.error.light, 0.6)),
        ve(R.Alert, "infoColor", D(Ht, R.info.light, 0.6)),
        ve(R.Alert, "successColor", D(Ht, R.success.light, 0.6)),
        ve(R.Alert, "warningColor", D(Ht, R.warning.light, 0.6)),
        ve(R.Alert, "errorFilledBg", $("palette-error-main")),
        ve(R.Alert, "infoFilledBg", $("palette-info-main")),
        ve(R.Alert, "successFilledBg", $("palette-success-main")),
        ve(R.Alert, "warningFilledBg", $("palette-warning-main")),
        ve(
          R.Alert,
          "errorFilledColor",
          Es(() => R.getContrastText(R.error.main))
        ),
        ve(
          R.Alert,
          "infoFilledColor",
          Es(() => R.getContrastText(R.info.main))
        ),
        ve(
          R.Alert,
          "successFilledColor",
          Es(() => R.getContrastText(R.success.main))
        ),
        ve(
          R.Alert,
          "warningFilledColor",
          Es(() => R.getContrastText(R.warning.main))
        ),
        ve(R.Alert, "errorStandardBg", D(Vt, R.error.light, 0.9)),
        ve(R.Alert, "infoStandardBg", D(Vt, R.info.light, 0.9)),
        ve(R.Alert, "successStandardBg", D(Vt, R.success.light, 0.9)),
        ve(R.Alert, "warningStandardBg", D(Vt, R.warning.light, 0.9)),
        ve(R.Alert, "errorIconColor", $("palette-error-main")),
        ve(R.Alert, "infoIconColor", $("palette-info-main")),
        ve(R.Alert, "successIconColor", $("palette-success-main")),
        ve(R.Alert, "warningIconColor", $("palette-warning-main")),
        ve(R.AppBar, "defaultBg", $("palette-grey-100")),
        ve(R.Avatar, "defaultBg", $("palette-grey-400")),
        ve(R.Button, "inheritContainedBg", $("palette-grey-300")),
        ve(R.Button, "inheritContainedHoverBg", $("palette-grey-A100")),
        ve(R.Chip, "defaultBorder", $("palette-grey-400")),
        ve(R.Chip, "defaultAvatarColor", $("palette-grey-700")),
        ve(R.Chip, "defaultIconColor", $("palette-grey-700")),
        ve(R.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"),
        ve(R.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"),
        ve(R.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"),
        ve(R.LinearProgress, "primaryBg", D(Vt, R.primary.main, 0.62)),
        ve(R.LinearProgress, "secondaryBg", D(Vt, R.secondary.main, 0.62)),
        ve(R.LinearProgress, "errorBg", D(Vt, R.error.main, 0.62)),
        ve(R.LinearProgress, "infoBg", D(Vt, R.info.main, 0.62)),
        ve(R.LinearProgress, "successBg", D(Vt, R.success.main, 0.62)),
        ve(R.LinearProgress, "warningBg", D(Vt, R.warning.main, 0.62)),
        ve(
          R.Skeleton,
          "bg",
          E
            ? D(Ya, R.text.primary, 0.11)
            : `rgba(${$("palette-text-primaryChannel")} / 0.11)`
        ),
        ve(R.Slider, "primaryTrack", D(Vt, R.primary.main, 0.62)),
        ve(R.Slider, "secondaryTrack", D(Vt, R.secondary.main, 0.62)),
        ve(R.Slider, "errorTrack", D(Vt, R.error.main, 0.62)),
        ve(R.Slider, "infoTrack", D(Vt, R.info.main, 0.62)),
        ve(R.Slider, "successTrack", D(Vt, R.success.main, 0.62)),
        ve(R.Slider, "warningTrack", D(Vt, R.warning.main, 0.62));
      const W = E
        ? D(Ht, R.background.default, 0.6825)
        : Lm(R.background.default, 0.8);
      ve(R.SnackbarContent, "bg", W),
        ve(
          R.SnackbarContent,
          "color",
          Es(() => (E ? E1.text.primary : R.getContrastText(W)))
        ),
        ve(R.SpeedDialAction, "fabHoverBg", Lm(R.background.paper, 0.15)),
        ve(R.StepConnector, "border", $("palette-grey-400")),
        ve(R.StepContent, "border", $("palette-grey-400")),
        ve(R.Switch, "defaultColor", $("palette-common-white")),
        ve(R.Switch, "defaultDisabledColor", $("palette-grey-100")),
        ve(R.Switch, "primaryDisabledColor", D(Vt, R.primary.main, 0.62)),
        ve(R.Switch, "secondaryDisabledColor", D(Vt, R.secondary.main, 0.62)),
        ve(R.Switch, "errorDisabledColor", D(Vt, R.error.main, 0.62)),
        ve(R.Switch, "infoDisabledColor", D(Vt, R.info.main, 0.62)),
        ve(R.Switch, "successDisabledColor", D(Vt, R.success.main, 0.62)),
        ve(R.Switch, "warningDisabledColor", D(Vt, R.warning.main, 0.62)),
        ve(R.TableCell, "border", D(Vt, D(Ya, R.divider, 1), 0.88)),
        ve(R.Tooltip, "bg", D(Ya, R.grey[700], 0.92));
    }
    if (R.mode === "dark") {
      ve(R.Alert, "errorColor", D(Vt, R.error.light, 0.6)),
        ve(R.Alert, "infoColor", D(Vt, R.info.light, 0.6)),
        ve(R.Alert, "successColor", D(Vt, R.success.light, 0.6)),
        ve(R.Alert, "warningColor", D(Vt, R.warning.light, 0.6)),
        ve(R.Alert, "errorFilledBg", $("palette-error-dark")),
        ve(R.Alert, "infoFilledBg", $("palette-info-dark")),
        ve(R.Alert, "successFilledBg", $("palette-success-dark")),
        ve(R.Alert, "warningFilledBg", $("palette-warning-dark")),
        ve(
          R.Alert,
          "errorFilledColor",
          Es(() => R.getContrastText(R.error.dark))
        ),
        ve(
          R.Alert,
          "infoFilledColor",
          Es(() => R.getContrastText(R.info.dark))
        ),
        ve(
          R.Alert,
          "successFilledColor",
          Es(() => R.getContrastText(R.success.dark))
        ),
        ve(
          R.Alert,
          "warningFilledColor",
          Es(() => R.getContrastText(R.warning.dark))
        ),
        ve(R.Alert, "errorStandardBg", D(Ht, R.error.light, 0.9)),
        ve(R.Alert, "infoStandardBg", D(Ht, R.info.light, 0.9)),
        ve(R.Alert, "successStandardBg", D(Ht, R.success.light, 0.9)),
        ve(R.Alert, "warningStandardBg", D(Ht, R.warning.light, 0.9)),
        ve(R.Alert, "errorIconColor", $("palette-error-main")),
        ve(R.Alert, "infoIconColor", $("palette-info-main")),
        ve(R.Alert, "successIconColor", $("palette-success-main")),
        ve(R.Alert, "warningIconColor", $("palette-warning-main")),
        ve(R.AppBar, "defaultBg", $("palette-grey-900")),
        ve(R.AppBar, "darkBg", $("palette-background-paper")),
        ve(R.AppBar, "darkColor", $("palette-text-primary")),
        ve(R.Avatar, "defaultBg", $("palette-grey-600")),
        ve(R.Button, "inheritContainedBg", $("palette-grey-800")),
        ve(R.Button, "inheritContainedHoverBg", $("palette-grey-700")),
        ve(R.Chip, "defaultBorder", $("palette-grey-700")),
        ve(R.Chip, "defaultAvatarColor", $("palette-grey-300")),
        ve(R.Chip, "defaultIconColor", $("palette-grey-300")),
        ve(R.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"),
        ve(R.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"),
        ve(R.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"),
        ve(R.LinearProgress, "primaryBg", D(Ht, R.primary.main, 0.5)),
        ve(R.LinearProgress, "secondaryBg", D(Ht, R.secondary.main, 0.5)),
        ve(R.LinearProgress, "errorBg", D(Ht, R.error.main, 0.5)),
        ve(R.LinearProgress, "infoBg", D(Ht, R.info.main, 0.5)),
        ve(R.LinearProgress, "successBg", D(Ht, R.success.main, 0.5)),
        ve(R.LinearProgress, "warningBg", D(Ht, R.warning.main, 0.5)),
        ve(
          R.Skeleton,
          "bg",
          E
            ? D(Ya, R.text.primary, 0.13)
            : `rgba(${$("palette-text-primaryChannel")} / 0.13)`
        ),
        ve(R.Slider, "primaryTrack", D(Ht, R.primary.main, 0.5)),
        ve(R.Slider, "secondaryTrack", D(Ht, R.secondary.main, 0.5)),
        ve(R.Slider, "errorTrack", D(Ht, R.error.main, 0.5)),
        ve(R.Slider, "infoTrack", D(Ht, R.info.main, 0.5)),
        ve(R.Slider, "successTrack", D(Ht, R.success.main, 0.5)),
        ve(R.Slider, "warningTrack", D(Ht, R.warning.main, 0.5));
      const W = E
        ? D(Vt, R.background.default, 0.985)
        : Lm(R.background.default, 0.98);
      ve(R.SnackbarContent, "bg", W),
        ve(
          R.SnackbarContent,
          "color",
          Es(() => (E ? KN.text.primary : R.getContrastText(W)))
        ),
        ve(R.SpeedDialAction, "fabHoverBg", Lm(R.background.paper, 0.15)),
        ve(R.StepConnector, "border", $("palette-grey-600")),
        ve(R.StepContent, "border", $("palette-grey-600")),
        ve(R.Switch, "defaultColor", $("palette-grey-300")),
        ve(R.Switch, "defaultDisabledColor", $("palette-grey-600")),
        ve(R.Switch, "primaryDisabledColor", D(Ht, R.primary.main, 0.55)),
        ve(R.Switch, "secondaryDisabledColor", D(Ht, R.secondary.main, 0.55)),
        ve(R.Switch, "errorDisabledColor", D(Ht, R.error.main, 0.55)),
        ve(R.Switch, "infoDisabledColor", D(Ht, R.info.main, 0.55)),
        ve(R.Switch, "successDisabledColor", D(Ht, R.success.main, 0.55)),
        ve(R.Switch, "warningDisabledColor", D(Ht, R.warning.main, 0.55)),
        ve(R.TableCell, "border", D(Ht, D(Ya, R.divider, 1), 0.68)),
        ve(R.Tooltip, "bg", D(Ya, R.grey[700], 0.92));
    }
    no(R.background, "default"),
      no(R.background, "paper"),
      no(R.common, "background"),
      no(R.common, "onBackground"),
      no(R, "divider"),
      Object.keys(R).forEach((W) => {
        const Y = R[W];
        W !== "tonalOffset" &&
          Y &&
          typeof Y == "object" &&
          (Y.main && ve(R[W], "mainChannel", Bf(Hf(Y.main))),
          Y.light && ve(R[W], "lightChannel", Bf(Hf(Y.light))),
          Y.dark && ve(R[W], "darkChannel", Bf(Hf(Y.dark))),
          Y.contrastText &&
            ve(R[W], "contrastTextChannel", Bf(Hf(Y.contrastText))),
          W === "text" && (no(R[W], "primary"), no(R[W], "secondary")),
          W === "action" &&
            (Y.active && no(R[W], "active"),
            Y.selected && no(R[W], "selected")));
      });
  }),
    (A = e.reduce((k, R) => Lr(k, R), A));
  const L = {
      prefix: s,
      disableCssColorScheme: i,
      shouldSkipGeneratingVar: a,
      getSelector: kj(A),
      enableContrastVars: o,
    },
    { vars: N, generateThemeVars: C, generateStyleSheets: I } = aj(A, L);
  return (
    (A.vars = N),
    Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([k, R]) => {
      A[k] = R;
    }),
    (A.generateThemeVars = C),
    (A.generateStyleSheets = I),
    (A.generateSpacing = function () {
      return VN(d.spacing, $M(this));
    }),
    (A.getColorSchemeSelector = lj(l)),
    (A.spacing = A.generateSpacing()),
    (A.shouldSkipGeneratingVar = a),
    (A.unstable_sxConfig = {
      ...yh,
      ...(d == null ? void 0 : d.unstable_sxConfig),
    }),
    (A.unstable_sx = function (R) {
      return Tc({ sx: R, theme: this });
    }),
    (A.toRuntimeSource = JN),
    A
  );
}
function LR(t, e, n) {
  t.colorSchemes &&
    n &&
    (t.colorSchemes[e] = {
      ...(n !== !0 && n),
      palette: KM({ ...(n === !0 ? {} : n.palette), mode: e }),
    });
}
function Hj(t = {}, ...e) {
  const {
      palette: n,
      cssVariables: r = !1,
      colorSchemes: i = n ? void 0 : { light: !0 },
      defaultColorScheme: s = n == null ? void 0 : n.mode,
      ...o
    } = t,
    a = s || "light",
    l = i == null ? void 0 : i[a],
    f = {
      ...i,
      ...(n
        ? { [a]: { ...(typeof l != "boolean" && l), palette: n } }
        : void 0),
    };
  if (r === !1) {
    if (!("colorSchemes" in t)) return b1(t, ...e);
    let d = n;
    "palette" in t ||
      (f[a] &&
        (f[a] !== !0
          ? (d = f[a].palette)
          : a === "dark" && (d = { mode: "dark" })));
    const h = b1({ ...t, palette: d }, ...e);
    return (
      (h.defaultColorScheme = a),
      (h.colorSchemes = f),
      h.palette.mode === "light" &&
        ((h.colorSchemes.light = {
          ...(f.light !== !0 && f.light),
          palette: h.palette,
        }),
        LR(h, "dark", f.dark)),
      h.palette.mode === "dark" &&
        ((h.colorSchemes.dark = {
          ...(f.dark !== !0 && f.dark),
          palette: h.palette,
        }),
        LR(h, "light", f.light)),
      h
    );
  }
  return (
    !n && !("light" in f) && a === "light" && (f.light = !0),
    Bj(
      {
        ...o,
        colorSchemes: f,
        defaultColorScheme: a,
        ...(typeof r != "boolean" && r),
      },
      ...e
    )
  );
}
const ZM = Hj();
function JM() {
  const t = WN(ZM);
  return t[OM] || t;
}
function tO(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
const Vs = (t) => tO(t) && t !== "classes",
  Rt = B7({ themeId: OM, defaultTheme: ZM, rootShouldForwardProp: Vs });
function IR(...t) {
  return t.reduce(
    (e, n) =>
      n == null
        ? e
        : function (...i) {
            e.apply(this, i), n.apply(this, i);
          },
    () => {}
  );
}
function nO(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++)
        t[e] && (n = nO(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function In() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
    (t = arguments[n]) && (e = nO(t)) && (r && (r += " "), (r += e));
  return r;
}
function Vj(t) {
  return Q.jsx(L7, { ...t, defaultTheme: ZM, themeId: OM });
}
function Wj(t) {
  return function (n) {
    return Q.jsx(Vj, {
      styles: typeof t == "function" ? (r) => t({ theme: r, ...n }) : t,
    });
  };
}
function Gj() {
  return N7;
}
const pr = rj;
function ir(t) {
  return ej(t);
}
function jj(t) {
  return zn("MuiSvgIcon", t);
}
Yn("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const $j = (t) => {
    const { color: e, fontSize: n, classes: r } = t,
      i = {
        root: ["root", e !== "inherit" && `color${gn(e)}`, `fontSize${gn(n)}`],
      };
    return Bn(i, jj, r);
  },
  Xj = Rt("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.color !== "inherit" && e[`color${gn(n.color)}`],
        e[`fontSize${gn(n.fontSize)}`],
      ];
    },
  })(
    pr(({ theme: t }) => {
      var e, n, r, i, s, o, a, l, f, d, h, p, g, v;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        flexShrink: 0,
        transition:
          (i = (e = t.transitions) == null ? void 0 : e.create) == null
            ? void 0
            : i.call(e, "fill", {
                duration:
                  (r =
                    (n = (t.vars ?? t).transitions) == null
                      ? void 0
                      : n.duration) == null
                    ? void 0
                    : r.shorter,
              }),
        variants: [
          { props: (_) => !_.hasSvgAsChild, style: { fill: "currentColor" } },
          { props: { fontSize: "inherit" }, style: { fontSize: "inherit" } },
          {
            props: { fontSize: "small" },
            style: {
              fontSize:
                ((o = (s = t.typography) == null ? void 0 : s.pxToRem) == null
                  ? void 0
                  : o.call(s, 20)) || "1.25rem",
            },
          },
          {
            props: { fontSize: "medium" },
            style: {
              fontSize:
                ((l = (a = t.typography) == null ? void 0 : a.pxToRem) == null
                  ? void 0
                  : l.call(a, 24)) || "1.5rem",
            },
          },
          {
            props: { fontSize: "large" },
            style: {
              fontSize:
                ((d = (f = t.typography) == null ? void 0 : f.pxToRem) == null
                  ? void 0
                  : d.call(f, 35)) || "2.1875rem",
            },
          },
          ...Object.entries((t.vars ?? t).palette)
            .filter(([, _]) => _ && _.main)
            .map(([_]) => {
              var x, m;
              return {
                props: { color: _ },
                style: {
                  color:
                    (m = (x = (t.vars ?? t).palette) == null ? void 0 : x[_]) ==
                    null
                      ? void 0
                      : m.main,
                },
              };
            }),
          {
            props: { color: "action" },
            style: {
              color:
                (p = (h = (t.vars ?? t).palette) == null ? void 0 : h.action) ==
                null
                  ? void 0
                  : p.active,
            },
          },
          {
            props: { color: "disabled" },
            style: {
              color:
                (v = (g = (t.vars ?? t).palette) == null ? void 0 : g.action) ==
                null
                  ? void 0
                  : v.disabled,
            },
          },
          { props: { color: "inherit" }, style: { color: void 0 } },
        ],
      };
    })
  ),
  A1 = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiSvgIcon" }),
      {
        children: i,
        className: s,
        color: o = "inherit",
        component: a = "svg",
        fontSize: l = "medium",
        htmlColor: f,
        inheritViewBox: d = !1,
        titleAccess: h,
        viewBox: p = "0 0 24 24",
        ...g
      } = r,
      v = U.isValidElement(i) && i.type === "svg",
      _ = {
        ...r,
        color: o,
        component: a,
        fontSize: l,
        instanceFontSize: e.fontSize,
        inheritViewBox: d,
        viewBox: p,
        hasSvgAsChild: v,
      },
      x = {};
    d || (x.viewBox = p);
    const m = $j(_);
    return Q.jsxs(Xj, {
      as: a,
      className: In(m.root, s),
      focusable: "false",
      color: f,
      "aria-hidden": h ? void 0 : !0,
      role: h ? "img" : void 0,
      ref: n,
      ...x,
      ...g,
      ...(v && i.props),
      ownerState: _,
      children: [
        v ? i.props.children : i,
        h ? Q.jsx("title", { children: h }) : null,
      ],
    });
  });
A1.muiName = "SvgIcon";
function rO(t, e) {
  function n(r, i) {
    return Q.jsx(A1, { "data-testid": void 0, ref: i, ...r, children: t });
  }
  return (n.muiName = A1.muiName), U.memo(U.forwardRef(n));
}
function iO(t, e = 166) {
  let n;
  function r(...i) {
    const s = () => {
      t.apply(this, i);
    };
    clearTimeout(n), (n = setTimeout(s, e));
  }
  return (
    (r.clear = () => {
      clearTimeout(n);
    }),
    r
  );
}
function fs(t) {
  return (t && t.ownerDocument) || document;
}
function bo(t) {
  return fs(t).defaultView || window;
}
function NR(t, e) {
  typeof t == "function" ? t(e) : t && (t.current = e);
}
function OR(t) {
  const { controlled: e, default: n, name: r, state: i = "value" } = t,
    { current: s } = U.useRef(e !== void 0),
    [o, a] = U.useState(n),
    l = s ? e : o,
    f = U.useCallback((d) => {
      s || a(d);
    }, []);
  return [l, f];
}
function C1(t) {
  const e = U.useRef(t);
  return (
    Nl(() => {
      e.current = t;
    }),
    U.useRef((...n) => (0, e.current)(...n)).current
  );
}
function $i(...t) {
  const e = U.useRef(void 0),
    n = U.useCallback((r) => {
      const i = t.map((s) => {
        if (s == null) return null;
        if (typeof s == "function") {
          const o = s,
            a = o(r);
          return typeof a == "function"
            ? a
            : () => {
                o(null);
              };
        }
        return (
          (s.current = r),
          () => {
            s.current = null;
          }
        );
      });
      return () => {
        i.forEach((s) => (s == null ? void 0 : s()));
      };
    }, t);
  return U.useMemo(
    () =>
      t.every((r) => r == null)
        ? null
        : (r) => {
            e.current && (e.current(), (e.current = void 0)),
              r != null && (e.current = n(r));
          },
    t
  );
}
function Yj(t, e) {
  const n = t.charCodeAt(2);
  return (
    t[0] === "o" && t[1] === "n" && n >= 65 && n <= 90 && typeof e == "function"
  );
}
function qj(t, e) {
  if (!t) return e;
  function n(o, a) {
    const l = {};
    return (
      Object.keys(a).forEach((f) => {
        Yj(f, a[f]) &&
          typeof o[f] == "function" &&
          (l[f] = (...d) => {
            o[f](...d), a[f](...d);
          });
      }),
      l
    );
  }
  if (typeof t == "function" || typeof e == "function")
    return (o) => {
      const a = typeof e == "function" ? e(o) : e,
        l = typeof t == "function" ? t({ ...o, ...a }) : t,
        f = In(
          o == null ? void 0 : o.className,
          a == null ? void 0 : a.className,
          l == null ? void 0 : l.className
        ),
        d = n(l, a);
      return {
        ...a,
        ...l,
        ...d,
        ...(!!f && { className: f }),
        ...((a == null ? void 0 : a.style) &&
          (l == null ? void 0 : l.style) && {
            style: { ...a.style, ...l.style },
          }),
        ...((a == null ? void 0 : a.sx) &&
          (l == null ? void 0 : l.sx) && {
            sx: [
              ...(Array.isArray(a.sx) ? a.sx : [a.sx]),
              ...(Array.isArray(l.sx) ? l.sx : [l.sx]),
            ],
          }),
      };
    };
  const r = e,
    i = n(t, r),
    s = In(r == null ? void 0 : r.className, t == null ? void 0 : t.className);
  return {
    ...e,
    ...t,
    ...i,
    ...(!!s && { className: s }),
    ...((r == null ? void 0 : r.style) &&
      (t == null ? void 0 : t.style) && { style: { ...r.style, ...t.style } }),
    ...((r == null ? void 0 : r.sx) &&
      (t == null ? void 0 : t.sx) && {
        sx: [
          ...(Array.isArray(r.sx) ? r.sx : [r.sx]),
          ...(Array.isArray(t.sx) ? t.sx : [t.sx]),
        ],
      }),
  };
}
function R1(t, e) {
  return (
    (R1 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    R1(t, e)
  );
}
function Kj(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    R1(t, e);
}
const DR = { disabled: !1 },
  sO = ol.createContext(null);
var Zj = function (e) {
    return e.scrollTop;
  },
  Vf = "unmounted",
  rl = "exited",
  il = "entering",
  Du = "entered",
  P1 = "exiting",
  Ws = (function (t) {
    Kj(e, t);
    function e(r, i) {
      var s;
      s = t.call(this, r, i) || this;
      var o = i,
        a = o && !o.isMounting ? r.enter : r.appear,
        l;
      return (
        (s.appearStatus = null),
        r.in
          ? a
            ? ((l = rl), (s.appearStatus = il))
            : (l = Du)
          : r.unmountOnExit || r.mountOnEnter
          ? (l = Vf)
          : (l = rl),
        (s.state = { status: l }),
        (s.nextCallback = null),
        s
      );
    }
    e.getDerivedStateFromProps = function (i, s) {
      var o = i.in;
      return o && s.status === Vf ? { status: rl } : null;
    };
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (n.componentDidUpdate = function (i) {
        var s = null;
        if (i !== this.props) {
          var o = this.state.status;
          this.props.in
            ? o !== il && o !== Du && (s = il)
            : (o === il || o === Du) && (s = P1);
        }
        this.updateStatus(!1, s);
      }),
      (n.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (n.getTimeouts = function () {
        var i = this.props.timeout,
          s,
          o,
          a;
        return (
          (s = o = a = i),
          i != null &&
            typeof i != "number" &&
            ((s = i.exit),
            (o = i.enter),
            (a = i.appear !== void 0 ? i.appear : o)),
          { exit: s, enter: o, appear: a }
        );
      }),
      (n.updateStatus = function (i, s) {
        if ((i === void 0 && (i = !1), s !== null))
          if ((this.cancelNextCallback(), s === il)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var o = this.props.nodeRef
                ? this.props.nodeRef.current
                : Op.findDOMNode(this);
              o && Zj(o);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === rl &&
            this.setState({ status: Vf });
      }),
      (n.performEnter = function (i) {
        var s = this,
          o = this.props.enter,
          a = this.context ? this.context.isMounting : i,
          l = this.props.nodeRef ? [a] : [Op.findDOMNode(this), a],
          f = l[0],
          d = l[1],
          h = this.getTimeouts(),
          p = a ? h.appear : h.enter;
        if ((!i && !o) || DR.disabled) {
          this.safeSetState({ status: Du }, function () {
            s.props.onEntered(f);
          });
          return;
        }
        this.props.onEnter(f, d),
          this.safeSetState({ status: il }, function () {
            s.props.onEntering(f, d),
              s.onTransitionEnd(p, function () {
                s.safeSetState({ status: Du }, function () {
                  s.props.onEntered(f, d);
                });
              });
          });
      }),
      (n.performExit = function () {
        var i = this,
          s = this.props.exit,
          o = this.getTimeouts(),
          a = this.props.nodeRef ? void 0 : Op.findDOMNode(this);
        if (!s || DR.disabled) {
          this.safeSetState({ status: rl }, function () {
            i.props.onExited(a);
          });
          return;
        }
        this.props.onExit(a),
          this.safeSetState({ status: P1 }, function () {
            i.props.onExiting(a),
              i.onTransitionEnd(o.exit, function () {
                i.safeSetState({ status: rl }, function () {
                  i.props.onExited(a);
                });
              });
          });
      }),
      (n.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (n.safeSetState = function (i, s) {
        (s = this.setNextCallback(s)), this.setState(i, s);
      }),
      (n.setNextCallback = function (i) {
        var s = this,
          o = !0;
        return (
          (this.nextCallback = function (a) {
            o && ((o = !1), (s.nextCallback = null), i(a));
          }),
          (this.nextCallback.cancel = function () {
            o = !1;
          }),
          this.nextCallback
        );
      }),
      (n.onTransitionEnd = function (i, s) {
        this.setNextCallback(s);
        var o = this.props.nodeRef
            ? this.props.nodeRef.current
            : Op.findDOMNode(this),
          a = i == null && !this.props.addEndListener;
        if (!o || a) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var l = this.props.nodeRef
              ? [this.nextCallback]
              : [o, this.nextCallback],
            f = l[0],
            d = l[1];
          this.props.addEndListener(f, d);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (n.render = function () {
        var i = this.state.status;
        if (i === Vf) return null;
        var s = this.props,
          o = s.children;
        s.in,
          s.mountOnEnter,
          s.unmountOnExit,
          s.appear,
          s.enter,
          s.exit,
          s.timeout,
          s.addEndListener,
          s.onEnter,
          s.onEntering,
          s.onEntered,
          s.onExit,
          s.onExiting,
          s.onExited,
          s.nodeRef;
        var a = uF(s, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return ol.createElement(
          sO.Provider,
          { value: null },
          typeof o == "function"
            ? o(i, a)
            : ol.cloneElement(ol.Children.only(o), a)
        );
      }),
      e
    );
  })(ol.Component);
Ws.contextType = sO;
Ws.propTypes = {};
function Iu() {}
Ws.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Iu,
  onEntering: Iu,
  onEntered: Iu,
  onExit: Iu,
  onExiting: Iu,
  onExited: Iu,
};
Ws.UNMOUNTED = Vf;
Ws.EXITED = rl;
Ws.ENTERING = il;
Ws.ENTERED = Du;
Ws.EXITING = P1;
const kR = {};
function Jj(t, e) {
  const n = U.useRef(kR);
  return n.current === kR && (n.current = t(e)), n;
}
const Qj = [];
function e$(t) {
  U.useEffect(t, Qj);
}
class QM {
  constructor() {
    gp(this, "currentId", null);
    gp(this, "clear", () => {
      this.currentId !== null &&
        (clearTimeout(this.currentId), (this.currentId = null));
    });
    gp(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new QM();
  }
  start(e, n) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        (this.currentId = null), n();
      }, e));
  }
}
function t$() {
  const t = Jj(QM.create).current;
  return e$(t.disposeEffect), t;
}
const oO = (t) => t.scrollTop;
function jg(t, e) {
  const { timeout: n, easing: r, style: i = {} } = t;
  return {
    duration:
      i.transitionDuration ?? (typeof n == "number" ? n : n[e.mode] || 0),
    easing:
      i.transitionTimingFunction ?? (typeof r == "object" ? r[e.mode] : r),
    delay: i.transitionDelay,
  };
}
function n$(t) {
  return zn("MuiPaper", t);
}
Yn("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const r$ = (t) => {
    const { square: e, elevation: n, variant: r, classes: i } = t,
      s = {
        root: [
          "root",
          r,
          !e && "rounded",
          r === "elevation" && `elevation${n}`,
        ],
      };
    return Bn(s, n$, i);
  },
  i$ = Rt("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[n.variant],
        !n.square && e.rounded,
        n.variant === "elevation" && e[`elevation${n.elevation}`],
      ];
    },
  })(
    pr(({ theme: t }) => ({
      backgroundColor: (t.vars || t).palette.background.paper,
      color: (t.vars || t).palette.text.primary,
      transition: t.transitions.create("box-shadow"),
      variants: [
        {
          props: ({ ownerState: e }) => !e.square,
          style: { borderRadius: t.shape.borderRadius },
        },
        {
          props: { variant: "outlined" },
          style: { border: `1px solid ${(t.vars || t).palette.divider}` },
        },
        {
          props: { variant: "elevation" },
          style: {
            boxShadow: "var(--Paper-shadow)",
            backgroundImage: "var(--Paper-overlay)",
          },
        },
      ],
    }))
  ),
  s$ = U.forwardRef(function (e, n) {
    var g;
    const r = ir({ props: e, name: "MuiPaper" }),
      i = JM(),
      {
        className: s,
        component: o = "div",
        elevation: a = 1,
        square: l = !1,
        variant: f = "elevation",
        ...d
      } = r,
      h = { ...r, component: o, elevation: a, square: l, variant: f },
      p = r$(h);
    return Q.jsx(i$, {
      as: o,
      ownerState: h,
      className: In(p.root, s),
      ref: n,
      ...d,
      style: {
        ...(f === "elevation" && {
          "--Paper-shadow": (i.vars || i).shadows[a],
          ...(i.vars && {
            "--Paper-overlay": (g = i.vars.overlays) == null ? void 0 : g[a],
          }),
          ...(!i.vars &&
            i.palette.mode === "dark" && {
              "--Paper-overlay": `linear-gradient(${Gg("#fff", T1(a))}, ${Gg(
                "#fff",
                T1(a)
              )})`,
            }),
        }),
        ...d.style,
      },
    });
  });
function $g(t) {
  return typeof t == "string";
}
function aO(t, e, n) {
  return t === void 0 || $g(t)
    ? e
    : { ...e, ownerState: { ...e.ownerState, ...n } };
}
function lO(t, e, n) {
  return typeof t == "function" ? t(e, n) : t;
}
function uO(t, e = []) {
  if (t === void 0) return {};
  const n = {};
  return (
    Object.keys(t)
      .filter(
        (r) =>
          r.match(/^on[A-Z]/) && typeof t[r] == "function" && !e.includes(r)
      )
      .forEach((r) => {
        n[r] = t[r];
      }),
    n
  );
}
function UR(t) {
  if (t === void 0) return {};
  const e = {};
  return (
    Object.keys(t)
      .filter((n) => !(n.match(/^on[A-Z]/) && typeof t[n] == "function"))
      .forEach((n) => {
        e[n] = t[n];
      }),
    e
  );
}
function cO(t) {
  const {
    getSlotProps: e,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: s,
  } = t;
  if (!e) {
    const g = S1(
        n == null ? void 0 : n.className,
        s,
        i == null ? void 0 : i.className,
        r == null ? void 0 : r.className
      ),
      v = {
        ...(n == null ? void 0 : n.style),
        ...(i == null ? void 0 : i.style),
        ...(r == null ? void 0 : r.style),
      },
      _ = { ...n, ...i, ...r };
    return (
      g.length > 0 && (_.className = g),
      Object.keys(v).length > 0 && (_.style = v),
      { props: _, internalRef: void 0 }
    );
  }
  const o = uO({ ...i, ...r }),
    a = UR(r),
    l = UR(i),
    f = e(o),
    d = S1(
      f == null ? void 0 : f.className,
      n == null ? void 0 : n.className,
      s,
      i == null ? void 0 : i.className,
      r == null ? void 0 : r.className
    ),
    h = {
      ...(f == null ? void 0 : f.style),
      ...(n == null ? void 0 : n.style),
      ...(i == null ? void 0 : i.style),
      ...(r == null ? void 0 : r.style),
    },
    p = { ...f, ...n, ...l, ...a };
  return (
    d.length > 0 && (p.className = d),
    Object.keys(h).length > 0 && (p.style = h),
    { props: p, internalRef: f.ref }
  );
}
function Ar(t, e) {
  const {
      className: n,
      elementType: r,
      ownerState: i,
      externalForwardedProps: s,
      internalForwardedProps: o,
      shouldForwardComponentProp: a = !1,
      ...l
    } = e,
    {
      component: f,
      slots: d = { [t]: void 0 },
      slotProps: h = { [t]: void 0 },
      ...p
    } = s,
    g = d[t] || r,
    v = lO(h[t], i),
    {
      props: { component: _, ...x },
      internalRef: m,
    } = cO({
      className: n,
      ...l,
      externalForwardedProps: t === "root" ? p : void 0,
      externalSlotProps: v,
    }),
    w = $i(m, v == null ? void 0 : v.ref, e.ref),
    S = t === "root" ? _ || f : _,
    E = aO(
      g,
      {
        ...(t === "root" && !f && !d[t] && o),
        ...(t !== "root" && !d[t] && o),
        ...x,
        ...(S && !a && { as: S }),
        ...(S && a && { component: S }),
        ref: w,
      },
      i
    );
  return [g, E];
}
function o$(t) {
  return typeof t.main == "string";
}
function a$(t, e = []) {
  if (!o$(t)) return !1;
  for (const n of e)
    if (!t.hasOwnProperty(n) || typeof t[n] != "string") return !1;
  return !0;
}
function xh(t = []) {
  return ([, e]) => e && a$(e, t);
}
function l$(t) {
  return zn("MuiTypography", t);
}
Yn("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const u$ = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0,
  },
  c$ = Gj(),
  f$ = (t) => {
    const {
        align: e,
        gutterBottom: n,
        noWrap: r,
        paragraph: i,
        variant: s,
        classes: o,
      } = t,
      a = {
        root: [
          "root",
          s,
          t.align !== "inherit" && `align${gn(e)}`,
          n && "gutterBottom",
          r && "noWrap",
          i && "paragraph",
        ],
      };
    return Bn(a, l$, o);
  },
  d$ = Rt("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.variant && e[n.variant],
        n.align !== "inherit" && e[`align${gn(n.align)}`],
        n.noWrap && e.noWrap,
        n.gutterBottom && e.gutterBottom,
        n.paragraph && e.paragraph,
      ];
    },
  })(
    pr(({ theme: t }) => {
      var e;
      return {
        margin: 0,
        variants: [
          {
            props: { variant: "inherit" },
            style: {
              font: "inherit",
              lineHeight: "inherit",
              letterSpacing: "inherit",
            },
          },
          ...Object.entries(t.typography)
            .filter(([n, r]) => n !== "inherit" && r && typeof r == "object")
            .map(([n, r]) => ({ props: { variant: n }, style: r })),
          ...Object.entries(t.palette)
            .filter(xh())
            .map(([n]) => ({
              props: { color: n },
              style: { color: (t.vars || t).palette[n].main },
            })),
          ...Object.entries(((e = t.palette) == null ? void 0 : e.text) || {})
            .filter(([, n]) => typeof n == "string")
            .map(([n]) => ({
              props: { color: `text${gn(n)}` },
              style: { color: (t.vars || t).palette.text[n] },
            })),
          {
            props: ({ ownerState: n }) => n.align !== "inherit",
            style: { textAlign: "var(--Typography-textAlign)" },
          },
          {
            props: ({ ownerState: n }) => n.noWrap,
            style: {
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap",
            },
          },
          {
            props: ({ ownerState: n }) => n.gutterBottom,
            style: { marginBottom: "0.35em" },
          },
          {
            props: ({ ownerState: n }) => n.paragraph,
            style: { marginBottom: 16 },
          },
        ],
      };
    })
  ),
  FR = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  ro = U.forwardRef(function (e, n) {
    const { color: r, ...i } = ir({ props: e, name: "MuiTypography" }),
      s = !u$[r],
      o = c$({ ...i, ...(s && { color: r }) }),
      {
        align: a = "inherit",
        className: l,
        component: f,
        gutterBottom: d = !1,
        noWrap: h = !1,
        paragraph: p = !1,
        variant: g = "body1",
        variantMapping: v = FR,
        ..._
      } = o,
      x = {
        ...o,
        align: a,
        color: r,
        className: l,
        component: f,
        gutterBottom: d,
        noWrap: h,
        paragraph: p,
        variant: g,
        variantMapping: v,
      },
      m = f || (p ? "p" : v[g] || FR[g]) || "span",
      w = f$(x);
    return Q.jsx(d$, {
      as: m,
      ref: n,
      className: In(w.root, l),
      ..._,
      ownerState: x,
      style: {
        ...(a !== "inherit" && { "--Typography-textAlign": a }),
        ..._.style,
      },
    });
  });
function h$(t) {
  var h;
  const {
      elementType: e,
      externalSlotProps: n,
      ownerState: r,
      skipResolvingSlotProps: i = !1,
      ...s
    } = t,
    o = i ? {} : lO(n, r),
    { props: a, internalRef: l } = cO({ ...s, externalSlotProps: o }),
    f = $i(
      l,
      o == null ? void 0 : o.ref,
      (h = t.additionalProps) == null ? void 0 : h.ref
    );
  return aO(e, { ...a, ref: f }, r);
}
function _h(t) {
  var e;
  return parseInt(U.version, 10) >= 19
    ? ((e = t == null ? void 0 : t.props) == null ? void 0 : e.ref) || null
    : (t == null ? void 0 : t.ref) || null;
}
function p$(t) {
  return typeof t == "function" ? t() : t;
}
const m$ = U.forwardRef(function (e, n) {
  const { children: r, container: i, disablePortal: s = !1 } = e,
    [o, a] = U.useState(null),
    l = $i(U.isValidElement(r) ? _h(r) : null, n);
  if (
    (Nl(() => {
      s || a(p$(i) || document.body);
    }, [i, s]),
    Nl(() => {
      if (o && !s)
        return (
          NR(n, o),
          () => {
            NR(n, null);
          }
        );
    }, [n, o, s]),
    s)
  ) {
    if (U.isValidElement(r)) {
      const f = { ref: l };
      return U.cloneElement(r, f);
    }
    return r;
  }
  return o && c0.createPortal(r, o);
});
function Im(t) {
  return parseInt(t, 10) || 0;
}
const g$ = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)",
  },
};
function v$(t) {
  for (const e in t) return !1;
  return !0;
}
function zR(t) {
  return v$(t) || (t.outerHeightStyle === 0 && !t.overflowing);
}
const y$ = U.forwardRef(function (e, n) {
  const {
      onChange: r,
      maxRows: i,
      minRows: s = 1,
      style: o,
      value: a,
      ...l
    } = e,
    { current: f } = U.useRef(a != null),
    d = U.useRef(null),
    h = $i(n, d),
    p = U.useRef(null),
    g = U.useRef(null),
    v = U.useCallback(() => {
      const S = d.current,
        E = g.current;
      if (!S || !E) return;
      const A = bo(S).getComputedStyle(S);
      if (A.width === "0px") return { outerHeightStyle: 0, overflowing: !1 };
      (E.style.width = A.width),
        (E.value = S.value || e.placeholder || "x"),
        E.value.slice(-1) ===
          `
` && (E.value += " ");
      const L = A.boxSizing,
        N = Im(A.paddingBottom) + Im(A.paddingTop),
        C = Im(A.borderBottomWidth) + Im(A.borderTopWidth),
        I = E.scrollHeight;
      E.value = "x";
      const k = E.scrollHeight;
      let R = I;
      s && (R = Math.max(Number(s) * k, R)),
        i && (R = Math.min(Number(i) * k, R)),
        (R = Math.max(R, k));
      const $ = R + (L === "border-box" ? N + C : 0),
        D = Math.abs(R - I) <= 1;
      return { outerHeightStyle: $, overflowing: D };
    }, [i, s, e.placeholder]),
    _ = C1(() => {
      const S = d.current,
        E = v();
      if (!S || !E || zR(E)) return !1;
      const T = E.outerHeightStyle;
      return p.current != null && p.current !== T;
    }),
    x = U.useCallback(() => {
      const S = d.current,
        E = v();
      if (!S || !E || zR(E)) return;
      const T = E.outerHeightStyle;
      p.current !== T && ((p.current = T), (S.style.height = `${T}px`)),
        (S.style.overflow = E.overflowing ? "hidden" : "");
    }, [v]),
    m = U.useRef(-1);
  Nl(() => {
    const S = iO(x),
      E = d == null ? void 0 : d.current;
    if (!E) return;
    const T = bo(E);
    T.addEventListener("resize", S);
    let A;
    return (
      typeof ResizeObserver < "u" &&
        ((A = new ResizeObserver(() => {
          _() &&
            (A.unobserve(E),
            cancelAnimationFrame(m.current),
            x(),
            (m.current = requestAnimationFrame(() => {
              A.observe(E);
            })));
        })),
        A.observe(E)),
      () => {
        S.clear(),
          cancelAnimationFrame(m.current),
          T.removeEventListener("resize", S),
          A && A.disconnect();
      }
    );
  }, [v, x, _]),
    Nl(() => {
      x();
    });
  const w = (S) => {
    f || x();
    const E = S.target,
      T = E.value.length,
      A = E.value.endsWith(`
`),
      L = E.selectionStart === T;
    A && L && E.setSelectionRange(T, T), r && r(S);
  };
  return Q.jsxs(U.Fragment, {
    children: [
      Q.jsx("textarea", {
        value: a,
        onChange: w,
        ref: h,
        rows: s,
        style: o,
        ...l,
      }),
      Q.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: g,
        tabIndex: -1,
        style: { ...g$.shadow, ...o, paddingTop: 0, paddingBottom: 0 },
      }),
    ],
  });
});
function Uc({ props: t, states: e, muiFormControl: n }) {
  return e.reduce(
    (r, i) => ((r[i] = t[i]), n && typeof t[i] > "u" && (r[i] = n[i]), r),
    {}
  );
}
const eE = U.createContext(void 0);
function Fc() {
  return U.useContext(eE);
}
function BR(t) {
  return t != null && !(Array.isArray(t) && t.length === 0);
}
function Xg(t, e = !1) {
  return (
    t &&
    ((BR(t.value) && t.value !== "") ||
      (e && BR(t.defaultValue) && t.defaultValue !== ""))
  );
}
function x$(t) {
  return t.startAdornment;
}
function _$(t) {
  return zn("MuiInputBase", t);
}
const Ac = Yn("MuiInputBase", [
  "root",
  "formControl",
  "focused",
  "disabled",
  "adornedStart",
  "adornedEnd",
  "error",
  "sizeSmall",
  "multiline",
  "colorSecondary",
  "fullWidth",
  "hiddenLabel",
  "readOnly",
  "input",
  "inputSizeSmall",
  "inputMultiline",
  "inputTypeSearch",
  "inputAdornedStart",
  "inputAdornedEnd",
  "inputHiddenLabel",
]);
var HR;
const Iv = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.root,
      n.formControl && e.formControl,
      n.startAdornment && e.adornedStart,
      n.endAdornment && e.adornedEnd,
      n.error && e.error,
      n.size === "small" && e.sizeSmall,
      n.multiline && e.multiline,
      n.color && e[`color${gn(n.color)}`],
      n.fullWidth && e.fullWidth,
      n.hiddenLabel && e.hiddenLabel,
    ];
  },
  Nv = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.input,
      n.size === "small" && e.inputSizeSmall,
      n.multiline && e.inputMultiline,
      n.type === "search" && e.inputTypeSearch,
      n.startAdornment && e.inputAdornedStart,
      n.endAdornment && e.inputAdornedEnd,
      n.hiddenLabel && e.inputHiddenLabel,
    ];
  },
  S$ = (t) => {
    const {
        classes: e,
        color: n,
        disabled: r,
        error: i,
        endAdornment: s,
        focused: o,
        formControl: a,
        fullWidth: l,
        hiddenLabel: f,
        multiline: d,
        readOnly: h,
        size: p,
        startAdornment: g,
        type: v,
      } = t,
      _ = {
        root: [
          "root",
          `color${gn(n)}`,
          r && "disabled",
          i && "error",
          l && "fullWidth",
          o && "focused",
          a && "formControl",
          p && p !== "medium" && `size${gn(p)}`,
          d && "multiline",
          g && "adornedStart",
          s && "adornedEnd",
          f && "hiddenLabel",
          h && "readOnly",
        ],
        input: [
          "input",
          r && "disabled",
          v === "search" && "inputTypeSearch",
          d && "inputMultiline",
          p === "small" && "inputSizeSmall",
          f && "inputHiddenLabel",
          g && "inputAdornedStart",
          s && "inputAdornedEnd",
          h && "readOnly",
        ],
      };
    return Bn(_, _$, e);
  },
  Ov = Rt("div", { name: "MuiInputBase", slot: "Root", overridesResolver: Iv })(
    pr(({ theme: t }) => ({
      ...t.typography.body1,
      color: (t.vars || t).palette.text.primary,
      lineHeight: "1.4375em",
      boxSizing: "border-box",
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${Ac.disabled}`]: {
        color: (t.vars || t).palette.text.disabled,
        cursor: "default",
      },
      variants: [
        {
          props: ({ ownerState: e }) => e.multiline,
          style: { padding: "4px 0 5px" },
        },
        {
          props: ({ ownerState: e, size: n }) => e.multiline && n === "small",
          style: { paddingTop: 1 },
        },
        { props: ({ ownerState: e }) => e.fullWidth, style: { width: "100%" } },
      ],
    }))
  ),
  Dv = Rt("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: Nv,
  })(
    pr(({ theme: t }) => {
      const e = t.palette.mode === "light",
        n = {
          color: "currentColor",
          ...(t.vars
            ? { opacity: t.vars.opacity.inputPlaceholder }
            : { opacity: e ? 0.42 : 0.5 }),
          transition: t.transitions.create("opacity", {
            duration: t.transitions.duration.shorter,
          }),
        },
        r = { opacity: "0 !important" },
        i = t.vars
          ? { opacity: t.vars.opacity.inputPlaceholder }
          : { opacity: e ? 0.42 : 0.5 };
      return {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        "&::-webkit-input-placeholder": n,
        "&::-moz-placeholder": n,
        "&::-ms-input-placeholder": n,
        "&:focus": { outline: 0 },
        "&:invalid": { boxShadow: "none" },
        "&::-webkit-search-decoration": { WebkitAppearance: "none" },
        [`label[data-shrink=false] + .${Ac.formControl} &`]: {
          "&::-webkit-input-placeholder": r,
          "&::-moz-placeholder": r,
          "&::-ms-input-placeholder": r,
          "&:focus::-webkit-input-placeholder": i,
          "&:focus::-moz-placeholder": i,
          "&:focus::-ms-input-placeholder": i,
        },
        [`&.${Ac.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (t.vars || t).palette.text.disabled,
        },
        variants: [
          {
            props: ({ ownerState: s }) => !s.disableInjectingGlobalStyles,
            style: {
              animationName: "mui-auto-fill-cancel",
              animationDuration: "10ms",
              "&:-webkit-autofill": {
                animationDuration: "5000s",
                animationName: "mui-auto-fill",
              },
            },
          },
          { props: { size: "small" }, style: { paddingTop: 1 } },
          {
            props: ({ ownerState: s }) => s.multiline,
            style: {
              height: "auto",
              resize: "none",
              padding: 0,
              paddingTop: 0,
            },
          },
          { props: { type: "search" }, style: { MozAppearance: "textfield" } },
        ],
      };
    })
  ),
  VR = Wj({
    "@keyframes mui-auto-fill": { from: { display: "block" } },
    "@keyframes mui-auto-fill-cancel": { from: { display: "block" } },
  }),
  tE = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiInputBase" }),
      {
        "aria-describedby": i,
        autoComplete: s,
        autoFocus: o,
        className: a,
        color: l,
        components: f = {},
        componentsProps: d = {},
        defaultValue: h,
        disabled: p,
        disableInjectingGlobalStyles: g,
        endAdornment: v,
        error: _,
        fullWidth: x = !1,
        id: m,
        inputComponent: w = "input",
        inputProps: S = {},
        inputRef: E,
        margin: T,
        maxRows: A,
        minRows: L,
        multiline: N = !1,
        name: C,
        onBlur: I,
        onChange: k,
        onClick: R,
        onFocus: $,
        onKeyDown: D,
        onKeyUp: W,
        placeholder: Y,
        readOnly: Z,
        renderSuffix: B,
        rows: G,
        size: X,
        slotProps: te = {},
        slots: oe = {},
        startAdornment: J,
        type: ae = "text",
        value: Se,
        ...Ie
      } = r,
      Ce = S.value != null ? S.value : Se,
      { current: et } = U.useRef(Ce != null),
      We = U.useRef(),
      Me = U.useCallback((Te) => {}, []),
      Le = $i(We, E, S.ref, Me),
      [H, pe] = U.useState(!1),
      ie = Fc(),
      we = Uc({
        props: r,
        muiFormControl: ie,
        states: [
          "color",
          "disabled",
          "error",
          "hiddenLabel",
          "size",
          "required",
          "filled",
        ],
      });
    (we.focused = ie ? ie.focused : H),
      U.useEffect(() => {
        !ie && p && H && (pe(!1), I && I());
      }, [ie, p, H, I]);
    const xe = ie && ie.onFilled,
      $e = ie && ie.onEmpty,
      Fe = U.useCallback(
        (Te) => {
          Xg(Te) ? xe && xe() : $e && $e();
        },
        [xe, $e]
      );
    Nl(() => {
      et && Fe({ value: Ce });
    }, [Ce, Fe, et]);
    const He = (Te) => {
        $ && $(Te),
          S.onFocus && S.onFocus(Te),
          ie && ie.onFocus ? ie.onFocus(Te) : pe(!0);
      },
      Ze = (Te) => {
        I && I(Te),
          S.onBlur && S.onBlur(Te),
          ie && ie.onBlur ? ie.onBlur(Te) : pe(!1);
      },
      it = (Te, ...at) => {
        if (!et) {
          const wt = Te.target || We.current;
          if (wt == null) throw new Error(Mo(1));
          Fe({ value: wt.value });
        }
        S.onChange && S.onChange(Te, ...at), k && k(Te, ...at);
      };
    U.useEffect(() => {
      Fe(We.current);
    }, []);
    const Tt = (Te) => {
      We.current && Te.currentTarget === Te.target && We.current.focus(),
        R && R(Te);
    };
    let V = w,
      O = S;
    N &&
      V === "input" &&
      (G
        ? (O = { type: void 0, minRows: G, maxRows: G, ...O })
        : (O = { type: void 0, maxRows: A, minRows: L, ...O }),
      (V = y$));
    const se = (Te) => {
      Fe(
        Te.animationName === "mui-auto-fill-cancel"
          ? We.current
          : { value: "x" }
      );
    };
    U.useEffect(() => {
      ie && ie.setAdornedStart(!!J);
    }, [ie, J]);
    const Re = {
        ...r,
        color: we.color || "primary",
        disabled: we.disabled,
        endAdornment: v,
        error: we.error,
        focused: we.focused,
        formControl: ie,
        fullWidth: x,
        hiddenLabel: we.hiddenLabel,
        multiline: N,
        size: we.size,
        startAdornment: J,
        type: ae,
      },
      Ee = S$(Re),
      Ae = oe.root || f.Root || Ov,
      Ye = te.root || d.root || {},
      Pe = oe.input || f.Input || Dv;
    return (
      (O = { ...O, ...(te.input ?? d.input) }),
      Q.jsxs(U.Fragment, {
        children: [
          !g && typeof VR == "function" && (HR || (HR = Q.jsx(VR, {}))),
          Q.jsxs(Ae, {
            ...Ye,
            ref: n,
            onClick: Tt,
            ...Ie,
            ...(!$g(Ae) && { ownerState: { ...Re, ...Ye.ownerState } }),
            className: In(
              Ee.root,
              Ye.className,
              a,
              Z && "MuiInputBase-readOnly"
            ),
            children: [
              J,
              Q.jsx(eE.Provider, {
                value: null,
                children: Q.jsx(Pe, {
                  "aria-invalid": we.error,
                  "aria-describedby": i,
                  autoComplete: s,
                  autoFocus: o,
                  defaultValue: h,
                  disabled: we.disabled,
                  id: m,
                  onAnimationStart: se,
                  name: C,
                  placeholder: Y,
                  readOnly: Z,
                  required: we.required,
                  rows: G,
                  value: Ce,
                  onKeyDown: D,
                  onKeyUp: W,
                  type: ae,
                  ...O,
                  ...(!$g(Pe) && {
                    as: V,
                    ownerState: { ...Re, ...O.ownerState },
                  }),
                  ref: Le,
                  className: In(
                    Ee.input,
                    O.className,
                    Z && "MuiInputBase-readOnly"
                  ),
                  onBlur: Ze,
                  onChange: it,
                  onFocus: He,
                }),
              }),
              v,
              B ? B({ ...we, startAdornment: J }) : null,
            ],
          }),
        ],
      })
    );
  });
function w$(t) {
  return zn("MuiInput", t);
}
const Pf = { ...Ac, ...Yn("MuiInput", ["root", "underline", "input"]) };
function M$(t) {
  return zn("MuiOutlinedInput", t);
}
const bs = {
  ...Ac,
  ...Yn("MuiOutlinedInput", ["root", "notchedOutline", "input"]),
};
function E$(t) {
  return zn("MuiFilledInput", t);
}
const qa = {
    ...Ac,
    ...Yn("MuiFilledInput", [
      "root",
      "underline",
      "input",
      "adornedStart",
      "adornedEnd",
      "sizeSmall",
      "multiline",
      "hiddenLabel",
    ]),
  },
  b$ = rO(Q.jsx("path", { d: "M7 10l5 5 5-5z" })),
  T$ = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  A$ = U.forwardRef(function (e, n) {
    const r = JM(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        addEndListener: s,
        appear: o = !0,
        children: a,
        easing: l,
        in: f,
        onEnter: d,
        onEntered: h,
        onEntering: p,
        onExit: g,
        onExited: v,
        onExiting: _,
        style: x,
        timeout: m = i,
        TransitionComponent: w = Ws,
        ...S
      } = e,
      E = U.useRef(null),
      T = $i(E, _h(a), n),
      A = (D) => (W) => {
        if (D) {
          const Y = E.current;
          W === void 0 ? D(Y) : D(Y, W);
        }
      },
      L = A(p),
      N = A((D, W) => {
        oO(D);
        const Y = jg({ style: x, timeout: m, easing: l }, { mode: "enter" });
        (D.style.webkitTransition = r.transitions.create("opacity", Y)),
          (D.style.transition = r.transitions.create("opacity", Y)),
          d && d(D, W);
      }),
      C = A(h),
      I = A(_),
      k = A((D) => {
        const W = jg({ style: x, timeout: m, easing: l }, { mode: "exit" });
        (D.style.webkitTransition = r.transitions.create("opacity", W)),
          (D.style.transition = r.transitions.create("opacity", W)),
          g && g(D);
      }),
      R = A(v),
      $ = (D) => {
        s && s(E.current, D);
      };
    return Q.jsx(w, {
      appear: o,
      in: f,
      nodeRef: E,
      onEnter: N,
      onEntered: C,
      onEntering: L,
      onExit: k,
      onExited: R,
      onExiting: I,
      addEndListener: $,
      timeout: m,
      ...S,
      children: (D, { ownerState: W, ...Y }) =>
        U.cloneElement(a, {
          style: {
            opacity: 0,
            visibility: D === "exited" && !f ? "hidden" : void 0,
            ...T$[D],
            ...x,
            ...a.props.style,
          },
          ref: T,
          ...Y,
        }),
    });
  });
function C$(t) {
  return zn("MuiBackdrop", t);
}
Yn("MuiBackdrop", ["root", "invisible"]);
const R$ = (t) => {
    const { classes: e, invisible: n } = t;
    return Bn({ root: ["root", n && "invisible"] }, C$, e);
  },
  P$ = Rt("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, n.invisible && e.invisible];
    },
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [
      { props: { invisible: !0 }, style: { backgroundColor: "transparent" } },
    ],
  }),
  L$ = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiBackdrop" }),
      {
        children: i,
        className: s,
        component: o = "div",
        invisible: a = !1,
        open: l,
        components: f = {},
        componentsProps: d = {},
        slotProps: h = {},
        slots: p = {},
        TransitionComponent: g,
        transitionDuration: v,
        ..._
      } = r,
      x = { ...r, component: o, invisible: a },
      m = R$(x),
      w = { transition: g, root: f.Root, ...p },
      S = { ...d, ...h },
      E = { component: o, slots: w, slotProps: S },
      [T, A] = Ar("root", {
        elementType: P$,
        externalForwardedProps: E,
        className: In(m.root, s),
        ownerState: x,
      }),
      [L, N] = Ar("transition", {
        elementType: A$,
        externalForwardedProps: E,
        ownerState: x,
      });
    return Q.jsx(L, {
      in: l,
      timeout: v,
      ..._,
      ...N,
      children: Q.jsx(T, {
        "aria-hidden": !0,
        ...A,
        classes: m,
        ref: n,
        children: i,
      }),
    });
  });
function fO(t = window) {
  const e = t.document.documentElement.clientWidth;
  return t.innerWidth - e;
}
function I$(t) {
  const e = fs(t);
  return e.body === t
    ? bo(t).innerWidth > e.documentElement.clientWidth
    : t.scrollHeight > t.clientHeight;
}
function sd(t, e) {
  e ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden");
}
function WR(t) {
  return parseInt(bo(t).getComputedStyle(t).paddingRight, 10) || 0;
}
function N$(t) {
  const n = [
      "TEMPLATE",
      "SCRIPT",
      "STYLE",
      "LINK",
      "MAP",
      "META",
      "NOSCRIPT",
      "PICTURE",
      "COL",
      "COLGROUP",
      "PARAM",
      "SLOT",
      "SOURCE",
      "TRACK",
    ].includes(t.tagName),
    r = t.tagName === "INPUT" && t.getAttribute("type") === "hidden";
  return n || r;
}
function GR(t, e, n, r, i) {
  const s = [e, n, ...r];
  [].forEach.call(t.children, (o) => {
    const a = !s.includes(o),
      l = !N$(o);
    a && l && sd(o, i);
  });
}
function __(t, e) {
  let n = -1;
  return t.some((r, i) => (e(r) ? ((n = i), !0) : !1)), n;
}
function O$(t, e) {
  const n = [],
    r = t.container;
  if (!e.disableScrollLock) {
    if (I$(r)) {
      const o = fO(bo(r));
      n.push({ value: r.style.paddingRight, property: "padding-right", el: r }),
        (r.style.paddingRight = `${WR(r) + o}px`);
      const a = fs(r).querySelectorAll(".mui-fixed");
      [].forEach.call(a, (l) => {
        n.push({
          value: l.style.paddingRight,
          property: "padding-right",
          el: l,
        }),
          (l.style.paddingRight = `${WR(l) + o}px`);
      });
    }
    let s;
    if (r.parentNode instanceof DocumentFragment) s = fs(r).body;
    else {
      const o = r.parentElement,
        a = bo(r);
      s =
        (o == null ? void 0 : o.nodeName) === "HTML" &&
        a.getComputedStyle(o).overflowY === "scroll"
          ? o
          : r;
    }
    n.push(
      { value: s.style.overflow, property: "overflow", el: s },
      { value: s.style.overflowX, property: "overflow-x", el: s },
      { value: s.style.overflowY, property: "overflow-y", el: s }
    ),
      (s.style.overflow = "hidden");
  }
  return () => {
    n.forEach(({ value: s, el: o, property: a }) => {
      s ? o.style.setProperty(a, s) : o.style.removeProperty(a);
    });
  };
}
function D$(t) {
  const e = [];
  return (
    [].forEach.call(t.children, (n) => {
      n.getAttribute("aria-hidden") === "true" && e.push(n);
    }),
    e
  );
}
class k$ {
  constructor() {
    (this.modals = []), (this.containers = []);
  }
  add(e, n) {
    let r = this.modals.indexOf(e);
    if (r !== -1) return r;
    (r = this.modals.length),
      this.modals.push(e),
      e.modalRef && sd(e.modalRef, !1);
    const i = D$(n);
    GR(n, e.mount, e.modalRef, i, !0);
    const s = __(this.containers, (o) => o.container === n);
    return s !== -1
      ? (this.containers[s].modals.push(e), r)
      : (this.containers.push({
          modals: [e],
          container: n,
          restore: null,
          hiddenSiblings: i,
        }),
        r);
  }
  mount(e, n) {
    const r = __(this.containers, (s) => s.modals.includes(e)),
      i = this.containers[r];
    i.restore || (i.restore = O$(i, n));
  }
  remove(e, n = !0) {
    const r = this.modals.indexOf(e);
    if (r === -1) return r;
    const i = __(this.containers, (o) => o.modals.includes(e)),
      s = this.containers[i];
    if (
      (s.modals.splice(s.modals.indexOf(e), 1),
      this.modals.splice(r, 1),
      s.modals.length === 0)
    )
      s.restore && s.restore(),
        e.modalRef && sd(e.modalRef, n),
        GR(s.container, e.mount, e.modalRef, s.hiddenSiblings, !1),
        this.containers.splice(i, 1);
    else {
      const o = s.modals[s.modals.length - 1];
      o.modalRef && sd(o.modalRef, !1);
    }
    return r;
  }
  isTopModal(e) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === e;
  }
}
const U$ = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])',
].join(",");
function F$(t) {
  const e = parseInt(t.getAttribute("tabindex") || "", 10);
  return Number.isNaN(e)
    ? t.contentEditable === "true" ||
      ((t.nodeName === "AUDIO" ||
        t.nodeName === "VIDEO" ||
        t.nodeName === "DETAILS") &&
        t.getAttribute("tabindex") === null)
      ? 0
      : t.tabIndex
    : e;
}
function z$(t) {
  if (t.tagName !== "INPUT" || t.type !== "radio" || !t.name) return !1;
  const e = (r) => t.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = e(`[name="${t.name}"]:checked`);
  return n || (n = e(`[name="${t.name}"]`)), n !== t;
}
function B$(t) {
  return !(
    t.disabled ||
    (t.tagName === "INPUT" && t.type === "hidden") ||
    z$(t)
  );
}
function H$(t) {
  const e = [],
    n = [];
  return (
    Array.from(t.querySelectorAll(U$)).forEach((r, i) => {
      const s = F$(r);
      s === -1 ||
        !B$(r) ||
        (s === 0
          ? e.push(r)
          : n.push({ documentOrder: i, tabIndex: s, node: r }));
    }),
    n
      .sort((r, i) =>
        r.tabIndex === i.tabIndex
          ? r.documentOrder - i.documentOrder
          : r.tabIndex - i.tabIndex
      )
      .map((r) => r.node)
      .concat(e)
  );
}
function V$() {
  return !0;
}
function W$(t) {
  const {
      children: e,
      disableAutoFocus: n = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: i = !1,
      getTabbable: s = H$,
      isEnabled: o = V$,
      open: a,
    } = t,
    l = U.useRef(!1),
    f = U.useRef(null),
    d = U.useRef(null),
    h = U.useRef(null),
    p = U.useRef(null),
    g = U.useRef(!1),
    v = U.useRef(null),
    _ = $i(_h(e), v),
    x = U.useRef(null);
  U.useEffect(() => {
    !a || !v.current || (g.current = !n);
  }, [n, a]),
    U.useEffect(() => {
      if (!a || !v.current) return;
      const S = fs(v.current);
      return (
        v.current.contains(S.activeElement) ||
          (v.current.hasAttribute("tabIndex") ||
            v.current.setAttribute("tabIndex", "-1"),
          g.current && v.current.focus()),
        () => {
          i ||
            (h.current &&
              h.current.focus &&
              ((l.current = !0), h.current.focus()),
            (h.current = null));
        }
      );
    }, [a]),
    U.useEffect(() => {
      if (!a || !v.current) return;
      const S = fs(v.current),
        E = (L) => {
          (x.current = L),
            !(r || !o() || L.key !== "Tab") &&
              S.activeElement === v.current &&
              L.shiftKey &&
              ((l.current = !0), d.current && d.current.focus());
        },
        T = () => {
          var C, I;
          const L = v.current;
          if (L === null) return;
          if (!S.hasFocus() || !o() || l.current) {
            l.current = !1;
            return;
          }
          if (
            L.contains(S.activeElement) ||
            (r &&
              S.activeElement !== f.current &&
              S.activeElement !== d.current)
          )
            return;
          if (S.activeElement !== p.current) p.current = null;
          else if (p.current !== null) return;
          if (!g.current) return;
          let N = [];
          if (
            ((S.activeElement === f.current || S.activeElement === d.current) &&
              (N = s(v.current)),
            N.length > 0)
          ) {
            const k = !!(
                (C = x.current) != null &&
                C.shiftKey &&
                ((I = x.current) == null ? void 0 : I.key) === "Tab"
              ),
              R = N[0],
              $ = N[N.length - 1];
            typeof R != "string" &&
              typeof $ != "string" &&
              (k ? $.focus() : R.focus());
          } else L.focus();
        };
      S.addEventListener("focusin", T), S.addEventListener("keydown", E, !0);
      const A = setInterval(() => {
        S.activeElement && S.activeElement.tagName === "BODY" && T();
      }, 50);
      return () => {
        clearInterval(A),
          S.removeEventListener("focusin", T),
          S.removeEventListener("keydown", E, !0);
      };
    }, [n, r, i, o, a, s]);
  const m = (S) => {
      h.current === null && (h.current = S.relatedTarget),
        (g.current = !0),
        (p.current = S.target);
      const E = e.props.onFocus;
      E && E(S);
    },
    w = (S) => {
      h.current === null && (h.current = S.relatedTarget), (g.current = !0);
    };
  return Q.jsxs(U.Fragment, {
    children: [
      Q.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: w,
        ref: f,
        "data-testid": "sentinelStart",
      }),
      U.cloneElement(e, { ref: _, onFocus: m }),
      Q.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: w,
        ref: d,
        "data-testid": "sentinelEnd",
      }),
    ],
  });
}
function G$(t) {
  return typeof t == "function" ? t() : t;
}
function j$(t) {
  return t ? t.props.hasOwnProperty("in") : !1;
}
const jR = () => {},
  Nm = new k$();
function $$(t) {
  const {
      container: e,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: r = !1,
      closeAfterTransition: i = !1,
      onTransitionEnter: s,
      onTransitionExited: o,
      children: a,
      onClose: l,
      open: f,
      rootRef: d,
    } = t,
    h = U.useRef({}),
    p = U.useRef(null),
    g = U.useRef(null),
    v = $i(g, d),
    [_, x] = U.useState(!f),
    m = j$(a);
  let w = !0;
  (t["aria-hidden"] === "false" || t["aria-hidden"] === !1) && (w = !1);
  const S = () => fs(p.current),
    E = () => (
      (h.current.modalRef = g.current), (h.current.mount = p.current), h.current
    ),
    T = () => {
      Nm.mount(E(), { disableScrollLock: r }),
        g.current && (g.current.scrollTop = 0);
    },
    A = C1(() => {
      const W = G$(e) || S().body;
      Nm.add(E(), W), g.current && T();
    }),
    L = () => Nm.isTopModal(E()),
    N = C1((W) => {
      (p.current = W), W && (f && L() ? T() : g.current && sd(g.current, w));
    }),
    C = U.useCallback(() => {
      Nm.remove(E(), w);
    }, [w]);
  U.useEffect(
    () => () => {
      C();
    },
    [C]
  ),
    U.useEffect(() => {
      f ? A() : (!m || !i) && C();
    }, [f, C, m, i, A]);
  const I = (W) => (Y) => {
      var Z;
      (Z = W.onKeyDown) == null || Z.call(W, Y),
        !(Y.key !== "Escape" || Y.which === 229 || !L()) &&
          (n || (Y.stopPropagation(), l && l(Y, "escapeKeyDown")));
    },
    k = (W) => (Y) => {
      var Z;
      (Z = W.onClick) == null || Z.call(W, Y),
        Y.target === Y.currentTarget && l && l(Y, "backdropClick");
    };
  return {
    getRootProps: (W = {}) => {
      const Y = uO(t);
      delete Y.onTransitionEnter, delete Y.onTransitionExited;
      const Z = { ...Y, ...W };
      return { role: "presentation", ...Z, onKeyDown: I(Z), ref: v };
    },
    getBackdropProps: (W = {}) => {
      const Y = W;
      return { "aria-hidden": !0, ...Y, onClick: k(Y), open: f };
    },
    getTransitionProps: () => {
      const W = () => {
          x(!1), s && s();
        },
        Y = () => {
          x(!0), o && o(), i && C();
        };
      return {
        onEnter: IR(W, (a == null ? void 0 : a.props.onEnter) ?? jR),
        onExited: IR(Y, (a == null ? void 0 : a.props.onExited) ?? jR),
      };
    },
    rootRef: v,
    portalRef: N,
    isTopModal: L,
    exited: _,
    hasTransition: m,
  };
}
function X$(t) {
  return zn("MuiModal", t);
}
Yn("MuiModal", ["root", "hidden", "backdrop"]);
const Y$ = (t) => {
    const { open: e, exited: n, classes: r } = t;
    return Bn(
      { root: ["root", !e && n && "hidden"], backdrop: ["backdrop"] },
      X$,
      r
    );
  },
  q$ = Rt("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, !n.open && n.exited && e.hidden];
    },
  })(
    pr(({ theme: t }) => ({
      position: "fixed",
      zIndex: (t.vars || t).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      variants: [
        {
          props: ({ ownerState: e }) => !e.open && e.exited,
          style: { visibility: "hidden" },
        },
      ],
    }))
  ),
  K$ = Rt(L$, { name: "MuiModal", slot: "Backdrop" })({ zIndex: -1 }),
  Z$ = U.forwardRef(function (e, n) {
    const r = ir({ name: "MuiModal", props: e }),
      {
        BackdropComponent: i = K$,
        BackdropProps: s,
        classes: o,
        className: a,
        closeAfterTransition: l = !1,
        children: f,
        container: d,
        component: h,
        components: p = {},
        componentsProps: g = {},
        disableAutoFocus: v = !1,
        disableEnforceFocus: _ = !1,
        disableEscapeKeyDown: x = !1,
        disablePortal: m = !1,
        disableRestoreFocus: w = !1,
        disableScrollLock: S = !1,
        hideBackdrop: E = !1,
        keepMounted: T = !1,
        onClose: A,
        onTransitionEnter: L,
        onTransitionExited: N,
        open: C,
        slotProps: I = {},
        slots: k = {},
        theme: R,
        ...$
      } = r,
      D = {
        ...r,
        closeAfterTransition: l,
        disableAutoFocus: v,
        disableEnforceFocus: _,
        disableEscapeKeyDown: x,
        disablePortal: m,
        disableRestoreFocus: w,
        disableScrollLock: S,
        hideBackdrop: E,
        keepMounted: T,
      },
      {
        getRootProps: W,
        getBackdropProps: Y,
        getTransitionProps: Z,
        portalRef: B,
        isTopModal: G,
        exited: X,
        hasTransition: te,
      } = $$({ ...D, rootRef: n }),
      oe = { ...D, exited: X },
      J = Y$(oe),
      ae = {};
    if ((f.props.tabIndex === void 0 && (ae.tabIndex = "-1"), te)) {
      const { onEnter: Me, onExited: Le } = Z();
      (ae.onEnter = Me), (ae.onExited = Le);
    }
    const Se = {
        slots: { root: p.Root, backdrop: p.Backdrop, ...k },
        slotProps: { ...g, ...I },
      },
      [Ie, Ce] = Ar("root", {
        ref: n,
        elementType: q$,
        externalForwardedProps: { ...Se, ...$, component: h },
        getSlotProps: W,
        ownerState: oe,
        className: In(
          a,
          J == null ? void 0 : J.root,
          !oe.open && oe.exited && (J == null ? void 0 : J.hidden)
        ),
      }),
      [et, We] = Ar("backdrop", {
        ref: s == null ? void 0 : s.ref,
        elementType: i,
        externalForwardedProps: Se,
        shouldForwardComponentProp: !0,
        additionalProps: s,
        getSlotProps: (Me) =>
          Y({
            ...Me,
            onClick: (Le) => {
              Me != null && Me.onClick && Me.onClick(Le);
            },
          }),
        className: In(
          s == null ? void 0 : s.className,
          J == null ? void 0 : J.backdrop
        ),
        ownerState: oe,
      });
    return !T && !C && (!te || X)
      ? null
      : Q.jsx(m$, {
          ref: B,
          container: d,
          disablePortal: m,
          children: Q.jsxs(Ie, {
            ...Ce,
            children: [
              !E && i ? Q.jsx(et, { ...We }) : null,
              Q.jsx(W$, {
                disableEnforceFocus: _,
                disableAutoFocus: v,
                disableRestoreFocus: w,
                isEnabled: G,
                open: C,
                children: U.cloneElement(f, ae),
              }),
            ],
          }),
        });
  }),
  J$ = (t) => {
    const {
        classes: e,
        disableUnderline: n,
        startAdornment: r,
        endAdornment: i,
        size: s,
        hiddenLabel: o,
        multiline: a,
      } = t,
      l = {
        root: [
          "root",
          !n && "underline",
          r && "adornedStart",
          i && "adornedEnd",
          s === "small" && `size${gn(s)}`,
          o && "hiddenLabel",
          a && "multiline",
        ],
        input: ["input"],
      },
      f = Bn(l, E$, e);
    return { ...e, ...f };
  },
  Q$ = Rt(Ov, {
    shouldForwardProp: (t) => Vs(t) || t === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [...Iv(t, e), !n.disableUnderline && e.underline];
    },
  })(
    pr(({ theme: t }) => {
      const e = t.palette.mode === "light",
        n = e ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
        r = e ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
        i = e ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
        s = e ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return {
        position: "relative",
        backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
        borderTopLeftRadius: (t.vars || t).shape.borderRadius,
        borderTopRightRadius: (t.vars || t).shape.borderRadius,
        transition: t.transitions.create("background-color", {
          duration: t.transitions.duration.shorter,
          easing: t.transitions.easing.easeOut,
        }),
        "&:hover": {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.hoverBg : i,
          "@media (hover: none)": {
            backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
          },
        },
        [`&.${qa.focused}`]: {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
        },
        [`&.${qa.disabled}`]: {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.disabledBg : s,
        },
        variants: [
          {
            props: ({ ownerState: o }) => !o.disableUnderline,
            style: {
              "&::after": {
                left: 0,
                bottom: 0,
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: t.transitions.create("transform", {
                  duration: t.transitions.duration.shorter,
                  easing: t.transitions.easing.easeOut,
                }),
                pointerEvents: "none",
              },
              [`&.${qa.focused}:after`]: {
                transform: "scaleX(1) translateX(0)",
              },
              [`&.${qa.error}`]: {
                "&::before, &::after": {
                  borderBottomColor: (t.vars || t).palette.error.main,
                },
              },
              "&::before": {
                borderBottom: `1px solid ${
                  t.vars
                    ? t.alpha(
                        t.vars.palette.common.onBackground,
                        t.vars.opacity.inputUnderline
                      )
                    : n
                }`,
                left: 0,
                bottom: 0,
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: t.transitions.create("border-bottom-color", {
                  duration: t.transitions.duration.shorter,
                }),
                pointerEvents: "none",
              },
              [`&:hover:not(.${qa.disabled}, .${qa.error}):before`]: {
                borderBottom: `1px solid ${(t.vars || t).palette.text.primary}`,
              },
              [`&.${qa.disabled}:before`]: { borderBottomStyle: "dotted" },
            },
          },
          ...Object.entries(t.palette)
            .filter(xh())
            .map(([o]) => {
              var a;
              return {
                props: { disableUnderline: !1, color: o },
                style: {
                  "&::after": {
                    borderBottom: `2px solid ${
                      (a = (t.vars || t).palette[o]) == null ? void 0 : a.main
                    }`,
                  },
                },
              };
            }),
          {
            props: ({ ownerState: o }) => o.startAdornment,
            style: { paddingLeft: 12 },
          },
          {
            props: ({ ownerState: o }) => o.endAdornment,
            style: { paddingRight: 12 },
          },
          {
            props: ({ ownerState: o }) => o.multiline,
            style: { padding: "25px 12px 8px" },
          },
          {
            props: ({ ownerState: o, size: a }) => o.multiline && a === "small",
            style: { paddingTop: 21, paddingBottom: 4 },
          },
          {
            props: ({ ownerState: o }) => o.multiline && o.hiddenLabel,
            style: { paddingTop: 16, paddingBottom: 17 },
          },
          {
            props: ({ ownerState: o }) =>
              o.multiline && o.hiddenLabel && o.size === "small",
            style: { paddingTop: 8, paddingBottom: 9 },
          },
        ],
      };
    })
  ),
  eX = Rt(Dv, { name: "MuiFilledInput", slot: "Input", overridesResolver: Nv })(
    pr(({ theme: t }) => ({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12,
      ...(!t.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            t.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: t.palette.mode === "light" ? null : "#fff",
          caretColor: t.palette.mode === "light" ? null : "#fff",
          borderTopLeftRadius: "inherit",
          borderTopRightRadius: "inherit",
        },
      }),
      ...(t.vars && {
        "&:-webkit-autofill": {
          borderTopLeftRadius: "inherit",
          borderTopRightRadius: "inherit",
        },
        [t.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      }),
      variants: [
        {
          props: { size: "small" },
          style: { paddingTop: 21, paddingBottom: 4 },
        },
        {
          props: ({ ownerState: e }) => e.hiddenLabel,
          style: { paddingTop: 16, paddingBottom: 17 },
        },
        {
          props: ({ ownerState: e }) => e.startAdornment,
          style: { paddingLeft: 0 },
        },
        {
          props: ({ ownerState: e }) => e.endAdornment,
          style: { paddingRight: 0 },
        },
        {
          props: ({ ownerState: e }) => e.hiddenLabel && e.size === "small",
          style: { paddingTop: 8, paddingBottom: 9 },
        },
        {
          props: ({ ownerState: e }) => e.multiline,
          style: {
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
          },
        },
      ],
    }))
  ),
  nE = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiFilledInput" }),
      {
        disableUnderline: i = !1,
        components: s = {},
        componentsProps: o,
        fullWidth: a = !1,
        hiddenLabel: l,
        inputComponent: f = "input",
        multiline: d = !1,
        slotProps: h,
        slots: p = {},
        type: g = "text",
        ...v
      } = r,
      _ = {
        ...r,
        disableUnderline: i,
        fullWidth: a,
        inputComponent: f,
        multiline: d,
        type: g,
      },
      x = J$(r),
      m = { root: { ownerState: _ }, input: { ownerState: _ } },
      w = h ?? o ? Lr(m, h ?? o) : m,
      S = p.root ?? s.Root ?? Q$,
      E = p.input ?? s.Input ?? eX;
    return Q.jsx(tE, {
      slots: { root: S, input: E },
      slotProps: w,
      fullWidth: a,
      inputComponent: f,
      multiline: d,
      ref: n,
      type: g,
      ...v,
      classes: x,
    });
  });
nE.muiName = "Input";
function tX(t) {
  return zn("MuiFormControl", t);
}
Yn("MuiFormControl", [
  "root",
  "marginNone",
  "marginNormal",
  "marginDense",
  "fullWidth",
  "disabled",
]);
const nX = (t) => {
    const { classes: e, margin: n, fullWidth: r } = t,
      i = {
        root: ["root", n !== "none" && `margin${gn(n)}`, r && "fullWidth"],
      };
    return Bn(i, tX, e);
  },
  rX = Rt("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, e[`margin${gn(n.margin)}`], n.fullWidth && e.fullWidth];
    },
  })({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    variants: [
      {
        props: { margin: "normal" },
        style: { marginTop: 16, marginBottom: 8 },
      },
      { props: { margin: "dense" }, style: { marginTop: 8, marginBottom: 4 } },
      { props: { fullWidth: !0 }, style: { width: "100%" } },
    ],
  }),
  iX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiFormControl" }),
      {
        children: i,
        className: s,
        color: o = "primary",
        component: a = "div",
        disabled: l = !1,
        error: f = !1,
        focused: d,
        fullWidth: h = !1,
        hiddenLabel: p = !1,
        margin: g = "none",
        required: v = !1,
        size: _ = "medium",
        variant: x = "outlined",
        ...m
      } = r,
      w = {
        ...r,
        color: o,
        component: a,
        disabled: l,
        error: f,
        fullWidth: h,
        hiddenLabel: p,
        margin: g,
        required: v,
        size: _,
        variant: x,
      },
      S = nX(w),
      [E, T] = U.useState(() => {
        let W = !1;
        return (
          i &&
            U.Children.forEach(i, (Y) => {
              if (!y_(Y, ["Input", "Select"])) return;
              const Z = y_(Y, ["Select"]) ? Y.props.input : Y;
              Z && x$(Z.props) && (W = !0);
            }),
          W
        );
      }),
      [A, L] = U.useState(() => {
        let W = !1;
        return (
          i &&
            U.Children.forEach(i, (Y) => {
              y_(Y, ["Input", "Select"]) &&
                (Xg(Y.props, !0) || Xg(Y.props.inputProps, !0)) &&
                (W = !0);
            }),
          W
        );
      }),
      [N, C] = U.useState(!1);
    l && N && C(!1);
    const I = d !== void 0 && !l ? d : N;
    let k;
    U.useRef(!1);
    const R = U.useCallback(() => {
        L(!0);
      }, []),
      $ = U.useCallback(() => {
        L(!1);
      }, []),
      D = U.useMemo(
        () => ({
          adornedStart: E,
          setAdornedStart: T,
          color: o,
          disabled: l,
          error: f,
          filled: A,
          focused: I,
          fullWidth: h,
          hiddenLabel: p,
          size: _,
          onBlur: () => {
            C(!1);
          },
          onFocus: () => {
            C(!0);
          },
          onEmpty: $,
          onFilled: R,
          registerEffect: k,
          required: v,
          variant: x,
        }),
        [E, o, l, f, A, I, h, p, k, $, R, v, _, x]
      );
    return Q.jsx(eE.Provider, {
      value: D,
      children: Q.jsx(rX, {
        as: a,
        ownerState: w,
        className: In(S.root, s),
        ref: n,
        ...m,
        children: i,
      }),
    });
  });
function sX(t) {
  return zn("MuiFormHelperText", t);
}
const $R = Yn("MuiFormHelperText", [
  "root",
  "error",
  "disabled",
  "sizeSmall",
  "sizeMedium",
  "contained",
  "focused",
  "filled",
  "required",
]);
var XR;
const oX = (t) => {
    const {
        classes: e,
        contained: n,
        size: r,
        disabled: i,
        error: s,
        filled: o,
        focused: a,
        required: l,
      } = t,
      f = {
        root: [
          "root",
          i && "disabled",
          s && "error",
          r && `size${gn(r)}`,
          n && "contained",
          a && "focused",
          o && "filled",
          l && "required",
        ],
      };
    return Bn(f, sX, e);
  },
  aX = Rt("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.size && e[`size${gn(n.size)}`],
        n.contained && e.contained,
        n.filled && e.filled,
      ];
    },
  })(
    pr(({ theme: t }) => ({
      color: (t.vars || t).palette.text.secondary,
      ...t.typography.caption,
      textAlign: "left",
      marginTop: 3,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0,
      [`&.${$R.disabled}`]: { color: (t.vars || t).palette.text.disabled },
      [`&.${$R.error}`]: { color: (t.vars || t).palette.error.main },
      variants: [
        { props: { size: "small" }, style: { marginTop: 4 } },
        {
          props: ({ ownerState: e }) => e.contained,
          style: { marginLeft: 14, marginRight: 14 },
        },
      ],
    }))
  ),
  lX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiFormHelperText" }),
      {
        children: i,
        className: s,
        component: o = "p",
        disabled: a,
        error: l,
        filled: f,
        focused: d,
        margin: h,
        required: p,
        variant: g,
        ...v
      } = r,
      _ = Fc(),
      x = Uc({
        props: r,
        muiFormControl: _,
        states: [
          "variant",
          "size",
          "disabled",
          "error",
          "filled",
          "focused",
          "required",
        ],
      }),
      m = {
        ...r,
        component: o,
        contained: x.variant === "filled" || x.variant === "outlined",
        variant: x.variant,
        size: x.size,
        disabled: x.disabled,
        error: x.error,
        filled: x.filled,
        focused: x.focused,
        required: x.required,
      };
    delete m.ownerState;
    const w = oX(m);
    return Q.jsx(aX, {
      as: o,
      className: In(w.root, s),
      ref: n,
      ...v,
      ownerState: m,
      children:
        i === " "
          ? XR ||
            (XR = Q.jsx("span", {
              className: "notranslate",
              "aria-hidden": !0,
              children: "​",
            }))
          : i,
    });
  });
function uX(t) {
  return zn("MuiFormLabel", t);
}
const od = Yn("MuiFormLabel", [
    "root",
    "colorSecondary",
    "focused",
    "disabled",
    "error",
    "filled",
    "required",
    "asterisk",
  ]),
  cX = (t) => {
    const {
        classes: e,
        color: n,
        focused: r,
        disabled: i,
        error: s,
        filled: o,
        required: a,
      } = t,
      l = {
        root: [
          "root",
          `color${gn(n)}`,
          i && "disabled",
          s && "error",
          o && "filled",
          r && "focused",
          a && "required",
        ],
        asterisk: ["asterisk", s && "error"],
      };
    return Bn(l, uX, e);
  },
  fX = Rt("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.color === "secondary" && e.colorSecondary,
        n.filled && e.filled,
      ];
    },
  })(
    pr(({ theme: t }) => ({
      color: (t.vars || t).palette.text.secondary,
      ...t.typography.body1,
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      variants: [
        ...Object.entries(t.palette)
          .filter(xh())
          .map(([e]) => ({
            props: { color: e },
            style: {
              [`&.${od.focused}`]: { color: (t.vars || t).palette[e].main },
            },
          })),
        {
          props: {},
          style: {
            [`&.${od.disabled}`]: {
              color: (t.vars || t).palette.text.disabled,
            },
            [`&.${od.error}`]: { color: (t.vars || t).palette.error.main },
          },
        },
      ],
    }))
  ),
  dX = Rt("span", { name: "MuiFormLabel", slot: "Asterisk" })(
    pr(({ theme: t }) => ({
      [`&.${od.error}`]: { color: (t.vars || t).palette.error.main },
    }))
  ),
  hX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiFormLabel" }),
      {
        children: i,
        className: s,
        color: o,
        component: a = "label",
        disabled: l,
        error: f,
        filled: d,
        focused: h,
        required: p,
        ...g
      } = r,
      v = Fc(),
      _ = Uc({
        props: r,
        muiFormControl: v,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
      }),
      x = {
        ...r,
        color: _.color || "primary",
        component: a,
        disabled: _.disabled,
        error: _.error,
        filled: _.filled,
        focused: _.focused,
        required: _.required,
      },
      m = cX(x);
    return Q.jsxs(fX, {
      as: a,
      ownerState: x,
      className: In(m.root, s),
      ref: n,
      ...g,
      children: [
        i,
        _.required &&
          Q.jsxs(dX, {
            ownerState: x,
            "aria-hidden": !0,
            className: m.asterisk,
            children: [" ", "*"],
          }),
      ],
    });
  });
function L1(t) {
  return `scale(${t}, ${t ** 2})`;
}
const pX = {
    entering: { opacity: 1, transform: L1(1) },
    entered: { opacity: 1, transform: "none" },
  },
  S_ =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  I1 = U.forwardRef(function (e, n) {
    const {
        addEndListener: r,
        appear: i = !0,
        children: s,
        easing: o,
        in: a,
        onEnter: l,
        onEntered: f,
        onEntering: d,
        onExit: h,
        onExited: p,
        onExiting: g,
        style: v,
        timeout: _ = "auto",
        TransitionComponent: x = Ws,
        ...m
      } = e,
      w = t$(),
      S = U.useRef(),
      E = JM(),
      T = U.useRef(null),
      A = $i(T, _h(s), n),
      L = (W) => (Y) => {
        if (W) {
          const Z = T.current;
          Y === void 0 ? W(Z) : W(Z, Y);
        }
      },
      N = L(d),
      C = L((W, Y) => {
        oO(W);
        const {
          duration: Z,
          delay: B,
          easing: G,
        } = jg({ style: v, timeout: _, easing: o }, { mode: "enter" });
        let X;
        _ === "auto"
          ? ((X = E.transitions.getAutoHeightDuration(W.clientHeight)),
            (S.current = X))
          : (X = Z),
          (W.style.transition = [
            E.transitions.create("opacity", { duration: X, delay: B }),
            E.transitions.create("transform", {
              duration: S_ ? X : X * 0.666,
              delay: B,
              easing: G,
            }),
          ].join(",")),
          l && l(W, Y);
      }),
      I = L(f),
      k = L(g),
      R = L((W) => {
        const {
          duration: Y,
          delay: Z,
          easing: B,
        } = jg({ style: v, timeout: _, easing: o }, { mode: "exit" });
        let G;
        _ === "auto"
          ? ((G = E.transitions.getAutoHeightDuration(W.clientHeight)),
            (S.current = G))
          : (G = Y),
          (W.style.transition = [
            E.transitions.create("opacity", { duration: G, delay: Z }),
            E.transitions.create("transform", {
              duration: S_ ? G : G * 0.666,
              delay: S_ ? Z : Z || G * 0.333,
              easing: B,
            }),
          ].join(",")),
          (W.style.opacity = 0),
          (W.style.transform = L1(0.75)),
          h && h(W);
      }),
      $ = L(p),
      D = (W) => {
        _ === "auto" && w.start(S.current || 0, W), r && r(T.current, W);
      };
    return Q.jsx(x, {
      appear: i,
      in: a,
      nodeRef: T,
      onEnter: C,
      onEntered: I,
      onEntering: N,
      onExit: R,
      onExited: $,
      onExiting: k,
      addEndListener: D,
      timeout: _ === "auto" ? null : _,
      ...m,
      children: (W, { ownerState: Y, ...Z }) =>
        U.cloneElement(s, {
          style: {
            opacity: 0,
            transform: L1(0.75),
            visibility: W === "exited" && !a ? "hidden" : void 0,
            ...pX[W],
            ...v,
            ...s.props.style,
          },
          ref: A,
          ...Z,
        }),
    });
  });
I1 && (I1.muiSupportAuto = !0);
const mX = (t) => {
    const { classes: e, disableUnderline: n } = t,
      i = Bn({ root: ["root", !n && "underline"], input: ["input"] }, w$, e);
    return { ...e, ...i };
  },
  gX = Rt(Ov, {
    shouldForwardProp: (t) => Vs(t) || t === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [...Iv(t, e), !n.disableUnderline && e.underline];
    },
  })(
    pr(({ theme: t }) => {
      let n =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.42)"
          : "rgba(255, 255, 255, 0.7)";
      return (
        t.vars &&
          (n = t.alpha(
            t.vars.palette.common.onBackground,
            t.vars.opacity.inputUnderline
          )),
        {
          position: "relative",
          variants: [
            {
              props: ({ ownerState: r }) => r.formControl,
              style: { "label + &": { marginTop: 16 } },
            },
            {
              props: ({ ownerState: r }) => !r.disableUnderline,
              style: {
                "&::after": {
                  left: 0,
                  bottom: 0,
                  content: '""',
                  position: "absolute",
                  right: 0,
                  transform: "scaleX(0)",
                  transition: t.transitions.create("transform", {
                    duration: t.transitions.duration.shorter,
                    easing: t.transitions.easing.easeOut,
                  }),
                  pointerEvents: "none",
                },
                [`&.${Pf.focused}:after`]: {
                  transform: "scaleX(1) translateX(0)",
                },
                [`&.${Pf.error}`]: {
                  "&::before, &::after": {
                    borderBottomColor: (t.vars || t).palette.error.main,
                  },
                },
                "&::before": {
                  borderBottom: `1px solid ${n}`,
                  left: 0,
                  bottom: 0,
                  content: '"\\00a0"',
                  position: "absolute",
                  right: 0,
                  transition: t.transitions.create("border-bottom-color", {
                    duration: t.transitions.duration.shorter,
                  }),
                  pointerEvents: "none",
                },
                [`&:hover:not(.${Pf.disabled}, .${Pf.error}):before`]: {
                  borderBottom: `2px solid ${
                    (t.vars || t).palette.text.primary
                  }`,
                  "@media (hover: none)": { borderBottom: `1px solid ${n}` },
                },
                [`&.${Pf.disabled}:before`]: { borderBottomStyle: "dotted" },
              },
            },
            ...Object.entries(t.palette)
              .filter(xh())
              .map(([r]) => ({
                props: { color: r, disableUnderline: !1 },
                style: {
                  "&::after": {
                    borderBottom: `2px solid ${(t.vars || t).palette[r].main}`,
                  },
                },
              })),
          ],
        }
      );
    })
  ),
  vX = Rt(Dv, { name: "MuiInput", slot: "Input", overridesResolver: Nv })({}),
  rE = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiInput" }),
      {
        disableUnderline: i = !1,
        components: s = {},
        componentsProps: o,
        fullWidth: a = !1,
        inputComponent: l = "input",
        multiline: f = !1,
        slotProps: d,
        slots: h = {},
        type: p = "text",
        ...g
      } = r,
      v = mX(r),
      x = { root: { ownerState: { disableUnderline: i } } },
      m = d ?? o ? Lr(d ?? o, x) : x,
      w = h.root ?? s.Root ?? gX,
      S = h.input ?? s.Input ?? vX;
    return Q.jsx(tE, {
      slots: { root: w, input: S },
      slotProps: m,
      fullWidth: a,
      inputComponent: l,
      multiline: f,
      ref: n,
      type: p,
      ...g,
      classes: v,
    });
  });
rE.muiName = "Input";
function yX(t) {
  return zn("MuiInputLabel", t);
}
Yn("MuiInputLabel", [
  "root",
  "focused",
  "disabled",
  "error",
  "required",
  "asterisk",
  "formControl",
  "sizeSmall",
  "shrink",
  "animated",
  "standard",
  "filled",
  "outlined",
]);
const xX = (t) => {
    const {
        classes: e,
        formControl: n,
        size: r,
        shrink: i,
        disableAnimation: s,
        variant: o,
        required: a,
      } = t,
      l = {
        root: [
          "root",
          n && "formControl",
          !s && "animated",
          i && "shrink",
          r && r !== "medium" && `size${gn(r)}`,
          o,
        ],
        asterisk: [a && "asterisk"],
      },
      f = Bn(l, yX, e);
    return { ...e, ...f };
  },
  _X = Rt(hX, {
    shouldForwardProp: (t) => Vs(t) || t === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`& .${od.asterisk}`]: e.asterisk },
        e.root,
        n.formControl && e.formControl,
        n.size === "small" && e.sizeSmall,
        n.shrink && e.shrink,
        !n.disableAnimation && e.animated,
        n.focused && e.focused,
        e[n.variant],
      ];
    },
  })(
    pr(({ theme: t }) => ({
      display: "block",
      transformOrigin: "top left",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%",
      variants: [
        {
          props: ({ ownerState: e }) => e.formControl,
          style: {
            position: "absolute",
            left: 0,
            top: 0,
            transform: "translate(0, 20px) scale(1)",
          },
        },
        {
          props: { size: "small" },
          style: { transform: "translate(0, 17px) scale(1)" },
        },
        {
          props: ({ ownerState: e }) => e.shrink,
          style: {
            transform: "translate(0, -1.5px) scale(0.75)",
            transformOrigin: "top left",
            maxWidth: "133%",
          },
        },
        {
          props: ({ ownerState: e }) => !e.disableAnimation,
          style: {
            transition: t.transitions.create(
              ["color", "transform", "max-width"],
              {
                duration: t.transitions.duration.shorter,
                easing: t.transitions.easing.easeOut,
              }
            ),
          },
        },
        {
          props: { variant: "filled" },
          style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
        },
        {
          props: { variant: "filled", size: "small" },
          style: { transform: "translate(12px, 13px) scale(1)" },
        },
        {
          props: ({ variant: e, ownerState: n }) => e === "filled" && n.shrink,
          style: {
            userSelect: "none",
            pointerEvents: "auto",
            transform: "translate(12px, 7px) scale(0.75)",
            maxWidth: "calc(133% - 24px)",
          },
        },
        {
          props: ({ variant: e, ownerState: n, size: r }) =>
            e === "filled" && n.shrink && r === "small",
          style: { transform: "translate(12px, 4px) scale(0.75)" },
        },
        {
          props: { variant: "outlined" },
          style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
        },
        {
          props: { variant: "outlined", size: "small" },
          style: { transform: "translate(14px, 9px) scale(1)" },
        },
        {
          props: ({ variant: e, ownerState: n }) =>
            e === "outlined" && n.shrink,
          style: {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)",
          },
        },
      ],
    }))
  ),
  SX = U.forwardRef(function (e, n) {
    const r = ir({ name: "MuiInputLabel", props: e }),
      {
        disableAnimation: i = !1,
        margin: s,
        shrink: o,
        variant: a,
        className: l,
        ...f
      } = r,
      d = Fc();
    let h = o;
    typeof h > "u" && d && (h = d.filled || d.focused || d.adornedStart);
    const p = Uc({
        props: r,
        muiFormControl: d,
        states: ["size", "variant", "required", "focused"],
      }),
      g = {
        ...r,
        disableAnimation: i,
        formControl: d,
        shrink: h,
        size: p.size,
        variant: p.variant,
        required: p.required,
        focused: p.focused,
      },
      v = xX(g);
    return Q.jsx(_X, {
      "data-shrink": h,
      ref: n,
      className: In(v.root, l),
      ...f,
      ownerState: g,
      classes: v,
    });
  }),
  wX = U.createContext({});
function MX(t) {
  return zn("MuiList", t);
}
Yn("MuiList", ["root", "padding", "dense", "subheader"]);
const EX = (t) => {
    const { classes: e, disablePadding: n, dense: r, subheader: i } = t;
    return Bn(
      { root: ["root", !n && "padding", r && "dense", i && "subheader"] },
      MX,
      e
    );
  },
  bX = Rt("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        !n.disablePadding && e.padding,
        n.dense && e.dense,
        n.subheader && e.subheader,
      ];
    },
  })({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [
      {
        props: ({ ownerState: t }) => !t.disablePadding,
        style: { paddingTop: 8, paddingBottom: 8 },
      },
      { props: ({ ownerState: t }) => t.subheader, style: { paddingTop: 0 } },
    ],
  }),
  TX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiList" }),
      {
        children: i,
        className: s,
        component: o = "ul",
        dense: a = !1,
        disablePadding: l = !1,
        subheader: f,
        ...d
      } = r,
      h = U.useMemo(() => ({ dense: a }), [a]),
      p = { ...r, component: o, dense: a, disablePadding: l },
      g = EX(p);
    return Q.jsx(wX.Provider, {
      value: h,
      children: Q.jsxs(bX, {
        as: o,
        className: In(g.root, s),
        ref: n,
        ownerState: p,
        ...d,
        children: [f, i],
      }),
    });
  });
function w_(t, e, n) {
  return t === e
    ? t.firstChild
    : e && e.nextElementSibling
    ? e.nextElementSibling
    : n
    ? null
    : t.firstChild;
}
function YR(t, e, n) {
  return t === e
    ? n
      ? t.firstChild
      : t.lastChild
    : e && e.previousElementSibling
    ? e.previousElementSibling
    : n
    ? null
    : t.lastChild;
}
function dO(t, e) {
  if (e === void 0) return !0;
  let n = t.innerText;
  return (
    n === void 0 && (n = t.textContent),
    (n = n.trim().toLowerCase()),
    n.length === 0
      ? !1
      : e.repeating
      ? n[0] === e.keys[0]
      : n.startsWith(e.keys.join(""))
  );
}
function Lf(t, e, n, r, i, s) {
  let o = !1,
    a = i(t, e, e ? n : !1);
  for (; a; ) {
    if (a === t.firstChild) {
      if (o) return !1;
      o = !0;
    }
    const l = r ? !1 : a.disabled || a.getAttribute("aria-disabled") === "true";
    if (!a.hasAttribute("tabindex") || !dO(a, s) || l) a = i(t, a, n);
    else return a.focus(), !0;
  }
  return !1;
}
const AX = U.forwardRef(function (e, n) {
  const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: s = !1,
      children: o,
      className: a,
      disabledItemsFocusable: l = !1,
      disableListWrap: f = !1,
      onKeyDown: d,
      variant: h = "selectedMenu",
      ...p
    } = e,
    g = U.useRef(null),
    v = U.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    });
  Nl(() => {
    i && g.current.focus();
  }, [i]),
    U.useImperativeHandle(
      r,
      () => ({
        adjustStyleForScrollbar: (S, { direction: E }) => {
          const T = !g.current.style.width;
          if (S.clientHeight < g.current.clientHeight && T) {
            const A = `${fO(bo(S))}px`;
            (g.current.style[E === "rtl" ? "paddingLeft" : "paddingRight"] = A),
              (g.current.style.width = `calc(100% + ${A})`);
          }
          return g.current;
        },
      }),
      []
    );
  const _ = (S) => {
      const E = g.current,
        T = S.key;
      if (S.ctrlKey || S.metaKey || S.altKey) {
        d && d(S);
        return;
      }
      const L = fs(E).activeElement;
      if (T === "ArrowDown") S.preventDefault(), Lf(E, L, f, l, w_);
      else if (T === "ArrowUp") S.preventDefault(), Lf(E, L, f, l, YR);
      else if (T === "Home") S.preventDefault(), Lf(E, null, f, l, w_);
      else if (T === "End") S.preventDefault(), Lf(E, null, f, l, YR);
      else if (T.length === 1) {
        const N = v.current,
          C = T.toLowerCase(),
          I = performance.now();
        N.keys.length > 0 &&
          (I - N.lastTime > 500
            ? ((N.keys = []), (N.repeating = !0), (N.previousKeyMatched = !0))
            : N.repeating && C !== N.keys[0] && (N.repeating = !1)),
          (N.lastTime = I),
          N.keys.push(C);
        const k = L && !N.repeating && dO(L, N);
        N.previousKeyMatched && (k || Lf(E, L, !1, l, w_, N))
          ? S.preventDefault()
          : (N.previousKeyMatched = !1);
      }
      d && d(S);
    },
    x = $i(g, n);
  let m = -1;
  U.Children.forEach(o, (S, E) => {
    if (!U.isValidElement(S)) {
      m === E && ((m += 1), m >= o.length && (m = -1));
      return;
    }
    S.props.disabled ||
      (((h === "selectedMenu" && S.props.selected) || m === -1) && (m = E)),
      m === E &&
        (S.props.disabled ||
          S.props.muiSkipListHighlight ||
          S.type.muiSkipListHighlight) &&
        ((m += 1), m >= o.length && (m = -1));
  });
  const w = U.Children.map(o, (S, E) => {
    if (E === m) {
      const T = {};
      return (
        s && (T.autoFocus = !0),
        S.props.tabIndex === void 0 && h === "selectedMenu" && (T.tabIndex = 0),
        U.cloneElement(S, T)
      );
    }
    return S;
  });
  return Q.jsx(TX, {
    role: "menu",
    ref: x,
    className: a,
    onKeyDown: _,
    tabIndex: i ? 0 : -1,
    ...p,
    children: w,
  });
});
function CX(t) {
  return zn("MuiPopover", t);
}
Yn("MuiPopover", ["root", "paper"]);
function qR(t, e) {
  let n = 0;
  return (
    typeof e == "number"
      ? (n = e)
      : e === "center"
      ? (n = t.height / 2)
      : e === "bottom" && (n = t.height),
    n
  );
}
function KR(t, e) {
  let n = 0;
  return (
    typeof e == "number"
      ? (n = e)
      : e === "center"
      ? (n = t.width / 2)
      : e === "right" && (n = t.width),
    n
  );
}
function ZR(t) {
  return [t.horizontal, t.vertical]
    .map((e) => (typeof e == "number" ? `${e}px` : e))
    .join(" ");
}
function Om(t) {
  return typeof t == "function" ? t() : t;
}
const RX = (t) => {
    const { classes: e } = t;
    return Bn({ root: ["root"], paper: ["paper"] }, CX, e);
  },
  PX = Rt(Z$, { name: "MuiPopover", slot: "Root" })({}),
  hO = Rt(s$, { name: "MuiPopover", slot: "Paper" })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0,
  }),
  LX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiPopover" }),
      {
        action: i,
        anchorEl: s,
        anchorOrigin: o = { vertical: "top", horizontal: "left" },
        anchorPosition: a,
        anchorReference: l = "anchorEl",
        children: f,
        className: d,
        container: h,
        elevation: p = 8,
        marginThreshold: g = 16,
        open: v,
        PaperProps: _ = {},
        slots: x = {},
        slotProps: m = {},
        transformOrigin: w = { vertical: "top", horizontal: "left" },
        TransitionComponent: S,
        transitionDuration: E = "auto",
        TransitionProps: T = {},
        disableScrollLock: A = !1,
        ...L
      } = r,
      N = U.useRef(),
      C = {
        ...r,
        anchorOrigin: o,
        anchorReference: l,
        elevation: p,
        marginThreshold: g,
        transformOrigin: w,
        TransitionComponent: S,
        transitionDuration: E,
        TransitionProps: T,
      },
      I = RX(C),
      k = U.useCallback(() => {
        if (l === "anchorPosition") return a;
        const Me = Om(s),
          H = (
            Me && Me.nodeType === 1 ? Me : fs(N.current).body
          ).getBoundingClientRect();
        return {
          top: H.top + qR(H, o.vertical),
          left: H.left + KR(H, o.horizontal),
        };
      }, [s, o.horizontal, o.vertical, a, l]),
      R = U.useCallback(
        (Me) => ({
          vertical: qR(Me, w.vertical),
          horizontal: KR(Me, w.horizontal),
        }),
        [w.horizontal, w.vertical]
      ),
      $ = U.useCallback(
        (Me) => {
          const Le = { width: Me.offsetWidth, height: Me.offsetHeight },
            H = R(Le);
          if (l === "none")
            return { top: null, left: null, transformOrigin: ZR(H) };
          const pe = k();
          let ie = pe.top - H.vertical,
            we = pe.left - H.horizontal;
          const xe = ie + Le.height,
            $e = we + Le.width,
            Fe = bo(Om(s)),
            He = Fe.innerHeight - g,
            Ze = Fe.innerWidth - g;
          if (g !== null && ie < g) {
            const it = ie - g;
            (ie -= it), (H.vertical += it);
          } else if (g !== null && xe > He) {
            const it = xe - He;
            (ie -= it), (H.vertical += it);
          }
          if (g !== null && we < g) {
            const it = we - g;
            (we -= it), (H.horizontal += it);
          } else if ($e > Ze) {
            const it = $e - Ze;
            (we -= it), (H.horizontal += it);
          }
          return {
            top: `${Math.round(ie)}px`,
            left: `${Math.round(we)}px`,
            transformOrigin: ZR(H),
          };
        },
        [s, l, k, R, g]
      ),
      [D, W] = U.useState(v),
      Y = U.useCallback(() => {
        const Me = N.current;
        if (!Me) return;
        const Le = $(Me);
        Le.top !== null && Me.style.setProperty("top", Le.top),
          Le.left !== null && (Me.style.left = Le.left),
          (Me.style.transformOrigin = Le.transformOrigin),
          W(!0);
      }, [$]);
    U.useEffect(
      () => (
        A && window.addEventListener("scroll", Y),
        () => window.removeEventListener("scroll", Y)
      ),
      [s, A, Y]
    );
    const Z = () => {
        Y();
      },
      B = () => {
        W(!1);
      };
    U.useEffect(() => {
      v && Y();
    }),
      U.useImperativeHandle(
        i,
        () =>
          v
            ? {
                updatePosition: () => {
                  Y();
                },
              }
            : null,
        [v, Y]
      ),
      U.useEffect(() => {
        if (!v) return;
        const Me = iO(() => {
            Y();
          }),
          Le = bo(Om(s));
        return (
          Le.addEventListener("resize", Me),
          () => {
            Me.clear(), Le.removeEventListener("resize", Me);
          }
        );
      }, [s, v, Y]);
    let G = E;
    const X = {
        slots: { transition: S, ...x },
        slotProps: { transition: T, paper: _, ...m },
      },
      [te, oe] = Ar("transition", {
        elementType: I1,
        externalForwardedProps: X,
        ownerState: C,
        getSlotProps: (Me) => ({
          ...Me,
          onEntering: (Le, H) => {
            var pe;
            (pe = Me.onEntering) == null || pe.call(Me, Le, H), Z();
          },
          onExited: (Le) => {
            var H;
            (H = Me.onExited) == null || H.call(Me, Le), B();
          },
        }),
        additionalProps: { appear: !0, in: v },
      });
    E === "auto" && !te.muiSupportAuto && (G = void 0);
    const J = h || (s ? fs(Om(s)).body : void 0),
      [ae, { slots: Se, slotProps: Ie, ...Ce }] = Ar("root", {
        ref: n,
        elementType: PX,
        externalForwardedProps: { ...X, ...L },
        shouldForwardComponentProp: !0,
        additionalProps: {
          slots: { backdrop: x.backdrop },
          slotProps: {
            backdrop: qj(
              typeof m.backdrop == "function" ? m.backdrop(C) : m.backdrop,
              { invisible: !0 }
            ),
          },
          container: J,
          open: v,
        },
        ownerState: C,
        className: In(I.root, d),
      }),
      [et, We] = Ar("paper", {
        ref: N,
        className: I.paper,
        elementType: hO,
        externalForwardedProps: X,
        shouldForwardComponentProp: !0,
        additionalProps: { elevation: p, style: D ? void 0 : { opacity: 0 } },
        ownerState: C,
      });
    return Q.jsx(ae, {
      ...Ce,
      ...(!$g(ae) && { slots: Se, slotProps: Ie, disableScrollLock: A }),
      children: Q.jsx(te, {
        ...oe,
        timeout: G,
        children: Q.jsx(et, { ...We, children: f }),
      }),
    });
  });
function IX(t) {
  return zn("MuiMenu", t);
}
Yn("MuiMenu", ["root", "paper", "list"]);
const NX = { vertical: "top", horizontal: "right" },
  OX = { vertical: "top", horizontal: "left" },
  DX = (t) => {
    const { classes: e } = t;
    return Bn({ root: ["root"], paper: ["paper"], list: ["list"] }, IX, e);
  },
  kX = Rt(LX, {
    shouldForwardProp: (t) => Vs(t) || t === "classes",
    name: "MuiMenu",
    slot: "Root",
  })({}),
  UX = Rt(hO, { name: "MuiMenu", slot: "Paper" })({
    maxHeight: "calc(100% - 96px)",
    WebkitOverflowScrolling: "touch",
  }),
  FX = Rt(AX, { name: "MuiMenu", slot: "List" })({ outline: 0 }),
  zX = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiMenu" }),
      {
        autoFocus: i = !0,
        children: s,
        className: o,
        disableAutoFocusItem: a = !1,
        MenuListProps: l = {},
        onClose: f,
        open: d,
        PaperProps: h = {},
        PopoverClasses: p,
        transitionDuration: g = "auto",
        TransitionProps: { onEntering: v, ..._ } = {},
        variant: x = "selectedMenu",
        slots: m = {},
        slotProps: w = {},
        ...S
      } = r,
      E = Z7(),
      T = {
        ...r,
        autoFocus: i,
        disableAutoFocusItem: a,
        MenuListProps: l,
        onEntering: v,
        PaperProps: h,
        transitionDuration: g,
        TransitionProps: _,
        variant: x,
      },
      A = DX(T),
      L = i && !a && d,
      N = U.useRef(null),
      C = (G, X) => {
        N.current &&
          N.current.adjustStyleForScrollbar(G, {
            direction: E ? "rtl" : "ltr",
          }),
          v && v(G, X);
      },
      I = (G) => {
        G.key === "Tab" && (G.preventDefault(), f && f(G, "tabKeyDown"));
      };
    let k = -1;
    U.Children.map(s, (G, X) => {
      U.isValidElement(G) &&
        (G.props.disabled ||
          (((x === "selectedMenu" && G.props.selected) || k === -1) &&
            (k = X)));
    });
    const R = {
        slots: m,
        slotProps: { list: l, transition: _, paper: h, ...w },
      },
      $ = h$({
        elementType: m.root,
        externalSlotProps: w.root,
        ownerState: T,
        className: [A.root, o],
      }),
      [D, W] = Ar("paper", {
        className: A.paper,
        elementType: UX,
        externalForwardedProps: R,
        shouldForwardComponentProp: !0,
        ownerState: T,
      }),
      [Y, Z] = Ar("list", {
        className: In(A.list, l.className),
        elementType: FX,
        shouldForwardComponentProp: !0,
        externalForwardedProps: R,
        getSlotProps: (G) => ({
          ...G,
          onKeyDown: (X) => {
            var te;
            I(X), (te = G.onKeyDown) == null || te.call(G, X);
          },
        }),
        ownerState: T,
      }),
      B =
        typeof R.slotProps.transition == "function"
          ? R.slotProps.transition(T)
          : R.slotProps.transition;
    return Q.jsx(kX, {
      onClose: f,
      anchorOrigin: { vertical: "bottom", horizontal: E ? "right" : "left" },
      transformOrigin: E ? NX : OX,
      slots: {
        root: m.root,
        paper: D,
        backdrop: m.backdrop,
        ...(m.transition && { transition: m.transition }),
      },
      slotProps: {
        root: $,
        paper: W,
        backdrop: typeof w.backdrop == "function" ? w.backdrop(T) : w.backdrop,
        transition: {
          ...B,
          onEntering: (...G) => {
            var X;
            C(...G),
              (X = B == null ? void 0 : B.onEntering) == null ||
                X.call(B, ...G);
          },
        },
      },
      open: d,
      ref: n,
      transitionDuration: g,
      ownerState: T,
      ...S,
      classes: p,
      children: Q.jsx(Y, {
        actions: N,
        autoFocus: i && (k === -1 || a),
        autoFocusItem: L,
        variant: x,
        ...Z,
        children: s,
      }),
    });
  });
function BX(t) {
  return zn("MuiNativeSelect", t);
}
const iE = Yn("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
  ]),
  HX = (t) => {
    const {
        classes: e,
        variant: n,
        disabled: r,
        multiple: i,
        open: s,
        error: o,
      } = t,
      a = {
        select: ["select", n, r && "disabled", i && "multiple", o && "error"],
        icon: ["icon", `icon${gn(n)}`, s && "iconOpen", r && "disabled"],
      };
    return Bn(a, BX, e);
  },
  pO = Rt("select", { name: "MuiNativeSelect" })(({ theme: t }) => ({
    MozAppearance: "none",
    WebkitAppearance: "none",
    userSelect: "none",
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": { borderRadius: 0 },
    [`&.${iE.disabled}`]: { cursor: "default" },
    "&[multiple]": { height: "auto" },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (t.vars || t).palette.background.paper,
    },
    variants: [
      {
        props: ({ ownerState: e }) =>
          e.variant !== "filled" && e.variant !== "outlined",
        style: { "&&&": { paddingRight: 24, minWidth: 16 } },
      },
      { props: { variant: "filled" }, style: { "&&&": { paddingRight: 32 } } },
      {
        props: { variant: "outlined" },
        style: {
          borderRadius: (t.vars || t).shape.borderRadius,
          "&:focus": { borderRadius: (t.vars || t).shape.borderRadius },
          "&&&": { paddingRight: 32 },
        },
      },
    ],
  })),
  VX = Rt(pO, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Vs,
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.select,
        e[n.variant],
        n.error && e.error,
        { [`&.${iE.multiple}`]: e.multiple },
      ];
    },
  })({}),
  mO = Rt("svg", { name: "MuiNativeSelect" })(({ theme: t }) => ({
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    pointerEvents: "none",
    color: (t.vars || t).palette.action.active,
    [`&.${iE.disabled}`]: { color: (t.vars || t).palette.action.disabled },
    variants: [
      {
        props: ({ ownerState: e }) => e.open,
        style: { transform: "rotate(180deg)" },
      },
      { props: { variant: "filled" }, style: { right: 7 } },
      { props: { variant: "outlined" }, style: { right: 7 } },
    ],
  })),
  WX = Rt(mO, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.icon,
        n.variant && e[`icon${gn(n.variant)}`],
        n.open && e.iconOpen,
      ];
    },
  })({}),
  GX = U.forwardRef(function (e, n) {
    const {
        className: r,
        disabled: i,
        error: s,
        IconComponent: o,
        inputRef: a,
        variant: l = "standard",
        ...f
      } = e,
      d = { ...e, disabled: i, variant: l, error: s },
      h = HX(d);
    return Q.jsxs(U.Fragment, {
      children: [
        Q.jsx(VX, {
          ownerState: d,
          className: In(h.select, r),
          disabled: i,
          ref: a || n,
          ...f,
        }),
        e.multiple
          ? null
          : Q.jsx(WX, { as: o, ownerState: d, className: h.icon }),
      ],
    });
  });
var JR;
const jX = Rt("fieldset", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: Vs,
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
  }),
  $X = Rt("legend", { name: "MuiNotchedOutlined", shouldForwardProp: Vs })(
    pr(({ theme: t }) => ({
      float: "unset",
      width: "auto",
      overflow: "hidden",
      variants: [
        {
          props: ({ ownerState: e }) => !e.withLabel,
          style: {
            padding: 0,
            lineHeight: "11px",
            transition: t.transitions.create("width", {
              duration: 150,
              easing: t.transitions.easing.easeOut,
            }),
          },
        },
        {
          props: ({ ownerState: e }) => e.withLabel,
          style: {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: 0.01,
            transition: t.transitions.create("max-width", {
              duration: 50,
              easing: t.transitions.easing.easeOut,
            }),
            whiteSpace: "nowrap",
            "& > span": {
              paddingLeft: 5,
              paddingRight: 5,
              display: "inline-block",
              opacity: 0,
              visibility: "visible",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.withLabel && e.notched,
          style: {
            maxWidth: "100%",
            transition: t.transitions.create("max-width", {
              duration: 100,
              easing: t.transitions.easing.easeOut,
              delay: 50,
            }),
          },
        },
      ],
    }))
  );
function XX(t) {
  const {
      children: e,
      classes: n,
      className: r,
      label: i,
      notched: s,
      ...o
    } = t,
    a = i != null && i !== "",
    l = { ...t, notched: s, withLabel: a };
  return Q.jsx(jX, {
    "aria-hidden": !0,
    className: r,
    ownerState: l,
    ...o,
    children: Q.jsx($X, {
      ownerState: l,
      children: a
        ? Q.jsx("span", { children: i })
        : JR ||
          (JR = Q.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: "​",
          })),
    }),
  });
}
const YX = (t) => {
    const { classes: e } = t,
      r = Bn(
        {
          root: ["root"],
          notchedOutline: ["notchedOutline"],
          input: ["input"],
        },
        M$,
        e
      );
    return { ...e, ...r };
  },
  qX = Rt(Ov, {
    shouldForwardProp: (t) => Vs(t) || t === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: Iv,
  })(
    pr(({ theme: t }) => {
      const e =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.23)"
          : "rgba(255, 255, 255, 0.23)";
      return {
        position: "relative",
        borderRadius: (t.vars || t).shape.borderRadius,
        [`&:hover .${bs.notchedOutline}`]: {
          borderColor: (t.vars || t).palette.text.primary,
        },
        "@media (hover: none)": {
          [`&:hover .${bs.notchedOutline}`]: {
            borderColor: t.vars
              ? t.alpha(t.vars.palette.common.onBackground, 0.23)
              : e,
          },
        },
        [`&.${bs.focused} .${bs.notchedOutline}`]: { borderWidth: 2 },
        variants: [
          ...Object.entries(t.palette)
            .filter(xh())
            .map(([n]) => ({
              props: { color: n },
              style: {
                [`&.${bs.focused} .${bs.notchedOutline}`]: {
                  borderColor: (t.vars || t).palette[n].main,
                },
              },
            })),
          {
            props: {},
            style: {
              [`&.${bs.error} .${bs.notchedOutline}`]: {
                borderColor: (t.vars || t).palette.error.main,
              },
              [`&.${bs.disabled} .${bs.notchedOutline}`]: {
                borderColor: (t.vars || t).palette.action.disabled,
              },
            },
          },
          {
            props: ({ ownerState: n }) => n.startAdornment,
            style: { paddingLeft: 14 },
          },
          {
            props: ({ ownerState: n }) => n.endAdornment,
            style: { paddingRight: 14 },
          },
          {
            props: ({ ownerState: n }) => n.multiline,
            style: { padding: "16.5px 14px" },
          },
          {
            props: ({ ownerState: n, size: r }) => n.multiline && r === "small",
            style: { padding: "8.5px 14px" },
          },
        ],
      };
    })
  ),
  KX = Rt(XX, { name: "MuiOutlinedInput", slot: "NotchedOutline" })(
    pr(({ theme: t }) => {
      const e =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.23)"
          : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: t.vars
          ? t.alpha(t.vars.palette.common.onBackground, 0.23)
          : e,
      };
    })
  ),
  ZX = Rt(Dv, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: Nv,
  })(
    pr(({ theme: t }) => ({
      padding: "16.5px 14px",
      ...(!t.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            t.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: t.palette.mode === "light" ? null : "#fff",
          caretColor: t.palette.mode === "light" ? null : "#fff",
          borderRadius: "inherit",
        },
      }),
      ...(t.vars && {
        "&:-webkit-autofill": { borderRadius: "inherit" },
        [t.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      }),
      variants: [
        { props: { size: "small" }, style: { padding: "8.5px 14px" } },
        { props: ({ ownerState: e }) => e.multiline, style: { padding: 0 } },
        {
          props: ({ ownerState: e }) => e.startAdornment,
          style: { paddingLeft: 0 },
        },
        {
          props: ({ ownerState: e }) => e.endAdornment,
          style: { paddingRight: 0 },
        },
      ],
    }))
  ),
  sE = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiOutlinedInput" }),
      {
        components: i = {},
        fullWidth: s = !1,
        inputComponent: o = "input",
        label: a,
        multiline: l = !1,
        notched: f,
        slots: d = {},
        slotProps: h = {},
        type: p = "text",
        ...g
      } = r,
      v = YX(r),
      _ = Fc(),
      x = Uc({
        props: r,
        muiFormControl: _,
        states: [
          "color",
          "disabled",
          "error",
          "focused",
          "hiddenLabel",
          "size",
          "required",
        ],
      }),
      m = {
        ...r,
        color: x.color || "primary",
        disabled: x.disabled,
        error: x.error,
        focused: x.focused,
        formControl: _,
        fullWidth: s,
        hiddenLabel: x.hiddenLabel,
        multiline: l,
        size: x.size,
        type: p,
      },
      w = d.root ?? i.Root ?? qX,
      S = d.input ?? i.Input ?? ZX,
      [E, T] = Ar("notchedOutline", {
        elementType: KX,
        className: v.notchedOutline,
        shouldForwardComponentProp: !0,
        ownerState: m,
        externalForwardedProps: { slots: d, slotProps: h },
        additionalProps: {
          label:
            a != null && a !== "" && x.required
              ? Q.jsxs(U.Fragment, { children: [a, " ", "*"] })
              : a,
        },
      });
    return Q.jsx(tE, {
      slots: { root: w, input: S },
      slotProps: h,
      renderSuffix: (A) =>
        Q.jsx(E, {
          ...T,
          notched:
            typeof f < "u" ? f : !!(A.startAdornment || A.filled || A.focused),
        }),
      fullWidth: s,
      inputComponent: o,
      multiline: l,
      ref: n,
      type: p,
      ...g,
      classes: { ...v, notchedOutline: null },
    });
  });
sE.muiName = "Input";
function gO(t) {
  return zn("MuiSelect", t);
}
const If = Yn("MuiSelect", [
  "root",
  "select",
  "multiple",
  "filled",
  "outlined",
  "standard",
  "disabled",
  "focused",
  "icon",
  "iconOpen",
  "iconFilled",
  "iconOutlined",
  "iconStandard",
  "nativeInput",
  "error",
]);
var QR;
const JX = Rt(pO, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`&.${If.select}`]: e.select },
        { [`&.${If.select}`]: e[n.variant] },
        { [`&.${If.error}`]: e.error },
        { [`&.${If.multiple}`]: e.multiple },
      ];
    },
  })({
    [`&.${If.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
    },
  }),
  QX = Rt(mO, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.icon,
        n.variant && e[`icon${gn(n.variant)}`],
        n.open && e.iconOpen,
      ];
    },
  })({}),
  eY = Rt("input", {
    shouldForwardProp: (t) => tO(t) && t !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
  });
function eP(t, e) {
  return typeof e == "object" && e !== null ? t === e : String(t) === String(e);
}
function tY(t) {
  return t == null || (typeof t == "string" && !t.trim());
}
const nY = (t) => {
    const {
        classes: e,
        variant: n,
        disabled: r,
        multiple: i,
        open: s,
        error: o,
      } = t,
      a = {
        select: ["select", n, r && "disabled", i && "multiple", o && "error"],
        icon: ["icon", `icon${gn(n)}`, s && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"],
      };
    return Bn(a, gO, e);
  },
  rY = U.forwardRef(function (e, n) {
    var Pt, q, me, be;
    const {
        "aria-describedby": r,
        "aria-label": i,
        autoFocus: s,
        autoWidth: o,
        children: a,
        className: l,
        defaultOpen: f,
        defaultValue: d,
        disabled: h,
        displayEmpty: p,
        error: g = !1,
        IconComponent: v,
        inputRef: _,
        labelId: x,
        MenuProps: m = {},
        multiple: w,
        name: S,
        onBlur: E,
        onChange: T,
        onClose: A,
        onFocus: L,
        onOpen: N,
        open: C,
        readOnly: I,
        renderValue: k,
        required: R,
        SelectDisplayProps: $ = {},
        tabIndex: D,
        type: W,
        value: Y,
        variant: Z = "standard",
        ...B
      } = e,
      [G, X] = OR({ controlled: Y, default: d, name: "Select" }),
      [te, oe] = OR({ controlled: C, default: f, name: "Select" }),
      J = U.useRef(null),
      ae = U.useRef(null),
      [Se, Ie] = U.useState(null),
      { current: Ce } = U.useRef(C != null),
      [et, We] = U.useState(),
      Me = $i(n, _),
      Le = U.useCallback((ue) => {
        (ae.current = ue), ue && Ie(ue);
      }, []),
      H = Se == null ? void 0 : Se.parentNode;
    U.useImperativeHandle(
      Me,
      () => ({
        focus: () => {
          ae.current.focus();
        },
        node: J.current,
        value: G,
      }),
      [G]
    ),
      U.useEffect(() => {
        f &&
          te &&
          Se &&
          !Ce &&
          (We(o ? null : H.clientWidth), ae.current.focus());
      }, [Se, o]),
      U.useEffect(() => {
        s && ae.current.focus();
      }, [s]),
      U.useEffect(() => {
        if (!x) return;
        const ue = fs(ae.current).getElementById(x);
        if (ue) {
          const Be = () => {
            getSelection().isCollapsed && ae.current.focus();
          };
          return (
            ue.addEventListener("click", Be),
            () => {
              ue.removeEventListener("click", Be);
            }
          );
        }
      }, [x]);
    const pe = (ue, Be) => {
        ue ? N && N(Be) : A && A(Be),
          Ce || (We(o ? null : H.clientWidth), oe(ue));
      },
      ie = (ue) => {
        ue.button === 0 &&
          (ue.preventDefault(), ae.current.focus(), pe(!0, ue));
      },
      we = (ue) => {
        pe(!1, ue);
      },
      xe = U.Children.toArray(a),
      $e = (ue) => {
        const Be = xe.find((K) => K.props.value === ue.target.value);
        Be !== void 0 && (X(Be.props.value), T && T(ue, Be));
      },
      Fe = (ue) => (Be) => {
        let K;
        if (Be.currentTarget.hasAttribute("tabindex")) {
          if (w) {
            K = Array.isArray(G) ? G.slice() : [];
            const ze = G.indexOf(ue.props.value);
            ze === -1 ? K.push(ue.props.value) : K.splice(ze, 1);
          } else K = ue.props.value;
          if (
            (ue.props.onClick && ue.props.onClick(Be), G !== K && (X(K), T))
          ) {
            const ze = Be.nativeEvent || Be,
              ke = new ze.constructor(ze.type, ze);
            Object.defineProperty(ke, "target", {
              writable: !0,
              value: { value: K, name: S },
            }),
              T(ke, ue);
          }
          w || pe(!1, Be);
        }
      },
      He = (ue) => {
        I ||
          ([" ", "ArrowUp", "ArrowDown", "Enter"].includes(ue.key) &&
            (ue.preventDefault(), pe(!0, ue)));
      },
      Ze = Se !== null && te,
      it = (ue) => {
        !Ze &&
          E &&
          (Object.defineProperty(ue, "target", {
            writable: !0,
            value: { value: G, name: S },
          }),
          E(ue));
      };
    delete B["aria-invalid"];
    let Tt, V;
    const O = [];
    let se = !1;
    (Xg({ value: G }) || p) && (k ? (Tt = k(G)) : (se = !0));
    const Re = xe.map((ue) => {
      if (!U.isValidElement(ue)) return null;
      let Be;
      if (w) {
        if (!Array.isArray(G)) throw new Error(Mo(2));
        (Be = G.some((K) => eP(K, ue.props.value))),
          Be && se && O.push(ue.props.children);
      } else (Be = eP(G, ue.props.value)), Be && se && (V = ue.props.children);
      return U.cloneElement(ue, {
        "aria-selected": Be ? "true" : "false",
        onClick: Fe(ue),
        onKeyUp: (K) => {
          K.key === " " && K.preventDefault(),
            ue.props.onKeyUp && ue.props.onKeyUp(K);
        },
        role: "option",
        selected: Be,
        value: void 0,
        "data-value": ue.props.value,
      });
    });
    se &&
      (w
        ? O.length === 0
          ? (Tt = null)
          : (Tt = O.reduce(
              (ue, Be, K) => (
                ue.push(Be), K < O.length - 1 && ue.push(", "), ue
              ),
              []
            ))
        : (Tt = V));
    let Ee = et;
    !o && Ce && Se && (Ee = H.clientWidth);
    let Ae;
    typeof D < "u" ? (Ae = D) : (Ae = h ? null : 0);
    const Ye = $.id || (S ? `mui-component-select-${S}` : void 0),
      Pe = { ...e, variant: Z, value: G, open: Ze, error: g },
      Te = nY(Pe),
      at = {
        ...m.PaperProps,
        ...(typeof ((Pt = m.slotProps) == null ? void 0 : Pt.paper) ==
        "function"
          ? m.slotProps.paper(Pe)
          : (q = m.slotProps) == null
          ? void 0
          : q.paper),
      },
      wt = {
        ...m.MenuListProps,
        ...(typeof ((me = m.slotProps) == null ? void 0 : me.list) == "function"
          ? m.slotProps.list(Pe)
          : (be = m.slotProps) == null
          ? void 0
          : be.list),
      },
      Ne = YN();
    return Q.jsxs(U.Fragment, {
      children: [
        Q.jsx(JX, {
          as: "div",
          ref: Le,
          tabIndex: Ae,
          role: "combobox",
          "aria-controls": Ze ? Ne : void 0,
          "aria-disabled": h ? "true" : void 0,
          "aria-expanded": Ze ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": i,
          "aria-labelledby": [x, Ye].filter(Boolean).join(" ") || void 0,
          "aria-describedby": r,
          "aria-required": R ? "true" : void 0,
          "aria-invalid": g ? "true" : void 0,
          onKeyDown: He,
          onMouseDown: h || I ? null : ie,
          onBlur: it,
          onFocus: L,
          ...$,
          ownerState: Pe,
          className: In($.className, Te.select, l),
          id: Ye,
          children: tY(Tt)
            ? QR ||
              (QR = Q.jsx("span", {
                className: "notranslate",
                "aria-hidden": !0,
                children: "​",
              }))
            : Tt,
        }),
        Q.jsx(eY, {
          "aria-invalid": g,
          value: Array.isArray(G) ? G.join(",") : G,
          name: S,
          ref: J,
          "aria-hidden": !0,
          onChange: $e,
          tabIndex: -1,
          disabled: h,
          className: Te.nativeInput,
          autoFocus: s,
          required: R,
          ...B,
          ownerState: Pe,
        }),
        Q.jsx(QX, { as: v, className: Te.icon, ownerState: Pe }),
        Q.jsx(zX, {
          id: `menu-${S || ""}`,
          anchorEl: H,
          open: Ze,
          onClose: we,
          anchorOrigin: { vertical: "bottom", horizontal: "center" },
          transformOrigin: { vertical: "top", horizontal: "center" },
          ...m,
          slotProps: {
            ...m.slotProps,
            list: {
              "aria-labelledby": x,
              role: "listbox",
              "aria-multiselectable": w ? "true" : void 0,
              disableListWrap: !0,
              id: Ne,
              ...wt,
            },
            paper: {
              ...at,
              style: { minWidth: Ee, ...(at != null ? at.style : null) },
            },
          },
          children: Re,
        }),
      ],
    });
  }),
  iY = (t) => {
    const { classes: e } = t,
      r = Bn({ root: ["root"] }, gO, e);
    return { ...e, ...r };
  },
  oE = {
    name: "MuiSelect",
    slot: "Root",
    shouldForwardProp: (t) => Vs(t) && t !== "variant",
  },
  sY = Rt(rE, oE)(""),
  oY = Rt(sE, oE)(""),
  aY = Rt(nE, oE)(""),
  vO = U.forwardRef(function (e, n) {
    const r = ir({ name: "MuiSelect", props: e }),
      {
        autoWidth: i = !1,
        children: s,
        classes: o = {},
        className: a,
        defaultOpen: l = !1,
        displayEmpty: f = !1,
        IconComponent: d = b$,
        id: h,
        input: p,
        inputProps: g,
        label: v,
        labelId: _,
        MenuProps: x,
        multiple: m = !1,
        native: w = !1,
        onClose: S,
        onOpen: E,
        open: T,
        renderValue: A,
        SelectDisplayProps: L,
        variant: N = "outlined",
        ...C
      } = r,
      I = w ? GX : rY,
      k = Fc(),
      R = Uc({ props: r, muiFormControl: k, states: ["variant", "error"] }),
      $ = R.variant || N,
      D = { ...r, variant: $, classes: o },
      W = iY(D),
      { root: Y, ...Z } = W,
      B =
        p ||
        {
          standard: Q.jsx(sY, { ownerState: D }),
          outlined: Q.jsx(oY, { label: v, ownerState: D }),
          filled: Q.jsx(aY, { ownerState: D }),
        }[$],
      G = $i(n, _h(B));
    return Q.jsx(U.Fragment, {
      children: U.cloneElement(B, {
        inputComponent: I,
        inputProps: {
          children: s,
          error: R.error,
          IconComponent: d,
          variant: $,
          type: void 0,
          multiple: m,
          ...(w
            ? { id: h }
            : {
                autoWidth: i,
                defaultOpen: l,
                displayEmpty: f,
                labelId: _,
                MenuProps: x,
                onClose: S,
                onOpen: E,
                open: T,
                renderValue: A,
                SelectDisplayProps: { id: h, ...L },
              }),
          ...g,
          classes: g ? Lr(Z, g.classes) : Z,
          ...(p ? p.props.inputProps : {}),
        },
        ...(((m && w) || f) && $ === "outlined" ? { notched: !0 } : {}),
        ref: G,
        className: In(B.props.className, a, W.root),
        ...(!p && { variant: $ }),
        ...C,
      }),
    });
  });
vO.muiName = "Select";
function lY(t) {
  return zn("MuiTextField", t);
}
Yn("MuiTextField", ["root"]);
const uY = { standard: rE, filled: nE, outlined: sE },
  cY = (t) => {
    const { classes: e } = t;
    return Bn({ root: ["root"] }, lY, e);
  },
  fY = Rt(iX, { name: "MuiTextField", slot: "Root" })({}),
  dY = U.forwardRef(function (e, n) {
    const r = ir({ props: e, name: "MuiTextField" }),
      {
        autoComplete: i,
        autoFocus: s = !1,
        children: o,
        className: a,
        color: l = "primary",
        defaultValue: f,
        disabled: d = !1,
        error: h = !1,
        FormHelperTextProps: p,
        fullWidth: g = !1,
        helperText: v,
        id: _,
        InputLabelProps: x,
        inputProps: m,
        InputProps: w,
        inputRef: S,
        label: E,
        maxRows: T,
        minRows: A,
        multiline: L = !1,
        name: N,
        onBlur: C,
        onChange: I,
        onFocus: k,
        placeholder: R,
        required: $ = !1,
        rows: D,
        select: W = !1,
        SelectProps: Y,
        slots: Z = {},
        slotProps: B = {},
        type: G,
        value: X,
        variant: te = "outlined",
        ...oe
      } = r,
      J = {
        ...r,
        autoFocus: s,
        color: l,
        disabled: d,
        error: h,
        fullWidth: g,
        multiline: L,
        required: $,
        select: W,
        variant: te,
      },
      ae = cY(J),
      Se = YN(_),
      Ie = v && Se ? `${Se}-helper-text` : void 0,
      Ce = E && Se ? `${Se}-label` : void 0,
      et = uY[te],
      We = {
        slots: Z,
        slotProps: {
          input: w,
          inputLabel: x,
          htmlInput: m,
          formHelperText: p,
          select: Y,
          ...B,
        },
      },
      Me = {},
      Le = We.slotProps.inputLabel;
    te === "outlined" &&
      (Le && typeof Le.shrink < "u" && (Me.notched = Le.shrink),
      (Me.label = E)),
      W &&
        ((!Y || !Y.native) && (Me.id = void 0),
        (Me["aria-describedby"] = void 0));
    const [H, pe] = Ar("root", {
        elementType: fY,
        shouldForwardComponentProp: !0,
        externalForwardedProps: { ...We, ...oe },
        ownerState: J,
        className: In(ae.root, a),
        ref: n,
        additionalProps: {
          disabled: d,
          error: h,
          fullWidth: g,
          required: $,
          color: l,
          variant: te,
        },
      }),
      [ie, we] = Ar("input", {
        elementType: et,
        externalForwardedProps: We,
        additionalProps: Me,
        ownerState: J,
      }),
      [xe, $e] = Ar("inputLabel", {
        elementType: SX,
        externalForwardedProps: We,
        ownerState: J,
      }),
      [Fe, He] = Ar("htmlInput", {
        elementType: "input",
        externalForwardedProps: We,
        ownerState: J,
      }),
      [Ze, it] = Ar("formHelperText", {
        elementType: lX,
        externalForwardedProps: We,
        ownerState: J,
      }),
      [Tt, V] = Ar("select", {
        elementType: vO,
        externalForwardedProps: We,
        ownerState: J,
      }),
      O = Q.jsx(ie, {
        "aria-describedby": Ie,
        autoComplete: i,
        autoFocus: s,
        defaultValue: f,
        fullWidth: g,
        multiline: L,
        name: N,
        rows: D,
        maxRows: T,
        minRows: A,
        type: G,
        value: X,
        id: Se,
        inputRef: S,
        onBlur: C,
        onChange: I,
        onFocus: k,
        placeholder: R,
        inputProps: He,
        slots: { input: Z.htmlInput ? Fe : void 0 },
        ...we,
      });
    return Q.jsxs(H, {
      ...pe,
      children: [
        E != null &&
          E !== "" &&
          Q.jsx(xe, { htmlFor: Se, id: Ce, ...$e, children: E }),
        W
          ? Q.jsx(Tt, {
              "aria-describedby": Ie,
              id: Se,
              labelId: Ce,
              value: X,
              input: O,
              ...V,
              children: o,
            })
          : O,
        v && Q.jsx(Ze, { id: Ie, ...it, children: v }),
      ],
    });
  }),
  M_ = rO(
    Q.jsx("path", {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16",
    })
  );
function E_(t, e, n) {
  if (!t || !e || !n) return new z();
  const r = t.getBoundingClientRect(),
    i = n.getBoundingClientRect(),
    s = r.left + r.width / 2 - i.left,
    o = r.top + r.height / 2 - i.top,
    a = (s / i.width) * 2 - 1,
    l = -((o / i.height) * 2 - 1),
    f = new z(a, l, 0.5);
  return f.unproject(e), f;
}
function tP({ from: t, to: e, keyTrigger: n, speed: r = 1.5, visible: i }) {
  const s = U.useRef(),
    o = IM(z3, I8),
    a = t || new z(),
    l = e || new z(),
    f = U.useRef(0);
  return (
    U.useEffect(() => {
      f.current = 0;
    }, [n]),
    yN((d, h) => {
      if (!i) return;
      f.current = Math.min(f.current + h * r, 1);
      const p = f.current,
        g = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p,
        v = new z().lerpVectors(a, l, g);
      s.current &&
        (s.current.position.copy(v), (s.current.rotation.z += h * 6));
    }),
    i
      ? Q.jsxs("mesh", {
          ref: s,
          position: a.clone(),
          children: [
            Q.jsx("circleGeometry", { args: [0.03, 32] }),
            Q.jsx("meshBasicMaterial", {
              map: o,
              color: "white",
              transparent: !0,
              toneMapped: !1,
            }),
          ],
        })
      : null
  );
}
function hY() {
  const t = Ow(),
    { tnxSts: e, tnxBlock: n, confirmblock: r } = fr((H) => H.tx),
    { tnxRace: i } = fr((H) => H.miners),
    {
      attacker: s,
      friend: o,
      merchant: a,
      paymentSts: l,
    } = fr((H) => H.balance),
    { enableReveal: f, othertnxmining: d } = fr((H) => H.miners),
    h = U.useRef(null),
    p = U.useRef(null),
    g = U.useRef(null),
    v = U.useRef(null),
    _ = U.useRef(null),
    [x, m] = U.useState(""),
    [w, S] = U.useState(!1),
    [E, T] = U.useState(""),
    [A, L] = U.useState(""),
    [N, C] = U.useState(!1),
    [I, k] = U.useState(!1),
    [R, $] = U.useState(!1),
    [D, W] = U.useState(0),
    [Y, Z] = U.useState(!1),
    [B, G] = U.useState(!1),
    [X, te] = U.useState(!1),
    [oe, J] = U.useState({
      coinA_from: new z(),
      coinA_to: new z(),
      coinB_from: new z(),
      coinB_to: new z(),
    }),
    [ae, Se] = U.useState(!1),
    Ie = U.useRef(),
    Ce = U.useRef(s);
  U.useEffect(() => {
    n &&
      (Z(!0),
      setTimeout(() => {
        Z(!1);
      }, 2e3));
  }, [n]),
    U.useEffect(() => {
      r &&
        (console.log("CONFIRM", r),
        G(!0),
        setTimeout(() => {
          G(!1);
        }, 2e3));
    }, [r]),
    U.useEffect(() => {
      Ce.current !== s && (Ce.current !== void 0 && C(!0), (Ce.current = s));
    }, [s]);
  const et = (H, pe) => {
      if (!p.current || !g.current || !v.current || !H || !pe) return;
      const ie = E_(p.current, H, pe),
        we = E_(g.current, H, pe),
        xe = E_(v.current, H, pe);
      J({
        coinA_from: ie.clone(),
        coinA_to: we.clone(),
        coinB_from: ie.clone(),
        coinB_to: xe.clone(),
      });
    },
    We = () => {
      if (!x || parseInt(x) <= 0) {
        S(!0), T("Please enter valid amount");
        return;
      }
      L("Attacker try to attempt double spending "),
        !(!Ie.current || !_.current) &&
          (et(Ie.current, _.current),
          Se(!0),
          W((H) => H + 1),
          setTimeout(() => {
            Se(!1), t(yz()), t(Oz(parseInt(x)));
          }, 3800));
    };
  U.useEffect(() => {
    i && k(!0),
      setTimeout(() => {
        k(!1);
      }, 3800);
  }, [i]),
    U.useEffect(() => {
      l === "credited" &&
        ($(!0),
        setTimeout(() => {
          $(!1);
        }, 3e3));
    }, [l]);
  function Me() {
    const { camera: H, gl: pe } = io();
    return (
      U.useEffect(() => {
        (Ie.current = H), (_.current = pe.domElement), et(H, pe.domElement);
      }, [H, pe]),
      null
    );
  }
  const Le = (H) => {
    S(!1), T("");
    let pe = H.target.value;
    if (parseInt(pe) > s) {
      S(!0), T("Insufficent Balance");
      return;
    }
    (pe = pe.replace(/\D/g, "")), pe === "0" && (pe = ""), m(pe);
  };
  return Q.jsxs("div", {
    ref: h,
    className:
      "relative w-full mt-6 min-h-[300px] sm:min-h-[500px] md:min-h-[600px] lg:min-h-[430px]",
    children: [
      Q.jsxs(x8, {
        ref: _,
        style: {
          position: "absolute",
          inset: 0,
          zIndex: 0,
          pointerEvents: "none",
        },
        camera: { position: [0, 0, 10], fov: 50 },
        children: [
          Q.jsx("ambientLight", { intensity: 0.8 }),
          Q.jsx("directionalLight", { position: [10, 10, 10], intensity: 0.6 }),
          Q.jsxs(U.Suspense, {
            fallback: null,
            children: [
              Q.jsx(Me, {}),
              Q.jsx(tP, {
                from: oe.coinA_from,
                to: oe.coinA_to,
                visible: ae,
                keyTrigger: D,
                speed: 0.2,
              }),
              Q.jsx(tP, {
                from: oe.coinB_from,
                to: oe.coinB_to,
                visible: ae,
                keyTrigger: D,
                speed: 0.2,
              }),
            ],
          }),
          Q.jsx(C8, { enableZoom: !1, enablePan: !1, enableRotate: !1 }),
        ],
      }),
      Q.jsxs("div", {
        ref: p,
        className:
          "absolute left-1/2 top-2 transform -translate-x-1/2 flex flex-col items-center z-10 max-w-[90%]",
        children: [
          Q.jsx("img", {
            src: R8,
            className:
              "w-10 sm:w-10 md:w-15 lg:w-20 h-10 sm:h-16 md:h-15 lg:h-20 rounded-full",
            alt: "attacker",
          }),
          Q.jsx(ro, {
            variant: "subtitle2",
            component: "div",
            className: "mt-1 sm:mt-2 text-center text-black",
            sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
            children: "Attacker",
          }),
          Q.jsxs("div", {
            className: "flex items-center gap-1 mt-1 sm:mt-2",
            children: [
              Q.jsx(M_, {
                fontSize: "small",
                className: N ? "text-red-500" : "text-green-500",
              }),
              Q.jsx(ro, {
                variant: "subtitle2",
                component: "div",
                sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
                children: s,
              }),
            ],
          }),
          Q.jsxs("div", {
            className: "mt-4 sm:mt-6 flex flex-col items-center gap-2 w-full",
            children: [
              Q.jsx(dY, {
                error: w,
                helperText: E,
                label: "Enter amount",
                value: x,
                onChange: Le,
                variant: "outlined",
                size: "small",
                placeholder: "Enter amount",
                sx: { width: { xs: "100px", sm: "120px", md: "140px" } },
                inputProps: { inputMode: "numeric", pattern: "[0-9]*" },
              }),
              Q.jsx("button", {
                disabled: e,
                className:
                  "w-full sm:w-auto px-3 md:px-4 py-1.5 md:py-2 bg-blue-600 text-white rounded text-xs sm:text-sm md:text-base",
                onClick: We,
                children: "Send Money",
              }),
              f &&
                Q.jsx("button", {
                  className:
                    "w-full sm:w-auto px-3 md:px-4 py-1.5 md:py-2 bg-red-600 text-white rounded text-xs sm:text-sm md:text-base",
                  onClick: () => t(Az()),
                  children: "Reveal Secret Chain",
                }),
              Q.jsx("div", {
                style: {
                  backgroundColor:
                    Y || B
                      ? "green"
                      : ae
                      ? "rgba(231, 110, 110, 1)"
                      : I || d
                      ? "#4d8bffff"
                      : "",
                },
                className:
                  "mt-2 w-full3  bg-gray-100 border border-gray-300 shadow-md rounded-lg p-1 sm:p-2 text-center",
                children: Q.jsx(ro, {
                  variant: "body2",
                  component: "div",
                  className:
                    ae || I || d || Y || B ? "text-white" : "text-gray-800",
                  sx: {
                    fontSize: { xs: 10, sm: 12, md: 14, lg: 20 },
                    lineHeight: 1.2,
                  },
                  children: ae
                    ? "Attacker try to attempt double spending.."
                    : I
                    ? "Miners start racing for mine the attacker transaction"
                    : Y
                    ? "First block addedd"
                    : B
                    ? "Confirmation block added"
                    : d
                    ? "Miners mining other transactions"
                    : "Enter amount and click Send Money",
                }),
              }),
            ],
          }),
        ],
      }),
      Q.jsxs("div", {
        ref: v,
        className:
          "absolute right-1 sm:right-5 md:right-2 top-2 flex flex-col items-right z-10 max-w-[40%] sm:max-w-none",
        children: [
          Q.jsx("img", {
            src: L8,
            className:
              "w-12 sm:w-16 md:w-15 lg:w-20 h-12 sm:h-16 md:h-15 lg:h-20 rounded-full",
            alt: "friend",
          }),
          Q.jsx(ro, {
            variant: "subtitle2",
            component: "div",
            className: "mt-1 sm:mt-2 text-right text-black",
            sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
            children: "Attacker Wallet",
          }),
          Q.jsxs("div", {
            className: "flex items-right gap-1 mt-1",
            children: [
              Q.jsx(M_, { fontSize: "small", className: "text-green-500" }),
              Q.jsx(ro, {
                variant: "subtitle2",
                component: "div",
                sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
                children: o,
              }),
            ],
          }),
        ],
      }),
      Q.jsxs("div", {
        ref: g,
        className:
          "absolute left-2 sm:left-5 md:left-2 top-2 flex flex-col items-left z-10 max-w-[40%] sm:max-w-none",
        children: [
          Q.jsx("img", {
            src: P8,
            className:
              "w-12 sm:w-16 md:w-15 lg:w-20 h-12 sm:h-16 md:h-15  lg:h-20 rounded-full",
            alt: "merchant",
          }),
          Q.jsx(ro, {
            variant: "subtitle2",
            component: "div",
            className: "mt-1 sm:mt-2 text-left text-black",
            sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
            children: "Merchant",
          }),
          Q.jsxs("div", {
            className: "flex items-center gap-1 mt-1",
            children: [
              Q.jsx(M_, { fontSize: "small", className: "text-green-500" }),
              Q.jsx(ro, {
                variant: "subtitle2",
                component: "div",
                sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
                children: a,
              }),
            ],
          }),
          Q.jsxs("div", {
            className: "flex gap-1 mt-1",
            children: [
              e &&
                l === "idle" &&
                Q.jsx(ro, {
                  variant: "subtitle2",
                  component: "div",
                  className: "text-yellow-500 text-left",
                  sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
                  children: "Merchant wait for the confirmations",
                }),
              R &&
                Q.jsx(ro, {
                  variant: "subtitle2",
                  component: "div",
                  className: "text-green-500 text-left",
                  sx: { fontSize: { xs: 10, sm: 12, md: 14, lg: 20 } },
                  children: "Payment Confirmed",
                }),
            ],
          }),
        ],
      }),
    ],
  });
}
function pY() {
  fr((x) => x.balance), fr((x) => x.chain);
  const t = fr((x) => x.tx),
    [e, n] = U.useState(!1),
    [r, i] = U.useState(!1),
    [s, o] = U.useState(!1),
    [a, l] = U.useState(!1),
    [f, d] = U.useState(!1),
    [h, p] = U.useState(null),
    g = U.useRef(null);
  U.useEffect(() => {
    g.current &&
      g.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
  }, [h]),
    U.useEffect(() => {
      t.tnxSts &&
        (setTimeout(() => {
          n(!0), p("thirdmsg");
        }, 3e3),
        setTimeout(() => {
          i(!0), p("fourthmsg");
        }, 3500));
    }, [t.tnxSts]),
    U.useEffect(() => {
      t.confirmblock &&
        (p("confirmblock"),
        setTimeout(() => {
          o(!0), p("fifthhmsg");
        }, 1500),
        setTimeout(() => {
          l(!0), p("sixthhmsg");
        }, 2e3),
        setTimeout(() => {
          d(!0), p("seventhhmsg");
        }, 3e3));
    }, [t.confirmblock]),
    U.useEffect(() => {
      t.honestwins && p("honestwins");
    }, [t.honestwins]);
  const v = "text-yellow-600 font-bold",
    _ = (x) => ({
      className: `font-semibold ${h === x ? v : ""}`,
      ref: h === x ? g : null,
    });
  return Q.jsxs("aside", {
    className:
      "w-full md:w-64 p-4 bg-gray-50 border-l rounded-lg shadow-sm h-64 overflow-y-auto min-h-[469px] lg:min-w-[400px]",
    children: [
      Q.jsx("h3", {
        className: "font-bold mb-4 text-lg",
        children: "Steps to Attempt Double Spending",
      }),
      Q.jsxs("ol", {
        className: "list-decimal list-inside space-y-2 text-gray-700",
        children: [
          Q.jsx("li", {
            className: "font-semibold",
            children:
              'Click "Send" to send the same coin to both the merchant and the attacker (double spend attempt).',
          }),
          t.tnxSts &&
            Q.jsx("li", {
              ..._(null),
              children:
                "Transaction in progress. Merchant is waiting for confirmations.",
            }),
          e &&
            Q.jsx("li", {
              ..._("thirdmsg"),
              children:
                "Merchant keeps watching the honest chain as blocks are added.",
            }),
          r &&
            Q.jsx("li", {
              ..._("fourthmsg"),
              children: "Merchant is waiting for confirmations...",
            }),
          t.confirmblock &&
            Q.jsx("li", {
              ..._("confirmblock"),
              children:
                "4 blocks added to the honest chain after the merchant’s transaction block.",
            }),
          s &&
            Q.jsx("li", {
              ..._("fifthhmsg"),
              children:
                "After the 4th block, the merchant confirms the transaction and credits the coin.",
            }),
          a &&
            Q.jsx("li", {
              ..._("sixthhmsg"),
              children: "Miners continue to add new transactions.",
            }),
          f &&
            Q.jsx("li", {
              ..._("seventhhmsg"),
              children:
                'Click "Reveal Secret Chain" to compare block counts between the honest chain and the secret chain.',
            }),
          t.honestwins &&
            Q.jsx("li", {
              ..._("honestwins"),
              children:
                "Blockchain accepts the honest chain as the valid chain.",
            }),
        ],
      }),
    ],
  });
}
function mY({ color: t, index: e, contains: n }) {
  const r = t === "green" ? "bg-green-500" : "bg-red-500",
    [i, s] = U.useState(!1);
  return (
    U.useEffect(() => {
      const o = setTimeout(() => s(!0), 50);
      return () => clearTimeout(o);
    }, []),
    Q.jsx("div", {
      className: `w-20 h-12 rounded-md p-2 text-white flex items-center justify-center shadow-md transition-all duration-2000 ease-in-out
        ${r}
        ${i ? "opacity-100 translate-x-0" : "opacity-0 translate-x-12"}
      `,
      children: Q.jsxs("div", {
        className: "text-xs",
        children: ["#", e, n ? " • tx" : ""],
      }),
    })
  );
}
function gY({ side: t }) {
  const e = fr((k) =>
      t === "honest" ? k.miners.honestMiners : k.miners.secretMiners
    ),
    { txA: n, txB: r, tnxSts: i } = fr((k) => k.tx),
    { stopMining: s } = fr((k) => k.miners),
    o = Ow(),
    [a, l] = U.useState([]),
    [f, d] = U.useState(!1),
    [h, p] = U.useState(null),
    [g, v] = U.useState(!1),
    [_, x] = U.useState(0),
    [m, w] = U.useState(!1),
    [S, E] = U.useState(!1),
    T = U.useRef(null),
    A = U.useRef(null),
    L = U.useRef(!0);
  U.useRef(!0);
  const N = (k) => {
      const R = [...k];
      for (let $ = R.length - 1; $ > 0; $--) {
        const D = Math.floor(Math.random() * ($ + 1));
        [R[$], R[D]] = [R[D], R[$]];
      }
      return R;
    },
    C = () => {
      !i ||
        g ||
        (L.current && (o(Rz()), (L.current = !1)),
        d(!1),
        p(null),
        l(e.map((k) => ({ ...k, pct: Math.random() * 100 }))),
        (T.current = setInterval(() => {
          l((k) =>
            N(
              k.map((R) => ({
                ...R,
                pct: Math.max(
                  0,
                  Math.min(100, R.pct + (Math.random() - 0.5) * 30)
                ),
              }))
            )
          );
        }, 200)),
        (A.current = setTimeout(
          () => {
            clearInterval(T.current),
              l((k) => {
                const R = [...k].sort((D, W) => W.pct - D.pct),
                  $ = R[0];
                return p(($ == null ? void 0 : $.id) || null), d(!0), R;
              });
          },
          t === "honest" ? 4e3 : 8e3
        )));
    },
    I = () => {
      if (!h) return;
      v(!0);
      const k = {
        id: `${t}-block-${Date.now()}`,
        color: t === "honest" ? "green" : "red",
        contains: null,
      };
      t === "honest"
        ? (o(pz(k)), (n == null ? void 0 : n.status) === "pending" && o(xz()))
        : (o(mz(k)),
          (r == null ? void 0 : r.status) === "pending" &&
            (o(Mz()), o(Nz(100)))),
        x((R) => R + 1),
        setTimeout(
          () => {
            v(!1), p(null), i && C();
          },
          t === "honest" ? 800 : 3e3
        );
    };
  return (
    U.useEffect(() => {
      _ === 1 &&
        (o(wz(!0)),
        setTimeout(() => {
          o(Cz());
        }, 2e3)),
        _ === 4 &&
          t === "honest" &&
          (console.log("HER", _), o(_z(!0)), o(Tz()), o(VL()));
    }, [_, t, o]),
    U.useEffect(() => {
      h && I();
    }, [h]),
    U.useEffect(
      () => (
        i && C(),
        () => {
          clearInterval(T.current), clearTimeout(A.current);
        }
      ),
      [i]
    ),
    U.useEffect(() => {
      o(t === "honest" ? Pz(a) : Lz(a));
    }, [a, t, o]),
    Q.jsxs("div", {
      className: "mt-2",
      children: [
        Q.jsxs("div", {
          className: "text-sm font-medium",
          children: ["Miner Race (", t, ")"],
        }),
        Q.jsxs("div", {
          className: "mt-2",
          children: [
            a.map((k) =>
              Q.jsxs(
                "div",
                {
                  className: `flex justify-between text-xs px-1 py-0.5 rounded ${
                    f && k.id === h ? "bg-yellow-400 text-black font-bold" : ""
                  }`,
                  children: [
                    Q.jsx("div", { children: k.id }),
                    Q.jsxs("div", { children: [Math.round(k.pct), "%"] }),
                  ],
                },
                k.id
              )
            ),
            f &&
              Q.jsx("div", {
                className: "text-xs mt-1",
                children: g
                  ? "Winner is mining new block..."
                  : `Winner chosen: ${h}`,
              }),
          ],
        }),
      ],
    })
  );
}
function nP({ side: t }) {
  const { tnxSts: e } = fr((s) => s.tx),
    n = fr((s) => s.chain),
    r = t === "honest" ? n.honest : n.secret,
    i = t === "honest" ? "green" : "red";
  return Q.jsxs("div", {
    className: "p-4",
    children: [
      Q.jsx("h4", {
        className: "font-semibold mb-2",
        children: t === "honest" ? "Honest Chain" : "Secret Chain",
      }),
      Q.jsx("div", {
        className: "flex gap-2 overflow-x-auto chain-area",
        children: r.map((s, o) =>
          Q.jsx(mY, { color: i, index: o + 1, contains: s.contains }, s.id || o)
        ),
      }),
      e &&
        Q.jsx("div", { className: "mt-3", children: Q.jsx(gY, { side: t }) }),
    ],
  });
}
function vY() {
  const t = Ow(),
    e = fr((N) => N.chain),
    n = fr((N) => N.tx),
    { honest: r, secret: i } = fr((N) => N.chain),
    { tnxSts: s } = fr((N) => N.tx),
    { stopMining: o } = fr((N) => N.miners),
    [a, l] = U.useState(!1),
    [f, d] = U.useState(!1),
    [h, p] = U.useState(50),
    [g, v] = U.useState(50),
    [_, x] = U.useState(!0),
    [m, w] = U.useState(!0);
  U.useEffect(() => {
    if (o) {
      d(!0);
      const N = setInterval(() => {
          const k = Math.floor(Math.random() * 100);
          p(k), v(100 - k);
        }, 200),
        C = setTimeout(() => {
          clearInterval(N);
          const k = r.length + i.length || 1,
            R = Math.round((r.length / k) * 100),
            $ = 100 - R;
          p(R), v($);
        }, 3e3),
        I = setTimeout(() => {
          d(!1), x(!1), t(Sz());
        }, 6e3);
      return () => {
        clearInterval(N), clearTimeout(C), clearTimeout(I);
      };
    }
  }, [o]);
  const [S, E] = U.useState(50),
    [T, A] = U.useState(50);
  U.useEffect(() => {
    if (f) {
      const N = setInterval(() => {
          const I = 45 + Math.random() * 10,
            k = 100 - I;
          E(I), A(k);
        }, 1e3),
        C = setTimeout(() => {
          clearInterval(N);
          const I = r.length + i.length,
            k = I ? (r.length / I) * 100 : 50,
            R = I ? (i.length / I) * 100 : 50;
          E(R), A(k);
        }, 3e3);
      return () => {
        clearInterval(N), clearTimeout(C);
      };
    }
  }, [f, r.length, i.length]),
    U.useEffect(() => {
      if (n.txA && n.txA.includedAt) {
        const N = n.txA.includedAt + 4;
        e.honest.length >= N &&
          n.txA.status !== "credited" &&
          (t(VL(100)), t(Ez()));
      }
    }, [e.honest.length, n.txA]),
    U.useEffect(() => {
      e.honest.length >= 10 && l(!0);
    }, [e.honest.length]);
  function L() {
    t(gz()), l(!1);
  }
  return m
    ? Q.jsx("div", {
        className:
          "h-screen w-screen flex items-center justify-center bg-gradient-to-br from-gray-100 to-gray-200 p-4",
        children: Q.jsxs("div", {
          className:
            "bg-white p-8 md:p-10 rounded-3xl shadow-2xl max-w-md w-full text-center",
          children: [
            Q.jsx("h1", {
              className: "text-3xl md:text-4xl font-bold text-gray-800 mb-6",
              children: "Double Spending Prevention Simulation",
            }),
            Q.jsxs("ul", {
              className:
                "text-gray-700 text-sm md:text-base leading-relaxed mb-6 space-y-4 text-left",
              children: [
                Q.jsxs("li", {
                  className: "flex items-start",
                  children: [
                    Q.jsx("span", {
                      className: "text-blue-500 mr-2 mt-1 text-lg",
                      children: "•",
                    }),
                    "This simulation shows how blockchain prevents double spending.",
                  ],
                }),
                Q.jsxs("li", {
                  className: "flex items-start",
                  children: [
                    Q.jsx("span", {
                      className: "text-blue-500 mr-2 mt-1 text-lg",
                      children: "•",
                    }),
                    "The honest chain has more miners and grows faster than the attacker’s secret chain.",
                  ],
                }),
                Q.jsxs("li", {
                  className: "flex items-start",
                  children: [
                    Q.jsx("span", {
                      className: "text-blue-500 mr-2 mt-1 text-lg",
                      children: "•",
                    }),
                    "When the attacker reveals their secret chain, the system compares both chains.",
                  ],
                }),
                Q.jsxs("li", {
                  className: "flex items-start",
                  children: [
                    Q.jsx("span", {
                      className: "text-blue-500 mr-2 mt-1 text-lg",
                      children: "•",
                    }),
                    "The longer honest chain stays valid, blocking any double spending attempt.",
                  ],
                }),
              ],
            }),
            Q.jsx("button", {
              onClick: () => w(!1),
              className:
                "bg-blue-600 hover:bg-blue-700 text-white font-semibold px-6 py-2 rounded-xl shadow-md transition transform hover:scale-105",
              children: "Go to Simulation",
            }),
          ],
        }),
      })
    : Q.jsx("div", {
        className: "h-screen w-screen flex flex-col relative",
        children: Q.jsx("main", {
          className: "flex-1 flex flex-col",
          children: Q.jsx("div", {
            className: "flex-1 p-6 relative",
            children: Q.jsxs("div", {
              className: "flex flex-col lg:flex-1 lg:flex lg:flex-col gap-4",
              children: [
                Q.jsxs("div", {
                  className: "flex flex-col md:flex-row gap-4",
                  children: [
                    Q.jsx("div", {
                      className:
                        "bg-gray-300 w-full h-auto min-h-fit p-2 rounded",
                      children: Q.jsx(hY, { revealEnabled: a, onReveal: L }),
                    }),
                    Q.jsx("div", {
                      className: "w-full md:w-96",
                      children: Q.jsx(pY, {}),
                    }),
                  ],
                }),
                Q.jsxs("div", {
                  className: "flex flex-col md:flex-row gap-4 mt-6 relative",
                  children: [
                    Q.jsx("div", {
                      className:
                        "bg-green-100 rounded shadow transition-all duration-1000 ease-in-out overflow-y-auto",
                      style: { width: "100%", padding: "1rem" },
                      children: Q.jsx(nP, { side: "honest" }),
                    }),
                    Q.jsx("div", {
                      className:
                        "bg-red-100 rounded shadow overflow-hidden transition-all duration-1000 ease-in-out",
                      style: {
                        width: _ ? "100%" : "0%",
                        padding: _ ? "1rem" : "0",
                        opacity: _ ? 1 : 0,
                      },
                      children: Q.jsx(nP, { side: "secret" }),
                    }),
                    f &&
                      Q.jsxs("div", {
                        className:
                          "absolute inset-0 flex flex-col items-center justify-center bg-black/40 backdrop-blur-sm z-20",
                        children: [
                          Q.jsxs("div", {
                            className:
                              "text-white text-lg font-bold mb-4 flex items-center",
                            children: [
                              "Comparing honest chain and secret chain",
                              Q.jsx("span", {
                                className: "animate-pulse ml-1",
                                children: "...",
                              }),
                            ],
                          }),
                          Q.jsxs("div", {
                            className:
                              "w-3/5 h-10 flex rounded overflow-hidden shadow-lg border border-gray-300",
                            children: [
                              Q.jsxs("div", {
                                className:
                                  "bg-green-500 flex items-center justify-center text-xs font-bold text-white transition-all duration-800 ease-in-out",
                                style: { width: `${T}%` },
                                children: [Math.round(T), "%"],
                              }),
                              Q.jsxs("div", {
                                className:
                                  "bg-red-500 flex items-center justify-center text-xs font-bold text-white transition-all duration-800 ease-in-out",
                                style: { width: `${S}%` },
                                children: [Math.round(S), "%"],
                              }),
                            ],
                          }),
                          Q.jsxs("div", {
                            className:
                              "flex justify-between w-3/5 mt-2 text-white text-sm font-semibold",
                            children: [
                              Q.jsxs("span", {
                                children: ["Honest: ", r.length],
                              }),
                              Q.jsxs("span", {
                                children: ["Secret: ", i.length],
                              }),
                            ],
                          }),
                        ],
                      }),
                  ],
                }),
              ],
            }),
          }),
        }),
      });
}
mL(document.getElementById("root")).render(
  Q.jsx(ol.StrictMode, {
    children: Q.jsx(EF, { store: kz, children: Q.jsx(vY, {}) }),
  })
);
