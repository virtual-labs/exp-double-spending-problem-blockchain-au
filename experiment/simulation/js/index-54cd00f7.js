function _mergeNamespaces(tt, et) {
  for (var nt = 0; nt < et.length; nt++) {
    const rt = et[nt];
    if (typeof rt != "string" && !Array.isArray(rt)) {
      for (const it in rt)
        if (it !== "default" && !(it in tt)) {
          const st = Object.getOwnPropertyDescriptor(rt, it);
          st &&
            Object.defineProperty(
              tt,
              it,
              st.get ? st : { enumerable: !0, get: () => rt[it] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(tt, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const et = document.createElement("link").relList;
  if (et && et.supports && et.supports("modulepreload")) return;
  for (const it of document.querySelectorAll('link[rel="modulepreload"]'))
    rt(it);
  new MutationObserver((it) => {
    for (const st of it)
      if (st.type === "childList")
        for (const ot of st.addedNodes)
          ot.tagName === "LINK" && ot.rel === "modulepreload" && rt(ot);
  }).observe(document, { childList: !0, subtree: !0 });
  function nt(it) {
    const st = {};
    return (
      it.integrity && (st.integrity = it.integrity),
      it.referrerPolicy && (st.referrerPolicy = it.referrerPolicy),
      it.crossOrigin === "use-credentials"
        ? (st.credentials = "include")
        : it.crossOrigin === "anonymous"
        ? (st.credentials = "omit")
        : (st.credentials = "same-origin"),
      st
    );
  }
  function rt(it) {
    if (it.ep) return;
    it.ep = !0;
    const st = nt(it);
    fetch(it.href, st);
  }
})();
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getDefaultExportFromCjs(tt) {
  return tt &&
    tt.__esModule &&
    Object.prototype.hasOwnProperty.call(tt, "default")
    ? tt.default
    : tt;
}
var react = { exports: {} },
  react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l$5 = Symbol.for("react.element"),
  n$6 = Symbol.for("react.portal"),
  p$7 = Symbol.for("react.fragment"),
  q$7 = Symbol.for("react.strict_mode"),
  r$5 = Symbol.for("react.profiler"),
  t$5 = Symbol.for("react.provider"),
  u$4 = Symbol.for("react.context"),
  v$6 = Symbol.for("react.forward_ref"),
  w$4 = Symbol.for("react.suspense"),
  x$3 = Symbol.for("react.memo"),
  y$3 = Symbol.for("react.lazy"),
  z$4 = Symbol.iterator;
function A$3(tt) {
  return tt === null || typeof tt != "object"
    ? null
    : ((tt = (z$4 && tt[z$4]) || tt["@@iterator"]),
      typeof tt == "function" ? tt : null);
}
var B$3 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  C$2 = Object.assign,
  D$3 = {};
function E$3(tt, et, nt) {
  (this.props = tt),
    (this.context = et),
    (this.refs = D$3),
    (this.updater = nt || B$3);
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function (tt, et) {
  if (typeof tt != "object" && typeof tt != "function" && tt != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, tt, et, "setState");
};
E$3.prototype.forceUpdate = function (tt) {
  this.updater.enqueueForceUpdate(this, tt, "forceUpdate");
};
function F$2() {}
F$2.prototype = E$3.prototype;
function G$3(tt, et, nt) {
  (this.props = tt),
    (this.context = et),
    (this.refs = D$3),
    (this.updater = nt || B$3);
}
var H$3 = (G$3.prototype = new F$2());
H$3.constructor = G$3;
C$2(H$3, E$3.prototype);
H$3.isPureReactComponent = !0;
var I$3 = Array.isArray,
  J$1 = Object.prototype.hasOwnProperty,
  K$2 = { current: null },
  L$3 = { key: !0, ref: !0, __self: !0, __source: !0 };
function M$3(tt, et, nt) {
  var rt,
    it = {},
    st = null,
    ot = null;
  if (et != null)
    for (rt in (et.ref !== void 0 && (ot = et.ref),
    et.key !== void 0 && (st = "" + et.key),
    et))
      J$1.call(et, rt) && !L$3.hasOwnProperty(rt) && (it[rt] = et[rt]);
  var at = arguments.length - 2;
  if (at === 1) it.children = nt;
  else if (1 < at) {
    for (var lt = Array(at), ct = 0; ct < at; ct++) lt[ct] = arguments[ct + 2];
    it.children = lt;
  }
  if (tt && tt.defaultProps)
    for (rt in ((at = tt.defaultProps), at))
      it[rt] === void 0 && (it[rt] = at[rt]);
  return {
    $$typeof: l$5,
    type: tt,
    key: st,
    ref: ot,
    props: it,
    _owner: K$2.current,
  };
}
function N$3(tt, et) {
  return {
    $$typeof: l$5,
    type: tt.type,
    key: et,
    ref: tt.ref,
    props: tt.props,
    _owner: tt._owner,
  };
}
function O$2(tt) {
  return typeof tt == "object" && tt !== null && tt.$$typeof === l$5;
}
function escape$1(tt) {
  var et = { "=": "=0", ":": "=2" };
  return (
    "$" +
    tt.replace(/[=:]/g, function (nt) {
      return et[nt];
    })
  );
}
var P$2 = /\/+/g;
function Q$3(tt, et) {
  return typeof tt == "object" && tt !== null && tt.key != null
    ? escape$1("" + tt.key)
    : et.toString(36);
}
function R$2(tt, et, nt, rt, it) {
  var st = typeof tt;
  (st === "undefined" || st === "boolean") && (tt = null);
  var ot = !1;
  if (tt === null) ot = !0;
  else
    switch (st) {
      case "string":
      case "number":
        ot = !0;
        break;
      case "object":
        switch (tt.$$typeof) {
          case l$5:
          case n$6:
            ot = !0;
        }
    }
  if (ot)
    return (
      (ot = tt),
      (it = it(ot)),
      (tt = rt === "" ? "." + Q$3(ot, 0) : rt),
      I$3(it)
        ? ((nt = ""),
          tt != null && (nt = tt.replace(P$2, "$&/") + "/"),
          R$2(it, et, nt, "", function (ct) {
            return ct;
          }))
        : it != null &&
          (O$2(it) &&
            (it = N$3(
              it,
              nt +
                (!it.key || (ot && ot.key === it.key)
                  ? ""
                  : ("" + it.key).replace(P$2, "$&/") + "/") +
                tt
            )),
          et.push(it)),
      1
    );
  if (((ot = 0), (rt = rt === "" ? "." : rt + ":"), I$3(tt)))
    for (var at = 0; at < tt.length; at++) {
      st = tt[at];
      var lt = rt + Q$3(st, at);
      ot += R$2(st, et, nt, lt, it);
    }
  else if (((lt = A$3(tt)), typeof lt == "function"))
    for (tt = lt.call(tt), at = 0; !(st = tt.next()).done; )
      (st = st.value),
        (lt = rt + Q$3(st, at++)),
        (ot += R$2(st, et, nt, lt, it));
  else if (st === "object")
    throw (
      ((et = String(tt)),
      Error(
        "Objects are not valid as a React child (found: " +
          (et === "[object Object]"
            ? "object with keys {" + Object.keys(tt).join(", ") + "}"
            : et) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return ot;
}
function S$3(tt, et, nt) {
  if (tt == null) return tt;
  var rt = [],
    it = 0;
  return (
    R$2(tt, rt, "", "", function (st) {
      return et.call(nt, st, it++);
    }),
    rt
  );
}
function T$2(tt) {
  if (tt._status === -1) {
    var et = tt._result;
    (et = et()),
      et.then(
        function (nt) {
          (tt._status === 0 || tt._status === -1) &&
            ((tt._status = 1), (tt._result = nt));
        },
        function (nt) {
          (tt._status === 0 || tt._status === -1) &&
            ((tt._status = 2), (tt._result = nt));
        }
      ),
      tt._status === -1 && ((tt._status = 0), (tt._result = et));
  }
  if (tt._status === 1) return tt._result.default;
  throw tt._result;
}
var U$3 = { current: null },
  V$2 = { transition: null },
  W$3 = {
    ReactCurrentDispatcher: U$3,
    ReactCurrentBatchConfig: V$2,
    ReactCurrentOwner: K$2,
  };
react_production_min.Children = {
  map: S$3,
  forEach: function (tt, et, nt) {
    S$3(
      tt,
      function () {
        et.apply(this, arguments);
      },
      nt
    );
  },
  count: function (tt) {
    var et = 0;
    return (
      S$3(tt, function () {
        et++;
      }),
      et
    );
  },
  toArray: function (tt) {
    return (
      S$3(tt, function (et) {
        return et;
      }) || []
    );
  },
  only: function (tt) {
    if (!O$2(tt))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return tt;
  },
};
react_production_min.Component = E$3;
react_production_min.Fragment = p$7;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$7;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
react_production_min.cloneElement = function (tt, et, nt) {
  if (tt == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        tt +
        "."
    );
  var rt = C$2({}, tt.props),
    it = tt.key,
    st = tt.ref,
    ot = tt._owner;
  if (et != null) {
    if (
      (et.ref !== void 0 && ((st = et.ref), (ot = K$2.current)),
      et.key !== void 0 && (it = "" + et.key),
      tt.type && tt.type.defaultProps)
    )
      var at = tt.type.defaultProps;
    for (lt in et)
      J$1.call(et, lt) &&
        !L$3.hasOwnProperty(lt) &&
        (rt[lt] = et[lt] === void 0 && at !== void 0 ? at[lt] : et[lt]);
  }
  var lt = arguments.length - 2;
  if (lt === 1) rt.children = nt;
  else if (1 < lt) {
    at = Array(lt);
    for (var ct = 0; ct < lt; ct++) at[ct] = arguments[ct + 2];
    rt.children = at;
  }
  return {
    $$typeof: l$5,
    type: tt.type,
    key: it,
    ref: st,
    props: rt,
    _owner: ot,
  };
};
react_production_min.createContext = function (tt) {
  return (
    (tt = {
      $$typeof: u$4,
      _currentValue: tt,
      _currentValue2: tt,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (tt.Provider = { $$typeof: t$5, _context: tt }),
    (tt.Consumer = tt)
  );
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function (tt) {
  var et = M$3.bind(null, tt);
  return (et.type = tt), et;
};
react_production_min.createRef = function () {
  return { current: null };
};
react_production_min.forwardRef = function (tt) {
  return { $$typeof: v$6, render: tt };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function (tt) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: tt }, _init: T$2 };
};
react_production_min.memo = function (tt, et) {
  return { $$typeof: x$3, type: tt, compare: et === void 0 ? null : et };
};
react_production_min.startTransition = function (tt) {
  var et = V$2.transition;
  V$2.transition = {};
  try {
    tt();
  } finally {
    V$2.transition = et;
  }
};
react_production_min.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function (tt, et) {
  return U$3.current.useCallback(tt, et);
};
react_production_min.useContext = function (tt) {
  return U$3.current.useContext(tt);
};
react_production_min.useDebugValue = function () {};
react_production_min.useDeferredValue = function (tt) {
  return U$3.current.useDeferredValue(tt);
};
react_production_min.useEffect = function (tt, et) {
  return U$3.current.useEffect(tt, et);
};
react_production_min.useId = function () {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function (tt, et, nt) {
  return U$3.current.useImperativeHandle(tt, et, nt);
};
react_production_min.useInsertionEffect = function (tt, et) {
  return U$3.current.useInsertionEffect(tt, et);
};
react_production_min.useLayoutEffect = function (tt, et) {
  return U$3.current.useLayoutEffect(tt, et);
};
react_production_min.useMemo = function (tt, et) {
  return U$3.current.useMemo(tt, et);
};
react_production_min.useReducer = function (tt, et, nt) {
  return U$3.current.useReducer(tt, et, nt);
};
react_production_min.useRef = function (tt) {
  return U$3.current.useRef(tt);
};
react_production_min.useState = function (tt) {
  return U$3.current.useState(tt);
};
react_production_min.useSyncExternalStore = function (tt, et, nt) {
  return U$3.current.useSyncExternalStore(tt, et, nt);
};
react_production_min.useTransition = function () {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
react.exports = react_production_min;
var reactExports = react.exports;
const React = getDefaultExportFromCjs(reactExports),
  React$1 = _mergeNamespaces({ __proto__: null, default: React }, [
    reactExports,
  ]);
var client = {},
  reactDom = { exports: {} },
  reactDom_production_min = {},
  scheduler$1 = { exports: {} },
  scheduler_production_min$1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (tt) {
  function et(Pt, Rt) {
    var Nt = Pt.length;
    Pt.push(Rt);
    e: for (; 0 < Nt; ) {
      var Dt = (Nt - 1) >>> 1,
        zt = Pt[Dt];
      if (0 < it(zt, Rt)) (Pt[Dt] = Rt), (Pt[Nt] = zt), (Nt = Dt);
      else break e;
    }
  }
  function nt(Pt) {
    return Pt.length === 0 ? null : Pt[0];
  }
  function rt(Pt) {
    if (Pt.length === 0) return null;
    var Rt = Pt[0],
      Nt = Pt.pop();
    if (Nt !== Rt) {
      Pt[0] = Nt;
      e: for (var Dt = 0, zt = Pt.length, Yt = zt >>> 1; Dt < Yt; ) {
        var qt = 2 * (Dt + 1) - 1,
          Zt = Pt[qt],
          Jt = qt + 1,
          mn = Pt[Jt];
        if (0 > it(Zt, Nt))
          Jt < zt && 0 > it(mn, Zt)
            ? ((Pt[Dt] = mn), (Pt[Jt] = Nt), (Dt = Jt))
            : ((Pt[Dt] = Zt), (Pt[qt] = Nt), (Dt = qt));
        else if (Jt < zt && 0 > it(mn, Nt))
          (Pt[Dt] = mn), (Pt[Jt] = Nt), (Dt = Jt);
        else break e;
      }
    }
    return Rt;
  }
  function it(Pt, Rt) {
    var Nt = Pt.sortIndex - Rt.sortIndex;
    return Nt !== 0 ? Nt : Pt.id - Rt.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var st = performance;
    tt.unstable_now = function () {
      return st.now();
    };
  } else {
    var ot = Date,
      at = ot.now();
    tt.unstable_now = function () {
      return ot.now() - at;
    };
  }
  var lt = [],
    ct = [],
    ut = 1,
    ft = null,
    ht = 3,
    mt = !1,
    vt = !1,
    yt = !1,
    Et = typeof setTimeout == "function" ? setTimeout : null,
    pt = typeof clearTimeout == "function" ? clearTimeout : null,
    xt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function St(Pt) {
    for (var Rt = nt(ct); Rt !== null; ) {
      if (Rt.callback === null) rt(ct);
      else if (Rt.startTime <= Pt)
        rt(ct), (Rt.sortIndex = Rt.expirationTime), et(lt, Rt);
      else break;
      Rt = nt(ct);
    }
  }
  function At(Pt) {
    if (((yt = !1), St(Pt), !vt))
      if (nt(lt) !== null) (vt = !0), kt(Ct);
      else {
        var Rt = nt(ct);
        Rt !== null && Gt(At, Rt.startTime - Pt);
      }
  }
  function Ct(Pt, Rt) {
    (vt = !1), yt && ((yt = !1), pt(Bt), (Bt = -1)), (mt = !0);
    var Nt = ht;
    try {
      for (
        St(Rt), ft = nt(lt);
        ft !== null && (!(ft.expirationTime > Rt) || (Pt && !Vt()));

      ) {
        var Dt = ft.callback;
        if (typeof Dt == "function") {
          (ft.callback = null), (ht = ft.priorityLevel);
          var zt = Dt(ft.expirationTime <= Rt);
          (Rt = tt.unstable_now()),
            typeof zt == "function"
              ? (ft.callback = zt)
              : ft === nt(lt) && rt(lt),
            St(Rt);
        } else rt(lt);
        ft = nt(lt);
      }
      if (ft !== null) var Yt = !0;
      else {
        var qt = nt(ct);
        qt !== null && Gt(At, qt.startTime - Rt), (Yt = !1);
      }
      return Yt;
    } finally {
      (ft = null), (ht = Nt), (mt = !1);
    }
  }
  var Mt = !1,
    wt = null,
    Bt = -1,
    It = 5,
    Ft = -1;
  function Vt() {
    return !(tt.unstable_now() - Ft < It);
  }
  function $t() {
    if (wt !== null) {
      var Pt = tt.unstable_now();
      Ft = Pt;
      var Rt = !0;
      try {
        Rt = wt(!0, Pt);
      } finally {
        Rt ? Kt() : ((Mt = !1), (wt = null));
      }
    } else Mt = !1;
  }
  var Kt;
  if (typeof xt == "function")
    Kt = function () {
      xt($t);
    };
  else if (typeof MessageChannel < "u") {
    var Ht = new MessageChannel(),
      Wt = Ht.port2;
    (Ht.port1.onmessage = $t),
      (Kt = function () {
        Wt.postMessage(null);
      });
  } else
    Kt = function () {
      Et($t, 0);
    };
  function kt(Pt) {
    (wt = Pt), Mt || ((Mt = !0), Kt());
  }
  function Gt(Pt, Rt) {
    Bt = Et(function () {
      Pt(tt.unstable_now());
    }, Rt);
  }
  (tt.unstable_IdlePriority = 5),
    (tt.unstable_ImmediatePriority = 1),
    (tt.unstable_LowPriority = 4),
    (tt.unstable_NormalPriority = 3),
    (tt.unstable_Profiling = null),
    (tt.unstable_UserBlockingPriority = 2),
    (tt.unstable_cancelCallback = function (Pt) {
      Pt.callback = null;
    }),
    (tt.unstable_continueExecution = function () {
      vt || mt || ((vt = !0), kt(Ct));
    }),
    (tt.unstable_forceFrameRate = function (Pt) {
      0 > Pt || 125 < Pt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (It = 0 < Pt ? Math.floor(1e3 / Pt) : 5);
    }),
    (tt.unstable_getCurrentPriorityLevel = function () {
      return ht;
    }),
    (tt.unstable_getFirstCallbackNode = function () {
      return nt(lt);
    }),
    (tt.unstable_next = function (Pt) {
      switch (ht) {
        case 1:
        case 2:
        case 3:
          var Rt = 3;
          break;
        default:
          Rt = ht;
      }
      var Nt = ht;
      ht = Rt;
      try {
        return Pt();
      } finally {
        ht = Nt;
      }
    }),
    (tt.unstable_pauseExecution = function () {}),
    (tt.unstable_requestPaint = function () {}),
    (tt.unstable_runWithPriority = function (Pt, Rt) {
      switch (Pt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Pt = 3;
      }
      var Nt = ht;
      ht = Pt;
      try {
        return Rt();
      } finally {
        ht = Nt;
      }
    }),
    (tt.unstable_scheduleCallback = function (Pt, Rt, Nt) {
      var Dt = tt.unstable_now();
      switch (
        (typeof Nt == "object" && Nt !== null
          ? ((Nt = Nt.delay),
            (Nt = typeof Nt == "number" && 0 < Nt ? Dt + Nt : Dt))
          : (Nt = Dt),
        Pt)
      ) {
        case 1:
          var zt = -1;
          break;
        case 2:
          zt = 250;
          break;
        case 5:
          zt = 1073741823;
          break;
        case 4:
          zt = 1e4;
          break;
        default:
          zt = 5e3;
      }
      return (
        (zt = Nt + zt),
        (Pt = {
          id: ut++,
          callback: Rt,
          priorityLevel: Pt,
          startTime: Nt,
          expirationTime: zt,
          sortIndex: -1,
        }),
        Nt > Dt
          ? ((Pt.sortIndex = Nt),
            et(ct, Pt),
            nt(lt) === null &&
              Pt === nt(ct) &&
              (yt ? (pt(Bt), (Bt = -1)) : (yt = !0), Gt(At, Nt - Dt)))
          : ((Pt.sortIndex = zt), et(lt, Pt), vt || mt || ((vt = !0), kt(Ct))),
        Pt
      );
    }),
    (tt.unstable_shouldYield = Vt),
    (tt.unstable_wrapCallback = function (Pt) {
      var Rt = ht;
      return function () {
        var Nt = ht;
        ht = Rt;
        try {
          return Pt.apply(this, arguments);
        } finally {
          ht = Nt;
        }
      };
    });
})(scheduler_production_min$1);
scheduler$1.exports = scheduler_production_min$1;
var schedulerExports$1 = scheduler$1.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aa = reactExports,
  ca = schedulerExports$1;
function p$6(tt) {
  for (
    var et = "https://reactjs.org/docs/error-decoder.html?invariant=" + tt,
      nt = 1;
    nt < arguments.length;
    nt++
  )
    et += "&args[]=" + encodeURIComponent(arguments[nt]);
  return (
    "Minified React error #" +
    tt +
    "; visit " +
    et +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var da = new Set(),
  ea = {};
function fa(tt, et) {
  ha(tt, et), ha(tt + "Capture", et);
}
function ha(tt, et) {
  for (ea[tt] = et, tt = 0; tt < et.length; tt++) da.add(et[tt]);
}
var ia = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ja = Object.prototype.hasOwnProperty,
  ka =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  la = {},
  ma = {};
function oa(tt) {
  return ja.call(ma, tt)
    ? !0
    : ja.call(la, tt)
    ? !1
    : ka.test(tt)
    ? (ma[tt] = !0)
    : ((la[tt] = !0), !1);
}
function pa(tt, et, nt, rt) {
  if (nt !== null && nt.type === 0) return !1;
  switch (typeof et) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return rt
        ? !1
        : nt !== null
        ? !nt.acceptsBooleans
        : ((tt = tt.toLowerCase().slice(0, 5)),
          tt !== "data-" && tt !== "aria-");
    default:
      return !1;
  }
}
function qa(tt, et, nt, rt) {
  if (et === null || typeof et > "u" || pa(tt, et, nt, rt)) return !0;
  if (rt) return !1;
  if (nt !== null)
    switch (nt.type) {
      case 3:
        return !et;
      case 4:
        return et === !1;
      case 5:
        return isNaN(et);
      case 6:
        return isNaN(et) || 1 > et;
    }
  return !1;
}
function v$5(tt, et, nt, rt, it, st, ot) {
  (this.acceptsBooleans = et === 2 || et === 3 || et === 4),
    (this.attributeName = rt),
    (this.attributeNamespace = it),
    (this.mustUseProperty = nt),
    (this.propertyName = tt),
    (this.type = et),
    (this.sanitizeURL = st),
    (this.removeEmptyString = ot);
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (tt) {
    z$3[tt] = new v$5(tt, 0, !1, tt, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (tt) {
  var et = tt[0];
  z$3[et] = new v$5(et, 1, !1, tt[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 2, !1, tt.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 2, !1, tt, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (tt) {
    z$3[tt] = new v$5(tt, 3, !1, tt.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 3, !0, tt, null, !1, !1);
});
["capture", "download"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 4, !1, tt, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 6, !1, tt, null, !1, !1);
});
["rowSpan", "start"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 5, !1, tt.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(tt) {
  return tt[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (tt) {
    var et = tt.replace(ra, sa);
    z$3[et] = new v$5(et, 1, !1, tt, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (tt) {
    var et = tt.replace(ra, sa);
    z$3[et] = new v$5(et, 1, !1, tt, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (tt) {
  var et = tt.replace(ra, sa);
  z$3[et] = new v$5(
    et,
    1,
    !1,
    tt,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    !1
  );
});
["tabIndex", "crossOrigin"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 1, !1, tt.toLowerCase(), null, !1, !1);
});
z$3.xlinkHref = new v$5(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (tt) {
  z$3[tt] = new v$5(tt, 1, !1, tt.toLowerCase(), null, !0, !0);
});
function ta(tt, et, nt, rt) {
  var it = z$3.hasOwnProperty(et) ? z$3[et] : null;
  (it !== null
    ? it.type !== 0
    : rt ||
      !(2 < et.length) ||
      (et[0] !== "o" && et[0] !== "O") ||
      (et[1] !== "n" && et[1] !== "N")) &&
    (qa(et, nt, it, rt) && (nt = null),
    rt || it === null
      ? oa(et) &&
        (nt === null ? tt.removeAttribute(et) : tt.setAttribute(et, "" + nt))
      : it.mustUseProperty
      ? (tt[it.propertyName] = nt === null ? (it.type === 3 ? !1 : "") : nt)
      : ((et = it.attributeName),
        (rt = it.attributeNamespace),
        nt === null
          ? tt.removeAttribute(et)
          : ((it = it.type),
            (nt = it === 3 || (it === 4 && nt === !0) ? "" : "" + nt),
            rt ? tt.setAttributeNS(rt, et, nt) : tt.setAttribute(et, nt))));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  va = Symbol.for("react.element"),
  wa = Symbol.for("react.portal"),
  ya = Symbol.for("react.fragment"),
  za = Symbol.for("react.strict_mode"),
  Aa = Symbol.for("react.profiler"),
  Ba = Symbol.for("react.provider"),
  Ca = Symbol.for("react.context"),
  Da = Symbol.for("react.forward_ref"),
  Ea = Symbol.for("react.suspense"),
  Fa = Symbol.for("react.suspense_list"),
  Ga = Symbol.for("react.memo"),
  Ha = Symbol.for("react.lazy"),
  Ia = Symbol.for("react.offscreen"),
  Ja = Symbol.iterator;
function Ka(tt) {
  return tt === null || typeof tt != "object"
    ? null
    : ((tt = (Ja && tt[Ja]) || tt["@@iterator"]),
      typeof tt == "function" ? tt : null);
}
var A$2 = Object.assign,
  La;
function Ma(tt) {
  if (La === void 0)
    try {
      throw Error();
    } catch (nt) {
      var et = nt.stack.trim().match(/\n( *(at )?)/);
      La = (et && et[1]) || "";
    }
  return (
    `
` +
    La +
    tt
  );
}
var Na = !1;
function Oa(tt, et) {
  if (!tt || Na) return "";
  Na = !0;
  var nt = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (et)
      if (
        ((et = function () {
          throw Error();
        }),
        Object.defineProperty(et.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(et, []);
        } catch (ct) {
          var rt = ct;
        }
        Reflect.construct(tt, [], et);
      } else {
        try {
          et.call();
        } catch (ct) {
          rt = ct;
        }
        tt.call(et.prototype);
      }
    else {
      try {
        throw Error();
      } catch (ct) {
        rt = ct;
      }
      tt();
    }
  } catch (ct) {
    if (ct && rt && typeof ct.stack == "string") {
      for (
        var it = ct.stack.split(`
`),
          st = rt.stack.split(`
`),
          ot = it.length - 1,
          at = st.length - 1;
        1 <= ot && 0 <= at && it[ot] !== st[at];

      )
        at--;
      for (; 1 <= ot && 0 <= at; ot--, at--)
        if (it[ot] !== st[at]) {
          if (ot !== 1 || at !== 1)
            do
              if ((ot--, at--, 0 > at || it[ot] !== st[at])) {
                var lt =
                  `
` + it[ot].replace(" at new ", " at ");
                return (
                  tt.displayName &&
                    lt.includes("<anonymous>") &&
                    (lt = lt.replace("<anonymous>", tt.displayName)),
                  lt
                );
              }
            while (1 <= ot && 0 <= at);
          break;
        }
    }
  } finally {
    (Na = !1), (Error.prepareStackTrace = nt);
  }
  return (tt = tt ? tt.displayName || tt.name : "") ? Ma(tt) : "";
}
function Pa(tt) {
  switch (tt.tag) {
    case 5:
      return Ma(tt.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (tt = Oa(tt.type, !1)), tt;
    case 11:
      return (tt = Oa(tt.type.render, !1)), tt;
    case 1:
      return (tt = Oa(tt.type, !0)), tt;
    default:
      return "";
  }
}
function Qa(tt) {
  if (tt == null) return null;
  if (typeof tt == "function") return tt.displayName || tt.name || null;
  if (typeof tt == "string") return tt;
  switch (tt) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if (typeof tt == "object")
    switch (tt.$$typeof) {
      case Ca:
        return (tt.displayName || "Context") + ".Consumer";
      case Ba:
        return (tt._context.displayName || "Context") + ".Provider";
      case Da:
        var et = tt.render;
        return (
          (tt = tt.displayName),
          tt ||
            ((tt = et.displayName || et.name || ""),
            (tt = tt !== "" ? "ForwardRef(" + tt + ")" : "ForwardRef")),
          tt
        );
      case Ga:
        return (
          (et = tt.displayName || null),
          et !== null ? et : Qa(tt.type) || "Memo"
        );
      case Ha:
        (et = tt._payload), (tt = tt._init);
        try {
          return Qa(tt(et));
        } catch {}
    }
  return null;
}
function Ra(tt) {
  var et = tt.type;
  switch (tt.tag) {
    case 24:
      return "Cache";
    case 9:
      return (et.displayName || "Context") + ".Consumer";
    case 10:
      return (et._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (tt = et.render),
        (tt = tt.displayName || tt.name || ""),
        et.displayName || (tt !== "" ? "ForwardRef(" + tt + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return et;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(et);
    case 8:
      return et === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof et == "function") return et.displayName || et.name || null;
      if (typeof et == "string") return et;
  }
  return null;
}
function Sa(tt) {
  switch (typeof tt) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return tt;
    case "object":
      return tt;
    default:
      return "";
  }
}
function Ta(tt) {
  var et = tt.type;
  return (
    (tt = tt.nodeName) &&
    tt.toLowerCase() === "input" &&
    (et === "checkbox" || et === "radio")
  );
}
function Ua(tt) {
  var et = Ta(tt) ? "checked" : "value",
    nt = Object.getOwnPropertyDescriptor(tt.constructor.prototype, et),
    rt = "" + tt[et];
  if (
    !tt.hasOwnProperty(et) &&
    typeof nt < "u" &&
    typeof nt.get == "function" &&
    typeof nt.set == "function"
  ) {
    var it = nt.get,
      st = nt.set;
    return (
      Object.defineProperty(tt, et, {
        configurable: !0,
        get: function () {
          return it.call(this);
        },
        set: function (ot) {
          (rt = "" + ot), st.call(this, ot);
        },
      }),
      Object.defineProperty(tt, et, { enumerable: nt.enumerable }),
      {
        getValue: function () {
          return rt;
        },
        setValue: function (ot) {
          rt = "" + ot;
        },
        stopTracking: function () {
          (tt._valueTracker = null), delete tt[et];
        },
      }
    );
  }
}
function Va(tt) {
  tt._valueTracker || (tt._valueTracker = Ua(tt));
}
function Wa(tt) {
  if (!tt) return !1;
  var et = tt._valueTracker;
  if (!et) return !0;
  var nt = et.getValue(),
    rt = "";
  return (
    tt && (rt = Ta(tt) ? (tt.checked ? "true" : "false") : tt.value),
    (tt = rt),
    tt !== nt ? (et.setValue(tt), !0) : !1
  );
}
function Xa(tt) {
  if (
    ((tt = tt || (typeof document < "u" ? document : void 0)), typeof tt > "u")
  )
    return null;
  try {
    return tt.activeElement || tt.body;
  } catch {
    return tt.body;
  }
}
function Ya(tt, et) {
  var nt = et.checked;
  return A$2({}, et, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: nt ?? tt._wrapperState.initialChecked,
  });
}
function Za(tt, et) {
  var nt = et.defaultValue == null ? "" : et.defaultValue,
    rt = et.checked != null ? et.checked : et.defaultChecked;
  (nt = Sa(et.value != null ? et.value : nt)),
    (tt._wrapperState = {
      initialChecked: rt,
      initialValue: nt,
      controlled:
        et.type === "checkbox" || et.type === "radio"
          ? et.checked != null
          : et.value != null,
    });
}
function ab(tt, et) {
  (et = et.checked), et != null && ta(tt, "checked", et, !1);
}
function bb(tt, et) {
  ab(tt, et);
  var nt = Sa(et.value),
    rt = et.type;
  if (nt != null)
    rt === "number"
      ? ((nt === 0 && tt.value === "") || tt.value != nt) &&
        (tt.value = "" + nt)
      : tt.value !== "" + nt && (tt.value = "" + nt);
  else if (rt === "submit" || rt === "reset") {
    tt.removeAttribute("value");
    return;
  }
  et.hasOwnProperty("value")
    ? cb(tt, et.type, nt)
    : et.hasOwnProperty("defaultValue") && cb(tt, et.type, Sa(et.defaultValue)),
    et.checked == null &&
      et.defaultChecked != null &&
      (tt.defaultChecked = !!et.defaultChecked);
}
function db(tt, et, nt) {
  if (et.hasOwnProperty("value") || et.hasOwnProperty("defaultValue")) {
    var rt = et.type;
    if (
      !(
        (rt !== "submit" && rt !== "reset") ||
        (et.value !== void 0 && et.value !== null)
      )
    )
      return;
    (et = "" + tt._wrapperState.initialValue),
      nt || et === tt.value || (tt.value = et),
      (tt.defaultValue = et);
  }
  (nt = tt.name),
    nt !== "" && (tt.name = ""),
    (tt.defaultChecked = !!tt._wrapperState.initialChecked),
    nt !== "" && (tt.name = nt);
}
function cb(tt, et, nt) {
  (et !== "number" || Xa(tt.ownerDocument) !== tt) &&
    (nt == null
      ? (tt.defaultValue = "" + tt._wrapperState.initialValue)
      : tt.defaultValue !== "" + nt && (tt.defaultValue = "" + nt));
}
var eb = Array.isArray;
function fb(tt, et, nt, rt) {
  if (((tt = tt.options), et)) {
    et = {};
    for (var it = 0; it < nt.length; it++) et["$" + nt[it]] = !0;
    for (nt = 0; nt < tt.length; nt++)
      (it = et.hasOwnProperty("$" + tt[nt].value)),
        tt[nt].selected !== it && (tt[nt].selected = it),
        it && rt && (tt[nt].defaultSelected = !0);
  } else {
    for (nt = "" + Sa(nt), et = null, it = 0; it < tt.length; it++) {
      if (tt[it].value === nt) {
        (tt[it].selected = !0), rt && (tt[it].defaultSelected = !0);
        return;
      }
      et !== null || tt[it].disabled || (et = tt[it]);
    }
    et !== null && (et.selected = !0);
  }
}
function gb(tt, et) {
  if (et.dangerouslySetInnerHTML != null) throw Error(p$6(91));
  return A$2({}, et, {
    value: void 0,
    defaultValue: void 0,
    children: "" + tt._wrapperState.initialValue,
  });
}
function hb(tt, et) {
  var nt = et.value;
  if (nt == null) {
    if (((nt = et.children), (et = et.defaultValue), nt != null)) {
      if (et != null) throw Error(p$6(92));
      if (eb(nt)) {
        if (1 < nt.length) throw Error(p$6(93));
        nt = nt[0];
      }
      et = nt;
    }
    et == null && (et = ""), (nt = et);
  }
  tt._wrapperState = { initialValue: Sa(nt) };
}
function ib(tt, et) {
  var nt = Sa(et.value),
    rt = Sa(et.defaultValue);
  nt != null &&
    ((nt = "" + nt),
    nt !== tt.value && (tt.value = nt),
    et.defaultValue == null &&
      tt.defaultValue !== nt &&
      (tt.defaultValue = nt)),
    rt != null && (tt.defaultValue = "" + rt);
}
function jb(tt) {
  var et = tt.textContent;
  et === tt._wrapperState.initialValue &&
    et !== "" &&
    et !== null &&
    (tt.value = et);
}
function kb(tt) {
  switch (tt) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(tt, et) {
  return tt == null || tt === "http://www.w3.org/1999/xhtml"
    ? kb(et)
    : tt === "http://www.w3.org/2000/svg" && et === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : tt;
}
var mb,
  nb = (function (tt) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (et, nt, rt, it) {
          MSApp.execUnsafeLocalFunction(function () {
            return tt(et, nt, rt, it);
          });
        }
      : tt;
  })(function (tt, et) {
    if (tt.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in tt)
      tt.innerHTML = et;
    else {
      for (
        mb = mb || document.createElement("div"),
          mb.innerHTML = "<svg>" + et.valueOf().toString() + "</svg>",
          et = mb.firstChild;
        tt.firstChild;

      )
        tt.removeChild(tt.firstChild);
      for (; et.firstChild; ) tt.appendChild(et.firstChild);
    }
  });
function ob(tt, et) {
  if (et) {
    var nt = tt.firstChild;
    if (nt && nt === tt.lastChild && nt.nodeType === 3) {
      nt.nodeValue = et;
      return;
    }
  }
  tt.textContent = et;
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (tt) {
  qb.forEach(function (et) {
    (et = et + tt.charAt(0).toUpperCase() + tt.substring(1)), (pb[et] = pb[tt]);
  });
});
function rb(tt, et, nt) {
  return et == null || typeof et == "boolean" || et === ""
    ? ""
    : nt ||
      typeof et != "number" ||
      et === 0 ||
      (pb.hasOwnProperty(tt) && pb[tt])
    ? ("" + et).trim()
    : et + "px";
}
function sb(tt, et) {
  tt = tt.style;
  for (var nt in et)
    if (et.hasOwnProperty(nt)) {
      var rt = nt.indexOf("--") === 0,
        it = rb(nt, et[nt], rt);
      nt === "float" && (nt = "cssFloat"),
        rt ? tt.setProperty(nt, it) : (tt[nt] = it);
    }
}
var tb = A$2(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function ub(tt, et) {
  if (et) {
    if (tb[tt] && (et.children != null || et.dangerouslySetInnerHTML != null))
      throw Error(p$6(137, tt));
    if (et.dangerouslySetInnerHTML != null) {
      if (et.children != null) throw Error(p$6(60));
      if (
        typeof et.dangerouslySetInnerHTML != "object" ||
        !("__html" in et.dangerouslySetInnerHTML)
      )
        throw Error(p$6(61));
    }
    if (et.style != null && typeof et.style != "object") throw Error(p$6(62));
  }
}
function vb(tt, et) {
  if (tt.indexOf("-") === -1) return typeof et.is == "string";
  switch (tt) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var wb = null;
function xb(tt) {
  return (
    (tt = tt.target || tt.srcElement || window),
    tt.correspondingUseElement && (tt = tt.correspondingUseElement),
    tt.nodeType === 3 ? tt.parentNode : tt
  );
}
var yb = null,
  zb = null,
  Ab = null;
function Bb(tt) {
  if ((tt = Cb(tt))) {
    if (typeof yb != "function") throw Error(p$6(280));
    var et = tt.stateNode;
    et && ((et = Db(et)), yb(tt.stateNode, tt.type, et));
  }
}
function Eb(tt) {
  zb ? (Ab ? Ab.push(tt) : (Ab = [tt])) : (zb = tt);
}
function Fb() {
  if (zb) {
    var tt = zb,
      et = Ab;
    if (((Ab = zb = null), Bb(tt), et))
      for (tt = 0; tt < et.length; tt++) Bb(et[tt]);
  }
}
function Gb(tt, et) {
  return tt(et);
}
function Hb() {}
var Ib = !1;
function Jb(tt, et, nt) {
  if (Ib) return tt(et, nt);
  Ib = !0;
  try {
    return Gb(tt, et, nt);
  } finally {
    (Ib = !1), (zb !== null || Ab !== null) && (Hb(), Fb());
  }
}
function Kb(tt, et) {
  var nt = tt.stateNode;
  if (nt === null) return null;
  var rt = Db(nt);
  if (rt === null) return null;
  nt = rt[et];
  e: switch (et) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (rt = !rt.disabled) ||
        ((tt = tt.type),
        (rt = !(
          tt === "button" ||
          tt === "input" ||
          tt === "select" ||
          tt === "textarea"
        ))),
        (tt = !rt);
      break e;
    default:
      tt = !1;
  }
  if (tt) return null;
  if (nt && typeof nt != "function") throw Error(p$6(231, et, typeof nt));
  return nt;
}
var Lb = !1;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", {
      get: function () {
        Lb = !0;
      },
    }),
      window.addEventListener("test", Mb, Mb),
      window.removeEventListener("test", Mb, Mb);
  } catch {
    Lb = !1;
  }
function Nb(tt, et, nt, rt, it, st, ot, at, lt) {
  var ct = Array.prototype.slice.call(arguments, 3);
  try {
    et.apply(nt, ct);
  } catch (ut) {
    this.onError(ut);
  }
}
var Ob = !1,
  Pb = null,
  Qb = !1,
  Rb = null,
  Sb = {
    onError: function (tt) {
      (Ob = !0), (Pb = tt);
    },
  };
function Tb(tt, et, nt, rt, it, st, ot, at, lt) {
  (Ob = !1), (Pb = null), Nb.apply(Sb, arguments);
}
function Ub(tt, et, nt, rt, it, st, ot, at, lt) {
  if ((Tb.apply(this, arguments), Ob)) {
    if (Ob) {
      var ct = Pb;
      (Ob = !1), (Pb = null);
    } else throw Error(p$6(198));
    Qb || ((Qb = !0), (Rb = ct));
  }
}
function Vb(tt) {
  var et = tt,
    nt = tt;
  if (tt.alternate) for (; et.return; ) et = et.return;
  else {
    tt = et;
    do (et = tt), et.flags & 4098 && (nt = et.return), (tt = et.return);
    while (tt);
  }
  return et.tag === 3 ? nt : null;
}
function Wb(tt) {
  if (tt.tag === 13) {
    var et = tt.memoizedState;
    if (
      (et === null &&
        ((tt = tt.alternate), tt !== null && (et = tt.memoizedState)),
      et !== null)
    )
      return et.dehydrated;
  }
  return null;
}
function Xb(tt) {
  if (Vb(tt) !== tt) throw Error(p$6(188));
}
function Yb(tt) {
  var et = tt.alternate;
  if (!et) {
    if (((et = Vb(tt)), et === null)) throw Error(p$6(188));
    return et !== tt ? null : tt;
  }
  for (var nt = tt, rt = et; ; ) {
    var it = nt.return;
    if (it === null) break;
    var st = it.alternate;
    if (st === null) {
      if (((rt = it.return), rt !== null)) {
        nt = rt;
        continue;
      }
      break;
    }
    if (it.child === st.child) {
      for (st = it.child; st; ) {
        if (st === nt) return Xb(it), tt;
        if (st === rt) return Xb(it), et;
        st = st.sibling;
      }
      throw Error(p$6(188));
    }
    if (nt.return !== rt.return) (nt = it), (rt = st);
    else {
      for (var ot = !1, at = it.child; at; ) {
        if (at === nt) {
          (ot = !0), (nt = it), (rt = st);
          break;
        }
        if (at === rt) {
          (ot = !0), (rt = it), (nt = st);
          break;
        }
        at = at.sibling;
      }
      if (!ot) {
        for (at = st.child; at; ) {
          if (at === nt) {
            (ot = !0), (nt = st), (rt = it);
            break;
          }
          if (at === rt) {
            (ot = !0), (rt = st), (nt = it);
            break;
          }
          at = at.sibling;
        }
        if (!ot) throw Error(p$6(189));
      }
    }
    if (nt.alternate !== rt) throw Error(p$6(190));
  }
  if (nt.tag !== 3) throw Error(p$6(188));
  return nt.stateNode.current === nt ? tt : et;
}
function Zb(tt) {
  return (tt = Yb(tt)), tt !== null ? $b(tt) : null;
}
function $b(tt) {
  if (tt.tag === 5 || tt.tag === 6) return tt;
  for (tt = tt.child; tt !== null; ) {
    var et = $b(tt);
    if (et !== null) return et;
    tt = tt.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback,
  bc = ca.unstable_cancelCallback,
  cc = ca.unstable_shouldYield,
  dc = ca.unstable_requestPaint,
  B$2 = ca.unstable_now,
  ec = ca.unstable_getCurrentPriorityLevel,
  fc = ca.unstable_ImmediatePriority,
  gc = ca.unstable_UserBlockingPriority,
  hc = ca.unstable_NormalPriority,
  ic = ca.unstable_LowPriority,
  jc = ca.unstable_IdlePriority,
  kc = null,
  lc = null;
function mc(tt) {
  if (lc && typeof lc.onCommitFiberRoot == "function")
    try {
      lc.onCommitFiberRoot(kc, tt, void 0, (tt.current.flags & 128) === 128);
    } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
  pc = Math.log,
  qc = Math.LN2;
function nc(tt) {
  return (tt >>>= 0), tt === 0 ? 32 : (31 - ((pc(tt) / qc) | 0)) | 0;
}
var rc = 64,
  sc = 4194304;
function tc(tt) {
  switch (tt & -tt) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return tt & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return tt & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return tt;
  }
}
function uc(tt, et) {
  var nt = tt.pendingLanes;
  if (nt === 0) return 0;
  var rt = 0,
    it = tt.suspendedLanes,
    st = tt.pingedLanes,
    ot = nt & 268435455;
  if (ot !== 0) {
    var at = ot & ~it;
    at !== 0 ? (rt = tc(at)) : ((st &= ot), st !== 0 && (rt = tc(st)));
  } else (ot = nt & ~it), ot !== 0 ? (rt = tc(ot)) : st !== 0 && (rt = tc(st));
  if (rt === 0) return 0;
  if (
    et !== 0 &&
    et !== rt &&
    !(et & it) &&
    ((it = rt & -rt),
    (st = et & -et),
    it >= st || (it === 16 && (st & 4194240) !== 0))
  )
    return et;
  if ((rt & 4 && (rt |= nt & 16), (et = tt.entangledLanes), et !== 0))
    for (tt = tt.entanglements, et &= rt; 0 < et; )
      (nt = 31 - oc(et)), (it = 1 << nt), (rt |= tt[nt]), (et &= ~it);
  return rt;
}
function vc(tt, et) {
  switch (tt) {
    case 1:
    case 2:
    case 4:
      return et + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return et + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(tt, et) {
  for (
    var nt = tt.suspendedLanes,
      rt = tt.pingedLanes,
      it = tt.expirationTimes,
      st = tt.pendingLanes;
    0 < st;

  ) {
    var ot = 31 - oc(st),
      at = 1 << ot,
      lt = it[ot];
    lt === -1
      ? (!(at & nt) || at & rt) && (it[ot] = vc(at, et))
      : lt <= et && (tt.expiredLanes |= at),
      (st &= ~at);
  }
}
function xc(tt) {
  return (
    (tt = tt.pendingLanes & -1073741825),
    tt !== 0 ? tt : tt & 1073741824 ? 1073741824 : 0
  );
}
function yc() {
  var tt = rc;
  return (rc <<= 1), !(rc & 4194240) && (rc = 64), tt;
}
function zc(tt) {
  for (var et = [], nt = 0; 31 > nt; nt++) et.push(tt);
  return et;
}
function Ac(tt, et, nt) {
  (tt.pendingLanes |= et),
    et !== 536870912 && ((tt.suspendedLanes = 0), (tt.pingedLanes = 0)),
    (tt = tt.eventTimes),
    (et = 31 - oc(et)),
    (tt[et] = nt);
}
function Bc(tt, et) {
  var nt = tt.pendingLanes & ~et;
  (tt.pendingLanes = et),
    (tt.suspendedLanes = 0),
    (tt.pingedLanes = 0),
    (tt.expiredLanes &= et),
    (tt.mutableReadLanes &= et),
    (tt.entangledLanes &= et),
    (et = tt.entanglements);
  var rt = tt.eventTimes;
  for (tt = tt.expirationTimes; 0 < nt; ) {
    var it = 31 - oc(nt),
      st = 1 << it;
    (et[it] = 0), (rt[it] = -1), (tt[it] = -1), (nt &= ~st);
  }
}
function Cc(tt, et) {
  var nt = (tt.entangledLanes |= et);
  for (tt = tt.entanglements; nt; ) {
    var rt = 31 - oc(nt),
      it = 1 << rt;
    (it & et) | (tt[rt] & et) && (tt[rt] |= et), (nt &= ~it);
  }
}
var C$1 = 0;
function Dc(tt) {
  return (
    (tt &= -tt), 1 < tt ? (4 < tt ? (tt & 268435455 ? 16 : 536870912) : 4) : 1
  );
}
var Ec,
  Fc,
  Gc,
  Hc,
  Ic,
  Jc = !1,
  Kc = [],
  Lc = null,
  Mc = null,
  Nc = null,
  Oc = new Map(),
  Pc = new Map(),
  Qc = [],
  Rc =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Sc(tt, et) {
  switch (tt) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(et.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(et.pointerId);
  }
}
function Tc(tt, et, nt, rt, it, st) {
  return tt === null || tt.nativeEvent !== st
    ? ((tt = {
        blockedOn: et,
        domEventName: nt,
        eventSystemFlags: rt,
        nativeEvent: st,
        targetContainers: [it],
      }),
      et !== null && ((et = Cb(et)), et !== null && Fc(et)),
      tt)
    : ((tt.eventSystemFlags |= rt),
      (et = tt.targetContainers),
      it !== null && et.indexOf(it) === -1 && et.push(it),
      tt);
}
function Uc(tt, et, nt, rt, it) {
  switch (et) {
    case "focusin":
      return (Lc = Tc(Lc, tt, et, nt, rt, it)), !0;
    case "dragenter":
      return (Mc = Tc(Mc, tt, et, nt, rt, it)), !0;
    case "mouseover":
      return (Nc = Tc(Nc, tt, et, nt, rt, it)), !0;
    case "pointerover":
      var st = it.pointerId;
      return Oc.set(st, Tc(Oc.get(st) || null, tt, et, nt, rt, it)), !0;
    case "gotpointercapture":
      return (
        (st = it.pointerId),
        Pc.set(st, Tc(Pc.get(st) || null, tt, et, nt, rt, it)),
        !0
      );
  }
  return !1;
}
function Vc(tt) {
  var et = Wc(tt.target);
  if (et !== null) {
    var nt = Vb(et);
    if (nt !== null) {
      if (((et = nt.tag), et === 13)) {
        if (((et = Wb(nt)), et !== null)) {
          (tt.blockedOn = et),
            Ic(tt.priority, function () {
              Gc(nt);
            });
          return;
        }
      } else if (et === 3 && nt.stateNode.current.memoizedState.isDehydrated) {
        tt.blockedOn = nt.tag === 3 ? nt.stateNode.containerInfo : null;
        return;
      }
    }
  }
  tt.blockedOn = null;
}
function Xc(tt) {
  if (tt.blockedOn !== null) return !1;
  for (var et = tt.targetContainers; 0 < et.length; ) {
    var nt = Yc(tt.domEventName, tt.eventSystemFlags, et[0], tt.nativeEvent);
    if (nt === null) {
      nt = tt.nativeEvent;
      var rt = new nt.constructor(nt.type, nt);
      (wb = rt), nt.target.dispatchEvent(rt), (wb = null);
    } else return (et = Cb(nt)), et !== null && Fc(et), (tt.blockedOn = nt), !1;
    et.shift();
  }
  return !0;
}
function Zc(tt, et, nt) {
  Xc(tt) && nt.delete(et);
}
function $c() {
  (Jc = !1),
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc);
}
function ad(tt, et) {
  tt.blockedOn === et &&
    ((tt.blockedOn = null),
    Jc ||
      ((Jc = !0),
      ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(tt) {
  function et(it) {
    return ad(it, tt);
  }
  if (0 < Kc.length) {
    ad(Kc[0], tt);
    for (var nt = 1; nt < Kc.length; nt++) {
      var rt = Kc[nt];
      rt.blockedOn === tt && (rt.blockedOn = null);
    }
  }
  for (
    Lc !== null && ad(Lc, tt),
      Mc !== null && ad(Mc, tt),
      Nc !== null && ad(Nc, tt),
      Oc.forEach(et),
      Pc.forEach(et),
      nt = 0;
    nt < Qc.length;
    nt++
  )
    (rt = Qc[nt]), rt.blockedOn === tt && (rt.blockedOn = null);
  for (; 0 < Qc.length && ((nt = Qc[0]), nt.blockedOn === null); )
    Vc(nt), nt.blockedOn === null && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig,
  dd = !0;
function ed(tt, et, nt, rt) {
  var it = C$1,
    st = cd.transition;
  cd.transition = null;
  try {
    (C$1 = 1), fd(tt, et, nt, rt);
  } finally {
    (C$1 = it), (cd.transition = st);
  }
}
function gd(tt, et, nt, rt) {
  var it = C$1,
    st = cd.transition;
  cd.transition = null;
  try {
    (C$1 = 4), fd(tt, et, nt, rt);
  } finally {
    (C$1 = it), (cd.transition = st);
  }
}
function fd(tt, et, nt, rt) {
  if (dd) {
    var it = Yc(tt, et, nt, rt);
    if (it === null) hd(tt, et, rt, id, nt), Sc(tt, rt);
    else if (Uc(it, tt, et, nt, rt)) rt.stopPropagation();
    else if ((Sc(tt, rt), et & 4 && -1 < Rc.indexOf(tt))) {
      for (; it !== null; ) {
        var st = Cb(it);
        if (
          (st !== null && Ec(st),
          (st = Yc(tt, et, nt, rt)),
          st === null && hd(tt, et, rt, id, nt),
          st === it)
        )
          break;
        it = st;
      }
      it !== null && rt.stopPropagation();
    } else hd(tt, et, rt, null, nt);
  }
}
var id = null;
function Yc(tt, et, nt, rt) {
  if (((id = null), (tt = xb(rt)), (tt = Wc(tt)), tt !== null))
    if (((et = Vb(tt)), et === null)) tt = null;
    else if (((nt = et.tag), nt === 13)) {
      if (((tt = Wb(et)), tt !== null)) return tt;
      tt = null;
    } else if (nt === 3) {
      if (et.stateNode.current.memoizedState.isDehydrated)
        return et.tag === 3 ? et.stateNode.containerInfo : null;
      tt = null;
    } else et !== tt && (tt = null);
  return (id = tt), null;
}
function jd(tt) {
  switch (tt) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null,
  ld = null,
  md = null;
function nd() {
  if (md) return md;
  var tt,
    et = ld,
    nt = et.length,
    rt,
    it = "value" in kd ? kd.value : kd.textContent,
    st = it.length;
  for (tt = 0; tt < nt && et[tt] === it[tt]; tt++);
  var ot = nt - tt;
  for (rt = 1; rt <= ot && et[nt - rt] === it[st - rt]; rt++);
  return (md = it.slice(tt, 1 < rt ? 1 - rt : void 0));
}
function od(tt) {
  var et = tt.keyCode;
  return (
    "charCode" in tt
      ? ((tt = tt.charCode), tt === 0 && et === 13 && (tt = 13))
      : (tt = et),
    tt === 10 && (tt = 13),
    32 <= tt || tt === 13 ? tt : 0
  );
}
function pd() {
  return !0;
}
function qd() {
  return !1;
}
function rd(tt) {
  function et(nt, rt, it, st, ot) {
    (this._reactName = nt),
      (this._targetInst = it),
      (this.type = rt),
      (this.nativeEvent = st),
      (this.target = ot),
      (this.currentTarget = null);
    for (var at in tt)
      tt.hasOwnProperty(at) &&
        ((nt = tt[at]), (this[at] = nt ? nt(st) : st[at]));
    return (
      (this.isDefaultPrevented = (
        st.defaultPrevented != null
          ? st.defaultPrevented
          : st.returnValue === !1
      )
        ? pd
        : qd),
      (this.isPropagationStopped = qd),
      this
    );
  }
  return (
    A$2(et.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var nt = this.nativeEvent;
        nt &&
          (nt.preventDefault
            ? nt.preventDefault()
            : typeof nt.returnValue != "unknown" && (nt.returnValue = !1),
          (this.isDefaultPrevented = pd));
      },
      stopPropagation: function () {
        var nt = this.nativeEvent;
        nt &&
          (nt.stopPropagation
            ? nt.stopPropagation()
            : typeof nt.cancelBubble != "unknown" && (nt.cancelBubble = !0),
          (this.isPropagationStopped = pd));
      },
      persist: function () {},
      isPersistent: pd,
    }),
    et
  );
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (tt) {
      return tt.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  td = rd(sd),
  ud = A$2({}, sd, { view: 0, detail: 0 }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = A$2({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (tt) {
      return tt.relatedTarget === void 0
        ? tt.fromElement === tt.srcElement
          ? tt.toElement
          : tt.fromElement
        : tt.relatedTarget;
    },
    movementX: function (tt) {
      return "movementX" in tt
        ? tt.movementX
        : (tt !== yd &&
            (yd && tt.type === "mousemove"
              ? ((wd = tt.screenX - yd.screenX), (xd = tt.screenY - yd.screenY))
              : (xd = wd = 0),
            (yd = tt)),
          wd);
    },
    movementY: function (tt) {
      return "movementY" in tt ? tt.movementY : xd;
    },
  }),
  Bd = rd(Ad),
  Cd = A$2({}, Ad, { dataTransfer: 0 }),
  Dd = rd(Cd),
  Ed = A$2({}, ud, { relatedTarget: 0 }),
  Fd = rd(Ed),
  Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Hd = rd(Gd),
  Id = A$2({}, sd, {
    clipboardData: function (tt) {
      return "clipboardData" in tt ? tt.clipboardData : window.clipboardData;
    },
  }),
  Jd = rd(Id),
  Kd = A$2({}, sd, { data: 0 }),
  Ld = rd(Kd),
  Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Pd(tt) {
  var et = this.nativeEvent;
  return et.getModifierState
    ? et.getModifierState(tt)
    : (tt = Od[tt])
    ? !!et[tt]
    : !1;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, {
    key: function (tt) {
      if (tt.key) {
        var et = Md[tt.key] || tt.key;
        if (et !== "Unidentified") return et;
      }
      return tt.type === "keypress"
        ? ((tt = od(tt)), tt === 13 ? "Enter" : String.fromCharCode(tt))
        : tt.type === "keydown" || tt.type === "keyup"
        ? Nd[tt.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (tt) {
      return tt.type === "keypress" ? od(tt) : 0;
    },
    keyCode: function (tt) {
      return tt.type === "keydown" || tt.type === "keyup" ? tt.keyCode : 0;
    },
    which: function (tt) {
      return tt.type === "keypress"
        ? od(tt)
        : tt.type === "keydown" || tt.type === "keyup"
        ? tt.keyCode
        : 0;
    },
  }),
  Rd = rd(Qd),
  Sd = A$2({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Td = rd(Sd),
  Ud = A$2({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd,
  }),
  Vd = rd(Ud),
  Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Xd = rd(Wd),
  Yd = A$2({}, Ad, {
    deltaX: function (tt) {
      return "deltaX" in tt
        ? tt.deltaX
        : "wheelDeltaX" in tt
        ? -tt.wheelDeltaX
        : 0;
    },
    deltaY: function (tt) {
      return "deltaY" in tt
        ? tt.deltaY
        : "wheelDeltaY" in tt
        ? -tt.wheelDeltaY
        : "wheelDelta" in tt
        ? -tt.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae$1 = ia && "CompositionEvent" in window,
  be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1,
  de$1 = ia && (!ae$1 || (be$1 && 8 < be$1 && 11 >= be$1)),
  ee$1 = String.fromCharCode(32),
  fe$1 = !1;
function ge$1(tt, et) {
  switch (tt) {
    case "keyup":
      return $d.indexOf(et.keyCode) !== -1;
    case "keydown":
      return et.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function he$1(tt) {
  return (
    (tt = tt.detail), typeof tt == "object" && "data" in tt ? tt.data : null
  );
}
var ie$1 = !1;
function je$1(tt, et) {
  switch (tt) {
    case "compositionend":
      return he$1(et);
    case "keypress":
      return et.which !== 32 ? null : ((fe$1 = !0), ee$1);
    case "textInput":
      return (tt = et.data), tt === ee$1 && fe$1 ? null : tt;
    default:
      return null;
  }
}
function ke$1(tt, et) {
  if (ie$1)
    return tt === "compositionend" || (!ae$1 && ge$1(tt, et))
      ? ((tt = nd()), (md = ld = kd = null), (ie$1 = !1), tt)
      : null;
  switch (tt) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(et.ctrlKey || et.altKey || et.metaKey) ||
        (et.ctrlKey && et.altKey)
      ) {
        if (et.char && 1 < et.char.length) return et.char;
        if (et.which) return String.fromCharCode(et.which);
      }
      return null;
    case "compositionend":
      return de$1 && et.locale !== "ko" ? null : et.data;
    default:
      return null;
  }
}
var le$1 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function me(tt) {
  var et = tt && tt.nodeName && tt.nodeName.toLowerCase();
  return et === "input" ? !!le$1[tt.type] : et === "textarea";
}
function ne$1(tt, et, nt, rt) {
  Eb(rt),
    (et = oe$1(et, "onChange")),
    0 < et.length &&
      ((nt = new td("onChange", "change", null, nt, rt)),
      tt.push({ event: nt, listeners: et }));
}
var pe$1 = null,
  qe$1 = null;
function re$1(tt) {
  se$1(tt, 0);
}
function te$1(tt) {
  var et = ue(tt);
  if (Wa(et)) return tt;
}
function ve$1(tt, et) {
  if (tt === "change") return et;
}
var we$1 = !1;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;"),
        (ye$1 = typeof ze$1.oninput == "function");
    }
    xe$1 = ye$1;
  } else xe$1 = !1;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), (qe$1 = pe$1 = null));
}
function Be$1(tt) {
  if (tt.propertyName === "value" && te$1(qe$1)) {
    var et = [];
    ne$1(et, qe$1, tt, xb(tt)), Jb(re$1, et);
  }
}
function Ce(tt, et, nt) {
  tt === "focusin"
    ? (Ae$1(),
      (pe$1 = et),
      (qe$1 = nt),
      pe$1.attachEvent("onpropertychange", Be$1))
    : tt === "focusout" && Ae$1();
}
function De$1(tt) {
  if (tt === "selectionchange" || tt === "keyup" || tt === "keydown")
    return te$1(qe$1);
}
function Ee$1(tt, et) {
  if (tt === "click") return te$1(et);
}
function Fe$1(tt, et) {
  if (tt === "input" || tt === "change") return te$1(et);
}
function Ge(tt, et) {
  return (
    (tt === et && (tt !== 0 || 1 / tt === 1 / et)) || (tt !== tt && et !== et)
  );
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(tt, et) {
  if (He(tt, et)) return !0;
  if (
    typeof tt != "object" ||
    tt === null ||
    typeof et != "object" ||
    et === null
  )
    return !1;
  var nt = Object.keys(tt),
    rt = Object.keys(et);
  if (nt.length !== rt.length) return !1;
  for (rt = 0; rt < nt.length; rt++) {
    var it = nt[rt];
    if (!ja.call(et, it) || !He(tt[it], et[it])) return !1;
  }
  return !0;
}
function Je(tt) {
  for (; tt && tt.firstChild; ) tt = tt.firstChild;
  return tt;
}
function Ke(tt, et) {
  var nt = Je(tt);
  tt = 0;
  for (var rt; nt; ) {
    if (nt.nodeType === 3) {
      if (((rt = tt + nt.textContent.length), tt <= et && rt >= et))
        return { node: nt, offset: et - tt };
      tt = rt;
    }
    e: {
      for (; nt; ) {
        if (nt.nextSibling) {
          nt = nt.nextSibling;
          break e;
        }
        nt = nt.parentNode;
      }
      nt = void 0;
    }
    nt = Je(nt);
  }
}
function Le(tt, et) {
  return tt && et
    ? tt === et
      ? !0
      : tt && tt.nodeType === 3
      ? !1
      : et && et.nodeType === 3
      ? Le(tt, et.parentNode)
      : "contains" in tt
      ? tt.contains(et)
      : tt.compareDocumentPosition
      ? !!(tt.compareDocumentPosition(et) & 16)
      : !1
    : !1;
}
function Me$1() {
  for (var tt = window, et = Xa(); et instanceof tt.HTMLIFrameElement; ) {
    try {
      var nt = typeof et.contentWindow.location.href == "string";
    } catch {
      nt = !1;
    }
    if (nt) tt = et.contentWindow;
    else break;
    et = Xa(tt.document);
  }
  return et;
}
function Ne$1(tt) {
  var et = tt && tt.nodeName && tt.nodeName.toLowerCase();
  return (
    et &&
    ((et === "input" &&
      (tt.type === "text" ||
        tt.type === "search" ||
        tt.type === "tel" ||
        tt.type === "url" ||
        tt.type === "password")) ||
      et === "textarea" ||
      tt.contentEditable === "true")
  );
}
function Oe$1(tt) {
  var et = Me$1(),
    nt = tt.focusedElem,
    rt = tt.selectionRange;
  if (
    et !== nt &&
    nt &&
    nt.ownerDocument &&
    Le(nt.ownerDocument.documentElement, nt)
  ) {
    if (rt !== null && Ne$1(nt)) {
      if (
        ((et = rt.start),
        (tt = rt.end),
        tt === void 0 && (tt = et),
        "selectionStart" in nt)
      )
        (nt.selectionStart = et),
          (nt.selectionEnd = Math.min(tt, nt.value.length));
      else if (
        ((tt =
          ((et = nt.ownerDocument || document) && et.defaultView) || window),
        tt.getSelection)
      ) {
        tt = tt.getSelection();
        var it = nt.textContent.length,
          st = Math.min(rt.start, it);
        (rt = rt.end === void 0 ? st : Math.min(rt.end, it)),
          !tt.extend && st > rt && ((it = rt), (rt = st), (st = it)),
          (it = Ke(nt, st));
        var ot = Ke(nt, rt);
        it &&
          ot &&
          (tt.rangeCount !== 1 ||
            tt.anchorNode !== it.node ||
            tt.anchorOffset !== it.offset ||
            tt.focusNode !== ot.node ||
            tt.focusOffset !== ot.offset) &&
          ((et = et.createRange()),
          et.setStart(it.node, it.offset),
          tt.removeAllRanges(),
          st > rt
            ? (tt.addRange(et), tt.extend(ot.node, ot.offset))
            : (et.setEnd(ot.node, ot.offset), tt.addRange(et)));
      }
    }
    for (et = [], tt = nt; (tt = tt.parentNode); )
      tt.nodeType === 1 &&
        et.push({ element: tt, left: tt.scrollLeft, top: tt.scrollTop });
    for (
      typeof nt.focus == "function" && nt.focus(), nt = 0;
      nt < et.length;
      nt++
    )
      (tt = et[nt]),
        (tt.element.scrollLeft = tt.left),
        (tt.element.scrollTop = tt.top);
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
  Qe = null,
  Re$1 = null,
  Se$1 = null,
  Te$1 = !1;
function Ue(tt, et, nt) {
  var rt =
    nt.window === nt ? nt.document : nt.nodeType === 9 ? nt : nt.ownerDocument;
  Te$1 ||
    Qe == null ||
    Qe !== Xa(rt) ||
    ((rt = Qe),
    "selectionStart" in rt && Ne$1(rt)
      ? (rt = { start: rt.selectionStart, end: rt.selectionEnd })
      : ((rt = (
          (rt.ownerDocument && rt.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (rt = {
          anchorNode: rt.anchorNode,
          anchorOffset: rt.anchorOffset,
          focusNode: rt.focusNode,
          focusOffset: rt.focusOffset,
        })),
    (Se$1 && Ie(Se$1, rt)) ||
      ((Se$1 = rt),
      (rt = oe$1(Re$1, "onSelect")),
      0 < rt.length &&
        ((et = new td("onSelect", "select", null, et, nt)),
        tt.push({ event: et, listeners: rt }),
        (et.target = Qe))));
}
function Ve$1(tt, et) {
  var nt = {};
  return (
    (nt[tt.toLowerCase()] = et.toLowerCase()),
    (nt["Webkit" + tt] = "webkit" + et),
    (nt["Moz" + tt] = "moz" + et),
    nt
  );
}
var We$1 = {
    animationend: Ve$1("Animation", "AnimationEnd"),
    animationiteration: Ve$1("Animation", "AnimationIteration"),
    animationstart: Ve$1("Animation", "AnimationStart"),
    transitionend: Ve$1("Transition", "TransitionEnd"),
  },
  Xe = {},
  Ye$1 = {};
ia &&
  ((Ye$1 = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete We$1.animationend.animation,
    delete We$1.animationiteration.animation,
    delete We$1.animationstart.animation),
  "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze(tt) {
  if (Xe[tt]) return Xe[tt];
  if (!We$1[tt]) return tt;
  var et = We$1[tt],
    nt;
  for (nt in et)
    if (et.hasOwnProperty(nt) && nt in Ye$1) return (Xe[tt] = et[nt]);
  return tt;
}
var $e = Ze("animationend"),
  af = Ze("animationiteration"),
  bf = Ze("animationstart"),
  cf = Ze("transitionend"),
  df = new Map(),
  ef =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ff(tt, et) {
  df.set(tt, et), fa(et, [tt]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
    jf = hf.toLowerCase(),
    kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
fa(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
fa(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
fa(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var lf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(tt, et, nt) {
  var rt = tt.type || "unknown-event";
  (tt.currentTarget = nt), Ub(rt, et, void 0, tt), (tt.currentTarget = null);
}
function se$1(tt, et) {
  et = (et & 4) !== 0;
  for (var nt = 0; nt < tt.length; nt++) {
    var rt = tt[nt],
      it = rt.event;
    rt = rt.listeners;
    e: {
      var st = void 0;
      if (et)
        for (var ot = rt.length - 1; 0 <= ot; ot--) {
          var at = rt[ot],
            lt = at.instance,
            ct = at.currentTarget;
          if (((at = at.listener), lt !== st && it.isPropagationStopped()))
            break e;
          nf(it, at, ct), (st = lt);
        }
      else
        for (ot = 0; ot < rt.length; ot++) {
          if (
            ((at = rt[ot]),
            (lt = at.instance),
            (ct = at.currentTarget),
            (at = at.listener),
            lt !== st && it.isPropagationStopped())
          )
            break e;
          nf(it, at, ct), (st = lt);
        }
    }
  }
  if (Qb) throw ((tt = Rb), (Qb = !1), (Rb = null), tt);
}
function D$2(tt, et) {
  var nt = et[of];
  nt === void 0 && (nt = et[of] = new Set());
  var rt = tt + "__bubble";
  nt.has(rt) || (pf(et, tt, 2, !1), nt.add(rt));
}
function qf(tt, et, nt) {
  var rt = 0;
  et && (rt |= 4), pf(nt, tt, rt, et);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(tt) {
  if (!tt[rf]) {
    (tt[rf] = !0),
      da.forEach(function (nt) {
        nt !== "selectionchange" &&
          (mf.has(nt) || qf(nt, !1, tt), qf(nt, !0, tt));
      });
    var et = tt.nodeType === 9 ? tt : tt.ownerDocument;
    et === null || et[rf] || ((et[rf] = !0), qf("selectionchange", !1, et));
  }
}
function pf(tt, et, nt, rt) {
  switch (jd(et)) {
    case 1:
      var it = ed;
      break;
    case 4:
      it = gd;
      break;
    default:
      it = fd;
  }
  (nt = it.bind(null, et, nt, tt)),
    (it = void 0),
    !Lb ||
      (et !== "touchstart" && et !== "touchmove" && et !== "wheel") ||
      (it = !0),
    rt
      ? it !== void 0
        ? tt.addEventListener(et, nt, { capture: !0, passive: it })
        : tt.addEventListener(et, nt, !0)
      : it !== void 0
      ? tt.addEventListener(et, nt, { passive: it })
      : tt.addEventListener(et, nt, !1);
}
function hd(tt, et, nt, rt, it) {
  var st = rt;
  if (!(et & 1) && !(et & 2) && rt !== null)
    e: for (;;) {
      if (rt === null) return;
      var ot = rt.tag;
      if (ot === 3 || ot === 4) {
        var at = rt.stateNode.containerInfo;
        if (at === it || (at.nodeType === 8 && at.parentNode === it)) break;
        if (ot === 4)
          for (ot = rt.return; ot !== null; ) {
            var lt = ot.tag;
            if (
              (lt === 3 || lt === 4) &&
              ((lt = ot.stateNode.containerInfo),
              lt === it || (lt.nodeType === 8 && lt.parentNode === it))
            )
              return;
            ot = ot.return;
          }
        for (; at !== null; ) {
          if (((ot = Wc(at)), ot === null)) return;
          if (((lt = ot.tag), lt === 5 || lt === 6)) {
            rt = st = ot;
            continue e;
          }
          at = at.parentNode;
        }
      }
      rt = rt.return;
    }
  Jb(function () {
    var ct = st,
      ut = xb(nt),
      ft = [];
    e: {
      var ht = df.get(tt);
      if (ht !== void 0) {
        var mt = td,
          vt = tt;
        switch (tt) {
          case "keypress":
            if (od(nt) === 0) break e;
          case "keydown":
          case "keyup":
            mt = Rd;
            break;
          case "focusin":
            (vt = "focus"), (mt = Fd);
            break;
          case "focusout":
            (vt = "blur"), (mt = Fd);
            break;
          case "beforeblur":
          case "afterblur":
            mt = Fd;
            break;
          case "click":
            if (nt.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            mt = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            mt = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            mt = Vd;
            break;
          case $e:
          case af:
          case bf:
            mt = Hd;
            break;
          case cf:
            mt = Xd;
            break;
          case "scroll":
            mt = vd;
            break;
          case "wheel":
            mt = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            mt = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            mt = Td;
        }
        var yt = (et & 4) !== 0,
          Et = !yt && tt === "scroll",
          pt = yt ? (ht !== null ? ht + "Capture" : null) : ht;
        yt = [];
        for (var xt = ct, St; xt !== null; ) {
          St = xt;
          var At = St.stateNode;
          if (
            (St.tag === 5 &&
              At !== null &&
              ((St = At),
              pt !== null &&
                ((At = Kb(xt, pt)), At != null && yt.push(tf(xt, At, St)))),
            Et)
          )
            break;
          xt = xt.return;
        }
        0 < yt.length &&
          ((ht = new mt(ht, vt, null, nt, ut)),
          ft.push({ event: ht, listeners: yt }));
      }
    }
    if (!(et & 7)) {
      e: {
        if (
          ((ht = tt === "mouseover" || tt === "pointerover"),
          (mt = tt === "mouseout" || tt === "pointerout"),
          ht &&
            nt !== wb &&
            (vt = nt.relatedTarget || nt.fromElement) &&
            (Wc(vt) || vt[uf]))
        )
          break e;
        if (
          (mt || ht) &&
          ((ht =
            ut.window === ut
              ? ut
              : (ht = ut.ownerDocument)
              ? ht.defaultView || ht.parentWindow
              : window),
          mt
            ? ((vt = nt.relatedTarget || nt.toElement),
              (mt = ct),
              (vt = vt ? Wc(vt) : null),
              vt !== null &&
                ((Et = Vb(vt)), vt !== Et || (vt.tag !== 5 && vt.tag !== 6)) &&
                (vt = null))
            : ((mt = null), (vt = ct)),
          mt !== vt)
        ) {
          if (
            ((yt = Bd),
            (At = "onMouseLeave"),
            (pt = "onMouseEnter"),
            (xt = "mouse"),
            (tt === "pointerout" || tt === "pointerover") &&
              ((yt = Td),
              (At = "onPointerLeave"),
              (pt = "onPointerEnter"),
              (xt = "pointer")),
            (Et = mt == null ? ht : ue(mt)),
            (St = vt == null ? ht : ue(vt)),
            (ht = new yt(At, xt + "leave", mt, nt, ut)),
            (ht.target = Et),
            (ht.relatedTarget = St),
            (At = null),
            Wc(ut) === ct &&
              ((yt = new yt(pt, xt + "enter", vt, nt, ut)),
              (yt.target = St),
              (yt.relatedTarget = Et),
              (At = yt)),
            (Et = At),
            mt && vt)
          )
            t: {
              for (yt = mt, pt = vt, xt = 0, St = yt; St; St = vf(St)) xt++;
              for (St = 0, At = pt; At; At = vf(At)) St++;
              for (; 0 < xt - St; ) (yt = vf(yt)), xt--;
              for (; 0 < St - xt; ) (pt = vf(pt)), St--;
              for (; xt--; ) {
                if (yt === pt || (pt !== null && yt === pt.alternate)) break t;
                (yt = vf(yt)), (pt = vf(pt));
              }
              yt = null;
            }
          else yt = null;
          mt !== null && wf(ft, ht, mt, yt, !1),
            vt !== null && Et !== null && wf(ft, Et, vt, yt, !0);
        }
      }
      e: {
        if (
          ((ht = ct ? ue(ct) : window),
          (mt = ht.nodeName && ht.nodeName.toLowerCase()),
          mt === "select" || (mt === "input" && ht.type === "file"))
        )
          var Ct = ve$1;
        else if (me(ht))
          if (we$1) Ct = Fe$1;
          else {
            Ct = De$1;
            var Mt = Ce;
          }
        else
          (mt = ht.nodeName) &&
            mt.toLowerCase() === "input" &&
            (ht.type === "checkbox" || ht.type === "radio") &&
            (Ct = Ee$1);
        if (Ct && (Ct = Ct(tt, ct))) {
          ne$1(ft, Ct, nt, ut);
          break e;
        }
        Mt && Mt(tt, ht, ct),
          tt === "focusout" &&
            (Mt = ht._wrapperState) &&
            Mt.controlled &&
            ht.type === "number" &&
            cb(ht, "number", ht.value);
      }
      switch (((Mt = ct ? ue(ct) : window), tt)) {
        case "focusin":
          (me(Mt) || Mt.contentEditable === "true") &&
            ((Qe = Mt), (Re$1 = ct), (Se$1 = null));
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Te$1 = !1), Ue(ft, nt, ut);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(ft, nt, ut);
      }
      var wt;
      if (ae$1)
        e: {
          switch (tt) {
            case "compositionstart":
              var Bt = "onCompositionStart";
              break e;
            case "compositionend":
              Bt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Bt = "onCompositionUpdate";
              break e;
          }
          Bt = void 0;
        }
      else
        ie$1
          ? ge$1(tt, nt) && (Bt = "onCompositionEnd")
          : tt === "keydown" &&
            nt.keyCode === 229 &&
            (Bt = "onCompositionStart");
      Bt &&
        (de$1 &&
          nt.locale !== "ko" &&
          (ie$1 || Bt !== "onCompositionStart"
            ? Bt === "onCompositionEnd" && ie$1 && (wt = nd())
            : ((kd = ut),
              (ld = "value" in kd ? kd.value : kd.textContent),
              (ie$1 = !0))),
        (Mt = oe$1(ct, Bt)),
        0 < Mt.length &&
          ((Bt = new Ld(Bt, tt, null, nt, ut)),
          ft.push({ event: Bt, listeners: Mt }),
          wt
            ? (Bt.data = wt)
            : ((wt = he$1(nt)), wt !== null && (Bt.data = wt)))),
        (wt = ce$1 ? je$1(tt, nt) : ke$1(tt, nt)) &&
          ((ct = oe$1(ct, "onBeforeInput")),
          0 < ct.length &&
            ((ut = new Ld("onBeforeInput", "beforeinput", null, nt, ut)),
            ft.push({ event: ut, listeners: ct }),
            (ut.data = wt)));
    }
    se$1(ft, et);
  });
}
function tf(tt, et, nt) {
  return { instance: tt, listener: et, currentTarget: nt };
}
function oe$1(tt, et) {
  for (var nt = et + "Capture", rt = []; tt !== null; ) {
    var it = tt,
      st = it.stateNode;
    it.tag === 5 &&
      st !== null &&
      ((it = st),
      (st = Kb(tt, nt)),
      st != null && rt.unshift(tf(tt, st, it)),
      (st = Kb(tt, et)),
      st != null && rt.push(tf(tt, st, it))),
      (tt = tt.return);
  }
  return rt;
}
function vf(tt) {
  if (tt === null) return null;
  do tt = tt.return;
  while (tt && tt.tag !== 5);
  return tt || null;
}
function wf(tt, et, nt, rt, it) {
  for (var st = et._reactName, ot = []; nt !== null && nt !== rt; ) {
    var at = nt,
      lt = at.alternate,
      ct = at.stateNode;
    if (lt !== null && lt === rt) break;
    at.tag === 5 &&
      ct !== null &&
      ((at = ct),
      it
        ? ((lt = Kb(nt, st)), lt != null && ot.unshift(tf(nt, lt, at)))
        : it || ((lt = Kb(nt, st)), lt != null && ot.push(tf(nt, lt, at)))),
      (nt = nt.return);
  }
  ot.length !== 0 && tt.push({ event: et, listeners: ot });
}
var xf = /\r\n?/g,
  yf = /\u0000|\uFFFD/g;
function zf(tt) {
  return (typeof tt == "string" ? tt : "" + tt)
    .replace(
      xf,
      `
`
    )
    .replace(yf, "");
}
function Af(tt, et, nt) {
  if (((et = zf(et)), zf(tt) !== et && nt)) throw Error(p$6(425));
}
function Bf() {}
var Cf = null,
  Df = null;
function Ef(tt, et) {
  return (
    tt === "textarea" ||
    tt === "noscript" ||
    typeof et.children == "string" ||
    typeof et.children == "number" ||
    (typeof et.dangerouslySetInnerHTML == "object" &&
      et.dangerouslySetInnerHTML !== null &&
      et.dangerouslySetInnerHTML.__html != null)
  );
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
  Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Hf = typeof Promise == "function" ? Promise : void 0,
  Jf =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Hf < "u"
      ? function (tt) {
          return Hf.resolve(null).then(tt).catch(If);
        }
      : Ff;
function If(tt) {
  setTimeout(function () {
    throw tt;
  });
}
function Kf(tt, et) {
  var nt = et,
    rt = 0;
  do {
    var it = nt.nextSibling;
    if ((tt.removeChild(nt), it && it.nodeType === 8))
      if (((nt = it.data), nt === "/$")) {
        if (rt === 0) {
          tt.removeChild(it), bd(et);
          return;
        }
        rt--;
      } else (nt !== "$" && nt !== "$?" && nt !== "$!") || rt++;
    nt = it;
  } while (nt);
  bd(et);
}
function Lf(tt) {
  for (; tt != null; tt = tt.nextSibling) {
    var et = tt.nodeType;
    if (et === 1 || et === 3) break;
    if (et === 8) {
      if (((et = tt.data), et === "$" || et === "$!" || et === "$?")) break;
      if (et === "/$") return null;
    }
  }
  return tt;
}
function Mf(tt) {
  tt = tt.previousSibling;
  for (var et = 0; tt; ) {
    if (tt.nodeType === 8) {
      var nt = tt.data;
      if (nt === "$" || nt === "$!" || nt === "$?") {
        if (et === 0) return tt;
        et--;
      } else nt === "/$" && et++;
    }
    tt = tt.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2),
  Of = "__reactFiber$" + Nf,
  Pf = "__reactProps$" + Nf,
  uf = "__reactContainer$" + Nf,
  of = "__reactEvents$" + Nf,
  Qf = "__reactListeners$" + Nf,
  Rf = "__reactHandles$" + Nf;
function Wc(tt) {
  var et = tt[Of];
  if (et) return et;
  for (var nt = tt.parentNode; nt; ) {
    if ((et = nt[uf] || nt[Of])) {
      if (
        ((nt = et.alternate),
        et.child !== null || (nt !== null && nt.child !== null))
      )
        for (tt = Mf(tt); tt !== null; ) {
          if ((nt = tt[Of])) return nt;
          tt = Mf(tt);
        }
      return et;
    }
    (tt = nt), (nt = tt.parentNode);
  }
  return null;
}
function Cb(tt) {
  return (
    (tt = tt[Of] || tt[uf]),
    !tt || (tt.tag !== 5 && tt.tag !== 6 && tt.tag !== 13 && tt.tag !== 3)
      ? null
      : tt
  );
}
function ue(tt) {
  if (tt.tag === 5 || tt.tag === 6) return tt.stateNode;
  throw Error(p$6(33));
}
function Db(tt) {
  return tt[Pf] || null;
}
var Sf = [],
  Tf = -1;
function Uf(tt) {
  return { current: tt };
}
function E$2(tt) {
  0 > Tf || ((tt.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
}
function G$2(tt, et) {
  Tf++, (Sf[Tf] = tt.current), (tt.current = et);
}
var Vf = {},
  H$2 = Uf(Vf),
  Wf = Uf(!1),
  Xf = Vf;
function Yf(tt, et) {
  var nt = tt.type.contextTypes;
  if (!nt) return Vf;
  var rt = tt.stateNode;
  if (rt && rt.__reactInternalMemoizedUnmaskedChildContext === et)
    return rt.__reactInternalMemoizedMaskedChildContext;
  var it = {},
    st;
  for (st in nt) it[st] = et[st];
  return (
    rt &&
      ((tt = tt.stateNode),
      (tt.__reactInternalMemoizedUnmaskedChildContext = et),
      (tt.__reactInternalMemoizedMaskedChildContext = it)),
    it
  );
}
function Zf(tt) {
  return (tt = tt.childContextTypes), tt != null;
}
function $f() {
  E$2(Wf), E$2(H$2);
}
function ag(tt, et, nt) {
  if (H$2.current !== Vf) throw Error(p$6(168));
  G$2(H$2, et), G$2(Wf, nt);
}
function bg(tt, et, nt) {
  var rt = tt.stateNode;
  if (((et = et.childContextTypes), typeof rt.getChildContext != "function"))
    return nt;
  rt = rt.getChildContext();
  for (var it in rt)
    if (!(it in et)) throw Error(p$6(108, Ra(tt) || "Unknown", it));
  return A$2({}, nt, rt);
}
function cg(tt) {
  return (
    (tt =
      ((tt = tt.stateNode) && tt.__reactInternalMemoizedMergedChildContext) ||
      Vf),
    (Xf = H$2.current),
    G$2(H$2, tt),
    G$2(Wf, Wf.current),
    !0
  );
}
function dg(tt, et, nt) {
  var rt = tt.stateNode;
  if (!rt) throw Error(p$6(169));
  nt
    ? ((tt = bg(tt, et, Xf)),
      (rt.__reactInternalMemoizedMergedChildContext = tt),
      E$2(Wf),
      E$2(H$2),
      G$2(H$2, tt))
    : E$2(Wf),
    G$2(Wf, nt);
}
var eg = null,
  fg = !1,
  gg = !1;
function hg(tt) {
  eg === null ? (eg = [tt]) : eg.push(tt);
}
function ig(tt) {
  (fg = !0), hg(tt);
}
function jg() {
  if (!gg && eg !== null) {
    gg = !0;
    var tt = 0,
      et = C$1;
    try {
      var nt = eg;
      for (C$1 = 1; tt < nt.length; tt++) {
        var rt = nt[tt];
        do rt = rt(!0);
        while (rt !== null);
      }
      (eg = null), (fg = !1);
    } catch (it) {
      throw (eg !== null && (eg = eg.slice(tt + 1)), ac(fc, jg), it);
    } finally {
      (C$1 = et), (gg = !1);
    }
  }
  return null;
}
var kg = [],
  lg = 0,
  mg = null,
  ng = 0,
  og = [],
  pg = 0,
  qg = null,
  rg = 1,
  sg = "";
function tg(tt, et) {
  (kg[lg++] = ng), (kg[lg++] = mg), (mg = tt), (ng = et);
}
function ug(tt, et, nt) {
  (og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (qg = tt);
  var rt = rg;
  tt = sg;
  var it = 32 - oc(rt) - 1;
  (rt &= ~(1 << it)), (nt += 1);
  var st = 32 - oc(et) + it;
  if (30 < st) {
    var ot = it - (it % 5);
    (st = (rt & ((1 << ot) - 1)).toString(32)),
      (rt >>= ot),
      (it -= ot),
      (rg = (1 << (32 - oc(et) + it)) | (nt << it) | rt),
      (sg = st + tt);
  } else (rg = (1 << st) | (nt << it) | rt), (sg = tt);
}
function vg(tt) {
  tt.return !== null && (tg(tt, 1), ug(tt, 1, 0));
}
function wg(tt) {
  for (; tt === mg; )
    (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null);
  for (; tt === qg; )
    (qg = og[--pg]),
      (og[pg] = null),
      (sg = og[--pg]),
      (og[pg] = null),
      (rg = og[--pg]),
      (og[pg] = null);
}
var xg = null,
  yg = null,
  I$2 = !1,
  zg = null;
function Ag(tt, et) {
  var nt = Bg(5, null, null, 0);
  (nt.elementType = "DELETED"),
    (nt.stateNode = et),
    (nt.return = tt),
    (et = tt.deletions),
    et === null ? ((tt.deletions = [nt]), (tt.flags |= 16)) : et.push(nt);
}
function Cg(tt, et) {
  switch (tt.tag) {
    case 5:
      var nt = tt.type;
      return (
        (et =
          et.nodeType !== 1 || nt.toLowerCase() !== et.nodeName.toLowerCase()
            ? null
            : et),
        et !== null
          ? ((tt.stateNode = et), (xg = tt), (yg = Lf(et.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (et = tt.pendingProps === "" || et.nodeType !== 3 ? null : et),
        et !== null ? ((tt.stateNode = et), (xg = tt), (yg = null), !0) : !1
      );
    case 13:
      return (
        (et = et.nodeType !== 8 ? null : et),
        et !== null
          ? ((nt = qg !== null ? { id: rg, overflow: sg } : null),
            (tt.memoizedState = {
              dehydrated: et,
              treeContext: nt,
              retryLane: 1073741824,
            }),
            (nt = Bg(18, null, null, 0)),
            (nt.stateNode = et),
            (nt.return = tt),
            (tt.child = nt),
            (xg = tt),
            (yg = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Dg(tt) {
  return (tt.mode & 1) !== 0 && (tt.flags & 128) === 0;
}
function Eg(tt) {
  if (I$2) {
    var et = yg;
    if (et) {
      var nt = et;
      if (!Cg(tt, et)) {
        if (Dg(tt)) throw Error(p$6(418));
        et = Lf(nt.nextSibling);
        var rt = xg;
        et && Cg(tt, et)
          ? Ag(rt, nt)
          : ((tt.flags = (tt.flags & -4097) | 2), (I$2 = !1), (xg = tt));
      }
    } else {
      if (Dg(tt)) throw Error(p$6(418));
      (tt.flags = (tt.flags & -4097) | 2), (I$2 = !1), (xg = tt);
    }
  }
}
function Fg(tt) {
  for (
    tt = tt.return;
    tt !== null && tt.tag !== 5 && tt.tag !== 3 && tt.tag !== 13;

  )
    tt = tt.return;
  xg = tt;
}
function Gg(tt) {
  if (tt !== xg) return !1;
  if (!I$2) return Fg(tt), (I$2 = !0), !1;
  var et;
  if (
    ((et = tt.tag !== 3) &&
      !(et = tt.tag !== 5) &&
      ((et = tt.type),
      (et = et !== "head" && et !== "body" && !Ef(tt.type, tt.memoizedProps))),
    et && (et = yg))
  ) {
    if (Dg(tt)) throw (Hg(), Error(p$6(418)));
    for (; et; ) Ag(tt, et), (et = Lf(et.nextSibling));
  }
  if ((Fg(tt), tt.tag === 13)) {
    if (
      ((tt = tt.memoizedState), (tt = tt !== null ? tt.dehydrated : null), !tt)
    )
      throw Error(p$6(317));
    e: {
      for (tt = tt.nextSibling, et = 0; tt; ) {
        if (tt.nodeType === 8) {
          var nt = tt.data;
          if (nt === "/$") {
            if (et === 0) {
              yg = Lf(tt.nextSibling);
              break e;
            }
            et--;
          } else (nt !== "$" && nt !== "$!" && nt !== "$?") || et++;
        }
        tt = tt.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(tt.stateNode.nextSibling) : null;
  return !0;
}
function Hg() {
  for (var tt = yg; tt; ) tt = Lf(tt.nextSibling);
}
function Ig() {
  (yg = xg = null), (I$2 = !1);
}
function Jg(tt) {
  zg === null ? (zg = [tt]) : zg.push(tt);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(tt, et) {
  if (tt && tt.defaultProps) {
    (et = A$2({}, et)), (tt = tt.defaultProps);
    for (var nt in tt) et[nt] === void 0 && (et[nt] = tt[nt]);
    return et;
  }
  return et;
}
var Mg = Uf(null),
  Ng = null,
  Og = null,
  Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(tt) {
  var et = Mg.current;
  E$2(Mg), (tt._currentValue = et);
}
function Sg(tt, et, nt) {
  for (; tt !== null; ) {
    var rt = tt.alternate;
    if (
      ((tt.childLanes & et) !== et
        ? ((tt.childLanes |= et), rt !== null && (rt.childLanes |= et))
        : rt !== null && (rt.childLanes & et) !== et && (rt.childLanes |= et),
      tt === nt)
    )
      break;
    tt = tt.return;
  }
}
function Tg(tt, et) {
  (Ng = tt),
    (Pg = Og = null),
    (tt = tt.dependencies),
    tt !== null &&
      tt.firstContext !== null &&
      (tt.lanes & et && (Ug = !0), (tt.firstContext = null));
}
function Vg(tt) {
  var et = tt._currentValue;
  if (Pg !== tt)
    if (((tt = { context: tt, memoizedValue: et, next: null }), Og === null)) {
      if (Ng === null) throw Error(p$6(308));
      (Og = tt), (Ng.dependencies = { lanes: 0, firstContext: tt });
    } else Og = Og.next = tt;
  return et;
}
var Wg = null;
function Xg(tt) {
  Wg === null ? (Wg = [tt]) : Wg.push(tt);
}
function Yg(tt, et, nt, rt) {
  var it = et.interleaved;
  return (
    it === null
      ? ((nt.next = nt), Xg(et))
      : ((nt.next = it.next), (it.next = nt)),
    (et.interleaved = nt),
    Zg(tt, rt)
  );
}
function Zg(tt, et) {
  tt.lanes |= et;
  var nt = tt.alternate;
  for (nt !== null && (nt.lanes |= et), nt = tt, tt = tt.return; tt !== null; )
    (tt.childLanes |= et),
      (nt = tt.alternate),
      nt !== null && (nt.childLanes |= et),
      (nt = tt),
      (tt = tt.return);
  return nt.tag === 3 ? nt.stateNode : null;
}
var $g = !1;
function ah(tt) {
  tt.updateQueue = {
    baseState: tt.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function bh(tt, et) {
  (tt = tt.updateQueue),
    et.updateQueue === tt &&
      (et.updateQueue = {
        baseState: tt.baseState,
        firstBaseUpdate: tt.firstBaseUpdate,
        lastBaseUpdate: tt.lastBaseUpdate,
        shared: tt.shared,
        effects: tt.effects,
      });
}
function ch(tt, et) {
  return {
    eventTime: tt,
    lane: et,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function dh(tt, et, nt) {
  var rt = tt.updateQueue;
  if (rt === null) return null;
  if (((rt = rt.shared), K$1 & 2)) {
    var it = rt.pending;
    return (
      it === null ? (et.next = et) : ((et.next = it.next), (it.next = et)),
      (rt.pending = et),
      Zg(tt, nt)
    );
  }
  return (
    (it = rt.interleaved),
    it === null
      ? ((et.next = et), Xg(rt))
      : ((et.next = it.next), (it.next = et)),
    (rt.interleaved = et),
    Zg(tt, nt)
  );
}
function eh(tt, et, nt) {
  if (
    ((et = et.updateQueue),
    et !== null && ((et = et.shared), (nt & 4194240) !== 0))
  ) {
    var rt = et.lanes;
    (rt &= tt.pendingLanes), (nt |= rt), (et.lanes = nt), Cc(tt, nt);
  }
}
function fh(tt, et) {
  var nt = tt.updateQueue,
    rt = tt.alternate;
  if (rt !== null && ((rt = rt.updateQueue), nt === rt)) {
    var it = null,
      st = null;
    if (((nt = nt.firstBaseUpdate), nt !== null)) {
      do {
        var ot = {
          eventTime: nt.eventTime,
          lane: nt.lane,
          tag: nt.tag,
          payload: nt.payload,
          callback: nt.callback,
          next: null,
        };
        st === null ? (it = st = ot) : (st = st.next = ot), (nt = nt.next);
      } while (nt !== null);
      st === null ? (it = st = et) : (st = st.next = et);
    } else it = st = et;
    (nt = {
      baseState: rt.baseState,
      firstBaseUpdate: it,
      lastBaseUpdate: st,
      shared: rt.shared,
      effects: rt.effects,
    }),
      (tt.updateQueue = nt);
    return;
  }
  (tt = nt.lastBaseUpdate),
    tt === null ? (nt.firstBaseUpdate = et) : (tt.next = et),
    (nt.lastBaseUpdate = et);
}
function gh(tt, et, nt, rt) {
  var it = tt.updateQueue;
  $g = !1;
  var st = it.firstBaseUpdate,
    ot = it.lastBaseUpdate,
    at = it.shared.pending;
  if (at !== null) {
    it.shared.pending = null;
    var lt = at,
      ct = lt.next;
    (lt.next = null), ot === null ? (st = ct) : (ot.next = ct), (ot = lt);
    var ut = tt.alternate;
    ut !== null &&
      ((ut = ut.updateQueue),
      (at = ut.lastBaseUpdate),
      at !== ot &&
        (at === null ? (ut.firstBaseUpdate = ct) : (at.next = ct),
        (ut.lastBaseUpdate = lt)));
  }
  if (st !== null) {
    var ft = it.baseState;
    (ot = 0), (ut = ct = lt = null), (at = st);
    do {
      var ht = at.lane,
        mt = at.eventTime;
      if ((rt & ht) === ht) {
        ut !== null &&
          (ut = ut.next =
            {
              eventTime: mt,
              lane: 0,
              tag: at.tag,
              payload: at.payload,
              callback: at.callback,
              next: null,
            });
        e: {
          var vt = tt,
            yt = at;
          switch (((ht = et), (mt = nt), yt.tag)) {
            case 1:
              if (((vt = yt.payload), typeof vt == "function")) {
                ft = vt.call(mt, ft, ht);
                break e;
              }
              ft = vt;
              break e;
            case 3:
              vt.flags = (vt.flags & -65537) | 128;
            case 0:
              if (
                ((vt = yt.payload),
                (ht = typeof vt == "function" ? vt.call(mt, ft, ht) : vt),
                ht == null)
              )
                break e;
              ft = A$2({}, ft, ht);
              break e;
            case 2:
              $g = !0;
          }
        }
        at.callback !== null &&
          at.lane !== 0 &&
          ((tt.flags |= 64),
          (ht = it.effects),
          ht === null ? (it.effects = [at]) : ht.push(at));
      } else
        (mt = {
          eventTime: mt,
          lane: ht,
          tag: at.tag,
          payload: at.payload,
          callback: at.callback,
          next: null,
        }),
          ut === null ? ((ct = ut = mt), (lt = ft)) : (ut = ut.next = mt),
          (ot |= ht);
      if (((at = at.next), at === null)) {
        if (((at = it.shared.pending), at === null)) break;
        (ht = at),
          (at = ht.next),
          (ht.next = null),
          (it.lastBaseUpdate = ht),
          (it.shared.pending = null);
      }
    } while (1);
    if (
      (ut === null && (lt = ft),
      (it.baseState = lt),
      (it.firstBaseUpdate = ct),
      (it.lastBaseUpdate = ut),
      (et = it.shared.interleaved),
      et !== null)
    ) {
      it = et;
      do (ot |= it.lane), (it = it.next);
      while (it !== et);
    } else st === null && (it.shared.lanes = 0);
    (hh |= ot), (tt.lanes = ot), (tt.memoizedState = ft);
  }
}
function ih(tt, et, nt) {
  if (((tt = et.effects), (et.effects = null), tt !== null))
    for (et = 0; et < tt.length; et++) {
      var rt = tt[et],
        it = rt.callback;
      if (it !== null) {
        if (((rt.callback = null), (rt = nt), typeof it != "function"))
          throw Error(p$6(191, it));
        it.call(rt);
      }
    }
}
var jh = new aa.Component().refs;
function kh(tt, et, nt, rt) {
  (et = tt.memoizedState),
    (nt = nt(rt, et)),
    (nt = nt == null ? et : A$2({}, et, nt)),
    (tt.memoizedState = nt),
    tt.lanes === 0 && (tt.updateQueue.baseState = nt);
}
var nh = {
  isMounted: function (tt) {
    return (tt = tt._reactInternals) ? Vb(tt) === tt : !1;
  },
  enqueueSetState: function (tt, et, nt) {
    tt = tt._reactInternals;
    var rt = L$2(),
      it = lh(tt),
      st = ch(rt, it);
    (st.payload = et),
      nt != null && (st.callback = nt),
      (et = dh(tt, st, it)),
      et !== null && (mh(et, tt, it, rt), eh(et, tt, it));
  },
  enqueueReplaceState: function (tt, et, nt) {
    tt = tt._reactInternals;
    var rt = L$2(),
      it = lh(tt),
      st = ch(rt, it);
    (st.tag = 1),
      (st.payload = et),
      nt != null && (st.callback = nt),
      (et = dh(tt, st, it)),
      et !== null && (mh(et, tt, it, rt), eh(et, tt, it));
  },
  enqueueForceUpdate: function (tt, et) {
    tt = tt._reactInternals;
    var nt = L$2(),
      rt = lh(tt),
      it = ch(nt, rt);
    (it.tag = 2),
      et != null && (it.callback = et),
      (et = dh(tt, it, rt)),
      et !== null && (mh(et, tt, rt, nt), eh(et, tt, rt));
  },
};
function oh(tt, et, nt, rt, it, st, ot) {
  return (
    (tt = tt.stateNode),
    typeof tt.shouldComponentUpdate == "function"
      ? tt.shouldComponentUpdate(rt, st, ot)
      : et.prototype && et.prototype.isPureReactComponent
      ? !Ie(nt, rt) || !Ie(it, st)
      : !0
  );
}
function ph(tt, et, nt) {
  var rt = !1,
    it = Vf,
    st = et.contextType;
  return (
    typeof st == "object" && st !== null
      ? (st = Vg(st))
      : ((it = Zf(et) ? Xf : H$2.current),
        (rt = et.contextTypes),
        (st = (rt = rt != null) ? Yf(tt, it) : Vf)),
    (et = new et(nt, st)),
    (tt.memoizedState =
      et.state !== null && et.state !== void 0 ? et.state : null),
    (et.updater = nh),
    (tt.stateNode = et),
    (et._reactInternals = tt),
    rt &&
      ((tt = tt.stateNode),
      (tt.__reactInternalMemoizedUnmaskedChildContext = it),
      (tt.__reactInternalMemoizedMaskedChildContext = st)),
    et
  );
}
function qh(tt, et, nt, rt) {
  (tt = et.state),
    typeof et.componentWillReceiveProps == "function" &&
      et.componentWillReceiveProps(nt, rt),
    typeof et.UNSAFE_componentWillReceiveProps == "function" &&
      et.UNSAFE_componentWillReceiveProps(nt, rt),
    et.state !== tt && nh.enqueueReplaceState(et, et.state, null);
}
function rh(tt, et, nt, rt) {
  var it = tt.stateNode;
  (it.props = nt), (it.state = tt.memoizedState), (it.refs = jh), ah(tt);
  var st = et.contextType;
  typeof st == "object" && st !== null
    ? (it.context = Vg(st))
    : ((st = Zf(et) ? Xf : H$2.current), (it.context = Yf(tt, st))),
    (it.state = tt.memoizedState),
    (st = et.getDerivedStateFromProps),
    typeof st == "function" &&
      (kh(tt, et, st, nt), (it.state = tt.memoizedState)),
    typeof et.getDerivedStateFromProps == "function" ||
      typeof it.getSnapshotBeforeUpdate == "function" ||
      (typeof it.UNSAFE_componentWillMount != "function" &&
        typeof it.componentWillMount != "function") ||
      ((et = it.state),
      typeof it.componentWillMount == "function" && it.componentWillMount(),
      typeof it.UNSAFE_componentWillMount == "function" &&
        it.UNSAFE_componentWillMount(),
      et !== it.state && nh.enqueueReplaceState(it, it.state, null),
      gh(tt, nt, it, rt),
      (it.state = tt.memoizedState)),
    typeof it.componentDidMount == "function" && (tt.flags |= 4194308);
}
function sh(tt, et, nt) {
  if (
    ((tt = nt.ref),
    tt !== null && typeof tt != "function" && typeof tt != "object")
  ) {
    if (nt._owner) {
      if (((nt = nt._owner), nt)) {
        if (nt.tag !== 1) throw Error(p$6(309));
        var rt = nt.stateNode;
      }
      if (!rt) throw Error(p$6(147, tt));
      var it = rt,
        st = "" + tt;
      return et !== null &&
        et.ref !== null &&
        typeof et.ref == "function" &&
        et.ref._stringRef === st
        ? et.ref
        : ((et = function (ot) {
            var at = it.refs;
            at === jh && (at = it.refs = {}),
              ot === null ? delete at[st] : (at[st] = ot);
          }),
          (et._stringRef = st),
          et);
    }
    if (typeof tt != "string") throw Error(p$6(284));
    if (!nt._owner) throw Error(p$6(290, tt));
  }
  return tt;
}
function th(tt, et) {
  throw (
    ((tt = Object.prototype.toString.call(et)),
    Error(
      p$6(
        31,
        tt === "[object Object]"
          ? "object with keys {" + Object.keys(et).join(", ") + "}"
          : tt
      )
    ))
  );
}
function uh(tt) {
  var et = tt._init;
  return et(tt._payload);
}
function vh(tt) {
  function et(pt, xt) {
    if (tt) {
      var St = pt.deletions;
      St === null ? ((pt.deletions = [xt]), (pt.flags |= 16)) : St.push(xt);
    }
  }
  function nt(pt, xt) {
    if (!tt) return null;
    for (; xt !== null; ) et(pt, xt), (xt = xt.sibling);
    return null;
  }
  function rt(pt, xt) {
    for (pt = new Map(); xt !== null; )
      xt.key !== null ? pt.set(xt.key, xt) : pt.set(xt.index, xt),
        (xt = xt.sibling);
    return pt;
  }
  function it(pt, xt) {
    return (pt = wh(pt, xt)), (pt.index = 0), (pt.sibling = null), pt;
  }
  function st(pt, xt, St) {
    return (
      (pt.index = St),
      tt
        ? ((St = pt.alternate),
          St !== null
            ? ((St = St.index), St < xt ? ((pt.flags |= 2), xt) : St)
            : ((pt.flags |= 2), xt))
        : ((pt.flags |= 1048576), xt)
    );
  }
  function ot(pt) {
    return tt && pt.alternate === null && (pt.flags |= 2), pt;
  }
  function at(pt, xt, St, At) {
    return xt === null || xt.tag !== 6
      ? ((xt = xh(St, pt.mode, At)), (xt.return = pt), xt)
      : ((xt = it(xt, St)), (xt.return = pt), xt);
  }
  function lt(pt, xt, St, At) {
    var Ct = St.type;
    return Ct === ya
      ? ut(pt, xt, St.props.children, At, St.key)
      : xt !== null &&
        (xt.elementType === Ct ||
          (typeof Ct == "object" &&
            Ct !== null &&
            Ct.$$typeof === Ha &&
            uh(Ct) === xt.type))
      ? ((At = it(xt, St.props)),
        (At.ref = sh(pt, xt, St)),
        (At.return = pt),
        At)
      : ((At = yh(St.type, St.key, St.props, null, pt.mode, At)),
        (At.ref = sh(pt, xt, St)),
        (At.return = pt),
        At);
  }
  function ct(pt, xt, St, At) {
    return xt === null ||
      xt.tag !== 4 ||
      xt.stateNode.containerInfo !== St.containerInfo ||
      xt.stateNode.implementation !== St.implementation
      ? ((xt = zh(St, pt.mode, At)), (xt.return = pt), xt)
      : ((xt = it(xt, St.children || [])), (xt.return = pt), xt);
  }
  function ut(pt, xt, St, At, Ct) {
    return xt === null || xt.tag !== 7
      ? ((xt = Ah(St, pt.mode, At, Ct)), (xt.return = pt), xt)
      : ((xt = it(xt, St)), (xt.return = pt), xt);
  }
  function ft(pt, xt, St) {
    if ((typeof xt == "string" && xt !== "") || typeof xt == "number")
      return (xt = xh("" + xt, pt.mode, St)), (xt.return = pt), xt;
    if (typeof xt == "object" && xt !== null) {
      switch (xt.$$typeof) {
        case va:
          return (
            (St = yh(xt.type, xt.key, xt.props, null, pt.mode, St)),
            (St.ref = sh(pt, null, xt)),
            (St.return = pt),
            St
          );
        case wa:
          return (xt = zh(xt, pt.mode, St)), (xt.return = pt), xt;
        case Ha:
          var At = xt._init;
          return ft(pt, At(xt._payload), St);
      }
      if (eb(xt) || Ka(xt))
        return (xt = Ah(xt, pt.mode, St, null)), (xt.return = pt), xt;
      th(pt, xt);
    }
    return null;
  }
  function ht(pt, xt, St, At) {
    var Ct = xt !== null ? xt.key : null;
    if ((typeof St == "string" && St !== "") || typeof St == "number")
      return Ct !== null ? null : at(pt, xt, "" + St, At);
    if (typeof St == "object" && St !== null) {
      switch (St.$$typeof) {
        case va:
          return St.key === Ct ? lt(pt, xt, St, At) : null;
        case wa:
          return St.key === Ct ? ct(pt, xt, St, At) : null;
        case Ha:
          return (Ct = St._init), ht(pt, xt, Ct(St._payload), At);
      }
      if (eb(St) || Ka(St))
        return Ct !== null ? null : ut(pt, xt, St, At, null);
      th(pt, St);
    }
    return null;
  }
  function mt(pt, xt, St, At, Ct) {
    if ((typeof At == "string" && At !== "") || typeof At == "number")
      return (pt = pt.get(St) || null), at(xt, pt, "" + At, Ct);
    if (typeof At == "object" && At !== null) {
      switch (At.$$typeof) {
        case va:
          return (
            (pt = pt.get(At.key === null ? St : At.key) || null),
            lt(xt, pt, At, Ct)
          );
        case wa:
          return (
            (pt = pt.get(At.key === null ? St : At.key) || null),
            ct(xt, pt, At, Ct)
          );
        case Ha:
          var Mt = At._init;
          return mt(pt, xt, St, Mt(At._payload), Ct);
      }
      if (eb(At) || Ka(At))
        return (pt = pt.get(St) || null), ut(xt, pt, At, Ct, null);
      th(xt, At);
    }
    return null;
  }
  function vt(pt, xt, St, At) {
    for (
      var Ct = null, Mt = null, wt = xt, Bt = (xt = 0), It = null;
      wt !== null && Bt < St.length;
      Bt++
    ) {
      wt.index > Bt ? ((It = wt), (wt = null)) : (It = wt.sibling);
      var Ft = ht(pt, wt, St[Bt], At);
      if (Ft === null) {
        wt === null && (wt = It);
        break;
      }
      tt && wt && Ft.alternate === null && et(pt, wt),
        (xt = st(Ft, xt, Bt)),
        Mt === null ? (Ct = Ft) : (Mt.sibling = Ft),
        (Mt = Ft),
        (wt = It);
    }
    if (Bt === St.length) return nt(pt, wt), I$2 && tg(pt, Bt), Ct;
    if (wt === null) {
      for (; Bt < St.length; Bt++)
        (wt = ft(pt, St[Bt], At)),
          wt !== null &&
            ((xt = st(wt, xt, Bt)),
            Mt === null ? (Ct = wt) : (Mt.sibling = wt),
            (Mt = wt));
      return I$2 && tg(pt, Bt), Ct;
    }
    for (wt = rt(pt, wt); Bt < St.length; Bt++)
      (It = mt(wt, pt, Bt, St[Bt], At)),
        It !== null &&
          (tt &&
            It.alternate !== null &&
            wt.delete(It.key === null ? Bt : It.key),
          (xt = st(It, xt, Bt)),
          Mt === null ? (Ct = It) : (Mt.sibling = It),
          (Mt = It));
    return (
      tt &&
        wt.forEach(function (Vt) {
          return et(pt, Vt);
        }),
      I$2 && tg(pt, Bt),
      Ct
    );
  }
  function yt(pt, xt, St, At) {
    var Ct = Ka(St);
    if (typeof Ct != "function") throw Error(p$6(150));
    if (((St = Ct.call(St)), St == null)) throw Error(p$6(151));
    for (
      var Mt = (Ct = null), wt = xt, Bt = (xt = 0), It = null, Ft = St.next();
      wt !== null && !Ft.done;
      Bt++, Ft = St.next()
    ) {
      wt.index > Bt ? ((It = wt), (wt = null)) : (It = wt.sibling);
      var Vt = ht(pt, wt, Ft.value, At);
      if (Vt === null) {
        wt === null && (wt = It);
        break;
      }
      tt && wt && Vt.alternate === null && et(pt, wt),
        (xt = st(Vt, xt, Bt)),
        Mt === null ? (Ct = Vt) : (Mt.sibling = Vt),
        (Mt = Vt),
        (wt = It);
    }
    if (Ft.done) return nt(pt, wt), I$2 && tg(pt, Bt), Ct;
    if (wt === null) {
      for (; !Ft.done; Bt++, Ft = St.next())
        (Ft = ft(pt, Ft.value, At)),
          Ft !== null &&
            ((xt = st(Ft, xt, Bt)),
            Mt === null ? (Ct = Ft) : (Mt.sibling = Ft),
            (Mt = Ft));
      return I$2 && tg(pt, Bt), Ct;
    }
    for (wt = rt(pt, wt); !Ft.done; Bt++, Ft = St.next())
      (Ft = mt(wt, pt, Bt, Ft.value, At)),
        Ft !== null &&
          (tt &&
            Ft.alternate !== null &&
            wt.delete(Ft.key === null ? Bt : Ft.key),
          (xt = st(Ft, xt, Bt)),
          Mt === null ? (Ct = Ft) : (Mt.sibling = Ft),
          (Mt = Ft));
    return (
      tt &&
        wt.forEach(function ($t) {
          return et(pt, $t);
        }),
      I$2 && tg(pt, Bt),
      Ct
    );
  }
  function Et(pt, xt, St, At) {
    if (
      (typeof St == "object" &&
        St !== null &&
        St.type === ya &&
        St.key === null &&
        (St = St.props.children),
      typeof St == "object" && St !== null)
    ) {
      switch (St.$$typeof) {
        case va:
          e: {
            for (var Ct = St.key, Mt = xt; Mt !== null; ) {
              if (Mt.key === Ct) {
                if (((Ct = St.type), Ct === ya)) {
                  if (Mt.tag === 7) {
                    nt(pt, Mt.sibling),
                      (xt = it(Mt, St.props.children)),
                      (xt.return = pt),
                      (pt = xt);
                    break e;
                  }
                } else if (
                  Mt.elementType === Ct ||
                  (typeof Ct == "object" &&
                    Ct !== null &&
                    Ct.$$typeof === Ha &&
                    uh(Ct) === Mt.type)
                ) {
                  nt(pt, Mt.sibling),
                    (xt = it(Mt, St.props)),
                    (xt.ref = sh(pt, Mt, St)),
                    (xt.return = pt),
                    (pt = xt);
                  break e;
                }
                nt(pt, Mt);
                break;
              } else et(pt, Mt);
              Mt = Mt.sibling;
            }
            St.type === ya
              ? ((xt = Ah(St.props.children, pt.mode, At, St.key)),
                (xt.return = pt),
                (pt = xt))
              : ((At = yh(St.type, St.key, St.props, null, pt.mode, At)),
                (At.ref = sh(pt, xt, St)),
                (At.return = pt),
                (pt = At));
          }
          return ot(pt);
        case wa:
          e: {
            for (Mt = St.key; xt !== null; ) {
              if (xt.key === Mt)
                if (
                  xt.tag === 4 &&
                  xt.stateNode.containerInfo === St.containerInfo &&
                  xt.stateNode.implementation === St.implementation
                ) {
                  nt(pt, xt.sibling),
                    (xt = it(xt, St.children || [])),
                    (xt.return = pt),
                    (pt = xt);
                  break e;
                } else {
                  nt(pt, xt);
                  break;
                }
              else et(pt, xt);
              xt = xt.sibling;
            }
            (xt = zh(St, pt.mode, At)), (xt.return = pt), (pt = xt);
          }
          return ot(pt);
        case Ha:
          return (Mt = St._init), Et(pt, xt, Mt(St._payload), At);
      }
      if (eb(St)) return vt(pt, xt, St, At);
      if (Ka(St)) return yt(pt, xt, St, At);
      th(pt, St);
    }
    return (typeof St == "string" && St !== "") || typeof St == "number"
      ? ((St = "" + St),
        xt !== null && xt.tag === 6
          ? (nt(pt, xt.sibling), (xt = it(xt, St)), (xt.return = pt), (pt = xt))
          : (nt(pt, xt),
            (xt = xh(St, pt.mode, At)),
            (xt.return = pt),
            (pt = xt)),
        ot(pt))
      : nt(pt, xt);
  }
  return Et;
}
var Bh = vh(!0),
  Ch = vh(!1),
  Dh = {},
  Eh = Uf(Dh),
  Fh = Uf(Dh),
  Gh = Uf(Dh);
function Hh(tt) {
  if (tt === Dh) throw Error(p$6(174));
  return tt;
}
function Ih(tt, et) {
  switch ((G$2(Gh, et), G$2(Fh, tt), G$2(Eh, Dh), (tt = et.nodeType), tt)) {
    case 9:
    case 11:
      et = (et = et.documentElement) ? et.namespaceURI : lb(null, "");
      break;
    default:
      (tt = tt === 8 ? et.parentNode : et),
        (et = tt.namespaceURI || null),
        (tt = tt.tagName),
        (et = lb(et, tt));
  }
  E$2(Eh), G$2(Eh, et);
}
function Jh() {
  E$2(Eh), E$2(Fh), E$2(Gh);
}
function Kh(tt) {
  Hh(Gh.current);
  var et = Hh(Eh.current),
    nt = lb(et, tt.type);
  et !== nt && (G$2(Fh, tt), G$2(Eh, nt));
}
function Lh(tt) {
  Fh.current === tt && (E$2(Eh), E$2(Fh));
}
var M$2 = Uf(0);
function Mh(tt) {
  for (var et = tt; et !== null; ) {
    if (et.tag === 13) {
      var nt = et.memoizedState;
      if (
        nt !== null &&
        ((nt = nt.dehydrated),
        nt === null || nt.data === "$?" || nt.data === "$!")
      )
        return et;
    } else if (et.tag === 19 && et.memoizedProps.revealOrder !== void 0) {
      if (et.flags & 128) return et;
    } else if (et.child !== null) {
      (et.child.return = et), (et = et.child);
      continue;
    }
    if (et === tt) break;
    for (; et.sibling === null; ) {
      if (et.return === null || et.return === tt) return null;
      et = et.return;
    }
    (et.sibling.return = et.return), (et = et.sibling);
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var tt = 0; tt < Nh.length; tt++)
    Nh[tt]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher,
  Qh = ua.ReactCurrentBatchConfig,
  Rh = 0,
  N$2 = null,
  O$1 = null,
  P$1 = null,
  Sh = !1,
  Th = !1,
  Uh = 0,
  Vh = 0;
function Q$2() {
  throw Error(p$6(321));
}
function Wh(tt, et) {
  if (et === null) return !1;
  for (var nt = 0; nt < et.length && nt < tt.length; nt++)
    if (!He(tt[nt], et[nt])) return !1;
  return !0;
}
function Xh(tt, et, nt, rt, it, st) {
  if (
    ((Rh = st),
    (N$2 = et),
    (et.memoizedState = null),
    (et.updateQueue = null),
    (et.lanes = 0),
    (Ph.current = tt === null || tt.memoizedState === null ? Yh : Zh),
    (tt = nt(rt, it)),
    Th)
  ) {
    st = 0;
    do {
      if (((Th = !1), (Uh = 0), 25 <= st)) throw Error(p$6(301));
      (st += 1),
        (P$1 = O$1 = null),
        (et.updateQueue = null),
        (Ph.current = $h),
        (tt = nt(rt, it));
    } while (Th);
  }
  if (
    ((Ph.current = ai),
    (et = O$1 !== null && O$1.next !== null),
    (Rh = 0),
    (P$1 = O$1 = N$2 = null),
    (Sh = !1),
    et)
  )
    throw Error(p$6(300));
  return tt;
}
function bi() {
  var tt = Uh !== 0;
  return (Uh = 0), tt;
}
function ci() {
  var tt = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return (
    P$1 === null ? (N$2.memoizedState = P$1 = tt) : (P$1 = P$1.next = tt), P$1
  );
}
function di() {
  if (O$1 === null) {
    var tt = N$2.alternate;
    tt = tt !== null ? tt.memoizedState : null;
  } else tt = O$1.next;
  var et = P$1 === null ? N$2.memoizedState : P$1.next;
  if (et !== null) (P$1 = et), (O$1 = tt);
  else {
    if (tt === null) throw Error(p$6(310));
    (O$1 = tt),
      (tt = {
        memoizedState: O$1.memoizedState,
        baseState: O$1.baseState,
        baseQueue: O$1.baseQueue,
        queue: O$1.queue,
        next: null,
      }),
      P$1 === null ? (N$2.memoizedState = P$1 = tt) : (P$1 = P$1.next = tt);
  }
  return P$1;
}
function ei(tt, et) {
  return typeof et == "function" ? et(tt) : et;
}
function fi(tt) {
  var et = di(),
    nt = et.queue;
  if (nt === null) throw Error(p$6(311));
  nt.lastRenderedReducer = tt;
  var rt = O$1,
    it = rt.baseQueue,
    st = nt.pending;
  if (st !== null) {
    if (it !== null) {
      var ot = it.next;
      (it.next = st.next), (st.next = ot);
    }
    (rt.baseQueue = it = st), (nt.pending = null);
  }
  if (it !== null) {
    (st = it.next), (rt = rt.baseState);
    var at = (ot = null),
      lt = null,
      ct = st;
    do {
      var ut = ct.lane;
      if ((Rh & ut) === ut)
        lt !== null &&
          (lt = lt.next =
            {
              lane: 0,
              action: ct.action,
              hasEagerState: ct.hasEagerState,
              eagerState: ct.eagerState,
              next: null,
            }),
          (rt = ct.hasEagerState ? ct.eagerState : tt(rt, ct.action));
      else {
        var ft = {
          lane: ut,
          action: ct.action,
          hasEagerState: ct.hasEagerState,
          eagerState: ct.eagerState,
          next: null,
        };
        lt === null ? ((at = lt = ft), (ot = rt)) : (lt = lt.next = ft),
          (N$2.lanes |= ut),
          (hh |= ut);
      }
      ct = ct.next;
    } while (ct !== null && ct !== st);
    lt === null ? (ot = rt) : (lt.next = at),
      He(rt, et.memoizedState) || (Ug = !0),
      (et.memoizedState = rt),
      (et.baseState = ot),
      (et.baseQueue = lt),
      (nt.lastRenderedState = rt);
  }
  if (((tt = nt.interleaved), tt !== null)) {
    it = tt;
    do (st = it.lane), (N$2.lanes |= st), (hh |= st), (it = it.next);
    while (it !== tt);
  } else it === null && (nt.lanes = 0);
  return [et.memoizedState, nt.dispatch];
}
function gi(tt) {
  var et = di(),
    nt = et.queue;
  if (nt === null) throw Error(p$6(311));
  nt.lastRenderedReducer = tt;
  var rt = nt.dispatch,
    it = nt.pending,
    st = et.memoizedState;
  if (it !== null) {
    nt.pending = null;
    var ot = (it = it.next);
    do (st = tt(st, ot.action)), (ot = ot.next);
    while (ot !== it);
    He(st, et.memoizedState) || (Ug = !0),
      (et.memoizedState = st),
      et.baseQueue === null && (et.baseState = st),
      (nt.lastRenderedState = st);
  }
  return [st, rt];
}
function hi() {}
function ii(tt, et) {
  var nt = N$2,
    rt = di(),
    it = et(),
    st = !He(rt.memoizedState, it);
  if (
    (st && ((rt.memoizedState = it), (Ug = !0)),
    (rt = rt.queue),
    ji(ki.bind(null, nt, rt, tt), [tt]),
    rt.getSnapshot !== et || st || (P$1 !== null && P$1.memoizedState.tag & 1))
  ) {
    if (
      ((nt.flags |= 2048),
      li(9, mi.bind(null, nt, rt, it, et), void 0, null),
      R$1 === null)
    )
      throw Error(p$6(349));
    Rh & 30 || ni(nt, et, it);
  }
  return it;
}
function ni(tt, et, nt) {
  (tt.flags |= 16384),
    (tt = { getSnapshot: et, value: nt }),
    (et = N$2.updateQueue),
    et === null
      ? ((et = { lastEffect: null, stores: null }),
        (N$2.updateQueue = et),
        (et.stores = [tt]))
      : ((nt = et.stores), nt === null ? (et.stores = [tt]) : nt.push(tt));
}
function mi(tt, et, nt, rt) {
  (et.value = nt), (et.getSnapshot = rt), oi(et) && pi(tt);
}
function ki(tt, et, nt) {
  return nt(function () {
    oi(et) && pi(tt);
  });
}
function oi(tt) {
  var et = tt.getSnapshot;
  tt = tt.value;
  try {
    var nt = et();
    return !He(tt, nt);
  } catch {
    return !0;
  }
}
function pi(tt) {
  var et = Zg(tt, 1);
  et !== null && mh(et, tt, 1, -1);
}
function qi(tt) {
  var et = ci();
  return (
    typeof tt == "function" && (tt = tt()),
    (et.memoizedState = et.baseState = tt),
    (tt = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ei,
      lastRenderedState: tt,
    }),
    (et.queue = tt),
    (tt = tt.dispatch = ri.bind(null, N$2, tt)),
    [et.memoizedState, tt]
  );
}
function li(tt, et, nt, rt) {
  return (
    (tt = { tag: tt, create: et, destroy: nt, deps: rt, next: null }),
    (et = N$2.updateQueue),
    et === null
      ? ((et = { lastEffect: null, stores: null }),
        (N$2.updateQueue = et),
        (et.lastEffect = tt.next = tt))
      : ((nt = et.lastEffect),
        nt === null
          ? (et.lastEffect = tt.next = tt)
          : ((rt = nt.next),
            (nt.next = tt),
            (tt.next = rt),
            (et.lastEffect = tt))),
    tt
  );
}
function si() {
  return di().memoizedState;
}
function ti(tt, et, nt, rt) {
  var it = ci();
  (N$2.flags |= tt),
    (it.memoizedState = li(1 | et, nt, void 0, rt === void 0 ? null : rt));
}
function ui(tt, et, nt, rt) {
  var it = di();
  rt = rt === void 0 ? null : rt;
  var st = void 0;
  if (O$1 !== null) {
    var ot = O$1.memoizedState;
    if (((st = ot.destroy), rt !== null && Wh(rt, ot.deps))) {
      it.memoizedState = li(et, nt, st, rt);
      return;
    }
  }
  (N$2.flags |= tt), (it.memoizedState = li(1 | et, nt, st, rt));
}
function vi(tt, et) {
  return ti(8390656, 8, tt, et);
}
function ji(tt, et) {
  return ui(2048, 8, tt, et);
}
function wi(tt, et) {
  return ui(4, 2, tt, et);
}
function xi(tt, et) {
  return ui(4, 4, tt, et);
}
function yi(tt, et) {
  if (typeof et == "function")
    return (
      (tt = tt()),
      et(tt),
      function () {
        et(null);
      }
    );
  if (et != null)
    return (
      (tt = tt()),
      (et.current = tt),
      function () {
        et.current = null;
      }
    );
}
function zi(tt, et, nt) {
  return (
    (nt = nt != null ? nt.concat([tt]) : null),
    ui(4, 4, yi.bind(null, et, tt), nt)
  );
}
function Ai() {}
function Bi(tt, et) {
  var nt = di();
  et = et === void 0 ? null : et;
  var rt = nt.memoizedState;
  return rt !== null && et !== null && Wh(et, rt[1])
    ? rt[0]
    : ((nt.memoizedState = [tt, et]), tt);
}
function Ci(tt, et) {
  var nt = di();
  et = et === void 0 ? null : et;
  var rt = nt.memoizedState;
  return rt !== null && et !== null && Wh(et, rt[1])
    ? rt[0]
    : ((tt = tt()), (nt.memoizedState = [tt, et]), tt);
}
function Di(tt, et, nt) {
  return Rh & 21
    ? (He(nt, et) ||
        ((nt = yc()), (N$2.lanes |= nt), (hh |= nt), (tt.baseState = !0)),
      et)
    : (tt.baseState && ((tt.baseState = !1), (Ug = !0)),
      (tt.memoizedState = nt));
}
function Ei(tt, et) {
  var nt = C$1;
  (C$1 = nt !== 0 && 4 > nt ? nt : 4), tt(!0);
  var rt = Qh.transition;
  Qh.transition = {};
  try {
    tt(!1), et();
  } finally {
    (C$1 = nt), (Qh.transition = rt);
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(tt, et, nt) {
  var rt = lh(tt);
  if (
    ((nt = {
      lane: rt,
      action: nt,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Hi(tt))
  )
    Ii(et, nt);
  else if (((nt = Yg(tt, et, nt, rt)), nt !== null)) {
    var it = L$2();
    mh(nt, tt, rt, it), Ji(nt, et, rt);
  }
}
function ri(tt, et, nt) {
  var rt = lh(tt),
    it = {
      lane: rt,
      action: nt,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
  if (Hi(tt)) Ii(et, it);
  else {
    var st = tt.alternate;
    if (
      tt.lanes === 0 &&
      (st === null || st.lanes === 0) &&
      ((st = et.lastRenderedReducer), st !== null)
    )
      try {
        var ot = et.lastRenderedState,
          at = st(ot, nt);
        if (((it.hasEagerState = !0), (it.eagerState = at), He(at, ot))) {
          var lt = et.interleaved;
          lt === null
            ? ((it.next = it), Xg(et))
            : ((it.next = lt.next), (lt.next = it)),
            (et.interleaved = it);
          return;
        }
      } catch {
      } finally {
      }
    (nt = Yg(tt, et, it, rt)),
      nt !== null && ((it = L$2()), mh(nt, tt, rt, it), Ji(nt, et, rt));
  }
}
function Hi(tt) {
  var et = tt.alternate;
  return tt === N$2 || (et !== null && et === N$2);
}
function Ii(tt, et) {
  Th = Sh = !0;
  var nt = tt.pending;
  nt === null ? (et.next = et) : ((et.next = nt.next), (nt.next = et)),
    (tt.pending = et);
}
function Ji(tt, et, nt) {
  if (nt & 4194240) {
    var rt = et.lanes;
    (rt &= tt.pendingLanes), (nt |= rt), (et.lanes = nt), Cc(tt, nt);
  }
}
var ai = {
    readContext: Vg,
    useCallback: Q$2,
    useContext: Q$2,
    useEffect: Q$2,
    useImperativeHandle: Q$2,
    useInsertionEffect: Q$2,
    useLayoutEffect: Q$2,
    useMemo: Q$2,
    useReducer: Q$2,
    useRef: Q$2,
    useState: Q$2,
    useDebugValue: Q$2,
    useDeferredValue: Q$2,
    useTransition: Q$2,
    useMutableSource: Q$2,
    useSyncExternalStore: Q$2,
    useId: Q$2,
    unstable_isNewReconciler: !1,
  },
  Yh = {
    readContext: Vg,
    useCallback: function (tt, et) {
      return (ci().memoizedState = [tt, et === void 0 ? null : et]), tt;
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function (tt, et, nt) {
      return (
        (nt = nt != null ? nt.concat([tt]) : null),
        ti(4194308, 4, yi.bind(null, et, tt), nt)
      );
    },
    useLayoutEffect: function (tt, et) {
      return ti(4194308, 4, tt, et);
    },
    useInsertionEffect: function (tt, et) {
      return ti(4, 2, tt, et);
    },
    useMemo: function (tt, et) {
      var nt = ci();
      return (
        (et = et === void 0 ? null : et),
        (tt = tt()),
        (nt.memoizedState = [tt, et]),
        tt
      );
    },
    useReducer: function (tt, et, nt) {
      var rt = ci();
      return (
        (et = nt !== void 0 ? nt(et) : et),
        (rt.memoizedState = rt.baseState = et),
        (tt = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: tt,
          lastRenderedState: et,
        }),
        (rt.queue = tt),
        (tt = tt.dispatch = Gi.bind(null, N$2, tt)),
        [rt.memoizedState, tt]
      );
    },
    useRef: function (tt) {
      var et = ci();
      return (tt = { current: tt }), (et.memoizedState = tt);
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function (tt) {
      return (ci().memoizedState = tt);
    },
    useTransition: function () {
      var tt = qi(!1),
        et = tt[0];
      return (tt = Ei.bind(null, tt[1])), (ci().memoizedState = tt), [et, tt];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (tt, et, nt) {
      var rt = N$2,
        it = ci();
      if (I$2) {
        if (nt === void 0) throw Error(p$6(407));
        nt = nt();
      } else {
        if (((nt = et()), R$1 === null)) throw Error(p$6(349));
        Rh & 30 || ni(rt, et, nt);
      }
      it.memoizedState = nt;
      var st = { value: nt, getSnapshot: et };
      return (
        (it.queue = st),
        vi(ki.bind(null, rt, st, tt), [tt]),
        (rt.flags |= 2048),
        li(9, mi.bind(null, rt, st, nt, et), void 0, null),
        nt
      );
    },
    useId: function () {
      var tt = ci(),
        et = R$1.identifierPrefix;
      if (I$2) {
        var nt = sg,
          rt = rg;
        (nt = (rt & ~(1 << (32 - oc(rt) - 1))).toString(32) + nt),
          (et = ":" + et + "R" + nt),
          (nt = Uh++),
          0 < nt && (et += "H" + nt.toString(32)),
          (et += ":");
      } else (nt = Vh++), (et = ":" + et + "r" + nt.toString(32) + ":");
      return (tt.memoizedState = et);
    },
    unstable_isNewReconciler: !1,
  },
  Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function () {
      return fi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (tt) {
      var et = di();
      return Di(et, O$1.memoizedState, tt);
    },
    useTransition: function () {
      var tt = fi(ei)[0],
        et = di().memoizedState;
      return [tt, et];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1,
  },
  $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function () {
      return gi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (tt) {
      var et = di();
      return O$1 === null
        ? (et.memoizedState = tt)
        : Di(et, O$1.memoizedState, tt);
    },
    useTransition: function () {
      var tt = gi(ei)[0],
        et = di().memoizedState;
      return [tt, et];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1,
  };
function Ki(tt, et) {
  try {
    var nt = "",
      rt = et;
    do (nt += Pa(rt)), (rt = rt.return);
    while (rt);
    var it = nt;
  } catch (st) {
    it =
      `
Error generating stack: ` +
      st.message +
      `
` +
      st.stack;
  }
  return { value: tt, source: et, stack: it, digest: null };
}
function Li(tt, et, nt) {
  return { value: tt, source: null, stack: nt ?? null, digest: et ?? null };
}
function Mi(tt, et) {
  try {
    console.error(et.value);
  } catch (nt) {
    setTimeout(function () {
      throw nt;
    });
  }
}
var Ni = typeof WeakMap == "function" ? WeakMap : Map;
function Oi(tt, et, nt) {
  (nt = ch(-1, nt)), (nt.tag = 3), (nt.payload = { element: null });
  var rt = et.value;
  return (
    (nt.callback = function () {
      Pi || ((Pi = !0), (Qi = rt)), Mi(tt, et);
    }),
    nt
  );
}
function Ri(tt, et, nt) {
  (nt = ch(-1, nt)), (nt.tag = 3);
  var rt = tt.type.getDerivedStateFromError;
  if (typeof rt == "function") {
    var it = et.value;
    (nt.payload = function () {
      return rt(it);
    }),
      (nt.callback = function () {
        Mi(tt, et);
      });
  }
  var st = tt.stateNode;
  return (
    st !== null &&
      typeof st.componentDidCatch == "function" &&
      (nt.callback = function () {
        Mi(tt, et),
          typeof rt != "function" &&
            (Si === null ? (Si = new Set([this])) : Si.add(this));
        var ot = et.stack;
        this.componentDidCatch(et.value, {
          componentStack: ot !== null ? ot : "",
        });
      }),
    nt
  );
}
function Ti(tt, et, nt) {
  var rt = tt.pingCache;
  if (rt === null) {
    rt = tt.pingCache = new Ni();
    var it = new Set();
    rt.set(et, it);
  } else (it = rt.get(et)), it === void 0 && ((it = new Set()), rt.set(et, it));
  it.has(nt) || (it.add(nt), (tt = Ui.bind(null, tt, et, nt)), et.then(tt, tt));
}
function Vi(tt) {
  do {
    var et;
    if (
      ((et = tt.tag === 13) &&
        ((et = tt.memoizedState),
        (et = et !== null ? et.dehydrated !== null : !0)),
      et)
    )
      return tt;
    tt = tt.return;
  } while (tt !== null);
  return null;
}
function Wi(tt, et, nt, rt, it) {
  return tt.mode & 1
    ? ((tt.flags |= 65536), (tt.lanes = it), tt)
    : (tt === et
        ? (tt.flags |= 65536)
        : ((tt.flags |= 128),
          (nt.flags |= 131072),
          (nt.flags &= -52805),
          nt.tag === 1 &&
            (nt.alternate === null
              ? (nt.tag = 17)
              : ((et = ch(-1, 1)), (et.tag = 2), dh(nt, et, 1))),
          (nt.lanes |= 1)),
      tt);
}
var Xi = ua.ReactCurrentOwner,
  Ug = !1;
function Yi(tt, et, nt, rt) {
  et.child = tt === null ? Ch(et, null, nt, rt) : Bh(et, tt.child, nt, rt);
}
function Zi(tt, et, nt, rt, it) {
  nt = nt.render;
  var st = et.ref;
  return (
    Tg(et, it),
    (rt = Xh(tt, et, nt, rt, st, it)),
    (nt = bi()),
    tt !== null && !Ug
      ? ((et.updateQueue = tt.updateQueue),
        (et.flags &= -2053),
        (tt.lanes &= ~it),
        $i(tt, et, it))
      : (I$2 && nt && vg(et), (et.flags |= 1), Yi(tt, et, rt, it), et.child)
  );
}
function aj(tt, et, nt, rt, it) {
  if (tt === null) {
    var st = nt.type;
    return typeof st == "function" &&
      !bj(st) &&
      st.defaultProps === void 0 &&
      nt.compare === null &&
      nt.defaultProps === void 0
      ? ((et.tag = 15), (et.type = st), cj(tt, et, st, rt, it))
      : ((tt = yh(nt.type, null, rt, et, et.mode, it)),
        (tt.ref = et.ref),
        (tt.return = et),
        (et.child = tt));
  }
  if (((st = tt.child), !(tt.lanes & it))) {
    var ot = st.memoizedProps;
    if (
      ((nt = nt.compare),
      (nt = nt !== null ? nt : Ie),
      nt(ot, rt) && tt.ref === et.ref)
    )
      return $i(tt, et, it);
  }
  return (
    (et.flags |= 1),
    (tt = wh(st, rt)),
    (tt.ref = et.ref),
    (tt.return = et),
    (et.child = tt)
  );
}
function cj(tt, et, nt, rt, it) {
  if (tt !== null) {
    var st = tt.memoizedProps;
    if (Ie(st, rt) && tt.ref === et.ref)
      if (((Ug = !1), (et.pendingProps = rt = st), (tt.lanes & it) !== 0))
        tt.flags & 131072 && (Ug = !0);
      else return (et.lanes = tt.lanes), $i(tt, et, it);
  }
  return dj(tt, et, nt, rt, it);
}
function ej(tt, et, nt) {
  var rt = et.pendingProps,
    it = rt.children,
    st = tt !== null ? tt.memoizedState : null;
  if (rt.mode === "hidden")
    if (!(et.mode & 1))
      (et.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        G$2(fj, gj),
        (gj |= nt);
    else {
      if (!(nt & 1073741824))
        return (
          (tt = st !== null ? st.baseLanes | nt : nt),
          (et.lanes = et.childLanes = 1073741824),
          (et.memoizedState = {
            baseLanes: tt,
            cachePool: null,
            transitions: null,
          }),
          (et.updateQueue = null),
          G$2(fj, gj),
          (gj |= tt),
          null
        );
      (et.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (rt = st !== null ? st.baseLanes : nt),
        G$2(fj, gj),
        (gj |= rt);
    }
  else
    st !== null
      ? ((rt = st.baseLanes | nt), (et.memoizedState = null))
      : (rt = nt),
      G$2(fj, gj),
      (gj |= rt);
  return Yi(tt, et, it, nt), et.child;
}
function hj(tt, et) {
  var nt = et.ref;
  ((tt === null && nt !== null) || (tt !== null && tt.ref !== nt)) &&
    ((et.flags |= 512), (et.flags |= 2097152));
}
function dj(tt, et, nt, rt, it) {
  var st = Zf(nt) ? Xf : H$2.current;
  return (
    (st = Yf(et, st)),
    Tg(et, it),
    (nt = Xh(tt, et, nt, rt, st, it)),
    (rt = bi()),
    tt !== null && !Ug
      ? ((et.updateQueue = tt.updateQueue),
        (et.flags &= -2053),
        (tt.lanes &= ~it),
        $i(tt, et, it))
      : (I$2 && rt && vg(et), (et.flags |= 1), Yi(tt, et, nt, it), et.child)
  );
}
function ij(tt, et, nt, rt, it) {
  if (Zf(nt)) {
    var st = !0;
    cg(et);
  } else st = !1;
  if ((Tg(et, it), et.stateNode === null))
    jj(tt, et), ph(et, nt, rt), rh(et, nt, rt, it), (rt = !0);
  else if (tt === null) {
    var ot = et.stateNode,
      at = et.memoizedProps;
    ot.props = at;
    var lt = ot.context,
      ct = nt.contextType;
    typeof ct == "object" && ct !== null
      ? (ct = Vg(ct))
      : ((ct = Zf(nt) ? Xf : H$2.current), (ct = Yf(et, ct)));
    var ut = nt.getDerivedStateFromProps,
      ft =
        typeof ut == "function" ||
        typeof ot.getSnapshotBeforeUpdate == "function";
    ft ||
      (typeof ot.UNSAFE_componentWillReceiveProps != "function" &&
        typeof ot.componentWillReceiveProps != "function") ||
      ((at !== rt || lt !== ct) && qh(et, ot, rt, ct)),
      ($g = !1);
    var ht = et.memoizedState;
    (ot.state = ht),
      gh(et, rt, ot, it),
      (lt = et.memoizedState),
      at !== rt || ht !== lt || Wf.current || $g
        ? (typeof ut == "function" &&
            (kh(et, nt, ut, rt), (lt = et.memoizedState)),
          (at = $g || oh(et, nt, at, rt, ht, lt, ct))
            ? (ft ||
                (typeof ot.UNSAFE_componentWillMount != "function" &&
                  typeof ot.componentWillMount != "function") ||
                (typeof ot.componentWillMount == "function" &&
                  ot.componentWillMount(),
                typeof ot.UNSAFE_componentWillMount == "function" &&
                  ot.UNSAFE_componentWillMount()),
              typeof ot.componentDidMount == "function" &&
                (et.flags |= 4194308))
            : (typeof ot.componentDidMount == "function" &&
                (et.flags |= 4194308),
              (et.memoizedProps = rt),
              (et.memoizedState = lt)),
          (ot.props = rt),
          (ot.state = lt),
          (ot.context = ct),
          (rt = at))
        : (typeof ot.componentDidMount == "function" && (et.flags |= 4194308),
          (rt = !1));
  } else {
    (ot = et.stateNode),
      bh(tt, et),
      (at = et.memoizedProps),
      (ct = et.type === et.elementType ? at : Lg(et.type, at)),
      (ot.props = ct),
      (ft = et.pendingProps),
      (ht = ot.context),
      (lt = nt.contextType),
      typeof lt == "object" && lt !== null
        ? (lt = Vg(lt))
        : ((lt = Zf(nt) ? Xf : H$2.current), (lt = Yf(et, lt)));
    var mt = nt.getDerivedStateFromProps;
    (ut =
      typeof mt == "function" ||
      typeof ot.getSnapshotBeforeUpdate == "function") ||
      (typeof ot.UNSAFE_componentWillReceiveProps != "function" &&
        typeof ot.componentWillReceiveProps != "function") ||
      ((at !== ft || ht !== lt) && qh(et, ot, rt, lt)),
      ($g = !1),
      (ht = et.memoizedState),
      (ot.state = ht),
      gh(et, rt, ot, it);
    var vt = et.memoizedState;
    at !== ft || ht !== vt || Wf.current || $g
      ? (typeof mt == "function" &&
          (kh(et, nt, mt, rt), (vt = et.memoizedState)),
        (ct = $g || oh(et, nt, ct, rt, ht, vt, lt) || !1)
          ? (ut ||
              (typeof ot.UNSAFE_componentWillUpdate != "function" &&
                typeof ot.componentWillUpdate != "function") ||
              (typeof ot.componentWillUpdate == "function" &&
                ot.componentWillUpdate(rt, vt, lt),
              typeof ot.UNSAFE_componentWillUpdate == "function" &&
                ot.UNSAFE_componentWillUpdate(rt, vt, lt)),
            typeof ot.componentDidUpdate == "function" && (et.flags |= 4),
            typeof ot.getSnapshotBeforeUpdate == "function" &&
              (et.flags |= 1024))
          : (typeof ot.componentDidUpdate != "function" ||
              (at === tt.memoizedProps && ht === tt.memoizedState) ||
              (et.flags |= 4),
            typeof ot.getSnapshotBeforeUpdate != "function" ||
              (at === tt.memoizedProps && ht === tt.memoizedState) ||
              (et.flags |= 1024),
            (et.memoizedProps = rt),
            (et.memoizedState = vt)),
        (ot.props = rt),
        (ot.state = vt),
        (ot.context = lt),
        (rt = ct))
      : (typeof ot.componentDidUpdate != "function" ||
          (at === tt.memoizedProps && ht === tt.memoizedState) ||
          (et.flags |= 4),
        typeof ot.getSnapshotBeforeUpdate != "function" ||
          (at === tt.memoizedProps && ht === tt.memoizedState) ||
          (et.flags |= 1024),
        (rt = !1));
  }
  return kj(tt, et, nt, rt, st, it);
}
function kj(tt, et, nt, rt, it, st) {
  hj(tt, et);
  var ot = (et.flags & 128) !== 0;
  if (!rt && !ot) return it && dg(et, nt, !1), $i(tt, et, st);
  (rt = et.stateNode), (Xi.current = et);
  var at =
    ot && typeof nt.getDerivedStateFromError != "function" ? null : rt.render();
  return (
    (et.flags |= 1),
    tt !== null && ot
      ? ((et.child = Bh(et, tt.child, null, st)),
        (et.child = Bh(et, null, at, st)))
      : Yi(tt, et, at, st),
    (et.memoizedState = rt.state),
    it && dg(et, nt, !0),
    et.child
  );
}
function lj(tt) {
  var et = tt.stateNode;
  et.pendingContext
    ? ag(tt, et.pendingContext, et.pendingContext !== et.context)
    : et.context && ag(tt, et.context, !1),
    Ih(tt, et.containerInfo);
}
function mj(tt, et, nt, rt, it) {
  return Ig(), Jg(it), (et.flags |= 256), Yi(tt, et, nt, rt), et.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(tt) {
  return { baseLanes: tt, cachePool: null, transitions: null };
}
function pj(tt, et, nt) {
  var rt = et.pendingProps,
    it = M$2.current,
    st = !1,
    ot = (et.flags & 128) !== 0,
    at;
  if (
    ((at = ot) ||
      (at = tt !== null && tt.memoizedState === null ? !1 : (it & 2) !== 0),
    at
      ? ((st = !0), (et.flags &= -129))
      : (tt === null || tt.memoizedState !== null) && (it |= 1),
    G$2(M$2, it & 1),
    tt === null)
  )
    return (
      Eg(et),
      (tt = et.memoizedState),
      tt !== null && ((tt = tt.dehydrated), tt !== null)
        ? (et.mode & 1
            ? tt.data === "$!"
              ? (et.lanes = 8)
              : (et.lanes = 1073741824)
            : (et.lanes = 1),
          null)
        : ((ot = rt.children),
          (tt = rt.fallback),
          st
            ? ((rt = et.mode),
              (st = et.child),
              (ot = { mode: "hidden", children: ot }),
              !(rt & 1) && st !== null
                ? ((st.childLanes = 0), (st.pendingProps = ot))
                : (st = qj(ot, rt, 0, null)),
              (tt = Ah(tt, rt, nt, null)),
              (st.return = et),
              (tt.return = et),
              (st.sibling = tt),
              (et.child = st),
              (et.child.memoizedState = oj(nt)),
              (et.memoizedState = nj),
              tt)
            : rj(et, ot))
    );
  if (
    ((it = tt.memoizedState),
    it !== null && ((at = it.dehydrated), at !== null))
  )
    return sj(tt, et, ot, rt, at, it, nt);
  if (st) {
    (st = rt.fallback), (ot = et.mode), (it = tt.child), (at = it.sibling);
    var lt = { mode: "hidden", children: rt.children };
    return (
      !(ot & 1) && et.child !== it
        ? ((rt = et.child),
          (rt.childLanes = 0),
          (rt.pendingProps = lt),
          (et.deletions = null))
        : ((rt = wh(it, lt)), (rt.subtreeFlags = it.subtreeFlags & 14680064)),
      at !== null
        ? (st = wh(at, st))
        : ((st = Ah(st, ot, nt, null)), (st.flags |= 2)),
      (st.return = et),
      (rt.return = et),
      (rt.sibling = st),
      (et.child = rt),
      (rt = st),
      (st = et.child),
      (ot = tt.child.memoizedState),
      (ot =
        ot === null
          ? oj(nt)
          : {
              baseLanes: ot.baseLanes | nt,
              cachePool: null,
              transitions: ot.transitions,
            }),
      (st.memoizedState = ot),
      (st.childLanes = tt.childLanes & ~nt),
      (et.memoizedState = nj),
      rt
    );
  }
  return (
    (st = tt.child),
    (tt = st.sibling),
    (rt = wh(st, { mode: "visible", children: rt.children })),
    !(et.mode & 1) && (rt.lanes = nt),
    (rt.return = et),
    (rt.sibling = null),
    tt !== null &&
      ((nt = et.deletions),
      nt === null ? ((et.deletions = [tt]), (et.flags |= 16)) : nt.push(tt)),
    (et.child = rt),
    (et.memoizedState = null),
    rt
  );
}
function rj(tt, et) {
  return (
    (et = qj({ mode: "visible", children: et }, tt.mode, 0, null)),
    (et.return = tt),
    (tt.child = et)
  );
}
function tj(tt, et, nt, rt) {
  return (
    rt !== null && Jg(rt),
    Bh(et, tt.child, null, nt),
    (tt = rj(et, et.pendingProps.children)),
    (tt.flags |= 2),
    (et.memoizedState = null),
    tt
  );
}
function sj(tt, et, nt, rt, it, st, ot) {
  if (nt)
    return et.flags & 256
      ? ((et.flags &= -257), (rt = Li(Error(p$6(422)))), tj(tt, et, ot, rt))
      : et.memoizedState !== null
      ? ((et.child = tt.child), (et.flags |= 128), null)
      : ((st = rt.fallback),
        (it = et.mode),
        (rt = qj({ mode: "visible", children: rt.children }, it, 0, null)),
        (st = Ah(st, it, ot, null)),
        (st.flags |= 2),
        (rt.return = et),
        (st.return = et),
        (rt.sibling = st),
        (et.child = rt),
        et.mode & 1 && Bh(et, tt.child, null, ot),
        (et.child.memoizedState = oj(ot)),
        (et.memoizedState = nj),
        st);
  if (!(et.mode & 1)) return tj(tt, et, ot, null);
  if (it.data === "$!") {
    if (((rt = it.nextSibling && it.nextSibling.dataset), rt)) var at = rt.dgst;
    return (
      (rt = at),
      (st = Error(p$6(419))),
      (rt = Li(st, rt, void 0)),
      tj(tt, et, ot, rt)
    );
  }
  if (((at = (ot & tt.childLanes) !== 0), Ug || at)) {
    if (((rt = R$1), rt !== null)) {
      switch (ot & -ot) {
        case 4:
          it = 2;
          break;
        case 16:
          it = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          it = 32;
          break;
        case 536870912:
          it = 268435456;
          break;
        default:
          it = 0;
      }
      (it = it & (rt.suspendedLanes | ot) ? 0 : it),
        it !== 0 &&
          it !== st.retryLane &&
          ((st.retryLane = it), Zg(tt, it), mh(rt, tt, it, -1));
    }
    return uj(), (rt = Li(Error(p$6(421)))), tj(tt, et, ot, rt);
  }
  return it.data === "$?"
    ? ((et.flags |= 128),
      (et.child = tt.child),
      (et = vj.bind(null, tt)),
      (it._reactRetry = et),
      null)
    : ((tt = st.treeContext),
      (yg = Lf(it.nextSibling)),
      (xg = et),
      (I$2 = !0),
      (zg = null),
      tt !== null &&
        ((og[pg++] = rg),
        (og[pg++] = sg),
        (og[pg++] = qg),
        (rg = tt.id),
        (sg = tt.overflow),
        (qg = et)),
      (et = rj(et, rt.children)),
      (et.flags |= 4096),
      et);
}
function wj(tt, et, nt) {
  tt.lanes |= et;
  var rt = tt.alternate;
  rt !== null && (rt.lanes |= et), Sg(tt.return, et, nt);
}
function xj(tt, et, nt, rt, it) {
  var st = tt.memoizedState;
  st === null
    ? (tt.memoizedState = {
        isBackwards: et,
        rendering: null,
        renderingStartTime: 0,
        last: rt,
        tail: nt,
        tailMode: it,
      })
    : ((st.isBackwards = et),
      (st.rendering = null),
      (st.renderingStartTime = 0),
      (st.last = rt),
      (st.tail = nt),
      (st.tailMode = it));
}
function yj(tt, et, nt) {
  var rt = et.pendingProps,
    it = rt.revealOrder,
    st = rt.tail;
  if ((Yi(tt, et, rt.children, nt), (rt = M$2.current), rt & 2))
    (rt = (rt & 1) | 2), (et.flags |= 128);
  else {
    if (tt !== null && tt.flags & 128)
      e: for (tt = et.child; tt !== null; ) {
        if (tt.tag === 13) tt.memoizedState !== null && wj(tt, nt, et);
        else if (tt.tag === 19) wj(tt, nt, et);
        else if (tt.child !== null) {
          (tt.child.return = tt), (tt = tt.child);
          continue;
        }
        if (tt === et) break e;
        for (; tt.sibling === null; ) {
          if (tt.return === null || tt.return === et) break e;
          tt = tt.return;
        }
        (tt.sibling.return = tt.return), (tt = tt.sibling);
      }
    rt &= 1;
  }
  if ((G$2(M$2, rt), !(et.mode & 1))) et.memoizedState = null;
  else
    switch (it) {
      case "forwards":
        for (nt = et.child, it = null; nt !== null; )
          (tt = nt.alternate),
            tt !== null && Mh(tt) === null && (it = nt),
            (nt = nt.sibling);
        (nt = it),
          nt === null
            ? ((it = et.child), (et.child = null))
            : ((it = nt.sibling), (nt.sibling = null)),
          xj(et, !1, it, nt, st);
        break;
      case "backwards":
        for (nt = null, it = et.child, et.child = null; it !== null; ) {
          if (((tt = it.alternate), tt !== null && Mh(tt) === null)) {
            et.child = it;
            break;
          }
          (tt = it.sibling), (it.sibling = nt), (nt = it), (it = tt);
        }
        xj(et, !0, nt, null, st);
        break;
      case "together":
        xj(et, !1, null, null, void 0);
        break;
      default:
        et.memoizedState = null;
    }
  return et.child;
}
function jj(tt, et) {
  !(et.mode & 1) &&
    tt !== null &&
    ((tt.alternate = null), (et.alternate = null), (et.flags |= 2));
}
function $i(tt, et, nt) {
  if (
    (tt !== null && (et.dependencies = tt.dependencies),
    (hh |= et.lanes),
    !(nt & et.childLanes))
  )
    return null;
  if (tt !== null && et.child !== tt.child) throw Error(p$6(153));
  if (et.child !== null) {
    for (
      tt = et.child,
        nt = wh(tt, tt.pendingProps),
        et.child = nt,
        nt.return = et;
      tt.sibling !== null;

    )
      (tt = tt.sibling),
        (nt = nt.sibling = wh(tt, tt.pendingProps)),
        (nt.return = et);
    nt.sibling = null;
  }
  return et.child;
}
function zj(tt, et, nt) {
  switch (et.tag) {
    case 3:
      lj(et), Ig();
      break;
    case 5:
      Kh(et);
      break;
    case 1:
      Zf(et.type) && cg(et);
      break;
    case 4:
      Ih(et, et.stateNode.containerInfo);
      break;
    case 10:
      var rt = et.type._context,
        it = et.memoizedProps.value;
      G$2(Mg, rt._currentValue), (rt._currentValue = it);
      break;
    case 13:
      if (((rt = et.memoizedState), rt !== null))
        return rt.dehydrated !== null
          ? (G$2(M$2, M$2.current & 1), (et.flags |= 128), null)
          : nt & et.child.childLanes
          ? pj(tt, et, nt)
          : (G$2(M$2, M$2.current & 1),
            (tt = $i(tt, et, nt)),
            tt !== null ? tt.sibling : null);
      G$2(M$2, M$2.current & 1);
      break;
    case 19:
      if (((rt = (nt & et.childLanes) !== 0), tt.flags & 128)) {
        if (rt) return yj(tt, et, nt);
        et.flags |= 128;
      }
      if (
        ((it = et.memoizedState),
        it !== null &&
          ((it.rendering = null), (it.tail = null), (it.lastEffect = null)),
        G$2(M$2, M$2.current),
        rt)
      )
        break;
      return null;
    case 22:
    case 23:
      return (et.lanes = 0), ej(tt, et, nt);
  }
  return $i(tt, et, nt);
}
var Aj, Bj, Cj, Dj;
Aj = function (tt, et) {
  for (var nt = et.child; nt !== null; ) {
    if (nt.tag === 5 || nt.tag === 6) tt.appendChild(nt.stateNode);
    else if (nt.tag !== 4 && nt.child !== null) {
      (nt.child.return = nt), (nt = nt.child);
      continue;
    }
    if (nt === et) break;
    for (; nt.sibling === null; ) {
      if (nt.return === null || nt.return === et) return;
      nt = nt.return;
    }
    (nt.sibling.return = nt.return), (nt = nt.sibling);
  }
};
Bj = function () {};
Cj = function (tt, et, nt, rt) {
  var it = tt.memoizedProps;
  if (it !== rt) {
    (tt = et.stateNode), Hh(Eh.current);
    var st = null;
    switch (nt) {
      case "input":
        (it = Ya(tt, it)), (rt = Ya(tt, rt)), (st = []);
        break;
      case "select":
        (it = A$2({}, it, { value: void 0 })),
          (rt = A$2({}, rt, { value: void 0 })),
          (st = []);
        break;
      case "textarea":
        (it = gb(tt, it)), (rt = gb(tt, rt)), (st = []);
        break;
      default:
        typeof it.onClick != "function" &&
          typeof rt.onClick == "function" &&
          (tt.onclick = Bf);
    }
    ub(nt, rt);
    var ot;
    nt = null;
    for (ct in it)
      if (!rt.hasOwnProperty(ct) && it.hasOwnProperty(ct) && it[ct] != null)
        if (ct === "style") {
          var at = it[ct];
          for (ot in at)
            at.hasOwnProperty(ot) && (nt || (nt = {}), (nt[ot] = ""));
        } else
          ct !== "dangerouslySetInnerHTML" &&
            ct !== "children" &&
            ct !== "suppressContentEditableWarning" &&
            ct !== "suppressHydrationWarning" &&
            ct !== "autoFocus" &&
            (ea.hasOwnProperty(ct)
              ? st || (st = [])
              : (st = st || []).push(ct, null));
    for (ct in rt) {
      var lt = rt[ct];
      if (
        ((at = it != null ? it[ct] : void 0),
        rt.hasOwnProperty(ct) && lt !== at && (lt != null || at != null))
      )
        if (ct === "style")
          if (at) {
            for (ot in at)
              !at.hasOwnProperty(ot) ||
                (lt && lt.hasOwnProperty(ot)) ||
                (nt || (nt = {}), (nt[ot] = ""));
            for (ot in lt)
              lt.hasOwnProperty(ot) &&
                at[ot] !== lt[ot] &&
                (nt || (nt = {}), (nt[ot] = lt[ot]));
          } else nt || (st || (st = []), st.push(ct, nt)), (nt = lt);
        else
          ct === "dangerouslySetInnerHTML"
            ? ((lt = lt ? lt.__html : void 0),
              (at = at ? at.__html : void 0),
              lt != null && at !== lt && (st = st || []).push(ct, lt))
            : ct === "children"
            ? (typeof lt != "string" && typeof lt != "number") ||
              (st = st || []).push(ct, "" + lt)
            : ct !== "suppressContentEditableWarning" &&
              ct !== "suppressHydrationWarning" &&
              (ea.hasOwnProperty(ct)
                ? (lt != null && ct === "onScroll" && D$2("scroll", tt),
                  st || at === lt || (st = []))
                : (st = st || []).push(ct, lt));
    }
    nt && (st = st || []).push("style", nt);
    var ct = st;
    (et.updateQueue = ct) && (et.flags |= 4);
  }
};
Dj = function (tt, et, nt, rt) {
  nt !== rt && (et.flags |= 4);
};
function Ej(tt, et) {
  if (!I$2)
    switch (tt.tailMode) {
      case "hidden":
        et = tt.tail;
        for (var nt = null; et !== null; )
          et.alternate !== null && (nt = et), (et = et.sibling);
        nt === null ? (tt.tail = null) : (nt.sibling = null);
        break;
      case "collapsed":
        nt = tt.tail;
        for (var rt = null; nt !== null; )
          nt.alternate !== null && (rt = nt), (nt = nt.sibling);
        rt === null
          ? et || tt.tail === null
            ? (tt.tail = null)
            : (tt.tail.sibling = null)
          : (rt.sibling = null);
    }
}
function S$2(tt) {
  var et = tt.alternate !== null && tt.alternate.child === tt.child,
    nt = 0,
    rt = 0;
  if (et)
    for (var it = tt.child; it !== null; )
      (nt |= it.lanes | it.childLanes),
        (rt |= it.subtreeFlags & 14680064),
        (rt |= it.flags & 14680064),
        (it.return = tt),
        (it = it.sibling);
  else
    for (it = tt.child; it !== null; )
      (nt |= it.lanes | it.childLanes),
        (rt |= it.subtreeFlags),
        (rt |= it.flags),
        (it.return = tt),
        (it = it.sibling);
  return (tt.subtreeFlags |= rt), (tt.childLanes = nt), et;
}
function Fj(tt, et, nt) {
  var rt = et.pendingProps;
  switch ((wg(et), et.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(et), null;
    case 1:
      return Zf(et.type) && $f(), S$2(et), null;
    case 3:
      return (
        (rt = et.stateNode),
        Jh(),
        E$2(Wf),
        E$2(H$2),
        Oh(),
        rt.pendingContext &&
          ((rt.context = rt.pendingContext), (rt.pendingContext = null)),
        (tt === null || tt.child === null) &&
          (Gg(et)
            ? (et.flags |= 4)
            : tt === null ||
              (tt.memoizedState.isDehydrated && !(et.flags & 256)) ||
              ((et.flags |= 1024), zg !== null && (Gj(zg), (zg = null)))),
        Bj(tt, et),
        S$2(et),
        null
      );
    case 5:
      Lh(et);
      var it = Hh(Gh.current);
      if (((nt = et.type), tt !== null && et.stateNode != null))
        Cj(tt, et, nt, rt, it),
          tt.ref !== et.ref && ((et.flags |= 512), (et.flags |= 2097152));
      else {
        if (!rt) {
          if (et.stateNode === null) throw Error(p$6(166));
          return S$2(et), null;
        }
        if (((tt = Hh(Eh.current)), Gg(et))) {
          (rt = et.stateNode), (nt = et.type);
          var st = et.memoizedProps;
          switch (
            ((rt[Of] = et), (rt[Pf] = st), (tt = (et.mode & 1) !== 0), nt)
          ) {
            case "dialog":
              D$2("cancel", rt), D$2("close", rt);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", rt);
              break;
            case "video":
            case "audio":
              for (it = 0; it < lf.length; it++) D$2(lf[it], rt);
              break;
            case "source":
              D$2("error", rt);
              break;
            case "img":
            case "image":
            case "link":
              D$2("error", rt), D$2("load", rt);
              break;
            case "details":
              D$2("toggle", rt);
              break;
            case "input":
              Za(rt, st), D$2("invalid", rt);
              break;
            case "select":
              (rt._wrapperState = { wasMultiple: !!st.multiple }),
                D$2("invalid", rt);
              break;
            case "textarea":
              hb(rt, st), D$2("invalid", rt);
          }
          ub(nt, st), (it = null);
          for (var ot in st)
            if (st.hasOwnProperty(ot)) {
              var at = st[ot];
              ot === "children"
                ? typeof at == "string"
                  ? rt.textContent !== at &&
                    (st.suppressHydrationWarning !== !0 &&
                      Af(rt.textContent, at, tt),
                    (it = ["children", at]))
                  : typeof at == "number" &&
                    rt.textContent !== "" + at &&
                    (st.suppressHydrationWarning !== !0 &&
                      Af(rt.textContent, at, tt),
                    (it = ["children", "" + at]))
                : ea.hasOwnProperty(ot) &&
                  at != null &&
                  ot === "onScroll" &&
                  D$2("scroll", rt);
            }
          switch (nt) {
            case "input":
              Va(rt), db(rt, st, !0);
              break;
            case "textarea":
              Va(rt), jb(rt);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof st.onClick == "function" && (rt.onclick = Bf);
          }
          (rt = it), (et.updateQueue = rt), rt !== null && (et.flags |= 4);
        } else {
          (ot = it.nodeType === 9 ? it : it.ownerDocument),
            tt === "http://www.w3.org/1999/xhtml" && (tt = kb(nt)),
            tt === "http://www.w3.org/1999/xhtml"
              ? nt === "script"
                ? ((tt = ot.createElement("div")),
                  (tt.innerHTML = "<script></script>"),
                  (tt = tt.removeChild(tt.firstChild)))
                : typeof rt.is == "string"
                ? (tt = ot.createElement(nt, { is: rt.is }))
                : ((tt = ot.createElement(nt)),
                  nt === "select" &&
                    ((ot = tt),
                    rt.multiple
                      ? (ot.multiple = !0)
                      : rt.size && (ot.size = rt.size)))
              : (tt = ot.createElementNS(tt, nt)),
            (tt[Of] = et),
            (tt[Pf] = rt),
            Aj(tt, et, !1, !1),
            (et.stateNode = tt);
          e: {
            switch (((ot = vb(nt, rt)), nt)) {
              case "dialog":
                D$2("cancel", tt), D$2("close", tt), (it = rt);
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", tt), (it = rt);
                break;
              case "video":
              case "audio":
                for (it = 0; it < lf.length; it++) D$2(lf[it], tt);
                it = rt;
                break;
              case "source":
                D$2("error", tt), (it = rt);
                break;
              case "img":
              case "image":
              case "link":
                D$2("error", tt), D$2("load", tt), (it = rt);
                break;
              case "details":
                D$2("toggle", tt), (it = rt);
                break;
              case "input":
                Za(tt, rt), (it = Ya(tt, rt)), D$2("invalid", tt);
                break;
              case "option":
                it = rt;
                break;
              case "select":
                (tt._wrapperState = { wasMultiple: !!rt.multiple }),
                  (it = A$2({}, rt, { value: void 0 })),
                  D$2("invalid", tt);
                break;
              case "textarea":
                hb(tt, rt), (it = gb(tt, rt)), D$2("invalid", tt);
                break;
              default:
                it = rt;
            }
            ub(nt, it), (at = it);
            for (st in at)
              if (at.hasOwnProperty(st)) {
                var lt = at[st];
                st === "style"
                  ? sb(tt, lt)
                  : st === "dangerouslySetInnerHTML"
                  ? ((lt = lt ? lt.__html : void 0), lt != null && nb(tt, lt))
                  : st === "children"
                  ? typeof lt == "string"
                    ? (nt !== "textarea" || lt !== "") && ob(tt, lt)
                    : typeof lt == "number" && ob(tt, "" + lt)
                  : st !== "suppressContentEditableWarning" &&
                    st !== "suppressHydrationWarning" &&
                    st !== "autoFocus" &&
                    (ea.hasOwnProperty(st)
                      ? lt != null && st === "onScroll" && D$2("scroll", tt)
                      : lt != null && ta(tt, st, lt, ot));
              }
            switch (nt) {
              case "input":
                Va(tt), db(tt, rt, !1);
                break;
              case "textarea":
                Va(tt), jb(tt);
                break;
              case "option":
                rt.value != null && tt.setAttribute("value", "" + Sa(rt.value));
                break;
              case "select":
                (tt.multiple = !!rt.multiple),
                  (st = rt.value),
                  st != null
                    ? fb(tt, !!rt.multiple, st, !1)
                    : rt.defaultValue != null &&
                      fb(tt, !!rt.multiple, rt.defaultValue, !0);
                break;
              default:
                typeof it.onClick == "function" && (tt.onclick = Bf);
            }
            switch (nt) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                rt = !!rt.autoFocus;
                break e;
              case "img":
                rt = !0;
                break e;
              default:
                rt = !1;
            }
          }
          rt && (et.flags |= 4);
        }
        et.ref !== null && ((et.flags |= 512), (et.flags |= 2097152));
      }
      return S$2(et), null;
    case 6:
      if (tt && et.stateNode != null) Dj(tt, et, tt.memoizedProps, rt);
      else {
        if (typeof rt != "string" && et.stateNode === null)
          throw Error(p$6(166));
        if (((nt = Hh(Gh.current)), Hh(Eh.current), Gg(et))) {
          if (
            ((rt = et.stateNode),
            (nt = et.memoizedProps),
            (rt[Of] = et),
            (st = rt.nodeValue !== nt) && ((tt = xg), tt !== null))
          )
            switch (tt.tag) {
              case 3:
                Af(rt.nodeValue, nt, (tt.mode & 1) !== 0);
                break;
              case 5:
                tt.memoizedProps.suppressHydrationWarning !== !0 &&
                  Af(rt.nodeValue, nt, (tt.mode & 1) !== 0);
            }
          st && (et.flags |= 4);
        } else
          (rt = (nt.nodeType === 9 ? nt : nt.ownerDocument).createTextNode(rt)),
            (rt[Of] = et),
            (et.stateNode = rt);
      }
      return S$2(et), null;
    case 13:
      if (
        (E$2(M$2),
        (rt = et.memoizedState),
        tt === null ||
          (tt.memoizedState !== null && tt.memoizedState.dehydrated !== null))
      ) {
        if (I$2 && yg !== null && et.mode & 1 && !(et.flags & 128))
          Hg(), Ig(), (et.flags |= 98560), (st = !1);
        else if (((st = Gg(et)), rt !== null && rt.dehydrated !== null)) {
          if (tt === null) {
            if (!st) throw Error(p$6(318));
            if (
              ((st = et.memoizedState),
              (st = st !== null ? st.dehydrated : null),
              !st)
            )
              throw Error(p$6(317));
            st[Of] = et;
          } else
            Ig(),
              !(et.flags & 128) && (et.memoizedState = null),
              (et.flags |= 4);
          S$2(et), (st = !1);
        } else zg !== null && (Gj(zg), (zg = null)), (st = !0);
        if (!st) return et.flags & 65536 ? et : null;
      }
      return et.flags & 128
        ? ((et.lanes = nt), et)
        : ((rt = rt !== null),
          rt !== (tt !== null && tt.memoizedState !== null) &&
            rt &&
            ((et.child.flags |= 8192),
            et.mode & 1 &&
              (tt === null || M$2.current & 1 ? T$1 === 0 && (T$1 = 3) : uj())),
          et.updateQueue !== null && (et.flags |= 4),
          S$2(et),
          null);
    case 4:
      return (
        Jh(),
        Bj(tt, et),
        tt === null && sf(et.stateNode.containerInfo),
        S$2(et),
        null
      );
    case 10:
      return Rg(et.type._context), S$2(et), null;
    case 17:
      return Zf(et.type) && $f(), S$2(et), null;
    case 19:
      if ((E$2(M$2), (st = et.memoizedState), st === null))
        return S$2(et), null;
      if (((rt = (et.flags & 128) !== 0), (ot = st.rendering), ot === null))
        if (rt) Ej(st, !1);
        else {
          if (T$1 !== 0 || (tt !== null && tt.flags & 128))
            for (tt = et.child; tt !== null; ) {
              if (((ot = Mh(tt)), ot !== null)) {
                for (
                  et.flags |= 128,
                    Ej(st, !1),
                    rt = ot.updateQueue,
                    rt !== null && ((et.updateQueue = rt), (et.flags |= 4)),
                    et.subtreeFlags = 0,
                    rt = nt,
                    nt = et.child;
                  nt !== null;

                )
                  (st = nt),
                    (tt = rt),
                    (st.flags &= 14680066),
                    (ot = st.alternate),
                    ot === null
                      ? ((st.childLanes = 0),
                        (st.lanes = tt),
                        (st.child = null),
                        (st.subtreeFlags = 0),
                        (st.memoizedProps = null),
                        (st.memoizedState = null),
                        (st.updateQueue = null),
                        (st.dependencies = null),
                        (st.stateNode = null))
                      : ((st.childLanes = ot.childLanes),
                        (st.lanes = ot.lanes),
                        (st.child = ot.child),
                        (st.subtreeFlags = 0),
                        (st.deletions = null),
                        (st.memoizedProps = ot.memoizedProps),
                        (st.memoizedState = ot.memoizedState),
                        (st.updateQueue = ot.updateQueue),
                        (st.type = ot.type),
                        (tt = ot.dependencies),
                        (st.dependencies =
                          tt === null
                            ? null
                            : {
                                lanes: tt.lanes,
                                firstContext: tt.firstContext,
                              })),
                    (nt = nt.sibling);
                return G$2(M$2, (M$2.current & 1) | 2), et.child;
              }
              tt = tt.sibling;
            }
          st.tail !== null &&
            B$2() > Hj &&
            ((et.flags |= 128), (rt = !0), Ej(st, !1), (et.lanes = 4194304));
        }
      else {
        if (!rt)
          if (((tt = Mh(ot)), tt !== null)) {
            if (
              ((et.flags |= 128),
              (rt = !0),
              (nt = tt.updateQueue),
              nt !== null && ((et.updateQueue = nt), (et.flags |= 4)),
              Ej(st, !0),
              st.tail === null &&
                st.tailMode === "hidden" &&
                !ot.alternate &&
                !I$2)
            )
              return S$2(et), null;
          } else
            2 * B$2() - st.renderingStartTime > Hj &&
              nt !== 1073741824 &&
              ((et.flags |= 128), (rt = !0), Ej(st, !1), (et.lanes = 4194304));
        st.isBackwards
          ? ((ot.sibling = et.child), (et.child = ot))
          : ((nt = st.last),
            nt !== null ? (nt.sibling = ot) : (et.child = ot),
            (st.last = ot));
      }
      return st.tail !== null
        ? ((et = st.tail),
          (st.rendering = et),
          (st.tail = et.sibling),
          (st.renderingStartTime = B$2()),
          (et.sibling = null),
          (nt = M$2.current),
          G$2(M$2, rt ? (nt & 1) | 2 : nt & 1),
          et)
        : (S$2(et), null);
    case 22:
    case 23:
      return (
        Ij(),
        (rt = et.memoizedState !== null),
        tt !== null && (tt.memoizedState !== null) !== rt && (et.flags |= 8192),
        rt && et.mode & 1
          ? gj & 1073741824 &&
            (S$2(et), et.subtreeFlags & 6 && (et.flags |= 8192))
          : S$2(et),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$6(156, et.tag));
}
function Jj(tt, et) {
  switch ((wg(et), et.tag)) {
    case 1:
      return (
        Zf(et.type) && $f(),
        (tt = et.flags),
        tt & 65536 ? ((et.flags = (tt & -65537) | 128), et) : null
      );
    case 3:
      return (
        Jh(),
        E$2(Wf),
        E$2(H$2),
        Oh(),
        (tt = et.flags),
        tt & 65536 && !(tt & 128)
          ? ((et.flags = (tt & -65537) | 128), et)
          : null
      );
    case 5:
      return Lh(et), null;
    case 13:
      if (
        (E$2(M$2),
        (tt = et.memoizedState),
        tt !== null && tt.dehydrated !== null)
      ) {
        if (et.alternate === null) throw Error(p$6(340));
        Ig();
      }
      return (
        (tt = et.flags),
        tt & 65536 ? ((et.flags = (tt & -65537) | 128), et) : null
      );
    case 19:
      return E$2(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(et.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = !1,
  U$2 = !1,
  Lj = typeof WeakSet == "function" ? WeakSet : Set,
  V$1 = null;
function Mj(tt, et) {
  var nt = tt.ref;
  if (nt !== null)
    if (typeof nt == "function")
      try {
        nt(null);
      } catch (rt) {
        W$2(tt, et, rt);
      }
    else nt.current = null;
}
function Nj(tt, et, nt) {
  try {
    nt();
  } catch (rt) {
    W$2(tt, et, rt);
  }
}
var Oj = !1;
function Pj(tt, et) {
  if (((Cf = dd), (tt = Me$1()), Ne$1(tt))) {
    if ("selectionStart" in tt)
      var nt = { start: tt.selectionStart, end: tt.selectionEnd };
    else
      e: {
        nt = ((nt = tt.ownerDocument) && nt.defaultView) || window;
        var rt = nt.getSelection && nt.getSelection();
        if (rt && rt.rangeCount !== 0) {
          nt = rt.anchorNode;
          var it = rt.anchorOffset,
            st = rt.focusNode;
          rt = rt.focusOffset;
          try {
            nt.nodeType, st.nodeType;
          } catch {
            nt = null;
            break e;
          }
          var ot = 0,
            at = -1,
            lt = -1,
            ct = 0,
            ut = 0,
            ft = tt,
            ht = null;
          t: for (;;) {
            for (
              var mt;
              ft !== nt || (it !== 0 && ft.nodeType !== 3) || (at = ot + it),
                ft !== st || (rt !== 0 && ft.nodeType !== 3) || (lt = ot + rt),
                ft.nodeType === 3 && (ot += ft.nodeValue.length),
                (mt = ft.firstChild) !== null;

            )
              (ht = ft), (ft = mt);
            for (;;) {
              if (ft === tt) break t;
              if (
                (ht === nt && ++ct === it && (at = ot),
                ht === st && ++ut === rt && (lt = ot),
                (mt = ft.nextSibling) !== null)
              )
                break;
              (ft = ht), (ht = ft.parentNode);
            }
            ft = mt;
          }
          nt = at === -1 || lt === -1 ? null : { start: at, end: lt };
        } else nt = null;
      }
    nt = nt || { start: 0, end: 0 };
  } else nt = null;
  for (
    Df = { focusedElem: tt, selectionRange: nt }, dd = !1, V$1 = et;
    V$1 !== null;

  )
    if (
      ((et = V$1),
      (tt = et.child),
      (et.subtreeFlags & 1028) !== 0 && tt !== null)
    )
      (tt.return = et), (V$1 = tt);
    else
      for (; V$1 !== null; ) {
        et = V$1;
        try {
          var vt = et.alternate;
          if (et.flags & 1024)
            switch (et.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (vt !== null) {
                  var yt = vt.memoizedProps,
                    Et = vt.memoizedState,
                    pt = et.stateNode,
                    xt = pt.getSnapshotBeforeUpdate(
                      et.elementType === et.type ? yt : Lg(et.type, yt),
                      Et
                    );
                  pt.__reactInternalSnapshotBeforeUpdate = xt;
                }
                break;
              case 3:
                var St = et.stateNode.containerInfo;
                St.nodeType === 1
                  ? (St.textContent = "")
                  : St.nodeType === 9 &&
                    St.documentElement &&
                    St.removeChild(St.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$6(163));
            }
        } catch (At) {
          W$2(et, et.return, At);
        }
        if (((tt = et.sibling), tt !== null)) {
          (tt.return = et.return), (V$1 = tt);
          break;
        }
        V$1 = et.return;
      }
  return (vt = Oj), (Oj = !1), vt;
}
function Qj(tt, et, nt) {
  var rt = et.updateQueue;
  if (((rt = rt !== null ? rt.lastEffect : null), rt !== null)) {
    var it = (rt = rt.next);
    do {
      if ((it.tag & tt) === tt) {
        var st = it.destroy;
        (it.destroy = void 0), st !== void 0 && Nj(et, nt, st);
      }
      it = it.next;
    } while (it !== rt);
  }
}
function Rj(tt, et) {
  if (
    ((et = et.updateQueue),
    (et = et !== null ? et.lastEffect : null),
    et !== null)
  ) {
    var nt = (et = et.next);
    do {
      if ((nt.tag & tt) === tt) {
        var rt = nt.create;
        nt.destroy = rt();
      }
      nt = nt.next;
    } while (nt !== et);
  }
}
function Sj(tt) {
  var et = tt.ref;
  if (et !== null) {
    var nt = tt.stateNode;
    switch (tt.tag) {
      case 5:
        tt = nt;
        break;
      default:
        tt = nt;
    }
    typeof et == "function" ? et(tt) : (et.current = tt);
  }
}
function Tj(tt) {
  var et = tt.alternate;
  et !== null && ((tt.alternate = null), Tj(et)),
    (tt.child = null),
    (tt.deletions = null),
    (tt.sibling = null),
    tt.tag === 5 &&
      ((et = tt.stateNode),
      et !== null &&
        (delete et[Of],
        delete et[Pf],
        delete et[of],
        delete et[Qf],
        delete et[Rf])),
    (tt.stateNode = null),
    (tt.return = null),
    (tt.dependencies = null),
    (tt.memoizedProps = null),
    (tt.memoizedState = null),
    (tt.pendingProps = null),
    (tt.stateNode = null),
    (tt.updateQueue = null);
}
function Uj(tt) {
  return tt.tag === 5 || tt.tag === 3 || tt.tag === 4;
}
function Vj(tt) {
  e: for (;;) {
    for (; tt.sibling === null; ) {
      if (tt.return === null || Uj(tt.return)) return null;
      tt = tt.return;
    }
    for (
      tt.sibling.return = tt.return, tt = tt.sibling;
      tt.tag !== 5 && tt.tag !== 6 && tt.tag !== 18;

    ) {
      if (tt.flags & 2 || tt.child === null || tt.tag === 4) continue e;
      (tt.child.return = tt), (tt = tt.child);
    }
    if (!(tt.flags & 2)) return tt.stateNode;
  }
}
function Wj(tt, et, nt) {
  var rt = tt.tag;
  if (rt === 5 || rt === 6)
    (tt = tt.stateNode),
      et
        ? nt.nodeType === 8
          ? nt.parentNode.insertBefore(tt, et)
          : nt.insertBefore(tt, et)
        : (nt.nodeType === 8
            ? ((et = nt.parentNode), et.insertBefore(tt, nt))
            : ((et = nt), et.appendChild(tt)),
          (nt = nt._reactRootContainer),
          nt != null || et.onclick !== null || (et.onclick = Bf));
  else if (rt !== 4 && ((tt = tt.child), tt !== null))
    for (Wj(tt, et, nt), tt = tt.sibling; tt !== null; )
      Wj(tt, et, nt), (tt = tt.sibling);
}
function Xj(tt, et, nt) {
  var rt = tt.tag;
  if (rt === 5 || rt === 6)
    (tt = tt.stateNode), et ? nt.insertBefore(tt, et) : nt.appendChild(tt);
  else if (rt !== 4 && ((tt = tt.child), tt !== null))
    for (Xj(tt, et, nt), tt = tt.sibling; tt !== null; )
      Xj(tt, et, nt), (tt = tt.sibling);
}
var X$2 = null,
  Yj = !1;
function Zj(tt, et, nt) {
  for (nt = nt.child; nt !== null; ) ak(tt, et, nt), (nt = nt.sibling);
}
function ak(tt, et, nt) {
  if (lc && typeof lc.onCommitFiberUnmount == "function")
    try {
      lc.onCommitFiberUnmount(kc, nt);
    } catch {}
  switch (nt.tag) {
    case 5:
      U$2 || Mj(nt, et);
    case 6:
      var rt = X$2,
        it = Yj;
      (X$2 = null),
        Zj(tt, et, nt),
        (X$2 = rt),
        (Yj = it),
        X$2 !== null &&
          (Yj
            ? ((tt = X$2),
              (nt = nt.stateNode),
              tt.nodeType === 8
                ? tt.parentNode.removeChild(nt)
                : tt.removeChild(nt))
            : X$2.removeChild(nt.stateNode));
      break;
    case 18:
      X$2 !== null &&
        (Yj
          ? ((tt = X$2),
            (nt = nt.stateNode),
            tt.nodeType === 8
              ? Kf(tt.parentNode, nt)
              : tt.nodeType === 1 && Kf(tt, nt),
            bd(tt))
          : Kf(X$2, nt.stateNode));
      break;
    case 4:
      (rt = X$2),
        (it = Yj),
        (X$2 = nt.stateNode.containerInfo),
        (Yj = !0),
        Zj(tt, et, nt),
        (X$2 = rt),
        (Yj = it);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !U$2 &&
        ((rt = nt.updateQueue),
        rt !== null && ((rt = rt.lastEffect), rt !== null))
      ) {
        it = rt = rt.next;
        do {
          var st = it,
            ot = st.destroy;
          (st = st.tag),
            ot !== void 0 && (st & 2 || st & 4) && Nj(nt, et, ot),
            (it = it.next);
        } while (it !== rt);
      }
      Zj(tt, et, nt);
      break;
    case 1:
      if (
        !U$2 &&
        (Mj(nt, et),
        (rt = nt.stateNode),
        typeof rt.componentWillUnmount == "function")
      )
        try {
          (rt.props = nt.memoizedProps),
            (rt.state = nt.memoizedState),
            rt.componentWillUnmount();
        } catch (at) {
          W$2(nt, et, at);
        }
      Zj(tt, et, nt);
      break;
    case 21:
      Zj(tt, et, nt);
      break;
    case 22:
      nt.mode & 1
        ? ((U$2 = (rt = U$2) || nt.memoizedState !== null),
          Zj(tt, et, nt),
          (U$2 = rt))
        : Zj(tt, et, nt);
      break;
    default:
      Zj(tt, et, nt);
  }
}
function bk(tt) {
  var et = tt.updateQueue;
  if (et !== null) {
    tt.updateQueue = null;
    var nt = tt.stateNode;
    nt === null && (nt = tt.stateNode = new Lj()),
      et.forEach(function (rt) {
        var it = ck.bind(null, tt, rt);
        nt.has(rt) || (nt.add(rt), rt.then(it, it));
      });
  }
}
function dk(tt, et) {
  var nt = et.deletions;
  if (nt !== null)
    for (var rt = 0; rt < nt.length; rt++) {
      var it = nt[rt];
      try {
        var st = tt,
          ot = et,
          at = ot;
        e: for (; at !== null; ) {
          switch (at.tag) {
            case 5:
              (X$2 = at.stateNode), (Yj = !1);
              break e;
            case 3:
              (X$2 = at.stateNode.containerInfo), (Yj = !0);
              break e;
            case 4:
              (X$2 = at.stateNode.containerInfo), (Yj = !0);
              break e;
          }
          at = at.return;
        }
        if (X$2 === null) throw Error(p$6(160));
        ak(st, ot, it), (X$2 = null), (Yj = !1);
        var lt = it.alternate;
        lt !== null && (lt.return = null), (it.return = null);
      } catch (ct) {
        W$2(it, et, ct);
      }
    }
  if (et.subtreeFlags & 12854)
    for (et = et.child; et !== null; ) ek(et, tt), (et = et.sibling);
}
function ek(tt, et) {
  var nt = tt.alternate,
    rt = tt.flags;
  switch (tt.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((dk(et, tt), fk(tt), rt & 4)) {
        try {
          Qj(3, tt, tt.return), Rj(3, tt);
        } catch (yt) {
          W$2(tt, tt.return, yt);
        }
        try {
          Qj(5, tt, tt.return);
        } catch (yt) {
          W$2(tt, tt.return, yt);
        }
      }
      break;
    case 1:
      dk(et, tt), fk(tt), rt & 512 && nt !== null && Mj(nt, nt.return);
      break;
    case 5:
      if (
        (dk(et, tt),
        fk(tt),
        rt & 512 && nt !== null && Mj(nt, nt.return),
        tt.flags & 32)
      ) {
        var it = tt.stateNode;
        try {
          ob(it, "");
        } catch (yt) {
          W$2(tt, tt.return, yt);
        }
      }
      if (rt & 4 && ((it = tt.stateNode), it != null)) {
        var st = tt.memoizedProps,
          ot = nt !== null ? nt.memoizedProps : st,
          at = tt.type,
          lt = tt.updateQueue;
        if (((tt.updateQueue = null), lt !== null))
          try {
            at === "input" &&
              st.type === "radio" &&
              st.name != null &&
              ab(it, st),
              vb(at, ot);
            var ct = vb(at, st);
            for (ot = 0; ot < lt.length; ot += 2) {
              var ut = lt[ot],
                ft = lt[ot + 1];
              ut === "style"
                ? sb(it, ft)
                : ut === "dangerouslySetInnerHTML"
                ? nb(it, ft)
                : ut === "children"
                ? ob(it, ft)
                : ta(it, ut, ft, ct);
            }
            switch (at) {
              case "input":
                bb(it, st);
                break;
              case "textarea":
                ib(it, st);
                break;
              case "select":
                var ht = it._wrapperState.wasMultiple;
                it._wrapperState.wasMultiple = !!st.multiple;
                var mt = st.value;
                mt != null
                  ? fb(it, !!st.multiple, mt, !1)
                  : ht !== !!st.multiple &&
                    (st.defaultValue != null
                      ? fb(it, !!st.multiple, st.defaultValue, !0)
                      : fb(it, !!st.multiple, st.multiple ? [] : "", !1));
            }
            it[Pf] = st;
          } catch (yt) {
            W$2(tt, tt.return, yt);
          }
      }
      break;
    case 6:
      if ((dk(et, tt), fk(tt), rt & 4)) {
        if (tt.stateNode === null) throw Error(p$6(162));
        (it = tt.stateNode), (st = tt.memoizedProps);
        try {
          it.nodeValue = st;
        } catch (yt) {
          W$2(tt, tt.return, yt);
        }
      }
      break;
    case 3:
      if (
        (dk(et, tt),
        fk(tt),
        rt & 4 && nt !== null && nt.memoizedState.isDehydrated)
      )
        try {
          bd(et.containerInfo);
        } catch (yt) {
          W$2(tt, tt.return, yt);
        }
      break;
    case 4:
      dk(et, tt), fk(tt);
      break;
    case 13:
      dk(et, tt),
        fk(tt),
        (it = tt.child),
        it.flags & 8192 &&
          ((st = it.memoizedState !== null),
          (it.stateNode.isHidden = st),
          !st ||
            (it.alternate !== null && it.alternate.memoizedState !== null) ||
            (gk = B$2())),
        rt & 4 && bk(tt);
      break;
    case 22:
      if (
        ((ut = nt !== null && nt.memoizedState !== null),
        tt.mode & 1
          ? ((U$2 = (ct = U$2) || ut), dk(et, tt), (U$2 = ct))
          : dk(et, tt),
        fk(tt),
        rt & 8192)
      ) {
        if (
          ((ct = tt.memoizedState !== null),
          (tt.stateNode.isHidden = ct) && !ut && tt.mode & 1)
        )
          for (V$1 = tt, ut = tt.child; ut !== null; ) {
            for (ft = V$1 = ut; V$1 !== null; ) {
              switch (((ht = V$1), (mt = ht.child), ht.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, ht, ht.return);
                  break;
                case 1:
                  Mj(ht, ht.return);
                  var vt = ht.stateNode;
                  if (typeof vt.componentWillUnmount == "function") {
                    (rt = ht), (nt = ht.return);
                    try {
                      (et = rt),
                        (vt.props = et.memoizedProps),
                        (vt.state = et.memoizedState),
                        vt.componentWillUnmount();
                    } catch (yt) {
                      W$2(rt, nt, yt);
                    }
                  }
                  break;
                case 5:
                  Mj(ht, ht.return);
                  break;
                case 22:
                  if (ht.memoizedState !== null) {
                    hk(ft);
                    continue;
                  }
              }
              mt !== null ? ((mt.return = ht), (V$1 = mt)) : hk(ft);
            }
            ut = ut.sibling;
          }
        e: for (ut = null, ft = tt; ; ) {
          if (ft.tag === 5) {
            if (ut === null) {
              ut = ft;
              try {
                (it = ft.stateNode),
                  ct
                    ? ((st = it.style),
                      typeof st.setProperty == "function"
                        ? st.setProperty("display", "none", "important")
                        : (st.display = "none"))
                    : ((at = ft.stateNode),
                      (lt = ft.memoizedProps.style),
                      (ot =
                        lt != null && lt.hasOwnProperty("display")
                          ? lt.display
                          : null),
                      (at.style.display = rb("display", ot)));
              } catch (yt) {
                W$2(tt, tt.return, yt);
              }
            }
          } else if (ft.tag === 6) {
            if (ut === null)
              try {
                ft.stateNode.nodeValue = ct ? "" : ft.memoizedProps;
              } catch (yt) {
                W$2(tt, tt.return, yt);
              }
          } else if (
            ((ft.tag !== 22 && ft.tag !== 23) ||
              ft.memoizedState === null ||
              ft === tt) &&
            ft.child !== null
          ) {
            (ft.child.return = ft), (ft = ft.child);
            continue;
          }
          if (ft === tt) break e;
          for (; ft.sibling === null; ) {
            if (ft.return === null || ft.return === tt) break e;
            ut === ft && (ut = null), (ft = ft.return);
          }
          ut === ft && (ut = null),
            (ft.sibling.return = ft.return),
            (ft = ft.sibling);
        }
      }
      break;
    case 19:
      dk(et, tt), fk(tt), rt & 4 && bk(tt);
      break;
    case 21:
      break;
    default:
      dk(et, tt), fk(tt);
  }
}
function fk(tt) {
  var et = tt.flags;
  if (et & 2) {
    try {
      e: {
        for (var nt = tt.return; nt !== null; ) {
          if (Uj(nt)) {
            var rt = nt;
            break e;
          }
          nt = nt.return;
        }
        throw Error(p$6(160));
      }
      switch (rt.tag) {
        case 5:
          var it = rt.stateNode;
          rt.flags & 32 && (ob(it, ""), (rt.flags &= -33));
          var st = Vj(tt);
          Xj(tt, st, it);
          break;
        case 3:
        case 4:
          var ot = rt.stateNode.containerInfo,
            at = Vj(tt);
          Wj(tt, at, ot);
          break;
        default:
          throw Error(p$6(161));
      }
    } catch (lt) {
      W$2(tt, tt.return, lt);
    }
    tt.flags &= -3;
  }
  et & 4096 && (tt.flags &= -4097);
}
function ik(tt, et, nt) {
  (V$1 = tt), jk(tt);
}
function jk(tt, et, nt) {
  for (var rt = (tt.mode & 1) !== 0; V$1 !== null; ) {
    var it = V$1,
      st = it.child;
    if (it.tag === 22 && rt) {
      var ot = it.memoizedState !== null || Kj;
      if (!ot) {
        var at = it.alternate,
          lt = (at !== null && at.memoizedState !== null) || U$2;
        at = Kj;
        var ct = U$2;
        if (((Kj = ot), (U$2 = lt) && !ct))
          for (V$1 = it; V$1 !== null; )
            (ot = V$1),
              (lt = ot.child),
              ot.tag === 22 && ot.memoizedState !== null
                ? kk(it)
                : lt !== null
                ? ((lt.return = ot), (V$1 = lt))
                : kk(it);
        for (; st !== null; ) (V$1 = st), jk(st), (st = st.sibling);
        (V$1 = it), (Kj = at), (U$2 = ct);
      }
      lk(tt);
    } else
      it.subtreeFlags & 8772 && st !== null
        ? ((st.return = it), (V$1 = st))
        : lk(tt);
  }
}
function lk(tt) {
  for (; V$1 !== null; ) {
    var et = V$1;
    if (et.flags & 8772) {
      var nt = et.alternate;
      try {
        if (et.flags & 8772)
          switch (et.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, et);
              break;
            case 1:
              var rt = et.stateNode;
              if (et.flags & 4 && !U$2)
                if (nt === null) rt.componentDidMount();
                else {
                  var it =
                    et.elementType === et.type
                      ? nt.memoizedProps
                      : Lg(et.type, nt.memoizedProps);
                  rt.componentDidUpdate(
                    it,
                    nt.memoizedState,
                    rt.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var st = et.updateQueue;
              st !== null && ih(et, st, rt);
              break;
            case 3:
              var ot = et.updateQueue;
              if (ot !== null) {
                if (((nt = null), et.child !== null))
                  switch (et.child.tag) {
                    case 5:
                      nt = et.child.stateNode;
                      break;
                    case 1:
                      nt = et.child.stateNode;
                  }
                ih(et, ot, nt);
              }
              break;
            case 5:
              var at = et.stateNode;
              if (nt === null && et.flags & 4) {
                nt = at;
                var lt = et.memoizedProps;
                switch (et.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    lt.autoFocus && nt.focus();
                    break;
                  case "img":
                    lt.src && (nt.src = lt.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (et.memoizedState === null) {
                var ct = et.alternate;
                if (ct !== null) {
                  var ut = ct.memoizedState;
                  if (ut !== null) {
                    var ft = ut.dehydrated;
                    ft !== null && bd(ft);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$6(163));
          }
        U$2 || (et.flags & 512 && Sj(et));
      } catch (ht) {
        W$2(et, et.return, ht);
      }
    }
    if (et === tt) {
      V$1 = null;
      break;
    }
    if (((nt = et.sibling), nt !== null)) {
      (nt.return = et.return), (V$1 = nt);
      break;
    }
    V$1 = et.return;
  }
}
function hk(tt) {
  for (; V$1 !== null; ) {
    var et = V$1;
    if (et === tt) {
      V$1 = null;
      break;
    }
    var nt = et.sibling;
    if (nt !== null) {
      (nt.return = et.return), (V$1 = nt);
      break;
    }
    V$1 = et.return;
  }
}
function kk(tt) {
  for (; V$1 !== null; ) {
    var et = V$1;
    try {
      switch (et.tag) {
        case 0:
        case 11:
        case 15:
          var nt = et.return;
          try {
            Rj(4, et);
          } catch (lt) {
            W$2(et, nt, lt);
          }
          break;
        case 1:
          var rt = et.stateNode;
          if (typeof rt.componentDidMount == "function") {
            var it = et.return;
            try {
              rt.componentDidMount();
            } catch (lt) {
              W$2(et, it, lt);
            }
          }
          var st = et.return;
          try {
            Sj(et);
          } catch (lt) {
            W$2(et, st, lt);
          }
          break;
        case 5:
          var ot = et.return;
          try {
            Sj(et);
          } catch (lt) {
            W$2(et, ot, lt);
          }
      }
    } catch (lt) {
      W$2(et, et.return, lt);
    }
    if (et === tt) {
      V$1 = null;
      break;
    }
    var at = et.sibling;
    if (at !== null) {
      (at.return = et.return), (V$1 = at);
      break;
    }
    V$1 = et.return;
  }
}
var mk = Math.ceil,
  nk = ua.ReactCurrentDispatcher,
  ok = ua.ReactCurrentOwner,
  pk = ua.ReactCurrentBatchConfig,
  K$1 = 0,
  R$1 = null,
  Y$1 = null,
  Z$2 = 0,
  gj = 0,
  fj = Uf(0),
  T$1 = 0,
  qk = null,
  hh = 0,
  rk = 0,
  sk = 0,
  tk = null,
  uk = null,
  gk = 0,
  Hj = 1 / 0,
  vk = null,
  Pi = !1,
  Qi = null,
  Si = null,
  wk = !1,
  xk = null,
  yk = 0,
  zk = 0,
  Ak = null,
  Bk = -1,
  Ck = 0;
function L$2() {
  return K$1 & 6 ? B$2() : Bk !== -1 ? Bk : (Bk = B$2());
}
function lh(tt) {
  return tt.mode & 1
    ? K$1 & 2 && Z$2 !== 0
      ? Z$2 & -Z$2
      : Kg.transition !== null
      ? (Ck === 0 && (Ck = yc()), Ck)
      : ((tt = C$1),
        tt !== 0 ||
          ((tt = window.event), (tt = tt === void 0 ? 16 : jd(tt.type))),
        tt)
    : 1;
}
function mh(tt, et, nt, rt) {
  if (50 < zk) throw ((zk = 0), (Ak = null), Error(p$6(185)));
  Ac(tt, nt, rt),
    (!(K$1 & 2) || tt !== R$1) &&
      (tt === R$1 && (!(K$1 & 2) && (rk |= nt), T$1 === 4 && Dk(tt, Z$2)),
      Ek(tt, rt),
      nt === 1 &&
        K$1 === 0 &&
        !(et.mode & 1) &&
        ((Hj = B$2() + 500), fg && jg()));
}
function Ek(tt, et) {
  var nt = tt.callbackNode;
  wc(tt, et);
  var rt = uc(tt, tt === R$1 ? Z$2 : 0);
  if (rt === 0)
    nt !== null && bc(nt), (tt.callbackNode = null), (tt.callbackPriority = 0);
  else if (((et = rt & -rt), tt.callbackPriority !== et)) {
    if ((nt != null && bc(nt), et === 1))
      tt.tag === 0 ? ig(Fk.bind(null, tt)) : hg(Fk.bind(null, tt)),
        Jf(function () {
          !(K$1 & 6) && jg();
        }),
        (nt = null);
    else {
      switch (Dc(rt)) {
        case 1:
          nt = fc;
          break;
        case 4:
          nt = gc;
          break;
        case 16:
          nt = hc;
          break;
        case 536870912:
          nt = jc;
          break;
        default:
          nt = hc;
      }
      nt = Gk(nt, Hk.bind(null, tt));
    }
    (tt.callbackPriority = et), (tt.callbackNode = nt);
  }
}
function Hk(tt, et) {
  if (((Bk = -1), (Ck = 0), K$1 & 6)) throw Error(p$6(327));
  var nt = tt.callbackNode;
  if (Ik() && tt.callbackNode !== nt) return null;
  var rt = uc(tt, tt === R$1 ? Z$2 : 0);
  if (rt === 0) return null;
  if (rt & 30 || rt & tt.expiredLanes || et) et = Jk(tt, rt);
  else {
    et = rt;
    var it = K$1;
    K$1 |= 2;
    var st = Kk();
    (R$1 !== tt || Z$2 !== et) && ((vk = null), (Hj = B$2() + 500), Lk(tt, et));
    do
      try {
        Mk();
        break;
      } catch (at) {
        Nk(tt, at);
      }
    while (1);
    Qg(),
      (nk.current = st),
      (K$1 = it),
      Y$1 !== null ? (et = 0) : ((R$1 = null), (Z$2 = 0), (et = T$1));
  }
  if (et !== 0) {
    if (
      (et === 2 && ((it = xc(tt)), it !== 0 && ((rt = it), (et = Ok(tt, it)))),
      et === 1)
    )
      throw ((nt = qk), Lk(tt, 0), Dk(tt, rt), Ek(tt, B$2()), nt);
    if (et === 6) Dk(tt, rt);
    else {
      if (
        ((it = tt.current.alternate),
        !(rt & 30) &&
          !Pk(it) &&
          ((et = Jk(tt, rt)),
          et === 2 &&
            ((st = xc(tt)), st !== 0 && ((rt = st), (et = Ok(tt, st)))),
          et === 1))
      )
        throw ((nt = qk), Lk(tt, 0), Dk(tt, rt), Ek(tt, B$2()), nt);
      switch (((tt.finishedWork = it), (tt.finishedLanes = rt), et)) {
        case 0:
        case 1:
          throw Error(p$6(345));
        case 2:
          Qk(tt, uk, vk);
          break;
        case 3:
          if (
            (Dk(tt, rt),
            (rt & 130023424) === rt && ((et = gk + 500 - B$2()), 10 < et))
          ) {
            if (uc(tt, 0) !== 0) break;
            if (((it = tt.suspendedLanes), (it & rt) !== rt)) {
              L$2(), (tt.pingedLanes |= tt.suspendedLanes & it);
              break;
            }
            tt.timeoutHandle = Ff(Qk.bind(null, tt, uk, vk), et);
            break;
          }
          Qk(tt, uk, vk);
          break;
        case 4:
          if ((Dk(tt, rt), (rt & 4194240) === rt)) break;
          for (et = tt.eventTimes, it = -1; 0 < rt; ) {
            var ot = 31 - oc(rt);
            (st = 1 << ot), (ot = et[ot]), ot > it && (it = ot), (rt &= ~st);
          }
          if (
            ((rt = it),
            (rt = B$2() - rt),
            (rt =
              (120 > rt
                ? 120
                : 480 > rt
                ? 480
                : 1080 > rt
                ? 1080
                : 1920 > rt
                ? 1920
                : 3e3 > rt
                ? 3e3
                : 4320 > rt
                ? 4320
                : 1960 * mk(rt / 1960)) - rt),
            10 < rt)
          ) {
            tt.timeoutHandle = Ff(Qk.bind(null, tt, uk, vk), rt);
            break;
          }
          Qk(tt, uk, vk);
          break;
        case 5:
          Qk(tt, uk, vk);
          break;
        default:
          throw Error(p$6(329));
      }
    }
  }
  return Ek(tt, B$2()), tt.callbackNode === nt ? Hk.bind(null, tt) : null;
}
function Ok(tt, et) {
  var nt = tk;
  return (
    tt.current.memoizedState.isDehydrated && (Lk(tt, et).flags |= 256),
    (tt = Jk(tt, et)),
    tt !== 2 && ((et = uk), (uk = nt), et !== null && Gj(et)),
    tt
  );
}
function Gj(tt) {
  uk === null ? (uk = tt) : uk.push.apply(uk, tt);
}
function Pk(tt) {
  for (var et = tt; ; ) {
    if (et.flags & 16384) {
      var nt = et.updateQueue;
      if (nt !== null && ((nt = nt.stores), nt !== null))
        for (var rt = 0; rt < nt.length; rt++) {
          var it = nt[rt],
            st = it.getSnapshot;
          it = it.value;
          try {
            if (!He(st(), it)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((nt = et.child), et.subtreeFlags & 16384 && nt !== null))
      (nt.return = et), (et = nt);
    else {
      if (et === tt) break;
      for (; et.sibling === null; ) {
        if (et.return === null || et.return === tt) return !0;
        et = et.return;
      }
      (et.sibling.return = et.return), (et = et.sibling);
    }
  }
  return !0;
}
function Dk(tt, et) {
  for (
    et &= ~sk,
      et &= ~rk,
      tt.suspendedLanes |= et,
      tt.pingedLanes &= ~et,
      tt = tt.expirationTimes;
    0 < et;

  ) {
    var nt = 31 - oc(et),
      rt = 1 << nt;
    (tt[nt] = -1), (et &= ~rt);
  }
}
function Fk(tt) {
  if (K$1 & 6) throw Error(p$6(327));
  Ik();
  var et = uc(tt, 0);
  if (!(et & 1)) return Ek(tt, B$2()), null;
  var nt = Jk(tt, et);
  if (tt.tag !== 0 && nt === 2) {
    var rt = xc(tt);
    rt !== 0 && ((et = rt), (nt = Ok(tt, rt)));
  }
  if (nt === 1) throw ((nt = qk), Lk(tt, 0), Dk(tt, et), Ek(tt, B$2()), nt);
  if (nt === 6) throw Error(p$6(345));
  return (
    (tt.finishedWork = tt.current.alternate),
    (tt.finishedLanes = et),
    Qk(tt, uk, vk),
    Ek(tt, B$2()),
    null
  );
}
function Rk(tt, et) {
  var nt = K$1;
  K$1 |= 1;
  try {
    return tt(et);
  } finally {
    (K$1 = nt), K$1 === 0 && ((Hj = B$2() + 500), fg && jg());
  }
}
function Sk(tt) {
  xk !== null && xk.tag === 0 && !(K$1 & 6) && Ik();
  var et = K$1;
  K$1 |= 1;
  var nt = pk.transition,
    rt = C$1;
  try {
    if (((pk.transition = null), (C$1 = 1), tt)) return tt();
  } finally {
    (C$1 = rt), (pk.transition = nt), (K$1 = et), !(K$1 & 6) && jg();
  }
}
function Ij() {
  (gj = fj.current), E$2(fj);
}
function Lk(tt, et) {
  (tt.finishedWork = null), (tt.finishedLanes = 0);
  var nt = tt.timeoutHandle;
  if ((nt !== -1 && ((tt.timeoutHandle = -1), Gf(nt)), Y$1 !== null))
    for (nt = Y$1.return; nt !== null; ) {
      var rt = nt;
      switch ((wg(rt), rt.tag)) {
        case 1:
          (rt = rt.type.childContextTypes), rt != null && $f();
          break;
        case 3:
          Jh(), E$2(Wf), E$2(H$2), Oh();
          break;
        case 5:
          Lh(rt);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$2);
          break;
        case 19:
          E$2(M$2);
          break;
        case 10:
          Rg(rt.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      nt = nt.return;
    }
  if (
    ((R$1 = tt),
    (Y$1 = tt = wh(tt.current, null)),
    (Z$2 = gj = et),
    (T$1 = 0),
    (qk = null),
    (sk = rk = hh = 0),
    (uk = tk = null),
    Wg !== null)
  ) {
    for (et = 0; et < Wg.length; et++)
      if (((nt = Wg[et]), (rt = nt.interleaved), rt !== null)) {
        nt.interleaved = null;
        var it = rt.next,
          st = nt.pending;
        if (st !== null) {
          var ot = st.next;
          (st.next = it), (rt.next = ot);
        }
        nt.pending = rt;
      }
    Wg = null;
  }
  return tt;
}
function Nk(tt, et) {
  do {
    var nt = Y$1;
    try {
      if ((Qg(), (Ph.current = ai), Sh)) {
        for (var rt = N$2.memoizedState; rt !== null; ) {
          var it = rt.queue;
          it !== null && (it.pending = null), (rt = rt.next);
        }
        Sh = !1;
      }
      if (
        ((Rh = 0),
        (P$1 = O$1 = N$2 = null),
        (Th = !1),
        (Uh = 0),
        (ok.current = null),
        nt === null || nt.return === null)
      ) {
        (T$1 = 1), (qk = et), (Y$1 = null);
        break;
      }
      e: {
        var st = tt,
          ot = nt.return,
          at = nt,
          lt = et;
        if (
          ((et = Z$2),
          (at.flags |= 32768),
          lt !== null && typeof lt == "object" && typeof lt.then == "function")
        ) {
          var ct = lt,
            ut = at,
            ft = ut.tag;
          if (!(ut.mode & 1) && (ft === 0 || ft === 11 || ft === 15)) {
            var ht = ut.alternate;
            ht
              ? ((ut.updateQueue = ht.updateQueue),
                (ut.memoizedState = ht.memoizedState),
                (ut.lanes = ht.lanes))
              : ((ut.updateQueue = null), (ut.memoizedState = null));
          }
          var mt = Vi(ot);
          if (mt !== null) {
            (mt.flags &= -257),
              Wi(mt, ot, at, st, et),
              mt.mode & 1 && Ti(st, ct, et),
              (et = mt),
              (lt = ct);
            var vt = et.updateQueue;
            if (vt === null) {
              var yt = new Set();
              yt.add(lt), (et.updateQueue = yt);
            } else vt.add(lt);
            break e;
          } else {
            if (!(et & 1)) {
              Ti(st, ct, et), uj();
              break e;
            }
            lt = Error(p$6(426));
          }
        } else if (I$2 && at.mode & 1) {
          var Et = Vi(ot);
          if (Et !== null) {
            !(Et.flags & 65536) && (Et.flags |= 256),
              Wi(Et, ot, at, st, et),
              Jg(Ki(lt, at));
            break e;
          }
        }
        (st = lt = Ki(lt, at)),
          T$1 !== 4 && (T$1 = 2),
          tk === null ? (tk = [st]) : tk.push(st),
          (st = ot);
        do {
          switch (st.tag) {
            case 3:
              (st.flags |= 65536), (et &= -et), (st.lanes |= et);
              var pt = Oi(st, lt, et);
              fh(st, pt);
              break e;
            case 1:
              at = lt;
              var xt = st.type,
                St = st.stateNode;
              if (
                !(st.flags & 128) &&
                (typeof xt.getDerivedStateFromError == "function" ||
                  (St !== null &&
                    typeof St.componentDidCatch == "function" &&
                    (Si === null || !Si.has(St))))
              ) {
                (st.flags |= 65536), (et &= -et), (st.lanes |= et);
                var At = Ri(st, at, et);
                fh(st, At);
                break e;
              }
          }
          st = st.return;
        } while (st !== null);
      }
      Tk(nt);
    } catch (Ct) {
      (et = Ct), Y$1 === nt && nt !== null && (Y$1 = nt = nt.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var tt = nk.current;
  return (nk.current = ai), tt === null ? ai : tt;
}
function uj() {
  (T$1 === 0 || T$1 === 3 || T$1 === 2) && (T$1 = 4),
    R$1 === null || (!(hh & 268435455) && !(rk & 268435455)) || Dk(R$1, Z$2);
}
function Jk(tt, et) {
  var nt = K$1;
  K$1 |= 2;
  var rt = Kk();
  (R$1 !== tt || Z$2 !== et) && ((vk = null), Lk(tt, et));
  do
    try {
      Uk();
      break;
    } catch (it) {
      Nk(tt, it);
    }
  while (1);
  if ((Qg(), (K$1 = nt), (nk.current = rt), Y$1 !== null))
    throw Error(p$6(261));
  return (R$1 = null), (Z$2 = 0), T$1;
}
function Uk() {
  for (; Y$1 !== null; ) Vk(Y$1);
}
function Mk() {
  for (; Y$1 !== null && !cc(); ) Vk(Y$1);
}
function Vk(tt) {
  var et = Wk(tt.alternate, tt, gj);
  (tt.memoizedProps = tt.pendingProps),
    et === null ? Tk(tt) : (Y$1 = et),
    (ok.current = null);
}
function Tk(tt) {
  var et = tt;
  do {
    var nt = et.alternate;
    if (((tt = et.return), et.flags & 32768)) {
      if (((nt = Jj(nt, et)), nt !== null)) {
        (nt.flags &= 32767), (Y$1 = nt);
        return;
      }
      if (tt !== null)
        (tt.flags |= 32768), (tt.subtreeFlags = 0), (tt.deletions = null);
      else {
        (T$1 = 6), (Y$1 = null);
        return;
      }
    } else if (((nt = Fj(nt, et, gj)), nt !== null)) {
      Y$1 = nt;
      return;
    }
    if (((et = et.sibling), et !== null)) {
      Y$1 = et;
      return;
    }
    Y$1 = et = tt;
  } while (et !== null);
  T$1 === 0 && (T$1 = 5);
}
function Qk(tt, et, nt) {
  var rt = C$1,
    it = pk.transition;
  try {
    (pk.transition = null), (C$1 = 1), Xk(tt, et, nt, rt);
  } finally {
    (pk.transition = it), (C$1 = rt);
  }
  return null;
}
function Xk(tt, et, nt, rt) {
  do Ik();
  while (xk !== null);
  if (K$1 & 6) throw Error(p$6(327));
  nt = tt.finishedWork;
  var it = tt.finishedLanes;
  if (nt === null) return null;
  if (((tt.finishedWork = null), (tt.finishedLanes = 0), nt === tt.current))
    throw Error(p$6(177));
  (tt.callbackNode = null), (tt.callbackPriority = 0);
  var st = nt.lanes | nt.childLanes;
  if (
    (Bc(tt, st),
    tt === R$1 && ((Y$1 = R$1 = null), (Z$2 = 0)),
    (!(nt.subtreeFlags & 2064) && !(nt.flags & 2064)) ||
      wk ||
      ((wk = !0),
      Gk(hc, function () {
        return Ik(), null;
      })),
    (st = (nt.flags & 15990) !== 0),
    nt.subtreeFlags & 15990 || st)
  ) {
    (st = pk.transition), (pk.transition = null);
    var ot = C$1;
    C$1 = 1;
    var at = K$1;
    (K$1 |= 4),
      (ok.current = null),
      Pj(tt, nt),
      ek(nt, tt),
      Oe$1(Df),
      (dd = !!Cf),
      (Df = Cf = null),
      (tt.current = nt),
      ik(nt),
      dc(),
      (K$1 = at),
      (C$1 = ot),
      (pk.transition = st);
  } else tt.current = nt;
  if (
    (wk && ((wk = !1), (xk = tt), (yk = it)),
    (st = tt.pendingLanes),
    st === 0 && (Si = null),
    mc(nt.stateNode),
    Ek(tt, B$2()),
    et !== null)
  )
    for (rt = tt.onRecoverableError, nt = 0; nt < et.length; nt++)
      (it = et[nt]),
        rt(it.value, { componentStack: it.stack, digest: it.digest });
  if (Pi) throw ((Pi = !1), (tt = Qi), (Qi = null), tt);
  return (
    yk & 1 && tt.tag !== 0 && Ik(),
    (st = tt.pendingLanes),
    st & 1 ? (tt === Ak ? zk++ : ((zk = 0), (Ak = tt))) : (zk = 0),
    jg(),
    null
  );
}
function Ik() {
  if (xk !== null) {
    var tt = Dc(yk),
      et = pk.transition,
      nt = C$1;
    try {
      if (((pk.transition = null), (C$1 = 16 > tt ? 16 : tt), xk === null))
        var rt = !1;
      else {
        if (((tt = xk), (xk = null), (yk = 0), K$1 & 6)) throw Error(p$6(331));
        var it = K$1;
        for (K$1 |= 4, V$1 = tt.current; V$1 !== null; ) {
          var st = V$1,
            ot = st.child;
          if (V$1.flags & 16) {
            var at = st.deletions;
            if (at !== null) {
              for (var lt = 0; lt < at.length; lt++) {
                var ct = at[lt];
                for (V$1 = ct; V$1 !== null; ) {
                  var ut = V$1;
                  switch (ut.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, ut, st);
                  }
                  var ft = ut.child;
                  if (ft !== null) (ft.return = ut), (V$1 = ft);
                  else
                    for (; V$1 !== null; ) {
                      ut = V$1;
                      var ht = ut.sibling,
                        mt = ut.return;
                      if ((Tj(ut), ut === ct)) {
                        V$1 = null;
                        break;
                      }
                      if (ht !== null) {
                        (ht.return = mt), (V$1 = ht);
                        break;
                      }
                      V$1 = mt;
                    }
                }
              }
              var vt = st.alternate;
              if (vt !== null) {
                var yt = vt.child;
                if (yt !== null) {
                  vt.child = null;
                  do {
                    var Et = yt.sibling;
                    (yt.sibling = null), (yt = Et);
                  } while (yt !== null);
                }
              }
              V$1 = st;
            }
          }
          if (st.subtreeFlags & 2064 && ot !== null)
            (ot.return = st), (V$1 = ot);
          else
            e: for (; V$1 !== null; ) {
              if (((st = V$1), st.flags & 2048))
                switch (st.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, st, st.return);
                }
              var pt = st.sibling;
              if (pt !== null) {
                (pt.return = st.return), (V$1 = pt);
                break e;
              }
              V$1 = st.return;
            }
        }
        var xt = tt.current;
        for (V$1 = xt; V$1 !== null; ) {
          ot = V$1;
          var St = ot.child;
          if (ot.subtreeFlags & 2064 && St !== null)
            (St.return = ot), (V$1 = St);
          else
            e: for (ot = xt; V$1 !== null; ) {
              if (((at = V$1), at.flags & 2048))
                try {
                  switch (at.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Rj(9, at);
                  }
                } catch (Ct) {
                  W$2(at, at.return, Ct);
                }
              if (at === ot) {
                V$1 = null;
                break e;
              }
              var At = at.sibling;
              if (At !== null) {
                (At.return = at.return), (V$1 = At);
                break e;
              }
              V$1 = at.return;
            }
        }
        if (
          ((K$1 = it),
          jg(),
          lc && typeof lc.onPostCommitFiberRoot == "function")
        )
          try {
            lc.onPostCommitFiberRoot(kc, tt);
          } catch {}
        rt = !0;
      }
      return rt;
    } finally {
      (C$1 = nt), (pk.transition = et);
    }
  }
  return !1;
}
function Yk(tt, et, nt) {
  (et = Ki(nt, et)),
    (et = Oi(tt, et, 1)),
    (tt = dh(tt, et, 1)),
    (et = L$2()),
    tt !== null && (Ac(tt, 1, et), Ek(tt, et));
}
function W$2(tt, et, nt) {
  if (tt.tag === 3) Yk(tt, tt, nt);
  else
    for (; et !== null; ) {
      if (et.tag === 3) {
        Yk(et, tt, nt);
        break;
      } else if (et.tag === 1) {
        var rt = et.stateNode;
        if (
          typeof et.type.getDerivedStateFromError == "function" ||
          (typeof rt.componentDidCatch == "function" &&
            (Si === null || !Si.has(rt)))
        ) {
          (tt = Ki(nt, tt)),
            (tt = Ri(et, tt, 1)),
            (et = dh(et, tt, 1)),
            (tt = L$2()),
            et !== null && (Ac(et, 1, tt), Ek(et, tt));
          break;
        }
      }
      et = et.return;
    }
}
function Ui(tt, et, nt) {
  var rt = tt.pingCache;
  rt !== null && rt.delete(et),
    (et = L$2()),
    (tt.pingedLanes |= tt.suspendedLanes & nt),
    R$1 === tt &&
      (Z$2 & nt) === nt &&
      (T$1 === 4 || (T$1 === 3 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - gk)
        ? Lk(tt, 0)
        : (sk |= nt)),
    Ek(tt, et);
}
function Zk(tt, et) {
  et === 0 &&
    (tt.mode & 1
      ? ((et = sc), (sc <<= 1), !(sc & 130023424) && (sc = 4194304))
      : (et = 1));
  var nt = L$2();
  (tt = Zg(tt, et)), tt !== null && (Ac(tt, et, nt), Ek(tt, nt));
}
function vj(tt) {
  var et = tt.memoizedState,
    nt = 0;
  et !== null && (nt = et.retryLane), Zk(tt, nt);
}
function ck(tt, et) {
  var nt = 0;
  switch (tt.tag) {
    case 13:
      var rt = tt.stateNode,
        it = tt.memoizedState;
      it !== null && (nt = it.retryLane);
      break;
    case 19:
      rt = tt.stateNode;
      break;
    default:
      throw Error(p$6(314));
  }
  rt !== null && rt.delete(et), Zk(tt, nt);
}
var Wk;
Wk = function (tt, et, nt) {
  if (tt !== null)
    if (tt.memoizedProps !== et.pendingProps || Wf.current) Ug = !0;
    else {
      if (!(tt.lanes & nt) && !(et.flags & 128))
        return (Ug = !1), zj(tt, et, nt);
      Ug = !!(tt.flags & 131072);
    }
  else (Ug = !1), I$2 && et.flags & 1048576 && ug(et, ng, et.index);
  switch (((et.lanes = 0), et.tag)) {
    case 2:
      var rt = et.type;
      jj(tt, et), (tt = et.pendingProps);
      var it = Yf(et, H$2.current);
      Tg(et, nt), (it = Xh(null, et, rt, tt, it, nt));
      var st = bi();
      return (
        (et.flags |= 1),
        typeof it == "object" &&
        it !== null &&
        typeof it.render == "function" &&
        it.$$typeof === void 0
          ? ((et.tag = 1),
            (et.memoizedState = null),
            (et.updateQueue = null),
            Zf(rt) ? ((st = !0), cg(et)) : (st = !1),
            (et.memoizedState =
              it.state !== null && it.state !== void 0 ? it.state : null),
            ah(et),
            (it.updater = nh),
            (et.stateNode = it),
            (it._reactInternals = et),
            rh(et, rt, tt, nt),
            (et = kj(null, et, rt, !0, st, nt)))
          : ((et.tag = 0),
            I$2 && st && vg(et),
            Yi(null, et, it, nt),
            (et = et.child)),
        et
      );
    case 16:
      rt = et.elementType;
      e: {
        switch (
          (jj(tt, et),
          (tt = et.pendingProps),
          (it = rt._init),
          (rt = it(rt._payload)),
          (et.type = rt),
          (it = et.tag = $k(rt)),
          (tt = Lg(rt, tt)),
          it)
        ) {
          case 0:
            et = dj(null, et, rt, tt, nt);
            break e;
          case 1:
            et = ij(null, et, rt, tt, nt);
            break e;
          case 11:
            et = Zi(null, et, rt, tt, nt);
            break e;
          case 14:
            et = aj(null, et, rt, Lg(rt.type, tt), nt);
            break e;
        }
        throw Error(p$6(306, rt, ""));
      }
      return et;
    case 0:
      return (
        (rt = et.type),
        (it = et.pendingProps),
        (it = et.elementType === rt ? it : Lg(rt, it)),
        dj(tt, et, rt, it, nt)
      );
    case 1:
      return (
        (rt = et.type),
        (it = et.pendingProps),
        (it = et.elementType === rt ? it : Lg(rt, it)),
        ij(tt, et, rt, it, nt)
      );
    case 3:
      e: {
        if ((lj(et), tt === null)) throw Error(p$6(387));
        (rt = et.pendingProps),
          (st = et.memoizedState),
          (it = st.element),
          bh(tt, et),
          gh(et, rt, null, nt);
        var ot = et.memoizedState;
        if (((rt = ot.element), st.isDehydrated))
          if (
            ((st = {
              element: rt,
              isDehydrated: !1,
              cache: ot.cache,
              pendingSuspenseBoundaries: ot.pendingSuspenseBoundaries,
              transitions: ot.transitions,
            }),
            (et.updateQueue.baseState = st),
            (et.memoizedState = st),
            et.flags & 256)
          ) {
            (it = Ki(Error(p$6(423)), et)), (et = mj(tt, et, rt, nt, it));
            break e;
          } else if (rt !== it) {
            (it = Ki(Error(p$6(424)), et)), (et = mj(tt, et, rt, nt, it));
            break e;
          } else
            for (
              yg = Lf(et.stateNode.containerInfo.firstChild),
                xg = et,
                I$2 = !0,
                zg = null,
                nt = Ch(et, null, rt, nt),
                et.child = nt;
              nt;

            )
              (nt.flags = (nt.flags & -3) | 4096), (nt = nt.sibling);
        else {
          if ((Ig(), rt === it)) {
            et = $i(tt, et, nt);
            break e;
          }
          Yi(tt, et, rt, nt);
        }
        et = et.child;
      }
      return et;
    case 5:
      return (
        Kh(et),
        tt === null && Eg(et),
        (rt = et.type),
        (it = et.pendingProps),
        (st = tt !== null ? tt.memoizedProps : null),
        (ot = it.children),
        Ef(rt, it)
          ? (ot = null)
          : st !== null && Ef(rt, st) && (et.flags |= 32),
        hj(tt, et),
        Yi(tt, et, ot, nt),
        et.child
      );
    case 6:
      return tt === null && Eg(et), null;
    case 13:
      return pj(tt, et, nt);
    case 4:
      return (
        Ih(et, et.stateNode.containerInfo),
        (rt = et.pendingProps),
        tt === null ? (et.child = Bh(et, null, rt, nt)) : Yi(tt, et, rt, nt),
        et.child
      );
    case 11:
      return (
        (rt = et.type),
        (it = et.pendingProps),
        (it = et.elementType === rt ? it : Lg(rt, it)),
        Zi(tt, et, rt, it, nt)
      );
    case 7:
      return Yi(tt, et, et.pendingProps, nt), et.child;
    case 8:
      return Yi(tt, et, et.pendingProps.children, nt), et.child;
    case 12:
      return Yi(tt, et, et.pendingProps.children, nt), et.child;
    case 10:
      e: {
        if (
          ((rt = et.type._context),
          (it = et.pendingProps),
          (st = et.memoizedProps),
          (ot = it.value),
          G$2(Mg, rt._currentValue),
          (rt._currentValue = ot),
          st !== null)
        )
          if (He(st.value, ot)) {
            if (st.children === it.children && !Wf.current) {
              et = $i(tt, et, nt);
              break e;
            }
          } else
            for (
              st = et.child, st !== null && (st.return = et);
              st !== null;

            ) {
              var at = st.dependencies;
              if (at !== null) {
                ot = st.child;
                for (var lt = at.firstContext; lt !== null; ) {
                  if (lt.context === rt) {
                    if (st.tag === 1) {
                      (lt = ch(-1, nt & -nt)), (lt.tag = 2);
                      var ct = st.updateQueue;
                      if (ct !== null) {
                        ct = ct.shared;
                        var ut = ct.pending;
                        ut === null
                          ? (lt.next = lt)
                          : ((lt.next = ut.next), (ut.next = lt)),
                          (ct.pending = lt);
                      }
                    }
                    (st.lanes |= nt),
                      (lt = st.alternate),
                      lt !== null && (lt.lanes |= nt),
                      Sg(st.return, nt, et),
                      (at.lanes |= nt);
                    break;
                  }
                  lt = lt.next;
                }
              } else if (st.tag === 10)
                ot = st.type === et.type ? null : st.child;
              else if (st.tag === 18) {
                if (((ot = st.return), ot === null)) throw Error(p$6(341));
                (ot.lanes |= nt),
                  (at = ot.alternate),
                  at !== null && (at.lanes |= nt),
                  Sg(ot, nt, et),
                  (ot = st.sibling);
              } else ot = st.child;
              if (ot !== null) ot.return = st;
              else
                for (ot = st; ot !== null; ) {
                  if (ot === et) {
                    ot = null;
                    break;
                  }
                  if (((st = ot.sibling), st !== null)) {
                    (st.return = ot.return), (ot = st);
                    break;
                  }
                  ot = ot.return;
                }
              st = ot;
            }
        Yi(tt, et, it.children, nt), (et = et.child);
      }
      return et;
    case 9:
      return (
        (it = et.type),
        (rt = et.pendingProps.children),
        Tg(et, nt),
        (it = Vg(it)),
        (rt = rt(it)),
        (et.flags |= 1),
        Yi(tt, et, rt, nt),
        et.child
      );
    case 14:
      return (
        (rt = et.type),
        (it = Lg(rt, et.pendingProps)),
        (it = Lg(rt.type, it)),
        aj(tt, et, rt, it, nt)
      );
    case 15:
      return cj(tt, et, et.type, et.pendingProps, nt);
    case 17:
      return (
        (rt = et.type),
        (it = et.pendingProps),
        (it = et.elementType === rt ? it : Lg(rt, it)),
        jj(tt, et),
        (et.tag = 1),
        Zf(rt) ? ((tt = !0), cg(et)) : (tt = !1),
        Tg(et, nt),
        ph(et, rt, it),
        rh(et, rt, it, nt),
        kj(null, et, rt, !0, tt, nt)
      );
    case 19:
      return yj(tt, et, nt);
    case 22:
      return ej(tt, et, nt);
  }
  throw Error(p$6(156, et.tag));
};
function Gk(tt, et) {
  return ac(tt, et);
}
function al(tt, et, nt, rt) {
  (this.tag = tt),
    (this.key = nt),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = et),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = rt),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Bg(tt, et, nt, rt) {
  return new al(tt, et, nt, rt);
}
function bj(tt) {
  return (tt = tt.prototype), !(!tt || !tt.isReactComponent);
}
function $k(tt) {
  if (typeof tt == "function") return bj(tt) ? 1 : 0;
  if (tt != null) {
    if (((tt = tt.$$typeof), tt === Da)) return 11;
    if (tt === Ga) return 14;
  }
  return 2;
}
function wh(tt, et) {
  var nt = tt.alternate;
  return (
    nt === null
      ? ((nt = Bg(tt.tag, et, tt.key, tt.mode)),
        (nt.elementType = tt.elementType),
        (nt.type = tt.type),
        (nt.stateNode = tt.stateNode),
        (nt.alternate = tt),
        (tt.alternate = nt))
      : ((nt.pendingProps = et),
        (nt.type = tt.type),
        (nt.flags = 0),
        (nt.subtreeFlags = 0),
        (nt.deletions = null)),
    (nt.flags = tt.flags & 14680064),
    (nt.childLanes = tt.childLanes),
    (nt.lanes = tt.lanes),
    (nt.child = tt.child),
    (nt.memoizedProps = tt.memoizedProps),
    (nt.memoizedState = tt.memoizedState),
    (nt.updateQueue = tt.updateQueue),
    (et = tt.dependencies),
    (nt.dependencies =
      et === null ? null : { lanes: et.lanes, firstContext: et.firstContext }),
    (nt.sibling = tt.sibling),
    (nt.index = tt.index),
    (nt.ref = tt.ref),
    nt
  );
}
function yh(tt, et, nt, rt, it, st) {
  var ot = 2;
  if (((rt = tt), typeof tt == "function")) bj(tt) && (ot = 1);
  else if (typeof tt == "string") ot = 5;
  else
    e: switch (tt) {
      case ya:
        return Ah(nt.children, it, st, et);
      case za:
        (ot = 8), (it |= 8);
        break;
      case Aa:
        return (
          (tt = Bg(12, nt, et, it | 2)),
          (tt.elementType = Aa),
          (tt.lanes = st),
          tt
        );
      case Ea:
        return (
          (tt = Bg(13, nt, et, it)), (tt.elementType = Ea), (tt.lanes = st), tt
        );
      case Fa:
        return (
          (tt = Bg(19, nt, et, it)), (tt.elementType = Fa), (tt.lanes = st), tt
        );
      case Ia:
        return qj(nt, it, st, et);
      default:
        if (typeof tt == "object" && tt !== null)
          switch (tt.$$typeof) {
            case Ba:
              ot = 10;
              break e;
            case Ca:
              ot = 9;
              break e;
            case Da:
              ot = 11;
              break e;
            case Ga:
              ot = 14;
              break e;
            case Ha:
              (ot = 16), (rt = null);
              break e;
          }
        throw Error(p$6(130, tt == null ? tt : typeof tt, ""));
    }
  return (
    (et = Bg(ot, nt, et, it)),
    (et.elementType = tt),
    (et.type = rt),
    (et.lanes = st),
    et
  );
}
function Ah(tt, et, nt, rt) {
  return (tt = Bg(7, tt, rt, et)), (tt.lanes = nt), tt;
}
function qj(tt, et, nt, rt) {
  return (
    (tt = Bg(22, tt, rt, et)),
    (tt.elementType = Ia),
    (tt.lanes = nt),
    (tt.stateNode = { isHidden: !1 }),
    tt
  );
}
function xh(tt, et, nt) {
  return (tt = Bg(6, tt, null, et)), (tt.lanes = nt), tt;
}
function zh(tt, et, nt) {
  return (
    (et = Bg(4, tt.children !== null ? tt.children : [], tt.key, et)),
    (et.lanes = nt),
    (et.stateNode = {
      containerInfo: tt.containerInfo,
      pendingChildren: null,
      implementation: tt.implementation,
    }),
    et
  );
}
function bl(tt, et, nt, rt, it) {
  (this.tag = et),
    (this.containerInfo = tt),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = zc(0)),
    (this.expirationTimes = zc(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = zc(0)),
    (this.identifierPrefix = rt),
    (this.onRecoverableError = it),
    (this.mutableSourceEagerHydrationData = null);
}
function cl(tt, et, nt, rt, it, st, ot, at, lt) {
  return (
    (tt = new bl(tt, et, nt, at, lt)),
    et === 1 ? ((et = 1), st === !0 && (et |= 8)) : (et = 0),
    (st = Bg(3, null, null, et)),
    (tt.current = st),
    (st.stateNode = tt),
    (st.memoizedState = {
      element: rt,
      isDehydrated: nt,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    ah(st),
    tt
  );
}
function dl(tt, et, nt) {
  var rt =
    3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: wa,
    key: rt == null ? null : "" + rt,
    children: tt,
    containerInfo: et,
    implementation: nt,
  };
}
function el(tt) {
  if (!tt) return Vf;
  tt = tt._reactInternals;
  e: {
    if (Vb(tt) !== tt || tt.tag !== 1) throw Error(p$6(170));
    var et = tt;
    do {
      switch (et.tag) {
        case 3:
          et = et.stateNode.context;
          break e;
        case 1:
          if (Zf(et.type)) {
            et = et.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      et = et.return;
    } while (et !== null);
    throw Error(p$6(171));
  }
  if (tt.tag === 1) {
    var nt = tt.type;
    if (Zf(nt)) return bg(tt, nt, et);
  }
  return et;
}
function fl(tt, et, nt, rt, it, st, ot, at, lt) {
  return (
    (tt = cl(nt, rt, !0, tt, it, st, ot, at, lt)),
    (tt.context = el(null)),
    (nt = tt.current),
    (rt = L$2()),
    (it = lh(nt)),
    (st = ch(rt, it)),
    (st.callback = et ?? null),
    dh(nt, st, it),
    (tt.current.lanes = it),
    Ac(tt, it, rt),
    Ek(tt, rt),
    tt
  );
}
function gl(tt, et, nt, rt) {
  var it = et.current,
    st = L$2(),
    ot = lh(it);
  return (
    (nt = el(nt)),
    et.context === null ? (et.context = nt) : (et.pendingContext = nt),
    (et = ch(st, ot)),
    (et.payload = { element: tt }),
    (rt = rt === void 0 ? null : rt),
    rt !== null && (et.callback = rt),
    (tt = dh(it, et, ot)),
    tt !== null && (mh(tt, it, ot, st), eh(tt, it, ot)),
    ot
  );
}
function hl(tt) {
  if (((tt = tt.current), !tt.child)) return null;
  switch (tt.child.tag) {
    case 5:
      return tt.child.stateNode;
    default:
      return tt.child.stateNode;
  }
}
function il(tt, et) {
  if (((tt = tt.memoizedState), tt !== null && tt.dehydrated !== null)) {
    var nt = tt.retryLane;
    tt.retryLane = nt !== 0 && nt < et ? nt : et;
  }
}
function jl(tt, et) {
  il(tt, et), (tt = tt.alternate) && il(tt, et);
}
function kl() {
  return null;
}
var ll =
  typeof reportError == "function"
    ? reportError
    : function (tt) {
        console.error(tt);
      };
function ml(tt) {
  this._internalRoot = tt;
}
nl.prototype.render = ml.prototype.render = function (tt) {
  var et = this._internalRoot;
  if (et === null) throw Error(p$6(409));
  gl(tt, et, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function () {
  var tt = this._internalRoot;
  if (tt !== null) {
    this._internalRoot = null;
    var et = tt.containerInfo;
    Sk(function () {
      gl(null, tt, null, null);
    }),
      (et[uf] = null);
  }
};
function nl(tt) {
  this._internalRoot = tt;
}
nl.prototype.unstable_scheduleHydration = function (tt) {
  if (tt) {
    var et = Hc();
    tt = { blockedOn: null, target: tt, priority: et };
    for (var nt = 0; nt < Qc.length && et !== 0 && et < Qc[nt].priority; nt++);
    Qc.splice(nt, 0, tt), nt === 0 && Vc(tt);
  }
};
function ol(tt) {
  return !(
    !tt ||
    (tt.nodeType !== 1 && tt.nodeType !== 9 && tt.nodeType !== 11)
  );
}
function pl(tt) {
  return !(
    !tt ||
    (tt.nodeType !== 1 &&
      tt.nodeType !== 9 &&
      tt.nodeType !== 11 &&
      (tt.nodeType !== 8 || tt.nodeValue !== " react-mount-point-unstable "))
  );
}
function ql() {}
function rl(tt, et, nt, rt, it) {
  if (it) {
    if (typeof rt == "function") {
      var st = rt;
      rt = function () {
        var ct = hl(ot);
        st.call(ct);
      };
    }
    var ot = fl(et, rt, tt, 0, null, !1, !1, "", ql);
    return (
      (tt._reactRootContainer = ot),
      (tt[uf] = ot.current),
      sf(tt.nodeType === 8 ? tt.parentNode : tt),
      Sk(),
      ot
    );
  }
  for (; (it = tt.lastChild); ) tt.removeChild(it);
  if (typeof rt == "function") {
    var at = rt;
    rt = function () {
      var ct = hl(lt);
      at.call(ct);
    };
  }
  var lt = cl(tt, 0, !1, null, null, !1, !1, "", ql);
  return (
    (tt._reactRootContainer = lt),
    (tt[uf] = lt.current),
    sf(tt.nodeType === 8 ? tt.parentNode : tt),
    Sk(function () {
      gl(et, lt, nt, rt);
    }),
    lt
  );
}
function sl(tt, et, nt, rt, it) {
  var st = nt._reactRootContainer;
  if (st) {
    var ot = st;
    if (typeof it == "function") {
      var at = it;
      it = function () {
        var lt = hl(ot);
        at.call(lt);
      };
    }
    gl(et, ot, tt, it);
  } else ot = rl(nt, et, tt, it, rt);
  return hl(ot);
}
Ec = function (tt) {
  switch (tt.tag) {
    case 3:
      var et = tt.stateNode;
      if (et.current.memoizedState.isDehydrated) {
        var nt = tc(et.pendingLanes);
        nt !== 0 &&
          (Cc(et, nt | 1),
          Ek(et, B$2()),
          !(K$1 & 6) && ((Hj = B$2() + 500), jg()));
      }
      break;
    case 13:
      Sk(function () {
        var rt = Zg(tt, 1);
        if (rt !== null) {
          var it = L$2();
          mh(rt, tt, 1, it);
        }
      }),
        jl(tt, 1);
  }
};
Fc = function (tt) {
  if (tt.tag === 13) {
    var et = Zg(tt, 134217728);
    if (et !== null) {
      var nt = L$2();
      mh(et, tt, 134217728, nt);
    }
    jl(tt, 134217728);
  }
};
Gc = function (tt) {
  if (tt.tag === 13) {
    var et = lh(tt),
      nt = Zg(tt, et);
    if (nt !== null) {
      var rt = L$2();
      mh(nt, tt, et, rt);
    }
    jl(tt, et);
  }
};
Hc = function () {
  return C$1;
};
Ic = function (tt, et) {
  var nt = C$1;
  try {
    return (C$1 = tt), et();
  } finally {
    C$1 = nt;
  }
};
yb = function (tt, et, nt) {
  switch (et) {
    case "input":
      if ((bb(tt, nt), (et = nt.name), nt.type === "radio" && et != null)) {
        for (nt = tt; nt.parentNode; ) nt = nt.parentNode;
        for (
          nt = nt.querySelectorAll(
            "input[name=" + JSON.stringify("" + et) + '][type="radio"]'
          ),
            et = 0;
          et < nt.length;
          et++
        ) {
          var rt = nt[et];
          if (rt !== tt && rt.form === tt.form) {
            var it = Db(rt);
            if (!it) throw Error(p$6(90));
            Wa(rt), bb(rt, it);
          }
        }
      }
      break;
    case "textarea":
      ib(tt, nt);
      break;
    case "select":
      (et = nt.value), et != null && fb(tt, !!nt.multiple, et, !1);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Rk] },
  ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  vl = {
    bundleType: ul.bundleType,
    version: ul.version,
    rendererPackageName: ul.rendererPackageName,
    rendererConfig: ul.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (tt) {
      return (tt = Zb(tt)), tt === null ? null : tt.stateNode;
    },
    findFiberByHostInstance: ul.findFiberByHostInstance || kl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      (kc = wl.inject(vl)), (lc = wl);
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function (tt, et) {
  var nt =
    2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ol(et)) throw Error(p$6(200));
  return dl(tt, et, null, nt);
};
reactDom_production_min.createRoot = function (tt, et) {
  if (!ol(tt)) throw Error(p$6(299));
  var nt = !1,
    rt = "",
    it = ll;
  return (
    et != null &&
      (et.unstable_strictMode === !0 && (nt = !0),
      et.identifierPrefix !== void 0 && (rt = et.identifierPrefix),
      et.onRecoverableError !== void 0 && (it = et.onRecoverableError)),
    (et = cl(tt, 1, !1, null, null, nt, !1, rt, it)),
    (tt[uf] = et.current),
    sf(tt.nodeType === 8 ? tt.parentNode : tt),
    new ml(et)
  );
};
reactDom_production_min.findDOMNode = function (tt) {
  if (tt == null) return null;
  if (tt.nodeType === 1) return tt;
  var et = tt._reactInternals;
  if (et === void 0)
    throw typeof tt.render == "function"
      ? Error(p$6(188))
      : ((tt = Object.keys(tt).join(",")), Error(p$6(268, tt)));
  return (tt = Zb(et)), (tt = tt === null ? null : tt.stateNode), tt;
};
reactDom_production_min.flushSync = function (tt) {
  return Sk(tt);
};
reactDom_production_min.hydrate = function (tt, et, nt) {
  if (!pl(et)) throw Error(p$6(200));
  return sl(null, tt, et, !0, nt);
};
reactDom_production_min.hydrateRoot = function (tt, et, nt) {
  if (!ol(tt)) throw Error(p$6(405));
  var rt = (nt != null && nt.hydratedSources) || null,
    it = !1,
    st = "",
    ot = ll;
  if (
    (nt != null &&
      (nt.unstable_strictMode === !0 && (it = !0),
      nt.identifierPrefix !== void 0 && (st = nt.identifierPrefix),
      nt.onRecoverableError !== void 0 && (ot = nt.onRecoverableError)),
    (et = fl(et, null, tt, 1, nt ?? null, it, !1, st, ot)),
    (tt[uf] = et.current),
    sf(tt),
    rt)
  )
    for (tt = 0; tt < rt.length; tt++)
      (nt = rt[tt]),
        (it = nt._getVersion),
        (it = it(nt._source)),
        et.mutableSourceEagerHydrationData == null
          ? (et.mutableSourceEagerHydrationData = [nt, it])
          : et.mutableSourceEagerHydrationData.push(nt, it);
  return new nl(et);
};
reactDom_production_min.render = function (tt, et, nt) {
  if (!pl(et)) throw Error(p$6(200));
  return sl(null, tt, et, !1, nt);
};
reactDom_production_min.unmountComponentAtNode = function (tt) {
  if (!pl(tt)) throw Error(p$6(40));
  return tt._reactRootContainer
    ? (Sk(function () {
        sl(null, null, tt, !1, function () {
          (tt._reactRootContainer = null), (tt[uf] = null);
        });
      }),
      !0)
    : !1;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function (
  tt,
  et,
  nt,
  rt
) {
  if (!pl(nt)) throw Error(p$6(200));
  if (tt == null || tt._reactInternals === void 0) throw Error(p$6(38));
  return sl(tt, et, nt, !1, rt);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (tt) {
      console.error(tt);
    }
}
checkDCE(), (reactDom.exports = reactDom_production_min);
var reactDomExports = reactDom.exports;
const ReactDOM = getDefaultExportFromCjs(reactDomExports);
var createRoot$1,
  m$6 = reactDomExports;
(createRoot$1 = client.createRoot = m$6.createRoot),
  (client.hydrateRoot = m$6.hydrateRoot);
const App$1 = "";
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const REVISION = "157",
  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  CullFaceFrontBack = 3,
  BasicShadowMap = 0,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  TwoPassDoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipMapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  NearestMipMapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipMapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  LinearMipMapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  AlphaFormat = 1021,
  RGBAFormat = 1023,
  LuminanceFormat = 1024,
  LuminanceAlphaFormat = 1025,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RGB_BPTC_SIGNED_Format = 36494,
  RGB_BPTC_UNSIGNED_Format = 36495,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LoopOnce = 2200,
  LoopRepeat = 2201,
  LoopPingPong = 2202,
  InterpolateDiscrete = 2300,
  InterpolateLinear = 2301,
  InterpolateSmooth = 2302,
  ZeroCurvatureEnding = 2400,
  ZeroSlopeEnding = 2401,
  WrapAroundEnding = 2402,
  NormalAnimationBlendMode = 2500,
  AdditiveAnimationBlendMode = 2501,
  TrianglesDrawMode = 0,
  TriangleStripDrawMode = 1,
  TriangleFanDrawMode = 2,
  LinearEncoding = 3e3,
  sRGBEncoding = 3001,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  NoColorSpace = "",
  SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  DisplayP3ColorSpace = "display-p3",
  LinearDisplayP3ColorSpace = "display-p3-linear",
  LinearTransfer = "linear",
  SRGBTransfer = "srgb",
  Rec709Primaries = "rec709",
  P3Primaries = "p3",
  ZeroStencilOp = 0,
  KeepStencilOp = 7680,
  ReplaceStencilOp = 7681,
  IncrementStencilOp = 7682,
  DecrementStencilOp = 7683,
  IncrementWrapStencilOp = 34055,
  DecrementWrapStencilOp = 34056,
  InvertStencilOp = 5386,
  NeverStencilFunc = 512,
  LessStencilFunc = 513,
  EqualStencilFunc = 514,
  LessEqualStencilFunc = 515,
  GreaterStencilFunc = 516,
  NotEqualStencilFunc = 517,
  GreaterEqualStencilFunc = 518,
  AlwaysStencilFunc = 519,
  NeverCompare = 512,
  LessCompare = 513,
  EqualCompare = 514,
  LessEqualCompare = 515,
  GreaterCompare = 516,
  NotEqualCompare = 517,
  GreaterEqualCompare = 518,
  AlwaysCompare = 519,
  StaticDrawUsage = 35044,
  DynamicDrawUsage = 35048,
  StreamDrawUsage = 35040,
  StaticReadUsage = 35045,
  DynamicReadUsage = 35049,
  StreamReadUsage = 35041,
  StaticCopyUsage = 35046,
  DynamicCopyUsage = 35050,
  StreamCopyUsage = 35042,
  GLSL1 = "100",
  GLSL3 = "300 es",
  _SRGBAFormat = 1035,
  WebGLCoordinateSystem = 2e3,
  WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(et, nt) {
    this._listeners === void 0 && (this._listeners = {});
    const rt = this._listeners;
    rt[et] === void 0 && (rt[et] = []),
      rt[et].indexOf(nt) === -1 && rt[et].push(nt);
  }
  hasEventListener(et, nt) {
    if (this._listeners === void 0) return !1;
    const rt = this._listeners;
    return rt[et] !== void 0 && rt[et].indexOf(nt) !== -1;
  }
  removeEventListener(et, nt) {
    if (this._listeners === void 0) return;
    const it = this._listeners[et];
    if (it !== void 0) {
      const st = it.indexOf(nt);
      st !== -1 && it.splice(st, 1);
    }
  }
  dispatchEvent(et) {
    if (this._listeners === void 0) return;
    const rt = this._listeners[et.type];
    if (rt !== void 0) {
      et.target = this;
      const it = rt.slice(0);
      for (let st = 0, ot = it.length; st < ot; st++) it[st].call(this, et);
      et.target = null;
    }
  }
}
const _lut$1 = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180,
  RAD2DEG = 180 / Math.PI;
function generateUUID$1() {
  const tt = (Math.random() * 4294967295) | 0,
    et = (Math.random() * 4294967295) | 0,
    nt = (Math.random() * 4294967295) | 0,
    rt = (Math.random() * 4294967295) | 0;
  return (
    _lut$1[tt & 255] +
    _lut$1[(tt >> 8) & 255] +
    _lut$1[(tt >> 16) & 255] +
    _lut$1[(tt >> 24) & 255] +
    "-" +
    _lut$1[et & 255] +
    _lut$1[(et >> 8) & 255] +
    "-" +
    _lut$1[((et >> 16) & 15) | 64] +
    _lut$1[(et >> 24) & 255] +
    "-" +
    _lut$1[(nt & 63) | 128] +
    _lut$1[(nt >> 8) & 255] +
    "-" +
    _lut$1[(nt >> 16) & 255] +
    _lut$1[(nt >> 24) & 255] +
    _lut$1[rt & 255] +
    _lut$1[(rt >> 8) & 255] +
    _lut$1[(rt >> 16) & 255] +
    _lut$1[(rt >> 24) & 255]
  ).toLowerCase();
}
function clamp$1(tt, et, nt) {
  return Math.max(et, Math.min(nt, tt));
}
function euclideanModulo(tt, et) {
  return ((tt % et) + et) % et;
}
function mapLinear(tt, et, nt, rt, it) {
  return rt + ((tt - et) * (it - rt)) / (nt - et);
}
function inverseLerp(tt, et, nt) {
  return tt !== et ? (nt - tt) / (et - tt) : 0;
}
function lerp(tt, et, nt) {
  return (1 - nt) * tt + nt * et;
}
function damp(tt, et, nt, rt) {
  return lerp(tt, et, 1 - Math.exp(-nt * rt));
}
function pingpong(tt, et = 1) {
  return et - Math.abs(euclideanModulo(tt, et * 2) - et);
}
function smoothstep(tt, et, nt) {
  return tt <= et
    ? 0
    : tt >= nt
    ? 1
    : ((tt = (tt - et) / (nt - et)), tt * tt * (3 - 2 * tt));
}
function smootherstep(tt, et, nt) {
  return tt <= et
    ? 0
    : tt >= nt
    ? 1
    : ((tt = (tt - et) / (nt - et)), tt * tt * tt * (tt * (tt * 6 - 15) + 10));
}
function randInt(tt, et) {
  return tt + Math.floor(Math.random() * (et - tt + 1));
}
function randFloat(tt, et) {
  return tt + Math.random() * (et - tt);
}
function randFloatSpread(tt) {
  return tt * (0.5 - Math.random());
}
function seededRandom(tt) {
  tt !== void 0 && (_seed = tt);
  let et = (_seed += 1831565813);
  return (
    (et = Math.imul(et ^ (et >>> 15), et | 1)),
    (et ^= et + Math.imul(et ^ (et >>> 7), et | 61)),
    ((et ^ (et >>> 14)) >>> 0) / 4294967296
  );
}
function degToRad(tt) {
  return tt * DEG2RAD;
}
function radToDeg(tt) {
  return tt * RAD2DEG;
}
function isPowerOfTwo(tt) {
  return (tt & (tt - 1)) === 0 && tt !== 0;
}
function ceilPowerOfTwo(tt) {
  return Math.pow(2, Math.ceil(Math.log(tt) / Math.LN2));
}
function floorPowerOfTwo(tt) {
  return Math.pow(2, Math.floor(Math.log(tt) / Math.LN2));
}
function setQuaternionFromProperEuler(tt, et, nt, rt, it) {
  const st = Math.cos,
    ot = Math.sin,
    at = st(nt / 2),
    lt = ot(nt / 2),
    ct = st((et + rt) / 2),
    ut = ot((et + rt) / 2),
    ft = st((et - rt) / 2),
    ht = ot((et - rt) / 2),
    mt = st((rt - et) / 2),
    vt = ot((rt - et) / 2);
  switch (it) {
    case "XYX":
      tt.set(at * ut, lt * ft, lt * ht, at * ct);
      break;
    case "YZY":
      tt.set(lt * ht, at * ut, lt * ft, at * ct);
      break;
    case "ZXZ":
      tt.set(lt * ft, lt * ht, at * ut, at * ct);
      break;
    case "XZX":
      tt.set(at * ut, lt * vt, lt * mt, at * ct);
      break;
    case "YXY":
      tt.set(lt * mt, at * ut, lt * vt, at * ct);
      break;
    case "ZYZ":
      tt.set(lt * vt, lt * mt, at * ut, at * ct);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          it
      );
  }
}
function denormalize(tt, et) {
  switch (et.constructor) {
    case Float32Array:
      return tt;
    case Uint32Array:
      return tt / 4294967295;
    case Uint16Array:
      return tt / 65535;
    case Uint8Array:
      return tt / 255;
    case Int32Array:
      return Math.max(tt / 2147483647, -1);
    case Int16Array:
      return Math.max(tt / 32767, -1);
    case Int8Array:
      return Math.max(tt / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(tt, et) {
  switch (et.constructor) {
    case Float32Array:
      return tt;
    case Uint32Array:
      return Math.round(tt * 4294967295);
    case Uint16Array:
      return Math.round(tt * 65535);
    case Uint8Array:
      return Math.round(tt * 255);
    case Int32Array:
      return Math.round(tt * 2147483647);
    case Int16Array:
      return Math.round(tt * 32767);
    case Int8Array:
      return Math.round(tt * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID: generateUUID$1,
  clamp: clamp$1,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize,
};
class Vector2 {
  constructor(et = 0, nt = 0) {
    (Vector2.prototype.isVector2 = !0), (this.x = et), (this.y = nt);
  }
  get width() {
    return this.x;
  }
  set width(et) {
    this.x = et;
  }
  get height() {
    return this.y;
  }
  set height(et) {
    this.y = et;
  }
  set(et, nt) {
    return (this.x = et), (this.y = nt), this;
  }
  setScalar(et) {
    return (this.x = et), (this.y = et), this;
  }
  setX(et) {
    return (this.x = et), this;
  }
  setY(et) {
    return (this.y = et), this;
  }
  setComponent(et, nt) {
    switch (et) {
      case 0:
        this.x = nt;
        break;
      case 1:
        this.y = nt;
        break;
      default:
        throw new Error("index is out of range: " + et);
    }
    return this;
  }
  getComponent(et) {
    switch (et) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + et);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(et) {
    return (this.x = et.x), (this.y = et.y), this;
  }
  add(et) {
    return (this.x += et.x), (this.y += et.y), this;
  }
  addScalar(et) {
    return (this.x += et), (this.y += et), this;
  }
  addVectors(et, nt) {
    return (this.x = et.x + nt.x), (this.y = et.y + nt.y), this;
  }
  addScaledVector(et, nt) {
    return (this.x += et.x * nt), (this.y += et.y * nt), this;
  }
  sub(et) {
    return (this.x -= et.x), (this.y -= et.y), this;
  }
  subScalar(et) {
    return (this.x -= et), (this.y -= et), this;
  }
  subVectors(et, nt) {
    return (this.x = et.x - nt.x), (this.y = et.y - nt.y), this;
  }
  multiply(et) {
    return (this.x *= et.x), (this.y *= et.y), this;
  }
  multiplyScalar(et) {
    return (this.x *= et), (this.y *= et), this;
  }
  divide(et) {
    return (this.x /= et.x), (this.y /= et.y), this;
  }
  divideScalar(et) {
    return this.multiplyScalar(1 / et);
  }
  applyMatrix3(et) {
    const nt = this.x,
      rt = this.y,
      it = et.elements;
    return (
      (this.x = it[0] * nt + it[3] * rt + it[6]),
      (this.y = it[1] * nt + it[4] * rt + it[7]),
      this
    );
  }
  min(et) {
    return (
      (this.x = Math.min(this.x, et.x)), (this.y = Math.min(this.y, et.y)), this
    );
  }
  max(et) {
    return (
      (this.x = Math.max(this.x, et.x)), (this.y = Math.max(this.y, et.y)), this
    );
  }
  clamp(et, nt) {
    return (
      (this.x = Math.max(et.x, Math.min(nt.x, this.x))),
      (this.y = Math.max(et.y, Math.min(nt.y, this.y))),
      this
    );
  }
  clampScalar(et, nt) {
    return (
      (this.x = Math.max(et, Math.min(nt, this.x))),
      (this.y = Math.max(et, Math.min(nt, this.y))),
      this
    );
  }
  clampLength(et, nt) {
    const rt = this.length();
    return this.divideScalar(rt || 1).multiplyScalar(
      Math.max(et, Math.min(nt, rt))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(et) {
    return this.x * et.x + this.y * et.y;
  }
  cross(et) {
    return this.x * et.y - this.y * et.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(et) {
    const nt = Math.sqrt(this.lengthSq() * et.lengthSq());
    if (nt === 0) return Math.PI / 2;
    const rt = this.dot(et) / nt;
    return Math.acos(clamp$1(rt, -1, 1));
  }
  distanceTo(et) {
    return Math.sqrt(this.distanceToSquared(et));
  }
  distanceToSquared(et) {
    const nt = this.x - et.x,
      rt = this.y - et.y;
    return nt * nt + rt * rt;
  }
  manhattanDistanceTo(et) {
    return Math.abs(this.x - et.x) + Math.abs(this.y - et.y);
  }
  setLength(et) {
    return this.normalize().multiplyScalar(et);
  }
  lerp(et, nt) {
    return (
      (this.x += (et.x - this.x) * nt), (this.y += (et.y - this.y) * nt), this
    );
  }
  lerpVectors(et, nt, rt) {
    return (
      (this.x = et.x + (nt.x - et.x) * rt),
      (this.y = et.y + (nt.y - et.y) * rt),
      this
    );
  }
  equals(et) {
    return et.x === this.x && et.y === this.y;
  }
  fromArray(et, nt = 0) {
    return (this.x = et[nt]), (this.y = et[nt + 1]), this;
  }
  toArray(et = [], nt = 0) {
    return (et[nt] = this.x), (et[nt + 1] = this.y), et;
  }
  fromBufferAttribute(et, nt) {
    return (this.x = et.getX(nt)), (this.y = et.getY(nt)), this;
  }
  rotateAround(et, nt) {
    const rt = Math.cos(nt),
      it = Math.sin(nt),
      st = this.x - et.x,
      ot = this.y - et.y;
    return (
      (this.x = st * rt - ot * it + et.x),
      (this.y = st * it + ot * rt + et.y),
      this
    );
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Matrix3 {
  constructor(et, nt, rt, it, st, ot, at, lt, ct) {
    (Matrix3.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      et !== void 0 && this.set(et, nt, rt, it, st, ot, at, lt, ct);
  }
  set(et, nt, rt, it, st, ot, at, lt, ct) {
    const ut = this.elements;
    return (
      (ut[0] = et),
      (ut[1] = it),
      (ut[2] = at),
      (ut[3] = nt),
      (ut[4] = st),
      (ut[5] = lt),
      (ut[6] = rt),
      (ut[7] = ot),
      (ut[8] = ct),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(et) {
    const nt = this.elements,
      rt = et.elements;
    return (
      (nt[0] = rt[0]),
      (nt[1] = rt[1]),
      (nt[2] = rt[2]),
      (nt[3] = rt[3]),
      (nt[4] = rt[4]),
      (nt[5] = rt[5]),
      (nt[6] = rt[6]),
      (nt[7] = rt[7]),
      (nt[8] = rt[8]),
      this
    );
  }
  extractBasis(et, nt, rt) {
    return (
      et.setFromMatrix3Column(this, 0),
      nt.setFromMatrix3Column(this, 1),
      rt.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(et) {
    const nt = et.elements;
    return (
      this.set(nt[0], nt[4], nt[8], nt[1], nt[5], nt[9], nt[2], nt[6], nt[10]),
      this
    );
  }
  multiply(et) {
    return this.multiplyMatrices(this, et);
  }
  premultiply(et) {
    return this.multiplyMatrices(et, this);
  }
  multiplyMatrices(et, nt) {
    const rt = et.elements,
      it = nt.elements,
      st = this.elements,
      ot = rt[0],
      at = rt[3],
      lt = rt[6],
      ct = rt[1],
      ut = rt[4],
      ft = rt[7],
      ht = rt[2],
      mt = rt[5],
      vt = rt[8],
      yt = it[0],
      Et = it[3],
      pt = it[6],
      xt = it[1],
      St = it[4],
      At = it[7],
      Ct = it[2],
      Mt = it[5],
      wt = it[8];
    return (
      (st[0] = ot * yt + at * xt + lt * Ct),
      (st[3] = ot * Et + at * St + lt * Mt),
      (st[6] = ot * pt + at * At + lt * wt),
      (st[1] = ct * yt + ut * xt + ft * Ct),
      (st[4] = ct * Et + ut * St + ft * Mt),
      (st[7] = ct * pt + ut * At + ft * wt),
      (st[2] = ht * yt + mt * xt + vt * Ct),
      (st[5] = ht * Et + mt * St + vt * Mt),
      (st[8] = ht * pt + mt * At + vt * wt),
      this
    );
  }
  multiplyScalar(et) {
    const nt = this.elements;
    return (
      (nt[0] *= et),
      (nt[3] *= et),
      (nt[6] *= et),
      (nt[1] *= et),
      (nt[4] *= et),
      (nt[7] *= et),
      (nt[2] *= et),
      (nt[5] *= et),
      (nt[8] *= et),
      this
    );
  }
  determinant() {
    const et = this.elements,
      nt = et[0],
      rt = et[1],
      it = et[2],
      st = et[3],
      ot = et[4],
      at = et[5],
      lt = et[6],
      ct = et[7],
      ut = et[8];
    return (
      nt * ot * ut -
      nt * at * ct -
      rt * st * ut +
      rt * at * lt +
      it * st * ct -
      it * ot * lt
    );
  }
  invert() {
    const et = this.elements,
      nt = et[0],
      rt = et[1],
      it = et[2],
      st = et[3],
      ot = et[4],
      at = et[5],
      lt = et[6],
      ct = et[7],
      ut = et[8],
      ft = ut * ot - at * ct,
      ht = at * lt - ut * st,
      mt = ct * st - ot * lt,
      vt = nt * ft + rt * ht + it * mt;
    if (vt === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const yt = 1 / vt;
    return (
      (et[0] = ft * yt),
      (et[1] = (it * ct - ut * rt) * yt),
      (et[2] = (at * rt - it * ot) * yt),
      (et[3] = ht * yt),
      (et[4] = (ut * nt - it * lt) * yt),
      (et[5] = (it * st - at * nt) * yt),
      (et[6] = mt * yt),
      (et[7] = (rt * lt - ct * nt) * yt),
      (et[8] = (ot * nt - rt * st) * yt),
      this
    );
  }
  transpose() {
    let et;
    const nt = this.elements;
    return (
      (et = nt[1]),
      (nt[1] = nt[3]),
      (nt[3] = et),
      (et = nt[2]),
      (nt[2] = nt[6]),
      (nt[6] = et),
      (et = nt[5]),
      (nt[5] = nt[7]),
      (nt[7] = et),
      this
    );
  }
  getNormalMatrix(et) {
    return this.setFromMatrix4(et).invert().transpose();
  }
  transposeIntoArray(et) {
    const nt = this.elements;
    return (
      (et[0] = nt[0]),
      (et[1] = nt[3]),
      (et[2] = nt[6]),
      (et[3] = nt[1]),
      (et[4] = nt[4]),
      (et[5] = nt[7]),
      (et[6] = nt[2]),
      (et[7] = nt[5]),
      (et[8] = nt[8]),
      this
    );
  }
  setUvTransform(et, nt, rt, it, st, ot, at) {
    const lt = Math.cos(st),
      ct = Math.sin(st);
    return (
      this.set(
        rt * lt,
        rt * ct,
        -rt * (lt * ot + ct * at) + ot + et,
        -it * ct,
        it * lt,
        -it * (-ct * ot + lt * at) + at + nt,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(et, nt) {
    return this.premultiply(_m3.makeScale(et, nt)), this;
  }
  rotate(et) {
    return this.premultiply(_m3.makeRotation(-et)), this;
  }
  translate(et, nt) {
    return this.premultiply(_m3.makeTranslation(et, nt)), this;
  }
  makeTranslation(et, nt) {
    return (
      et.isVector2
        ? this.set(1, 0, et.x, 0, 1, et.y, 0, 0, 1)
        : this.set(1, 0, et, 0, 1, nt, 0, 0, 1),
      this
    );
  }
  makeRotation(et) {
    const nt = Math.cos(et),
      rt = Math.sin(et);
    return this.set(nt, -rt, 0, rt, nt, 0, 0, 0, 1), this;
  }
  makeScale(et, nt) {
    return this.set(et, 0, 0, 0, nt, 0, 0, 0, 1), this;
  }
  equals(et) {
    const nt = this.elements,
      rt = et.elements;
    for (let it = 0; it < 9; it++) if (nt[it] !== rt[it]) return !1;
    return !0;
  }
  fromArray(et, nt = 0) {
    for (let rt = 0; rt < 9; rt++) this.elements[rt] = et[rt + nt];
    return this;
  }
  toArray(et = [], nt = 0) {
    const rt = this.elements;
    return (
      (et[nt] = rt[0]),
      (et[nt + 1] = rt[1]),
      (et[nt + 2] = rt[2]),
      (et[nt + 3] = rt[3]),
      (et[nt + 4] = rt[4]),
      (et[nt + 5] = rt[5]),
      (et[nt + 6] = rt[6]),
      (et[nt + 7] = rt[7]),
      (et[nt + 8] = rt[8]),
      et
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = new Matrix3();
function arrayNeedsUint32(tt) {
  for (let et = tt.length - 1; et >= 0; --et) if (tt[et] >= 65535) return !0;
  return !1;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function getTypedArray(tt, et) {
  return new TYPED_ARRAYS[tt](et);
}
function createElementNS(tt) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", tt);
}
function createCanvasElement() {
  const tt = createElementNS("canvas");
  return (tt.style.display = "block"), tt;
}
const _cache = {};
function warnOnce(tt) {
  tt in _cache || ((_cache[tt] = !0), console.warn(tt));
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  COLOR_SPACES = {
    [LinearSRGBColorSpace]: {
      transfer: LinearTransfer,
      primaries: Rec709Primaries,
      toReference: (tt) => tt,
      fromReference: (tt) => tt,
    },
    [SRGBColorSpace]: {
      transfer: SRGBTransfer,
      primaries: Rec709Primaries,
      toReference: (tt) => tt.convertSRGBToLinear(),
      fromReference: (tt) => tt.convertLinearToSRGB(),
    },
    [LinearDisplayP3ColorSpace]: {
      transfer: LinearTransfer,
      primaries: P3Primaries,
      toReference: (tt) => tt.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (tt) => tt.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3),
    },
    [DisplayP3ColorSpace]: {
      transfer: SRGBTransfer,
      primaries: P3Primaries,
      toReference: (tt) =>
        tt.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (tt) =>
        tt.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB(),
    },
  },
  SUPPORTED_WORKING_COLOR_SPACES = new Set([
    LinearSRGBColorSpace,
    LinearDisplayP3ColorSpace,
  ]),
  ColorManagement = {
    enabled: !0,
    _workingColorSpace: LinearSRGBColorSpace,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(tt) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !tt);
    },
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(tt) {
      if (!SUPPORTED_WORKING_COLOR_SPACES.has(tt))
        throw new Error(`Unsupported working color space, "${tt}".`);
      this._workingColorSpace = tt;
    },
    convert: function (tt, et, nt) {
      if (this.enabled === !1 || et === nt || !et || !nt) return tt;
      const rt = COLOR_SPACES[et].toReference,
        it = COLOR_SPACES[nt].fromReference;
      return it(rt(tt));
    },
    fromWorkingColorSpace: function (tt, et) {
      return this.convert(tt, this._workingColorSpace, et);
    },
    toWorkingColorSpace: function (tt, et) {
      return this.convert(tt, et, this._workingColorSpace);
    },
    getPrimaries: function (tt) {
      return COLOR_SPACES[tt].primaries;
    },
    getTransfer: function (tt) {
      return tt === NoColorSpace ? LinearTransfer : COLOR_SPACES[tt].transfer;
    },
  };
function SRGBToLinear(tt) {
  return tt < 0.04045
    ? tt * 0.0773993808
    : Math.pow(tt * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(tt) {
  return tt < 0.0031308 ? tt * 12.92 : 1.055 * Math.pow(tt, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(et) {
    if (/^data:/i.test(et.src) || typeof HTMLCanvasElement > "u") return et.src;
    let nt;
    if (et instanceof HTMLCanvasElement) nt = et;
    else {
      _canvas === void 0 && (_canvas = createElementNS("canvas")),
        (_canvas.width = et.width),
        (_canvas.height = et.height);
      const rt = _canvas.getContext("2d");
      et instanceof ImageData
        ? rt.putImageData(et, 0, 0)
        : rt.drawImage(et, 0, 0, et.width, et.height),
        (nt = _canvas);
    }
    return nt.width > 2048 || nt.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          et
        ),
        nt.toDataURL("image/jpeg", 0.6))
      : nt.toDataURL("image/png");
  }
  static sRGBToLinear(et) {
    if (
      (typeof HTMLImageElement < "u" && et instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && et instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && et instanceof ImageBitmap)
    ) {
      const nt = createElementNS("canvas");
      (nt.width = et.width), (nt.height = et.height);
      const rt = nt.getContext("2d");
      rt.drawImage(et, 0, 0, et.width, et.height);
      const it = rt.getImageData(0, 0, et.width, et.height),
        st = it.data;
      for (let ot = 0; ot < st.length; ot++)
        st[ot] = SRGBToLinear(st[ot] / 255) * 255;
      return rt.putImageData(it, 0, 0), nt;
    } else if (et.data) {
      const nt = et.data.slice(0);
      for (let rt = 0; rt < nt.length; rt++)
        nt instanceof Uint8Array || nt instanceof Uint8ClampedArray
          ? (nt[rt] = Math.floor(SRGBToLinear(nt[rt] / 255) * 255))
          : (nt[rt] = SRGBToLinear(nt[rt]));
      return { data: nt, width: et.width, height: et.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        et
      );
  }
}
let _sourceId = 0;
class Source {
  constructor(et = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: _sourceId++ }),
      (this.uuid = generateUUID$1()),
      (this.data = et),
      (this.version = 0);
  }
  set needsUpdate(et) {
    et === !0 && this.version++;
  }
  toJSON(et) {
    const nt = et === void 0 || typeof et == "string";
    if (!nt && et.images[this.uuid] !== void 0) return et.images[this.uuid];
    const rt = { uuid: this.uuid, url: "" },
      it = this.data;
    if (it !== null) {
      let st;
      if (Array.isArray(it)) {
        st = [];
        for (let ot = 0, at = it.length; ot < at; ot++)
          it[ot].isDataTexture
            ? st.push(serializeImage(it[ot].image))
            : st.push(serializeImage(it[ot]));
      } else st = serializeImage(it);
      rt.url = st;
    }
    return nt || (et.images[this.uuid] = rt), rt;
  }
}
function serializeImage(tt) {
  return (typeof HTMLImageElement < "u" && tt instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && tt instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && tt instanceof ImageBitmap)
    ? ImageUtils.getDataURL(tt)
    : tt.data
    ? {
        data: Array.from(tt.data),
        width: tt.width,
        height: tt.height,
        type: tt.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(
    et = Texture.DEFAULT_IMAGE,
    nt = Texture.DEFAULT_MAPPING,
    rt = ClampToEdgeWrapping,
    it = ClampToEdgeWrapping,
    st = LinearFilter,
    ot = LinearMipmapLinearFilter,
    at = RGBAFormat,
    lt = UnsignedByteType,
    ct = Texture.DEFAULT_ANISOTROPY,
    ut = NoColorSpace
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: _textureId++ }),
      (this.uuid = generateUUID$1()),
      (this.name = ""),
      (this.source = new Source(et)),
      (this.mipmaps = []),
      (this.mapping = nt),
      (this.channel = 0),
      (this.wrapS = rt),
      (this.wrapT = it),
      (this.magFilter = st),
      (this.minFilter = ot),
      (this.anisotropy = ct),
      (this.format = at),
      (this.internalFormat = null),
      (this.type = lt),
      (this.offset = new Vector2(0, 0)),
      (this.repeat = new Vector2(1, 1)),
      (this.center = new Vector2(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Matrix3()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof ut == "string"
        ? (this.colorSpace = ut)
        : (warnOnce(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace =
            ut === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(et = null) {
    this.source.data = et;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    return (
      (this.name = et.name),
      (this.source = et.source),
      (this.mipmaps = et.mipmaps.slice(0)),
      (this.mapping = et.mapping),
      (this.channel = et.channel),
      (this.wrapS = et.wrapS),
      (this.wrapT = et.wrapT),
      (this.magFilter = et.magFilter),
      (this.minFilter = et.minFilter),
      (this.anisotropy = et.anisotropy),
      (this.format = et.format),
      (this.internalFormat = et.internalFormat),
      (this.type = et.type),
      this.offset.copy(et.offset),
      this.repeat.copy(et.repeat),
      this.center.copy(et.center),
      (this.rotation = et.rotation),
      (this.matrixAutoUpdate = et.matrixAutoUpdate),
      this.matrix.copy(et.matrix),
      (this.generateMipmaps = et.generateMipmaps),
      (this.premultiplyAlpha = et.premultiplyAlpha),
      (this.flipY = et.flipY),
      (this.unpackAlignment = et.unpackAlignment),
      (this.colorSpace = et.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(et.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(et) {
    const nt = et === void 0 || typeof et == "string";
    if (!nt && et.textures[this.uuid] !== void 0) return et.textures[this.uuid];
    const rt = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(et).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (rt.userData = this.userData),
      nt || (et.textures[this.uuid] = rt),
      rt
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(et) {
    if (this.mapping !== UVMapping) return et;
    if ((et.applyMatrix3(this.matrix), et.x < 0 || et.x > 1))
      switch (this.wrapS) {
        case RepeatWrapping:
          et.x = et.x - Math.floor(et.x);
          break;
        case ClampToEdgeWrapping:
          et.x = et.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(et.x) % 2) === 1
            ? (et.x = Math.ceil(et.x) - et.x)
            : (et.x = et.x - Math.floor(et.x));
          break;
      }
    if (et.y < 0 || et.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          et.y = et.y - Math.floor(et.y);
          break;
        case ClampToEdgeWrapping:
          et.y = et.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(et.y) % 2) === 1
            ? (et.y = Math.ceil(et.y) - et.y)
            : (et.y = et.y - Math.floor(et.y));
          break;
      }
    return this.flipY && (et.y = 1 - et.y), et;
  }
  set needsUpdate(et) {
    et === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      warnOnce(
        "THREE.Texture: Property .encoding has been replaced by .colorSpace."
      ),
      this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    );
  }
  set encoding(et) {
    warnOnce(
      "THREE.Texture: Property .encoding has been replaced by .colorSpace."
    ),
      (this.colorSpace = et === sRGBEncoding ? SRGBColorSpace : NoColorSpace);
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(et = 0, nt = 0, rt = 0, it = 1) {
    (Vector4.prototype.isVector4 = !0),
      (this.x = et),
      (this.y = nt),
      (this.z = rt),
      (this.w = it);
  }
  get width() {
    return this.z;
  }
  set width(et) {
    this.z = et;
  }
  get height() {
    return this.w;
  }
  set height(et) {
    this.w = et;
  }
  set(et, nt, rt, it) {
    return (this.x = et), (this.y = nt), (this.z = rt), (this.w = it), this;
  }
  setScalar(et) {
    return (this.x = et), (this.y = et), (this.z = et), (this.w = et), this;
  }
  setX(et) {
    return (this.x = et), this;
  }
  setY(et) {
    return (this.y = et), this;
  }
  setZ(et) {
    return (this.z = et), this;
  }
  setW(et) {
    return (this.w = et), this;
  }
  setComponent(et, nt) {
    switch (et) {
      case 0:
        this.x = nt;
        break;
      case 1:
        this.y = nt;
        break;
      case 2:
        this.z = nt;
        break;
      case 3:
        this.w = nt;
        break;
      default:
        throw new Error("index is out of range: " + et);
    }
    return this;
  }
  getComponent(et) {
    switch (et) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + et);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(et) {
    return (
      (this.x = et.x),
      (this.y = et.y),
      (this.z = et.z),
      (this.w = et.w !== void 0 ? et.w : 1),
      this
    );
  }
  add(et) {
    return (
      (this.x += et.x),
      (this.y += et.y),
      (this.z += et.z),
      (this.w += et.w),
      this
    );
  }
  addScalar(et) {
    return (this.x += et), (this.y += et), (this.z += et), (this.w += et), this;
  }
  addVectors(et, nt) {
    return (
      (this.x = et.x + nt.x),
      (this.y = et.y + nt.y),
      (this.z = et.z + nt.z),
      (this.w = et.w + nt.w),
      this
    );
  }
  addScaledVector(et, nt) {
    return (
      (this.x += et.x * nt),
      (this.y += et.y * nt),
      (this.z += et.z * nt),
      (this.w += et.w * nt),
      this
    );
  }
  sub(et) {
    return (
      (this.x -= et.x),
      (this.y -= et.y),
      (this.z -= et.z),
      (this.w -= et.w),
      this
    );
  }
  subScalar(et) {
    return (this.x -= et), (this.y -= et), (this.z -= et), (this.w -= et), this;
  }
  subVectors(et, nt) {
    return (
      (this.x = et.x - nt.x),
      (this.y = et.y - nt.y),
      (this.z = et.z - nt.z),
      (this.w = et.w - nt.w),
      this
    );
  }
  multiply(et) {
    return (
      (this.x *= et.x),
      (this.y *= et.y),
      (this.z *= et.z),
      (this.w *= et.w),
      this
    );
  }
  multiplyScalar(et) {
    return (this.x *= et), (this.y *= et), (this.z *= et), (this.w *= et), this;
  }
  applyMatrix4(et) {
    const nt = this.x,
      rt = this.y,
      it = this.z,
      st = this.w,
      ot = et.elements;
    return (
      (this.x = ot[0] * nt + ot[4] * rt + ot[8] * it + ot[12] * st),
      (this.y = ot[1] * nt + ot[5] * rt + ot[9] * it + ot[13] * st),
      (this.z = ot[2] * nt + ot[6] * rt + ot[10] * it + ot[14] * st),
      (this.w = ot[3] * nt + ot[7] * rt + ot[11] * it + ot[15] * st),
      this
    );
  }
  divideScalar(et) {
    return this.multiplyScalar(1 / et);
  }
  setAxisAngleFromQuaternion(et) {
    this.w = 2 * Math.acos(et.w);
    const nt = Math.sqrt(1 - et.w * et.w);
    return (
      nt < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = et.x / nt), (this.y = et.y / nt), (this.z = et.z / nt)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(et) {
    let nt, rt, it, st;
    const lt = et.elements,
      ct = lt[0],
      ut = lt[4],
      ft = lt[8],
      ht = lt[1],
      mt = lt[5],
      vt = lt[9],
      yt = lt[2],
      Et = lt[6],
      pt = lt[10];
    if (
      Math.abs(ut - ht) < 0.01 &&
      Math.abs(ft - yt) < 0.01 &&
      Math.abs(vt - Et) < 0.01
    ) {
      if (
        Math.abs(ut + ht) < 0.1 &&
        Math.abs(ft + yt) < 0.1 &&
        Math.abs(vt + Et) < 0.1 &&
        Math.abs(ct + mt + pt - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      nt = Math.PI;
      const St = (ct + 1) / 2,
        At = (mt + 1) / 2,
        Ct = (pt + 1) / 2,
        Mt = (ut + ht) / 4,
        wt = (ft + yt) / 4,
        Bt = (vt + Et) / 4;
      return (
        St > At && St > Ct
          ? St < 0.01
            ? ((rt = 0), (it = 0.707106781), (st = 0.707106781))
            : ((rt = Math.sqrt(St)), (it = Mt / rt), (st = wt / rt))
          : At > Ct
          ? At < 0.01
            ? ((rt = 0.707106781), (it = 0), (st = 0.707106781))
            : ((it = Math.sqrt(At)), (rt = Mt / it), (st = Bt / it))
          : Ct < 0.01
          ? ((rt = 0.707106781), (it = 0.707106781), (st = 0))
          : ((st = Math.sqrt(Ct)), (rt = wt / st), (it = Bt / st)),
        this.set(rt, it, st, nt),
        this
      );
    }
    let xt = Math.sqrt(
      (Et - vt) * (Et - vt) + (ft - yt) * (ft - yt) + (ht - ut) * (ht - ut)
    );
    return (
      Math.abs(xt) < 0.001 && (xt = 1),
      (this.x = (Et - vt) / xt),
      (this.y = (ft - yt) / xt),
      (this.z = (ht - ut) / xt),
      (this.w = Math.acos((ct + mt + pt - 1) / 2)),
      this
    );
  }
  min(et) {
    return (
      (this.x = Math.min(this.x, et.x)),
      (this.y = Math.min(this.y, et.y)),
      (this.z = Math.min(this.z, et.z)),
      (this.w = Math.min(this.w, et.w)),
      this
    );
  }
  max(et) {
    return (
      (this.x = Math.max(this.x, et.x)),
      (this.y = Math.max(this.y, et.y)),
      (this.z = Math.max(this.z, et.z)),
      (this.w = Math.max(this.w, et.w)),
      this
    );
  }
  clamp(et, nt) {
    return (
      (this.x = Math.max(et.x, Math.min(nt.x, this.x))),
      (this.y = Math.max(et.y, Math.min(nt.y, this.y))),
      (this.z = Math.max(et.z, Math.min(nt.z, this.z))),
      (this.w = Math.max(et.w, Math.min(nt.w, this.w))),
      this
    );
  }
  clampScalar(et, nt) {
    return (
      (this.x = Math.max(et, Math.min(nt, this.x))),
      (this.y = Math.max(et, Math.min(nt, this.y))),
      (this.z = Math.max(et, Math.min(nt, this.z))),
      (this.w = Math.max(et, Math.min(nt, this.w))),
      this
    );
  }
  clampLength(et, nt) {
    const rt = this.length();
    return this.divideScalar(rt || 1).multiplyScalar(
      Math.max(et, Math.min(nt, rt))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(et) {
    return this.x * et.x + this.y * et.y + this.z * et.z + this.w * et.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(et) {
    return this.normalize().multiplyScalar(et);
  }
  lerp(et, nt) {
    return (
      (this.x += (et.x - this.x) * nt),
      (this.y += (et.y - this.y) * nt),
      (this.z += (et.z - this.z) * nt),
      (this.w += (et.w - this.w) * nt),
      this
    );
  }
  lerpVectors(et, nt, rt) {
    return (
      (this.x = et.x + (nt.x - et.x) * rt),
      (this.y = et.y + (nt.y - et.y) * rt),
      (this.z = et.z + (nt.z - et.z) * rt),
      (this.w = et.w + (nt.w - et.w) * rt),
      this
    );
  }
  equals(et) {
    return (
      et.x === this.x && et.y === this.y && et.z === this.z && et.w === this.w
    );
  }
  fromArray(et, nt = 0) {
    return (
      (this.x = et[nt]),
      (this.y = et[nt + 1]),
      (this.z = et[nt + 2]),
      (this.w = et[nt + 3]),
      this
    );
  }
  toArray(et = [], nt = 0) {
    return (
      (et[nt] = this.x),
      (et[nt + 1] = this.y),
      (et[nt + 2] = this.z),
      (et[nt + 3] = this.w),
      et
    );
  }
  fromBufferAttribute(et, nt) {
    return (
      (this.x = et.getX(nt)),
      (this.y = et.getY(nt)),
      (this.z = et.getZ(nt)),
      (this.w = et.getW(nt)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(et = 1, nt = 1, rt = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = et),
      (this.height = nt),
      (this.depth = 1),
      (this.scissor = new Vector4(0, 0, et, nt)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, et, nt));
    const it = { width: et, height: nt, depth: 1 };
    rt.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (rt.colorSpace =
        rt.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (rt = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: LinearFilter,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        rt
      )),
      (this.texture = new Texture(
        it,
        rt.mapping,
        rt.wrapS,
        rt.wrapT,
        rt.magFilter,
        rt.minFilter,
        rt.format,
        rt.type,
        rt.anisotropy,
        rt.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = rt.generateMipmaps),
      (this.texture.internalFormat = rt.internalFormat),
      (this.depthBuffer = rt.depthBuffer),
      (this.stencilBuffer = rt.stencilBuffer),
      (this.depthTexture = rt.depthTexture),
      (this.samples = rt.samples);
  }
  setSize(et, nt, rt = 1) {
    (this.width !== et || this.height !== nt || this.depth !== rt) &&
      ((this.width = et),
      (this.height = nt),
      (this.depth = rt),
      (this.texture.image.width = et),
      (this.texture.image.height = nt),
      (this.texture.image.depth = rt),
      this.dispose()),
      this.viewport.set(0, 0, et, nt),
      this.scissor.set(0, 0, et, nt);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    (this.width = et.width),
      (this.height = et.height),
      (this.depth = et.depth),
      this.scissor.copy(et.scissor),
      (this.scissorTest = et.scissorTest),
      this.viewport.copy(et.viewport),
      (this.texture = et.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const nt = Object.assign({}, et.texture.image);
    return (
      (this.texture.source = new Source(nt)),
      (this.depthBuffer = et.depthBuffer),
      (this.stencilBuffer = et.stencilBuffer),
      et.depthTexture !== null && (this.depthTexture = et.depthTexture.clone()),
      (this.samples = et.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(et = 1, nt = 1, rt = {}) {
    super(et, nt, rt), (this.isWebGLRenderTarget = !0);
  }
}
class DataArrayTexture extends Texture {
  constructor(et = null, nt = 1, rt = 1, it = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: et, width: nt, height: rt, depth: it }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(et = 1, nt = 1, rt = 1) {
    super(et, nt),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = rt),
      (this.texture = new DataArrayTexture(null, et, nt, rt)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Data3DTexture extends Texture {
  constructor(et = null, nt = 1, rt = 1, it = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: et, width: nt, height: rt, depth: it }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(et = 1, nt = 1, rt = 1) {
    super(et, nt),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = rt),
      (this.texture = new Data3DTexture(null, et, nt, rt)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(et = 1, nt = 1, rt = 1, it = {}) {
    super(et, nt, it), (this.isWebGLMultipleRenderTargets = !0);
    const st = this.texture;
    this.texture = [];
    for (let ot = 0; ot < rt; ot++)
      (this.texture[ot] = st.clone()),
        (this.texture[ot].isRenderTargetTexture = !0);
  }
  setSize(et, nt, rt = 1) {
    if (this.width !== et || this.height !== nt || this.depth !== rt) {
      (this.width = et), (this.height = nt), (this.depth = rt);
      for (let it = 0, st = this.texture.length; it < st; it++)
        (this.texture[it].image.width = et),
          (this.texture[it].image.height = nt),
          (this.texture[it].image.depth = rt);
      this.dispose();
    }
    this.viewport.set(0, 0, et, nt), this.scissor.set(0, 0, et, nt);
  }
  copy(et) {
    this.dispose(),
      (this.width = et.width),
      (this.height = et.height),
      (this.depth = et.depth),
      this.scissor.copy(et.scissor),
      (this.scissorTest = et.scissorTest),
      this.viewport.copy(et.viewport),
      (this.depthBuffer = et.depthBuffer),
      (this.stencilBuffer = et.stencilBuffer),
      et.depthTexture !== null && (this.depthTexture = et.depthTexture.clone()),
      (this.texture.length = 0);
    for (let nt = 0, rt = et.texture.length; nt < rt; nt++)
      (this.texture[nt] = et.texture[nt].clone()),
        (this.texture[nt].isRenderTargetTexture = !0);
    return this;
  }
}
class Quaternion {
  constructor(et = 0, nt = 0, rt = 0, it = 1) {
    (this.isQuaternion = !0),
      (this._x = et),
      (this._y = nt),
      (this._z = rt),
      (this._w = it);
  }
  static slerpFlat(et, nt, rt, it, st, ot, at) {
    let lt = rt[it + 0],
      ct = rt[it + 1],
      ut = rt[it + 2],
      ft = rt[it + 3];
    const ht = st[ot + 0],
      mt = st[ot + 1],
      vt = st[ot + 2],
      yt = st[ot + 3];
    if (at === 0) {
      (et[nt + 0] = lt),
        (et[nt + 1] = ct),
        (et[nt + 2] = ut),
        (et[nt + 3] = ft);
      return;
    }
    if (at === 1) {
      (et[nt + 0] = ht),
        (et[nt + 1] = mt),
        (et[nt + 2] = vt),
        (et[nt + 3] = yt);
      return;
    }
    if (ft !== yt || lt !== ht || ct !== mt || ut !== vt) {
      let Et = 1 - at;
      const pt = lt * ht + ct * mt + ut * vt + ft * yt,
        xt = pt >= 0 ? 1 : -1,
        St = 1 - pt * pt;
      if (St > Number.EPSILON) {
        const Ct = Math.sqrt(St),
          Mt = Math.atan2(Ct, pt * xt);
        (Et = Math.sin(Et * Mt) / Ct), (at = Math.sin(at * Mt) / Ct);
      }
      const At = at * xt;
      if (
        ((lt = lt * Et + ht * At),
        (ct = ct * Et + mt * At),
        (ut = ut * Et + vt * At),
        (ft = ft * Et + yt * At),
        Et === 1 - at)
      ) {
        const Ct = 1 / Math.sqrt(lt * lt + ct * ct + ut * ut + ft * ft);
        (lt *= Ct), (ct *= Ct), (ut *= Ct), (ft *= Ct);
      }
    }
    (et[nt] = lt), (et[nt + 1] = ct), (et[nt + 2] = ut), (et[nt + 3] = ft);
  }
  static multiplyQuaternionsFlat(et, nt, rt, it, st, ot) {
    const at = rt[it],
      lt = rt[it + 1],
      ct = rt[it + 2],
      ut = rt[it + 3],
      ft = st[ot],
      ht = st[ot + 1],
      mt = st[ot + 2],
      vt = st[ot + 3];
    return (
      (et[nt] = at * vt + ut * ft + lt * mt - ct * ht),
      (et[nt + 1] = lt * vt + ut * ht + ct * ft - at * mt),
      (et[nt + 2] = ct * vt + ut * mt + at * ht - lt * ft),
      (et[nt + 3] = ut * vt - at * ft - lt * ht - ct * mt),
      et
    );
  }
  get x() {
    return this._x;
  }
  set x(et) {
    (this._x = et), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(et) {
    (this._y = et), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(et) {
    (this._z = et), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(et) {
    (this._w = et), this._onChangeCallback();
  }
  set(et, nt, rt, it) {
    return (
      (this._x = et),
      (this._y = nt),
      (this._z = rt),
      (this._w = it),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(et) {
    return (
      (this._x = et.x),
      (this._y = et.y),
      (this._z = et.z),
      (this._w = et.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(et, nt) {
    const rt = et._x,
      it = et._y,
      st = et._z,
      ot = et._order,
      at = Math.cos,
      lt = Math.sin,
      ct = at(rt / 2),
      ut = at(it / 2),
      ft = at(st / 2),
      ht = lt(rt / 2),
      mt = lt(it / 2),
      vt = lt(st / 2);
    switch (ot) {
      case "XYZ":
        (this._x = ht * ut * ft + ct * mt * vt),
          (this._y = ct * mt * ft - ht * ut * vt),
          (this._z = ct * ut * vt + ht * mt * ft),
          (this._w = ct * ut * ft - ht * mt * vt);
        break;
      case "YXZ":
        (this._x = ht * ut * ft + ct * mt * vt),
          (this._y = ct * mt * ft - ht * ut * vt),
          (this._z = ct * ut * vt - ht * mt * ft),
          (this._w = ct * ut * ft + ht * mt * vt);
        break;
      case "ZXY":
        (this._x = ht * ut * ft - ct * mt * vt),
          (this._y = ct * mt * ft + ht * ut * vt),
          (this._z = ct * ut * vt + ht * mt * ft),
          (this._w = ct * ut * ft - ht * mt * vt);
        break;
      case "ZYX":
        (this._x = ht * ut * ft - ct * mt * vt),
          (this._y = ct * mt * ft + ht * ut * vt),
          (this._z = ct * ut * vt - ht * mt * ft),
          (this._w = ct * ut * ft + ht * mt * vt);
        break;
      case "YZX":
        (this._x = ht * ut * ft + ct * mt * vt),
          (this._y = ct * mt * ft + ht * ut * vt),
          (this._z = ct * ut * vt - ht * mt * ft),
          (this._w = ct * ut * ft - ht * mt * vt);
        break;
      case "XZY":
        (this._x = ht * ut * ft - ct * mt * vt),
          (this._y = ct * mt * ft - ht * ut * vt),
          (this._z = ct * ut * vt + ht * mt * ft),
          (this._w = ct * ut * ft + ht * mt * vt);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            ot
        );
    }
    return nt !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(et, nt) {
    const rt = nt / 2,
      it = Math.sin(rt);
    return (
      (this._x = et.x * it),
      (this._y = et.y * it),
      (this._z = et.z * it),
      (this._w = Math.cos(rt)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(et) {
    const nt = et.elements,
      rt = nt[0],
      it = nt[4],
      st = nt[8],
      ot = nt[1],
      at = nt[5],
      lt = nt[9],
      ct = nt[2],
      ut = nt[6],
      ft = nt[10],
      ht = rt + at + ft;
    if (ht > 0) {
      const mt = 0.5 / Math.sqrt(ht + 1);
      (this._w = 0.25 / mt),
        (this._x = (ut - lt) * mt),
        (this._y = (st - ct) * mt),
        (this._z = (ot - it) * mt);
    } else if (rt > at && rt > ft) {
      const mt = 2 * Math.sqrt(1 + rt - at - ft);
      (this._w = (ut - lt) / mt),
        (this._x = 0.25 * mt),
        (this._y = (it + ot) / mt),
        (this._z = (st + ct) / mt);
    } else if (at > ft) {
      const mt = 2 * Math.sqrt(1 + at - rt - ft);
      (this._w = (st - ct) / mt),
        (this._x = (it + ot) / mt),
        (this._y = 0.25 * mt),
        (this._z = (lt + ut) / mt);
    } else {
      const mt = 2 * Math.sqrt(1 + ft - rt - at);
      (this._w = (ot - it) / mt),
        (this._x = (st + ct) / mt),
        (this._y = (lt + ut) / mt),
        (this._z = 0.25 * mt);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(et, nt) {
    let rt = et.dot(nt) + 1;
    return (
      rt < Number.EPSILON
        ? ((rt = 0),
          Math.abs(et.x) > Math.abs(et.z)
            ? ((this._x = -et.y),
              (this._y = et.x),
              (this._z = 0),
              (this._w = rt))
            : ((this._x = 0),
              (this._y = -et.z),
              (this._z = et.y),
              (this._w = rt)))
        : ((this._x = et.y * nt.z - et.z * nt.y),
          (this._y = et.z * nt.x - et.x * nt.z),
          (this._z = et.x * nt.y - et.y * nt.x),
          (this._w = rt)),
      this.normalize()
    );
  }
  angleTo(et) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(et), -1, 1)));
  }
  rotateTowards(et, nt) {
    const rt = this.angleTo(et);
    if (rt === 0) return this;
    const it = Math.min(1, nt / rt);
    return this.slerp(et, it), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(et) {
    return (
      this._x * et._x + this._y * et._y + this._z * et._z + this._w * et._w
    );
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let et = this.length();
    return (
      et === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((et = 1 / et),
          (this._x = this._x * et),
          (this._y = this._y * et),
          (this._z = this._z * et),
          (this._w = this._w * et)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(et) {
    return this.multiplyQuaternions(this, et);
  }
  premultiply(et) {
    return this.multiplyQuaternions(et, this);
  }
  multiplyQuaternions(et, nt) {
    const rt = et._x,
      it = et._y,
      st = et._z,
      ot = et._w,
      at = nt._x,
      lt = nt._y,
      ct = nt._z,
      ut = nt._w;
    return (
      (this._x = rt * ut + ot * at + it * ct - st * lt),
      (this._y = it * ut + ot * lt + st * at - rt * ct),
      (this._z = st * ut + ot * ct + rt * lt - it * at),
      (this._w = ot * ut - rt * at - it * lt - st * ct),
      this._onChangeCallback(),
      this
    );
  }
  slerp(et, nt) {
    if (nt === 0) return this;
    if (nt === 1) return this.copy(et);
    const rt = this._x,
      it = this._y,
      st = this._z,
      ot = this._w;
    let at = ot * et._w + rt * et._x + it * et._y + st * et._z;
    if (
      (at < 0
        ? ((this._w = -et._w),
          (this._x = -et._x),
          (this._y = -et._y),
          (this._z = -et._z),
          (at = -at))
        : this.copy(et),
      at >= 1)
    )
      return (
        (this._w = ot), (this._x = rt), (this._y = it), (this._z = st), this
      );
    const lt = 1 - at * at;
    if (lt <= Number.EPSILON) {
      const mt = 1 - nt;
      return (
        (this._w = mt * ot + nt * this._w),
        (this._x = mt * rt + nt * this._x),
        (this._y = mt * it + nt * this._y),
        (this._z = mt * st + nt * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const ct = Math.sqrt(lt),
      ut = Math.atan2(ct, at),
      ft = Math.sin((1 - nt) * ut) / ct,
      ht = Math.sin(nt * ut) / ct;
    return (
      (this._w = ot * ft + this._w * ht),
      (this._x = rt * ft + this._x * ht),
      (this._y = it * ft + this._y * ht),
      (this._z = st * ft + this._z * ht),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(et, nt, rt) {
    return this.copy(et).slerp(nt, rt);
  }
  random() {
    const et = Math.random(),
      nt = Math.sqrt(1 - et),
      rt = Math.sqrt(et),
      it = 2 * Math.PI * Math.random(),
      st = 2 * Math.PI * Math.random();
    return this.set(
      nt * Math.cos(it),
      rt * Math.sin(st),
      rt * Math.cos(st),
      nt * Math.sin(it)
    );
  }
  equals(et) {
    return (
      et._x === this._x &&
      et._y === this._y &&
      et._z === this._z &&
      et._w === this._w
    );
  }
  fromArray(et, nt = 0) {
    return (
      (this._x = et[nt]),
      (this._y = et[nt + 1]),
      (this._z = et[nt + 2]),
      (this._w = et[nt + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(et = [], nt = 0) {
    return (
      (et[nt] = this._x),
      (et[nt + 1] = this._y),
      (et[nt + 2] = this._z),
      (et[nt + 3] = this._w),
      et
    );
  }
  fromBufferAttribute(et, nt) {
    return (
      (this._x = et.getX(nt)),
      (this._y = et.getY(nt)),
      (this._z = et.getZ(nt)),
      (this._w = et.getW(nt)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(et) {
    return (this._onChangeCallback = et), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Vector3 {
  constructor(et = 0, nt = 0, rt = 0) {
    (Vector3.prototype.isVector3 = !0),
      (this.x = et),
      (this.y = nt),
      (this.z = rt);
  }
  set(et, nt, rt) {
    return (
      rt === void 0 && (rt = this.z),
      (this.x = et),
      (this.y = nt),
      (this.z = rt),
      this
    );
  }
  setScalar(et) {
    return (this.x = et), (this.y = et), (this.z = et), this;
  }
  setX(et) {
    return (this.x = et), this;
  }
  setY(et) {
    return (this.y = et), this;
  }
  setZ(et) {
    return (this.z = et), this;
  }
  setComponent(et, nt) {
    switch (et) {
      case 0:
        this.x = nt;
        break;
      case 1:
        this.y = nt;
        break;
      case 2:
        this.z = nt;
        break;
      default:
        throw new Error("index is out of range: " + et);
    }
    return this;
  }
  getComponent(et) {
    switch (et) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + et);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(et) {
    return (this.x = et.x), (this.y = et.y), (this.z = et.z), this;
  }
  add(et) {
    return (this.x += et.x), (this.y += et.y), (this.z += et.z), this;
  }
  addScalar(et) {
    return (this.x += et), (this.y += et), (this.z += et), this;
  }
  addVectors(et, nt) {
    return (
      (this.x = et.x + nt.x),
      (this.y = et.y + nt.y),
      (this.z = et.z + nt.z),
      this
    );
  }
  addScaledVector(et, nt) {
    return (
      (this.x += et.x * nt), (this.y += et.y * nt), (this.z += et.z * nt), this
    );
  }
  sub(et) {
    return (this.x -= et.x), (this.y -= et.y), (this.z -= et.z), this;
  }
  subScalar(et) {
    return (this.x -= et), (this.y -= et), (this.z -= et), this;
  }
  subVectors(et, nt) {
    return (
      (this.x = et.x - nt.x),
      (this.y = et.y - nt.y),
      (this.z = et.z - nt.z),
      this
    );
  }
  multiply(et) {
    return (this.x *= et.x), (this.y *= et.y), (this.z *= et.z), this;
  }
  multiplyScalar(et) {
    return (this.x *= et), (this.y *= et), (this.z *= et), this;
  }
  multiplyVectors(et, nt) {
    return (
      (this.x = et.x * nt.x),
      (this.y = et.y * nt.y),
      (this.z = et.z * nt.z),
      this
    );
  }
  applyEuler(et) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(et));
  }
  applyAxisAngle(et, nt) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(et, nt));
  }
  applyMatrix3(et) {
    const nt = this.x,
      rt = this.y,
      it = this.z,
      st = et.elements;
    return (
      (this.x = st[0] * nt + st[3] * rt + st[6] * it),
      (this.y = st[1] * nt + st[4] * rt + st[7] * it),
      (this.z = st[2] * nt + st[5] * rt + st[8] * it),
      this
    );
  }
  applyNormalMatrix(et) {
    return this.applyMatrix3(et).normalize();
  }
  applyMatrix4(et) {
    const nt = this.x,
      rt = this.y,
      it = this.z,
      st = et.elements,
      ot = 1 / (st[3] * nt + st[7] * rt + st[11] * it + st[15]);
    return (
      (this.x = (st[0] * nt + st[4] * rt + st[8] * it + st[12]) * ot),
      (this.y = (st[1] * nt + st[5] * rt + st[9] * it + st[13]) * ot),
      (this.z = (st[2] * nt + st[6] * rt + st[10] * it + st[14]) * ot),
      this
    );
  }
  applyQuaternion(et) {
    const nt = this.x,
      rt = this.y,
      it = this.z,
      st = et.x,
      ot = et.y,
      at = et.z,
      lt = et.w,
      ct = lt * nt + ot * it - at * rt,
      ut = lt * rt + at * nt - st * it,
      ft = lt * it + st * rt - ot * nt,
      ht = -st * nt - ot * rt - at * it;
    return (
      (this.x = ct * lt + ht * -st + ut * -at - ft * -ot),
      (this.y = ut * lt + ht * -ot + ft * -st - ct * -at),
      (this.z = ft * lt + ht * -at + ct * -ot - ut * -st),
      this
    );
  }
  project(et) {
    return this.applyMatrix4(et.matrixWorldInverse).applyMatrix4(
      et.projectionMatrix
    );
  }
  unproject(et) {
    return this.applyMatrix4(et.projectionMatrixInverse).applyMatrix4(
      et.matrixWorld
    );
  }
  transformDirection(et) {
    const nt = this.x,
      rt = this.y,
      it = this.z,
      st = et.elements;
    return (
      (this.x = st[0] * nt + st[4] * rt + st[8] * it),
      (this.y = st[1] * nt + st[5] * rt + st[9] * it),
      (this.z = st[2] * nt + st[6] * rt + st[10] * it),
      this.normalize()
    );
  }
  divide(et) {
    return (this.x /= et.x), (this.y /= et.y), (this.z /= et.z), this;
  }
  divideScalar(et) {
    return this.multiplyScalar(1 / et);
  }
  min(et) {
    return (
      (this.x = Math.min(this.x, et.x)),
      (this.y = Math.min(this.y, et.y)),
      (this.z = Math.min(this.z, et.z)),
      this
    );
  }
  max(et) {
    return (
      (this.x = Math.max(this.x, et.x)),
      (this.y = Math.max(this.y, et.y)),
      (this.z = Math.max(this.z, et.z)),
      this
    );
  }
  clamp(et, nt) {
    return (
      (this.x = Math.max(et.x, Math.min(nt.x, this.x))),
      (this.y = Math.max(et.y, Math.min(nt.y, this.y))),
      (this.z = Math.max(et.z, Math.min(nt.z, this.z))),
      this
    );
  }
  clampScalar(et, nt) {
    return (
      (this.x = Math.max(et, Math.min(nt, this.x))),
      (this.y = Math.max(et, Math.min(nt, this.y))),
      (this.z = Math.max(et, Math.min(nt, this.z))),
      this
    );
  }
  clampLength(et, nt) {
    const rt = this.length();
    return this.divideScalar(rt || 1).multiplyScalar(
      Math.max(et, Math.min(nt, rt))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(et) {
    return this.x * et.x + this.y * et.y + this.z * et.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(et) {
    return this.normalize().multiplyScalar(et);
  }
  lerp(et, nt) {
    return (
      (this.x += (et.x - this.x) * nt),
      (this.y += (et.y - this.y) * nt),
      (this.z += (et.z - this.z) * nt),
      this
    );
  }
  lerpVectors(et, nt, rt) {
    return (
      (this.x = et.x + (nt.x - et.x) * rt),
      (this.y = et.y + (nt.y - et.y) * rt),
      (this.z = et.z + (nt.z - et.z) * rt),
      this
    );
  }
  cross(et) {
    return this.crossVectors(this, et);
  }
  crossVectors(et, nt) {
    const rt = et.x,
      it = et.y,
      st = et.z,
      ot = nt.x,
      at = nt.y,
      lt = nt.z;
    return (
      (this.x = it * lt - st * at),
      (this.y = st * ot - rt * lt),
      (this.z = rt * at - it * ot),
      this
    );
  }
  projectOnVector(et) {
    const nt = et.lengthSq();
    if (nt === 0) return this.set(0, 0, 0);
    const rt = et.dot(this) / nt;
    return this.copy(et).multiplyScalar(rt);
  }
  projectOnPlane(et) {
    return _vector$b.copy(this).projectOnVector(et), this.sub(_vector$b);
  }
  reflect(et) {
    return this.sub(_vector$b.copy(et).multiplyScalar(2 * this.dot(et)));
  }
  angleTo(et) {
    const nt = Math.sqrt(this.lengthSq() * et.lengthSq());
    if (nt === 0) return Math.PI / 2;
    const rt = this.dot(et) / nt;
    return Math.acos(clamp$1(rt, -1, 1));
  }
  distanceTo(et) {
    return Math.sqrt(this.distanceToSquared(et));
  }
  distanceToSquared(et) {
    const nt = this.x - et.x,
      rt = this.y - et.y,
      it = this.z - et.z;
    return nt * nt + rt * rt + it * it;
  }
  manhattanDistanceTo(et) {
    return (
      Math.abs(this.x - et.x) +
      Math.abs(this.y - et.y) +
      Math.abs(this.z - et.z)
    );
  }
  setFromSpherical(et) {
    return this.setFromSphericalCoords(et.radius, et.phi, et.theta);
  }
  setFromSphericalCoords(et, nt, rt) {
    const it = Math.sin(nt) * et;
    return (
      (this.x = it * Math.sin(rt)),
      (this.y = Math.cos(nt) * et),
      (this.z = it * Math.cos(rt)),
      this
    );
  }
  setFromCylindrical(et) {
    return this.setFromCylindricalCoords(et.radius, et.theta, et.y);
  }
  setFromCylindricalCoords(et, nt, rt) {
    return (
      (this.x = et * Math.sin(nt)),
      (this.y = rt),
      (this.z = et * Math.cos(nt)),
      this
    );
  }
  setFromMatrixPosition(et) {
    const nt = et.elements;
    return (this.x = nt[12]), (this.y = nt[13]), (this.z = nt[14]), this;
  }
  setFromMatrixScale(et) {
    const nt = this.setFromMatrixColumn(et, 0).length(),
      rt = this.setFromMatrixColumn(et, 1).length(),
      it = this.setFromMatrixColumn(et, 2).length();
    return (this.x = nt), (this.y = rt), (this.z = it), this;
  }
  setFromMatrixColumn(et, nt) {
    return this.fromArray(et.elements, nt * 4);
  }
  setFromMatrix3Column(et, nt) {
    return this.fromArray(et.elements, nt * 3);
  }
  setFromEuler(et) {
    return (this.x = et._x), (this.y = et._y), (this.z = et._z), this;
  }
  setFromColor(et) {
    return (this.x = et.r), (this.y = et.g), (this.z = et.b), this;
  }
  equals(et) {
    return et.x === this.x && et.y === this.y && et.z === this.z;
  }
  fromArray(et, nt = 0) {
    return (
      (this.x = et[nt]), (this.y = et[nt + 1]), (this.z = et[nt + 2]), this
    );
  }
  toArray(et = [], nt = 0) {
    return (et[nt] = this.x), (et[nt + 1] = this.y), (et[nt + 2] = this.z), et;
  }
  fromBufferAttribute(et, nt) {
    return (
      (this.x = et.getX(nt)),
      (this.y = et.getY(nt)),
      (this.z = et.getZ(nt)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const et = (Math.random() - 0.5) * 2,
      nt = Math.random() * Math.PI * 2,
      rt = Math.sqrt(1 - et ** 2);
    return (
      (this.x = rt * Math.cos(nt)),
      (this.y = rt * Math.sin(nt)),
      (this.z = et),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _vector$b = new Vector3(),
  _quaternion$4 = new Quaternion();
class Box3 {
  constructor(
    et = new Vector3(1 / 0, 1 / 0, 1 / 0),
    nt = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = et), (this.max = nt);
  }
  set(et, nt) {
    return this.min.copy(et), this.max.copy(nt), this;
  }
  setFromArray(et) {
    this.makeEmpty();
    for (let nt = 0, rt = et.length; nt < rt; nt += 3)
      this.expandByPoint(_vector$a.fromArray(et, nt));
    return this;
  }
  setFromBufferAttribute(et) {
    this.makeEmpty();
    for (let nt = 0, rt = et.count; nt < rt; nt++)
      this.expandByPoint(_vector$a.fromBufferAttribute(et, nt));
    return this;
  }
  setFromPoints(et) {
    this.makeEmpty();
    for (let nt = 0, rt = et.length; nt < rt; nt++) this.expandByPoint(et[nt]);
    return this;
  }
  setFromCenterAndSize(et, nt) {
    const rt = _vector$a.copy(nt).multiplyScalar(0.5);
    return this.min.copy(et).sub(rt), this.max.copy(et).add(rt), this;
  }
  setFromObject(et, nt = !1) {
    return this.makeEmpty(), this.expandByObject(et, nt);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    return this.min.copy(et.min), this.max.copy(et.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(et) {
    return this.isEmpty()
      ? et.set(0, 0, 0)
      : et.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(et) {
    return this.isEmpty() ? et.set(0, 0, 0) : et.subVectors(this.max, this.min);
  }
  expandByPoint(et) {
    return this.min.min(et), this.max.max(et), this;
  }
  expandByVector(et) {
    return this.min.sub(et), this.max.add(et), this;
  }
  expandByScalar(et) {
    return this.min.addScalar(-et), this.max.addScalar(et), this;
  }
  expandByObject(et, nt = !1) {
    if ((et.updateWorldMatrix(!1, !1), et.boundingBox !== void 0))
      et.boundingBox === null && et.computeBoundingBox(),
        _box$3.copy(et.boundingBox),
        _box$3.applyMatrix4(et.matrixWorld),
        this.union(_box$3);
    else {
      const it = et.geometry;
      if (it !== void 0)
        if (
          nt &&
          it.attributes !== void 0 &&
          it.attributes.position !== void 0
        ) {
          const st = it.attributes.position;
          for (let ot = 0, at = st.count; ot < at; ot++)
            _vector$a.fromBufferAttribute(st, ot).applyMatrix4(et.matrixWorld),
              this.expandByPoint(_vector$a);
        } else
          it.boundingBox === null && it.computeBoundingBox(),
            _box$3.copy(it.boundingBox),
            _box$3.applyMatrix4(et.matrixWorld),
            this.union(_box$3);
    }
    const rt = et.children;
    for (let it = 0, st = rt.length; it < st; it++)
      this.expandByObject(rt[it], nt);
    return this;
  }
  containsPoint(et) {
    return !(
      et.x < this.min.x ||
      et.x > this.max.x ||
      et.y < this.min.y ||
      et.y > this.max.y ||
      et.z < this.min.z ||
      et.z > this.max.z
    );
  }
  containsBox(et) {
    return (
      this.min.x <= et.min.x &&
      et.max.x <= this.max.x &&
      this.min.y <= et.min.y &&
      et.max.y <= this.max.y &&
      this.min.z <= et.min.z &&
      et.max.z <= this.max.z
    );
  }
  getParameter(et, nt) {
    return nt.set(
      (et.x - this.min.x) / (this.max.x - this.min.x),
      (et.y - this.min.y) / (this.max.y - this.min.y),
      (et.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(et) {
    return !(
      et.max.x < this.min.x ||
      et.min.x > this.max.x ||
      et.max.y < this.min.y ||
      et.min.y > this.max.y ||
      et.max.z < this.min.z ||
      et.min.z > this.max.z
    );
  }
  intersectsSphere(et) {
    return (
      this.clampPoint(et.center, _vector$a),
      _vector$a.distanceToSquared(et.center) <= et.radius * et.radius
    );
  }
  intersectsPlane(et) {
    let nt, rt;
    return (
      et.normal.x > 0
        ? ((nt = et.normal.x * this.min.x), (rt = et.normal.x * this.max.x))
        : ((nt = et.normal.x * this.max.x), (rt = et.normal.x * this.min.x)),
      et.normal.y > 0
        ? ((nt += et.normal.y * this.min.y), (rt += et.normal.y * this.max.y))
        : ((nt += et.normal.y * this.max.y), (rt += et.normal.y * this.min.y)),
      et.normal.z > 0
        ? ((nt += et.normal.z * this.min.z), (rt += et.normal.z * this.max.z))
        : ((nt += et.normal.z * this.max.z), (rt += et.normal.z * this.min.z)),
      nt <= -et.constant && rt >= -et.constant
    );
  }
  intersectsTriangle(et) {
    if (this.isEmpty()) return !1;
    this.getCenter(_center),
      _extents.subVectors(this.max, _center),
      _v0$2.subVectors(et.a, _center),
      _v1$7.subVectors(et.b, _center),
      _v2$4.subVectors(et.c, _center),
      _f0.subVectors(_v1$7, _v0$2),
      _f1.subVectors(_v2$4, _v1$7),
      _f2.subVectors(_v0$2, _v2$4);
    let nt = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    return !satForAxes(nt, _v0$2, _v1$7, _v2$4, _extents) ||
      ((nt = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !satForAxes(nt, _v0$2, _v1$7, _v2$4, _extents))
      ? !1
      : (_triangleNormal.crossVectors(_f0, _f1),
        (nt = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]),
        satForAxes(nt, _v0$2, _v1$7, _v2$4, _extents));
  }
  clampPoint(et, nt) {
    return nt.copy(et).clamp(this.min, this.max);
  }
  distanceToPoint(et) {
    return this.clampPoint(et, _vector$a).distanceTo(et);
  }
  getBoundingSphere(et) {
    return (
      this.isEmpty()
        ? et.makeEmpty()
        : (this.getCenter(et.center),
          (et.radius = this.getSize(_vector$a).length() * 0.5)),
      et
    );
  }
  intersect(et) {
    return (
      this.min.max(et.min),
      this.max.min(et.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(et) {
    return this.min.min(et.min), this.max.max(et.max), this;
  }
  applyMatrix4(et) {
    return this.isEmpty()
      ? this
      : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(et),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(et),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(et),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(et),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(et),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(et),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(et),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(et),
        this.setFromPoints(_points),
        this);
  }
  translate(et) {
    return this.min.add(et), this.max.add(et), this;
  }
  equals(et) {
    return et.min.equals(this.min) && et.max.equals(this.max);
  }
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  _vector$a = new Vector3(),
  _box$3 = new Box3(),
  _v0$2 = new Vector3(),
  _v1$7 = new Vector3(),
  _v2$4 = new Vector3(),
  _f0 = new Vector3(),
  _f1 = new Vector3(),
  _f2 = new Vector3(),
  _center = new Vector3(),
  _extents = new Vector3(),
  _triangleNormal = new Vector3(),
  _testAxis = new Vector3();
function satForAxes(tt, et, nt, rt, it) {
  for (let st = 0, ot = tt.length - 3; st <= ot; st += 3) {
    _testAxis.fromArray(tt, st);
    const at =
        it.x * Math.abs(_testAxis.x) +
        it.y * Math.abs(_testAxis.y) +
        it.z * Math.abs(_testAxis.z),
      lt = et.dot(_testAxis),
      ct = nt.dot(_testAxis),
      ut = rt.dot(_testAxis);
    if (Math.max(-Math.max(lt, ct, ut), Math.min(lt, ct, ut)) > at) return !1;
  }
  return !0;
}
const _box$2 = new Box3(),
  _v1$6 = new Vector3(),
  _v2$3 = new Vector3();
class Sphere {
  constructor(et = new Vector3(), nt = -1) {
    (this.center = et), (this.radius = nt);
  }
  set(et, nt) {
    return this.center.copy(et), (this.radius = nt), this;
  }
  setFromPoints(et, nt) {
    const rt = this.center;
    nt !== void 0 ? rt.copy(nt) : _box$2.setFromPoints(et).getCenter(rt);
    let it = 0;
    for (let st = 0, ot = et.length; st < ot; st++)
      it = Math.max(it, rt.distanceToSquared(et[st]));
    return (this.radius = Math.sqrt(it)), this;
  }
  copy(et) {
    return this.center.copy(et.center), (this.radius = et.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(et) {
    return et.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(et) {
    return et.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(et) {
    const nt = this.radius + et.radius;
    return et.center.distanceToSquared(this.center) <= nt * nt;
  }
  intersectsBox(et) {
    return et.intersectsSphere(this);
  }
  intersectsPlane(et) {
    return Math.abs(et.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(et, nt) {
    const rt = this.center.distanceToSquared(et);
    return (
      nt.copy(et),
      rt > this.radius * this.radius &&
        (nt.sub(this.center).normalize(),
        nt.multiplyScalar(this.radius).add(this.center)),
      nt
    );
  }
  getBoundingBox(et) {
    return this.isEmpty()
      ? (et.makeEmpty(), et)
      : (et.set(this.center, this.center), et.expandByScalar(this.radius), et);
  }
  applyMatrix4(et) {
    return (
      this.center.applyMatrix4(et),
      (this.radius = this.radius * et.getMaxScaleOnAxis()),
      this
    );
  }
  translate(et) {
    return this.center.add(et), this;
  }
  expandByPoint(et) {
    if (this.isEmpty()) return this.center.copy(et), (this.radius = 0), this;
    _v1$6.subVectors(et, this.center);
    const nt = _v1$6.lengthSq();
    if (nt > this.radius * this.radius) {
      const rt = Math.sqrt(nt),
        it = (rt - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, it / rt), (this.radius += it);
    }
    return this;
  }
  union(et) {
    return et.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(et), this)
      : (this.center.equals(et.center) === !0
          ? (this.radius = Math.max(this.radius, et.radius))
          : (_v2$3.subVectors(et.center, this.center).setLength(et.radius),
            this.expandByPoint(_v1$6.copy(et.center).add(_v2$3)),
            this.expandByPoint(_v1$6.copy(et.center).sub(_v2$3))),
        this);
  }
  equals(et) {
    return et.center.equals(this.center) && et.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$9 = new Vector3(),
  _segCenter = new Vector3(),
  _segDir = new Vector3(),
  _diff = new Vector3(),
  _edge1 = new Vector3(),
  _edge2 = new Vector3(),
  _normal$1 = new Vector3();
class Ray {
  constructor(et = new Vector3(), nt = new Vector3(0, 0, -1)) {
    (this.origin = et), (this.direction = nt);
  }
  set(et, nt) {
    return this.origin.copy(et), this.direction.copy(nt), this;
  }
  copy(et) {
    return this.origin.copy(et.origin), this.direction.copy(et.direction), this;
  }
  at(et, nt) {
    return nt.copy(this.origin).addScaledVector(this.direction, et);
  }
  lookAt(et) {
    return this.direction.copy(et).sub(this.origin).normalize(), this;
  }
  recast(et) {
    return this.origin.copy(this.at(et, _vector$9)), this;
  }
  closestPointToPoint(et, nt) {
    nt.subVectors(et, this.origin);
    const rt = nt.dot(this.direction);
    return rt < 0
      ? nt.copy(this.origin)
      : nt.copy(this.origin).addScaledVector(this.direction, rt);
  }
  distanceToPoint(et) {
    return Math.sqrt(this.distanceSqToPoint(et));
  }
  distanceSqToPoint(et) {
    const nt = _vector$9.subVectors(et, this.origin).dot(this.direction);
    return nt < 0
      ? this.origin.distanceToSquared(et)
      : (_vector$9.copy(this.origin).addScaledVector(this.direction, nt),
        _vector$9.distanceToSquared(et));
  }
  distanceSqToSegment(et, nt, rt, it) {
    _segCenter.copy(et).add(nt).multiplyScalar(0.5),
      _segDir.copy(nt).sub(et).normalize(),
      _diff.copy(this.origin).sub(_segCenter);
    const st = et.distanceTo(nt) * 0.5,
      ot = -this.direction.dot(_segDir),
      at = _diff.dot(this.direction),
      lt = -_diff.dot(_segDir),
      ct = _diff.lengthSq(),
      ut = Math.abs(1 - ot * ot);
    let ft, ht, mt, vt;
    if (ut > 0)
      if (((ft = ot * lt - at), (ht = ot * at - lt), (vt = st * ut), ft >= 0))
        if (ht >= -vt)
          if (ht <= vt) {
            const yt = 1 / ut;
            (ft *= yt),
              (ht *= yt),
              (mt =
                ft * (ft + ot * ht + 2 * at) +
                ht * (ot * ft + ht + 2 * lt) +
                ct);
          } else
            (ht = st),
              (ft = Math.max(0, -(ot * ht + at))),
              (mt = -ft * ft + ht * (ht + 2 * lt) + ct);
        else
          (ht = -st),
            (ft = Math.max(0, -(ot * ht + at))),
            (mt = -ft * ft + ht * (ht + 2 * lt) + ct);
      else
        ht <= -vt
          ? ((ft = Math.max(0, -(-ot * st + at))),
            (ht = ft > 0 ? -st : Math.min(Math.max(-st, -lt), st)),
            (mt = -ft * ft + ht * (ht + 2 * lt) + ct))
          : ht <= vt
          ? ((ft = 0),
            (ht = Math.min(Math.max(-st, -lt), st)),
            (mt = ht * (ht + 2 * lt) + ct))
          : ((ft = Math.max(0, -(ot * st + at))),
            (ht = ft > 0 ? st : Math.min(Math.max(-st, -lt), st)),
            (mt = -ft * ft + ht * (ht + 2 * lt) + ct));
    else
      (ht = ot > 0 ? -st : st),
        (ft = Math.max(0, -(ot * ht + at))),
        (mt = -ft * ft + ht * (ht + 2 * lt) + ct);
    return (
      rt && rt.copy(this.origin).addScaledVector(this.direction, ft),
      it && it.copy(_segCenter).addScaledVector(_segDir, ht),
      mt
    );
  }
  intersectSphere(et, nt) {
    _vector$9.subVectors(et.center, this.origin);
    const rt = _vector$9.dot(this.direction),
      it = _vector$9.dot(_vector$9) - rt * rt,
      st = et.radius * et.radius;
    if (it > st) return null;
    const ot = Math.sqrt(st - it),
      at = rt - ot,
      lt = rt + ot;
    return lt < 0 ? null : at < 0 ? this.at(lt, nt) : this.at(at, nt);
  }
  intersectsSphere(et) {
    return this.distanceSqToPoint(et.center) <= et.radius * et.radius;
  }
  distanceToPlane(et) {
    const nt = et.normal.dot(this.direction);
    if (nt === 0) return et.distanceToPoint(this.origin) === 0 ? 0 : null;
    const rt = -(this.origin.dot(et.normal) + et.constant) / nt;
    return rt >= 0 ? rt : null;
  }
  intersectPlane(et, nt) {
    const rt = this.distanceToPlane(et);
    return rt === null ? null : this.at(rt, nt);
  }
  intersectsPlane(et) {
    const nt = et.distanceToPoint(this.origin);
    return nt === 0 || et.normal.dot(this.direction) * nt < 0;
  }
  intersectBox(et, nt) {
    let rt, it, st, ot, at, lt;
    const ct = 1 / this.direction.x,
      ut = 1 / this.direction.y,
      ft = 1 / this.direction.z,
      ht = this.origin;
    return (
      ct >= 0
        ? ((rt = (et.min.x - ht.x) * ct), (it = (et.max.x - ht.x) * ct))
        : ((rt = (et.max.x - ht.x) * ct), (it = (et.min.x - ht.x) * ct)),
      ut >= 0
        ? ((st = (et.min.y - ht.y) * ut), (ot = (et.max.y - ht.y) * ut))
        : ((st = (et.max.y - ht.y) * ut), (ot = (et.min.y - ht.y) * ut)),
      rt > ot ||
      st > it ||
      ((st > rt || isNaN(rt)) && (rt = st),
      (ot < it || isNaN(it)) && (it = ot),
      ft >= 0
        ? ((at = (et.min.z - ht.z) * ft), (lt = (et.max.z - ht.z) * ft))
        : ((at = (et.max.z - ht.z) * ft), (lt = (et.min.z - ht.z) * ft)),
      rt > lt || at > it) ||
      ((at > rt || rt !== rt) && (rt = at),
      (lt < it || it !== it) && (it = lt),
      it < 0)
        ? null
        : this.at(rt >= 0 ? rt : it, nt)
    );
  }
  intersectsBox(et) {
    return this.intersectBox(et, _vector$9) !== null;
  }
  intersectTriangle(et, nt, rt, it, st) {
    _edge1.subVectors(nt, et),
      _edge2.subVectors(rt, et),
      _normal$1.crossVectors(_edge1, _edge2);
    let ot = this.direction.dot(_normal$1),
      at;
    if (ot > 0) {
      if (it) return null;
      at = 1;
    } else if (ot < 0) (at = -1), (ot = -ot);
    else return null;
    _diff.subVectors(this.origin, et);
    const lt = at * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (lt < 0) return null;
    const ct = at * this.direction.dot(_edge1.cross(_diff));
    if (ct < 0 || lt + ct > ot) return null;
    const ut = -at * _diff.dot(_normal$1);
    return ut < 0 ? null : this.at(ut / ot, st);
  }
  applyMatrix4(et) {
    return (
      this.origin.applyMatrix4(et), this.direction.transformDirection(et), this
    );
  }
  equals(et) {
    return et.origin.equals(this.origin) && et.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(et, nt, rt, it, st, ot, at, lt, ct, ut, ft, ht, mt, vt, yt, Et) {
    (Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      et !== void 0 &&
        this.set(
          et,
          nt,
          rt,
          it,
          st,
          ot,
          at,
          lt,
          ct,
          ut,
          ft,
          ht,
          mt,
          vt,
          yt,
          Et
        );
  }
  set(et, nt, rt, it, st, ot, at, lt, ct, ut, ft, ht, mt, vt, yt, Et) {
    const pt = this.elements;
    return (
      (pt[0] = et),
      (pt[4] = nt),
      (pt[8] = rt),
      (pt[12] = it),
      (pt[1] = st),
      (pt[5] = ot),
      (pt[9] = at),
      (pt[13] = lt),
      (pt[2] = ct),
      (pt[6] = ut),
      (pt[10] = ft),
      (pt[14] = ht),
      (pt[3] = mt),
      (pt[7] = vt),
      (pt[11] = yt),
      (pt[15] = Et),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(et) {
    const nt = this.elements,
      rt = et.elements;
    return (
      (nt[0] = rt[0]),
      (nt[1] = rt[1]),
      (nt[2] = rt[2]),
      (nt[3] = rt[3]),
      (nt[4] = rt[4]),
      (nt[5] = rt[5]),
      (nt[6] = rt[6]),
      (nt[7] = rt[7]),
      (nt[8] = rt[8]),
      (nt[9] = rt[9]),
      (nt[10] = rt[10]),
      (nt[11] = rt[11]),
      (nt[12] = rt[12]),
      (nt[13] = rt[13]),
      (nt[14] = rt[14]),
      (nt[15] = rt[15]),
      this
    );
  }
  copyPosition(et) {
    const nt = this.elements,
      rt = et.elements;
    return (nt[12] = rt[12]), (nt[13] = rt[13]), (nt[14] = rt[14]), this;
  }
  setFromMatrix3(et) {
    const nt = et.elements;
    return (
      this.set(
        nt[0],
        nt[3],
        nt[6],
        0,
        nt[1],
        nt[4],
        nt[7],
        0,
        nt[2],
        nt[5],
        nt[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(et, nt, rt) {
    return (
      et.setFromMatrixColumn(this, 0),
      nt.setFromMatrixColumn(this, 1),
      rt.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(et, nt, rt) {
    return (
      this.set(
        et.x,
        nt.x,
        rt.x,
        0,
        et.y,
        nt.y,
        rt.y,
        0,
        et.z,
        nt.z,
        rt.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(et) {
    const nt = this.elements,
      rt = et.elements,
      it = 1 / _v1$5.setFromMatrixColumn(et, 0).length(),
      st = 1 / _v1$5.setFromMatrixColumn(et, 1).length(),
      ot = 1 / _v1$5.setFromMatrixColumn(et, 2).length();
    return (
      (nt[0] = rt[0] * it),
      (nt[1] = rt[1] * it),
      (nt[2] = rt[2] * it),
      (nt[3] = 0),
      (nt[4] = rt[4] * st),
      (nt[5] = rt[5] * st),
      (nt[6] = rt[6] * st),
      (nt[7] = 0),
      (nt[8] = rt[8] * ot),
      (nt[9] = rt[9] * ot),
      (nt[10] = rt[10] * ot),
      (nt[11] = 0),
      (nt[12] = 0),
      (nt[13] = 0),
      (nt[14] = 0),
      (nt[15] = 1),
      this
    );
  }
  makeRotationFromEuler(et) {
    const nt = this.elements,
      rt = et.x,
      it = et.y,
      st = et.z,
      ot = Math.cos(rt),
      at = Math.sin(rt),
      lt = Math.cos(it),
      ct = Math.sin(it),
      ut = Math.cos(st),
      ft = Math.sin(st);
    if (et.order === "XYZ") {
      const ht = ot * ut,
        mt = ot * ft,
        vt = at * ut,
        yt = at * ft;
      (nt[0] = lt * ut),
        (nt[4] = -lt * ft),
        (nt[8] = ct),
        (nt[1] = mt + vt * ct),
        (nt[5] = ht - yt * ct),
        (nt[9] = -at * lt),
        (nt[2] = yt - ht * ct),
        (nt[6] = vt + mt * ct),
        (nt[10] = ot * lt);
    } else if (et.order === "YXZ") {
      const ht = lt * ut,
        mt = lt * ft,
        vt = ct * ut,
        yt = ct * ft;
      (nt[0] = ht + yt * at),
        (nt[4] = vt * at - mt),
        (nt[8] = ot * ct),
        (nt[1] = ot * ft),
        (nt[5] = ot * ut),
        (nt[9] = -at),
        (nt[2] = mt * at - vt),
        (nt[6] = yt + ht * at),
        (nt[10] = ot * lt);
    } else if (et.order === "ZXY") {
      const ht = lt * ut,
        mt = lt * ft,
        vt = ct * ut,
        yt = ct * ft;
      (nt[0] = ht - yt * at),
        (nt[4] = -ot * ft),
        (nt[8] = vt + mt * at),
        (nt[1] = mt + vt * at),
        (nt[5] = ot * ut),
        (nt[9] = yt - ht * at),
        (nt[2] = -ot * ct),
        (nt[6] = at),
        (nt[10] = ot * lt);
    } else if (et.order === "ZYX") {
      const ht = ot * ut,
        mt = ot * ft,
        vt = at * ut,
        yt = at * ft;
      (nt[0] = lt * ut),
        (nt[4] = vt * ct - mt),
        (nt[8] = ht * ct + yt),
        (nt[1] = lt * ft),
        (nt[5] = yt * ct + ht),
        (nt[9] = mt * ct - vt),
        (nt[2] = -ct),
        (nt[6] = at * lt),
        (nt[10] = ot * lt);
    } else if (et.order === "YZX") {
      const ht = ot * lt,
        mt = ot * ct,
        vt = at * lt,
        yt = at * ct;
      (nt[0] = lt * ut),
        (nt[4] = yt - ht * ft),
        (nt[8] = vt * ft + mt),
        (nt[1] = ft),
        (nt[5] = ot * ut),
        (nt[9] = -at * ut),
        (nt[2] = -ct * ut),
        (nt[6] = mt * ft + vt),
        (nt[10] = ht - yt * ft);
    } else if (et.order === "XZY") {
      const ht = ot * lt,
        mt = ot * ct,
        vt = at * lt,
        yt = at * ct;
      (nt[0] = lt * ut),
        (nt[4] = -ft),
        (nt[8] = ct * ut),
        (nt[1] = ht * ft + yt),
        (nt[5] = ot * ut),
        (nt[9] = mt * ft - vt),
        (nt[2] = vt * ft - mt),
        (nt[6] = at * ut),
        (nt[10] = yt * ft + ht);
    }
    return (
      (nt[3] = 0),
      (nt[7] = 0),
      (nt[11] = 0),
      (nt[12] = 0),
      (nt[13] = 0),
      (nt[14] = 0),
      (nt[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(et) {
    return this.compose(_zero, et, _one);
  }
  lookAt(et, nt, rt) {
    const it = this.elements;
    return (
      _z.subVectors(et, nt),
      _z.lengthSq() === 0 && (_z.z = 1),
      _z.normalize(),
      _x.crossVectors(rt, _z),
      _x.lengthSq() === 0 &&
        (Math.abs(rt.z) === 1 ? (_z.x += 1e-4) : (_z.z += 1e-4),
        _z.normalize(),
        _x.crossVectors(rt, _z)),
      _x.normalize(),
      _y.crossVectors(_z, _x),
      (it[0] = _x.x),
      (it[4] = _y.x),
      (it[8] = _z.x),
      (it[1] = _x.y),
      (it[5] = _y.y),
      (it[9] = _z.y),
      (it[2] = _x.z),
      (it[6] = _y.z),
      (it[10] = _z.z),
      this
    );
  }
  multiply(et) {
    return this.multiplyMatrices(this, et);
  }
  premultiply(et) {
    return this.multiplyMatrices(et, this);
  }
  multiplyMatrices(et, nt) {
    const rt = et.elements,
      it = nt.elements,
      st = this.elements,
      ot = rt[0],
      at = rt[4],
      lt = rt[8],
      ct = rt[12],
      ut = rt[1],
      ft = rt[5],
      ht = rt[9],
      mt = rt[13],
      vt = rt[2],
      yt = rt[6],
      Et = rt[10],
      pt = rt[14],
      xt = rt[3],
      St = rt[7],
      At = rt[11],
      Ct = rt[15],
      Mt = it[0],
      wt = it[4],
      Bt = it[8],
      It = it[12],
      Ft = it[1],
      Vt = it[5],
      $t = it[9],
      Kt = it[13],
      Ht = it[2],
      Wt = it[6],
      kt = it[10],
      Gt = it[14],
      Pt = it[3],
      Rt = it[7],
      Nt = it[11],
      Dt = it[15];
    return (
      (st[0] = ot * Mt + at * Ft + lt * Ht + ct * Pt),
      (st[4] = ot * wt + at * Vt + lt * Wt + ct * Rt),
      (st[8] = ot * Bt + at * $t + lt * kt + ct * Nt),
      (st[12] = ot * It + at * Kt + lt * Gt + ct * Dt),
      (st[1] = ut * Mt + ft * Ft + ht * Ht + mt * Pt),
      (st[5] = ut * wt + ft * Vt + ht * Wt + mt * Rt),
      (st[9] = ut * Bt + ft * $t + ht * kt + mt * Nt),
      (st[13] = ut * It + ft * Kt + ht * Gt + mt * Dt),
      (st[2] = vt * Mt + yt * Ft + Et * Ht + pt * Pt),
      (st[6] = vt * wt + yt * Vt + Et * Wt + pt * Rt),
      (st[10] = vt * Bt + yt * $t + Et * kt + pt * Nt),
      (st[14] = vt * It + yt * Kt + Et * Gt + pt * Dt),
      (st[3] = xt * Mt + St * Ft + At * Ht + Ct * Pt),
      (st[7] = xt * wt + St * Vt + At * Wt + Ct * Rt),
      (st[11] = xt * Bt + St * $t + At * kt + Ct * Nt),
      (st[15] = xt * It + St * Kt + At * Gt + Ct * Dt),
      this
    );
  }
  multiplyScalar(et) {
    const nt = this.elements;
    return (
      (nt[0] *= et),
      (nt[4] *= et),
      (nt[8] *= et),
      (nt[12] *= et),
      (nt[1] *= et),
      (nt[5] *= et),
      (nt[9] *= et),
      (nt[13] *= et),
      (nt[2] *= et),
      (nt[6] *= et),
      (nt[10] *= et),
      (nt[14] *= et),
      (nt[3] *= et),
      (nt[7] *= et),
      (nt[11] *= et),
      (nt[15] *= et),
      this
    );
  }
  determinant() {
    const et = this.elements,
      nt = et[0],
      rt = et[4],
      it = et[8],
      st = et[12],
      ot = et[1],
      at = et[5],
      lt = et[9],
      ct = et[13],
      ut = et[2],
      ft = et[6],
      ht = et[10],
      mt = et[14],
      vt = et[3],
      yt = et[7],
      Et = et[11],
      pt = et[15];
    return (
      vt *
        (+st * lt * ft -
          it * ct * ft -
          st * at * ht +
          rt * ct * ht +
          it * at * mt -
          rt * lt * mt) +
      yt *
        (+nt * lt * mt -
          nt * ct * ht +
          st * ot * ht -
          it * ot * mt +
          it * ct * ut -
          st * lt * ut) +
      Et *
        (+nt * ct * ft -
          nt * at * mt -
          st * ot * ft +
          rt * ot * mt +
          st * at * ut -
          rt * ct * ut) +
      pt *
        (-it * at * ut -
          nt * lt * ft +
          nt * at * ht +
          it * ot * ft -
          rt * ot * ht +
          rt * lt * ut)
    );
  }
  transpose() {
    const et = this.elements;
    let nt;
    return (
      (nt = et[1]),
      (et[1] = et[4]),
      (et[4] = nt),
      (nt = et[2]),
      (et[2] = et[8]),
      (et[8] = nt),
      (nt = et[6]),
      (et[6] = et[9]),
      (et[9] = nt),
      (nt = et[3]),
      (et[3] = et[12]),
      (et[12] = nt),
      (nt = et[7]),
      (et[7] = et[13]),
      (et[13] = nt),
      (nt = et[11]),
      (et[11] = et[14]),
      (et[14] = nt),
      this
    );
  }
  setPosition(et, nt, rt) {
    const it = this.elements;
    return (
      et.isVector3
        ? ((it[12] = et.x), (it[13] = et.y), (it[14] = et.z))
        : ((it[12] = et), (it[13] = nt), (it[14] = rt)),
      this
    );
  }
  invert() {
    const et = this.elements,
      nt = et[0],
      rt = et[1],
      it = et[2],
      st = et[3],
      ot = et[4],
      at = et[5],
      lt = et[6],
      ct = et[7],
      ut = et[8],
      ft = et[9],
      ht = et[10],
      mt = et[11],
      vt = et[12],
      yt = et[13],
      Et = et[14],
      pt = et[15],
      xt =
        ft * Et * ct -
        yt * ht * ct +
        yt * lt * mt -
        at * Et * mt -
        ft * lt * pt +
        at * ht * pt,
      St =
        vt * ht * ct -
        ut * Et * ct -
        vt * lt * mt +
        ot * Et * mt +
        ut * lt * pt -
        ot * ht * pt,
      At =
        ut * yt * ct -
        vt * ft * ct +
        vt * at * mt -
        ot * yt * mt -
        ut * at * pt +
        ot * ft * pt,
      Ct =
        vt * ft * lt -
        ut * yt * lt -
        vt * at * ht +
        ot * yt * ht +
        ut * at * Et -
        ot * ft * Et,
      Mt = nt * xt + rt * St + it * At + st * Ct;
    if (Mt === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const wt = 1 / Mt;
    return (
      (et[0] = xt * wt),
      (et[1] =
        (yt * ht * st -
          ft * Et * st -
          yt * it * mt +
          rt * Et * mt +
          ft * it * pt -
          rt * ht * pt) *
        wt),
      (et[2] =
        (at * Et * st -
          yt * lt * st +
          yt * it * ct -
          rt * Et * ct -
          at * it * pt +
          rt * lt * pt) *
        wt),
      (et[3] =
        (ft * lt * st -
          at * ht * st -
          ft * it * ct +
          rt * ht * ct +
          at * it * mt -
          rt * lt * mt) *
        wt),
      (et[4] = St * wt),
      (et[5] =
        (ut * Et * st -
          vt * ht * st +
          vt * it * mt -
          nt * Et * mt -
          ut * it * pt +
          nt * ht * pt) *
        wt),
      (et[6] =
        (vt * lt * st -
          ot * Et * st -
          vt * it * ct +
          nt * Et * ct +
          ot * it * pt -
          nt * lt * pt) *
        wt),
      (et[7] =
        (ot * ht * st -
          ut * lt * st +
          ut * it * ct -
          nt * ht * ct -
          ot * it * mt +
          nt * lt * mt) *
        wt),
      (et[8] = At * wt),
      (et[9] =
        (vt * ft * st -
          ut * yt * st -
          vt * rt * mt +
          nt * yt * mt +
          ut * rt * pt -
          nt * ft * pt) *
        wt),
      (et[10] =
        (ot * yt * st -
          vt * at * st +
          vt * rt * ct -
          nt * yt * ct -
          ot * rt * pt +
          nt * at * pt) *
        wt),
      (et[11] =
        (ut * at * st -
          ot * ft * st -
          ut * rt * ct +
          nt * ft * ct +
          ot * rt * mt -
          nt * at * mt) *
        wt),
      (et[12] = Ct * wt),
      (et[13] =
        (ut * yt * it -
          vt * ft * it +
          vt * rt * ht -
          nt * yt * ht -
          ut * rt * Et +
          nt * ft * Et) *
        wt),
      (et[14] =
        (vt * at * it -
          ot * yt * it -
          vt * rt * lt +
          nt * yt * lt +
          ot * rt * Et -
          nt * at * Et) *
        wt),
      (et[15] =
        (ot * ft * it -
          ut * at * it +
          ut * rt * lt -
          nt * ft * lt -
          ot * rt * ht +
          nt * at * ht) *
        wt),
      this
    );
  }
  scale(et) {
    const nt = this.elements,
      rt = et.x,
      it = et.y,
      st = et.z;
    return (
      (nt[0] *= rt),
      (nt[4] *= it),
      (nt[8] *= st),
      (nt[1] *= rt),
      (nt[5] *= it),
      (nt[9] *= st),
      (nt[2] *= rt),
      (nt[6] *= it),
      (nt[10] *= st),
      (nt[3] *= rt),
      (nt[7] *= it),
      (nt[11] *= st),
      this
    );
  }
  getMaxScaleOnAxis() {
    const et = this.elements,
      nt = et[0] * et[0] + et[1] * et[1] + et[2] * et[2],
      rt = et[4] * et[4] + et[5] * et[5] + et[6] * et[6],
      it = et[8] * et[8] + et[9] * et[9] + et[10] * et[10];
    return Math.sqrt(Math.max(nt, rt, it));
  }
  makeTranslation(et, nt, rt) {
    return (
      et.isVector3
        ? this.set(1, 0, 0, et.x, 0, 1, 0, et.y, 0, 0, 1, et.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, et, 0, 1, 0, nt, 0, 0, 1, rt, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(et) {
    const nt = Math.cos(et),
      rt = Math.sin(et);
    return this.set(1, 0, 0, 0, 0, nt, -rt, 0, 0, rt, nt, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(et) {
    const nt = Math.cos(et),
      rt = Math.sin(et);
    return this.set(nt, 0, rt, 0, 0, 1, 0, 0, -rt, 0, nt, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(et) {
    const nt = Math.cos(et),
      rt = Math.sin(et);
    return this.set(nt, -rt, 0, 0, rt, nt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(et, nt) {
    const rt = Math.cos(nt),
      it = Math.sin(nt),
      st = 1 - rt,
      ot = et.x,
      at = et.y,
      lt = et.z,
      ct = st * ot,
      ut = st * at;
    return (
      this.set(
        ct * ot + rt,
        ct * at - it * lt,
        ct * lt + it * at,
        0,
        ct * at + it * lt,
        ut * at + rt,
        ut * lt - it * ot,
        0,
        ct * lt - it * at,
        ut * lt + it * ot,
        st * lt * lt + rt,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(et, nt, rt) {
    return this.set(et, 0, 0, 0, 0, nt, 0, 0, 0, 0, rt, 0, 0, 0, 0, 1), this;
  }
  makeShear(et, nt, rt, it, st, ot) {
    return this.set(1, rt, st, 0, et, 1, ot, 0, nt, it, 1, 0, 0, 0, 0, 1), this;
  }
  compose(et, nt, rt) {
    const it = this.elements,
      st = nt._x,
      ot = nt._y,
      at = nt._z,
      lt = nt._w,
      ct = st + st,
      ut = ot + ot,
      ft = at + at,
      ht = st * ct,
      mt = st * ut,
      vt = st * ft,
      yt = ot * ut,
      Et = ot * ft,
      pt = at * ft,
      xt = lt * ct,
      St = lt * ut,
      At = lt * ft,
      Ct = rt.x,
      Mt = rt.y,
      wt = rt.z;
    return (
      (it[0] = (1 - (yt + pt)) * Ct),
      (it[1] = (mt + At) * Ct),
      (it[2] = (vt - St) * Ct),
      (it[3] = 0),
      (it[4] = (mt - At) * Mt),
      (it[5] = (1 - (ht + pt)) * Mt),
      (it[6] = (Et + xt) * Mt),
      (it[7] = 0),
      (it[8] = (vt + St) * wt),
      (it[9] = (Et - xt) * wt),
      (it[10] = (1 - (ht + yt)) * wt),
      (it[11] = 0),
      (it[12] = et.x),
      (it[13] = et.y),
      (it[14] = et.z),
      (it[15] = 1),
      this
    );
  }
  decompose(et, nt, rt) {
    const it = this.elements;
    let st = _v1$5.set(it[0], it[1], it[2]).length();
    const ot = _v1$5.set(it[4], it[5], it[6]).length(),
      at = _v1$5.set(it[8], it[9], it[10]).length();
    this.determinant() < 0 && (st = -st),
      (et.x = it[12]),
      (et.y = it[13]),
      (et.z = it[14]),
      _m1$2.copy(this);
    const ct = 1 / st,
      ut = 1 / ot,
      ft = 1 / at;
    return (
      (_m1$2.elements[0] *= ct),
      (_m1$2.elements[1] *= ct),
      (_m1$2.elements[2] *= ct),
      (_m1$2.elements[4] *= ut),
      (_m1$2.elements[5] *= ut),
      (_m1$2.elements[6] *= ut),
      (_m1$2.elements[8] *= ft),
      (_m1$2.elements[9] *= ft),
      (_m1$2.elements[10] *= ft),
      nt.setFromRotationMatrix(_m1$2),
      (rt.x = st),
      (rt.y = ot),
      (rt.z = at),
      this
    );
  }
  makePerspective(et, nt, rt, it, st, ot, at = WebGLCoordinateSystem) {
    const lt = this.elements,
      ct = (2 * st) / (nt - et),
      ut = (2 * st) / (rt - it),
      ft = (nt + et) / (nt - et),
      ht = (rt + it) / (rt - it);
    let mt, vt;
    if (at === WebGLCoordinateSystem)
      (mt = -(ot + st) / (ot - st)), (vt = (-2 * ot * st) / (ot - st));
    else if (at === WebGPUCoordinateSystem)
      (mt = -ot / (ot - st)), (vt = (-ot * st) / (ot - st));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + at
      );
    return (
      (lt[0] = ct),
      (lt[4] = 0),
      (lt[8] = ft),
      (lt[12] = 0),
      (lt[1] = 0),
      (lt[5] = ut),
      (lt[9] = ht),
      (lt[13] = 0),
      (lt[2] = 0),
      (lt[6] = 0),
      (lt[10] = mt),
      (lt[14] = vt),
      (lt[3] = 0),
      (lt[7] = 0),
      (lt[11] = -1),
      (lt[15] = 0),
      this
    );
  }
  makeOrthographic(et, nt, rt, it, st, ot, at = WebGLCoordinateSystem) {
    const lt = this.elements,
      ct = 1 / (nt - et),
      ut = 1 / (rt - it),
      ft = 1 / (ot - st),
      ht = (nt + et) * ct,
      mt = (rt + it) * ut;
    let vt, yt;
    if (at === WebGLCoordinateSystem) (vt = (ot + st) * ft), (yt = -2 * ft);
    else if (at === WebGPUCoordinateSystem) (vt = st * ft), (yt = -1 * ft);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + at
      );
    return (
      (lt[0] = 2 * ct),
      (lt[4] = 0),
      (lt[8] = 0),
      (lt[12] = -ht),
      (lt[1] = 0),
      (lt[5] = 2 * ut),
      (lt[9] = 0),
      (lt[13] = -mt),
      (lt[2] = 0),
      (lt[6] = 0),
      (lt[10] = yt),
      (lt[14] = -vt),
      (lt[3] = 0),
      (lt[7] = 0),
      (lt[11] = 0),
      (lt[15] = 1),
      this
    );
  }
  equals(et) {
    const nt = this.elements,
      rt = et.elements;
    for (let it = 0; it < 16; it++) if (nt[it] !== rt[it]) return !1;
    return !0;
  }
  fromArray(et, nt = 0) {
    for (let rt = 0; rt < 16; rt++) this.elements[rt] = et[rt + nt];
    return this;
  }
  toArray(et = [], nt = 0) {
    const rt = this.elements;
    return (
      (et[nt] = rt[0]),
      (et[nt + 1] = rt[1]),
      (et[nt + 2] = rt[2]),
      (et[nt + 3] = rt[3]),
      (et[nt + 4] = rt[4]),
      (et[nt + 5] = rt[5]),
      (et[nt + 6] = rt[6]),
      (et[nt + 7] = rt[7]),
      (et[nt + 8] = rt[8]),
      (et[nt + 9] = rt[9]),
      (et[nt + 10] = rt[10]),
      (et[nt + 11] = rt[11]),
      (et[nt + 12] = rt[12]),
      (et[nt + 13] = rt[13]),
      (et[nt + 14] = rt[14]),
      (et[nt + 15] = rt[15]),
      et
    );
  }
}
const _v1$5 = new Vector3(),
  _m1$2 = new Matrix4(),
  _zero = new Vector3(0, 0, 0),
  _one = new Vector3(1, 1, 1),
  _x = new Vector3(),
  _y = new Vector3(),
  _z = new Vector3(),
  _matrix = new Matrix4(),
  _quaternion$3 = new Quaternion();
class Euler {
  constructor(et = 0, nt = 0, rt = 0, it = Euler.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = et),
      (this._y = nt),
      (this._z = rt),
      (this._order = it);
  }
  get x() {
    return this._x;
  }
  set x(et) {
    (this._x = et), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(et) {
    (this._y = et), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(et) {
    (this._z = et), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(et) {
    (this._order = et), this._onChangeCallback();
  }
  set(et, nt, rt, it = this._order) {
    return (
      (this._x = et),
      (this._y = nt),
      (this._z = rt),
      (this._order = it),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(et) {
    return (
      (this._x = et._x),
      (this._y = et._y),
      (this._z = et._z),
      (this._order = et._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(et, nt = this._order, rt = !0) {
    const it = et.elements,
      st = it[0],
      ot = it[4],
      at = it[8],
      lt = it[1],
      ct = it[5],
      ut = it[9],
      ft = it[2],
      ht = it[6],
      mt = it[10];
    switch (nt) {
      case "XYZ":
        (this._y = Math.asin(clamp$1(at, -1, 1))),
          Math.abs(at) < 0.9999999
            ? ((this._x = Math.atan2(-ut, mt)), (this._z = Math.atan2(-ot, st)))
            : ((this._x = Math.atan2(ht, ct)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-clamp$1(ut, -1, 1))),
          Math.abs(ut) < 0.9999999
            ? ((this._y = Math.atan2(at, mt)), (this._z = Math.atan2(lt, ct)))
            : ((this._y = Math.atan2(-ft, st)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(clamp$1(ht, -1, 1))),
          Math.abs(ht) < 0.9999999
            ? ((this._y = Math.atan2(-ft, mt)), (this._z = Math.atan2(-ot, ct)))
            : ((this._y = 0), (this._z = Math.atan2(lt, st)));
        break;
      case "ZYX":
        (this._y = Math.asin(-clamp$1(ft, -1, 1))),
          Math.abs(ft) < 0.9999999
            ? ((this._x = Math.atan2(ht, mt)), (this._z = Math.atan2(lt, st)))
            : ((this._x = 0), (this._z = Math.atan2(-ot, ct)));
        break;
      case "YZX":
        (this._z = Math.asin(clamp$1(lt, -1, 1))),
          Math.abs(lt) < 0.9999999
            ? ((this._x = Math.atan2(-ut, ct)), (this._y = Math.atan2(-ft, st)))
            : ((this._x = 0), (this._y = Math.atan2(at, mt)));
        break;
      case "XZY":
        (this._z = Math.asin(-clamp$1(ot, -1, 1))),
          Math.abs(ot) < 0.9999999
            ? ((this._x = Math.atan2(ht, ct)), (this._y = Math.atan2(at, st)))
            : ((this._x = Math.atan2(-ut, mt)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            nt
        );
    }
    return (this._order = nt), rt === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(et, nt, rt) {
    return (
      _matrix.makeRotationFromQuaternion(et),
      this.setFromRotationMatrix(_matrix, nt, rt)
    );
  }
  setFromVector3(et, nt = this._order) {
    return this.set(et.x, et.y, et.z, nt);
  }
  reorder(et) {
    return (
      _quaternion$3.setFromEuler(this),
      this.setFromQuaternion(_quaternion$3, et)
    );
  }
  equals(et) {
    return (
      et._x === this._x &&
      et._y === this._y &&
      et._z === this._z &&
      et._order === this._order
    );
  }
  fromArray(et) {
    return (
      (this._x = et[0]),
      (this._y = et[1]),
      (this._z = et[2]),
      et[3] !== void 0 && (this._order = et[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(et = [], nt = 0) {
    return (
      (et[nt] = this._x),
      (et[nt + 1] = this._y),
      (et[nt + 2] = this._z),
      (et[nt + 3] = this._order),
      et
    );
  }
  _onChange(et) {
    return (this._onChangeCallback = et), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(et) {
    this.mask = ((1 << et) | 0) >>> 0;
  }
  enable(et) {
    this.mask |= (1 << et) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(et) {
    this.mask ^= (1 << et) | 0;
  }
  disable(et) {
    this.mask &= ~((1 << et) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(et) {
    return (this.mask & et.mask) !== 0;
  }
  isEnabled(et) {
    return (this.mask & ((1 << et) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3(),
  _q1 = new Quaternion(),
  _m1$1 = new Matrix4(),
  _target = new Vector3(),
  _position$3 = new Vector3(),
  _scale$2 = new Vector3(),
  _quaternion$2 = new Quaternion(),
  _xAxis = new Vector3(1, 0, 0),
  _yAxis = new Vector3(0, 1, 0),
  _zAxis = new Vector3(0, 0, 1),
  _addedEvent = { type: "added" },
  _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: _object3DId++ }),
      (this.uuid = generateUUID$1()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone());
    const et = new Vector3(),
      nt = new Euler(),
      rt = new Quaternion(),
      it = new Vector3(1, 1, 1);
    function st() {
      rt.setFromEuler(nt, !1);
    }
    function ot() {
      nt.setFromQuaternion(rt, void 0, !1);
    }
    nt._onChange(st),
      rt._onChange(ot),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: et },
        rotation: { configurable: !0, enumerable: !0, value: nt },
        quaternion: { configurable: !0, enumerable: !0, value: rt },
        scale: { configurable: !0, enumerable: !0, value: it },
        modelViewMatrix: { value: new Matrix4() },
        normalMatrix: { value: new Matrix3() },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Layers()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(et) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(et),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(et) {
    return this.quaternion.premultiply(et), this;
  }
  setRotationFromAxisAngle(et, nt) {
    this.quaternion.setFromAxisAngle(et, nt);
  }
  setRotationFromEuler(et) {
    this.quaternion.setFromEuler(et, !0);
  }
  setRotationFromMatrix(et) {
    this.quaternion.setFromRotationMatrix(et);
  }
  setRotationFromQuaternion(et) {
    this.quaternion.copy(et);
  }
  rotateOnAxis(et, nt) {
    return _q1.setFromAxisAngle(et, nt), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(et, nt) {
    return _q1.setFromAxisAngle(et, nt), this.quaternion.premultiply(_q1), this;
  }
  rotateX(et) {
    return this.rotateOnAxis(_xAxis, et);
  }
  rotateY(et) {
    return this.rotateOnAxis(_yAxis, et);
  }
  rotateZ(et) {
    return this.rotateOnAxis(_zAxis, et);
  }
  translateOnAxis(et, nt) {
    return (
      _v1$4.copy(et).applyQuaternion(this.quaternion),
      this.position.add(_v1$4.multiplyScalar(nt)),
      this
    );
  }
  translateX(et) {
    return this.translateOnAxis(_xAxis, et);
  }
  translateY(et) {
    return this.translateOnAxis(_yAxis, et);
  }
  translateZ(et) {
    return this.translateOnAxis(_zAxis, et);
  }
  localToWorld(et) {
    return this.updateWorldMatrix(!0, !1), et.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(et) {
    return (
      this.updateWorldMatrix(!0, !1),
      et.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
    );
  }
  lookAt(et, nt, rt) {
    et.isVector3 ? _target.copy(et) : _target.set(et, nt, rt);
    const it = this.parent;
    this.updateWorldMatrix(!0, !1),
      _position$3.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _m1$1.lookAt(_position$3, _target, this.up)
        : _m1$1.lookAt(_target, _position$3, this.up),
      this.quaternion.setFromRotationMatrix(_m1$1),
      it &&
        (_m1$1.extractRotation(it.matrixWorld),
        _q1.setFromRotationMatrix(_m1$1),
        this.quaternion.premultiply(_q1.invert()));
  }
  add(et) {
    if (arguments.length > 1) {
      for (let nt = 0; nt < arguments.length; nt++) this.add(arguments[nt]);
      return this;
    }
    return et === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          et
        ),
        this)
      : (et && et.isObject3D
          ? (et.parent !== null && et.parent.remove(et),
            (et.parent = this),
            this.children.push(et),
            et.dispatchEvent(_addedEvent))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              et
            ),
        this);
  }
  remove(et) {
    if (arguments.length > 1) {
      for (let rt = 0; rt < arguments.length; rt++) this.remove(arguments[rt]);
      return this;
    }
    const nt = this.children.indexOf(et);
    return (
      nt !== -1 &&
        ((et.parent = null),
        this.children.splice(nt, 1),
        et.dispatchEvent(_removedEvent)),
      this
    );
  }
  removeFromParent() {
    const et = this.parent;
    return et !== null && et.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(et) {
    return (
      this.updateWorldMatrix(!0, !1),
      _m1$1.copy(this.matrixWorld).invert(),
      et.parent !== null &&
        (et.parent.updateWorldMatrix(!0, !1),
        _m1$1.multiply(et.parent.matrixWorld)),
      et.applyMatrix4(_m1$1),
      this.add(et),
      et.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(et) {
    return this.getObjectByProperty("id", et);
  }
  getObjectByName(et) {
    return this.getObjectByProperty("name", et);
  }
  getObjectByProperty(et, nt) {
    if (this[et] === nt) return this;
    for (let rt = 0, it = this.children.length; rt < it; rt++) {
      const ot = this.children[rt].getObjectByProperty(et, nt);
      if (ot !== void 0) return ot;
    }
  }
  getObjectsByProperty(et, nt) {
    let rt = [];
    this[et] === nt && rt.push(this);
    for (let it = 0, st = this.children.length; it < st; it++) {
      const ot = this.children[it].getObjectsByProperty(et, nt);
      ot.length > 0 && (rt = rt.concat(ot));
    }
    return rt;
  }
  getWorldPosition(et) {
    return (
      this.updateWorldMatrix(!0, !1), et.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(et) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, et, _scale$2),
      et
    );
  }
  getWorldScale(et) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, _quaternion$2, et),
      et
    );
  }
  getWorldDirection(et) {
    this.updateWorldMatrix(!0, !1);
    const nt = this.matrixWorld.elements;
    return et.set(nt[8], nt[9], nt[10]).normalize();
  }
  raycast() {}
  traverse(et) {
    et(this);
    const nt = this.children;
    for (let rt = 0, it = nt.length; rt < it; rt++) nt[rt].traverse(et);
  }
  traverseVisible(et) {
    if (this.visible === !1) return;
    et(this);
    const nt = this.children;
    for (let rt = 0, it = nt.length; rt < it; rt++) nt[rt].traverseVisible(et);
  }
  traverseAncestors(et) {
    const nt = this.parent;
    nt !== null && (et(nt), nt.traverseAncestors(et));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(et) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || et) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (et = !0));
    const nt = this.children;
    for (let rt = 0, it = nt.length; rt < it; rt++) {
      const st = nt[rt];
      (st.matrixWorldAutoUpdate === !0 || et === !0) &&
        st.updateMatrixWorld(et);
    }
  }
  updateWorldMatrix(et, nt) {
    const rt = this.parent;
    if (
      (et === !0 &&
        rt !== null &&
        rt.matrixWorldAutoUpdate === !0 &&
        rt.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      nt === !0)
    ) {
      const it = this.children;
      for (let st = 0, ot = it.length; st < ot; st++) {
        const at = it[st];
        at.matrixWorldAutoUpdate === !0 && at.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(et) {
    const nt = et === void 0 || typeof et == "string",
      rt = {};
    nt &&
      ((et = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (rt.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const it = {};
    (it.uuid = this.uuid),
      (it.type = this.type),
      this.name !== "" && (it.name = this.name),
      this.castShadow === !0 && (it.castShadow = !0),
      this.receiveShadow === !0 && (it.receiveShadow = !0),
      this.visible === !1 && (it.visible = !1),
      this.frustumCulled === !1 && (it.frustumCulled = !1),
      this.renderOrder !== 0 && (it.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (it.userData = this.userData),
      (it.layers = this.layers.mask),
      (it.matrix = this.matrix.toArray()),
      (it.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (it.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((it.type = "InstancedMesh"),
        (it.count = this.count),
        (it.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (it.instanceColor = this.instanceColor.toJSON()));
    function st(at, lt) {
      return at[lt.uuid] === void 0 && (at[lt.uuid] = lt.toJSON(et)), lt.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (it.background = this.background.toJSON())
          : this.background.isTexture &&
            (it.background = this.background.toJSON(et).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (it.environment = this.environment.toJSON(et).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      it.geometry = st(et.geometries, this.geometry);
      const at = this.geometry.parameters;
      if (at !== void 0 && at.shapes !== void 0) {
        const lt = at.shapes;
        if (Array.isArray(lt))
          for (let ct = 0, ut = lt.length; ct < ut; ct++) {
            const ft = lt[ct];
            st(et.shapes, ft);
          }
        else st(et.shapes, lt);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((it.bindMode = this.bindMode),
        (it.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (st(et.skeletons, this.skeleton),
          (it.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const at = [];
        for (let lt = 0, ct = this.material.length; lt < ct; lt++)
          at.push(st(et.materials, this.material[lt]));
        it.material = at;
      } else it.material = st(et.materials, this.material);
    if (this.children.length > 0) {
      it.children = [];
      for (let at = 0; at < this.children.length; at++)
        it.children.push(this.children[at].toJSON(et).object);
    }
    if (this.animations.length > 0) {
      it.animations = [];
      for (let at = 0; at < this.animations.length; at++) {
        const lt = this.animations[at];
        it.animations.push(st(et.animations, lt));
      }
    }
    if (nt) {
      const at = ot(et.geometries),
        lt = ot(et.materials),
        ct = ot(et.textures),
        ut = ot(et.images),
        ft = ot(et.shapes),
        ht = ot(et.skeletons),
        mt = ot(et.animations),
        vt = ot(et.nodes);
      at.length > 0 && (rt.geometries = at),
        lt.length > 0 && (rt.materials = lt),
        ct.length > 0 && (rt.textures = ct),
        ut.length > 0 && (rt.images = ut),
        ft.length > 0 && (rt.shapes = ft),
        ht.length > 0 && (rt.skeletons = ht),
        mt.length > 0 && (rt.animations = mt),
        vt.length > 0 && (rt.nodes = vt);
    }
    return (rt.object = it), rt;
    function ot(at) {
      const lt = [];
      for (const ct in at) {
        const ut = at[ct];
        delete ut.metadata, lt.push(ut);
      }
      return lt;
    }
  }
  clone(et) {
    return new this.constructor().copy(this, et);
  }
  copy(et, nt = !0) {
    if (
      ((this.name = et.name),
      this.up.copy(et.up),
      this.position.copy(et.position),
      (this.rotation.order = et.rotation.order),
      this.quaternion.copy(et.quaternion),
      this.scale.copy(et.scale),
      this.matrix.copy(et.matrix),
      this.matrixWorld.copy(et.matrixWorld),
      (this.matrixAutoUpdate = et.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = et.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = et.matrixWorldAutoUpdate),
      (this.layers.mask = et.layers.mask),
      (this.visible = et.visible),
      (this.castShadow = et.castShadow),
      (this.receiveShadow = et.receiveShadow),
      (this.frustumCulled = et.frustumCulled),
      (this.renderOrder = et.renderOrder),
      (this.animations = et.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(et.userData))),
      nt === !0)
    )
      for (let rt = 0; rt < et.children.length; rt++) {
        const it = et.children[rt];
        this.add(it.clone());
      }
    return this;
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$1 = new Vector3(),
  _v1$3 = new Vector3(),
  _v2$2 = new Vector3(),
  _v3$1 = new Vector3(),
  _vab = new Vector3(),
  _vac = new Vector3(),
  _vbc = new Vector3(),
  _vap = new Vector3(),
  _vbp = new Vector3(),
  _vcp = new Vector3();
let warnedGetUV = !1;
class Triangle {
  constructor(et = new Vector3(), nt = new Vector3(), rt = new Vector3()) {
    (this.a = et), (this.b = nt), (this.c = rt);
  }
  static getNormal(et, nt, rt, it) {
    it.subVectors(rt, nt), _v0$1.subVectors(et, nt), it.cross(_v0$1);
    const st = it.lengthSq();
    return st > 0 ? it.multiplyScalar(1 / Math.sqrt(st)) : it.set(0, 0, 0);
  }
  static getBarycoord(et, nt, rt, it, st) {
    _v0$1.subVectors(it, nt),
      _v1$3.subVectors(rt, nt),
      _v2$2.subVectors(et, nt);
    const ot = _v0$1.dot(_v0$1),
      at = _v0$1.dot(_v1$3),
      lt = _v0$1.dot(_v2$2),
      ct = _v1$3.dot(_v1$3),
      ut = _v1$3.dot(_v2$2),
      ft = ot * ct - at * at;
    if (ft === 0) return st.set(-2, -1, -1);
    const ht = 1 / ft,
      mt = (ct * lt - at * ut) * ht,
      vt = (ot * ut - at * lt) * ht;
    return st.set(1 - mt - vt, vt, mt);
  }
  static containsPoint(et, nt, rt, it) {
    return (
      this.getBarycoord(et, nt, rt, it, _v3$1),
      _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
    );
  }
  static getUV(et, nt, rt, it, st, ot, at, lt) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      this.getInterpolation(et, nt, rt, it, st, ot, at, lt)
    );
  }
  static getInterpolation(et, nt, rt, it, st, ot, at, lt) {
    return (
      this.getBarycoord(et, nt, rt, it, _v3$1),
      lt.setScalar(0),
      lt.addScaledVector(st, _v3$1.x),
      lt.addScaledVector(ot, _v3$1.y),
      lt.addScaledVector(at, _v3$1.z),
      lt
    );
  }
  static isFrontFacing(et, nt, rt, it) {
    return (
      _v0$1.subVectors(rt, nt),
      _v1$3.subVectors(et, nt),
      _v0$1.cross(_v1$3).dot(it) < 0
    );
  }
  set(et, nt, rt) {
    return this.a.copy(et), this.b.copy(nt), this.c.copy(rt), this;
  }
  setFromPointsAndIndices(et, nt, rt, it) {
    return this.a.copy(et[nt]), this.b.copy(et[rt]), this.c.copy(et[it]), this;
  }
  setFromAttributeAndIndices(et, nt, rt, it) {
    return (
      this.a.fromBufferAttribute(et, nt),
      this.b.fromBufferAttribute(et, rt),
      this.c.fromBufferAttribute(et, it),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    return this.a.copy(et.a), this.b.copy(et.b), this.c.copy(et.c), this;
  }
  getArea() {
    return (
      _v0$1.subVectors(this.c, this.b),
      _v1$3.subVectors(this.a, this.b),
      _v0$1.cross(_v1$3).length() * 0.5
    );
  }
  getMidpoint(et) {
    return et
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(et) {
    return Triangle.getNormal(this.a, this.b, this.c, et);
  }
  getPlane(et) {
    return et.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(et, nt) {
    return Triangle.getBarycoord(et, this.a, this.b, this.c, nt);
  }
  getUV(et, nt, rt, it, st) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      Triangle.getInterpolation(et, this.a, this.b, this.c, nt, rt, it, st)
    );
  }
  getInterpolation(et, nt, rt, it, st) {
    return Triangle.getInterpolation(
      et,
      this.a,
      this.b,
      this.c,
      nt,
      rt,
      it,
      st
    );
  }
  containsPoint(et) {
    return Triangle.containsPoint(et, this.a, this.b, this.c);
  }
  isFrontFacing(et) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, et);
  }
  intersectsBox(et) {
    return et.intersectsTriangle(this);
  }
  closestPointToPoint(et, nt) {
    const rt = this.a,
      it = this.b,
      st = this.c;
    let ot, at;
    _vab.subVectors(it, rt), _vac.subVectors(st, rt), _vap.subVectors(et, rt);
    const lt = _vab.dot(_vap),
      ct = _vac.dot(_vap);
    if (lt <= 0 && ct <= 0) return nt.copy(rt);
    _vbp.subVectors(et, it);
    const ut = _vab.dot(_vbp),
      ft = _vac.dot(_vbp);
    if (ut >= 0 && ft <= ut) return nt.copy(it);
    const ht = lt * ft - ut * ct;
    if (ht <= 0 && lt >= 0 && ut <= 0)
      return (ot = lt / (lt - ut)), nt.copy(rt).addScaledVector(_vab, ot);
    _vcp.subVectors(et, st);
    const mt = _vab.dot(_vcp),
      vt = _vac.dot(_vcp);
    if (vt >= 0 && mt <= vt) return nt.copy(st);
    const yt = mt * ct - lt * vt;
    if (yt <= 0 && ct >= 0 && vt <= 0)
      return (at = ct / (ct - vt)), nt.copy(rt).addScaledVector(_vac, at);
    const Et = ut * vt - mt * ft;
    if (Et <= 0 && ft - ut >= 0 && mt - vt >= 0)
      return (
        _vbc.subVectors(st, it),
        (at = (ft - ut) / (ft - ut + (mt - vt))),
        nt.copy(it).addScaledVector(_vbc, at)
      );
    const pt = 1 / (Et + yt + ht);
    return (
      (ot = yt * pt),
      (at = ht * pt),
      nt.copy(rt).addScaledVector(_vab, ot).addScaledVector(_vac, at)
    );
  }
  equals(et) {
    return et.a.equals(this.a) && et.b.equals(this.b) && et.c.equals(this.c);
  }
}
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: _materialId++ }),
      (this.uuid = generateUUID$1()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = NormalBlending),
      (this.side = FrontSide),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = SrcAlphaFactor),
      (this.blendDst = OneMinusSrcAlphaFactor),
      (this.blendEquation = AddEquation),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = LessEqualDepth),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = AlwaysStencilFunc),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = KeepStencilOp),
      (this.stencilZFail = KeepStencilOp),
      (this.stencilZPass = KeepStencilOp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(et) {
    this._alphaTest > 0 != et > 0 && this.version++, (this._alphaTest = et);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(et) {
    if (et !== void 0)
      for (const nt in et) {
        const rt = et[nt];
        if (rt === void 0) {
          console.warn(
            `THREE.Material: parameter '${nt}' has value of undefined.`
          );
          continue;
        }
        const it = this[nt];
        if (it === void 0) {
          console.warn(
            `THREE.Material: '${nt}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        it && it.isColor
          ? it.set(rt)
          : it && it.isVector3 && rt && rt.isVector3
          ? it.copy(rt)
          : (this[nt] = rt);
      }
  }
  toJSON(et) {
    const nt = et === void 0 || typeof et == "string";
    nt && (et = { textures: {}, images: {} });
    const rt = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (rt.uuid = this.uuid),
      (rt.type = this.type),
      this.name !== "" && (rt.name = this.name),
      this.color && this.color.isColor && (rt.color = this.color.getHex()),
      this.roughness !== void 0 && (rt.roughness = this.roughness),
      this.metalness !== void 0 && (rt.metalness = this.metalness),
      this.sheen !== void 0 && (rt.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (rt.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (rt.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (rt.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (rt.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (rt.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (rt.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (rt.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (rt.shininess = this.shininess),
      this.clearcoat !== void 0 && (rt.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (rt.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (rt.clearcoatMap = this.clearcoatMap.toJSON(et).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (rt.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(et).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((rt.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(et).uuid),
        (rt.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (rt.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (rt.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (rt.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (rt.iridescenceMap = this.iridescenceMap.toJSON(et).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (rt.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(et).uuid),
      this.anisotropy !== void 0 && (rt.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (rt.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (rt.anisotropyMap = this.anisotropyMap.toJSON(et).uuid),
      this.map && this.map.isTexture && (rt.map = this.map.toJSON(et).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (rt.matcap = this.matcap.toJSON(et).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (rt.alphaMap = this.alphaMap.toJSON(et).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((rt.lightMap = this.lightMap.toJSON(et).uuid),
        (rt.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((rt.aoMap = this.aoMap.toJSON(et).uuid),
        (rt.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((rt.bumpMap = this.bumpMap.toJSON(et).uuid),
        (rt.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((rt.normalMap = this.normalMap.toJSON(et).uuid),
        (rt.normalMapType = this.normalMapType),
        (rt.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((rt.displacementMap = this.displacementMap.toJSON(et).uuid),
        (rt.displacementScale = this.displacementScale),
        (rt.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (rt.roughnessMap = this.roughnessMap.toJSON(et).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (rt.metalnessMap = this.metalnessMap.toJSON(et).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (rt.emissiveMap = this.emissiveMap.toJSON(et).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (rt.specularMap = this.specularMap.toJSON(et).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (rt.specularIntensityMap = this.specularIntensityMap.toJSON(et).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (rt.specularColorMap = this.specularColorMap.toJSON(et).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((rt.envMap = this.envMap.toJSON(et).uuid),
        this.combine !== void 0 && (rt.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (rt.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (rt.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (rt.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (rt.gradientMap = this.gradientMap.toJSON(et).uuid),
      this.transmission !== void 0 && (rt.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (rt.transmissionMap = this.transmissionMap.toJSON(et).uuid),
      this.thickness !== void 0 && (rt.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (rt.thicknessMap = this.thicknessMap.toJSON(et).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (rt.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (rt.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (rt.size = this.size),
      this.shadowSide !== null && (rt.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (rt.sizeAttenuation = this.sizeAttenuation),
      this.blending !== NormalBlending && (rt.blending = this.blending),
      this.side !== FrontSide && (rt.side = this.side),
      this.vertexColors === !0 && (rt.vertexColors = !0),
      this.opacity < 1 && (rt.opacity = this.opacity),
      this.transparent === !0 && (rt.transparent = !0),
      (rt.depthFunc = this.depthFunc),
      (rt.depthTest = this.depthTest),
      (rt.depthWrite = this.depthWrite),
      (rt.colorWrite = this.colorWrite),
      (rt.stencilWrite = this.stencilWrite),
      (rt.stencilWriteMask = this.stencilWriteMask),
      (rt.stencilFunc = this.stencilFunc),
      (rt.stencilRef = this.stencilRef),
      (rt.stencilFuncMask = this.stencilFuncMask),
      (rt.stencilFail = this.stencilFail),
      (rt.stencilZFail = this.stencilZFail),
      (rt.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (rt.rotation = this.rotation),
      this.polygonOffset === !0 && (rt.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (rt.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (rt.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (rt.linewidth = this.linewidth),
      this.dashSize !== void 0 && (rt.dashSize = this.dashSize),
      this.gapSize !== void 0 && (rt.gapSize = this.gapSize),
      this.scale !== void 0 && (rt.scale = this.scale),
      this.dithering === !0 && (rt.dithering = !0),
      this.alphaTest > 0 && (rt.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (rt.alphaHash = !0),
      this.alphaToCoverage === !0 && (rt.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (rt.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (rt.forceSinglePass = !0),
      this.wireframe === !0 && (rt.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (rt.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (rt.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (rt.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (rt.flatShading = !0),
      this.visible === !1 && (rt.visible = !1),
      this.toneMapped === !1 && (rt.toneMapped = !1),
      this.fog === !1 && (rt.fog = !1),
      Object.keys(this.userData).length > 0 && (rt.userData = this.userData);
    function it(st) {
      const ot = [];
      for (const at in st) {
        const lt = st[at];
        delete lt.metadata, ot.push(lt);
      }
      return ot;
    }
    if (nt) {
      const st = it(et.textures),
        ot = it(et.images);
      st.length > 0 && (rt.textures = st), ot.length > 0 && (rt.images = ot);
    }
    return rt;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    (this.name = et.name),
      (this.blending = et.blending),
      (this.side = et.side),
      (this.vertexColors = et.vertexColors),
      (this.opacity = et.opacity),
      (this.transparent = et.transparent),
      (this.blendSrc = et.blendSrc),
      (this.blendDst = et.blendDst),
      (this.blendEquation = et.blendEquation),
      (this.blendSrcAlpha = et.blendSrcAlpha),
      (this.blendDstAlpha = et.blendDstAlpha),
      (this.blendEquationAlpha = et.blendEquationAlpha),
      (this.depthFunc = et.depthFunc),
      (this.depthTest = et.depthTest),
      (this.depthWrite = et.depthWrite),
      (this.stencilWriteMask = et.stencilWriteMask),
      (this.stencilFunc = et.stencilFunc),
      (this.stencilRef = et.stencilRef),
      (this.stencilFuncMask = et.stencilFuncMask),
      (this.stencilFail = et.stencilFail),
      (this.stencilZFail = et.stencilZFail),
      (this.stencilZPass = et.stencilZPass),
      (this.stencilWrite = et.stencilWrite);
    const nt = et.clippingPlanes;
    let rt = null;
    if (nt !== null) {
      const it = nt.length;
      rt = new Array(it);
      for (let st = 0; st !== it; ++st) rt[st] = nt[st].clone();
    }
    return (
      (this.clippingPlanes = rt),
      (this.clipIntersection = et.clipIntersection),
      (this.clipShadows = et.clipShadows),
      (this.shadowSide = et.shadowSide),
      (this.colorWrite = et.colorWrite),
      (this.precision = et.precision),
      (this.polygonOffset = et.polygonOffset),
      (this.polygonOffsetFactor = et.polygonOffsetFactor),
      (this.polygonOffsetUnits = et.polygonOffsetUnits),
      (this.dithering = et.dithering),
      (this.alphaTest = et.alphaTest),
      (this.alphaHash = et.alphaHash),
      (this.alphaToCoverage = et.alphaToCoverage),
      (this.premultipliedAlpha = et.premultipliedAlpha),
      (this.forceSinglePass = et.forceSinglePass),
      (this.visible = et.visible),
      (this.toneMapped = et.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(et.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(et) {
    et === !0 && this.version++;
  }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _hslA = { h: 0, s: 0, l: 0 },
  _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(tt, et, nt) {
  return (
    nt < 0 && (nt += 1),
    nt > 1 && (nt -= 1),
    nt < 1 / 6
      ? tt + (et - tt) * 6 * nt
      : nt < 1 / 2
      ? et
      : nt < 2 / 3
      ? tt + (et - tt) * 6 * (2 / 3 - nt)
      : tt
  );
}
class Color {
  constructor(et, nt, rt) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(et, nt, rt)
    );
  }
  set(et, nt, rt) {
    if (nt === void 0 && rt === void 0) {
      const it = et;
      it && it.isColor
        ? this.copy(it)
        : typeof it == "number"
        ? this.setHex(it)
        : typeof it == "string" && this.setStyle(it);
    } else this.setRGB(et, nt, rt);
    return this;
  }
  setScalar(et) {
    return (this.r = et), (this.g = et), (this.b = et), this;
  }
  setHex(et, nt = SRGBColorSpace) {
    return (
      (et = Math.floor(et)),
      (this.r = ((et >> 16) & 255) / 255),
      (this.g = ((et >> 8) & 255) / 255),
      (this.b = (et & 255) / 255),
      ColorManagement.toWorkingColorSpace(this, nt),
      this
    );
  }
  setRGB(et, nt, rt, it = ColorManagement.workingColorSpace) {
    return (
      (this.r = et),
      (this.g = nt),
      (this.b = rt),
      ColorManagement.toWorkingColorSpace(this, it),
      this
    );
  }
  setHSL(et, nt, rt, it = ColorManagement.workingColorSpace) {
    if (
      ((et = euclideanModulo(et, 1)),
      (nt = clamp$1(nt, 0, 1)),
      (rt = clamp$1(rt, 0, 1)),
      nt === 0)
    )
      this.r = this.g = this.b = rt;
    else {
      const st = rt <= 0.5 ? rt * (1 + nt) : rt + nt - rt * nt,
        ot = 2 * rt - st;
      (this.r = hue2rgb(ot, st, et + 1 / 3)),
        (this.g = hue2rgb(ot, st, et)),
        (this.b = hue2rgb(ot, st, et - 1 / 3));
    }
    return ColorManagement.toWorkingColorSpace(this, it), this;
  }
  setStyle(et, nt = SRGBColorSpace) {
    function rt(st) {
      st !== void 0 &&
        parseFloat(st) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + et + " will be ignored."
        );
    }
    let it;
    if ((it = /^(\w+)\(([^\)]*)\)/.exec(et))) {
      let st;
      const ot = it[1],
        at = it[2];
      switch (ot) {
        case "rgb":
        case "rgba":
          if (
            (st =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                at
              ))
          )
            return (
              rt(st[4]),
              this.setRGB(
                Math.min(255, parseInt(st[1], 10)) / 255,
                Math.min(255, parseInt(st[2], 10)) / 255,
                Math.min(255, parseInt(st[3], 10)) / 255,
                nt
              )
            );
          if (
            (st =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                at
              ))
          )
            return (
              rt(st[4]),
              this.setRGB(
                Math.min(100, parseInt(st[1], 10)) / 100,
                Math.min(100, parseInt(st[2], 10)) / 100,
                Math.min(100, parseInt(st[3], 10)) / 100,
                nt
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (st =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                at
              ))
          )
            return (
              rt(st[4]),
              this.setHSL(
                parseFloat(st[1]) / 360,
                parseFloat(st[2]) / 100,
                parseFloat(st[3]) / 100,
                nt
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + et);
      }
    } else if ((it = /^\#([A-Fa-f\d]+)$/.exec(et))) {
      const st = it[1],
        ot = st.length;
      if (ot === 3)
        return this.setRGB(
          parseInt(st.charAt(0), 16) / 15,
          parseInt(st.charAt(1), 16) / 15,
          parseInt(st.charAt(2), 16) / 15,
          nt
        );
      if (ot === 6) return this.setHex(parseInt(st, 16), nt);
      console.warn("THREE.Color: Invalid hex color " + et);
    } else if (et && et.length > 0) return this.setColorName(et, nt);
    return this;
  }
  setColorName(et, nt = SRGBColorSpace) {
    const rt = _colorKeywords[et.toLowerCase()];
    return (
      rt !== void 0
        ? this.setHex(rt, nt)
        : console.warn("THREE.Color: Unknown color " + et),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(et) {
    return (this.r = et.r), (this.g = et.g), (this.b = et.b), this;
  }
  copySRGBToLinear(et) {
    return (
      (this.r = SRGBToLinear(et.r)),
      (this.g = SRGBToLinear(et.g)),
      (this.b = SRGBToLinear(et.b)),
      this
    );
  }
  copyLinearToSRGB(et) {
    return (
      (this.r = LinearToSRGB(et.r)),
      (this.g = LinearToSRGB(et.g)),
      (this.b = LinearToSRGB(et.b)),
      this
    );
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(et = SRGBColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), et),
      Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 +
        Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 +
        Math.round(clamp$1(_color.b * 255, 0, 255))
    );
  }
  getHexString(et = SRGBColorSpace) {
    return ("000000" + this.getHex(et).toString(16)).slice(-6);
  }
  getHSL(et, nt = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), nt);
    const rt = _color.r,
      it = _color.g,
      st = _color.b,
      ot = Math.max(rt, it, st),
      at = Math.min(rt, it, st);
    let lt, ct;
    const ut = (at + ot) / 2;
    if (at === ot) (lt = 0), (ct = 0);
    else {
      const ft = ot - at;
      switch (((ct = ut <= 0.5 ? ft / (ot + at) : ft / (2 - ot - at)), ot)) {
        case rt:
          lt = (it - st) / ft + (it < st ? 6 : 0);
          break;
        case it:
          lt = (st - rt) / ft + 2;
          break;
        case st:
          lt = (rt - it) / ft + 4;
          break;
      }
      lt /= 6;
    }
    return (et.h = lt), (et.s = ct), (et.l = ut), et;
  }
  getRGB(et, nt = ColorManagement.workingColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), nt),
      (et.r = _color.r),
      (et.g = _color.g),
      (et.b = _color.b),
      et
    );
  }
  getStyle(et = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), et);
    const nt = _color.r,
      rt = _color.g,
      it = _color.b;
    return et !== SRGBColorSpace
      ? `color(${et} ${nt.toFixed(3)} ${rt.toFixed(3)} ${it.toFixed(3)})`
      : `rgb(${Math.round(nt * 255)},${Math.round(rt * 255)},${Math.round(
          it * 255
        )})`;
  }
  offsetHSL(et, nt, rt) {
    return (
      this.getHSL(_hslA), this.setHSL(_hslA.h + et, _hslA.s + nt, _hslA.l + rt)
    );
  }
  add(et) {
    return (this.r += et.r), (this.g += et.g), (this.b += et.b), this;
  }
  addColors(et, nt) {
    return (
      (this.r = et.r + nt.r),
      (this.g = et.g + nt.g),
      (this.b = et.b + nt.b),
      this
    );
  }
  addScalar(et) {
    return (this.r += et), (this.g += et), (this.b += et), this;
  }
  sub(et) {
    return (
      (this.r = Math.max(0, this.r - et.r)),
      (this.g = Math.max(0, this.g - et.g)),
      (this.b = Math.max(0, this.b - et.b)),
      this
    );
  }
  multiply(et) {
    return (this.r *= et.r), (this.g *= et.g), (this.b *= et.b), this;
  }
  multiplyScalar(et) {
    return (this.r *= et), (this.g *= et), (this.b *= et), this;
  }
  lerp(et, nt) {
    return (
      (this.r += (et.r - this.r) * nt),
      (this.g += (et.g - this.g) * nt),
      (this.b += (et.b - this.b) * nt),
      this
    );
  }
  lerpColors(et, nt, rt) {
    return (
      (this.r = et.r + (nt.r - et.r) * rt),
      (this.g = et.g + (nt.g - et.g) * rt),
      (this.b = et.b + (nt.b - et.b) * rt),
      this
    );
  }
  lerpHSL(et, nt) {
    this.getHSL(_hslA), et.getHSL(_hslB);
    const rt = lerp(_hslA.h, _hslB.h, nt),
      it = lerp(_hslA.s, _hslB.s, nt),
      st = lerp(_hslA.l, _hslB.l, nt);
    return this.setHSL(rt, it, st), this;
  }
  setFromVector3(et) {
    return (this.r = et.x), (this.g = et.y), (this.b = et.z), this;
  }
  applyMatrix3(et) {
    const nt = this.r,
      rt = this.g,
      it = this.b,
      st = et.elements;
    return (
      (this.r = st[0] * nt + st[3] * rt + st[6] * it),
      (this.g = st[1] * nt + st[4] * rt + st[7] * it),
      (this.b = st[2] * nt + st[5] * rt + st[8] * it),
      this
    );
  }
  equals(et) {
    return et.r === this.r && et.g === this.g && et.b === this.b;
  }
  fromArray(et, nt = 0) {
    return (
      (this.r = et[nt]), (this.g = et[nt + 1]), (this.b = et[nt + 2]), this
    );
  }
  toArray(et = [], nt = 0) {
    return (et[nt] = this.r), (et[nt + 1] = this.g), (et[nt + 2] = this.b), et;
  }
  fromBufferAttribute(et, nt) {
    return (
      (this.r = et.getX(nt)),
      (this.g = et.getY(nt)),
      (this.b = et.getZ(nt)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const _color = new Color();
Color.NAMES = _colorKeywords;
class MeshBasicMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.lightMap = et.lightMap),
      (this.lightMapIntensity = et.lightMapIntensity),
      (this.aoMap = et.aoMap),
      (this.aoMapIntensity = et.aoMapIntensity),
      (this.specularMap = et.specularMap),
      (this.alphaMap = et.alphaMap),
      (this.envMap = et.envMap),
      (this.combine = et.combine),
      (this.reflectivity = et.reflectivity),
      (this.refractionRatio = et.refractionRatio),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.wireframeLinecap = et.wireframeLinecap),
      (this.wireframeLinejoin = et.wireframeLinejoin),
      (this.fog = et.fog),
      this
    );
  }
}
const _tables = _generateTables();
function _generateTables() {
  const tt = new ArrayBuffer(4),
    et = new Float32Array(tt),
    nt = new Uint32Array(tt),
    rt = new Uint32Array(512),
    it = new Uint32Array(512);
  for (let lt = 0; lt < 256; ++lt) {
    const ct = lt - 127;
    ct < -27
      ? ((rt[lt] = 0),
        (rt[lt | 256] = 32768),
        (it[lt] = 24),
        (it[lt | 256] = 24))
      : ct < -14
      ? ((rt[lt] = 1024 >> (-ct - 14)),
        (rt[lt | 256] = (1024 >> (-ct - 14)) | 32768),
        (it[lt] = -ct - 1),
        (it[lt | 256] = -ct - 1))
      : ct <= 15
      ? ((rt[lt] = (ct + 15) << 10),
        (rt[lt | 256] = ((ct + 15) << 10) | 32768),
        (it[lt] = 13),
        (it[lt | 256] = 13))
      : ct < 128
      ? ((rt[lt] = 31744),
        (rt[lt | 256] = 64512),
        (it[lt] = 24),
        (it[lt | 256] = 24))
      : ((rt[lt] = 31744),
        (rt[lt | 256] = 64512),
        (it[lt] = 13),
        (it[lt | 256] = 13));
  }
  const st = new Uint32Array(2048),
    ot = new Uint32Array(64),
    at = new Uint32Array(64);
  for (let lt = 1; lt < 1024; ++lt) {
    let ct = lt << 13,
      ut = 0;
    for (; !(ct & 8388608); ) (ct <<= 1), (ut -= 8388608);
    (ct &= -8388609), (ut += 947912704), (st[lt] = ct | ut);
  }
  for (let lt = 1024; lt < 2048; ++lt) st[lt] = 939524096 + ((lt - 1024) << 13);
  for (let lt = 1; lt < 31; ++lt) ot[lt] = lt << 23;
  (ot[31] = 1199570944), (ot[32] = 2147483648);
  for (let lt = 33; lt < 63; ++lt) ot[lt] = 2147483648 + ((lt - 32) << 23);
  ot[63] = 3347054592;
  for (let lt = 1; lt < 64; ++lt) lt !== 32 && (at[lt] = 1024);
  return {
    floatView: et,
    uint32View: nt,
    baseTable: rt,
    shiftTable: it,
    mantissaTable: st,
    exponentTable: ot,
    offsetTable: at,
  };
}
function toHalfFloat(tt) {
  Math.abs(tt) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (tt = clamp$1(tt, -65504, 65504)),
    (_tables.floatView[0] = tt);
  const et = _tables.uint32View[0],
    nt = (et >> 23) & 511;
  return _tables.baseTable[nt] + ((et & 8388607) >> _tables.shiftTable[nt]);
}
function fromHalfFloat(tt) {
  const et = tt >> 10;
  return (
    (_tables.uint32View[0] =
      _tables.mantissaTable[_tables.offsetTable[et] + (tt & 1023)] +
      _tables.exponentTable[et]),
    _tables.floatView[0]
  );
}
const DataUtils = { toHalfFloat, fromHalfFloat },
  _vector$8 = new Vector3(),
  _vector2$1 = new Vector2();
class BufferAttribute {
  constructor(et, nt, rt = !1) {
    if (Array.isArray(et))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = et),
      (this.itemSize = nt),
      (this.count = et !== void 0 ? et.length / nt : 0),
      (this.normalized = rt),
      (this.usage = StaticDrawUsage),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = FloatType),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(et) {
    et === !0 && this.version++;
  }
  setUsage(et) {
    return (this.usage = et), this;
  }
  copy(et) {
    return (
      (this.name = et.name),
      (this.array = new et.array.constructor(et.array)),
      (this.itemSize = et.itemSize),
      (this.count = et.count),
      (this.normalized = et.normalized),
      (this.usage = et.usage),
      (this.gpuType = et.gpuType),
      this
    );
  }
  copyAt(et, nt, rt) {
    (et *= this.itemSize), (rt *= nt.itemSize);
    for (let it = 0, st = this.itemSize; it < st; it++)
      this.array[et + it] = nt.array[rt + it];
    return this;
  }
  copyArray(et) {
    return this.array.set(et), this;
  }
  applyMatrix3(et) {
    if (this.itemSize === 2)
      for (let nt = 0, rt = this.count; nt < rt; nt++)
        _vector2$1.fromBufferAttribute(this, nt),
          _vector2$1.applyMatrix3(et),
          this.setXY(nt, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let nt = 0, rt = this.count; nt < rt; nt++)
        _vector$8.fromBufferAttribute(this, nt),
          _vector$8.applyMatrix3(et),
          this.setXYZ(nt, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  applyMatrix4(et) {
    for (let nt = 0, rt = this.count; nt < rt; nt++)
      _vector$8.fromBufferAttribute(this, nt),
        _vector$8.applyMatrix4(et),
        this.setXYZ(nt, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  applyNormalMatrix(et) {
    for (let nt = 0, rt = this.count; nt < rt; nt++)
      _vector$8.fromBufferAttribute(this, nt),
        _vector$8.applyNormalMatrix(et),
        this.setXYZ(nt, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  transformDirection(et) {
    for (let nt = 0, rt = this.count; nt < rt; nt++)
      _vector$8.fromBufferAttribute(this, nt),
        _vector$8.transformDirection(et),
        this.setXYZ(nt, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  set(et, nt = 0) {
    return this.array.set(et, nt), this;
  }
  getComponent(et, nt) {
    let rt = this.array[et * this.itemSize + nt];
    return this.normalized && (rt = denormalize(rt, this.array)), rt;
  }
  setComponent(et, nt, rt) {
    return (
      this.normalized && (rt = normalize(rt, this.array)),
      (this.array[et * this.itemSize + nt] = rt),
      this
    );
  }
  getX(et) {
    let nt = this.array[et * this.itemSize];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setX(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize] = nt),
      this
    );
  }
  getY(et) {
    let nt = this.array[et * this.itemSize + 1];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setY(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 1] = nt),
      this
    );
  }
  getZ(et) {
    let nt = this.array[et * this.itemSize + 2];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setZ(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 2] = nt),
      this
    );
  }
  getW(et) {
    let nt = this.array[et * this.itemSize + 3];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setW(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 3] = nt),
      this
    );
  }
  setXY(et, nt, rt) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)), (rt = normalize(rt, this.array))),
      (this.array[et + 0] = nt),
      (this.array[et + 1] = rt),
      this
    );
  }
  setXYZ(et, nt, rt, it) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array))),
      (this.array[et + 0] = nt),
      (this.array[et + 1] = rt),
      (this.array[et + 2] = it),
      this
    );
  }
  setXYZW(et, nt, rt, it, st) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array)),
        (st = normalize(st, this.array))),
      (this.array[et + 0] = nt),
      (this.array[et + 1] = rt),
      (this.array[et + 2] = it),
      (this.array[et + 3] = st),
      this
    );
  }
  onUpload(et) {
    return (this.onUploadCallback = et), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const et = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (et.name = this.name),
      this.usage !== StaticDrawUsage && (et.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (et.updateRange = this.updateRange),
      et
    );
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Int8Array(et), nt, rt);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Uint8Array(et), nt, rt);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Uint8ClampedArray(et), nt, rt);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Int16Array(et), nt, rt);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Uint16Array(et), nt, rt);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Int32Array(et), nt, rt);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Uint32Array(et), nt, rt);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Uint16Array(et), nt, rt), (this.isFloat16BufferAttribute = !0);
  }
  getX(et) {
    let nt = fromHalfFloat(this.array[et * this.itemSize]);
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setX(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize] = toHalfFloat(nt)),
      this
    );
  }
  getY(et) {
    let nt = fromHalfFloat(this.array[et * this.itemSize + 1]);
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setY(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 1] = toHalfFloat(nt)),
      this
    );
  }
  getZ(et) {
    let nt = fromHalfFloat(this.array[et * this.itemSize + 2]);
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setZ(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 2] = toHalfFloat(nt)),
      this
    );
  }
  getW(et) {
    let nt = fromHalfFloat(this.array[et * this.itemSize + 3]);
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setW(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.array[et * this.itemSize + 3] = toHalfFloat(nt)),
      this
    );
  }
  setXY(et, nt, rt) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)), (rt = normalize(rt, this.array))),
      (this.array[et + 0] = toHalfFloat(nt)),
      (this.array[et + 1] = toHalfFloat(rt)),
      this
    );
  }
  setXYZ(et, nt, rt, it) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array))),
      (this.array[et + 0] = toHalfFloat(nt)),
      (this.array[et + 1] = toHalfFloat(rt)),
      (this.array[et + 2] = toHalfFloat(it)),
      this
    );
  }
  setXYZW(et, nt, rt, it, st) {
    return (
      (et *= this.itemSize),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array)),
        (st = normalize(st, this.array))),
      (this.array[et + 0] = toHalfFloat(nt)),
      (this.array[et + 1] = toHalfFloat(rt)),
      (this.array[et + 2] = toHalfFloat(it)),
      (this.array[et + 3] = toHalfFloat(st)),
      this
    );
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Float32Array(et), nt, rt);
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(et, nt, rt) {
    super(new Float64Array(et), nt, rt);
  }
}
let _id$2 = 0;
const _m1 = new Matrix4(),
  _obj = new Object3D(),
  _offset = new Vector3(),
  _box$1$1 = new Box3(),
  _boxMorphTargets = new Box3(),
  _vector$7 = new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _id$2++ }),
      (this.uuid = generateUUID$1()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(et) {
    return (
      Array.isArray(et)
        ? (this.index = new (
            arrayNeedsUint32(et) ? Uint32BufferAttribute : Uint16BufferAttribute
          )(et, 1))
        : (this.index = et),
      this
    );
  }
  getAttribute(et) {
    return this.attributes[et];
  }
  setAttribute(et, nt) {
    return (this.attributes[et] = nt), this;
  }
  deleteAttribute(et) {
    return delete this.attributes[et], this;
  }
  hasAttribute(et) {
    return this.attributes[et] !== void 0;
  }
  addGroup(et, nt, rt = 0) {
    this.groups.push({ start: et, count: nt, materialIndex: rt });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(et, nt) {
    (this.drawRange.start = et), (this.drawRange.count = nt);
  }
  applyMatrix4(et) {
    const nt = this.attributes.position;
    nt !== void 0 && (nt.applyMatrix4(et), (nt.needsUpdate = !0));
    const rt = this.attributes.normal;
    if (rt !== void 0) {
      const st = new Matrix3().getNormalMatrix(et);
      rt.applyNormalMatrix(st), (rt.needsUpdate = !0);
    }
    const it = this.attributes.tangent;
    return (
      it !== void 0 && (it.transformDirection(et), (it.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(et) {
    return _m1.makeRotationFromQuaternion(et), this.applyMatrix4(_m1), this;
  }
  rotateX(et) {
    return _m1.makeRotationX(et), this.applyMatrix4(_m1), this;
  }
  rotateY(et) {
    return _m1.makeRotationY(et), this.applyMatrix4(_m1), this;
  }
  rotateZ(et) {
    return _m1.makeRotationZ(et), this.applyMatrix4(_m1), this;
  }
  translate(et, nt, rt) {
    return _m1.makeTranslation(et, nt, rt), this.applyMatrix4(_m1), this;
  }
  scale(et, nt, rt) {
    return _m1.makeScale(et, nt, rt), this.applyMatrix4(_m1), this;
  }
  lookAt(et) {
    return (
      _obj.lookAt(et), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_offset).negate(),
      this.translate(_offset.x, _offset.y, _offset.z),
      this
    );
  }
  setFromPoints(et) {
    const nt = [];
    for (let rt = 0, it = et.length; rt < it; rt++) {
      const st = et[rt];
      nt.push(st.x, st.y, st.z || 0);
    }
    return (
      this.setAttribute("position", new Float32BufferAttribute(nt, 3)), this
    );
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const et = this.attributes.position,
      nt = this.morphAttributes.position;
    if (et && et.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (et !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(et), nt))
        for (let rt = 0, it = nt.length; rt < it; rt++) {
          const st = nt[rt];
          _box$1$1.setFromBufferAttribute(st),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(this.boundingBox.min, _box$1$1.min),
                this.boundingBox.expandByPoint(_vector$7),
                _vector$7.addVectors(this.boundingBox.max, _box$1$1.max),
                this.boundingBox.expandByPoint(_vector$7))
              : (this.boundingBox.expandByPoint(_box$1$1.min),
                this.boundingBox.expandByPoint(_box$1$1.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const et = this.attributes.position,
      nt = this.morphAttributes.position;
    if (et && et.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (et) {
      const rt = this.boundingSphere.center;
      if ((_box$1$1.setFromBufferAttribute(et), nt))
        for (let st = 0, ot = nt.length; st < ot; st++) {
          const at = nt[st];
          _boxMorphTargets.setFromBufferAttribute(at),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(_box$1$1.min, _boxMorphTargets.min),
                _box$1$1.expandByPoint(_vector$7),
                _vector$7.addVectors(_box$1$1.max, _boxMorphTargets.max),
                _box$1$1.expandByPoint(_vector$7))
              : (_box$1$1.expandByPoint(_boxMorphTargets.min),
                _box$1$1.expandByPoint(_boxMorphTargets.max));
        }
      _box$1$1.getCenter(rt);
      let it = 0;
      for (let st = 0, ot = et.count; st < ot; st++)
        _vector$7.fromBufferAttribute(et, st),
          (it = Math.max(it, rt.distanceToSquared(_vector$7)));
      if (nt)
        for (let st = 0, ot = nt.length; st < ot; st++) {
          const at = nt[st],
            lt = this.morphTargetsRelative;
          for (let ct = 0, ut = at.count; ct < ut; ct++)
            _vector$7.fromBufferAttribute(at, ct),
              lt &&
                (_offset.fromBufferAttribute(et, ct), _vector$7.add(_offset)),
              (it = Math.max(it, rt.distanceToSquared(_vector$7)));
        }
      (this.boundingSphere.radius = Math.sqrt(it)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const et = this.index,
      nt = this.attributes;
    if (
      et === null ||
      nt.position === void 0 ||
      nt.normal === void 0 ||
      nt.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const rt = et.array,
      it = nt.position.array,
      st = nt.normal.array,
      ot = nt.uv.array,
      at = it.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * at), 4)
      );
    const lt = this.getAttribute("tangent").array,
      ct = [],
      ut = [];
    for (let Ft = 0; Ft < at; Ft++)
      (ct[Ft] = new Vector3()), (ut[Ft] = new Vector3());
    const ft = new Vector3(),
      ht = new Vector3(),
      mt = new Vector3(),
      vt = new Vector2(),
      yt = new Vector2(),
      Et = new Vector2(),
      pt = new Vector3(),
      xt = new Vector3();
    function St(Ft, Vt, $t) {
      ft.fromArray(it, Ft * 3),
        ht.fromArray(it, Vt * 3),
        mt.fromArray(it, $t * 3),
        vt.fromArray(ot, Ft * 2),
        yt.fromArray(ot, Vt * 2),
        Et.fromArray(ot, $t * 2),
        ht.sub(ft),
        mt.sub(ft),
        yt.sub(vt),
        Et.sub(vt);
      const Kt = 1 / (yt.x * Et.y - Et.x * yt.y);
      isFinite(Kt) &&
        (pt
          .copy(ht)
          .multiplyScalar(Et.y)
          .addScaledVector(mt, -yt.y)
          .multiplyScalar(Kt),
        xt
          .copy(mt)
          .multiplyScalar(yt.x)
          .addScaledVector(ht, -Et.x)
          .multiplyScalar(Kt),
        ct[Ft].add(pt),
        ct[Vt].add(pt),
        ct[$t].add(pt),
        ut[Ft].add(xt),
        ut[Vt].add(xt),
        ut[$t].add(xt));
    }
    let At = this.groups;
    At.length === 0 && (At = [{ start: 0, count: rt.length }]);
    for (let Ft = 0, Vt = At.length; Ft < Vt; ++Ft) {
      const $t = At[Ft],
        Kt = $t.start,
        Ht = $t.count;
      for (let Wt = Kt, kt = Kt + Ht; Wt < kt; Wt += 3)
        St(rt[Wt + 0], rt[Wt + 1], rt[Wt + 2]);
    }
    const Ct = new Vector3(),
      Mt = new Vector3(),
      wt = new Vector3(),
      Bt = new Vector3();
    function It(Ft) {
      wt.fromArray(st, Ft * 3), Bt.copy(wt);
      const Vt = ct[Ft];
      Ct.copy(Vt),
        Ct.sub(wt.multiplyScalar(wt.dot(Vt))).normalize(),
        Mt.crossVectors(Bt, Vt);
      const Kt = Mt.dot(ut[Ft]) < 0 ? -1 : 1;
      (lt[Ft * 4] = Ct.x),
        (lt[Ft * 4 + 1] = Ct.y),
        (lt[Ft * 4 + 2] = Ct.z),
        (lt[Ft * 4 + 3] = Kt);
    }
    for (let Ft = 0, Vt = At.length; Ft < Vt; ++Ft) {
      const $t = At[Ft],
        Kt = $t.start,
        Ht = $t.count;
      for (let Wt = Kt, kt = Kt + Ht; Wt < kt; Wt += 3)
        It(rt[Wt + 0]), It(rt[Wt + 1]), It(rt[Wt + 2]);
    }
  }
  computeVertexNormals() {
    const et = this.index,
      nt = this.getAttribute("position");
    if (nt !== void 0) {
      let rt = this.getAttribute("normal");
      if (rt === void 0)
        (rt = new BufferAttribute(new Float32Array(nt.count * 3), 3)),
          this.setAttribute("normal", rt);
      else
        for (let ht = 0, mt = rt.count; ht < mt; ht++) rt.setXYZ(ht, 0, 0, 0);
      const it = new Vector3(),
        st = new Vector3(),
        ot = new Vector3(),
        at = new Vector3(),
        lt = new Vector3(),
        ct = new Vector3(),
        ut = new Vector3(),
        ft = new Vector3();
      if (et)
        for (let ht = 0, mt = et.count; ht < mt; ht += 3) {
          const vt = et.getX(ht + 0),
            yt = et.getX(ht + 1),
            Et = et.getX(ht + 2);
          it.fromBufferAttribute(nt, vt),
            st.fromBufferAttribute(nt, yt),
            ot.fromBufferAttribute(nt, Et),
            ut.subVectors(ot, st),
            ft.subVectors(it, st),
            ut.cross(ft),
            at.fromBufferAttribute(rt, vt),
            lt.fromBufferAttribute(rt, yt),
            ct.fromBufferAttribute(rt, Et),
            at.add(ut),
            lt.add(ut),
            ct.add(ut),
            rt.setXYZ(vt, at.x, at.y, at.z),
            rt.setXYZ(yt, lt.x, lt.y, lt.z),
            rt.setXYZ(Et, ct.x, ct.y, ct.z);
        }
      else
        for (let ht = 0, mt = nt.count; ht < mt; ht += 3)
          it.fromBufferAttribute(nt, ht + 0),
            st.fromBufferAttribute(nt, ht + 1),
            ot.fromBufferAttribute(nt, ht + 2),
            ut.subVectors(ot, st),
            ft.subVectors(it, st),
            ut.cross(ft),
            rt.setXYZ(ht + 0, ut.x, ut.y, ut.z),
            rt.setXYZ(ht + 1, ut.x, ut.y, ut.z),
            rt.setXYZ(ht + 2, ut.x, ut.y, ut.z);
      this.normalizeNormals(), (rt.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const et = this.attributes.normal;
    for (let nt = 0, rt = et.count; nt < rt; nt++)
      _vector$7.fromBufferAttribute(et, nt),
        _vector$7.normalize(),
        et.setXYZ(nt, _vector$7.x, _vector$7.y, _vector$7.z);
  }
  toNonIndexed() {
    function et(at, lt) {
      const ct = at.array,
        ut = at.itemSize,
        ft = at.normalized,
        ht = new ct.constructor(lt.length * ut);
      let mt = 0,
        vt = 0;
      for (let yt = 0, Et = lt.length; yt < Et; yt++) {
        at.isInterleavedBufferAttribute
          ? (mt = lt[yt] * at.data.stride + at.offset)
          : (mt = lt[yt] * ut);
        for (let pt = 0; pt < ut; pt++) ht[vt++] = ct[mt++];
      }
      return new BufferAttribute(ht, ut, ft);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const nt = new BufferGeometry(),
      rt = this.index.array,
      it = this.attributes;
    for (const at in it) {
      const lt = it[at],
        ct = et(lt, rt);
      nt.setAttribute(at, ct);
    }
    const st = this.morphAttributes;
    for (const at in st) {
      const lt = [],
        ct = st[at];
      for (let ut = 0, ft = ct.length; ut < ft; ut++) {
        const ht = ct[ut],
          mt = et(ht, rt);
        lt.push(mt);
      }
      nt.morphAttributes[at] = lt;
    }
    nt.morphTargetsRelative = this.morphTargetsRelative;
    const ot = this.groups;
    for (let at = 0, lt = ot.length; at < lt; at++) {
      const ct = ot[at];
      nt.addGroup(ct.start, ct.count, ct.materialIndex);
    }
    return nt;
  }
  toJSON() {
    const et = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((et.uuid = this.uuid),
      (et.type = this.type),
      this.name !== "" && (et.name = this.name),
      Object.keys(this.userData).length > 0 && (et.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const lt = this.parameters;
      for (const ct in lt) lt[ct] !== void 0 && (et[ct] = lt[ct]);
      return et;
    }
    et.data = { attributes: {} };
    const nt = this.index;
    nt !== null &&
      (et.data.index = {
        type: nt.array.constructor.name,
        array: Array.prototype.slice.call(nt.array),
      });
    const rt = this.attributes;
    for (const lt in rt) {
      const ct = rt[lt];
      et.data.attributes[lt] = ct.toJSON(et.data);
    }
    const it = {};
    let st = !1;
    for (const lt in this.morphAttributes) {
      const ct = this.morphAttributes[lt],
        ut = [];
      for (let ft = 0, ht = ct.length; ft < ht; ft++) {
        const mt = ct[ft];
        ut.push(mt.toJSON(et.data));
      }
      ut.length > 0 && ((it[lt] = ut), (st = !0));
    }
    st &&
      ((et.data.morphAttributes = it),
      (et.data.morphTargetsRelative = this.morphTargetsRelative));
    const ot = this.groups;
    ot.length > 0 && (et.data.groups = JSON.parse(JSON.stringify(ot)));
    const at = this.boundingSphere;
    return (
      at !== null &&
        (et.data.boundingSphere = {
          center: at.center.toArray(),
          radius: at.radius,
        }),
      et
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const nt = {};
    this.name = et.name;
    const rt = et.index;
    rt !== null && this.setIndex(rt.clone(nt));
    const it = et.attributes;
    for (const ct in it) {
      const ut = it[ct];
      this.setAttribute(ct, ut.clone(nt));
    }
    const st = et.morphAttributes;
    for (const ct in st) {
      const ut = [],
        ft = st[ct];
      for (let ht = 0, mt = ft.length; ht < mt; ht++) ut.push(ft[ht].clone(nt));
      this.morphAttributes[ct] = ut;
    }
    this.morphTargetsRelative = et.morphTargetsRelative;
    const ot = et.groups;
    for (let ct = 0, ut = ot.length; ct < ut; ct++) {
      const ft = ot[ct];
      this.addGroup(ft.start, ft.count, ft.materialIndex);
    }
    const at = et.boundingBox;
    at !== null && (this.boundingBox = at.clone());
    const lt = et.boundingSphere;
    return (
      lt !== null && (this.boundingSphere = lt.clone()),
      (this.drawRange.start = et.drawRange.start),
      (this.drawRange.count = et.drawRange.count),
      (this.userData = et.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = new Matrix4(),
  _ray$3 = new Ray(),
  _sphere$5 = new Sphere(),
  _sphereHitAt = new Vector3(),
  _vA$1 = new Vector3(),
  _vB$1 = new Vector3(),
  _vC$1 = new Vector3(),
  _tempA = new Vector3(),
  _morphA = new Vector3(),
  _uvA$1 = new Vector2(),
  _uvB$1 = new Vector2(),
  _uvC$1 = new Vector2(),
  _normalA = new Vector3(),
  _normalB = new Vector3(),
  _normalC = new Vector3(),
  _intersectionPoint = new Vector3(),
  _intersectionPointWorld = new Vector3();
class Mesh extends Object3D {
  constructor(et = new BufferGeometry(), nt = new MeshBasicMaterial()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = et),
      (this.material = nt),
      this.updateMorphTargets();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      et.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = et.morphTargetInfluences.slice()),
      et.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          et.morphTargetDictionary
        )),
      (this.material = Array.isArray(et.material)
        ? et.material.slice()
        : et.material),
      (this.geometry = et.geometry),
      this
    );
  }
  updateMorphTargets() {
    const nt = this.geometry.morphAttributes,
      rt = Object.keys(nt);
    if (rt.length > 0) {
      const it = nt[rt[0]];
      if (it !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let st = 0, ot = it.length; st < ot; st++) {
          const at = it[st].name || String(st);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[at] = st);
        }
      }
    }
  }
  getVertexPosition(et, nt) {
    const rt = this.geometry,
      it = rt.attributes.position,
      st = rt.morphAttributes.position,
      ot = rt.morphTargetsRelative;
    nt.fromBufferAttribute(it, et);
    const at = this.morphTargetInfluences;
    if (st && at) {
      _morphA.set(0, 0, 0);
      for (let lt = 0, ct = st.length; lt < ct; lt++) {
        const ut = at[lt],
          ft = st[lt];
        ut !== 0 &&
          (_tempA.fromBufferAttribute(ft, et),
          ot
            ? _morphA.addScaledVector(_tempA, ut)
            : _morphA.addScaledVector(_tempA.sub(nt), ut));
      }
      nt.add(_morphA);
    }
    return nt;
  }
  raycast(et, nt) {
    const rt = this.geometry,
      it = this.material,
      st = this.matrixWorld;
    it !== void 0 &&
      (rt.boundingSphere === null && rt.computeBoundingSphere(),
      _sphere$5.copy(rt.boundingSphere),
      _sphere$5.applyMatrix4(st),
      _ray$3.copy(et.ray).recast(et.near),
      !(
        _sphere$5.containsPoint(_ray$3.origin) === !1 &&
        (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null ||
          _ray$3.origin.distanceToSquared(_sphereHitAt) >
            (et.far - et.near) ** 2)
      ) &&
        (_inverseMatrix$3.copy(st).invert(),
        _ray$3.copy(et.ray).applyMatrix4(_inverseMatrix$3),
        !(
          rt.boundingBox !== null && _ray$3.intersectsBox(rt.boundingBox) === !1
        ) && this._computeIntersections(et, nt, _ray$3)));
  }
  _computeIntersections(et, nt, rt) {
    let it;
    const st = this.geometry,
      ot = this.material,
      at = st.index,
      lt = st.attributes.position,
      ct = st.attributes.uv,
      ut = st.attributes.uv1,
      ft = st.attributes.normal,
      ht = st.groups,
      mt = st.drawRange;
    if (at !== null)
      if (Array.isArray(ot))
        for (let vt = 0, yt = ht.length; vt < yt; vt++) {
          const Et = ht[vt],
            pt = ot[Et.materialIndex],
            xt = Math.max(Et.start, mt.start),
            St = Math.min(
              at.count,
              Math.min(Et.start + Et.count, mt.start + mt.count)
            );
          for (let At = xt, Ct = St; At < Ct; At += 3) {
            const Mt = at.getX(At),
              wt = at.getX(At + 1),
              Bt = at.getX(At + 2);
            (it = checkGeometryIntersection(
              this,
              pt,
              et,
              rt,
              ct,
              ut,
              ft,
              Mt,
              wt,
              Bt
            )),
              it &&
                ((it.faceIndex = Math.floor(At / 3)),
                (it.face.materialIndex = Et.materialIndex),
                nt.push(it));
          }
        }
      else {
        const vt = Math.max(0, mt.start),
          yt = Math.min(at.count, mt.start + mt.count);
        for (let Et = vt, pt = yt; Et < pt; Et += 3) {
          const xt = at.getX(Et),
            St = at.getX(Et + 1),
            At = at.getX(Et + 2);
          (it = checkGeometryIntersection(
            this,
            ot,
            et,
            rt,
            ct,
            ut,
            ft,
            xt,
            St,
            At
          )),
            it && ((it.faceIndex = Math.floor(Et / 3)), nt.push(it));
        }
      }
    else if (lt !== void 0)
      if (Array.isArray(ot))
        for (let vt = 0, yt = ht.length; vt < yt; vt++) {
          const Et = ht[vt],
            pt = ot[Et.materialIndex],
            xt = Math.max(Et.start, mt.start),
            St = Math.min(
              lt.count,
              Math.min(Et.start + Et.count, mt.start + mt.count)
            );
          for (let At = xt, Ct = St; At < Ct; At += 3) {
            const Mt = At,
              wt = At + 1,
              Bt = At + 2;
            (it = checkGeometryIntersection(
              this,
              pt,
              et,
              rt,
              ct,
              ut,
              ft,
              Mt,
              wt,
              Bt
            )),
              it &&
                ((it.faceIndex = Math.floor(At / 3)),
                (it.face.materialIndex = Et.materialIndex),
                nt.push(it));
          }
        }
      else {
        const vt = Math.max(0, mt.start),
          yt = Math.min(lt.count, mt.start + mt.count);
        for (let Et = vt, pt = yt; Et < pt; Et += 3) {
          const xt = Et,
            St = Et + 1,
            At = Et + 2;
          (it = checkGeometryIntersection(
            this,
            ot,
            et,
            rt,
            ct,
            ut,
            ft,
            xt,
            St,
            At
          )),
            it && ((it.faceIndex = Math.floor(Et / 3)), nt.push(it));
        }
      }
  }
}
function checkIntersection(tt, et, nt, rt, it, st, ot, at) {
  let lt;
  if (
    (et.side === BackSide
      ? (lt = rt.intersectTriangle(ot, st, it, !0, at))
      : (lt = rt.intersectTriangle(it, st, ot, et.side === FrontSide, at)),
    lt === null)
  )
    return null;
  _intersectionPointWorld.copy(at),
    _intersectionPointWorld.applyMatrix4(tt.matrixWorld);
  const ct = nt.ray.origin.distanceTo(_intersectionPointWorld);
  return ct < nt.near || ct > nt.far
    ? null
    : { distance: ct, point: _intersectionPointWorld.clone(), object: tt };
}
function checkGeometryIntersection(tt, et, nt, rt, it, st, ot, at, lt, ct) {
  tt.getVertexPosition(at, _vA$1),
    tt.getVertexPosition(lt, _vB$1),
    tt.getVertexPosition(ct, _vC$1);
  const ut = checkIntersection(
    tt,
    et,
    nt,
    rt,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  );
  if (ut) {
    it &&
      (_uvA$1.fromBufferAttribute(it, at),
      _uvB$1.fromBufferAttribute(it, lt),
      _uvC$1.fromBufferAttribute(it, ct),
      (ut.uv = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2()
      ))),
      st &&
        (_uvA$1.fromBufferAttribute(st, at),
        _uvB$1.fromBufferAttribute(st, lt),
        _uvC$1.fromBufferAttribute(st, ct),
        (ut.uv1 = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _uvA$1,
          _uvB$1,
          _uvC$1,
          new Vector2()
        )),
        (ut.uv2 = ut.uv1)),
      ot &&
        (_normalA.fromBufferAttribute(ot, at),
        _normalB.fromBufferAttribute(ot, lt),
        _normalC.fromBufferAttribute(ot, ct),
        (ut.normal = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _normalA,
          _normalB,
          _normalC,
          new Vector3()
        )),
        ut.normal.dot(rt.direction) > 0 && ut.normal.multiplyScalar(-1));
    const ft = { a: at, b: lt, c: ct, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, ft.normal), (ut.face = ft);
  }
  return ut;
}
class BoxGeometry extends BufferGeometry {
  constructor(et = 1, nt = 1, rt = 1, it = 1, st = 1, ot = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: et,
        height: nt,
        depth: rt,
        widthSegments: it,
        heightSegments: st,
        depthSegments: ot,
      });
    const at = this;
    (it = Math.floor(it)), (st = Math.floor(st)), (ot = Math.floor(ot));
    const lt = [],
      ct = [],
      ut = [],
      ft = [];
    let ht = 0,
      mt = 0;
    vt("z", "y", "x", -1, -1, rt, nt, et, ot, st, 0),
      vt("z", "y", "x", 1, -1, rt, nt, -et, ot, st, 1),
      vt("x", "z", "y", 1, 1, et, rt, nt, it, ot, 2),
      vt("x", "z", "y", 1, -1, et, rt, -nt, it, ot, 3),
      vt("x", "y", "z", 1, -1, et, nt, rt, it, st, 4),
      vt("x", "y", "z", -1, -1, et, nt, -rt, it, st, 5),
      this.setIndex(lt),
      this.setAttribute("position", new Float32BufferAttribute(ct, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ut, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ft, 2));
    function vt(yt, Et, pt, xt, St, At, Ct, Mt, wt, Bt, It) {
      const Ft = At / wt,
        Vt = Ct / Bt,
        $t = At / 2,
        Kt = Ct / 2,
        Ht = Mt / 2,
        Wt = wt + 1,
        kt = Bt + 1;
      let Gt = 0,
        Pt = 0;
      const Rt = new Vector3();
      for (let Nt = 0; Nt < kt; Nt++) {
        const Dt = Nt * Vt - Kt;
        for (let zt = 0; zt < Wt; zt++) {
          const Yt = zt * Ft - $t;
          (Rt[yt] = Yt * xt),
            (Rt[Et] = Dt * St),
            (Rt[pt] = Ht),
            ct.push(Rt.x, Rt.y, Rt.z),
            (Rt[yt] = 0),
            (Rt[Et] = 0),
            (Rt[pt] = Mt > 0 ? 1 : -1),
            ut.push(Rt.x, Rt.y, Rt.z),
            ft.push(zt / wt),
            ft.push(1 - Nt / Bt),
            (Gt += 1);
        }
      }
      for (let Nt = 0; Nt < Bt; Nt++)
        for (let Dt = 0; Dt < wt; Dt++) {
          const zt = ht + Dt + Wt * Nt,
            Yt = ht + Dt + Wt * (Nt + 1),
            qt = ht + (Dt + 1) + Wt * (Nt + 1),
            Zt = ht + (Dt + 1) + Wt * Nt;
          lt.push(zt, Yt, Zt), lt.push(Yt, qt, Zt), (Pt += 6);
        }
      at.addGroup(mt, Pt, It), (mt += Pt), (ht += Gt);
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new BoxGeometry(
      et.width,
      et.height,
      et.depth,
      et.widthSegments,
      et.heightSegments,
      et.depthSegments
    );
  }
}
function cloneUniforms(tt) {
  const et = {};
  for (const nt in tt) {
    et[nt] = {};
    for (const rt in tt[nt]) {
      const it = tt[nt][rt];
      it &&
      (it.isColor ||
        it.isMatrix3 ||
        it.isMatrix4 ||
        it.isVector2 ||
        it.isVector3 ||
        it.isVector4 ||
        it.isTexture ||
        it.isQuaternion)
        ? it.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (et[nt][rt] = null))
          : (et[nt][rt] = it.clone())
        : Array.isArray(it)
        ? (et[nt][rt] = it.slice())
        : (et[nt][rt] = it);
    }
  }
  return et;
}
function mergeUniforms(tt) {
  const et = {};
  for (let nt = 0; nt < tt.length; nt++) {
    const rt = cloneUniforms(tt[nt]);
    for (const it in rt) et[it] = rt[it];
  }
  return et;
}
function cloneUniformsGroups(tt) {
  const et = [];
  for (let nt = 0; nt < tt.length; nt++) et.push(tt[nt].clone());
  return et;
}
function getUnlitUniformColorSpace(tt) {
  return tt.getRenderTarget() === null
    ? tt.outputColorSpace
    : ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(et) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = default_vertex),
      (this.fragmentShader = default_fragment),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      et !== void 0 && this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.fragmentShader = et.fragmentShader),
      (this.vertexShader = et.vertexShader),
      (this.uniforms = cloneUniforms(et.uniforms)),
      (this.uniformsGroups = cloneUniformsGroups(et.uniformsGroups)),
      (this.defines = Object.assign({}, et.defines)),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.fog = et.fog),
      (this.lights = et.lights),
      (this.clipping = et.clipping),
      (this.extensions = Object.assign({}, et.extensions)),
      (this.glslVersion = et.glslVersion),
      this
    );
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    (nt.glslVersion = this.glslVersion), (nt.uniforms = {});
    for (const it in this.uniforms) {
      const ot = this.uniforms[it].value;
      ot && ot.isTexture
        ? (nt.uniforms[it] = { type: "t", value: ot.toJSON(et).uuid })
        : ot && ot.isColor
        ? (nt.uniforms[it] = { type: "c", value: ot.getHex() })
        : ot && ot.isVector2
        ? (nt.uniforms[it] = { type: "v2", value: ot.toArray() })
        : ot && ot.isVector3
        ? (nt.uniforms[it] = { type: "v3", value: ot.toArray() })
        : ot && ot.isVector4
        ? (nt.uniforms[it] = { type: "v4", value: ot.toArray() })
        : ot && ot.isMatrix3
        ? (nt.uniforms[it] = { type: "m3", value: ot.toArray() })
        : ot && ot.isMatrix4
        ? (nt.uniforms[it] = { type: "m4", value: ot.toArray() })
        : (nt.uniforms[it] = { value: ot });
    }
    Object.keys(this.defines).length > 0 && (nt.defines = this.defines),
      (nt.vertexShader = this.vertexShader),
      (nt.fragmentShader = this.fragmentShader),
      (nt.lights = this.lights),
      (nt.clipping = this.clipping);
    const rt = {};
    for (const it in this.extensions)
      this.extensions[it] === !0 && (rt[it] = !0);
    return Object.keys(rt).length > 0 && (nt.extensions = rt), nt;
  }
}
class Camera extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = WebGLCoordinateSystem);
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      this.matrixWorldInverse.copy(et.matrixWorldInverse),
      this.projectionMatrix.copy(et.projectionMatrix),
      this.projectionMatrixInverse.copy(et.projectionMatrixInverse),
      (this.coordinateSystem = et.coordinateSystem),
      this
    );
  }
  getWorldDirection(et) {
    return super.getWorldDirection(et).negate();
  }
  updateMatrixWorld(et) {
    super.updateMatrixWorld(et),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(et, nt) {
    super.updateWorldMatrix(et, nt),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class PerspectiveCamera extends Camera {
  constructor(et = 50, nt = 1, rt = 0.1, it = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = et),
      (this.zoom = 1),
      (this.near = rt),
      (this.far = it),
      (this.focus = 10),
      (this.aspect = nt),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.fov = et.fov),
      (this.zoom = et.zoom),
      (this.near = et.near),
      (this.far = et.far),
      (this.focus = et.focus),
      (this.aspect = et.aspect),
      (this.view = et.view === null ? null : Object.assign({}, et.view)),
      (this.filmGauge = et.filmGauge),
      (this.filmOffset = et.filmOffset),
      this
    );
  }
  setFocalLength(et) {
    const nt = (0.5 * this.getFilmHeight()) / et;
    (this.fov = RAD2DEG * 2 * Math.atan(nt)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const et = Math.tan(DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / et;
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(et, nt, rt, it, st, ot) {
    (this.aspect = et / nt),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = et),
      (this.view.fullHeight = nt),
      (this.view.offsetX = rt),
      (this.view.offsetY = it),
      (this.view.width = st),
      (this.view.height = ot),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const et = this.near;
    let nt = (et * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom,
      rt = 2 * nt,
      it = this.aspect * rt,
      st = -0.5 * it;
    const ot = this.view;
    if (this.view !== null && this.view.enabled) {
      const lt = ot.fullWidth,
        ct = ot.fullHeight;
      (st += (ot.offsetX * it) / lt),
        (nt -= (ot.offsetY * rt) / ct),
        (it *= ot.width / lt),
        (rt *= ot.height / ct);
    }
    const at = this.filmOffset;
    at !== 0 && (st += (et * at) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        st,
        st + it,
        nt,
        nt - rt,
        et,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      (nt.object.fov = this.fov),
      (nt.object.zoom = this.zoom),
      (nt.object.near = this.near),
      (nt.object.far = this.far),
      (nt.object.focus = this.focus),
      (nt.object.aspect = this.aspect),
      this.view !== null && (nt.object.view = Object.assign({}, this.view)),
      (nt.object.filmGauge = this.filmGauge),
      (nt.object.filmOffset = this.filmOffset),
      nt
    );
  }
}
const fov = -90,
  aspect = 1;
class CubeCamera extends Object3D {
  constructor(et, nt, rt) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = rt),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const it = new PerspectiveCamera(fov, aspect, et, nt);
    (it.layers = this.layers), this.add(it);
    const st = new PerspectiveCamera(fov, aspect, et, nt);
    (st.layers = this.layers), this.add(st);
    const ot = new PerspectiveCamera(fov, aspect, et, nt);
    (ot.layers = this.layers), this.add(ot);
    const at = new PerspectiveCamera(fov, aspect, et, nt);
    (at.layers = this.layers), this.add(at);
    const lt = new PerspectiveCamera(fov, aspect, et, nt);
    (lt.layers = this.layers), this.add(lt);
    const ct = new PerspectiveCamera(fov, aspect, et, nt);
    (ct.layers = this.layers), this.add(ct);
  }
  updateCoordinateSystem() {
    const et = this.coordinateSystem,
      nt = this.children.concat(),
      [rt, it, st, ot, at, lt] = nt;
    for (const ct of nt) this.remove(ct);
    if (et === WebGLCoordinateSystem)
      rt.up.set(0, 1, 0),
        rt.lookAt(1, 0, 0),
        it.up.set(0, 1, 0),
        it.lookAt(-1, 0, 0),
        st.up.set(0, 0, -1),
        st.lookAt(0, 1, 0),
        ot.up.set(0, 0, 1),
        ot.lookAt(0, -1, 0),
        at.up.set(0, 1, 0),
        at.lookAt(0, 0, 1),
        lt.up.set(0, 1, 0),
        lt.lookAt(0, 0, -1);
    else if (et === WebGPUCoordinateSystem)
      rt.up.set(0, -1, 0),
        rt.lookAt(-1, 0, 0),
        it.up.set(0, -1, 0),
        it.lookAt(1, 0, 0),
        st.up.set(0, 0, 1),
        st.lookAt(0, 1, 0),
        ot.up.set(0, 0, -1),
        ot.lookAt(0, -1, 0),
        at.up.set(0, -1, 0),
        at.lookAt(0, 0, 1),
        lt.up.set(0, -1, 0),
        lt.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          et
      );
    for (const ct of nt) this.add(ct), ct.updateMatrixWorld();
  }
  update(et, nt) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: rt, activeMipmapLevel: it } = this;
    this.coordinateSystem !== et.coordinateSystem &&
      ((this.coordinateSystem = et.coordinateSystem),
      this.updateCoordinateSystem());
    const [st, ot, at, lt, ct, ut] = this.children,
      ft = et.getRenderTarget(),
      ht = et.getActiveCubeFace(),
      mt = et.getActiveMipmapLevel(),
      vt = et.xr.enabled;
    et.xr.enabled = !1;
    const yt = rt.texture.generateMipmaps;
    (rt.texture.generateMipmaps = !1),
      et.setRenderTarget(rt, 0, it),
      et.render(nt, st),
      et.setRenderTarget(rt, 1, it),
      et.render(nt, ot),
      et.setRenderTarget(rt, 2, it),
      et.render(nt, at),
      et.setRenderTarget(rt, 3, it),
      et.render(nt, lt),
      et.setRenderTarget(rt, 4, it),
      et.render(nt, ct),
      (rt.texture.generateMipmaps = yt),
      et.setRenderTarget(rt, 5, it),
      et.render(nt, ut),
      et.setRenderTarget(ft, ht, mt),
      (et.xr.enabled = vt),
      (rt.texture.needsPMREMUpdate = !0);
  }
}
class CubeTexture extends Texture {
  constructor(et, nt, rt, it, st, ot, at, lt, ct, ut) {
    (et = et !== void 0 ? et : []),
      (nt = nt !== void 0 ? nt : CubeReflectionMapping),
      super(et, nt, rt, it, st, ot, at, lt, ct, ut),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(et) {
    this.image = et;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(et = 1, nt = {}) {
    super(et, et, nt), (this.isWebGLCubeRenderTarget = !0);
    const rt = { width: et, height: et, depth: 1 },
      it = [rt, rt, rt, rt, rt, rt];
    nt.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (nt.colorSpace =
        nt.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.texture = new CubeTexture(
        it,
        nt.mapping,
        nt.wrapS,
        nt.wrapT,
        nt.magFilter,
        nt.minFilter,
        nt.format,
        nt.type,
        nt.anisotropy,
        nt.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        nt.generateMipmaps !== void 0 ? nt.generateMipmaps : !1),
      (this.texture.minFilter =
        nt.minFilter !== void 0 ? nt.minFilter : LinearFilter);
  }
  fromEquirectangularTexture(et, nt) {
    (this.texture.type = nt.type),
      (this.texture.colorSpace = nt.colorSpace),
      (this.texture.generateMipmaps = nt.generateMipmaps),
      (this.texture.minFilter = nt.minFilter),
      (this.texture.magFilter = nt.magFilter);
    const rt = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      it = new BoxGeometry(5, 5, 5),
      st = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(rt.uniforms),
        vertexShader: rt.vertexShader,
        fragmentShader: rt.fragmentShader,
        side: BackSide,
        blending: NoBlending,
      });
    st.uniforms.tEquirect.value = nt;
    const ot = new Mesh(it, st),
      at = nt.minFilter;
    return (
      nt.minFilter === LinearMipmapLinearFilter &&
        (nt.minFilter = LinearFilter),
      new CubeCamera(1, 10, this).update(et, ot),
      (nt.minFilter = at),
      ot.geometry.dispose(),
      ot.material.dispose(),
      this
    );
  }
  clear(et, nt, rt, it) {
    const st = et.getRenderTarget();
    for (let ot = 0; ot < 6; ot++)
      et.setRenderTarget(this, ot), et.clear(nt, rt, it);
    et.setRenderTarget(st);
  }
}
const _vector1 = new Vector3(),
  _vector2 = new Vector3(),
  _normalMatrix = new Matrix3();
class Plane {
  constructor(et = new Vector3(1, 0, 0), nt = 0) {
    (this.isPlane = !0), (this.normal = et), (this.constant = nt);
  }
  set(et, nt) {
    return this.normal.copy(et), (this.constant = nt), this;
  }
  setComponents(et, nt, rt, it) {
    return this.normal.set(et, nt, rt), (this.constant = it), this;
  }
  setFromNormalAndCoplanarPoint(et, nt) {
    return this.normal.copy(et), (this.constant = -nt.dot(this.normal)), this;
  }
  setFromCoplanarPoints(et, nt, rt) {
    const it = _vector1
      .subVectors(rt, nt)
      .cross(_vector2.subVectors(et, nt))
      .normalize();
    return this.setFromNormalAndCoplanarPoint(it, et), this;
  }
  copy(et) {
    return this.normal.copy(et.normal), (this.constant = et.constant), this;
  }
  normalize() {
    const et = 1 / this.normal.length();
    return this.normal.multiplyScalar(et), (this.constant *= et), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(et) {
    return this.normal.dot(et) + this.constant;
  }
  distanceToSphere(et) {
    return this.distanceToPoint(et.center) - et.radius;
  }
  projectPoint(et, nt) {
    return nt.copy(et).addScaledVector(this.normal, -this.distanceToPoint(et));
  }
  intersectLine(et, nt) {
    const rt = et.delta(_vector1),
      it = this.normal.dot(rt);
    if (it === 0)
      return this.distanceToPoint(et.start) === 0 ? nt.copy(et.start) : null;
    const st = -(et.start.dot(this.normal) + this.constant) / it;
    return st < 0 || st > 1 ? null : nt.copy(et.start).addScaledVector(rt, st);
  }
  intersectsLine(et) {
    const nt = this.distanceToPoint(et.start),
      rt = this.distanceToPoint(et.end);
    return (nt < 0 && rt > 0) || (rt < 0 && nt > 0);
  }
  intersectsBox(et) {
    return et.intersectsPlane(this);
  }
  intersectsSphere(et) {
    return et.intersectsPlane(this);
  }
  coplanarPoint(et) {
    return et.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(et, nt) {
    const rt = nt || _normalMatrix.getNormalMatrix(et),
      it = this.coplanarPoint(_vector1).applyMatrix4(et),
      st = this.normal.applyMatrix3(rt).normalize();
    return (this.constant = -it.dot(st)), this;
  }
  translate(et) {
    return (this.constant -= et.dot(this.normal)), this;
  }
  equals(et) {
    return et.normal.equals(this.normal) && et.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$4 = new Sphere(),
  _vector$6 = new Vector3();
class Frustum {
  constructor(
    et = new Plane(),
    nt = new Plane(),
    rt = new Plane(),
    it = new Plane(),
    st = new Plane(),
    ot = new Plane()
  ) {
    this.planes = [et, nt, rt, it, st, ot];
  }
  set(et, nt, rt, it, st, ot) {
    const at = this.planes;
    return (
      at[0].copy(et),
      at[1].copy(nt),
      at[2].copy(rt),
      at[3].copy(it),
      at[4].copy(st),
      at[5].copy(ot),
      this
    );
  }
  copy(et) {
    const nt = this.planes;
    for (let rt = 0; rt < 6; rt++) nt[rt].copy(et.planes[rt]);
    return this;
  }
  setFromProjectionMatrix(et, nt = WebGLCoordinateSystem) {
    const rt = this.planes,
      it = et.elements,
      st = it[0],
      ot = it[1],
      at = it[2],
      lt = it[3],
      ct = it[4],
      ut = it[5],
      ft = it[6],
      ht = it[7],
      mt = it[8],
      vt = it[9],
      yt = it[10],
      Et = it[11],
      pt = it[12],
      xt = it[13],
      St = it[14],
      At = it[15];
    if (
      (rt[0].setComponents(lt - st, ht - ct, Et - mt, At - pt).normalize(),
      rt[1].setComponents(lt + st, ht + ct, Et + mt, At + pt).normalize(),
      rt[2].setComponents(lt + ot, ht + ut, Et + vt, At + xt).normalize(),
      rt[3].setComponents(lt - ot, ht - ut, Et - vt, At - xt).normalize(),
      rt[4].setComponents(lt - at, ht - ft, Et - yt, At - St).normalize(),
      nt === WebGLCoordinateSystem)
    )
      rt[5].setComponents(lt + at, ht + ft, Et + yt, At + St).normalize();
    else if (nt === WebGPUCoordinateSystem)
      rt[5].setComponents(at, ft, yt, St).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          nt
      );
    return this;
  }
  intersectsObject(et) {
    if (et.boundingSphere !== void 0)
      et.boundingSphere === null && et.computeBoundingSphere(),
        _sphere$4.copy(et.boundingSphere).applyMatrix4(et.matrixWorld);
    else {
      const nt = et.geometry;
      nt.boundingSphere === null && nt.computeBoundingSphere(),
        _sphere$4.copy(nt.boundingSphere).applyMatrix4(et.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(et) {
    return (
      _sphere$4.center.set(0, 0, 0),
      (_sphere$4.radius = 0.7071067811865476),
      _sphere$4.applyMatrix4(et.matrixWorld),
      this.intersectsSphere(_sphere$4)
    );
  }
  intersectsSphere(et) {
    const nt = this.planes,
      rt = et.center,
      it = -et.radius;
    for (let st = 0; st < 6; st++)
      if (nt[st].distanceToPoint(rt) < it) return !1;
    return !0;
  }
  intersectsBox(et) {
    const nt = this.planes;
    for (let rt = 0; rt < 6; rt++) {
      const it = nt[rt];
      if (
        ((_vector$6.x = it.normal.x > 0 ? et.max.x : et.min.x),
        (_vector$6.y = it.normal.y > 0 ? et.max.y : et.min.y),
        (_vector$6.z = it.normal.z > 0 ? et.max.z : et.min.z),
        it.distanceToPoint(_vector$6) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(et) {
    const nt = this.planes;
    for (let rt = 0; rt < 6; rt++)
      if (nt[rt].distanceToPoint(et) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let tt = null,
    et = !1,
    nt = null,
    rt = null;
  function it(st, ot) {
    nt(st, ot), (rt = tt.requestAnimationFrame(it));
  }
  return {
    start: function () {
      et !== !0 &&
        nt !== null &&
        ((rt = tt.requestAnimationFrame(it)), (et = !0));
    },
    stop: function () {
      tt.cancelAnimationFrame(rt), (et = !1);
    },
    setAnimationLoop: function (st) {
      nt = st;
    },
    setContext: function (st) {
      tt = st;
    },
  };
}
function WebGLAttributes(tt, et) {
  const nt = et.isWebGL2,
    rt = new WeakMap();
  function it(ct, ut) {
    const ft = ct.array,
      ht = ct.usage,
      mt = tt.createBuffer();
    tt.bindBuffer(ut, mt), tt.bufferData(ut, ft, ht), ct.onUploadCallback();
    let vt;
    if (ft instanceof Float32Array) vt = tt.FLOAT;
    else if (ft instanceof Uint16Array)
      if (ct.isFloat16BufferAttribute)
        if (nt) vt = tt.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else vt = tt.UNSIGNED_SHORT;
    else if (ft instanceof Int16Array) vt = tt.SHORT;
    else if (ft instanceof Uint32Array) vt = tt.UNSIGNED_INT;
    else if (ft instanceof Int32Array) vt = tt.INT;
    else if (ft instanceof Int8Array) vt = tt.BYTE;
    else if (ft instanceof Uint8Array) vt = tt.UNSIGNED_BYTE;
    else if (ft instanceof Uint8ClampedArray) vt = tt.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + ft
      );
    return {
      buffer: mt,
      type: vt,
      bytesPerElement: ft.BYTES_PER_ELEMENT,
      version: ct.version,
    };
  }
  function st(ct, ut, ft) {
    const ht = ut.array,
      mt = ut.updateRange;
    tt.bindBuffer(ft, ct),
      mt.count === -1
        ? tt.bufferSubData(ft, 0, ht)
        : (nt
            ? tt.bufferSubData(
                ft,
                mt.offset * ht.BYTES_PER_ELEMENT,
                ht,
                mt.offset,
                mt.count
              )
            : tt.bufferSubData(
                ft,
                mt.offset * ht.BYTES_PER_ELEMENT,
                ht.subarray(mt.offset, mt.offset + mt.count)
              ),
          (mt.count = -1)),
      ut.onUploadCallback();
  }
  function ot(ct) {
    return ct.isInterleavedBufferAttribute && (ct = ct.data), rt.get(ct);
  }
  function at(ct) {
    ct.isInterleavedBufferAttribute && (ct = ct.data);
    const ut = rt.get(ct);
    ut && (tt.deleteBuffer(ut.buffer), rt.delete(ct));
  }
  function lt(ct, ut) {
    if (ct.isGLBufferAttribute) {
      const ht = rt.get(ct);
      (!ht || ht.version < ct.version) &&
        rt.set(ct, {
          buffer: ct.buffer,
          type: ct.type,
          bytesPerElement: ct.elementSize,
          version: ct.version,
        });
      return;
    }
    ct.isInterleavedBufferAttribute && (ct = ct.data);
    const ft = rt.get(ct);
    ft === void 0
      ? rt.set(ct, it(ct, ut))
      : ft.version < ct.version &&
        (st(ft.buffer, ct, ut), (ft.version = ct.version));
  }
  return { get: ot, remove: at, update: lt };
}
class PlaneGeometry extends BufferGeometry {
  constructor(et = 1, nt = 1, rt = 1, it = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: et,
        height: nt,
        widthSegments: rt,
        heightSegments: it,
      });
    const st = et / 2,
      ot = nt / 2,
      at = Math.floor(rt),
      lt = Math.floor(it),
      ct = at + 1,
      ut = lt + 1,
      ft = et / at,
      ht = nt / lt,
      mt = [],
      vt = [],
      yt = [],
      Et = [];
    for (let pt = 0; pt < ut; pt++) {
      const xt = pt * ht - ot;
      for (let St = 0; St < ct; St++) {
        const At = St * ft - st;
        vt.push(At, -xt, 0),
          yt.push(0, 0, 1),
          Et.push(St / at),
          Et.push(1 - pt / lt);
      }
    }
    for (let pt = 0; pt < lt; pt++)
      for (let xt = 0; xt < at; xt++) {
        const St = xt + ct * pt,
          At = xt + ct * (pt + 1),
          Ct = xt + 1 + ct * (pt + 1),
          Mt = xt + 1 + ct * pt;
        mt.push(St, At, Mt), mt.push(At, Ct, Mt);
      }
    this.setIndex(mt),
      this.setAttribute("position", new Float32BufferAttribute(vt, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(yt, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(Et, 2));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new PlaneGeometry(
      et.width,
      et.height,
      et.widthSegments,
      et.heightSegments
    );
  }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  alphatest_fragment = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  common$2 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  colorspace_pars_fragment = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal;
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$e = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$a = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common: common$2,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1,
  },
  UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Matrix3() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Matrix3() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Matrix3() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Matrix3() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Matrix3() },
      normalScale: { value: new Vector2(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Matrix3() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Matrix3() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Matrix3() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() },
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
  },
  ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog,
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag,
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag,
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag,
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag,
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag,
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag,
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag,
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag,
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag,
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag,
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        { color: { value: new Color(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag,
    },
  };
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
};
const _rgb = { r: 0, b: 0, g: 0 };
function WebGLBackground(tt, et, nt, rt, it, st, ot) {
  const at = new Color(0);
  let lt = st === !0 ? 0 : 1,
    ct,
    ut,
    ft = null,
    ht = 0,
    mt = null;
  function vt(Et, pt) {
    let xt = !1,
      St = pt.isScene === !0 ? pt.background : null;
    St &&
      St.isTexture &&
      (St = (pt.backgroundBlurriness > 0 ? nt : et).get(St)),
      St === null ? yt(at, lt) : St && St.isColor && (yt(St, 1), (xt = !0));
    const At = tt.xr.getEnvironmentBlendMode();
    At === "additive"
      ? rt.buffers.color.setClear(0, 0, 0, 1, ot)
      : At === "alpha-blend" && rt.buffers.color.setClear(0, 0, 0, 0, ot),
      (tt.autoClear || xt) &&
        tt.clear(tt.autoClearColor, tt.autoClearDepth, tt.autoClearStencil),
      St && (St.isCubeTexture || St.mapping === CubeUVReflectionMapping)
        ? (ut === void 0 &&
            ((ut = new Mesh(
              new BoxGeometry(1, 1, 1),
              new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
                vertexShader: ShaderLib.backgroundCube.vertexShader,
                fragmentShader: ShaderLib.backgroundCube.fragmentShader,
                side: BackSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            ut.geometry.deleteAttribute("normal"),
            ut.geometry.deleteAttribute("uv"),
            (ut.onBeforeRender = function (Ct, Mt, wt) {
              this.matrixWorld.copyPosition(wt.matrixWorld);
            }),
            Object.defineProperty(ut.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            it.update(ut)),
          (ut.material.uniforms.envMap.value = St),
          (ut.material.uniforms.flipEnvMap.value =
            St.isCubeTexture && St.isRenderTargetTexture === !1 ? -1 : 1),
          (ut.material.uniforms.backgroundBlurriness.value =
            pt.backgroundBlurriness),
          (ut.material.uniforms.backgroundIntensity.value =
            pt.backgroundIntensity),
          (ut.material.toneMapped =
            ColorManagement.getTransfer(St.colorSpace) !== SRGBTransfer),
          (ft !== St || ht !== St.version || mt !== tt.toneMapping) &&
            ((ut.material.needsUpdate = !0),
            (ft = St),
            (ht = St.version),
            (mt = tt.toneMapping)),
          ut.layers.enableAll(),
          Et.unshift(ut, ut.geometry, ut.material, 0, 0, null))
        : St &&
          St.isTexture &&
          (ct === void 0 &&
            ((ct = new Mesh(
              new PlaneGeometry(2, 2),
              new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            ct.geometry.deleteAttribute("normal"),
            Object.defineProperty(ct.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            it.update(ct)),
          (ct.material.uniforms.t2D.value = St),
          (ct.material.uniforms.backgroundIntensity.value =
            pt.backgroundIntensity),
          (ct.material.toneMapped =
            ColorManagement.getTransfer(St.colorSpace) !== SRGBTransfer),
          St.matrixAutoUpdate === !0 && St.updateMatrix(),
          ct.material.uniforms.uvTransform.value.copy(St.matrix),
          (ft !== St || ht !== St.version || mt !== tt.toneMapping) &&
            ((ct.material.needsUpdate = !0),
            (ft = St),
            (ht = St.version),
            (mt = tt.toneMapping)),
          ct.layers.enableAll(),
          Et.unshift(ct, ct.geometry, ct.material, 0, 0, null));
  }
  function yt(Et, pt) {
    Et.getRGB(_rgb, getUnlitUniformColorSpace(tt)),
      rt.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, pt, ot);
  }
  return {
    getClearColor: function () {
      return at;
    },
    setClearColor: function (Et, pt = 1) {
      at.set(Et), (lt = pt), yt(at, lt);
    },
    getClearAlpha: function () {
      return lt;
    },
    setClearAlpha: function (Et) {
      (lt = Et), yt(at, lt);
    },
    render: vt,
  };
}
function WebGLBindingStates(tt, et, nt, rt) {
  const it = tt.getParameter(tt.MAX_VERTEX_ATTRIBS),
    st = rt.isWebGL2 ? null : et.get("OES_vertex_array_object"),
    ot = rt.isWebGL2 || st !== null,
    at = {},
    lt = Et(null);
  let ct = lt,
    ut = !1;
  function ft(Ht, Wt, kt, Gt, Pt) {
    let Rt = !1;
    if (ot) {
      const Nt = yt(Gt, kt, Wt);
      ct !== Nt && ((ct = Nt), mt(ct.object)),
        (Rt = pt(Ht, Gt, kt, Pt)),
        Rt && xt(Ht, Gt, kt, Pt);
    } else {
      const Nt = Wt.wireframe === !0;
      (ct.geometry !== Gt.id || ct.program !== kt.id || ct.wireframe !== Nt) &&
        ((ct.geometry = Gt.id),
        (ct.program = kt.id),
        (ct.wireframe = Nt),
        (Rt = !0));
    }
    Pt !== null && nt.update(Pt, tt.ELEMENT_ARRAY_BUFFER),
      (Rt || ut) &&
        ((ut = !1),
        Bt(Ht, Wt, kt, Gt),
        Pt !== null &&
          tt.bindBuffer(tt.ELEMENT_ARRAY_BUFFER, nt.get(Pt).buffer));
  }
  function ht() {
    return rt.isWebGL2 ? tt.createVertexArray() : st.createVertexArrayOES();
  }
  function mt(Ht) {
    return rt.isWebGL2 ? tt.bindVertexArray(Ht) : st.bindVertexArrayOES(Ht);
  }
  function vt(Ht) {
    return rt.isWebGL2 ? tt.deleteVertexArray(Ht) : st.deleteVertexArrayOES(Ht);
  }
  function yt(Ht, Wt, kt) {
    const Gt = kt.wireframe === !0;
    let Pt = at[Ht.id];
    Pt === void 0 && ((Pt = {}), (at[Ht.id] = Pt));
    let Rt = Pt[Wt.id];
    Rt === void 0 && ((Rt = {}), (Pt[Wt.id] = Rt));
    let Nt = Rt[Gt];
    return Nt === void 0 && ((Nt = Et(ht())), (Rt[Gt] = Nt)), Nt;
  }
  function Et(Ht) {
    const Wt = [],
      kt = [],
      Gt = [];
    for (let Pt = 0; Pt < it; Pt++) (Wt[Pt] = 0), (kt[Pt] = 0), (Gt[Pt] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Wt,
      enabledAttributes: kt,
      attributeDivisors: Gt,
      object: Ht,
      attributes: {},
      index: null,
    };
  }
  function pt(Ht, Wt, kt, Gt) {
    const Pt = ct.attributes,
      Rt = Wt.attributes;
    let Nt = 0;
    const Dt = kt.getAttributes();
    for (const zt in Dt)
      if (Dt[zt].location >= 0) {
        const qt = Pt[zt];
        let Zt = Rt[zt];
        if (
          (Zt === void 0 &&
            (zt === "instanceMatrix" &&
              Ht.instanceMatrix &&
              (Zt = Ht.instanceMatrix),
            zt === "instanceColor" &&
              Ht.instanceColor &&
              (Zt = Ht.instanceColor)),
          qt === void 0 || qt.attribute !== Zt || (Zt && qt.data !== Zt.data))
        )
          return !0;
        Nt++;
      }
    return ct.attributesNum !== Nt || ct.index !== Gt;
  }
  function xt(Ht, Wt, kt, Gt) {
    const Pt = {},
      Rt = Wt.attributes;
    let Nt = 0;
    const Dt = kt.getAttributes();
    for (const zt in Dt)
      if (Dt[zt].location >= 0) {
        let qt = Rt[zt];
        qt === void 0 &&
          (zt === "instanceMatrix" &&
            Ht.instanceMatrix &&
            (qt = Ht.instanceMatrix),
          zt === "instanceColor" &&
            Ht.instanceColor &&
            (qt = Ht.instanceColor));
        const Zt = {};
        (Zt.attribute = qt),
          qt && qt.data && (Zt.data = qt.data),
          (Pt[zt] = Zt),
          Nt++;
      }
    (ct.attributes = Pt), (ct.attributesNum = Nt), (ct.index = Gt);
  }
  function St() {
    const Ht = ct.newAttributes;
    for (let Wt = 0, kt = Ht.length; Wt < kt; Wt++) Ht[Wt] = 0;
  }
  function At(Ht) {
    Ct(Ht, 0);
  }
  function Ct(Ht, Wt) {
    const kt = ct.newAttributes,
      Gt = ct.enabledAttributes,
      Pt = ct.attributeDivisors;
    (kt[Ht] = 1),
      Gt[Ht] === 0 && (tt.enableVertexAttribArray(Ht), (Gt[Ht] = 1)),
      Pt[Ht] !== Wt &&
        ((rt.isWebGL2 ? tt : et.get("ANGLE_instanced_arrays"))[
          rt.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](Ht, Wt),
        (Pt[Ht] = Wt));
  }
  function Mt() {
    const Ht = ct.newAttributes,
      Wt = ct.enabledAttributes;
    for (let kt = 0, Gt = Wt.length; kt < Gt; kt++)
      Wt[kt] !== Ht[kt] && (tt.disableVertexAttribArray(kt), (Wt[kt] = 0));
  }
  function wt(Ht, Wt, kt, Gt, Pt, Rt, Nt) {
    Nt === !0
      ? tt.vertexAttribIPointer(Ht, Wt, kt, Pt, Rt)
      : tt.vertexAttribPointer(Ht, Wt, kt, Gt, Pt, Rt);
  }
  function Bt(Ht, Wt, kt, Gt) {
    if (
      rt.isWebGL2 === !1 &&
      (Ht.isInstancedMesh || Gt.isInstancedBufferGeometry) &&
      et.get("ANGLE_instanced_arrays") === null
    )
      return;
    St();
    const Pt = Gt.attributes,
      Rt = kt.getAttributes(),
      Nt = Wt.defaultAttributeValues;
    for (const Dt in Rt) {
      const zt = Rt[Dt];
      if (zt.location >= 0) {
        let Yt = Pt[Dt];
        if (
          (Yt === void 0 &&
            (Dt === "instanceMatrix" &&
              Ht.instanceMatrix &&
              (Yt = Ht.instanceMatrix),
            Dt === "instanceColor" &&
              Ht.instanceColor &&
              (Yt = Ht.instanceColor)),
          Yt !== void 0)
        ) {
          const qt = Yt.normalized,
            Zt = Yt.itemSize,
            Jt = nt.get(Yt);
          if (Jt === void 0) continue;
          const mn = Jt.buffer,
            ln = Jt.type,
            bn = Jt.bytesPerElement,
            Bn =
              rt.isWebGL2 === !0 &&
              (ln === tt.INT ||
                ln === tt.UNSIGNED_INT ||
                Yt.gpuType === IntType);
          if (Yt.isInterleavedBufferAttribute) {
            const gn = Yt.data,
              jt = gn.stride,
              yn = Yt.offset;
            if (gn.isInstancedInterleavedBuffer) {
              for (let pn = 0; pn < zt.locationSize; pn++)
                Ct(zt.location + pn, gn.meshPerAttribute);
              Ht.isInstancedMesh !== !0 &&
                Gt._maxInstanceCount === void 0 &&
                (Gt._maxInstanceCount = gn.meshPerAttribute * gn.count);
            } else
              for (let pn = 0; pn < zt.locationSize; pn++) At(zt.location + pn);
            tt.bindBuffer(tt.ARRAY_BUFFER, mn);
            for (let pn = 0; pn < zt.locationSize; pn++)
              wt(
                zt.location + pn,
                Zt / zt.locationSize,
                ln,
                qt,
                jt * bn,
                (yn + (Zt / zt.locationSize) * pn) * bn,
                Bn
              );
          } else {
            if (Yt.isInstancedBufferAttribute) {
              for (let gn = 0; gn < zt.locationSize; gn++)
                Ct(zt.location + gn, Yt.meshPerAttribute);
              Ht.isInstancedMesh !== !0 &&
                Gt._maxInstanceCount === void 0 &&
                (Gt._maxInstanceCount = Yt.meshPerAttribute * Yt.count);
            } else
              for (let gn = 0; gn < zt.locationSize; gn++) At(zt.location + gn);
            tt.bindBuffer(tt.ARRAY_BUFFER, mn);
            for (let gn = 0; gn < zt.locationSize; gn++)
              wt(
                zt.location + gn,
                Zt / zt.locationSize,
                ln,
                qt,
                Zt * bn,
                (Zt / zt.locationSize) * gn * bn,
                Bn
              );
          }
        } else if (Nt !== void 0) {
          const qt = Nt[Dt];
          if (qt !== void 0)
            switch (qt.length) {
              case 2:
                tt.vertexAttrib2fv(zt.location, qt);
                break;
              case 3:
                tt.vertexAttrib3fv(zt.location, qt);
                break;
              case 4:
                tt.vertexAttrib4fv(zt.location, qt);
                break;
              default:
                tt.vertexAttrib1fv(zt.location, qt);
            }
        }
      }
    }
    Mt();
  }
  function It() {
    $t();
    for (const Ht in at) {
      const Wt = at[Ht];
      for (const kt in Wt) {
        const Gt = Wt[kt];
        for (const Pt in Gt) vt(Gt[Pt].object), delete Gt[Pt];
        delete Wt[kt];
      }
      delete at[Ht];
    }
  }
  function Ft(Ht) {
    if (at[Ht.id] === void 0) return;
    const Wt = at[Ht.id];
    for (const kt in Wt) {
      const Gt = Wt[kt];
      for (const Pt in Gt) vt(Gt[Pt].object), delete Gt[Pt];
      delete Wt[kt];
    }
    delete at[Ht.id];
  }
  function Vt(Ht) {
    for (const Wt in at) {
      const kt = at[Wt];
      if (kt[Ht.id] === void 0) continue;
      const Gt = kt[Ht.id];
      for (const Pt in Gt) vt(Gt[Pt].object), delete Gt[Pt];
      delete kt[Ht.id];
    }
  }
  function $t() {
    Kt(), (ut = !0), ct !== lt && ((ct = lt), mt(ct.object));
  }
  function Kt() {
    (lt.geometry = null), (lt.program = null), (lt.wireframe = !1);
  }
  return {
    setup: ft,
    reset: $t,
    resetDefaultState: Kt,
    dispose: It,
    releaseStatesOfGeometry: Ft,
    releaseStatesOfProgram: Vt,
    initAttributes: St,
    enableAttribute: At,
    disableUnusedAttributes: Mt,
  };
}
function WebGLBufferRenderer(tt, et, nt, rt) {
  const it = rt.isWebGL2;
  let st;
  function ot(ct) {
    st = ct;
  }
  function at(ct, ut) {
    tt.drawArrays(st, ct, ut), nt.update(ut, st, 1);
  }
  function lt(ct, ut, ft) {
    if (ft === 0) return;
    let ht, mt;
    if (it) (ht = tt), (mt = "drawArraysInstanced");
    else if (
      ((ht = et.get("ANGLE_instanced_arrays")),
      (mt = "drawArraysInstancedANGLE"),
      ht === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    ht[mt](st, ct, ut, ft), nt.update(ut, st, ft);
  }
  (this.setMode = ot), (this.render = at), (this.renderInstances = lt);
}
function WebGLCapabilities(tt, et, nt) {
  let rt;
  function it() {
    if (rt !== void 0) return rt;
    if (et.has("EXT_texture_filter_anisotropic") === !0) {
      const wt = et.get("EXT_texture_filter_anisotropic");
      rt = tt.getParameter(wt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else rt = 0;
    return rt;
  }
  function st(wt) {
    if (wt === "highp") {
      if (
        tt.getShaderPrecisionFormat(tt.VERTEX_SHADER, tt.HIGH_FLOAT).precision >
          0 &&
        tt.getShaderPrecisionFormat(tt.FRAGMENT_SHADER, tt.HIGH_FLOAT)
          .precision > 0
      )
        return "highp";
      wt = "mediump";
    }
    return wt === "mediump" &&
      tt.getShaderPrecisionFormat(tt.VERTEX_SHADER, tt.MEDIUM_FLOAT).precision >
        0 &&
      tt.getShaderPrecisionFormat(tt.FRAGMENT_SHADER, tt.MEDIUM_FLOAT)
        .precision > 0
      ? "mediump"
      : "lowp";
  }
  const ot =
    typeof WebGL2RenderingContext < "u" &&
    tt.constructor.name === "WebGL2RenderingContext";
  let at = nt.precision !== void 0 ? nt.precision : "highp";
  const lt = st(at);
  lt !== at &&
    (console.warn(
      "THREE.WebGLRenderer:",
      at,
      "not supported, using",
      lt,
      "instead."
    ),
    (at = lt));
  const ct = ot || et.has("WEBGL_draw_buffers"),
    ut = nt.logarithmicDepthBuffer === !0,
    ft = tt.getParameter(tt.MAX_TEXTURE_IMAGE_UNITS),
    ht = tt.getParameter(tt.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    mt = tt.getParameter(tt.MAX_TEXTURE_SIZE),
    vt = tt.getParameter(tt.MAX_CUBE_MAP_TEXTURE_SIZE),
    yt = tt.getParameter(tt.MAX_VERTEX_ATTRIBS),
    Et = tt.getParameter(tt.MAX_VERTEX_UNIFORM_VECTORS),
    pt = tt.getParameter(tt.MAX_VARYING_VECTORS),
    xt = tt.getParameter(tt.MAX_FRAGMENT_UNIFORM_VECTORS),
    St = ht > 0,
    At = ot || et.has("OES_texture_float"),
    Ct = St && At,
    Mt = ot ? tt.getParameter(tt.MAX_SAMPLES) : 0;
  return {
    isWebGL2: ot,
    drawBuffers: ct,
    getMaxAnisotropy: it,
    getMaxPrecision: st,
    precision: at,
    logarithmicDepthBuffer: ut,
    maxTextures: ft,
    maxVertexTextures: ht,
    maxTextureSize: mt,
    maxCubemapSize: vt,
    maxAttributes: yt,
    maxVertexUniforms: Et,
    maxVaryings: pt,
    maxFragmentUniforms: xt,
    vertexTextures: St,
    floatFragmentTextures: At,
    floatVertexTextures: Ct,
    maxSamples: Mt,
  };
}
function WebGLClipping(tt) {
  const et = this;
  let nt = null,
    rt = 0,
    it = !1,
    st = !1;
  const ot = new Plane(),
    at = new Matrix3(),
    lt = { value: null, needsUpdate: !1 };
  (this.uniform = lt),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (ft, ht) {
      const mt = ft.length !== 0 || ht || rt !== 0 || it;
      return (it = ht), (rt = ft.length), mt;
    }),
    (this.beginShadows = function () {
      (st = !0), ut(null);
    }),
    (this.endShadows = function () {
      st = !1;
    }),
    (this.setGlobalState = function (ft, ht) {
      nt = ut(ft, ht, 0);
    }),
    (this.setState = function (ft, ht, mt) {
      const vt = ft.clippingPlanes,
        yt = ft.clipIntersection,
        Et = ft.clipShadows,
        pt = tt.get(ft);
      if (!it || vt === null || vt.length === 0 || (st && !Et))
        st ? ut(null) : ct();
      else {
        const xt = st ? 0 : rt,
          St = xt * 4;
        let At = pt.clippingState || null;
        (lt.value = At), (At = ut(vt, ht, St, mt));
        for (let Ct = 0; Ct !== St; ++Ct) At[Ct] = nt[Ct];
        (pt.clippingState = At),
          (this.numIntersection = yt ? this.numPlanes : 0),
          (this.numPlanes += xt);
      }
    });
  function ct() {
    lt.value !== nt && ((lt.value = nt), (lt.needsUpdate = rt > 0)),
      (et.numPlanes = rt),
      (et.numIntersection = 0);
  }
  function ut(ft, ht, mt, vt) {
    const yt = ft !== null ? ft.length : 0;
    let Et = null;
    if (yt !== 0) {
      if (((Et = lt.value), vt !== !0 || Et === null)) {
        const pt = mt + yt * 4,
          xt = ht.matrixWorldInverse;
        at.getNormalMatrix(xt),
          (Et === null || Et.length < pt) && (Et = new Float32Array(pt));
        for (let St = 0, At = mt; St !== yt; ++St, At += 4)
          ot.copy(ft[St]).applyMatrix4(xt, at),
            ot.normal.toArray(Et, At),
            (Et[At + 3] = ot.constant);
      }
      (lt.value = Et), (lt.needsUpdate = !0);
    }
    return (et.numPlanes = yt), (et.numIntersection = 0), Et;
  }
}
function WebGLCubeMaps(tt) {
  let et = new WeakMap();
  function nt(ot, at) {
    return (
      at === EquirectangularReflectionMapping
        ? (ot.mapping = CubeReflectionMapping)
        : at === EquirectangularRefractionMapping &&
          (ot.mapping = CubeRefractionMapping),
      ot
    );
  }
  function rt(ot) {
    if (ot && ot.isTexture && ot.isRenderTargetTexture === !1) {
      const at = ot.mapping;
      if (
        at === EquirectangularReflectionMapping ||
        at === EquirectangularRefractionMapping
      )
        if (et.has(ot)) {
          const lt = et.get(ot).texture;
          return nt(lt, ot.mapping);
        } else {
          const lt = ot.image;
          if (lt && lt.height > 0) {
            const ct = new WebGLCubeRenderTarget(lt.height / 2);
            return (
              ct.fromEquirectangularTexture(tt, ot),
              et.set(ot, ct),
              ot.addEventListener("dispose", it),
              nt(ct.texture, ot.mapping)
            );
          } else return null;
        }
    }
    return ot;
  }
  function it(ot) {
    const at = ot.target;
    at.removeEventListener("dispose", it);
    const lt = et.get(at);
    lt !== void 0 && (et.delete(at), lt.dispose());
  }
  function st() {
    et = new WeakMap();
  }
  return { get: rt, dispose: st };
}
class OrthographicCamera extends Camera {
  constructor(et = -1, nt = 1, rt = 1, it = -1, st = 0.1, ot = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = et),
      (this.right = nt),
      (this.top = rt),
      (this.bottom = it),
      (this.near = st),
      (this.far = ot),
      this.updateProjectionMatrix();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.left = et.left),
      (this.right = et.right),
      (this.top = et.top),
      (this.bottom = et.bottom),
      (this.near = et.near),
      (this.far = et.far),
      (this.zoom = et.zoom),
      (this.view = et.view === null ? null : Object.assign({}, et.view)),
      this
    );
  }
  setViewOffset(et, nt, rt, it, st, ot) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = et),
      (this.view.fullHeight = nt),
      (this.view.offsetX = rt),
      (this.view.offsetY = it),
      (this.view.width = st),
      (this.view.height = ot),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const et = (this.right - this.left) / (2 * this.zoom),
      nt = (this.top - this.bottom) / (2 * this.zoom),
      rt = (this.right + this.left) / 2,
      it = (this.top + this.bottom) / 2;
    let st = rt - et,
      ot = rt + et,
      at = it + nt,
      lt = it - nt;
    if (this.view !== null && this.view.enabled) {
      const ct = (this.right - this.left) / this.view.fullWidth / this.zoom,
        ut = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (st += ct * this.view.offsetX),
        (ot = st + ct * this.view.width),
        (at -= ut * this.view.offsetY),
        (lt = at - ut * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      st,
      ot,
      at,
      lt,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      (nt.object.zoom = this.zoom),
      (nt.object.left = this.left),
      (nt.object.right = this.right),
      (nt.object.top = this.top),
      (nt.object.bottom = this.bottom),
      (nt.object.near = this.near),
      (nt.object.far = this.far),
      this.view !== null && (nt.object.view = Object.assign({}, this.view)),
      nt
    );
  }
}
const LOD_MIN = 4,
  EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  MAX_SAMPLES = 20,
  _flatCamera = new OrthographicCamera(),
  _clearColor = new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2,
  INV_PHI = 1 / PHI,
  _axisDirections = [
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-PHI, INV_PHI, 0),
  ];
class PMREMGenerator {
  constructor(et) {
    (this._renderer = et),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(et, nt = 0, rt = 0.1, it = 100) {
    (_oldTarget = this._renderer.getRenderTarget()), this._setSize(256);
    const st = this._allocateTargets();
    return (
      (st.depthBuffer = !0),
      this._sceneToCubeUV(et, rt, it, st),
      nt > 0 && this._blur(st, 0, 0, nt),
      this._applyPMREM(st),
      this._cleanup(st),
      st
    );
  }
  fromEquirectangular(et, nt = null) {
    return this._fromTexture(et, nt);
  }
  fromCubemap(et, nt = null) {
    return this._fromTexture(et, nt);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = _getCubemapMaterial()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = _getEquirectMaterial()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(et) {
    (this._lodMax = Math.floor(Math.log2(et))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let et = 0; et < this._lodPlanes.length; et++)
      this._lodPlanes[et].dispose();
  }
  _cleanup(et) {
    this._renderer.setRenderTarget(_oldTarget),
      (et.scissorTest = !1),
      _setViewport(et, 0, 0, et.width, et.height);
  }
  _fromTexture(et, nt) {
    et.mapping === CubeReflectionMapping || et.mapping === CubeRefractionMapping
      ? this._setSize(
          et.image.length === 0
            ? 16
            : et.image[0].width || et.image[0].image.width
        )
      : this._setSize(et.image.width / 4),
      (_oldTarget = this._renderer.getRenderTarget());
    const rt = nt || this._allocateTargets();
    return (
      this._textureToCubeUV(et, rt), this._applyPMREM(rt), this._cleanup(rt), rt
    );
  }
  _allocateTargets() {
    const et = 3 * Math.max(this._cubeSize, 112),
      nt = 4 * this._cubeSize,
      rt = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: !1,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: !1,
      },
      it = _createRenderTarget(et, nt, rt);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== et ||
      this._pingPongRenderTarget.height !== nt
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = _createRenderTarget(et, nt, rt));
      const { _lodMax: st } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(st)),
        (this._blurMaterial = _getBlurShader(st, et, nt));
    }
    return it;
  }
  _compileMaterial(et) {
    const nt = new Mesh(this._lodPlanes[0], et);
    this._renderer.compile(nt, _flatCamera);
  }
  _sceneToCubeUV(et, nt, rt, it) {
    const at = new PerspectiveCamera(90, 1, nt, rt),
      lt = [1, -1, 1, 1, 1, 1],
      ct = [1, 1, 1, -1, -1, -1],
      ut = this._renderer,
      ft = ut.autoClear,
      ht = ut.toneMapping;
    ut.getClearColor(_clearColor),
      (ut.toneMapping = NoToneMapping),
      (ut.autoClear = !1);
    const mt = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: !1,
        depthTest: !1,
      }),
      vt = new Mesh(new BoxGeometry(), mt);
    let yt = !1;
    const Et = et.background;
    Et
      ? Et.isColor && (mt.color.copy(Et), (et.background = null), (yt = !0))
      : (mt.color.copy(_clearColor), (yt = !0));
    for (let pt = 0; pt < 6; pt++) {
      const xt = pt % 3;
      xt === 0
        ? (at.up.set(0, lt[pt], 0), at.lookAt(ct[pt], 0, 0))
        : xt === 1
        ? (at.up.set(0, 0, lt[pt]), at.lookAt(0, ct[pt], 0))
        : (at.up.set(0, lt[pt], 0), at.lookAt(0, 0, ct[pt]));
      const St = this._cubeSize;
      _setViewport(it, xt * St, pt > 2 ? St : 0, St, St),
        ut.setRenderTarget(it),
        yt && ut.render(vt, at),
        ut.render(et, at);
    }
    vt.geometry.dispose(),
      vt.material.dispose(),
      (ut.toneMapping = ht),
      (ut.autoClear = ft),
      (et.background = Et);
  }
  _textureToCubeUV(et, nt) {
    const rt = this._renderer,
      it =
        et.mapping === CubeReflectionMapping ||
        et.mapping === CubeRefractionMapping;
    it
      ? (this._cubemapMaterial === null &&
          (this._cubemapMaterial = _getCubemapMaterial()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          et.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null &&
        (this._equirectMaterial = _getEquirectMaterial());
    const st = it ? this._cubemapMaterial : this._equirectMaterial,
      ot = new Mesh(this._lodPlanes[0], st),
      at = st.uniforms;
    at.envMap.value = et;
    const lt = this._cubeSize;
    _setViewport(nt, 0, 0, 3 * lt, 2 * lt),
      rt.setRenderTarget(nt),
      rt.render(ot, _flatCamera);
  }
  _applyPMREM(et) {
    const nt = this._renderer,
      rt = nt.autoClear;
    nt.autoClear = !1;
    for (let it = 1; it < this._lodPlanes.length; it++) {
      const st = Math.sqrt(
          this._sigmas[it] * this._sigmas[it] -
            this._sigmas[it - 1] * this._sigmas[it - 1]
        ),
        ot = _axisDirections[(it - 1) % _axisDirections.length];
      this._blur(et, it - 1, it, st, ot);
    }
    nt.autoClear = rt;
  }
  _blur(et, nt, rt, it, st) {
    const ot = this._pingPongRenderTarget;
    this._halfBlur(et, ot, nt, rt, it, "latitudinal", st),
      this._halfBlur(ot, et, rt, rt, it, "longitudinal", st);
  }
  _halfBlur(et, nt, rt, it, st, ot, at) {
    const lt = this._renderer,
      ct = this._blurMaterial;
    ot !== "latitudinal" &&
      ot !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const ut = 3,
      ft = new Mesh(this._lodPlanes[it], ct),
      ht = ct.uniforms,
      mt = this._sizeLods[rt] - 1,
      vt = isFinite(st)
        ? Math.PI / (2 * mt)
        : (2 * Math.PI) / (2 * MAX_SAMPLES - 1),
      yt = st / vt,
      Et = isFinite(st) ? 1 + Math.floor(ut * yt) : MAX_SAMPLES;
    Et > MAX_SAMPLES &&
      console.warn(
        `sigmaRadians, ${st}, is too large and will clip, as it requested ${Et} samples when the maximum is set to ${MAX_SAMPLES}`
      );
    const pt = [];
    let xt = 0;
    for (let wt = 0; wt < MAX_SAMPLES; ++wt) {
      const Bt = wt / yt,
        It = Math.exp((-Bt * Bt) / 2);
      pt.push(It), wt === 0 ? (xt += It) : wt < Et && (xt += 2 * It);
    }
    for (let wt = 0; wt < pt.length; wt++) pt[wt] = pt[wt] / xt;
    (ht.envMap.value = et.texture),
      (ht.samples.value = Et),
      (ht.weights.value = pt),
      (ht.latitudinal.value = ot === "latitudinal"),
      at && (ht.poleAxis.value = at);
    const { _lodMax: St } = this;
    (ht.dTheta.value = vt), (ht.mipInt.value = St - rt);
    const At = this._sizeLods[it],
      Ct = 3 * At * (it > St - LOD_MIN ? it - St + LOD_MIN : 0),
      Mt = 4 * (this._cubeSize - At);
    _setViewport(nt, Ct, Mt, 3 * At, 2 * At),
      lt.setRenderTarget(nt),
      lt.render(ft, _flatCamera);
  }
}
function _createPlanes(tt) {
  const et = [],
    nt = [],
    rt = [];
  let it = tt;
  const st = tt - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let ot = 0; ot < st; ot++) {
    const at = Math.pow(2, it);
    nt.push(at);
    let lt = 1 / at;
    ot > tt - LOD_MIN
      ? (lt = EXTRA_LOD_SIGMA[ot - tt + LOD_MIN - 1])
      : ot === 0 && (lt = 0),
      rt.push(lt);
    const ct = 1 / (at - 2),
      ut = -ct,
      ft = 1 + ct,
      ht = [ut, ut, ft, ut, ft, ft, ut, ut, ft, ft, ut, ft],
      mt = 6,
      vt = 6,
      yt = 3,
      Et = 2,
      pt = 1,
      xt = new Float32Array(yt * vt * mt),
      St = new Float32Array(Et * vt * mt),
      At = new Float32Array(pt * vt * mt);
    for (let Mt = 0; Mt < mt; Mt++) {
      const wt = ((Mt % 3) * 2) / 3 - 1,
        Bt = Mt > 2 ? 0 : -1,
        It = [
          wt,
          Bt,
          0,
          wt + 2 / 3,
          Bt,
          0,
          wt + 2 / 3,
          Bt + 1,
          0,
          wt,
          Bt,
          0,
          wt + 2 / 3,
          Bt + 1,
          0,
          wt,
          Bt + 1,
          0,
        ];
      xt.set(It, yt * vt * Mt), St.set(ht, Et * vt * Mt);
      const Ft = [Mt, Mt, Mt, Mt, Mt, Mt];
      At.set(Ft, pt * vt * Mt);
    }
    const Ct = new BufferGeometry();
    Ct.setAttribute("position", new BufferAttribute(xt, yt)),
      Ct.setAttribute("uv", new BufferAttribute(St, Et)),
      Ct.setAttribute("faceIndex", new BufferAttribute(At, pt)),
      et.push(Ct),
      it > LOD_MIN && it--;
  }
  return { lodPlanes: et, sizeLods: nt, sigmas: rt };
}
function _createRenderTarget(tt, et, nt) {
  const rt = new WebGLRenderTarget(tt, et, nt);
  return (
    (rt.texture.mapping = CubeUVReflectionMapping),
    (rt.texture.name = "PMREM.cubeUv"),
    (rt.scissorTest = !0),
    rt
  );
}
function _setViewport(tt, et, nt, rt, it) {
  tt.viewport.set(et, nt, rt, it), tt.scissor.set(et, nt, rt, it);
}
function _getBlurShader(tt, et, nt) {
  const rt = new Float32Array(MAX_SAMPLES),
    it = new Vector3(0, 1, 0);
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / et,
      CUBEUV_TEXEL_HEIGHT: 1 / nt,
      CUBEUV_MAX_MIP: `${tt}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: rt },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: it },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(tt) {
  let et = new WeakMap(),
    nt = null;
  function rt(at) {
    if (at && at.isTexture) {
      const lt = at.mapping,
        ct =
          lt === EquirectangularReflectionMapping ||
          lt === EquirectangularRefractionMapping,
        ut = lt === CubeReflectionMapping || lt === CubeRefractionMapping;
      if (ct || ut)
        if (at.isRenderTargetTexture && at.needsPMREMUpdate === !0) {
          at.needsPMREMUpdate = !1;
          let ft = et.get(at);
          return (
            nt === null && (nt = new PMREMGenerator(tt)),
            (ft = ct ? nt.fromEquirectangular(at, ft) : nt.fromCubemap(at, ft)),
            et.set(at, ft),
            ft.texture
          );
        } else {
          if (et.has(at)) return et.get(at).texture;
          {
            const ft = at.image;
            if ((ct && ft && ft.height > 0) || (ut && ft && it(ft))) {
              nt === null && (nt = new PMREMGenerator(tt));
              const ht = ct ? nt.fromEquirectangular(at) : nt.fromCubemap(at);
              return (
                et.set(at, ht), at.addEventListener("dispose", st), ht.texture
              );
            } else return null;
          }
        }
    }
    return at;
  }
  function it(at) {
    let lt = 0;
    const ct = 6;
    for (let ut = 0; ut < ct; ut++) at[ut] !== void 0 && lt++;
    return lt === ct;
  }
  function st(at) {
    const lt = at.target;
    lt.removeEventListener("dispose", st);
    const ct = et.get(lt);
    ct !== void 0 && (et.delete(lt), ct.dispose());
  }
  function ot() {
    (et = new WeakMap()), nt !== null && (nt.dispose(), (nt = null));
  }
  return { get: rt, dispose: ot };
}
function WebGLExtensions(tt) {
  const et = {};
  function nt(rt) {
    if (et[rt] !== void 0) return et[rt];
    let it;
    switch (rt) {
      case "WEBGL_depth_texture":
        it =
          tt.getExtension("WEBGL_depth_texture") ||
          tt.getExtension("MOZ_WEBGL_depth_texture") ||
          tt.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        it =
          tt.getExtension("EXT_texture_filter_anisotropic") ||
          tt.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          tt.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        it =
          tt.getExtension("WEBGL_compressed_texture_s3tc") ||
          tt.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          tt.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        it =
          tt.getExtension("WEBGL_compressed_texture_pvrtc") ||
          tt.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        it = tt.getExtension(rt);
    }
    return (et[rt] = it), it;
  }
  return {
    has: function (rt) {
      return nt(rt) !== null;
    },
    init: function (rt) {
      rt.isWebGL2
        ? nt("EXT_color_buffer_float")
        : (nt("WEBGL_depth_texture"),
          nt("OES_texture_float"),
          nt("OES_texture_half_float"),
          nt("OES_texture_half_float_linear"),
          nt("OES_standard_derivatives"),
          nt("OES_element_index_uint"),
          nt("OES_vertex_array_object"),
          nt("ANGLE_instanced_arrays")),
        nt("OES_texture_float_linear"),
        nt("EXT_color_buffer_half_float"),
        nt("WEBGL_multisampled_render_to_texture");
    },
    get: function (rt) {
      const it = nt(rt);
      return (
        it === null &&
          console.warn(
            "THREE.WebGLRenderer: " + rt + " extension not supported."
          ),
        it
      );
    },
  };
}
function WebGLGeometries(tt, et, nt, rt) {
  const it = {},
    st = new WeakMap();
  function ot(ft) {
    const ht = ft.target;
    ht.index !== null && et.remove(ht.index);
    for (const vt in ht.attributes) et.remove(ht.attributes[vt]);
    for (const vt in ht.morphAttributes) {
      const yt = ht.morphAttributes[vt];
      for (let Et = 0, pt = yt.length; Et < pt; Et++) et.remove(yt[Et]);
    }
    ht.removeEventListener("dispose", ot), delete it[ht.id];
    const mt = st.get(ht);
    mt && (et.remove(mt), st.delete(ht)),
      rt.releaseStatesOfGeometry(ht),
      ht.isInstancedBufferGeometry === !0 && delete ht._maxInstanceCount,
      nt.memory.geometries--;
  }
  function at(ft, ht) {
    return (
      it[ht.id] === !0 ||
        (ht.addEventListener("dispose", ot),
        (it[ht.id] = !0),
        nt.memory.geometries++),
      ht
    );
  }
  function lt(ft) {
    const ht = ft.attributes;
    for (const vt in ht) et.update(ht[vt], tt.ARRAY_BUFFER);
    const mt = ft.morphAttributes;
    for (const vt in mt) {
      const yt = mt[vt];
      for (let Et = 0, pt = yt.length; Et < pt; Et++)
        et.update(yt[Et], tt.ARRAY_BUFFER);
    }
  }
  function ct(ft) {
    const ht = [],
      mt = ft.index,
      vt = ft.attributes.position;
    let yt = 0;
    if (mt !== null) {
      const xt = mt.array;
      yt = mt.version;
      for (let St = 0, At = xt.length; St < At; St += 3) {
        const Ct = xt[St + 0],
          Mt = xt[St + 1],
          wt = xt[St + 2];
        ht.push(Ct, Mt, Mt, wt, wt, Ct);
      }
    } else if (vt !== void 0) {
      const xt = vt.array;
      yt = vt.version;
      for (let St = 0, At = xt.length / 3 - 1; St < At; St += 3) {
        const Ct = St + 0,
          Mt = St + 1,
          wt = St + 2;
        ht.push(Ct, Mt, Mt, wt, wt, Ct);
      }
    } else return;
    const Et = new (
      arrayNeedsUint32(ht) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(ht, 1);
    Et.version = yt;
    const pt = st.get(ft);
    pt && et.remove(pt), st.set(ft, Et);
  }
  function ut(ft) {
    const ht = st.get(ft);
    if (ht) {
      const mt = ft.index;
      mt !== null && ht.version < mt.version && ct(ft);
    } else ct(ft);
    return st.get(ft);
  }
  return { get: at, update: lt, getWireframeAttribute: ut };
}
function WebGLIndexedBufferRenderer(tt, et, nt, rt) {
  const it = rt.isWebGL2;
  let st;
  function ot(ht) {
    st = ht;
  }
  let at, lt;
  function ct(ht) {
    (at = ht.type), (lt = ht.bytesPerElement);
  }
  function ut(ht, mt) {
    tt.drawElements(st, mt, at, ht * lt), nt.update(mt, st, 1);
  }
  function ft(ht, mt, vt) {
    if (vt === 0) return;
    let yt, Et;
    if (it) (yt = tt), (Et = "drawElementsInstanced");
    else if (
      ((yt = et.get("ANGLE_instanced_arrays")),
      (Et = "drawElementsInstancedANGLE"),
      yt === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    yt[Et](st, mt, at, ht * lt, vt), nt.update(mt, st, vt);
  }
  (this.setMode = ot),
    (this.setIndex = ct),
    (this.render = ut),
    (this.renderInstances = ft);
}
function WebGLInfo(tt) {
  const et = { geometries: 0, textures: 0 },
    nt = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function rt(st, ot, at) {
    switch ((nt.calls++, ot)) {
      case tt.TRIANGLES:
        nt.triangles += at * (st / 3);
        break;
      case tt.LINES:
        nt.lines += at * (st / 2);
        break;
      case tt.LINE_STRIP:
        nt.lines += at * (st - 1);
        break;
      case tt.LINE_LOOP:
        nt.lines += at * st;
        break;
      case tt.POINTS:
        nt.points += at * st;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", ot);
        break;
    }
  }
  function it() {
    (nt.calls = 0), (nt.triangles = 0), (nt.points = 0), (nt.lines = 0);
  }
  return {
    memory: et,
    render: nt,
    programs: null,
    autoReset: !0,
    reset: it,
    update: rt,
  };
}
function numericalSort(tt, et) {
  return tt[0] - et[0];
}
function absNumericalSort(tt, et) {
  return Math.abs(et[1]) - Math.abs(tt[1]);
}
function WebGLMorphtargets(tt, et, nt) {
  const rt = {},
    it = new Float32Array(8),
    st = new WeakMap(),
    ot = new Vector4(),
    at = [];
  for (let ct = 0; ct < 8; ct++) at[ct] = [ct, 0];
  function lt(ct, ut, ft) {
    const ht = ct.morphTargetInfluences;
    if (et.isWebGL2 === !0) {
      const vt =
          ut.morphAttributes.position ||
          ut.morphAttributes.normal ||
          ut.morphAttributes.color,
        yt = vt !== void 0 ? vt.length : 0;
      let Et = st.get(ut);
      if (Et === void 0 || Et.count !== yt) {
        let Wt = function () {
          Kt.dispose(), st.delete(ut), ut.removeEventListener("dispose", Wt);
        };
        var mt = Wt;
        Et !== void 0 && Et.texture.dispose();
        const St = ut.morphAttributes.position !== void 0,
          At = ut.morphAttributes.normal !== void 0,
          Ct = ut.morphAttributes.color !== void 0,
          Mt = ut.morphAttributes.position || [],
          wt = ut.morphAttributes.normal || [],
          Bt = ut.morphAttributes.color || [];
        let It = 0;
        St === !0 && (It = 1), At === !0 && (It = 2), Ct === !0 && (It = 3);
        let Ft = ut.attributes.position.count * It,
          Vt = 1;
        Ft > et.maxTextureSize &&
          ((Vt = Math.ceil(Ft / et.maxTextureSize)), (Ft = et.maxTextureSize));
        const $t = new Float32Array(Ft * Vt * 4 * yt),
          Kt = new DataArrayTexture($t, Ft, Vt, yt);
        (Kt.type = FloatType), (Kt.needsUpdate = !0);
        const Ht = It * 4;
        for (let kt = 0; kt < yt; kt++) {
          const Gt = Mt[kt],
            Pt = wt[kt],
            Rt = Bt[kt],
            Nt = Ft * Vt * 4 * kt;
          for (let Dt = 0; Dt < Gt.count; Dt++) {
            const zt = Dt * Ht;
            St === !0 &&
              (ot.fromBufferAttribute(Gt, Dt),
              ($t[Nt + zt + 0] = ot.x),
              ($t[Nt + zt + 1] = ot.y),
              ($t[Nt + zt + 2] = ot.z),
              ($t[Nt + zt + 3] = 0)),
              At === !0 &&
                (ot.fromBufferAttribute(Pt, Dt),
                ($t[Nt + zt + 4] = ot.x),
                ($t[Nt + zt + 5] = ot.y),
                ($t[Nt + zt + 6] = ot.z),
                ($t[Nt + zt + 7] = 0)),
              Ct === !0 &&
                (ot.fromBufferAttribute(Rt, Dt),
                ($t[Nt + zt + 8] = ot.x),
                ($t[Nt + zt + 9] = ot.y),
                ($t[Nt + zt + 10] = ot.z),
                ($t[Nt + zt + 11] = Rt.itemSize === 4 ? ot.w : 1));
          }
        }
        (Et = { count: yt, texture: Kt, size: new Vector2(Ft, Vt) }),
          st.set(ut, Et),
          ut.addEventListener("dispose", Wt);
      }
      let pt = 0;
      for (let St = 0; St < ht.length; St++) pt += ht[St];
      const xt = ut.morphTargetsRelative ? 1 : 1 - pt;
      ft.getUniforms().setValue(tt, "morphTargetBaseInfluence", xt),
        ft.getUniforms().setValue(tt, "morphTargetInfluences", ht),
        ft.getUniforms().setValue(tt, "morphTargetsTexture", Et.texture, nt),
        ft.getUniforms().setValue(tt, "morphTargetsTextureSize", Et.size);
    } else {
      const vt = ht === void 0 ? 0 : ht.length;
      let yt = rt[ut.id];
      if (yt === void 0 || yt.length !== vt) {
        yt = [];
        for (let At = 0; At < vt; At++) yt[At] = [At, 0];
        rt[ut.id] = yt;
      }
      for (let At = 0; At < vt; At++) {
        const Ct = yt[At];
        (Ct[0] = At), (Ct[1] = ht[At]);
      }
      yt.sort(absNumericalSort);
      for (let At = 0; At < 8; At++)
        At < vt && yt[At][1]
          ? ((at[At][0] = yt[At][0]), (at[At][1] = yt[At][1]))
          : ((at[At][0] = Number.MAX_SAFE_INTEGER), (at[At][1] = 0));
      at.sort(numericalSort);
      const Et = ut.morphAttributes.position,
        pt = ut.morphAttributes.normal;
      let xt = 0;
      for (let At = 0; At < 8; At++) {
        const Ct = at[At],
          Mt = Ct[0],
          wt = Ct[1];
        Mt !== Number.MAX_SAFE_INTEGER && wt
          ? (Et &&
              ut.getAttribute("morphTarget" + At) !== Et[Mt] &&
              ut.setAttribute("morphTarget" + At, Et[Mt]),
            pt &&
              ut.getAttribute("morphNormal" + At) !== pt[Mt] &&
              ut.setAttribute("morphNormal" + At, pt[Mt]),
            (it[At] = wt),
            (xt += wt))
          : (Et &&
              ut.hasAttribute("morphTarget" + At) === !0 &&
              ut.deleteAttribute("morphTarget" + At),
            pt &&
              ut.hasAttribute("morphNormal" + At) === !0 &&
              ut.deleteAttribute("morphNormal" + At),
            (it[At] = 0));
      }
      const St = ut.morphTargetsRelative ? 1 : 1 - xt;
      ft.getUniforms().setValue(tt, "morphTargetBaseInfluence", St),
        ft.getUniforms().setValue(tt, "morphTargetInfluences", it);
    }
  }
  return { update: lt };
}
function WebGLObjects(tt, et, nt, rt) {
  let it = new WeakMap();
  function st(lt) {
    const ct = rt.render.frame,
      ut = lt.geometry,
      ft = et.get(lt, ut);
    if (
      (it.get(ft) !== ct && (et.update(ft), it.set(ft, ct)),
      lt.isInstancedMesh &&
        (lt.hasEventListener("dispose", at) === !1 &&
          lt.addEventListener("dispose", at),
        it.get(lt) !== ct &&
          (nt.update(lt.instanceMatrix, tt.ARRAY_BUFFER),
          lt.instanceColor !== null &&
            nt.update(lt.instanceColor, tt.ARRAY_BUFFER),
          it.set(lt, ct))),
      lt.isSkinnedMesh)
    ) {
      const ht = lt.skeleton;
      it.get(ht) !== ct && (ht.update(), it.set(ht, ct));
    }
    return ft;
  }
  function ot() {
    it = new WeakMap();
  }
  function at(lt) {
    const ct = lt.target;
    ct.removeEventListener("dispose", at),
      nt.remove(ct.instanceMatrix),
      ct.instanceColor !== null && nt.remove(ct.instanceColor);
  }
  return { update: st, dispose: ot };
}
const emptyTexture = new Texture(),
  emptyArrayTexture = new DataArrayTexture(),
  empty3dTexture = new Data3DTexture(),
  emptyCubeTexture = new CubeTexture(),
  arrayCacheF32 = [],
  arrayCacheI32 = [],
  mat4array = new Float32Array(16),
  mat3array = new Float32Array(9),
  mat2array = new Float32Array(4);
function flatten(tt, et, nt) {
  const rt = tt[0];
  if (rt <= 0 || rt > 0) return tt;
  const it = et * nt;
  let st = arrayCacheF32[it];
  if (
    (st === void 0 && ((st = new Float32Array(it)), (arrayCacheF32[it] = st)),
    et !== 0)
  ) {
    rt.toArray(st, 0);
    for (let ot = 1, at = 0; ot !== et; ++ot)
      (at += nt), tt[ot].toArray(st, at);
  }
  return st;
}
function arraysEqual(tt, et) {
  if (tt.length !== et.length) return !1;
  for (let nt = 0, rt = tt.length; nt < rt; nt++)
    if (tt[nt] !== et[nt]) return !1;
  return !0;
}
function copyArray(tt, et) {
  for (let nt = 0, rt = et.length; nt < rt; nt++) tt[nt] = et[nt];
}
function allocTexUnits(tt, et) {
  let nt = arrayCacheI32[et];
  nt === void 0 && ((nt = new Int32Array(et)), (arrayCacheI32[et] = nt));
  for (let rt = 0; rt !== et; ++rt) nt[rt] = tt.allocateTextureUnit();
  return nt;
}
function setValueV1f(tt, et) {
  const nt = this.cache;
  nt[0] !== et && (tt.uniform1f(this.addr, et), (nt[0] = et));
}
function setValueV2f(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y) &&
      (tt.uniform2f(this.addr, et.x, et.y), (nt[0] = et.x), (nt[1] = et.y));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform2fv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV3f(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z) &&
      (tt.uniform3f(this.addr, et.x, et.y, et.z),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z));
  else if (et.r !== void 0)
    (nt[0] !== et.r || nt[1] !== et.g || nt[2] !== et.b) &&
      (tt.uniform3f(this.addr, et.r, et.g, et.b),
      (nt[0] = et.r),
      (nt[1] = et.g),
      (nt[2] = et.b));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform3fv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV4f(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z || nt[3] !== et.w) &&
      (tt.uniform4f(this.addr, et.x, et.y, et.z, et.w),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z),
      (nt[3] = et.w));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform4fv(this.addr, et), copyArray(nt, et);
  }
}
function setValueM2(tt, et) {
  const nt = this.cache,
    rt = et.elements;
  if (rt === void 0) {
    if (arraysEqual(nt, et)) return;
    tt.uniformMatrix2fv(this.addr, !1, et), copyArray(nt, et);
  } else {
    if (arraysEqual(nt, rt)) return;
    mat2array.set(rt),
      tt.uniformMatrix2fv(this.addr, !1, mat2array),
      copyArray(nt, rt);
  }
}
function setValueM3(tt, et) {
  const nt = this.cache,
    rt = et.elements;
  if (rt === void 0) {
    if (arraysEqual(nt, et)) return;
    tt.uniformMatrix3fv(this.addr, !1, et), copyArray(nt, et);
  } else {
    if (arraysEqual(nt, rt)) return;
    mat3array.set(rt),
      tt.uniformMatrix3fv(this.addr, !1, mat3array),
      copyArray(nt, rt);
  }
}
function setValueM4(tt, et) {
  const nt = this.cache,
    rt = et.elements;
  if (rt === void 0) {
    if (arraysEqual(nt, et)) return;
    tt.uniformMatrix4fv(this.addr, !1, et), copyArray(nt, et);
  } else {
    if (arraysEqual(nt, rt)) return;
    mat4array.set(rt),
      tt.uniformMatrix4fv(this.addr, !1, mat4array),
      copyArray(nt, rt);
  }
}
function setValueV1i(tt, et) {
  const nt = this.cache;
  nt[0] !== et && (tt.uniform1i(this.addr, et), (nt[0] = et));
}
function setValueV2i(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y) &&
      (tt.uniform2i(this.addr, et.x, et.y), (nt[0] = et.x), (nt[1] = et.y));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform2iv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV3i(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z) &&
      (tt.uniform3i(this.addr, et.x, et.y, et.z),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform3iv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV4i(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z || nt[3] !== et.w) &&
      (tt.uniform4i(this.addr, et.x, et.y, et.z, et.w),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z),
      (nt[3] = et.w));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform4iv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV1ui(tt, et) {
  const nt = this.cache;
  nt[0] !== et && (tt.uniform1ui(this.addr, et), (nt[0] = et));
}
function setValueV2ui(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y) &&
      (tt.uniform2ui(this.addr, et.x, et.y), (nt[0] = et.x), (nt[1] = et.y));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform2uiv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV3ui(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z) &&
      (tt.uniform3ui(this.addr, et.x, et.y, et.z),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform3uiv(this.addr, et), copyArray(nt, et);
  }
}
function setValueV4ui(tt, et) {
  const nt = this.cache;
  if (et.x !== void 0)
    (nt[0] !== et.x || nt[1] !== et.y || nt[2] !== et.z || nt[3] !== et.w) &&
      (tt.uniform4ui(this.addr, et.x, et.y, et.z, et.w),
      (nt[0] = et.x),
      (nt[1] = et.y),
      (nt[2] = et.z),
      (nt[3] = et.w));
  else {
    if (arraysEqual(nt, et)) return;
    tt.uniform4uiv(this.addr, et), copyArray(nt, et);
  }
}
function setValueT1(tt, et, nt) {
  const rt = this.cache,
    it = nt.allocateTextureUnit();
  rt[0] !== it && (tt.uniform1i(this.addr, it), (rt[0] = it)),
    nt.setTexture2D(et || emptyTexture, it);
}
function setValueT3D1(tt, et, nt) {
  const rt = this.cache,
    it = nt.allocateTextureUnit();
  rt[0] !== it && (tt.uniform1i(this.addr, it), (rt[0] = it)),
    nt.setTexture3D(et || empty3dTexture, it);
}
function setValueT6(tt, et, nt) {
  const rt = this.cache,
    it = nt.allocateTextureUnit();
  rt[0] !== it && (tt.uniform1i(this.addr, it), (rt[0] = it)),
    nt.setTextureCube(et || emptyCubeTexture, it);
}
function setValueT2DArray1(tt, et, nt) {
  const rt = this.cache,
    it = nt.allocateTextureUnit();
  rt[0] !== it && (tt.uniform1i(this.addr, it), (rt[0] = it)),
    nt.setTexture2DArray(et || emptyArrayTexture, it);
}
function getSingularSetter(tt) {
  switch (tt) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(tt, et) {
  tt.uniform1fv(this.addr, et);
}
function setValueV2fArray(tt, et) {
  const nt = flatten(et, this.size, 2);
  tt.uniform2fv(this.addr, nt);
}
function setValueV3fArray(tt, et) {
  const nt = flatten(et, this.size, 3);
  tt.uniform3fv(this.addr, nt);
}
function setValueV4fArray(tt, et) {
  const nt = flatten(et, this.size, 4);
  tt.uniform4fv(this.addr, nt);
}
function setValueM2Array(tt, et) {
  const nt = flatten(et, this.size, 4);
  tt.uniformMatrix2fv(this.addr, !1, nt);
}
function setValueM3Array(tt, et) {
  const nt = flatten(et, this.size, 9);
  tt.uniformMatrix3fv(this.addr, !1, nt);
}
function setValueM4Array(tt, et) {
  const nt = flatten(et, this.size, 16);
  tt.uniformMatrix4fv(this.addr, !1, nt);
}
function setValueV1iArray(tt, et) {
  tt.uniform1iv(this.addr, et);
}
function setValueV2iArray(tt, et) {
  tt.uniform2iv(this.addr, et);
}
function setValueV3iArray(tt, et) {
  tt.uniform3iv(this.addr, et);
}
function setValueV4iArray(tt, et) {
  tt.uniform4iv(this.addr, et);
}
function setValueV1uiArray(tt, et) {
  tt.uniform1uiv(this.addr, et);
}
function setValueV2uiArray(tt, et) {
  tt.uniform2uiv(this.addr, et);
}
function setValueV3uiArray(tt, et) {
  tt.uniform3uiv(this.addr, et);
}
function setValueV4uiArray(tt, et) {
  tt.uniform4uiv(this.addr, et);
}
function setValueT1Array(tt, et, nt) {
  const rt = this.cache,
    it = et.length,
    st = allocTexUnits(nt, it);
  arraysEqual(rt, st) || (tt.uniform1iv(this.addr, st), copyArray(rt, st));
  for (let ot = 0; ot !== it; ++ot)
    nt.setTexture2D(et[ot] || emptyTexture, st[ot]);
}
function setValueT3DArray(tt, et, nt) {
  const rt = this.cache,
    it = et.length,
    st = allocTexUnits(nt, it);
  arraysEqual(rt, st) || (tt.uniform1iv(this.addr, st), copyArray(rt, st));
  for (let ot = 0; ot !== it; ++ot)
    nt.setTexture3D(et[ot] || empty3dTexture, st[ot]);
}
function setValueT6Array(tt, et, nt) {
  const rt = this.cache,
    it = et.length,
    st = allocTexUnits(nt, it);
  arraysEqual(rt, st) || (tt.uniform1iv(this.addr, st), copyArray(rt, st));
  for (let ot = 0; ot !== it; ++ot)
    nt.setTextureCube(et[ot] || emptyCubeTexture, st[ot]);
}
function setValueT2DArrayArray(tt, et, nt) {
  const rt = this.cache,
    it = et.length,
    st = allocTexUnits(nt, it);
  arraysEqual(rt, st) || (tt.uniform1iv(this.addr, st), copyArray(rt, st));
  for (let ot = 0; ot !== it; ++ot)
    nt.setTexture2DArray(et[ot] || emptyArrayTexture, st[ot]);
}
function getPureArraySetter(tt) {
  switch (tt) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(et, nt, rt) {
    (this.id = et),
      (this.addr = rt),
      (this.cache = []),
      (this.setValue = getSingularSetter(nt.type));
  }
}
class PureArrayUniform {
  constructor(et, nt, rt) {
    (this.id = et),
      (this.addr = rt),
      (this.cache = []),
      (this.size = nt.size),
      (this.setValue = getPureArraySetter(nt.type));
  }
}
class StructuredUniform {
  constructor(et) {
    (this.id = et), (this.seq = []), (this.map = {});
  }
  setValue(et, nt, rt) {
    const it = this.seq;
    for (let st = 0, ot = it.length; st !== ot; ++st) {
      const at = it[st];
      at.setValue(et, nt[at.id], rt);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(tt, et) {
  tt.seq.push(et), (tt.map[et.id] = et);
}
function parseUniform(tt, et, nt) {
  const rt = tt.name,
    it = rt.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const st = RePathPart.exec(rt),
      ot = RePathPart.lastIndex;
    let at = st[1];
    const lt = st[2] === "]",
      ct = st[3];
    if ((lt && (at = at | 0), ct === void 0 || (ct === "[" && ot + 2 === it))) {
      addUniform(
        nt,
        ct === void 0
          ? new SingleUniform(at, tt, et)
          : new PureArrayUniform(at, tt, et)
      );
      break;
    } else {
      let ft = nt.map[at];
      ft === void 0 && ((ft = new StructuredUniform(at)), addUniform(nt, ft)),
        (nt = ft);
    }
  }
}
class WebGLUniforms {
  constructor(et, nt) {
    (this.seq = []), (this.map = {});
    const rt = et.getProgramParameter(nt, et.ACTIVE_UNIFORMS);
    for (let it = 0; it < rt; ++it) {
      const st = et.getActiveUniform(nt, it),
        ot = et.getUniformLocation(nt, st.name);
      parseUniform(st, ot, this);
    }
  }
  setValue(et, nt, rt, it) {
    const st = this.map[nt];
    st !== void 0 && st.setValue(et, rt, it);
  }
  setOptional(et, nt, rt) {
    const it = nt[rt];
    it !== void 0 && this.setValue(et, rt, it);
  }
  static upload(et, nt, rt, it) {
    for (let st = 0, ot = nt.length; st !== ot; ++st) {
      const at = nt[st],
        lt = rt[at.id];
      lt.needsUpdate !== !1 && at.setValue(et, lt.value, it);
    }
  }
  static seqWithValue(et, nt) {
    const rt = [];
    for (let it = 0, st = et.length; it !== st; ++it) {
      const ot = et[it];
      ot.id in nt && rt.push(ot);
    }
    return rt;
  }
}
function WebGLShader(tt, et, nt) {
  const rt = tt.createShader(et);
  return tt.shaderSource(rt, nt), tt.compileShader(rt), rt;
}
let programIdCount = 0;
function handleSource(tt, et) {
  const nt = tt.split(`
`),
    rt = [],
    it = Math.max(et - 6, 0),
    st = Math.min(et + 6, nt.length);
  for (let ot = it; ot < st; ot++) {
    const at = ot + 1;
    rt.push(`${at === et ? ">" : " "} ${at}: ${nt[ot]}`);
  }
  return rt.join(`
`);
}
function getEncodingComponents(tt) {
  const et = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
    nt = ColorManagement.getPrimaries(tt);
  let rt;
  switch (
    (et === nt
      ? (rt = "")
      : et === P3Primaries && nt === Rec709Primaries
      ? (rt = "LinearDisplayP3ToLinearSRGB")
      : et === Rec709Primaries &&
        nt === P3Primaries &&
        (rt = "LinearSRGBToLinearDisplayP3"),
    tt)
  ) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [rt, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [rt, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", tt),
        [rt, "LinearTransferOETF"]
      );
  }
}
function getShaderErrors(tt, et, nt) {
  const rt = tt.getShaderParameter(et, tt.COMPILE_STATUS),
    it = tt.getShaderInfoLog(et).trim();
  if (rt && it === "") return "";
  const st = /ERROR: 0:(\d+)/.exec(it);
  if (st) {
    const ot = parseInt(st[1]);
    return (
      nt.toUpperCase() +
      `

` +
      it +
      `

` +
      handleSource(tt.getShaderSource(et), ot)
    );
  } else return it;
}
function getTexelEncodingFunction(tt, et) {
  const nt = getEncodingComponents(et);
  return `vec4 ${tt}( vec4 value ) { return ${nt[0]}( ${nt[1]}( value ) ); }`;
}
function getToneMappingFunction(tt, et) {
  let nt;
  switch (et) {
    case LinearToneMapping:
      nt = "Linear";
      break;
    case ReinhardToneMapping:
      nt = "Reinhard";
      break;
    case CineonToneMapping:
      nt = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      nt = "ACESFilmic";
      break;
    case CustomToneMapping:
      nt = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", et),
        (nt = "Linear");
  }
  return (
    "vec3 " + tt + "( vec3 color ) { return " + nt + "ToneMapping( color ); }"
  );
}
function generateExtensions(tt) {
  return [
    tt.extensionDerivatives ||
    tt.envMapCubeUVHeight ||
    tt.bumpMap ||
    tt.normalMapTangentSpace ||
    tt.clearcoatNormalMap ||
    tt.flatShading ||
    tt.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (tt.extensionFragDepth || tt.logarithmicDepthBuffer) &&
    tt.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    tt.extensionDrawBuffers && tt.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (tt.extensionShaderTextureLOD || tt.envMap || tt.transmission) &&
    tt.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(tt) {
  const et = [];
  for (const nt in tt) {
    const rt = tt[nt];
    rt !== !1 && et.push("#define " + nt + " " + rt);
  }
  return et.join(`
`);
}
function fetchAttributeLocations(tt, et) {
  const nt = {},
    rt = tt.getProgramParameter(et, tt.ACTIVE_ATTRIBUTES);
  for (let it = 0; it < rt; it++) {
    const st = tt.getActiveAttrib(et, it),
      ot = st.name;
    let at = 1;
    st.type === tt.FLOAT_MAT2 && (at = 2),
      st.type === tt.FLOAT_MAT3 && (at = 3),
      st.type === tt.FLOAT_MAT4 && (at = 4),
      (nt[ot] = {
        type: st.type,
        location: tt.getAttribLocation(et, ot),
        locationSize: at,
      });
  }
  return nt;
}
function filterEmptyLine(tt) {
  return tt !== "";
}
function replaceLightNums(tt, et) {
  const nt =
    et.numSpotLightShadows +
    et.numSpotLightMaps -
    et.numSpotLightShadowsWithMaps;
  return tt
    .replace(/NUM_DIR_LIGHTS/g, et.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, et.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, et.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, nt)
    .replace(/NUM_RECT_AREA_LIGHTS/g, et.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, et.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, et.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, et.numDirLightShadows)
    .replace(
      /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
      et.numSpotLightShadowsWithMaps
    )
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, et.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, et.numPointLightShadows);
}
function replaceClippingPlaneNums(tt, et) {
  return tt
    .replace(/NUM_CLIPPING_PLANES/g, et.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      et.numClippingPlanes - et.numClipIntersection
    );
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(tt) {
  return tt.replace(includePattern, includeReplacer);
}
const shaderChunkMap = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function includeReplacer(tt, et) {
  let nt = ShaderChunk[et];
  if (nt === void 0) {
    const rt = shaderChunkMap.get(et);
    if (rt !== void 0)
      (nt = ShaderChunk[rt]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          et,
          rt
        );
    else throw new Error("Can not resolve #include <" + et + ">");
  }
  return resolveIncludes(nt);
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(tt) {
  return tt.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(tt, et, nt, rt) {
  let it = "";
  for (let st = parseInt(et); st < parseInt(nt); st++)
    it += rt
      .replace(/\[\s*i\s*\]/g, "[ " + st + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, st);
  return it;
}
function generatePrecision(tt) {
  let et =
    "precision " +
    tt.precision +
    ` float;
precision ` +
    tt.precision +
    " int;";
  return (
    tt.precision === "highp"
      ? (et += `
#define HIGH_PRECISION`)
      : tt.precision === "mediump"
      ? (et += `
#define MEDIUM_PRECISION`)
      : tt.precision === "lowp" &&
        (et += `
#define LOW_PRECISION`),
    et
  );
}
function generateShadowMapTypeDefine(tt) {
  let et = "SHADOWMAP_TYPE_BASIC";
  return (
    tt.shadowMapType === PCFShadowMap
      ? (et = "SHADOWMAP_TYPE_PCF")
      : tt.shadowMapType === PCFSoftShadowMap
      ? (et = "SHADOWMAP_TYPE_PCF_SOFT")
      : tt.shadowMapType === VSMShadowMap && (et = "SHADOWMAP_TYPE_VSM"),
    et
  );
}
function generateEnvMapTypeDefine(tt) {
  let et = "ENVMAP_TYPE_CUBE";
  if (tt.envMap)
    switch (tt.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        et = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        et = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return et;
}
function generateEnvMapModeDefine(tt) {
  let et = "ENVMAP_MODE_REFLECTION";
  if (tt.envMap)
    switch (tt.envMapMode) {
      case CubeRefractionMapping:
        et = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return et;
}
function generateEnvMapBlendingDefine(tt) {
  let et = "ENVMAP_BLENDING_NONE";
  if (tt.envMap)
    switch (tt.combine) {
      case MultiplyOperation:
        et = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        et = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        et = "ENVMAP_BLENDING_ADD";
        break;
    }
  return et;
}
function generateCubeUVSize(tt) {
  const et = tt.envMapCubeUVHeight;
  if (et === null) return null;
  const nt = Math.log2(et) - 2,
    rt = 1 / et;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, nt), 7 * 16)),
    texelHeight: rt,
    maxMip: nt,
  };
}
function WebGLProgram(tt, et, nt, rt) {
  const it = tt.getContext(),
    st = nt.defines;
  let ot = nt.vertexShader,
    at = nt.fragmentShader;
  const lt = generateShadowMapTypeDefine(nt),
    ct = generateEnvMapTypeDefine(nt),
    ut = generateEnvMapModeDefine(nt),
    ft = generateEnvMapBlendingDefine(nt),
    ht = generateCubeUVSize(nt),
    mt = nt.isWebGL2 ? "" : generateExtensions(nt),
    vt = generateDefines(st),
    yt = it.createProgram();
  let Et,
    pt,
    xt = nt.glslVersion
      ? "#version " +
        nt.glslVersion +
        `
`
      : "";
  nt.isRawShaderMaterial
    ? ((Et = [
        "#define SHADER_TYPE " + nt.shaderType,
        "#define SHADER_NAME " + nt.shaderName,
        vt,
      ].filter(filterEmptyLine).join(`
`)),
      Et.length > 0 &&
        (Et += `
`),
      (pt = [
        mt,
        "#define SHADER_TYPE " + nt.shaderType,
        "#define SHADER_NAME " + nt.shaderName,
        vt,
      ].filter(filterEmptyLine).join(`
`)),
      pt.length > 0 &&
        (pt += `
`))
    : ((Et = [
        generatePrecision(nt),
        "#define SHADER_TYPE " + nt.shaderType,
        "#define SHADER_NAME " + nt.shaderName,
        vt,
        nt.instancing ? "#define USE_INSTANCING" : "",
        nt.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        nt.useFog && nt.fog ? "#define USE_FOG" : "",
        nt.useFog && nt.fogExp2 ? "#define FOG_EXP2" : "",
        nt.map ? "#define USE_MAP" : "",
        nt.envMap ? "#define USE_ENVMAP" : "",
        nt.envMap ? "#define " + ut : "",
        nt.lightMap ? "#define USE_LIGHTMAP" : "",
        nt.aoMap ? "#define USE_AOMAP" : "",
        nt.bumpMap ? "#define USE_BUMPMAP" : "",
        nt.normalMap ? "#define USE_NORMALMAP" : "",
        nt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        nt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        nt.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        nt.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        nt.anisotropy ? "#define USE_ANISOTROPY" : "",
        nt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        nt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        nt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        nt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        nt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        nt.iridescenceThicknessMap
          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
          : "",
        nt.specularMap ? "#define USE_SPECULARMAP" : "",
        nt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        nt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        nt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        nt.metalnessMap ? "#define USE_METALNESSMAP" : "",
        nt.alphaMap ? "#define USE_ALPHAMAP" : "",
        nt.alphaHash ? "#define USE_ALPHAHASH" : "",
        nt.transmission ? "#define USE_TRANSMISSION" : "",
        nt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        nt.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        nt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        nt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        nt.mapUv ? "#define MAP_UV " + nt.mapUv : "",
        nt.alphaMapUv ? "#define ALPHAMAP_UV " + nt.alphaMapUv : "",
        nt.lightMapUv ? "#define LIGHTMAP_UV " + nt.lightMapUv : "",
        nt.aoMapUv ? "#define AOMAP_UV " + nt.aoMapUv : "",
        nt.emissiveMapUv ? "#define EMISSIVEMAP_UV " + nt.emissiveMapUv : "",
        nt.bumpMapUv ? "#define BUMPMAP_UV " + nt.bumpMapUv : "",
        nt.normalMapUv ? "#define NORMALMAP_UV " + nt.normalMapUv : "",
        nt.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + nt.displacementMapUv
          : "",
        nt.metalnessMapUv ? "#define METALNESSMAP_UV " + nt.metalnessMapUv : "",
        nt.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + nt.roughnessMapUv : "",
        nt.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + nt.anisotropyMapUv
          : "",
        nt.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + nt.clearcoatMapUv : "",
        nt.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + nt.clearcoatNormalMapUv
          : "",
        nt.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + nt.clearcoatRoughnessMapUv
          : "",
        nt.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + nt.iridescenceMapUv
          : "",
        nt.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
            nt.iridescenceThicknessMapUv
          : "",
        nt.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + nt.sheenColorMapUv
          : "",
        nt.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + nt.sheenRoughnessMapUv
          : "",
        nt.specularMapUv ? "#define SPECULARMAP_UV " + nt.specularMapUv : "",
        nt.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + nt.specularColorMapUv
          : "",
        nt.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + nt.specularIntensityMapUv
          : "",
        nt.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + nt.transmissionMapUv
          : "",
        nt.thicknessMapUv ? "#define THICKNESSMAP_UV " + nt.thicknessMapUv : "",
        nt.vertexTangents && nt.flatShading === !1 ? "#define USE_TANGENT" : "",
        nt.vertexColors ? "#define USE_COLOR" : "",
        nt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        nt.vertexUv1s ? "#define USE_UV1" : "",
        nt.vertexUv2s ? "#define USE_UV2" : "",
        nt.vertexUv3s ? "#define USE_UV3" : "",
        nt.pointsUvs ? "#define USE_POINTS_UV" : "",
        nt.flatShading ? "#define FLAT_SHADED" : "",
        nt.skinning ? "#define USE_SKINNING" : "",
        nt.morphTargets ? "#define USE_MORPHTARGETS" : "",
        nt.morphNormals && nt.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        nt.morphColors && nt.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        nt.morphTargetsCount > 0 && nt.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        nt.morphTargetsCount > 0 && nt.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + nt.morphTextureStride
          : "",
        nt.morphTargetsCount > 0 && nt.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + nt.morphTargetsCount
          : "",
        nt.doubleSided ? "#define DOUBLE_SIDED" : "",
        nt.flipSided ? "#define FLIP_SIDED" : "",
        nt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        nt.shadowMapEnabled ? "#define " + lt : "",
        nt.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        nt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        nt.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        nt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        nt.logarithmicDepthBuffer && nt.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(filterEmptyLine).join(`
`)),
      (pt = [
        mt,
        generatePrecision(nt),
        "#define SHADER_TYPE " + nt.shaderType,
        "#define SHADER_NAME " + nt.shaderName,
        vt,
        nt.useFog && nt.fog ? "#define USE_FOG" : "",
        nt.useFog && nt.fogExp2 ? "#define FOG_EXP2" : "",
        nt.map ? "#define USE_MAP" : "",
        nt.matcap ? "#define USE_MATCAP" : "",
        nt.envMap ? "#define USE_ENVMAP" : "",
        nt.envMap ? "#define " + ct : "",
        nt.envMap ? "#define " + ut : "",
        nt.envMap ? "#define " + ft : "",
        ht ? "#define CUBEUV_TEXEL_WIDTH " + ht.texelWidth : "",
        ht ? "#define CUBEUV_TEXEL_HEIGHT " + ht.texelHeight : "",
        ht ? "#define CUBEUV_MAX_MIP " + ht.maxMip + ".0" : "",
        nt.lightMap ? "#define USE_LIGHTMAP" : "",
        nt.aoMap ? "#define USE_AOMAP" : "",
        nt.bumpMap ? "#define USE_BUMPMAP" : "",
        nt.normalMap ? "#define USE_NORMALMAP" : "",
        nt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        nt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        nt.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        nt.anisotropy ? "#define USE_ANISOTROPY" : "",
        nt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        nt.clearcoat ? "#define USE_CLEARCOAT" : "",
        nt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        nt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        nt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        nt.iridescence ? "#define USE_IRIDESCENCE" : "",
        nt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        nt.iridescenceThicknessMap
          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
          : "",
        nt.specularMap ? "#define USE_SPECULARMAP" : "",
        nt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        nt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        nt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        nt.metalnessMap ? "#define USE_METALNESSMAP" : "",
        nt.alphaMap ? "#define USE_ALPHAMAP" : "",
        nt.alphaTest ? "#define USE_ALPHATEST" : "",
        nt.alphaHash ? "#define USE_ALPHAHASH" : "",
        nt.sheen ? "#define USE_SHEEN" : "",
        nt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        nt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        nt.transmission ? "#define USE_TRANSMISSION" : "",
        nt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        nt.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        nt.vertexTangents && nt.flatShading === !1 ? "#define USE_TANGENT" : "",
        nt.vertexColors || nt.instancingColor ? "#define USE_COLOR" : "",
        nt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        nt.vertexUv1s ? "#define USE_UV1" : "",
        nt.vertexUv2s ? "#define USE_UV2" : "",
        nt.vertexUv3s ? "#define USE_UV3" : "",
        nt.pointsUvs ? "#define USE_POINTS_UV" : "",
        nt.gradientMap ? "#define USE_GRADIENTMAP" : "",
        nt.flatShading ? "#define FLAT_SHADED" : "",
        nt.doubleSided ? "#define DOUBLE_SIDED" : "",
        nt.flipSided ? "#define FLIP_SIDED" : "",
        nt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        nt.shadowMapEnabled ? "#define " + lt : "",
        nt.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        nt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        nt.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        nt.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        nt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        nt.logarithmicDepthBuffer && nt.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        nt.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        nt.toneMapping !== NoToneMapping
          ? ShaderChunk.tonemapping_pars_fragment
          : "",
        nt.toneMapping !== NoToneMapping
          ? getToneMappingFunction("toneMapping", nt.toneMapping)
          : "",
        nt.dithering ? "#define DITHERING" : "",
        nt.opaque ? "#define OPAQUE" : "",
        ShaderChunk.colorspace_pars_fragment,
        getTexelEncodingFunction("linearToOutputTexel", nt.outputColorSpace),
        nt.useDepthPacking ? "#define DEPTH_PACKING " + nt.depthPacking : "",
        `
`,
      ].filter(filterEmptyLine).join(`
`))),
    (ot = resolveIncludes(ot)),
    (ot = replaceLightNums(ot, nt)),
    (ot = replaceClippingPlaneNums(ot, nt)),
    (at = resolveIncludes(at)),
    (at = replaceLightNums(at, nt)),
    (at = replaceClippingPlaneNums(at, nt)),
    (ot = unrollLoops(ot)),
    (at = unrollLoops(at)),
    nt.isWebGL2 &&
      nt.isRawShaderMaterial !== !0 &&
      ((xt = `#version 300 es
`),
      (Et =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        Et),
      (pt =
        [
          "#define varying in",
          nt.glslVersion === GLSL3
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          nt.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        pt));
  const St = xt + Et + ot,
    At = xt + pt + at,
    Ct = WebGLShader(it, it.VERTEX_SHADER, St),
    Mt = WebGLShader(it, it.FRAGMENT_SHADER, At);
  if (
    (it.attachShader(yt, Ct),
    it.attachShader(yt, Mt),
    nt.index0AttributeName !== void 0
      ? it.bindAttribLocation(yt, 0, nt.index0AttributeName)
      : nt.morphTargets === !0 && it.bindAttribLocation(yt, 0, "position"),
    it.linkProgram(yt),
    tt.debug.checkShaderErrors)
  ) {
    const It = it.getProgramInfoLog(yt).trim(),
      Ft = it.getShaderInfoLog(Ct).trim(),
      Vt = it.getShaderInfoLog(Mt).trim();
    let $t = !0,
      Kt = !0;
    if (it.getProgramParameter(yt, it.LINK_STATUS) === !1)
      if ((($t = !1), typeof tt.debug.onShaderError == "function"))
        tt.debug.onShaderError(it, yt, Ct, Mt);
      else {
        const Ht = getShaderErrors(it, Ct, "vertex"),
          Wt = getShaderErrors(it, Mt, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            it.getError() +
            " - VALIDATE_STATUS " +
            it.getProgramParameter(yt, it.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            It +
            `
` +
            Ht +
            `
` +
            Wt
        );
      }
    else
      It !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", It)
        : (Ft === "" || Vt === "") && (Kt = !1);
    Kt &&
      (this.diagnostics = {
        runnable: $t,
        programLog: It,
        vertexShader: { log: Ft, prefix: Et },
        fragmentShader: { log: Vt, prefix: pt },
      });
  }
  it.deleteShader(Ct), it.deleteShader(Mt);
  let wt;
  this.getUniforms = function () {
    return wt === void 0 && (wt = new WebGLUniforms(it, yt)), wt;
  };
  let Bt;
  return (
    (this.getAttributes = function () {
      return Bt === void 0 && (Bt = fetchAttributeLocations(it, yt)), Bt;
    }),
    (this.destroy = function () {
      rt.releaseStatesOfProgram(this),
        it.deleteProgram(yt),
        (this.program = void 0);
    }),
    (this.type = nt.shaderType),
    (this.name = nt.shaderName),
    (this.id = programIdCount++),
    (this.cacheKey = et),
    (this.usedTimes = 1),
    (this.program = yt),
    (this.vertexShader = Ct),
    (this.fragmentShader = Mt),
    this
  );
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(et) {
    const nt = et.vertexShader,
      rt = et.fragmentShader,
      it = this._getShaderStage(nt),
      st = this._getShaderStage(rt),
      ot = this._getShaderCacheForMaterial(et);
    return (
      ot.has(it) === !1 && (ot.add(it), it.usedTimes++),
      ot.has(st) === !1 && (ot.add(st), st.usedTimes++),
      this
    );
  }
  remove(et) {
    const nt = this.materialCache.get(et);
    for (const rt of nt)
      rt.usedTimes--, rt.usedTimes === 0 && this.shaderCache.delete(rt.code);
    return this.materialCache.delete(et), this;
  }
  getVertexShaderID(et) {
    return this._getShaderStage(et.vertexShader).id;
  }
  getFragmentShaderID(et) {
    return this._getShaderStage(et.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(et) {
    const nt = this.materialCache;
    let rt = nt.get(et);
    return rt === void 0 && ((rt = new Set()), nt.set(et, rt)), rt;
  }
  _getShaderStage(et) {
    const nt = this.shaderCache;
    let rt = nt.get(et);
    return (
      rt === void 0 && ((rt = new WebGLShaderStage(et)), nt.set(et, rt)), rt
    );
  }
}
class WebGLShaderStage {
  constructor(et) {
    (this.id = _id$1++), (this.code = et), (this.usedTimes = 0);
  }
}
function WebGLPrograms(tt, et, nt, rt, it, st, ot) {
  const at = new Layers(),
    lt = new WebGLShaderCache(),
    ct = [],
    ut = it.isWebGL2,
    ft = it.logarithmicDepthBuffer,
    ht = it.vertexTextures;
  let mt = it.precision;
  const vt = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function yt(It) {
    return It === 0 ? "uv" : `uv${It}`;
  }
  function Et(It, Ft, Vt, $t, Kt) {
    const Ht = $t.fog,
      Wt = Kt.geometry,
      kt = It.isMeshStandardMaterial ? $t.environment : null,
      Gt = (It.isMeshStandardMaterial ? nt : et).get(It.envMap || kt),
      Pt =
        Gt && Gt.mapping === CubeUVReflectionMapping ? Gt.image.height : null,
      Rt = vt[It.type];
    It.precision !== null &&
      ((mt = it.getMaxPrecision(It.precision)),
      mt !== It.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          It.precision,
          "not supported, using",
          mt,
          "instead."
        ));
    const Nt =
        Wt.morphAttributes.position ||
        Wt.morphAttributes.normal ||
        Wt.morphAttributes.color,
      Dt = Nt !== void 0 ? Nt.length : 0;
    let zt = 0;
    Wt.morphAttributes.position !== void 0 && (zt = 1),
      Wt.morphAttributes.normal !== void 0 && (zt = 2),
      Wt.morphAttributes.color !== void 0 && (zt = 3);
    let Yt, qt, Zt, Jt;
    if (Rt) {
      const Ar = ShaderLib[Rt];
      (Yt = Ar.vertexShader), (qt = Ar.fragmentShader);
    } else
      (Yt = It.vertexShader),
        (qt = It.fragmentShader),
        lt.update(It),
        (Zt = lt.getVertexShaderID(It)),
        (Jt = lt.getFragmentShaderID(It));
    const mn = tt.getRenderTarget(),
      ln = Kt.isInstancedMesh === !0,
      bn = !!It.map,
      Bn = !!It.matcap,
      gn = !!Gt,
      jt = !!It.aoMap,
      yn = !!It.lightMap,
      pn = !!It.bumpMap,
      vn = !!It.normalMap,
      xn = !!It.displacementMap,
      Fn = !!It.emissiveMap,
      _n = !!It.metalnessMap,
      Dn = !!It.roughnessMap,
      Tn = It.anisotropy > 0,
      An = It.clearcoat > 0,
      Wn = It.iridescence > 0,
      Xt = It.sheen > 0,
      Ut = It.transmission > 0,
      hn = Tn && !!It.anisotropyMap,
      Ln = An && !!It.clearcoatMap,
      Cn = An && !!It.clearcoatNormalMap,
      Mn = An && !!It.clearcoatRoughnessMap,
      kn = Wn && !!It.iridescenceMap,
      Vn = Wn && !!It.iridescenceThicknessMap,
      Kn = Xt && !!It.sheenColorMap,
      Yn = Xt && !!It.sheenRoughnessMap,
      ir = !!It.specularMap,
      On = !!It.specularColorMap,
      qn = !!It.specularIntensityMap,
      dn = Ut && !!It.transmissionMap,
      Pn = Ut && !!It.thicknessMap,
      Hn = !!It.gradientMap,
      Qt = !!It.alphaMap,
      zn = It.alphaTest > 0,
      Xn = !!It.alphaHash,
      Qn = !!It.extensions,
      tr = !!Wt.attributes.uv1,
      jn = !!Wt.attributes.uv2,
      nr = !!Wt.attributes.uv3;
    let or = NoToneMapping;
    return (
      It.toneMapped &&
        (mn === null || mn.isXRRenderTarget === !0) &&
        (or = tt.toneMapping),
      {
        isWebGL2: ut,
        shaderID: Rt,
        shaderType: It.type,
        shaderName: It.name,
        vertexShader: Yt,
        fragmentShader: qt,
        defines: It.defines,
        customVertexShaderID: Zt,
        customFragmentShaderID: Jt,
        isRawShaderMaterial: It.isRawShaderMaterial === !0,
        glslVersion: It.glslVersion,
        precision: mt,
        instancing: ln,
        instancingColor: ln && Kt.instanceColor !== null,
        supportsVertexTextures: ht,
        outputColorSpace:
          mn === null
            ? tt.outputColorSpace
            : mn.isXRRenderTarget === !0
            ? mn.texture.colorSpace
            : LinearSRGBColorSpace,
        map: bn,
        matcap: Bn,
        envMap: gn,
        envMapMode: gn && Gt.mapping,
        envMapCubeUVHeight: Pt,
        aoMap: jt,
        lightMap: yn,
        bumpMap: pn,
        normalMap: vn,
        displacementMap: ht && xn,
        emissiveMap: Fn,
        normalMapObjectSpace: vn && It.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: vn && It.normalMapType === TangentSpaceNormalMap,
        metalnessMap: _n,
        roughnessMap: Dn,
        anisotropy: Tn,
        anisotropyMap: hn,
        clearcoat: An,
        clearcoatMap: Ln,
        clearcoatNormalMap: Cn,
        clearcoatRoughnessMap: Mn,
        iridescence: Wn,
        iridescenceMap: kn,
        iridescenceThicknessMap: Vn,
        sheen: Xt,
        sheenColorMap: Kn,
        sheenRoughnessMap: Yn,
        specularMap: ir,
        specularColorMap: On,
        specularIntensityMap: qn,
        transmission: Ut,
        transmissionMap: dn,
        thicknessMap: Pn,
        gradientMap: Hn,
        opaque: It.transparent === !1 && It.blending === NormalBlending,
        alphaMap: Qt,
        alphaTest: zn,
        alphaHash: Xn,
        combine: It.combine,
        mapUv: bn && yt(It.map.channel),
        aoMapUv: jt && yt(It.aoMap.channel),
        lightMapUv: yn && yt(It.lightMap.channel),
        bumpMapUv: pn && yt(It.bumpMap.channel),
        normalMapUv: vn && yt(It.normalMap.channel),
        displacementMapUv: xn && yt(It.displacementMap.channel),
        emissiveMapUv: Fn && yt(It.emissiveMap.channel),
        metalnessMapUv: _n && yt(It.metalnessMap.channel),
        roughnessMapUv: Dn && yt(It.roughnessMap.channel),
        anisotropyMapUv: hn && yt(It.anisotropyMap.channel),
        clearcoatMapUv: Ln && yt(It.clearcoatMap.channel),
        clearcoatNormalMapUv: Cn && yt(It.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: Mn && yt(It.clearcoatRoughnessMap.channel),
        iridescenceMapUv: kn && yt(It.iridescenceMap.channel),
        iridescenceThicknessMapUv: Vn && yt(It.iridescenceThicknessMap.channel),
        sheenColorMapUv: Kn && yt(It.sheenColorMap.channel),
        sheenRoughnessMapUv: Yn && yt(It.sheenRoughnessMap.channel),
        specularMapUv: ir && yt(It.specularMap.channel),
        specularColorMapUv: On && yt(It.specularColorMap.channel),
        specularIntensityMapUv: qn && yt(It.specularIntensityMap.channel),
        transmissionMapUv: dn && yt(It.transmissionMap.channel),
        thicknessMapUv: Pn && yt(It.thicknessMap.channel),
        alphaMapUv: Qt && yt(It.alphaMap.channel),
        vertexTangents: !!Wt.attributes.tangent && (vn || Tn),
        vertexColors: It.vertexColors,
        vertexAlphas:
          It.vertexColors === !0 &&
          !!Wt.attributes.color &&
          Wt.attributes.color.itemSize === 4,
        vertexUv1s: tr,
        vertexUv2s: jn,
        vertexUv3s: nr,
        pointsUvs: Kt.isPoints === !0 && !!Wt.attributes.uv && (bn || Qt),
        fog: !!Ht,
        useFog: It.fog === !0,
        fogExp2: Ht && Ht.isFogExp2,
        flatShading: It.flatShading === !0,
        sizeAttenuation: It.sizeAttenuation === !0,
        logarithmicDepthBuffer: ft,
        skinning: Kt.isSkinnedMesh === !0,
        morphTargets: Wt.morphAttributes.position !== void 0,
        morphNormals: Wt.morphAttributes.normal !== void 0,
        morphColors: Wt.morphAttributes.color !== void 0,
        morphTargetsCount: Dt,
        morphTextureStride: zt,
        numDirLights: Ft.directional.length,
        numPointLights: Ft.point.length,
        numSpotLights: Ft.spot.length,
        numSpotLightMaps: Ft.spotLightMap.length,
        numRectAreaLights: Ft.rectArea.length,
        numHemiLights: Ft.hemi.length,
        numDirLightShadows: Ft.directionalShadowMap.length,
        numPointLightShadows: Ft.pointShadowMap.length,
        numSpotLightShadows: Ft.spotShadowMap.length,
        numSpotLightShadowsWithMaps: Ft.numSpotLightShadowsWithMaps,
        numLightProbes: Ft.numLightProbes,
        numClippingPlanes: ot.numPlanes,
        numClipIntersection: ot.numIntersection,
        dithering: It.dithering,
        shadowMapEnabled: tt.shadowMap.enabled && Vt.length > 0,
        shadowMapType: tt.shadowMap.type,
        toneMapping: or,
        useLegacyLights: tt._useLegacyLights,
        decodeVideoTexture:
          bn &&
          It.map.isVideoTexture === !0 &&
          ColorManagement.getTransfer(It.map.colorSpace) === SRGBTransfer,
        premultipliedAlpha: It.premultipliedAlpha,
        doubleSided: It.side === DoubleSide,
        flipSided: It.side === BackSide,
        useDepthPacking: It.depthPacking >= 0,
        depthPacking: It.depthPacking || 0,
        index0AttributeName: It.index0AttributeName,
        extensionDerivatives: Qn && It.extensions.derivatives === !0,
        extensionFragDepth: Qn && It.extensions.fragDepth === !0,
        extensionDrawBuffers: Qn && It.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: Qn && It.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: ut || rt.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: ut || rt.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod:
          ut || rt.has("EXT_shader_texture_lod"),
        customProgramCacheKey: It.customProgramCacheKey(),
      }
    );
  }
  function pt(It) {
    const Ft = [];
    if (
      (It.shaderID
        ? Ft.push(It.shaderID)
        : (Ft.push(It.customVertexShaderID),
          Ft.push(It.customFragmentShaderID)),
      It.defines !== void 0)
    )
      for (const Vt in It.defines) Ft.push(Vt), Ft.push(It.defines[Vt]);
    return (
      It.isRawShaderMaterial === !1 &&
        (xt(Ft, It), St(Ft, It), Ft.push(tt.outputColorSpace)),
      Ft.push(It.customProgramCacheKey),
      Ft.join()
    );
  }
  function xt(It, Ft) {
    It.push(Ft.precision),
      It.push(Ft.outputColorSpace),
      It.push(Ft.envMapMode),
      It.push(Ft.envMapCubeUVHeight),
      It.push(Ft.mapUv),
      It.push(Ft.alphaMapUv),
      It.push(Ft.lightMapUv),
      It.push(Ft.aoMapUv),
      It.push(Ft.bumpMapUv),
      It.push(Ft.normalMapUv),
      It.push(Ft.displacementMapUv),
      It.push(Ft.emissiveMapUv),
      It.push(Ft.metalnessMapUv),
      It.push(Ft.roughnessMapUv),
      It.push(Ft.anisotropyMapUv),
      It.push(Ft.clearcoatMapUv),
      It.push(Ft.clearcoatNormalMapUv),
      It.push(Ft.clearcoatRoughnessMapUv),
      It.push(Ft.iridescenceMapUv),
      It.push(Ft.iridescenceThicknessMapUv),
      It.push(Ft.sheenColorMapUv),
      It.push(Ft.sheenRoughnessMapUv),
      It.push(Ft.specularMapUv),
      It.push(Ft.specularColorMapUv),
      It.push(Ft.specularIntensityMapUv),
      It.push(Ft.transmissionMapUv),
      It.push(Ft.thicknessMapUv),
      It.push(Ft.combine),
      It.push(Ft.fogExp2),
      It.push(Ft.sizeAttenuation),
      It.push(Ft.morphTargetsCount),
      It.push(Ft.morphAttributeCount),
      It.push(Ft.numDirLights),
      It.push(Ft.numPointLights),
      It.push(Ft.numSpotLights),
      It.push(Ft.numSpotLightMaps),
      It.push(Ft.numHemiLights),
      It.push(Ft.numRectAreaLights),
      It.push(Ft.numDirLightShadows),
      It.push(Ft.numPointLightShadows),
      It.push(Ft.numSpotLightShadows),
      It.push(Ft.numSpotLightShadowsWithMaps),
      It.push(Ft.numLightProbes),
      It.push(Ft.shadowMapType),
      It.push(Ft.toneMapping),
      It.push(Ft.numClippingPlanes),
      It.push(Ft.numClipIntersection),
      It.push(Ft.depthPacking);
  }
  function St(It, Ft) {
    at.disableAll(),
      Ft.isWebGL2 && at.enable(0),
      Ft.supportsVertexTextures && at.enable(1),
      Ft.instancing && at.enable(2),
      Ft.instancingColor && at.enable(3),
      Ft.matcap && at.enable(4),
      Ft.envMap && at.enable(5),
      Ft.normalMapObjectSpace && at.enable(6),
      Ft.normalMapTangentSpace && at.enable(7),
      Ft.clearcoat && at.enable(8),
      Ft.iridescence && at.enable(9),
      Ft.alphaTest && at.enable(10),
      Ft.vertexColors && at.enable(11),
      Ft.vertexAlphas && at.enable(12),
      Ft.vertexUv1s && at.enable(13),
      Ft.vertexUv2s && at.enable(14),
      Ft.vertexUv3s && at.enable(15),
      Ft.vertexTangents && at.enable(16),
      Ft.anisotropy && at.enable(17),
      It.push(at.mask),
      at.disableAll(),
      Ft.fog && at.enable(0),
      Ft.useFog && at.enable(1),
      Ft.flatShading && at.enable(2),
      Ft.logarithmicDepthBuffer && at.enable(3),
      Ft.skinning && at.enable(4),
      Ft.morphTargets && at.enable(5),
      Ft.morphNormals && at.enable(6),
      Ft.morphColors && at.enable(7),
      Ft.premultipliedAlpha && at.enable(8),
      Ft.shadowMapEnabled && at.enable(9),
      Ft.useLegacyLights && at.enable(10),
      Ft.doubleSided && at.enable(11),
      Ft.flipSided && at.enable(12),
      Ft.useDepthPacking && at.enable(13),
      Ft.dithering && at.enable(14),
      Ft.transmission && at.enable(15),
      Ft.sheen && at.enable(16),
      Ft.opaque && at.enable(17),
      Ft.pointsUvs && at.enable(18),
      Ft.decodeVideoTexture && at.enable(19),
      It.push(at.mask);
  }
  function At(It) {
    const Ft = vt[It.type];
    let Vt;
    if (Ft) {
      const $t = ShaderLib[Ft];
      Vt = UniformsUtils.clone($t.uniforms);
    } else Vt = It.uniforms;
    return Vt;
  }
  function Ct(It, Ft) {
    let Vt;
    for (let $t = 0, Kt = ct.length; $t < Kt; $t++) {
      const Ht = ct[$t];
      if (Ht.cacheKey === Ft) {
        (Vt = Ht), ++Vt.usedTimes;
        break;
      }
    }
    return (
      Vt === void 0 && ((Vt = new WebGLProgram(tt, Ft, It, st)), ct.push(Vt)),
      Vt
    );
  }
  function Mt(It) {
    if (--It.usedTimes === 0) {
      const Ft = ct.indexOf(It);
      (ct[Ft] = ct[ct.length - 1]), ct.pop(), It.destroy();
    }
  }
  function wt(It) {
    lt.remove(It);
  }
  function Bt() {
    lt.dispose();
  }
  return {
    getParameters: Et,
    getProgramCacheKey: pt,
    getUniforms: At,
    acquireProgram: Ct,
    releaseProgram: Mt,
    releaseShaderCache: wt,
    programs: ct,
    dispose: Bt,
  };
}
function WebGLProperties() {
  let tt = new WeakMap();
  function et(st) {
    let ot = tt.get(st);
    return ot === void 0 && ((ot = {}), tt.set(st, ot)), ot;
  }
  function nt(st) {
    tt.delete(st);
  }
  function rt(st, ot, at) {
    tt.get(st)[ot] = at;
  }
  function it() {
    tt = new WeakMap();
  }
  return { get: et, remove: nt, update: rt, dispose: it };
}
function painterSortStable(tt, et) {
  return tt.groupOrder !== et.groupOrder
    ? tt.groupOrder - et.groupOrder
    : tt.renderOrder !== et.renderOrder
    ? tt.renderOrder - et.renderOrder
    : tt.material.id !== et.material.id
    ? tt.material.id - et.material.id
    : tt.z !== et.z
    ? tt.z - et.z
    : tt.id - et.id;
}
function reversePainterSortStable(tt, et) {
  return tt.groupOrder !== et.groupOrder
    ? tt.groupOrder - et.groupOrder
    : tt.renderOrder !== et.renderOrder
    ? tt.renderOrder - et.renderOrder
    : tt.z !== et.z
    ? et.z - tt.z
    : tt.id - et.id;
}
function WebGLRenderList() {
  const tt = [];
  let et = 0;
  const nt = [],
    rt = [],
    it = [];
  function st() {
    (et = 0), (nt.length = 0), (rt.length = 0), (it.length = 0);
  }
  function ot(ft, ht, mt, vt, yt, Et) {
    let pt = tt[et];
    return (
      pt === void 0
        ? ((pt = {
            id: ft.id,
            object: ft,
            geometry: ht,
            material: mt,
            groupOrder: vt,
            renderOrder: ft.renderOrder,
            z: yt,
            group: Et,
          }),
          (tt[et] = pt))
        : ((pt.id = ft.id),
          (pt.object = ft),
          (pt.geometry = ht),
          (pt.material = mt),
          (pt.groupOrder = vt),
          (pt.renderOrder = ft.renderOrder),
          (pt.z = yt),
          (pt.group = Et)),
      et++,
      pt
    );
  }
  function at(ft, ht, mt, vt, yt, Et) {
    const pt = ot(ft, ht, mt, vt, yt, Et);
    mt.transmission > 0
      ? rt.push(pt)
      : mt.transparent === !0
      ? it.push(pt)
      : nt.push(pt);
  }
  function lt(ft, ht, mt, vt, yt, Et) {
    const pt = ot(ft, ht, mt, vt, yt, Et);
    mt.transmission > 0
      ? rt.unshift(pt)
      : mt.transparent === !0
      ? it.unshift(pt)
      : nt.unshift(pt);
  }
  function ct(ft, ht) {
    nt.length > 1 && nt.sort(ft || painterSortStable),
      rt.length > 1 && rt.sort(ht || reversePainterSortStable),
      it.length > 1 && it.sort(ht || reversePainterSortStable);
  }
  function ut() {
    for (let ft = et, ht = tt.length; ft < ht; ft++) {
      const mt = tt[ft];
      if (mt.id === null) break;
      (mt.id = null),
        (mt.object = null),
        (mt.geometry = null),
        (mt.material = null),
        (mt.group = null);
    }
  }
  return {
    opaque: nt,
    transmissive: rt,
    transparent: it,
    init: st,
    push: at,
    unshift: lt,
    finish: ut,
    sort: ct,
  };
}
function WebGLRenderLists() {
  let tt = new WeakMap();
  function et(rt, it) {
    const st = tt.get(rt);
    let ot;
    return (
      st === void 0
        ? ((ot = new WebGLRenderList()), tt.set(rt, [ot]))
        : it >= st.length
        ? ((ot = new WebGLRenderList()), st.push(ot))
        : (ot = st[it]),
      ot
    );
  }
  function nt() {
    tt = new WeakMap();
  }
  return { get: et, dispose: nt };
}
function UniformsCache() {
  const tt = {};
  return {
    get: function (et) {
      if (tt[et.id] !== void 0) return tt[et.id];
      let nt;
      switch (et.type) {
        case "DirectionalLight":
          nt = { direction: new Vector3(), color: new Color() };
          break;
        case "SpotLight":
          nt = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          nt = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          nt = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          nt = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          };
          break;
      }
      return (tt[et.id] = nt), nt;
    },
  };
}
function ShadowUniformsCache() {
  const tt = {};
  return {
    get: function (et) {
      if (tt[et.id] !== void 0) return tt[et.id];
      let nt;
      switch (et.type) {
        case "DirectionalLight":
          nt = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "SpotLight":
          nt = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "PointLight":
          nt = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (tt[et.id] = nt), nt;
    },
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(tt, et) {
  return (
    (et.castShadow ? 2 : 0) -
    (tt.castShadow ? 2 : 0) +
    (et.map ? 1 : 0) -
    (tt.map ? 1 : 0)
  );
}
function WebGLLights(tt, et) {
  const nt = new UniformsCache(),
    rt = ShadowUniformsCache(),
    it = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let ut = 0; ut < 9; ut++) it.probe.push(new Vector3());
  const st = new Vector3(),
    ot = new Matrix4(),
    at = new Matrix4();
  function lt(ut, ft) {
    let ht = 0,
      mt = 0,
      vt = 0;
    for (let $t = 0; $t < 9; $t++) it.probe[$t].set(0, 0, 0);
    let yt = 0,
      Et = 0,
      pt = 0,
      xt = 0,
      St = 0,
      At = 0,
      Ct = 0,
      Mt = 0,
      wt = 0,
      Bt = 0,
      It = 0;
    ut.sort(shadowCastingAndTexturingLightsFirst);
    const Ft = ft === !0 ? Math.PI : 1;
    for (let $t = 0, Kt = ut.length; $t < Kt; $t++) {
      const Ht = ut[$t],
        Wt = Ht.color,
        kt = Ht.intensity,
        Gt = Ht.distance,
        Pt = Ht.shadow && Ht.shadow.map ? Ht.shadow.map.texture : null;
      if (Ht.isAmbientLight)
        (ht += Wt.r * kt * Ft), (mt += Wt.g * kt * Ft), (vt += Wt.b * kt * Ft);
      else if (Ht.isLightProbe) {
        for (let Rt = 0; Rt < 9; Rt++)
          it.probe[Rt].addScaledVector(Ht.sh.coefficients[Rt], kt);
        It++;
      } else if (Ht.isDirectionalLight) {
        const Rt = nt.get(Ht);
        if (
          (Rt.color.copy(Ht.color).multiplyScalar(Ht.intensity * Ft),
          Ht.castShadow)
        ) {
          const Nt = Ht.shadow,
            Dt = rt.get(Ht);
          (Dt.shadowBias = Nt.bias),
            (Dt.shadowNormalBias = Nt.normalBias),
            (Dt.shadowRadius = Nt.radius),
            (Dt.shadowMapSize = Nt.mapSize),
            (it.directionalShadow[yt] = Dt),
            (it.directionalShadowMap[yt] = Pt),
            (it.directionalShadowMatrix[yt] = Ht.shadow.matrix),
            At++;
        }
        (it.directional[yt] = Rt), yt++;
      } else if (Ht.isSpotLight) {
        const Rt = nt.get(Ht);
        Rt.position.setFromMatrixPosition(Ht.matrixWorld),
          Rt.color.copy(Wt).multiplyScalar(kt * Ft),
          (Rt.distance = Gt),
          (Rt.coneCos = Math.cos(Ht.angle)),
          (Rt.penumbraCos = Math.cos(Ht.angle * (1 - Ht.penumbra))),
          (Rt.decay = Ht.decay),
          (it.spot[pt] = Rt);
        const Nt = Ht.shadow;
        if (
          (Ht.map &&
            ((it.spotLightMap[wt] = Ht.map),
            wt++,
            Nt.updateMatrices(Ht),
            Ht.castShadow && Bt++),
          (it.spotLightMatrix[pt] = Nt.matrix),
          Ht.castShadow)
        ) {
          const Dt = rt.get(Ht);
          (Dt.shadowBias = Nt.bias),
            (Dt.shadowNormalBias = Nt.normalBias),
            (Dt.shadowRadius = Nt.radius),
            (Dt.shadowMapSize = Nt.mapSize),
            (it.spotShadow[pt] = Dt),
            (it.spotShadowMap[pt] = Pt),
            Mt++;
        }
        pt++;
      } else if (Ht.isRectAreaLight) {
        const Rt = nt.get(Ht);
        Rt.color.copy(Wt).multiplyScalar(kt),
          Rt.halfWidth.set(Ht.width * 0.5, 0, 0),
          Rt.halfHeight.set(0, Ht.height * 0.5, 0),
          (it.rectArea[xt] = Rt),
          xt++;
      } else if (Ht.isPointLight) {
        const Rt = nt.get(Ht);
        if (
          (Rt.color.copy(Ht.color).multiplyScalar(Ht.intensity * Ft),
          (Rt.distance = Ht.distance),
          (Rt.decay = Ht.decay),
          Ht.castShadow)
        ) {
          const Nt = Ht.shadow,
            Dt = rt.get(Ht);
          (Dt.shadowBias = Nt.bias),
            (Dt.shadowNormalBias = Nt.normalBias),
            (Dt.shadowRadius = Nt.radius),
            (Dt.shadowMapSize = Nt.mapSize),
            (Dt.shadowCameraNear = Nt.camera.near),
            (Dt.shadowCameraFar = Nt.camera.far),
            (it.pointShadow[Et] = Dt),
            (it.pointShadowMap[Et] = Pt),
            (it.pointShadowMatrix[Et] = Ht.shadow.matrix),
            Ct++;
        }
        (it.point[Et] = Rt), Et++;
      } else if (Ht.isHemisphereLight) {
        const Rt = nt.get(Ht);
        Rt.skyColor.copy(Ht.color).multiplyScalar(kt * Ft),
          Rt.groundColor.copy(Ht.groundColor).multiplyScalar(kt * Ft),
          (it.hemi[St] = Rt),
          St++;
      }
    }
    xt > 0 &&
      (et.isWebGL2 || tt.has("OES_texture_float_linear") === !0
        ? ((it.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1),
          (it.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2))
        : tt.has("OES_texture_half_float_linear") === !0
        ? ((it.rectAreaLTC1 = UniformsLib.LTC_HALF_1),
          (it.rectAreaLTC2 = UniformsLib.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (it.ambient[0] = ht),
      (it.ambient[1] = mt),
      (it.ambient[2] = vt);
    const Vt = it.hash;
    (Vt.directionalLength !== yt ||
      Vt.pointLength !== Et ||
      Vt.spotLength !== pt ||
      Vt.rectAreaLength !== xt ||
      Vt.hemiLength !== St ||
      Vt.numDirectionalShadows !== At ||
      Vt.numPointShadows !== Ct ||
      Vt.numSpotShadows !== Mt ||
      Vt.numSpotMaps !== wt ||
      Vt.numLightProbes !== It) &&
      ((it.directional.length = yt),
      (it.spot.length = pt),
      (it.rectArea.length = xt),
      (it.point.length = Et),
      (it.hemi.length = St),
      (it.directionalShadow.length = At),
      (it.directionalShadowMap.length = At),
      (it.pointShadow.length = Ct),
      (it.pointShadowMap.length = Ct),
      (it.spotShadow.length = Mt),
      (it.spotShadowMap.length = Mt),
      (it.directionalShadowMatrix.length = At),
      (it.pointShadowMatrix.length = Ct),
      (it.spotLightMatrix.length = Mt + wt - Bt),
      (it.spotLightMap.length = wt),
      (it.numSpotLightShadowsWithMaps = Bt),
      (it.numLightProbes = It),
      (Vt.directionalLength = yt),
      (Vt.pointLength = Et),
      (Vt.spotLength = pt),
      (Vt.rectAreaLength = xt),
      (Vt.hemiLength = St),
      (Vt.numDirectionalShadows = At),
      (Vt.numPointShadows = Ct),
      (Vt.numSpotShadows = Mt),
      (Vt.numSpotMaps = wt),
      (Vt.numLightProbes = It),
      (it.version = nextVersion++));
  }
  function ct(ut, ft) {
    let ht = 0,
      mt = 0,
      vt = 0,
      yt = 0,
      Et = 0;
    const pt = ft.matrixWorldInverse;
    for (let xt = 0, St = ut.length; xt < St; xt++) {
      const At = ut[xt];
      if (At.isDirectionalLight) {
        const Ct = it.directional[ht];
        Ct.direction.setFromMatrixPosition(At.matrixWorld),
          st.setFromMatrixPosition(At.target.matrixWorld),
          Ct.direction.sub(st),
          Ct.direction.transformDirection(pt),
          ht++;
      } else if (At.isSpotLight) {
        const Ct = it.spot[vt];
        Ct.position.setFromMatrixPosition(At.matrixWorld),
          Ct.position.applyMatrix4(pt),
          Ct.direction.setFromMatrixPosition(At.matrixWorld),
          st.setFromMatrixPosition(At.target.matrixWorld),
          Ct.direction.sub(st),
          Ct.direction.transformDirection(pt),
          vt++;
      } else if (At.isRectAreaLight) {
        const Ct = it.rectArea[yt];
        Ct.position.setFromMatrixPosition(At.matrixWorld),
          Ct.position.applyMatrix4(pt),
          at.identity(),
          ot.copy(At.matrixWorld),
          ot.premultiply(pt),
          at.extractRotation(ot),
          Ct.halfWidth.set(At.width * 0.5, 0, 0),
          Ct.halfHeight.set(0, At.height * 0.5, 0),
          Ct.halfWidth.applyMatrix4(at),
          Ct.halfHeight.applyMatrix4(at),
          yt++;
      } else if (At.isPointLight) {
        const Ct = it.point[mt];
        Ct.position.setFromMatrixPosition(At.matrixWorld),
          Ct.position.applyMatrix4(pt),
          mt++;
      } else if (At.isHemisphereLight) {
        const Ct = it.hemi[Et];
        Ct.direction.setFromMatrixPosition(At.matrixWorld),
          Ct.direction.transformDirection(pt),
          Et++;
      }
    }
  }
  return { setup: lt, setupView: ct, state: it };
}
function WebGLRenderState(tt, et) {
  const nt = new WebGLLights(tt, et),
    rt = [],
    it = [];
  function st() {
    (rt.length = 0), (it.length = 0);
  }
  function ot(ft) {
    rt.push(ft);
  }
  function at(ft) {
    it.push(ft);
  }
  function lt(ft) {
    nt.setup(rt, ft);
  }
  function ct(ft) {
    nt.setupView(rt, ft);
  }
  return {
    init: st,
    state: { lightsArray: rt, shadowsArray: it, lights: nt },
    setupLights: lt,
    setupLightsView: ct,
    pushLight: ot,
    pushShadow: at,
  };
}
function WebGLRenderStates(tt, et) {
  let nt = new WeakMap();
  function rt(st, ot = 0) {
    const at = nt.get(st);
    let lt;
    return (
      at === void 0
        ? ((lt = new WebGLRenderState(tt, et)), nt.set(st, [lt]))
        : ot >= at.length
        ? ((lt = new WebGLRenderState(tt, et)), at.push(lt))
        : (lt = at[ot]),
      lt
    );
  }
  function it() {
    nt = new WeakMap();
  }
  return { get: rt, dispose: it };
}
class MeshDepthMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = BasicDepthPacking),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.depthPacking = et.depthPacking),
      (this.map = et.map),
      (this.alphaMap = et.alphaMap),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      this
    );
  }
}
class MeshDistanceMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.map = et.map),
      (this.alphaMap = et.alphaMap),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      this
    );
  }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(tt, et, nt) {
  let rt = new Frustum();
  const it = new Vector2(),
    st = new Vector2(),
    ot = new Vector4(),
    at = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    lt = new MeshDistanceMaterial(),
    ct = {},
    ut = nt.maxTextureSize,
    ft = {
      [FrontSide]: BackSide,
      [BackSide]: FrontSide,
      [DoubleSide]: DoubleSide,
    },
    ht = new ShaderMaterial({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
      },
      vertexShader: vertex,
      fragmentShader: fragment,
    }),
    mt = ht.clone();
  mt.defines.HORIZONTAL_PASS = 1;
  const vt = new BufferGeometry();
  vt.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const yt = new Mesh(vt, ht),
    Et = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = PCFShadowMap);
  let pt = this.type;
  this.render = function (Ct, Mt, wt) {
    if (
      Et.enabled === !1 ||
      (Et.autoUpdate === !1 && Et.needsUpdate === !1) ||
      Ct.length === 0
    )
      return;
    const Bt = tt.getRenderTarget(),
      It = tt.getActiveCubeFace(),
      Ft = tt.getActiveMipmapLevel(),
      Vt = tt.state;
    Vt.setBlending(NoBlending),
      Vt.buffers.color.setClear(1, 1, 1, 1),
      Vt.buffers.depth.setTest(!0),
      Vt.setScissorTest(!1);
    const $t = pt !== VSMShadowMap && this.type === VSMShadowMap,
      Kt = pt === VSMShadowMap && this.type !== VSMShadowMap;
    for (let Ht = 0, Wt = Ct.length; Ht < Wt; Ht++) {
      const kt = Ct[Ht],
        Gt = kt.shadow;
      if (Gt === void 0) {
        console.warn("THREE.WebGLShadowMap:", kt, "has no shadow.");
        continue;
      }
      if (Gt.autoUpdate === !1 && Gt.needsUpdate === !1) continue;
      it.copy(Gt.mapSize);
      const Pt = Gt.getFrameExtents();
      if (
        (it.multiply(Pt),
        st.copy(Gt.mapSize),
        (it.x > ut || it.y > ut) &&
          (it.x > ut &&
            ((st.x = Math.floor(ut / Pt.x)),
            (it.x = st.x * Pt.x),
            (Gt.mapSize.x = st.x)),
          it.y > ut &&
            ((st.y = Math.floor(ut / Pt.y)),
            (it.y = st.y * Pt.y),
            (Gt.mapSize.y = st.y))),
        Gt.map === null || $t === !0 || Kt === !0)
      ) {
        const Nt =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {};
        Gt.map !== null && Gt.map.dispose(),
          (Gt.map = new WebGLRenderTarget(it.x, it.y, Nt)),
          (Gt.map.texture.name = kt.name + ".shadowMap"),
          Gt.camera.updateProjectionMatrix();
      }
      tt.setRenderTarget(Gt.map), tt.clear();
      const Rt = Gt.getViewportCount();
      for (let Nt = 0; Nt < Rt; Nt++) {
        const Dt = Gt.getViewport(Nt);
        ot.set(st.x * Dt.x, st.y * Dt.y, st.x * Dt.z, st.y * Dt.w),
          Vt.viewport(ot),
          Gt.updateMatrices(kt, Nt),
          (rt = Gt.getFrustum()),
          At(Mt, wt, Gt.camera, kt, this.type);
      }
      Gt.isPointLightShadow !== !0 && this.type === VSMShadowMap && xt(Gt, wt),
        (Gt.needsUpdate = !1);
    }
    (pt = this.type), (Et.needsUpdate = !1), tt.setRenderTarget(Bt, It, Ft);
  };
  function xt(Ct, Mt) {
    const wt = et.update(yt);
    ht.defines.VSM_SAMPLES !== Ct.blurSamples &&
      ((ht.defines.VSM_SAMPLES = Ct.blurSamples),
      (mt.defines.VSM_SAMPLES = Ct.blurSamples),
      (ht.needsUpdate = !0),
      (mt.needsUpdate = !0)),
      Ct.mapPass === null && (Ct.mapPass = new WebGLRenderTarget(it.x, it.y)),
      (ht.uniforms.shadow_pass.value = Ct.map.texture),
      (ht.uniforms.resolution.value = Ct.mapSize),
      (ht.uniforms.radius.value = Ct.radius),
      tt.setRenderTarget(Ct.mapPass),
      tt.clear(),
      tt.renderBufferDirect(Mt, null, wt, ht, yt, null),
      (mt.uniforms.shadow_pass.value = Ct.mapPass.texture),
      (mt.uniforms.resolution.value = Ct.mapSize),
      (mt.uniforms.radius.value = Ct.radius),
      tt.setRenderTarget(Ct.map),
      tt.clear(),
      tt.renderBufferDirect(Mt, null, wt, mt, yt, null);
  }
  function St(Ct, Mt, wt, Bt) {
    let It = null;
    const Ft =
      wt.isPointLight === !0
        ? Ct.customDistanceMaterial
        : Ct.customDepthMaterial;
    if (Ft !== void 0) It = Ft;
    else if (
      ((It = wt.isPointLight === !0 ? lt : at),
      (tt.localClippingEnabled &&
        Mt.clipShadows === !0 &&
        Array.isArray(Mt.clippingPlanes) &&
        Mt.clippingPlanes.length !== 0) ||
        (Mt.displacementMap && Mt.displacementScale !== 0) ||
        (Mt.alphaMap && Mt.alphaTest > 0) ||
        (Mt.map && Mt.alphaTest > 0))
    ) {
      const Vt = It.uuid,
        $t = Mt.uuid;
      let Kt = ct[Vt];
      Kt === void 0 && ((Kt = {}), (ct[Vt] = Kt));
      let Ht = Kt[$t];
      Ht === void 0 && ((Ht = It.clone()), (Kt[$t] = Ht)), (It = Ht);
    }
    if (
      ((It.visible = Mt.visible),
      (It.wireframe = Mt.wireframe),
      Bt === VSMShadowMap
        ? (It.side = Mt.shadowSide !== null ? Mt.shadowSide : Mt.side)
        : (It.side = Mt.shadowSide !== null ? Mt.shadowSide : ft[Mt.side]),
      (It.alphaMap = Mt.alphaMap),
      (It.alphaTest = Mt.alphaTest),
      (It.map = Mt.map),
      (It.clipShadows = Mt.clipShadows),
      (It.clippingPlanes = Mt.clippingPlanes),
      (It.clipIntersection = Mt.clipIntersection),
      (It.displacementMap = Mt.displacementMap),
      (It.displacementScale = Mt.displacementScale),
      (It.displacementBias = Mt.displacementBias),
      (It.wireframeLinewidth = Mt.wireframeLinewidth),
      (It.linewidth = Mt.linewidth),
      wt.isPointLight === !0 && It.isMeshDistanceMaterial === !0)
    ) {
      const Vt = tt.properties.get(It);
      Vt.light = wt;
    }
    return It;
  }
  function At(Ct, Mt, wt, Bt, It) {
    if (Ct.visible === !1) return;
    if (
      Ct.layers.test(Mt.layers) &&
      (Ct.isMesh || Ct.isLine || Ct.isPoints) &&
      (Ct.castShadow || (Ct.receiveShadow && It === VSMShadowMap)) &&
      (!Ct.frustumCulled || rt.intersectsObject(Ct))
    ) {
      Ct.modelViewMatrix.multiplyMatrices(
        wt.matrixWorldInverse,
        Ct.matrixWorld
      );
      const $t = et.update(Ct),
        Kt = Ct.material;
      if (Array.isArray(Kt)) {
        const Ht = $t.groups;
        for (let Wt = 0, kt = Ht.length; Wt < kt; Wt++) {
          const Gt = Ht[Wt],
            Pt = Kt[Gt.materialIndex];
          if (Pt && Pt.visible) {
            const Rt = St(Ct, Pt, Bt, It);
            tt.renderBufferDirect(wt, null, $t, Rt, Ct, Gt);
          }
        }
      } else if (Kt.visible) {
        const Ht = St(Ct, Kt, Bt, It);
        tt.renderBufferDirect(wt, null, $t, Ht, Ct, null);
      }
    }
    const Vt = Ct.children;
    for (let $t = 0, Kt = Vt.length; $t < Kt; $t++) At(Vt[$t], Mt, wt, Bt, It);
  }
}
function WebGLState(tt, et, nt) {
  const rt = nt.isWebGL2;
  function it() {
    let Qt = !1;
    const zn = new Vector4();
    let Xn = null;
    const Qn = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (tr) {
        Xn !== tr && !Qt && (tt.colorMask(tr, tr, tr, tr), (Xn = tr));
      },
      setLocked: function (tr) {
        Qt = tr;
      },
      setClear: function (tr, jn, nr, or, vr) {
        vr === !0 && ((tr *= or), (jn *= or), (nr *= or)),
          zn.set(tr, jn, nr, or),
          Qn.equals(zn) === !1 && (tt.clearColor(tr, jn, nr, or), Qn.copy(zn));
      },
      reset: function () {
        (Qt = !1), (Xn = null), Qn.set(-1, 0, 0, 0);
      },
    };
  }
  function st() {
    let Qt = !1,
      zn = null,
      Xn = null,
      Qn = null;
    return {
      setTest: function (tr) {
        tr ? mn(tt.DEPTH_TEST) : ln(tt.DEPTH_TEST);
      },
      setMask: function (tr) {
        zn !== tr && !Qt && (tt.depthMask(tr), (zn = tr));
      },
      setFunc: function (tr) {
        if (Xn !== tr) {
          switch (tr) {
            case NeverDepth:
              tt.depthFunc(tt.NEVER);
              break;
            case AlwaysDepth:
              tt.depthFunc(tt.ALWAYS);
              break;
            case LessDepth:
              tt.depthFunc(tt.LESS);
              break;
            case LessEqualDepth:
              tt.depthFunc(tt.LEQUAL);
              break;
            case EqualDepth:
              tt.depthFunc(tt.EQUAL);
              break;
            case GreaterEqualDepth:
              tt.depthFunc(tt.GEQUAL);
              break;
            case GreaterDepth:
              tt.depthFunc(tt.GREATER);
              break;
            case NotEqualDepth:
              tt.depthFunc(tt.NOTEQUAL);
              break;
            default:
              tt.depthFunc(tt.LEQUAL);
          }
          Xn = tr;
        }
      },
      setLocked: function (tr) {
        Qt = tr;
      },
      setClear: function (tr) {
        Qn !== tr && (tt.clearDepth(tr), (Qn = tr));
      },
      reset: function () {
        (Qt = !1), (zn = null), (Xn = null), (Qn = null);
      },
    };
  }
  function ot() {
    let Qt = !1,
      zn = null,
      Xn = null,
      Qn = null,
      tr = null,
      jn = null,
      nr = null,
      or = null,
      vr = null;
    return {
      setTest: function (Ar) {
        Qt || (Ar ? mn(tt.STENCIL_TEST) : ln(tt.STENCIL_TEST));
      },
      setMask: function (Ar) {
        zn !== Ar && !Qt && (tt.stencilMask(Ar), (zn = Ar));
      },
      setFunc: function (Ar, _r, yr) {
        (Xn !== Ar || Qn !== _r || tr !== yr) &&
          (tt.stencilFunc(Ar, _r, yr), (Xn = Ar), (Qn = _r), (tr = yr));
      },
      setOp: function (Ar, _r, yr) {
        (jn !== Ar || nr !== _r || or !== yr) &&
          (tt.stencilOp(Ar, _r, yr), (jn = Ar), (nr = _r), (or = yr));
      },
      setLocked: function (Ar) {
        Qt = Ar;
      },
      setClear: function (Ar) {
        vr !== Ar && (tt.clearStencil(Ar), (vr = Ar));
      },
      reset: function () {
        (Qt = !1),
          (zn = null),
          (Xn = null),
          (Qn = null),
          (tr = null),
          (jn = null),
          (nr = null),
          (or = null),
          (vr = null);
      },
    };
  }
  const at = new it(),
    lt = new st(),
    ct = new ot(),
    ut = new WeakMap(),
    ft = new WeakMap();
  let ht = {},
    mt = {},
    vt = new WeakMap(),
    yt = [],
    Et = null,
    pt = !1,
    xt = null,
    St = null,
    At = null,
    Ct = null,
    Mt = null,
    wt = null,
    Bt = null,
    It = !1,
    Ft = null,
    Vt = null,
    $t = null,
    Kt = null,
    Ht = null;
  const Wt = tt.getParameter(tt.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let kt = !1,
    Gt = 0;
  const Pt = tt.getParameter(tt.VERSION);
  Pt.indexOf("WebGL") !== -1
    ? ((Gt = parseFloat(/^WebGL (\d)/.exec(Pt)[1])), (kt = Gt >= 1))
    : Pt.indexOf("OpenGL ES") !== -1 &&
      ((Gt = parseFloat(/^OpenGL ES (\d)/.exec(Pt)[1])), (kt = Gt >= 2));
  let Rt = null,
    Nt = {};
  const Dt = tt.getParameter(tt.SCISSOR_BOX),
    zt = tt.getParameter(tt.VIEWPORT),
    Yt = new Vector4().fromArray(Dt),
    qt = new Vector4().fromArray(zt);
  function Zt(Qt, zn, Xn, Qn) {
    const tr = new Uint8Array(4),
      jn = tt.createTexture();
    tt.bindTexture(Qt, jn),
      tt.texParameteri(Qt, tt.TEXTURE_MIN_FILTER, tt.NEAREST),
      tt.texParameteri(Qt, tt.TEXTURE_MAG_FILTER, tt.NEAREST);
    for (let nr = 0; nr < Xn; nr++)
      rt && (Qt === tt.TEXTURE_3D || Qt === tt.TEXTURE_2D_ARRAY)
        ? tt.texImage3D(
            zn,
            0,
            tt.RGBA,
            1,
            1,
            Qn,
            0,
            tt.RGBA,
            tt.UNSIGNED_BYTE,
            tr
          )
        : tt.texImage2D(
            zn + nr,
            0,
            tt.RGBA,
            1,
            1,
            0,
            tt.RGBA,
            tt.UNSIGNED_BYTE,
            tr
          );
    return jn;
  }
  const Jt = {};
  (Jt[tt.TEXTURE_2D] = Zt(tt.TEXTURE_2D, tt.TEXTURE_2D, 1)),
    (Jt[tt.TEXTURE_CUBE_MAP] = Zt(
      tt.TEXTURE_CUBE_MAP,
      tt.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    rt &&
      ((Jt[tt.TEXTURE_2D_ARRAY] = Zt(
        tt.TEXTURE_2D_ARRAY,
        tt.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Jt[tt.TEXTURE_3D] = Zt(tt.TEXTURE_3D, tt.TEXTURE_3D, 1, 1))),
    at.setClear(0, 0, 0, 1),
    lt.setClear(1),
    ct.setClear(0),
    mn(tt.DEPTH_TEST),
    lt.setFunc(LessEqualDepth),
    xn(!1),
    Fn(CullFaceBack),
    mn(tt.CULL_FACE),
    pn(NoBlending);
  function mn(Qt) {
    ht[Qt] !== !0 && (tt.enable(Qt), (ht[Qt] = !0));
  }
  function ln(Qt) {
    ht[Qt] !== !1 && (tt.disable(Qt), (ht[Qt] = !1));
  }
  function bn(Qt, zn) {
    return mt[Qt] !== zn
      ? (tt.bindFramebuffer(Qt, zn),
        (mt[Qt] = zn),
        rt &&
          (Qt === tt.DRAW_FRAMEBUFFER && (mt[tt.FRAMEBUFFER] = zn),
          Qt === tt.FRAMEBUFFER && (mt[tt.DRAW_FRAMEBUFFER] = zn)),
        !0)
      : !1;
  }
  function Bn(Qt, zn) {
    let Xn = yt,
      Qn = !1;
    if (Qt)
      if (
        ((Xn = vt.get(zn)),
        Xn === void 0 && ((Xn = []), vt.set(zn, Xn)),
        Qt.isWebGLMultipleRenderTargets)
      ) {
        const tr = Qt.texture;
        if (Xn.length !== tr.length || Xn[0] !== tt.COLOR_ATTACHMENT0) {
          for (let jn = 0, nr = tr.length; jn < nr; jn++)
            Xn[jn] = tt.COLOR_ATTACHMENT0 + jn;
          (Xn.length = tr.length), (Qn = !0);
        }
      } else
        Xn[0] !== tt.COLOR_ATTACHMENT0 &&
          ((Xn[0] = tt.COLOR_ATTACHMENT0), (Qn = !0));
    else Xn[0] !== tt.BACK && ((Xn[0] = tt.BACK), (Qn = !0));
    Qn &&
      (nt.isWebGL2
        ? tt.drawBuffers(Xn)
        : et.get("WEBGL_draw_buffers").drawBuffersWEBGL(Xn));
  }
  function gn(Qt) {
    return Et !== Qt ? (tt.useProgram(Qt), (Et = Qt), !0) : !1;
  }
  const jt = {
    [AddEquation]: tt.FUNC_ADD,
    [SubtractEquation]: tt.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: tt.FUNC_REVERSE_SUBTRACT,
  };
  if (rt) (jt[MinEquation] = tt.MIN), (jt[MaxEquation] = tt.MAX);
  else {
    const Qt = et.get("EXT_blend_minmax");
    Qt !== null &&
      ((jt[MinEquation] = Qt.MIN_EXT), (jt[MaxEquation] = Qt.MAX_EXT));
  }
  const yn = {
    [ZeroFactor]: tt.ZERO,
    [OneFactor]: tt.ONE,
    [SrcColorFactor]: tt.SRC_COLOR,
    [SrcAlphaFactor]: tt.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: tt.SRC_ALPHA_SATURATE,
    [DstColorFactor]: tt.DST_COLOR,
    [DstAlphaFactor]: tt.DST_ALPHA,
    [OneMinusSrcColorFactor]: tt.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: tt.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: tt.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: tt.ONE_MINUS_DST_ALPHA,
  };
  function pn(Qt, zn, Xn, Qn, tr, jn, nr, or) {
    if (Qt === NoBlending) {
      pt === !0 && (ln(tt.BLEND), (pt = !1));
      return;
    }
    if ((pt === !1 && (mn(tt.BLEND), (pt = !0)), Qt !== CustomBlending)) {
      if (Qt !== xt || or !== It) {
        if (
          ((St !== AddEquation || Mt !== AddEquation) &&
            (tt.blendEquation(tt.FUNC_ADD),
            (St = AddEquation),
            (Mt = AddEquation)),
          or)
        )
          switch (Qt) {
            case NormalBlending:
              tt.blendFuncSeparate(
                tt.ONE,
                tt.ONE_MINUS_SRC_ALPHA,
                tt.ONE,
                tt.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              tt.blendFunc(tt.ONE, tt.ONE);
              break;
            case SubtractiveBlending:
              tt.blendFuncSeparate(
                tt.ZERO,
                tt.ONE_MINUS_SRC_COLOR,
                tt.ZERO,
                tt.ONE
              );
              break;
            case MultiplyBlending:
              tt.blendFuncSeparate(
                tt.ZERO,
                tt.SRC_COLOR,
                tt.ZERO,
                tt.SRC_ALPHA
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Qt);
              break;
          }
        else
          switch (Qt) {
            case NormalBlending:
              tt.blendFuncSeparate(
                tt.SRC_ALPHA,
                tt.ONE_MINUS_SRC_ALPHA,
                tt.ONE,
                tt.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              tt.blendFunc(tt.SRC_ALPHA, tt.ONE);
              break;
            case SubtractiveBlending:
              tt.blendFuncSeparate(
                tt.ZERO,
                tt.ONE_MINUS_SRC_COLOR,
                tt.ZERO,
                tt.ONE
              );
              break;
            case MultiplyBlending:
              tt.blendFunc(tt.ZERO, tt.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Qt);
              break;
          }
        (At = null),
          (Ct = null),
          (wt = null),
          (Bt = null),
          (xt = Qt),
          (It = or);
      }
      return;
    }
    (tr = tr || zn),
      (jn = jn || Xn),
      (nr = nr || Qn),
      (zn !== St || tr !== Mt) &&
        (tt.blendEquationSeparate(jt[zn], jt[tr]), (St = zn), (Mt = tr)),
      (Xn !== At || Qn !== Ct || jn !== wt || nr !== Bt) &&
        (tt.blendFuncSeparate(yn[Xn], yn[Qn], yn[jn], yn[nr]),
        (At = Xn),
        (Ct = Qn),
        (wt = jn),
        (Bt = nr)),
      (xt = Qt),
      (It = !1);
  }
  function vn(Qt, zn) {
    Qt.side === DoubleSide ? ln(tt.CULL_FACE) : mn(tt.CULL_FACE);
    let Xn = Qt.side === BackSide;
    zn && (Xn = !Xn),
      xn(Xn),
      Qt.blending === NormalBlending && Qt.transparent === !1
        ? pn(NoBlending)
        : pn(
            Qt.blending,
            Qt.blendEquation,
            Qt.blendSrc,
            Qt.blendDst,
            Qt.blendEquationAlpha,
            Qt.blendSrcAlpha,
            Qt.blendDstAlpha,
            Qt.premultipliedAlpha
          ),
      lt.setFunc(Qt.depthFunc),
      lt.setTest(Qt.depthTest),
      lt.setMask(Qt.depthWrite),
      at.setMask(Qt.colorWrite);
    const Qn = Qt.stencilWrite;
    ct.setTest(Qn),
      Qn &&
        (ct.setMask(Qt.stencilWriteMask),
        ct.setFunc(Qt.stencilFunc, Qt.stencilRef, Qt.stencilFuncMask),
        ct.setOp(Qt.stencilFail, Qt.stencilZFail, Qt.stencilZPass)),
      Dn(Qt.polygonOffset, Qt.polygonOffsetFactor, Qt.polygonOffsetUnits),
      Qt.alphaToCoverage === !0
        ? mn(tt.SAMPLE_ALPHA_TO_COVERAGE)
        : ln(tt.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function xn(Qt) {
    Ft !== Qt && (Qt ? tt.frontFace(tt.CW) : tt.frontFace(tt.CCW), (Ft = Qt));
  }
  function Fn(Qt) {
    Qt !== CullFaceNone
      ? (mn(tt.CULL_FACE),
        Qt !== Vt &&
          (Qt === CullFaceBack
            ? tt.cullFace(tt.BACK)
            : Qt === CullFaceFront
            ? tt.cullFace(tt.FRONT)
            : tt.cullFace(tt.FRONT_AND_BACK)))
      : ln(tt.CULL_FACE),
      (Vt = Qt);
  }
  function _n(Qt) {
    Qt !== $t && (kt && tt.lineWidth(Qt), ($t = Qt));
  }
  function Dn(Qt, zn, Xn) {
    Qt
      ? (mn(tt.POLYGON_OFFSET_FILL),
        (Kt !== zn || Ht !== Xn) &&
          (tt.polygonOffset(zn, Xn), (Kt = zn), (Ht = Xn)))
      : ln(tt.POLYGON_OFFSET_FILL);
  }
  function Tn(Qt) {
    Qt ? mn(tt.SCISSOR_TEST) : ln(tt.SCISSOR_TEST);
  }
  function An(Qt) {
    Qt === void 0 && (Qt = tt.TEXTURE0 + Wt - 1),
      Rt !== Qt && (tt.activeTexture(Qt), (Rt = Qt));
  }
  function Wn(Qt, zn, Xn) {
    Xn === void 0 && (Rt === null ? (Xn = tt.TEXTURE0 + Wt - 1) : (Xn = Rt));
    let Qn = Nt[Xn];
    Qn === void 0 && ((Qn = { type: void 0, texture: void 0 }), (Nt[Xn] = Qn)),
      (Qn.type !== Qt || Qn.texture !== zn) &&
        (Rt !== Xn && (tt.activeTexture(Xn), (Rt = Xn)),
        tt.bindTexture(Qt, zn || Jt[Qt]),
        (Qn.type = Qt),
        (Qn.texture = zn));
  }
  function Xt() {
    const Qt = Nt[Rt];
    Qt !== void 0 &&
      Qt.type !== void 0 &&
      (tt.bindTexture(Qt.type, null),
      (Qt.type = void 0),
      (Qt.texture = void 0));
  }
  function Ut() {
    try {
      tt.compressedTexImage2D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function hn() {
    try {
      tt.compressedTexImage3D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Ln() {
    try {
      tt.texSubImage2D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Cn() {
    try {
      tt.texSubImage3D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Mn() {
    try {
      tt.compressedTexSubImage2D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function kn() {
    try {
      tt.compressedTexSubImage3D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Vn() {
    try {
      tt.texStorage2D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Kn() {
    try {
      tt.texStorage3D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function Yn() {
    try {
      tt.texImage2D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function ir() {
    try {
      tt.texImage3D.apply(tt, arguments);
    } catch (Qt) {
      console.error("THREE.WebGLState:", Qt);
    }
  }
  function On(Qt) {
    Yt.equals(Qt) === !1 && (tt.scissor(Qt.x, Qt.y, Qt.z, Qt.w), Yt.copy(Qt));
  }
  function qn(Qt) {
    qt.equals(Qt) === !1 && (tt.viewport(Qt.x, Qt.y, Qt.z, Qt.w), qt.copy(Qt));
  }
  function dn(Qt, zn) {
    let Xn = ft.get(zn);
    Xn === void 0 && ((Xn = new WeakMap()), ft.set(zn, Xn));
    let Qn = Xn.get(Qt);
    Qn === void 0 &&
      ((Qn = tt.getUniformBlockIndex(zn, Qt.name)), Xn.set(Qt, Qn));
  }
  function Pn(Qt, zn) {
    const Qn = ft.get(zn).get(Qt);
    ut.get(zn) !== Qn &&
      (tt.uniformBlockBinding(zn, Qn, Qt.__bindingPointIndex), ut.set(zn, Qn));
  }
  function Hn() {
    tt.disable(tt.BLEND),
      tt.disable(tt.CULL_FACE),
      tt.disable(tt.DEPTH_TEST),
      tt.disable(tt.POLYGON_OFFSET_FILL),
      tt.disable(tt.SCISSOR_TEST),
      tt.disable(tt.STENCIL_TEST),
      tt.disable(tt.SAMPLE_ALPHA_TO_COVERAGE),
      tt.blendEquation(tt.FUNC_ADD),
      tt.blendFunc(tt.ONE, tt.ZERO),
      tt.blendFuncSeparate(tt.ONE, tt.ZERO, tt.ONE, tt.ZERO),
      tt.colorMask(!0, !0, !0, !0),
      tt.clearColor(0, 0, 0, 0),
      tt.depthMask(!0),
      tt.depthFunc(tt.LESS),
      tt.clearDepth(1),
      tt.stencilMask(4294967295),
      tt.stencilFunc(tt.ALWAYS, 0, 4294967295),
      tt.stencilOp(tt.KEEP, tt.KEEP, tt.KEEP),
      tt.clearStencil(0),
      tt.cullFace(tt.BACK),
      tt.frontFace(tt.CCW),
      tt.polygonOffset(0, 0),
      tt.activeTexture(tt.TEXTURE0),
      tt.bindFramebuffer(tt.FRAMEBUFFER, null),
      rt === !0 &&
        (tt.bindFramebuffer(tt.DRAW_FRAMEBUFFER, null),
        tt.bindFramebuffer(tt.READ_FRAMEBUFFER, null)),
      tt.useProgram(null),
      tt.lineWidth(1),
      tt.scissor(0, 0, tt.canvas.width, tt.canvas.height),
      tt.viewport(0, 0, tt.canvas.width, tt.canvas.height),
      (ht = {}),
      (Rt = null),
      (Nt = {}),
      (mt = {}),
      (vt = new WeakMap()),
      (yt = []),
      (Et = null),
      (pt = !1),
      (xt = null),
      (St = null),
      (At = null),
      (Ct = null),
      (Mt = null),
      (wt = null),
      (Bt = null),
      (It = !1),
      (Ft = null),
      (Vt = null),
      ($t = null),
      (Kt = null),
      (Ht = null),
      Yt.set(0, 0, tt.canvas.width, tt.canvas.height),
      qt.set(0, 0, tt.canvas.width, tt.canvas.height),
      at.reset(),
      lt.reset(),
      ct.reset();
  }
  return {
    buffers: { color: at, depth: lt, stencil: ct },
    enable: mn,
    disable: ln,
    bindFramebuffer: bn,
    drawBuffers: Bn,
    useProgram: gn,
    setBlending: pn,
    setMaterial: vn,
    setFlipSided: xn,
    setCullFace: Fn,
    setLineWidth: _n,
    setPolygonOffset: Dn,
    setScissorTest: Tn,
    activeTexture: An,
    bindTexture: Wn,
    unbindTexture: Xt,
    compressedTexImage2D: Ut,
    compressedTexImage3D: hn,
    texImage2D: Yn,
    texImage3D: ir,
    updateUBOMapping: dn,
    uniformBlockBinding: Pn,
    texStorage2D: Vn,
    texStorage3D: Kn,
    texSubImage2D: Ln,
    texSubImage3D: Cn,
    compressedTexSubImage2D: Mn,
    compressedTexSubImage3D: kn,
    scissor: On,
    viewport: qn,
    reset: Hn,
  };
}
function WebGLTextures(tt, et, nt, rt, it, st, ot) {
  const at = it.isWebGL2,
    lt = it.maxTextures,
    ct = it.maxCubemapSize,
    ut = it.maxTextureSize,
    ft = it.maxSamples,
    ht = et.has("WEBGL_multisampled_render_to_texture")
      ? et.get("WEBGL_multisampled_render_to_texture")
      : null,
    mt =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    vt = new WeakMap();
  let yt;
  const Et = new WeakMap();
  let pt = !1;
  try {
    pt =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function xt(Xt, Ut) {
    return pt ? new OffscreenCanvas(Xt, Ut) : createElementNS("canvas");
  }
  function St(Xt, Ut, hn, Ln) {
    let Cn = 1;
    if (
      ((Xt.width > Ln || Xt.height > Ln) &&
        (Cn = Ln / Math.max(Xt.width, Xt.height)),
      Cn < 1 || Ut === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && Xt instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Xt instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Xt instanceof ImageBitmap)
      ) {
        const Mn = Ut ? floorPowerOfTwo : Math.floor,
          kn = Mn(Cn * Xt.width),
          Vn = Mn(Cn * Xt.height);
        yt === void 0 && (yt = xt(kn, Vn));
        const Kn = hn ? xt(kn, Vn) : yt;
        return (
          (Kn.width = kn),
          (Kn.height = Vn),
          Kn.getContext("2d").drawImage(Xt, 0, 0, kn, Vn),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Xt.width +
              "x" +
              Xt.height +
              ") to (" +
              kn +
              "x" +
              Vn +
              ")."
          ),
          Kn
        );
      } else
        return (
          "data" in Xt &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Xt.width +
                "x" +
                Xt.height +
                ")."
            ),
          Xt
        );
    return Xt;
  }
  function At(Xt) {
    return isPowerOfTwo(Xt.width) && isPowerOfTwo(Xt.height);
  }
  function Ct(Xt) {
    return at
      ? !1
      : Xt.wrapS !== ClampToEdgeWrapping ||
          Xt.wrapT !== ClampToEdgeWrapping ||
          (Xt.minFilter !== NearestFilter && Xt.minFilter !== LinearFilter);
  }
  function Mt(Xt, Ut) {
    return (
      Xt.generateMipmaps &&
      Ut &&
      Xt.minFilter !== NearestFilter &&
      Xt.minFilter !== LinearFilter
    );
  }
  function wt(Xt) {
    tt.generateMipmap(Xt);
  }
  function Bt(Xt, Ut, hn, Ln, Cn = !1) {
    if (at === !1) return Ut;
    if (Xt !== null) {
      if (tt[Xt] !== void 0) return tt[Xt];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Xt +
          "'"
      );
    }
    let Mn = Ut;
    if (
      (Ut === tt.RED &&
        (hn === tt.FLOAT && (Mn = tt.R32F),
        hn === tt.HALF_FLOAT && (Mn = tt.R16F),
        hn === tt.UNSIGNED_BYTE && (Mn = tt.R8)),
      Ut === tt.RED_INTEGER &&
        (hn === tt.UNSIGNED_BYTE && (Mn = tt.R8UI),
        hn === tt.UNSIGNED_SHORT && (Mn = tt.R16UI),
        hn === tt.UNSIGNED_INT && (Mn = tt.R32UI),
        hn === tt.BYTE && (Mn = tt.R8I),
        hn === tt.SHORT && (Mn = tt.R16I),
        hn === tt.INT && (Mn = tt.R32I)),
      Ut === tt.RG &&
        (hn === tt.FLOAT && (Mn = tt.RG32F),
        hn === tt.HALF_FLOAT && (Mn = tt.RG16F),
        hn === tt.UNSIGNED_BYTE && (Mn = tt.RG8)),
      Ut === tt.RGBA)
    ) {
      const kn = Cn ? LinearTransfer : ColorManagement.getTransfer(Ln);
      hn === tt.FLOAT && (Mn = tt.RGBA32F),
        hn === tt.HALF_FLOAT && (Mn = tt.RGBA16F),
        hn === tt.UNSIGNED_BYTE &&
          (Mn = kn === SRGBTransfer ? tt.SRGB8_ALPHA8 : tt.RGBA8),
        hn === tt.UNSIGNED_SHORT_4_4_4_4 && (Mn = tt.RGBA4),
        hn === tt.UNSIGNED_SHORT_5_5_5_1 && (Mn = tt.RGB5_A1);
    }
    return (
      (Mn === tt.R16F ||
        Mn === tt.R32F ||
        Mn === tt.RG16F ||
        Mn === tt.RG32F ||
        Mn === tt.RGBA16F ||
        Mn === tt.RGBA32F) &&
        et.get("EXT_color_buffer_float"),
      Mn
    );
  }
  function It(Xt, Ut, hn) {
    return Mt(Xt, hn) === !0 ||
      (Xt.isFramebufferTexture &&
        Xt.minFilter !== NearestFilter &&
        Xt.minFilter !== LinearFilter)
      ? Math.log2(Math.max(Ut.width, Ut.height)) + 1
      : Xt.mipmaps !== void 0 && Xt.mipmaps.length > 0
      ? Xt.mipmaps.length
      : Xt.isCompressedTexture && Array.isArray(Xt.image)
      ? Ut.mipmaps.length
      : 1;
  }
  function Ft(Xt) {
    return Xt === NearestFilter ||
      Xt === NearestMipmapNearestFilter ||
      Xt === NearestMipmapLinearFilter
      ? tt.NEAREST
      : tt.LINEAR;
  }
  function Vt(Xt) {
    const Ut = Xt.target;
    Ut.removeEventListener("dispose", Vt),
      Kt(Ut),
      Ut.isVideoTexture && vt.delete(Ut);
  }
  function $t(Xt) {
    const Ut = Xt.target;
    Ut.removeEventListener("dispose", $t), Wt(Ut);
  }
  function Kt(Xt) {
    const Ut = rt.get(Xt);
    if (Ut.__webglInit === void 0) return;
    const hn = Xt.source,
      Ln = Et.get(hn);
    if (Ln) {
      const Cn = Ln[Ut.__cacheKey];
      Cn.usedTimes--,
        Cn.usedTimes === 0 && Ht(Xt),
        Object.keys(Ln).length === 0 && Et.delete(hn);
    }
    rt.remove(Xt);
  }
  function Ht(Xt) {
    const Ut = rt.get(Xt);
    tt.deleteTexture(Ut.__webglTexture);
    const hn = Xt.source,
      Ln = Et.get(hn);
    delete Ln[Ut.__cacheKey], ot.memory.textures--;
  }
  function Wt(Xt) {
    const Ut = Xt.texture,
      hn = rt.get(Xt),
      Ln = rt.get(Ut);
    if (
      (Ln.__webglTexture !== void 0 &&
        (tt.deleteTexture(Ln.__webglTexture), ot.memory.textures--),
      Xt.depthTexture && Xt.depthTexture.dispose(),
      Xt.isWebGLCubeRenderTarget)
    )
      for (let Cn = 0; Cn < 6; Cn++) {
        if (Array.isArray(hn.__webglFramebuffer[Cn]))
          for (let Mn = 0; Mn < hn.__webglFramebuffer[Cn].length; Mn++)
            tt.deleteFramebuffer(hn.__webglFramebuffer[Cn][Mn]);
        else tt.deleteFramebuffer(hn.__webglFramebuffer[Cn]);
        hn.__webglDepthbuffer &&
          tt.deleteRenderbuffer(hn.__webglDepthbuffer[Cn]);
      }
    else {
      if (Array.isArray(hn.__webglFramebuffer))
        for (let Cn = 0; Cn < hn.__webglFramebuffer.length; Cn++)
          tt.deleteFramebuffer(hn.__webglFramebuffer[Cn]);
      else tt.deleteFramebuffer(hn.__webglFramebuffer);
      if (
        (hn.__webglDepthbuffer && tt.deleteRenderbuffer(hn.__webglDepthbuffer),
        hn.__webglMultisampledFramebuffer &&
          tt.deleteFramebuffer(hn.__webglMultisampledFramebuffer),
        hn.__webglColorRenderbuffer)
      )
        for (let Cn = 0; Cn < hn.__webglColorRenderbuffer.length; Cn++)
          hn.__webglColorRenderbuffer[Cn] &&
            tt.deleteRenderbuffer(hn.__webglColorRenderbuffer[Cn]);
      hn.__webglDepthRenderbuffer &&
        tt.deleteRenderbuffer(hn.__webglDepthRenderbuffer);
    }
    if (Xt.isWebGLMultipleRenderTargets)
      for (let Cn = 0, Mn = Ut.length; Cn < Mn; Cn++) {
        const kn = rt.get(Ut[Cn]);
        kn.__webglTexture &&
          (tt.deleteTexture(kn.__webglTexture), ot.memory.textures--),
          rt.remove(Ut[Cn]);
      }
    rt.remove(Ut), rt.remove(Xt);
  }
  let kt = 0;
  function Gt() {
    kt = 0;
  }
  function Pt() {
    const Xt = kt;
    return (
      Xt >= lt &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Xt +
            " texture units while this GPU supports only " +
            lt
        ),
      (kt += 1),
      Xt
    );
  }
  function Rt(Xt) {
    const Ut = [];
    return (
      Ut.push(Xt.wrapS),
      Ut.push(Xt.wrapT),
      Ut.push(Xt.wrapR || 0),
      Ut.push(Xt.magFilter),
      Ut.push(Xt.minFilter),
      Ut.push(Xt.anisotropy),
      Ut.push(Xt.internalFormat),
      Ut.push(Xt.format),
      Ut.push(Xt.type),
      Ut.push(Xt.generateMipmaps),
      Ut.push(Xt.premultiplyAlpha),
      Ut.push(Xt.flipY),
      Ut.push(Xt.unpackAlignment),
      Ut.push(Xt.colorSpace),
      Ut.join()
    );
  }
  function Nt(Xt, Ut) {
    const hn = rt.get(Xt);
    if (
      (Xt.isVideoTexture && An(Xt),
      Xt.isRenderTargetTexture === !1 &&
        Xt.version > 0 &&
        hn.__version !== Xt.version)
    ) {
      const Ln = Xt.image;
      if (Ln === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ln.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        bn(hn, Xt, Ut);
        return;
      }
    }
    nt.bindTexture(tt.TEXTURE_2D, hn.__webglTexture, tt.TEXTURE0 + Ut);
  }
  function Dt(Xt, Ut) {
    const hn = rt.get(Xt);
    if (Xt.version > 0 && hn.__version !== Xt.version) {
      bn(hn, Xt, Ut);
      return;
    }
    nt.bindTexture(tt.TEXTURE_2D_ARRAY, hn.__webglTexture, tt.TEXTURE0 + Ut);
  }
  function zt(Xt, Ut) {
    const hn = rt.get(Xt);
    if (Xt.version > 0 && hn.__version !== Xt.version) {
      bn(hn, Xt, Ut);
      return;
    }
    nt.bindTexture(tt.TEXTURE_3D, hn.__webglTexture, tt.TEXTURE0 + Ut);
  }
  function Yt(Xt, Ut) {
    const hn = rt.get(Xt);
    if (Xt.version > 0 && hn.__version !== Xt.version) {
      Bn(hn, Xt, Ut);
      return;
    }
    nt.bindTexture(tt.TEXTURE_CUBE_MAP, hn.__webglTexture, tt.TEXTURE0 + Ut);
  }
  const qt = {
      [RepeatWrapping]: tt.REPEAT,
      [ClampToEdgeWrapping]: tt.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: tt.MIRRORED_REPEAT,
    },
    Zt = {
      [NearestFilter]: tt.NEAREST,
      [NearestMipmapNearestFilter]: tt.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: tt.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: tt.LINEAR,
      [LinearMipmapNearestFilter]: tt.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: tt.LINEAR_MIPMAP_LINEAR,
    },
    Jt = {
      [NeverCompare]: tt.NEVER,
      [AlwaysCompare]: tt.ALWAYS,
      [LessCompare]: tt.LESS,
      [LessEqualCompare]: tt.LEQUAL,
      [EqualCompare]: tt.EQUAL,
      [GreaterEqualCompare]: tt.GEQUAL,
      [GreaterCompare]: tt.GREATER,
      [NotEqualCompare]: tt.NOTEQUAL,
    };
  function mn(Xt, Ut, hn) {
    if (
      (hn
        ? (tt.texParameteri(Xt, tt.TEXTURE_WRAP_S, qt[Ut.wrapS]),
          tt.texParameteri(Xt, tt.TEXTURE_WRAP_T, qt[Ut.wrapT]),
          (Xt === tt.TEXTURE_3D || Xt === tt.TEXTURE_2D_ARRAY) &&
            tt.texParameteri(Xt, tt.TEXTURE_WRAP_R, qt[Ut.wrapR]),
          tt.texParameteri(Xt, tt.TEXTURE_MAG_FILTER, Zt[Ut.magFilter]),
          tt.texParameteri(Xt, tt.TEXTURE_MIN_FILTER, Zt[Ut.minFilter]))
        : (tt.texParameteri(Xt, tt.TEXTURE_WRAP_S, tt.CLAMP_TO_EDGE),
          tt.texParameteri(Xt, tt.TEXTURE_WRAP_T, tt.CLAMP_TO_EDGE),
          (Xt === tt.TEXTURE_3D || Xt === tt.TEXTURE_2D_ARRAY) &&
            tt.texParameteri(Xt, tt.TEXTURE_WRAP_R, tt.CLAMP_TO_EDGE),
          (Ut.wrapS !== ClampToEdgeWrapping ||
            Ut.wrapT !== ClampToEdgeWrapping) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          tt.texParameteri(Xt, tt.TEXTURE_MAG_FILTER, Ft(Ut.magFilter)),
          tt.texParameteri(Xt, tt.TEXTURE_MIN_FILTER, Ft(Ut.minFilter)),
          Ut.minFilter !== NearestFilter &&
            Ut.minFilter !== LinearFilter &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      Ut.compareFunction &&
        (tt.texParameteri(
          Xt,
          tt.TEXTURE_COMPARE_MODE,
          tt.COMPARE_REF_TO_TEXTURE
        ),
        tt.texParameteri(Xt, tt.TEXTURE_COMPARE_FUNC, Jt[Ut.compareFunction])),
      et.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Ln = et.get("EXT_texture_filter_anisotropic");
      if (
        Ut.magFilter === NearestFilter ||
        (Ut.minFilter !== NearestMipmapLinearFilter &&
          Ut.minFilter !== LinearMipmapLinearFilter) ||
        (Ut.type === FloatType && et.has("OES_texture_float_linear") === !1) ||
        (at === !1 &&
          Ut.type === HalfFloatType &&
          et.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (Ut.anisotropy > 1 || rt.get(Ut).__currentAnisotropy) &&
        (tt.texParameterf(
          Xt,
          Ln.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Ut.anisotropy, it.getMaxAnisotropy())
        ),
        (rt.get(Ut).__currentAnisotropy = Ut.anisotropy));
    }
  }
  function ln(Xt, Ut) {
    let hn = !1;
    Xt.__webglInit === void 0 &&
      ((Xt.__webglInit = !0), Ut.addEventListener("dispose", Vt));
    const Ln = Ut.source;
    let Cn = Et.get(Ln);
    Cn === void 0 && ((Cn = {}), Et.set(Ln, Cn));
    const Mn = Rt(Ut);
    if (Mn !== Xt.__cacheKey) {
      Cn[Mn] === void 0 &&
        ((Cn[Mn] = { texture: tt.createTexture(), usedTimes: 0 }),
        ot.memory.textures++,
        (hn = !0)),
        Cn[Mn].usedTimes++;
      const kn = Cn[Xt.__cacheKey];
      kn !== void 0 &&
        (Cn[Xt.__cacheKey].usedTimes--, kn.usedTimes === 0 && Ht(Ut)),
        (Xt.__cacheKey = Mn),
        (Xt.__webglTexture = Cn[Mn].texture);
    }
    return hn;
  }
  function bn(Xt, Ut, hn) {
    let Ln = tt.TEXTURE_2D;
    (Ut.isDataArrayTexture || Ut.isCompressedArrayTexture) &&
      (Ln = tt.TEXTURE_2D_ARRAY),
      Ut.isData3DTexture && (Ln = tt.TEXTURE_3D);
    const Cn = ln(Xt, Ut),
      Mn = Ut.source;
    nt.bindTexture(Ln, Xt.__webglTexture, tt.TEXTURE0 + hn);
    const kn = rt.get(Mn);
    if (Mn.version !== kn.__version || Cn === !0) {
      nt.activeTexture(tt.TEXTURE0 + hn);
      const Vn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        Kn =
          Ut.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Ut.colorSpace),
        Yn =
          Ut.colorSpace === NoColorSpace || Vn === Kn
            ? tt.NONE
            : tt.BROWSER_DEFAULT_WEBGL;
      tt.pixelStorei(tt.UNPACK_FLIP_Y_WEBGL, Ut.flipY),
        tt.pixelStorei(tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ut.premultiplyAlpha),
        tt.pixelStorei(tt.UNPACK_ALIGNMENT, Ut.unpackAlignment),
        tt.pixelStorei(tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, Yn);
      const ir = Ct(Ut) && At(Ut.image) === !1;
      let On = St(Ut.image, ir, !1, ut);
      On = Wn(Ut, On);
      const qn = At(On) || at,
        dn = st.convert(Ut.format, Ut.colorSpace);
      let Pn = st.convert(Ut.type),
        Hn = Bt(Ut.internalFormat, dn, Pn, Ut.colorSpace, Ut.isVideoTexture);
      mn(Ln, Ut, qn);
      let Qt;
      const zn = Ut.mipmaps,
        Xn = at && Ut.isVideoTexture !== !0,
        Qn = kn.__version === void 0 || Cn === !0,
        tr = It(Ut, On, qn);
      if (Ut.isDepthTexture)
        (Hn = tt.DEPTH_COMPONENT),
          at
            ? Ut.type === FloatType
              ? (Hn = tt.DEPTH_COMPONENT32F)
              : Ut.type === UnsignedIntType
              ? (Hn = tt.DEPTH_COMPONENT24)
              : Ut.type === UnsignedInt248Type
              ? (Hn = tt.DEPTH24_STENCIL8)
              : (Hn = tt.DEPTH_COMPONENT16)
            : Ut.type === FloatType &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          Ut.format === DepthFormat &&
            Hn === tt.DEPTH_COMPONENT &&
            Ut.type !== UnsignedShortType &&
            Ut.type !== UnsignedIntType &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (Ut.type = UnsignedIntType),
            (Pn = st.convert(Ut.type))),
          Ut.format === DepthStencilFormat &&
            Hn === tt.DEPTH_COMPONENT &&
            ((Hn = tt.DEPTH_STENCIL),
            Ut.type !== UnsignedInt248Type &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (Ut.type = UnsignedInt248Type),
              (Pn = st.convert(Ut.type)))),
          Qn &&
            (Xn
              ? nt.texStorage2D(tt.TEXTURE_2D, 1, Hn, On.width, On.height)
              : nt.texImage2D(
                  tt.TEXTURE_2D,
                  0,
                  Hn,
                  On.width,
                  On.height,
                  0,
                  dn,
                  Pn,
                  null
                ));
      else if (Ut.isDataTexture)
        if (zn.length > 0 && qn) {
          Xn &&
            Qn &&
            nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, zn[0].width, zn[0].height);
          for (let jn = 0, nr = zn.length; jn < nr; jn++)
            (Qt = zn[jn]),
              Xn
                ? nt.texSubImage2D(
                    tt.TEXTURE_2D,
                    jn,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    dn,
                    Pn,
                    Qt.data
                  )
                : nt.texImage2D(
                    tt.TEXTURE_2D,
                    jn,
                    Hn,
                    Qt.width,
                    Qt.height,
                    0,
                    dn,
                    Pn,
                    Qt.data
                  );
          Ut.generateMipmaps = !1;
        } else
          Xn
            ? (Qn &&
                nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, On.width, On.height),
              nt.texSubImage2D(
                tt.TEXTURE_2D,
                0,
                0,
                0,
                On.width,
                On.height,
                dn,
                Pn,
                On.data
              ))
            : nt.texImage2D(
                tt.TEXTURE_2D,
                0,
                Hn,
                On.width,
                On.height,
                0,
                dn,
                Pn,
                On.data
              );
      else if (Ut.isCompressedTexture)
        if (Ut.isCompressedArrayTexture) {
          Xn &&
            Qn &&
            nt.texStorage3D(
              tt.TEXTURE_2D_ARRAY,
              tr,
              Hn,
              zn[0].width,
              zn[0].height,
              On.depth
            );
          for (let jn = 0, nr = zn.length; jn < nr; jn++)
            (Qt = zn[jn]),
              Ut.format !== RGBAFormat
                ? dn !== null
                  ? Xn
                    ? nt.compressedTexSubImage3D(
                        tt.TEXTURE_2D_ARRAY,
                        jn,
                        0,
                        0,
                        0,
                        Qt.width,
                        Qt.height,
                        On.depth,
                        dn,
                        Qt.data,
                        0,
                        0
                      )
                    : nt.compressedTexImage3D(
                        tt.TEXTURE_2D_ARRAY,
                        jn,
                        Hn,
                        Qt.width,
                        Qt.height,
                        On.depth,
                        0,
                        Qt.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Xn
                ? nt.texSubImage3D(
                    tt.TEXTURE_2D_ARRAY,
                    jn,
                    0,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    On.depth,
                    dn,
                    Pn,
                    Qt.data
                  )
                : nt.texImage3D(
                    tt.TEXTURE_2D_ARRAY,
                    jn,
                    Hn,
                    Qt.width,
                    Qt.height,
                    On.depth,
                    0,
                    dn,
                    Pn,
                    Qt.data
                  );
        } else {
          Xn &&
            Qn &&
            nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, zn[0].width, zn[0].height);
          for (let jn = 0, nr = zn.length; jn < nr; jn++)
            (Qt = zn[jn]),
              Ut.format !== RGBAFormat
                ? dn !== null
                  ? Xn
                    ? nt.compressedTexSubImage2D(
                        tt.TEXTURE_2D,
                        jn,
                        0,
                        0,
                        Qt.width,
                        Qt.height,
                        dn,
                        Qt.data
                      )
                    : nt.compressedTexImage2D(
                        tt.TEXTURE_2D,
                        jn,
                        Hn,
                        Qt.width,
                        Qt.height,
                        0,
                        Qt.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Xn
                ? nt.texSubImage2D(
                    tt.TEXTURE_2D,
                    jn,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    dn,
                    Pn,
                    Qt.data
                  )
                : nt.texImage2D(
                    tt.TEXTURE_2D,
                    jn,
                    Hn,
                    Qt.width,
                    Qt.height,
                    0,
                    dn,
                    Pn,
                    Qt.data
                  );
        }
      else if (Ut.isDataArrayTexture)
        Xn
          ? (Qn &&
              nt.texStorage3D(
                tt.TEXTURE_2D_ARRAY,
                tr,
                Hn,
                On.width,
                On.height,
                On.depth
              ),
            nt.texSubImage3D(
              tt.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              On.width,
              On.height,
              On.depth,
              dn,
              Pn,
              On.data
            ))
          : nt.texImage3D(
              tt.TEXTURE_2D_ARRAY,
              0,
              Hn,
              On.width,
              On.height,
              On.depth,
              0,
              dn,
              Pn,
              On.data
            );
      else if (Ut.isData3DTexture)
        Xn
          ? (Qn &&
              nt.texStorage3D(
                tt.TEXTURE_3D,
                tr,
                Hn,
                On.width,
                On.height,
                On.depth
              ),
            nt.texSubImage3D(
              tt.TEXTURE_3D,
              0,
              0,
              0,
              0,
              On.width,
              On.height,
              On.depth,
              dn,
              Pn,
              On.data
            ))
          : nt.texImage3D(
              tt.TEXTURE_3D,
              0,
              Hn,
              On.width,
              On.height,
              On.depth,
              0,
              dn,
              Pn,
              On.data
            );
      else if (Ut.isFramebufferTexture) {
        if (Qn)
          if (Xn) nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, On.width, On.height);
          else {
            let jn = On.width,
              nr = On.height;
            for (let or = 0; or < tr; or++)
              nt.texImage2D(tt.TEXTURE_2D, or, Hn, jn, nr, 0, dn, Pn, null),
                (jn >>= 1),
                (nr >>= 1);
          }
      } else if (zn.length > 0 && qn) {
        Xn &&
          Qn &&
          nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, zn[0].width, zn[0].height);
        for (let jn = 0, nr = zn.length; jn < nr; jn++)
          (Qt = zn[jn]),
            Xn
              ? nt.texSubImage2D(tt.TEXTURE_2D, jn, 0, 0, dn, Pn, Qt)
              : nt.texImage2D(tt.TEXTURE_2D, jn, Hn, dn, Pn, Qt);
        Ut.generateMipmaps = !1;
      } else
        Xn
          ? (Qn && nt.texStorage2D(tt.TEXTURE_2D, tr, Hn, On.width, On.height),
            nt.texSubImage2D(tt.TEXTURE_2D, 0, 0, 0, dn, Pn, On))
          : nt.texImage2D(tt.TEXTURE_2D, 0, Hn, dn, Pn, On);
      Mt(Ut, qn) && wt(Ln),
        (kn.__version = Mn.version),
        Ut.onUpdate && Ut.onUpdate(Ut);
    }
    Xt.__version = Ut.version;
  }
  function Bn(Xt, Ut, hn) {
    if (Ut.image.length !== 6) return;
    const Ln = ln(Xt, Ut),
      Cn = Ut.source;
    nt.bindTexture(tt.TEXTURE_CUBE_MAP, Xt.__webglTexture, tt.TEXTURE0 + hn);
    const Mn = rt.get(Cn);
    if (Cn.version !== Mn.__version || Ln === !0) {
      nt.activeTexture(tt.TEXTURE0 + hn);
      const kn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        Vn =
          Ut.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Ut.colorSpace),
        Kn =
          Ut.colorSpace === NoColorSpace || kn === Vn
            ? tt.NONE
            : tt.BROWSER_DEFAULT_WEBGL;
      tt.pixelStorei(tt.UNPACK_FLIP_Y_WEBGL, Ut.flipY),
        tt.pixelStorei(tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ut.premultiplyAlpha),
        tt.pixelStorei(tt.UNPACK_ALIGNMENT, Ut.unpackAlignment),
        tt.pixelStorei(tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, Kn);
      const Yn = Ut.isCompressedTexture || Ut.image[0].isCompressedTexture,
        ir = Ut.image[0] && Ut.image[0].isDataTexture,
        On = [];
      for (let jn = 0; jn < 6; jn++)
        !Yn && !ir
          ? (On[jn] = St(Ut.image[jn], !1, !0, ct))
          : (On[jn] = ir ? Ut.image[jn].image : Ut.image[jn]),
          (On[jn] = Wn(Ut, On[jn]));
      const qn = On[0],
        dn = At(qn) || at,
        Pn = st.convert(Ut.format, Ut.colorSpace),
        Hn = st.convert(Ut.type),
        Qt = Bt(Ut.internalFormat, Pn, Hn, Ut.colorSpace),
        zn = at && Ut.isVideoTexture !== !0,
        Xn = Mn.__version === void 0 || Ln === !0;
      let Qn = It(Ut, qn, dn);
      mn(tt.TEXTURE_CUBE_MAP, Ut, dn);
      let tr;
      if (Yn) {
        zn &&
          Xn &&
          nt.texStorage2D(tt.TEXTURE_CUBE_MAP, Qn, Qt, qn.width, qn.height);
        for (let jn = 0; jn < 6; jn++) {
          tr = On[jn].mipmaps;
          for (let nr = 0; nr < tr.length; nr++) {
            const or = tr[nr];
            Ut.format !== RGBAFormat
              ? Pn !== null
                ? zn
                  ? nt.compressedTexSubImage2D(
                      tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                      nr,
                      0,
                      0,
                      or.width,
                      or.height,
                      Pn,
                      or.data
                    )
                  : nt.compressedTexImage2D(
                      tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                      nr,
                      Qt,
                      or.width,
                      or.height,
                      0,
                      or.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : zn
              ? nt.texSubImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  nr,
                  0,
                  0,
                  or.width,
                  or.height,
                  Pn,
                  Hn,
                  or.data
                )
              : nt.texImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  nr,
                  Qt,
                  or.width,
                  or.height,
                  0,
                  Pn,
                  Hn,
                  or.data
                );
          }
        }
      } else {
        (tr = Ut.mipmaps),
          zn &&
            Xn &&
            (tr.length > 0 && Qn++,
            nt.texStorage2D(
              tt.TEXTURE_CUBE_MAP,
              Qn,
              Qt,
              On[0].width,
              On[0].height
            ));
        for (let jn = 0; jn < 6; jn++)
          if (ir) {
            zn
              ? nt.texSubImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  0,
                  0,
                  0,
                  On[jn].width,
                  On[jn].height,
                  Pn,
                  Hn,
                  On[jn].data
                )
              : nt.texImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  0,
                  Qt,
                  On[jn].width,
                  On[jn].height,
                  0,
                  Pn,
                  Hn,
                  On[jn].data
                );
            for (let nr = 0; nr < tr.length; nr++) {
              const vr = tr[nr].image[jn].image;
              zn
                ? nt.texSubImage2D(
                    tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                    nr + 1,
                    0,
                    0,
                    vr.width,
                    vr.height,
                    Pn,
                    Hn,
                    vr.data
                  )
                : nt.texImage2D(
                    tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                    nr + 1,
                    Qt,
                    vr.width,
                    vr.height,
                    0,
                    Pn,
                    Hn,
                    vr.data
                  );
            }
          } else {
            zn
              ? nt.texSubImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  0,
                  0,
                  0,
                  Pn,
                  Hn,
                  On[jn]
                )
              : nt.texImage2D(
                  tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                  0,
                  Qt,
                  Pn,
                  Hn,
                  On[jn]
                );
            for (let nr = 0; nr < tr.length; nr++) {
              const or = tr[nr];
              zn
                ? nt.texSubImage2D(
                    tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                    nr + 1,
                    0,
                    0,
                    Pn,
                    Hn,
                    or.image[jn]
                  )
                : nt.texImage2D(
                    tt.TEXTURE_CUBE_MAP_POSITIVE_X + jn,
                    nr + 1,
                    Qt,
                    Pn,
                    Hn,
                    or.image[jn]
                  );
            }
          }
      }
      Mt(Ut, dn) && wt(tt.TEXTURE_CUBE_MAP),
        (Mn.__version = Cn.version),
        Ut.onUpdate && Ut.onUpdate(Ut);
    }
    Xt.__version = Ut.version;
  }
  function gn(Xt, Ut, hn, Ln, Cn, Mn) {
    const kn = st.convert(hn.format, hn.colorSpace),
      Vn = st.convert(hn.type),
      Kn = Bt(hn.internalFormat, kn, Vn, hn.colorSpace);
    if (!rt.get(Ut).__hasExternalTextures) {
      const ir = Math.max(1, Ut.width >> Mn),
        On = Math.max(1, Ut.height >> Mn);
      Cn === tt.TEXTURE_3D || Cn === tt.TEXTURE_2D_ARRAY
        ? nt.texImage3D(Cn, Mn, Kn, ir, On, Ut.depth, 0, kn, Vn, null)
        : nt.texImage2D(Cn, Mn, Kn, ir, On, 0, kn, Vn, null);
    }
    nt.bindFramebuffer(tt.FRAMEBUFFER, Xt),
      Tn(Ut)
        ? ht.framebufferTexture2DMultisampleEXT(
            tt.FRAMEBUFFER,
            Ln,
            Cn,
            rt.get(hn).__webglTexture,
            0,
            Dn(Ut)
          )
        : (Cn === tt.TEXTURE_2D ||
            (Cn >= tt.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Cn <= tt.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          tt.framebufferTexture2D(
            tt.FRAMEBUFFER,
            Ln,
            Cn,
            rt.get(hn).__webglTexture,
            Mn
          ),
      nt.bindFramebuffer(tt.FRAMEBUFFER, null);
  }
  function jt(Xt, Ut, hn) {
    if (
      (tt.bindRenderbuffer(tt.RENDERBUFFER, Xt),
      Ut.depthBuffer && !Ut.stencilBuffer)
    ) {
      let Ln = at === !0 ? tt.DEPTH_COMPONENT24 : tt.DEPTH_COMPONENT16;
      if (hn || Tn(Ut)) {
        const Cn = Ut.depthTexture;
        Cn &&
          Cn.isDepthTexture &&
          (Cn.type === FloatType
            ? (Ln = tt.DEPTH_COMPONENT32F)
            : Cn.type === UnsignedIntType && (Ln = tt.DEPTH_COMPONENT24));
        const Mn = Dn(Ut);
        Tn(Ut)
          ? ht.renderbufferStorageMultisampleEXT(
              tt.RENDERBUFFER,
              Mn,
              Ln,
              Ut.width,
              Ut.height
            )
          : tt.renderbufferStorageMultisample(
              tt.RENDERBUFFER,
              Mn,
              Ln,
              Ut.width,
              Ut.height
            );
      } else tt.renderbufferStorage(tt.RENDERBUFFER, Ln, Ut.width, Ut.height);
      tt.framebufferRenderbuffer(
        tt.FRAMEBUFFER,
        tt.DEPTH_ATTACHMENT,
        tt.RENDERBUFFER,
        Xt
      );
    } else if (Ut.depthBuffer && Ut.stencilBuffer) {
      const Ln = Dn(Ut);
      hn && Tn(Ut) === !1
        ? tt.renderbufferStorageMultisample(
            tt.RENDERBUFFER,
            Ln,
            tt.DEPTH24_STENCIL8,
            Ut.width,
            Ut.height
          )
        : Tn(Ut)
        ? ht.renderbufferStorageMultisampleEXT(
            tt.RENDERBUFFER,
            Ln,
            tt.DEPTH24_STENCIL8,
            Ut.width,
            Ut.height
          )
        : tt.renderbufferStorage(
            tt.RENDERBUFFER,
            tt.DEPTH_STENCIL,
            Ut.width,
            Ut.height
          ),
        tt.framebufferRenderbuffer(
          tt.FRAMEBUFFER,
          tt.DEPTH_STENCIL_ATTACHMENT,
          tt.RENDERBUFFER,
          Xt
        );
    } else {
      const Ln =
        Ut.isWebGLMultipleRenderTargets === !0 ? Ut.texture : [Ut.texture];
      for (let Cn = 0; Cn < Ln.length; Cn++) {
        const Mn = Ln[Cn],
          kn = st.convert(Mn.format, Mn.colorSpace),
          Vn = st.convert(Mn.type),
          Kn = Bt(Mn.internalFormat, kn, Vn, Mn.colorSpace),
          Yn = Dn(Ut);
        hn && Tn(Ut) === !1
          ? tt.renderbufferStorageMultisample(
              tt.RENDERBUFFER,
              Yn,
              Kn,
              Ut.width,
              Ut.height
            )
          : Tn(Ut)
          ? ht.renderbufferStorageMultisampleEXT(
              tt.RENDERBUFFER,
              Yn,
              Kn,
              Ut.width,
              Ut.height
            )
          : tt.renderbufferStorage(tt.RENDERBUFFER, Kn, Ut.width, Ut.height);
      }
    }
    tt.bindRenderbuffer(tt.RENDERBUFFER, null);
  }
  function yn(Xt, Ut) {
    if (Ut && Ut.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (nt.bindFramebuffer(tt.FRAMEBUFFER, Xt),
      !(Ut.depthTexture && Ut.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!rt.get(Ut.depthTexture).__webglTexture ||
      Ut.depthTexture.image.width !== Ut.width ||
      Ut.depthTexture.image.height !== Ut.height) &&
      ((Ut.depthTexture.image.width = Ut.width),
      (Ut.depthTexture.image.height = Ut.height),
      (Ut.depthTexture.needsUpdate = !0)),
      Nt(Ut.depthTexture, 0);
    const Ln = rt.get(Ut.depthTexture).__webglTexture,
      Cn = Dn(Ut);
    if (Ut.depthTexture.format === DepthFormat)
      Tn(Ut)
        ? ht.framebufferTexture2DMultisampleEXT(
            tt.FRAMEBUFFER,
            tt.DEPTH_ATTACHMENT,
            tt.TEXTURE_2D,
            Ln,
            0,
            Cn
          )
        : tt.framebufferTexture2D(
            tt.FRAMEBUFFER,
            tt.DEPTH_ATTACHMENT,
            tt.TEXTURE_2D,
            Ln,
            0
          );
    else if (Ut.depthTexture.format === DepthStencilFormat)
      Tn(Ut)
        ? ht.framebufferTexture2DMultisampleEXT(
            tt.FRAMEBUFFER,
            tt.DEPTH_STENCIL_ATTACHMENT,
            tt.TEXTURE_2D,
            Ln,
            0,
            Cn
          )
        : tt.framebufferTexture2D(
            tt.FRAMEBUFFER,
            tt.DEPTH_STENCIL_ATTACHMENT,
            tt.TEXTURE_2D,
            Ln,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function pn(Xt) {
    const Ut = rt.get(Xt),
      hn = Xt.isWebGLCubeRenderTarget === !0;
    if (Xt.depthTexture && !Ut.__autoAllocateDepthBuffer) {
      if (hn)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      yn(Ut.__webglFramebuffer, Xt);
    } else if (hn) {
      Ut.__webglDepthbuffer = [];
      for (let Ln = 0; Ln < 6; Ln++)
        nt.bindFramebuffer(tt.FRAMEBUFFER, Ut.__webglFramebuffer[Ln]),
          (Ut.__webglDepthbuffer[Ln] = tt.createRenderbuffer()),
          jt(Ut.__webglDepthbuffer[Ln], Xt, !1);
    } else
      nt.bindFramebuffer(tt.FRAMEBUFFER, Ut.__webglFramebuffer),
        (Ut.__webglDepthbuffer = tt.createRenderbuffer()),
        jt(Ut.__webglDepthbuffer, Xt, !1);
    nt.bindFramebuffer(tt.FRAMEBUFFER, null);
  }
  function vn(Xt, Ut, hn) {
    const Ln = rt.get(Xt);
    Ut !== void 0 &&
      gn(
        Ln.__webglFramebuffer,
        Xt,
        Xt.texture,
        tt.COLOR_ATTACHMENT0,
        tt.TEXTURE_2D,
        0
      ),
      hn !== void 0 && pn(Xt);
  }
  function xn(Xt) {
    const Ut = Xt.texture,
      hn = rt.get(Xt),
      Ln = rt.get(Ut);
    Xt.addEventListener("dispose", $t),
      Xt.isWebGLMultipleRenderTargets !== !0 &&
        (Ln.__webglTexture === void 0 &&
          (Ln.__webglTexture = tt.createTexture()),
        (Ln.__version = Ut.version),
        ot.memory.textures++);
    const Cn = Xt.isWebGLCubeRenderTarget === !0,
      Mn = Xt.isWebGLMultipleRenderTargets === !0,
      kn = At(Xt) || at;
    if (Cn) {
      hn.__webglFramebuffer = [];
      for (let Vn = 0; Vn < 6; Vn++)
        if (at && Ut.mipmaps && Ut.mipmaps.length > 0) {
          hn.__webglFramebuffer[Vn] = [];
          for (let Kn = 0; Kn < Ut.mipmaps.length; Kn++)
            hn.__webglFramebuffer[Vn][Kn] = tt.createFramebuffer();
        } else hn.__webglFramebuffer[Vn] = tt.createFramebuffer();
    } else {
      if (at && Ut.mipmaps && Ut.mipmaps.length > 0) {
        hn.__webglFramebuffer = [];
        for (let Vn = 0; Vn < Ut.mipmaps.length; Vn++)
          hn.__webglFramebuffer[Vn] = tt.createFramebuffer();
      } else hn.__webglFramebuffer = tt.createFramebuffer();
      if (Mn)
        if (it.drawBuffers) {
          const Vn = Xt.texture;
          for (let Kn = 0, Yn = Vn.length; Kn < Yn; Kn++) {
            const ir = rt.get(Vn[Kn]);
            ir.__webglTexture === void 0 &&
              ((ir.__webglTexture = tt.createTexture()), ot.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (at && Xt.samples > 0 && Tn(Xt) === !1) {
        const Vn = Mn ? Ut : [Ut];
        (hn.__webglMultisampledFramebuffer = tt.createFramebuffer()),
          (hn.__webglColorRenderbuffer = []),
          nt.bindFramebuffer(tt.FRAMEBUFFER, hn.__webglMultisampledFramebuffer);
        for (let Kn = 0; Kn < Vn.length; Kn++) {
          const Yn = Vn[Kn];
          (hn.__webglColorRenderbuffer[Kn] = tt.createRenderbuffer()),
            tt.bindRenderbuffer(
              tt.RENDERBUFFER,
              hn.__webglColorRenderbuffer[Kn]
            );
          const ir = st.convert(Yn.format, Yn.colorSpace),
            On = st.convert(Yn.type),
            qn = Bt(
              Yn.internalFormat,
              ir,
              On,
              Yn.colorSpace,
              Xt.isXRRenderTarget === !0
            ),
            dn = Dn(Xt);
          tt.renderbufferStorageMultisample(
            tt.RENDERBUFFER,
            dn,
            qn,
            Xt.width,
            Xt.height
          ),
            tt.framebufferRenderbuffer(
              tt.FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0 + Kn,
              tt.RENDERBUFFER,
              hn.__webglColorRenderbuffer[Kn]
            );
        }
        tt.bindRenderbuffer(tt.RENDERBUFFER, null),
          Xt.depthBuffer &&
            ((hn.__webglDepthRenderbuffer = tt.createRenderbuffer()),
            jt(hn.__webglDepthRenderbuffer, Xt, !0)),
          nt.bindFramebuffer(tt.FRAMEBUFFER, null);
      }
    }
    if (Cn) {
      nt.bindTexture(tt.TEXTURE_CUBE_MAP, Ln.__webglTexture),
        mn(tt.TEXTURE_CUBE_MAP, Ut, kn);
      for (let Vn = 0; Vn < 6; Vn++)
        if (at && Ut.mipmaps && Ut.mipmaps.length > 0)
          for (let Kn = 0; Kn < Ut.mipmaps.length; Kn++)
            gn(
              hn.__webglFramebuffer[Vn][Kn],
              Xt,
              Ut,
              tt.COLOR_ATTACHMENT0,
              tt.TEXTURE_CUBE_MAP_POSITIVE_X + Vn,
              Kn
            );
        else
          gn(
            hn.__webglFramebuffer[Vn],
            Xt,
            Ut,
            tt.COLOR_ATTACHMENT0,
            tt.TEXTURE_CUBE_MAP_POSITIVE_X + Vn,
            0
          );
      Mt(Ut, kn) && wt(tt.TEXTURE_CUBE_MAP), nt.unbindTexture();
    } else if (Mn) {
      const Vn = Xt.texture;
      for (let Kn = 0, Yn = Vn.length; Kn < Yn; Kn++) {
        const ir = Vn[Kn],
          On = rt.get(ir);
        nt.bindTexture(tt.TEXTURE_2D, On.__webglTexture),
          mn(tt.TEXTURE_2D, ir, kn),
          gn(
            hn.__webglFramebuffer,
            Xt,
            ir,
            tt.COLOR_ATTACHMENT0 + Kn,
            tt.TEXTURE_2D,
            0
          ),
          Mt(ir, kn) && wt(tt.TEXTURE_2D);
      }
      nt.unbindTexture();
    } else {
      let Vn = tt.TEXTURE_2D;
      if (
        ((Xt.isWebGL3DRenderTarget || Xt.isWebGLArrayRenderTarget) &&
          (at
            ? (Vn = Xt.isWebGL3DRenderTarget
                ? tt.TEXTURE_3D
                : tt.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        nt.bindTexture(Vn, Ln.__webglTexture),
        mn(Vn, Ut, kn),
        at && Ut.mipmaps && Ut.mipmaps.length > 0)
      )
        for (let Kn = 0; Kn < Ut.mipmaps.length; Kn++)
          gn(hn.__webglFramebuffer[Kn], Xt, Ut, tt.COLOR_ATTACHMENT0, Vn, Kn);
      else gn(hn.__webglFramebuffer, Xt, Ut, tt.COLOR_ATTACHMENT0, Vn, 0);
      Mt(Ut, kn) && wt(Vn), nt.unbindTexture();
    }
    Xt.depthBuffer && pn(Xt);
  }
  function Fn(Xt) {
    const Ut = At(Xt) || at,
      hn = Xt.isWebGLMultipleRenderTargets === !0 ? Xt.texture : [Xt.texture];
    for (let Ln = 0, Cn = hn.length; Ln < Cn; Ln++) {
      const Mn = hn[Ln];
      if (Mt(Mn, Ut)) {
        const kn = Xt.isWebGLCubeRenderTarget
            ? tt.TEXTURE_CUBE_MAP
            : tt.TEXTURE_2D,
          Vn = rt.get(Mn).__webglTexture;
        nt.bindTexture(kn, Vn), wt(kn), nt.unbindTexture();
      }
    }
  }
  function _n(Xt) {
    if (at && Xt.samples > 0 && Tn(Xt) === !1) {
      const Ut = Xt.isWebGLMultipleRenderTargets ? Xt.texture : [Xt.texture],
        hn = Xt.width,
        Ln = Xt.height;
      let Cn = tt.COLOR_BUFFER_BIT;
      const Mn = [],
        kn = Xt.stencilBuffer
          ? tt.DEPTH_STENCIL_ATTACHMENT
          : tt.DEPTH_ATTACHMENT,
        Vn = rt.get(Xt),
        Kn = Xt.isWebGLMultipleRenderTargets === !0;
      if (Kn)
        for (let Yn = 0; Yn < Ut.length; Yn++)
          nt.bindFramebuffer(tt.FRAMEBUFFER, Vn.__webglMultisampledFramebuffer),
            tt.framebufferRenderbuffer(
              tt.FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0 + Yn,
              tt.RENDERBUFFER,
              null
            ),
            nt.bindFramebuffer(tt.FRAMEBUFFER, Vn.__webglFramebuffer),
            tt.framebufferTexture2D(
              tt.DRAW_FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0 + Yn,
              tt.TEXTURE_2D,
              null,
              0
            );
      nt.bindFramebuffer(
        tt.READ_FRAMEBUFFER,
        Vn.__webglMultisampledFramebuffer
      ),
        nt.bindFramebuffer(tt.DRAW_FRAMEBUFFER, Vn.__webglFramebuffer);
      for (let Yn = 0; Yn < Ut.length; Yn++) {
        Mn.push(tt.COLOR_ATTACHMENT0 + Yn), Xt.depthBuffer && Mn.push(kn);
        const ir =
          Vn.__ignoreDepthValues !== void 0 ? Vn.__ignoreDepthValues : !1;
        if (
          (ir === !1 &&
            (Xt.depthBuffer && (Cn |= tt.DEPTH_BUFFER_BIT),
            Xt.stencilBuffer && (Cn |= tt.STENCIL_BUFFER_BIT)),
          Kn &&
            tt.framebufferRenderbuffer(
              tt.READ_FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0,
              tt.RENDERBUFFER,
              Vn.__webglColorRenderbuffer[Yn]
            ),
          ir === !0 &&
            (tt.invalidateFramebuffer(tt.READ_FRAMEBUFFER, [kn]),
            tt.invalidateFramebuffer(tt.DRAW_FRAMEBUFFER, [kn])),
          Kn)
        ) {
          const On = rt.get(Ut[Yn]).__webglTexture;
          tt.framebufferTexture2D(
            tt.DRAW_FRAMEBUFFER,
            tt.COLOR_ATTACHMENT0,
            tt.TEXTURE_2D,
            On,
            0
          );
        }
        tt.blitFramebuffer(0, 0, hn, Ln, 0, 0, hn, Ln, Cn, tt.NEAREST),
          mt && tt.invalidateFramebuffer(tt.READ_FRAMEBUFFER, Mn);
      }
      if (
        (nt.bindFramebuffer(tt.READ_FRAMEBUFFER, null),
        nt.bindFramebuffer(tt.DRAW_FRAMEBUFFER, null),
        Kn)
      )
        for (let Yn = 0; Yn < Ut.length; Yn++) {
          nt.bindFramebuffer(tt.FRAMEBUFFER, Vn.__webglMultisampledFramebuffer),
            tt.framebufferRenderbuffer(
              tt.FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0 + Yn,
              tt.RENDERBUFFER,
              Vn.__webglColorRenderbuffer[Yn]
            );
          const ir = rt.get(Ut[Yn]).__webglTexture;
          nt.bindFramebuffer(tt.FRAMEBUFFER, Vn.__webglFramebuffer),
            tt.framebufferTexture2D(
              tt.DRAW_FRAMEBUFFER,
              tt.COLOR_ATTACHMENT0 + Yn,
              tt.TEXTURE_2D,
              ir,
              0
            );
        }
      nt.bindFramebuffer(
        tt.DRAW_FRAMEBUFFER,
        Vn.__webglMultisampledFramebuffer
      );
    }
  }
  function Dn(Xt) {
    return Math.min(ft, Xt.samples);
  }
  function Tn(Xt) {
    const Ut = rt.get(Xt);
    return (
      at &&
      Xt.samples > 0 &&
      et.has("WEBGL_multisampled_render_to_texture") === !0 &&
      Ut.__useRenderToTexture !== !1
    );
  }
  function An(Xt) {
    const Ut = ot.render.frame;
    vt.get(Xt) !== Ut && (vt.set(Xt, Ut), Xt.update());
  }
  function Wn(Xt, Ut) {
    const hn = Xt.colorSpace,
      Ln = Xt.format,
      Cn = Xt.type;
    return (
      Xt.isCompressedTexture === !0 ||
        Xt.isVideoTexture === !0 ||
        Xt.format === _SRGBAFormat ||
        (hn !== LinearSRGBColorSpace &&
          hn !== NoColorSpace &&
          (ColorManagement.getTransfer(hn) === SRGBTransfer
            ? at === !1
              ? et.has("EXT_sRGB") === !0 && Ln === RGBAFormat
                ? ((Xt.format = _SRGBAFormat),
                  (Xt.minFilter = LinearFilter),
                  (Xt.generateMipmaps = !1))
                : (Ut = ImageUtils.sRGBToLinear(Ut))
              : (Ln !== RGBAFormat || Cn !== UnsignedByteType) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                hn
              ))),
      Ut
    );
  }
  (this.allocateTextureUnit = Pt),
    (this.resetTextureUnits = Gt),
    (this.setTexture2D = Nt),
    (this.setTexture2DArray = Dt),
    (this.setTexture3D = zt),
    (this.setTextureCube = Yt),
    (this.rebindTextures = vn),
    (this.setupRenderTarget = xn),
    (this.updateRenderTargetMipmap = Fn),
    (this.updateMultisampleRenderTarget = _n),
    (this.setupDepthRenderbuffer = pn),
    (this.setupFrameBufferTexture = gn),
    (this.useMultisampledRTT = Tn);
}
function WebGLUtils(tt, et, nt) {
  const rt = nt.isWebGL2;
  function it(st, ot = NoColorSpace) {
    let at;
    const lt = ColorManagement.getTransfer(ot);
    if (st === UnsignedByteType) return tt.UNSIGNED_BYTE;
    if (st === UnsignedShort4444Type) return tt.UNSIGNED_SHORT_4_4_4_4;
    if (st === UnsignedShort5551Type) return tt.UNSIGNED_SHORT_5_5_5_1;
    if (st === ByteType) return tt.BYTE;
    if (st === ShortType) return tt.SHORT;
    if (st === UnsignedShortType) return tt.UNSIGNED_SHORT;
    if (st === IntType) return tt.INT;
    if (st === UnsignedIntType) return tt.UNSIGNED_INT;
    if (st === FloatType) return tt.FLOAT;
    if (st === HalfFloatType)
      return rt
        ? tt.HALF_FLOAT
        : ((at = et.get("OES_texture_half_float")),
          at !== null ? at.HALF_FLOAT_OES : null);
    if (st === AlphaFormat) return tt.ALPHA;
    if (st === RGBAFormat) return tt.RGBA;
    if (st === LuminanceFormat) return tt.LUMINANCE;
    if (st === LuminanceAlphaFormat) return tt.LUMINANCE_ALPHA;
    if (st === DepthFormat) return tt.DEPTH_COMPONENT;
    if (st === DepthStencilFormat) return tt.DEPTH_STENCIL;
    if (st === _SRGBAFormat)
      return (at = et.get("EXT_sRGB")), at !== null ? at.SRGB_ALPHA_EXT : null;
    if (st === RedFormat) return tt.RED;
    if (st === RedIntegerFormat) return tt.RED_INTEGER;
    if (st === RGFormat) return tt.RG;
    if (st === RGIntegerFormat) return tt.RG_INTEGER;
    if (st === RGBAIntegerFormat) return tt.RGBA_INTEGER;
    if (
      st === RGB_S3TC_DXT1_Format ||
      st === RGBA_S3TC_DXT1_Format ||
      st === RGBA_S3TC_DXT3_Format ||
      st === RGBA_S3TC_DXT5_Format
    )
      if (lt === SRGBTransfer)
        if (
          ((at = et.get("WEBGL_compressed_texture_s3tc_srgb")), at !== null)
        ) {
          if (st === RGB_S3TC_DXT1_Format)
            return at.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (st === RGBA_S3TC_DXT1_Format)
            return at.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (st === RGBA_S3TC_DXT3_Format)
            return at.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (st === RGBA_S3TC_DXT5_Format)
            return at.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((at = et.get("WEBGL_compressed_texture_s3tc")), at !== null)) {
        if (st === RGB_S3TC_DXT1_Format) return at.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (st === RGBA_S3TC_DXT1_Format)
          return at.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (st === RGBA_S3TC_DXT3_Format)
          return at.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (st === RGBA_S3TC_DXT5_Format)
          return at.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (
      st === RGB_PVRTC_4BPPV1_Format ||
      st === RGB_PVRTC_2BPPV1_Format ||
      st === RGBA_PVRTC_4BPPV1_Format ||
      st === RGBA_PVRTC_2BPPV1_Format
    )
      if (((at = et.get("WEBGL_compressed_texture_pvrtc")), at !== null)) {
        if (st === RGB_PVRTC_4BPPV1_Format)
          return at.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (st === RGB_PVRTC_2BPPV1_Format)
          return at.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (st === RGBA_PVRTC_4BPPV1_Format)
          return at.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (st === RGBA_PVRTC_2BPPV1_Format)
          return at.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (st === RGB_ETC1_Format)
      return (
        (at = et.get("WEBGL_compressed_texture_etc1")),
        at !== null ? at.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (st === RGB_ETC2_Format || st === RGBA_ETC2_EAC_Format)
      if (((at = et.get("WEBGL_compressed_texture_etc")), at !== null)) {
        if (st === RGB_ETC2_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ETC2
            : at.COMPRESSED_RGB8_ETC2;
        if (st === RGBA_ETC2_EAC_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : at.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      st === RGBA_ASTC_4x4_Format ||
      st === RGBA_ASTC_5x4_Format ||
      st === RGBA_ASTC_5x5_Format ||
      st === RGBA_ASTC_6x5_Format ||
      st === RGBA_ASTC_6x6_Format ||
      st === RGBA_ASTC_8x5_Format ||
      st === RGBA_ASTC_8x6_Format ||
      st === RGBA_ASTC_8x8_Format ||
      st === RGBA_ASTC_10x5_Format ||
      st === RGBA_ASTC_10x6_Format ||
      st === RGBA_ASTC_10x8_Format ||
      st === RGBA_ASTC_10x10_Format ||
      st === RGBA_ASTC_12x10_Format ||
      st === RGBA_ASTC_12x12_Format
    )
      if (((at = et.get("WEBGL_compressed_texture_astc")), at !== null)) {
        if (st === RGBA_ASTC_4x4_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : at.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (st === RGBA_ASTC_5x4_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : at.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (st === RGBA_ASTC_5x5_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : at.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (st === RGBA_ASTC_6x5_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : at.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (st === RGBA_ASTC_6x6_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : at.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (st === RGBA_ASTC_8x5_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : at.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (st === RGBA_ASTC_8x6_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : at.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (st === RGBA_ASTC_8x8_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : at.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (st === RGBA_ASTC_10x5_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : at.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (st === RGBA_ASTC_10x6_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : at.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (st === RGBA_ASTC_10x8_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : at.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (st === RGBA_ASTC_10x10_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : at.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (st === RGBA_ASTC_12x10_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : at.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (st === RGBA_ASTC_12x12_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : at.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (
      st === RGBA_BPTC_Format ||
      st === RGB_BPTC_SIGNED_Format ||
      st === RGB_BPTC_UNSIGNED_Format
    )
      if (((at = et.get("EXT_texture_compression_bptc")), at !== null)) {
        if (st === RGBA_BPTC_Format)
          return lt === SRGBTransfer
            ? at.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : at.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (st === RGB_BPTC_SIGNED_Format)
          return at.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (st === RGB_BPTC_UNSIGNED_Format)
          return at.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (
      st === RED_RGTC1_Format ||
      st === SIGNED_RED_RGTC1_Format ||
      st === RED_GREEN_RGTC2_Format ||
      st === SIGNED_RED_GREEN_RGTC2_Format
    )
      if (((at = et.get("EXT_texture_compression_rgtc")), at !== null)) {
        if (st === RGBA_BPTC_Format) return at.COMPRESSED_RED_RGTC1_EXT;
        if (st === SIGNED_RED_RGTC1_Format)
          return at.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (st === RED_GREEN_RGTC2_Format)
          return at.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (st === SIGNED_RED_GREEN_RGTC2_Format)
          return at.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return st === UnsignedInt248Type
      ? rt
        ? tt.UNSIGNED_INT_24_8
        : ((at = et.get("WEBGL_depth_texture")),
          at !== null ? at.UNSIGNED_INT_24_8_WEBGL : null)
      : tt[st] !== void 0
      ? tt[st]
      : null;
  }
  return { convert: it };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(et = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = et);
  }
}
class Group extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Group()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Group()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Group()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    );
  }
  dispatchEvent(et) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(et),
      this._grip !== null && this._grip.dispatchEvent(et),
      this._hand !== null && this._hand.dispatchEvent(et),
      this
    );
  }
  connect(et) {
    if (et && et.hand) {
      const nt = this._hand;
      if (nt) for (const rt of et.hand.values()) this._getHandJoint(nt, rt);
    }
    return this.dispatchEvent({ type: "connected", data: et }), this;
  }
  disconnect(et) {
    return (
      this.dispatchEvent({ type: "disconnected", data: et }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(et, nt, rt) {
    let it = null,
      st = null,
      ot = null;
    const at = this._targetRay,
      lt = this._grip,
      ct = this._hand;
    if (et && nt.session.visibilityState !== "visible-blurred") {
      if (ct && et.hand) {
        ot = !0;
        for (const yt of et.hand.values()) {
          const Et = nt.getJointPose(yt, rt),
            pt = this._getHandJoint(ct, yt);
          Et !== null &&
            (pt.matrix.fromArray(Et.transform.matrix),
            pt.matrix.decompose(pt.position, pt.rotation, pt.scale),
            (pt.matrixWorldNeedsUpdate = !0),
            (pt.jointRadius = Et.radius)),
            (pt.visible = Et !== null);
        }
        const ut = ct.joints["index-finger-tip"],
          ft = ct.joints["thumb-tip"],
          ht = ut.position.distanceTo(ft.position),
          mt = 0.02,
          vt = 0.005;
        ct.inputState.pinching && ht > mt + vt
          ? ((ct.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: et.handedness,
              target: this,
            }))
          : !ct.inputState.pinching &&
            ht <= mt - vt &&
            ((ct.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: et.handedness,
              target: this,
            }));
      } else
        lt !== null &&
          et.gripSpace &&
          ((st = nt.getPose(et.gripSpace, rt)),
          st !== null &&
            (lt.matrix.fromArray(st.transform.matrix),
            lt.matrix.decompose(lt.position, lt.rotation, lt.scale),
            (lt.matrixWorldNeedsUpdate = !0),
            st.linearVelocity
              ? ((lt.hasLinearVelocity = !0),
                lt.linearVelocity.copy(st.linearVelocity))
              : (lt.hasLinearVelocity = !1),
            st.angularVelocity
              ? ((lt.hasAngularVelocity = !0),
                lt.angularVelocity.copy(st.angularVelocity))
              : (lt.hasAngularVelocity = !1)));
      at !== null &&
        ((it = nt.getPose(et.targetRaySpace, rt)),
        it === null && st !== null && (it = st),
        it !== null &&
          (at.matrix.fromArray(it.transform.matrix),
          at.matrix.decompose(at.position, at.rotation, at.scale),
          (at.matrixWorldNeedsUpdate = !0),
          it.linearVelocity
            ? ((at.hasLinearVelocity = !0),
              at.linearVelocity.copy(it.linearVelocity))
            : (at.hasLinearVelocity = !1),
          it.angularVelocity
            ? ((at.hasAngularVelocity = !0),
              at.angularVelocity.copy(it.angularVelocity))
            : (at.hasAngularVelocity = !1),
          this.dispatchEvent(_moveEvent)));
    }
    return (
      at !== null && (at.visible = it !== null),
      lt !== null && (lt.visible = st !== null),
      ct !== null && (ct.visible = ot !== null),
      this
    );
  }
  _getHandJoint(et, nt) {
    if (et.joints[nt.jointName] === void 0) {
      const rt = new Group();
      (rt.matrixAutoUpdate = !1),
        (rt.visible = !1),
        (et.joints[nt.jointName] = rt),
        et.add(rt);
    }
    return et.joints[nt.jointName];
  }
}
class DepthTexture extends Texture {
  constructor(et, nt, rt, it, st, ot, at, lt, ct, ut) {
    if (
      ((ut = ut !== void 0 ? ut : DepthFormat),
      ut !== DepthFormat && ut !== DepthStencilFormat)
    )
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    rt === void 0 && ut === DepthFormat && (rt = UnsignedIntType),
      rt === void 0 && ut === DepthStencilFormat && (rt = UnsignedInt248Type),
      super(null, it, st, ot, at, lt, ut, rt, ct),
      (this.isDepthTexture = !0),
      (this.image = { width: et, height: nt }),
      (this.magFilter = at !== void 0 ? at : NearestFilter),
      (this.minFilter = lt !== void 0 ? lt : NearestFilter),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(et) {
    return super.copy(et), (this.compareFunction = et.compareFunction), this;
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      this.compareFunction !== null &&
        (nt.compareFunction = this.compareFunction),
      nt
    );
  }
}
class WebXRManager extends EventDispatcher {
  constructor(et, nt) {
    super();
    const rt = this;
    let it = null,
      st = 1,
      ot = null,
      at = "local-floor",
      lt = 1,
      ct = null,
      ut = null,
      ft = null,
      ht = null,
      mt = null,
      vt = null;
    const yt = nt.getContextAttributes();
    let Et = null,
      pt = null;
    const xt = [],
      St = [],
      At = new PerspectiveCamera();
    At.layers.enable(1), (At.viewport = new Vector4());
    const Ct = new PerspectiveCamera();
    Ct.layers.enable(2), (Ct.viewport = new Vector4());
    const Mt = [At, Ct],
      wt = new ArrayCamera();
    wt.layers.enable(1), wt.layers.enable(2);
    let Bt = null,
      It = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Dt) {
        let zt = xt[Dt];
        return (
          zt === void 0 && ((zt = new WebXRController()), (xt[Dt] = zt)),
          zt.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Dt) {
        let zt = xt[Dt];
        return (
          zt === void 0 && ((zt = new WebXRController()), (xt[Dt] = zt)),
          zt.getGripSpace()
        );
      }),
      (this.getHand = function (Dt) {
        let zt = xt[Dt];
        return (
          zt === void 0 && ((zt = new WebXRController()), (xt[Dt] = zt)),
          zt.getHandSpace()
        );
      });
    function Ft(Dt) {
      const zt = St.indexOf(Dt.inputSource);
      if (zt === -1) return;
      const Yt = xt[zt];
      Yt !== void 0 &&
        (Yt.update(Dt.inputSource, Dt.frame, ct || ot),
        Yt.dispatchEvent({ type: Dt.type, data: Dt.inputSource }));
    }
    function Vt() {
      it.removeEventListener("select", Ft),
        it.removeEventListener("selectstart", Ft),
        it.removeEventListener("selectend", Ft),
        it.removeEventListener("squeeze", Ft),
        it.removeEventListener("squeezestart", Ft),
        it.removeEventListener("squeezeend", Ft),
        it.removeEventListener("end", Vt),
        it.removeEventListener("inputsourceschange", $t);
      for (let Dt = 0; Dt < xt.length; Dt++) {
        const zt = St[Dt];
        zt !== null && ((St[Dt] = null), xt[Dt].disconnect(zt));
      }
      (Bt = null),
        (It = null),
        et.setRenderTarget(Et),
        (mt = null),
        (ht = null),
        (ft = null),
        (it = null),
        (pt = null),
        Nt.stop(),
        (rt.isPresenting = !1),
        rt.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (Dt) {
      (st = Dt),
        rt.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (Dt) {
        (at = Dt),
          rt.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return ct || ot;
      }),
      (this.setReferenceSpace = function (Dt) {
        ct = Dt;
      }),
      (this.getBaseLayer = function () {
        return ht !== null ? ht : mt;
      }),
      (this.getBinding = function () {
        return ft;
      }),
      (this.getFrame = function () {
        return vt;
      }),
      (this.getSession = function () {
        return it;
      }),
      (this.setSession = async function (Dt) {
        if (((it = Dt), it !== null)) {
          if (
            ((Et = et.getRenderTarget()),
            it.addEventListener("select", Ft),
            it.addEventListener("selectstart", Ft),
            it.addEventListener("selectend", Ft),
            it.addEventListener("squeeze", Ft),
            it.addEventListener("squeezestart", Ft),
            it.addEventListener("squeezeend", Ft),
            it.addEventListener("end", Vt),
            it.addEventListener("inputsourceschange", $t),
            yt.xrCompatible !== !0 && (await nt.makeXRCompatible()),
            it.renderState.layers === void 0 || et.capabilities.isWebGL2 === !1)
          ) {
            const zt = {
              antialias: it.renderState.layers === void 0 ? yt.antialias : !0,
              alpha: !0,
              depth: yt.depth,
              stencil: yt.stencil,
              framebufferScaleFactor: st,
            };
            (mt = new XRWebGLLayer(it, nt, zt)),
              it.updateRenderState({ baseLayer: mt }),
              (pt = new WebGLRenderTarget(
                mt.framebufferWidth,
                mt.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: et.outputColorSpace,
                  stencilBuffer: yt.stencil,
                }
              ));
          } else {
            let zt = null,
              Yt = null,
              qt = null;
            yt.depth &&
              ((qt = yt.stencil ? nt.DEPTH24_STENCIL8 : nt.DEPTH_COMPONENT24),
              (zt = yt.stencil ? DepthStencilFormat : DepthFormat),
              (Yt = yt.stencil ? UnsignedInt248Type : UnsignedIntType));
            const Zt = {
              colorFormat: nt.RGBA8,
              depthFormat: qt,
              scaleFactor: st,
            };
            (ft = new XRWebGLBinding(it, nt)),
              (ht = ft.createProjectionLayer(Zt)),
              it.updateRenderState({ layers: [ht] }),
              (pt = new WebGLRenderTarget(ht.textureWidth, ht.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(
                  ht.textureWidth,
                  ht.textureHeight,
                  Yt,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  zt
                ),
                stencilBuffer: yt.stencil,
                colorSpace: et.outputColorSpace,
                samples: yt.antialias ? 4 : 0,
              }));
            const Jt = et.properties.get(pt);
            Jt.__ignoreDepthValues = ht.ignoreDepthValues;
          }
          (pt.isXRRenderTarget = !0),
            this.setFoveation(lt),
            (ct = null),
            (ot = await it.requestReferenceSpace(at)),
            Nt.setContext(it),
            Nt.start(),
            (rt.isPresenting = !0),
            rt.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (it !== null) return it.environmentBlendMode;
      });
    function $t(Dt) {
      for (let zt = 0; zt < Dt.removed.length; zt++) {
        const Yt = Dt.removed[zt],
          qt = St.indexOf(Yt);
        qt >= 0 && ((St[qt] = null), xt[qt].disconnect(Yt));
      }
      for (let zt = 0; zt < Dt.added.length; zt++) {
        const Yt = Dt.added[zt];
        let qt = St.indexOf(Yt);
        if (qt === -1) {
          for (let Jt = 0; Jt < xt.length; Jt++)
            if (Jt >= St.length) {
              St.push(Yt), (qt = Jt);
              break;
            } else if (St[Jt] === null) {
              (St[Jt] = Yt), (qt = Jt);
              break;
            }
          if (qt === -1) break;
        }
        const Zt = xt[qt];
        Zt && Zt.connect(Yt);
      }
    }
    const Kt = new Vector3(),
      Ht = new Vector3();
    function Wt(Dt, zt, Yt) {
      Kt.setFromMatrixPosition(zt.matrixWorld),
        Ht.setFromMatrixPosition(Yt.matrixWorld);
      const qt = Kt.distanceTo(Ht),
        Zt = zt.projectionMatrix.elements,
        Jt = Yt.projectionMatrix.elements,
        mn = Zt[14] / (Zt[10] - 1),
        ln = Zt[14] / (Zt[10] + 1),
        bn = (Zt[9] + 1) / Zt[5],
        Bn = (Zt[9] - 1) / Zt[5],
        gn = (Zt[8] - 1) / Zt[0],
        jt = (Jt[8] + 1) / Jt[0],
        yn = mn * gn,
        pn = mn * jt,
        vn = qt / (-gn + jt),
        xn = vn * -gn;
      zt.matrixWorld.decompose(Dt.position, Dt.quaternion, Dt.scale),
        Dt.translateX(xn),
        Dt.translateZ(vn),
        Dt.matrixWorld.compose(Dt.position, Dt.quaternion, Dt.scale),
        Dt.matrixWorldInverse.copy(Dt.matrixWorld).invert();
      const Fn = mn + vn,
        _n = ln + vn,
        Dn = yn - xn,
        Tn = pn + (qt - xn),
        An = ((bn * ln) / _n) * Fn,
        Wn = ((Bn * ln) / _n) * Fn;
      Dt.projectionMatrix.makePerspective(Dn, Tn, An, Wn, Fn, _n),
        Dt.projectionMatrixInverse.copy(Dt.projectionMatrix).invert();
    }
    function kt(Dt, zt) {
      zt === null
        ? Dt.matrixWorld.copy(Dt.matrix)
        : Dt.matrixWorld.multiplyMatrices(zt.matrixWorld, Dt.matrix),
        Dt.matrixWorldInverse.copy(Dt.matrixWorld).invert();
    }
    this.updateCamera = function (Dt) {
      if (it === null) return;
      (wt.near = Ct.near = At.near = Dt.near),
        (wt.far = Ct.far = At.far = Dt.far),
        (Bt !== wt.near || It !== wt.far) &&
          (it.updateRenderState({ depthNear: wt.near, depthFar: wt.far }),
          (Bt = wt.near),
          (It = wt.far));
      const zt = Dt.parent,
        Yt = wt.cameras;
      kt(wt, zt);
      for (let qt = 0; qt < Yt.length; qt++) kt(Yt[qt], zt);
      Yt.length === 2
        ? Wt(wt, At, Ct)
        : wt.projectionMatrix.copy(At.projectionMatrix),
        Gt(Dt, wt, zt);
    };
    function Gt(Dt, zt, Yt) {
      Yt === null
        ? Dt.matrix.copy(zt.matrixWorld)
        : (Dt.matrix.copy(Yt.matrixWorld),
          Dt.matrix.invert(),
          Dt.matrix.multiply(zt.matrixWorld)),
        Dt.matrix.decompose(Dt.position, Dt.quaternion, Dt.scale),
        Dt.updateMatrixWorld(!0),
        Dt.projectionMatrix.copy(zt.projectionMatrix),
        Dt.projectionMatrixInverse.copy(zt.projectionMatrixInverse),
        Dt.isPerspectiveCamera &&
          ((Dt.fov =
            RAD2DEG * 2 * Math.atan(1 / Dt.projectionMatrix.elements[5])),
          (Dt.zoom = 1));
    }
    (this.getCamera = function () {
      return wt;
    }),
      (this.getFoveation = function () {
        if (!(ht === null && mt === null)) return lt;
      }),
      (this.setFoveation = function (Dt) {
        (lt = Dt),
          ht !== null && (ht.fixedFoveation = Dt),
          mt !== null &&
            mt.fixedFoveation !== void 0 &&
            (mt.fixedFoveation = Dt);
      });
    let Pt = null;
    function Rt(Dt, zt) {
      if (((ut = zt.getViewerPose(ct || ot)), (vt = zt), ut !== null)) {
        const Yt = ut.views;
        mt !== null &&
          (et.setRenderTargetFramebuffer(pt, mt.framebuffer),
          et.setRenderTarget(pt));
        let qt = !1;
        Yt.length !== wt.cameras.length && ((wt.cameras.length = 0), (qt = !0));
        for (let Zt = 0; Zt < Yt.length; Zt++) {
          const Jt = Yt[Zt];
          let mn = null;
          if (mt !== null) mn = mt.getViewport(Jt);
          else {
            const bn = ft.getViewSubImage(ht, Jt);
            (mn = bn.viewport),
              Zt === 0 &&
                (et.setRenderTargetTextures(
                  pt,
                  bn.colorTexture,
                  ht.ignoreDepthValues ? void 0 : bn.depthStencilTexture
                ),
                et.setRenderTarget(pt));
          }
          let ln = Mt[Zt];
          ln === void 0 &&
            ((ln = new PerspectiveCamera()),
            ln.layers.enable(Zt),
            (ln.viewport = new Vector4()),
            (Mt[Zt] = ln)),
            ln.matrix.fromArray(Jt.transform.matrix),
            ln.matrix.decompose(ln.position, ln.quaternion, ln.scale),
            ln.projectionMatrix.fromArray(Jt.projectionMatrix),
            ln.projectionMatrixInverse.copy(ln.projectionMatrix).invert(),
            ln.viewport.set(mn.x, mn.y, mn.width, mn.height),
            Zt === 0 &&
              (wt.matrix.copy(ln.matrix),
              wt.matrix.decompose(wt.position, wt.quaternion, wt.scale)),
            qt === !0 && wt.cameras.push(ln);
        }
      }
      for (let Yt = 0; Yt < xt.length; Yt++) {
        const qt = St[Yt],
          Zt = xt[Yt];
        qt !== null && Zt !== void 0 && Zt.update(qt, zt, ct || ot);
      }
      Pt && Pt(Dt, zt),
        zt.detectedPlanes &&
          rt.dispatchEvent({ type: "planesdetected", data: zt }),
        (vt = null);
    }
    const Nt = new WebGLAnimation();
    Nt.setAnimationLoop(Rt),
      (this.setAnimationLoop = function (Dt) {
        Pt = Dt;
      }),
      (this.dispose = function () {});
  }
}
function WebGLMaterials(tt, et) {
  function nt(Et, pt) {
    Et.matrixAutoUpdate === !0 && Et.updateMatrix(), pt.value.copy(Et.matrix);
  }
  function rt(Et, pt) {
    pt.color.getRGB(Et.fogColor.value, getUnlitUniformColorSpace(tt)),
      pt.isFog
        ? ((Et.fogNear.value = pt.near), (Et.fogFar.value = pt.far))
        : pt.isFogExp2 && (Et.fogDensity.value = pt.density);
  }
  function it(Et, pt, xt, St, At) {
    pt.isMeshBasicMaterial || pt.isMeshLambertMaterial
      ? st(Et, pt)
      : pt.isMeshToonMaterial
      ? (st(Et, pt), ft(Et, pt))
      : pt.isMeshPhongMaterial
      ? (st(Et, pt), ut(Et, pt))
      : pt.isMeshStandardMaterial
      ? (st(Et, pt), ht(Et, pt), pt.isMeshPhysicalMaterial && mt(Et, pt, At))
      : pt.isMeshMatcapMaterial
      ? (st(Et, pt), vt(Et, pt))
      : pt.isMeshDepthMaterial
      ? st(Et, pt)
      : pt.isMeshDistanceMaterial
      ? (st(Et, pt), yt(Et, pt))
      : pt.isMeshNormalMaterial
      ? st(Et, pt)
      : pt.isLineBasicMaterial
      ? (ot(Et, pt), pt.isLineDashedMaterial && at(Et, pt))
      : pt.isPointsMaterial
      ? lt(Et, pt, xt, St)
      : pt.isSpriteMaterial
      ? ct(Et, pt)
      : pt.isShadowMaterial
      ? (Et.color.value.copy(pt.color), (Et.opacity.value = pt.opacity))
      : pt.isShaderMaterial && (pt.uniformsNeedUpdate = !1);
  }
  function st(Et, pt) {
    (Et.opacity.value = pt.opacity),
      pt.color && Et.diffuse.value.copy(pt.color),
      pt.emissive &&
        Et.emissive.value
          .copy(pt.emissive)
          .multiplyScalar(pt.emissiveIntensity),
      pt.map && ((Et.map.value = pt.map), nt(pt.map, Et.mapTransform)),
      pt.alphaMap &&
        ((Et.alphaMap.value = pt.alphaMap),
        nt(pt.alphaMap, Et.alphaMapTransform)),
      pt.bumpMap &&
        ((Et.bumpMap.value = pt.bumpMap),
        nt(pt.bumpMap, Et.bumpMapTransform),
        (Et.bumpScale.value = pt.bumpScale),
        pt.side === BackSide && (Et.bumpScale.value *= -1)),
      pt.normalMap &&
        ((Et.normalMap.value = pt.normalMap),
        nt(pt.normalMap, Et.normalMapTransform),
        Et.normalScale.value.copy(pt.normalScale),
        pt.side === BackSide && Et.normalScale.value.negate()),
      pt.displacementMap &&
        ((Et.displacementMap.value = pt.displacementMap),
        nt(pt.displacementMap, Et.displacementMapTransform),
        (Et.displacementScale.value = pt.displacementScale),
        (Et.displacementBias.value = pt.displacementBias)),
      pt.emissiveMap &&
        ((Et.emissiveMap.value = pt.emissiveMap),
        nt(pt.emissiveMap, Et.emissiveMapTransform)),
      pt.specularMap &&
        ((Et.specularMap.value = pt.specularMap),
        nt(pt.specularMap, Et.specularMapTransform)),
      pt.alphaTest > 0 && (Et.alphaTest.value = pt.alphaTest);
    const xt = et.get(pt).envMap;
    if (
      (xt &&
        ((Et.envMap.value = xt),
        (Et.flipEnvMap.value =
          xt.isCubeTexture && xt.isRenderTargetTexture === !1 ? -1 : 1),
        (Et.reflectivity.value = pt.reflectivity),
        (Et.ior.value = pt.ior),
        (Et.refractionRatio.value = pt.refractionRatio)),
      pt.lightMap)
    ) {
      Et.lightMap.value = pt.lightMap;
      const St = tt._useLegacyLights === !0 ? Math.PI : 1;
      (Et.lightMapIntensity.value = pt.lightMapIntensity * St),
        nt(pt.lightMap, Et.lightMapTransform);
    }
    pt.aoMap &&
      ((Et.aoMap.value = pt.aoMap),
      (Et.aoMapIntensity.value = pt.aoMapIntensity),
      nt(pt.aoMap, Et.aoMapTransform));
  }
  function ot(Et, pt) {
    Et.diffuse.value.copy(pt.color),
      (Et.opacity.value = pt.opacity),
      pt.map && ((Et.map.value = pt.map), nt(pt.map, Et.mapTransform));
  }
  function at(Et, pt) {
    (Et.dashSize.value = pt.dashSize),
      (Et.totalSize.value = pt.dashSize + pt.gapSize),
      (Et.scale.value = pt.scale);
  }
  function lt(Et, pt, xt, St) {
    Et.diffuse.value.copy(pt.color),
      (Et.opacity.value = pt.opacity),
      (Et.size.value = pt.size * xt),
      (Et.scale.value = St * 0.5),
      pt.map && ((Et.map.value = pt.map), nt(pt.map, Et.uvTransform)),
      pt.alphaMap &&
        ((Et.alphaMap.value = pt.alphaMap),
        nt(pt.alphaMap, Et.alphaMapTransform)),
      pt.alphaTest > 0 && (Et.alphaTest.value = pt.alphaTest);
  }
  function ct(Et, pt) {
    Et.diffuse.value.copy(pt.color),
      (Et.opacity.value = pt.opacity),
      (Et.rotation.value = pt.rotation),
      pt.map && ((Et.map.value = pt.map), nt(pt.map, Et.mapTransform)),
      pt.alphaMap &&
        ((Et.alphaMap.value = pt.alphaMap),
        nt(pt.alphaMap, Et.alphaMapTransform)),
      pt.alphaTest > 0 && (Et.alphaTest.value = pt.alphaTest);
  }
  function ut(Et, pt) {
    Et.specular.value.copy(pt.specular),
      (Et.shininess.value = Math.max(pt.shininess, 1e-4));
  }
  function ft(Et, pt) {
    pt.gradientMap && (Et.gradientMap.value = pt.gradientMap);
  }
  function ht(Et, pt) {
    (Et.metalness.value = pt.metalness),
      pt.metalnessMap &&
        ((Et.metalnessMap.value = pt.metalnessMap),
        nt(pt.metalnessMap, Et.metalnessMapTransform)),
      (Et.roughness.value = pt.roughness),
      pt.roughnessMap &&
        ((Et.roughnessMap.value = pt.roughnessMap),
        nt(pt.roughnessMap, Et.roughnessMapTransform)),
      et.get(pt).envMap && (Et.envMapIntensity.value = pt.envMapIntensity);
  }
  function mt(Et, pt, xt) {
    (Et.ior.value = pt.ior),
      pt.sheen > 0 &&
        (Et.sheenColor.value.copy(pt.sheenColor).multiplyScalar(pt.sheen),
        (Et.sheenRoughness.value = pt.sheenRoughness),
        pt.sheenColorMap &&
          ((Et.sheenColorMap.value = pt.sheenColorMap),
          nt(pt.sheenColorMap, Et.sheenColorMapTransform)),
        pt.sheenRoughnessMap &&
          ((Et.sheenRoughnessMap.value = pt.sheenRoughnessMap),
          nt(pt.sheenRoughnessMap, Et.sheenRoughnessMapTransform))),
      pt.clearcoat > 0 &&
        ((Et.clearcoat.value = pt.clearcoat),
        (Et.clearcoatRoughness.value = pt.clearcoatRoughness),
        pt.clearcoatMap &&
          ((Et.clearcoatMap.value = pt.clearcoatMap),
          nt(pt.clearcoatMap, Et.clearcoatMapTransform)),
        pt.clearcoatRoughnessMap &&
          ((Et.clearcoatRoughnessMap.value = pt.clearcoatRoughnessMap),
          nt(pt.clearcoatRoughnessMap, Et.clearcoatRoughnessMapTransform)),
        pt.clearcoatNormalMap &&
          ((Et.clearcoatNormalMap.value = pt.clearcoatNormalMap),
          nt(pt.clearcoatNormalMap, Et.clearcoatNormalMapTransform),
          Et.clearcoatNormalScale.value.copy(pt.clearcoatNormalScale),
          pt.side === BackSide && Et.clearcoatNormalScale.value.negate())),
      pt.iridescence > 0 &&
        ((Et.iridescence.value = pt.iridescence),
        (Et.iridescenceIOR.value = pt.iridescenceIOR),
        (Et.iridescenceThicknessMinimum.value =
          pt.iridescenceThicknessRange[0]),
        (Et.iridescenceThicknessMaximum.value =
          pt.iridescenceThicknessRange[1]),
        pt.iridescenceMap &&
          ((Et.iridescenceMap.value = pt.iridescenceMap),
          nt(pt.iridescenceMap, Et.iridescenceMapTransform)),
        pt.iridescenceThicknessMap &&
          ((Et.iridescenceThicknessMap.value = pt.iridescenceThicknessMap),
          nt(pt.iridescenceThicknessMap, Et.iridescenceThicknessMapTransform))),
      pt.transmission > 0 &&
        ((Et.transmission.value = pt.transmission),
        (Et.transmissionSamplerMap.value = xt.texture),
        Et.transmissionSamplerSize.value.set(xt.width, xt.height),
        pt.transmissionMap &&
          ((Et.transmissionMap.value = pt.transmissionMap),
          nt(pt.transmissionMap, Et.transmissionMapTransform)),
        (Et.thickness.value = pt.thickness),
        pt.thicknessMap &&
          ((Et.thicknessMap.value = pt.thicknessMap),
          nt(pt.thicknessMap, Et.thicknessMapTransform)),
        (Et.attenuationDistance.value = pt.attenuationDistance),
        Et.attenuationColor.value.copy(pt.attenuationColor)),
      pt.anisotropy > 0 &&
        (Et.anisotropyVector.value.set(
          pt.anisotropy * Math.cos(pt.anisotropyRotation),
          pt.anisotropy * Math.sin(pt.anisotropyRotation)
        ),
        pt.anisotropyMap &&
          ((Et.anisotropyMap.value = pt.anisotropyMap),
          nt(pt.anisotropyMap, Et.anisotropyMapTransform))),
      (Et.specularIntensity.value = pt.specularIntensity),
      Et.specularColor.value.copy(pt.specularColor),
      pt.specularColorMap &&
        ((Et.specularColorMap.value = pt.specularColorMap),
        nt(pt.specularColorMap, Et.specularColorMapTransform)),
      pt.specularIntensityMap &&
        ((Et.specularIntensityMap.value = pt.specularIntensityMap),
        nt(pt.specularIntensityMap, Et.specularIntensityMapTransform));
  }
  function vt(Et, pt) {
    pt.matcap && (Et.matcap.value = pt.matcap);
  }
  function yt(Et, pt) {
    const xt = et.get(pt).light;
    Et.referencePosition.value.setFromMatrixPosition(xt.matrixWorld),
      (Et.nearDistance.value = xt.shadow.camera.near),
      (Et.farDistance.value = xt.shadow.camera.far);
  }
  return { refreshFogUniforms: rt, refreshMaterialUniforms: it };
}
function WebGLUniformsGroups(tt, et, nt, rt) {
  let it = {},
    st = {},
    ot = [];
  const at = nt.isWebGL2 ? tt.getParameter(tt.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function lt(xt, St) {
    const At = St.program;
    rt.uniformBlockBinding(xt, At);
  }
  function ct(xt, St) {
    let At = it[xt.id];
    At === void 0 &&
      (vt(xt),
      (At = ut(xt)),
      (it[xt.id] = At),
      xt.addEventListener("dispose", Et));
    const Ct = St.program;
    rt.updateUBOMapping(xt, Ct);
    const Mt = et.render.frame;
    st[xt.id] !== Mt && (ht(xt), (st[xt.id] = Mt));
  }
  function ut(xt) {
    const St = ft();
    xt.__bindingPointIndex = St;
    const At = tt.createBuffer(),
      Ct = xt.__size,
      Mt = xt.usage;
    return (
      tt.bindBuffer(tt.UNIFORM_BUFFER, At),
      tt.bufferData(tt.UNIFORM_BUFFER, Ct, Mt),
      tt.bindBuffer(tt.UNIFORM_BUFFER, null),
      tt.bindBufferBase(tt.UNIFORM_BUFFER, St, At),
      At
    );
  }
  function ft() {
    for (let xt = 0; xt < at; xt++)
      if (ot.indexOf(xt) === -1) return ot.push(xt), xt;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function ht(xt) {
    const St = it[xt.id],
      At = xt.uniforms,
      Ct = xt.__cache;
    tt.bindBuffer(tt.UNIFORM_BUFFER, St);
    for (let Mt = 0, wt = At.length; Mt < wt; Mt++) {
      const Bt = At[Mt];
      if (mt(Bt, Mt, Ct) === !0) {
        const It = Bt.__offset,
          Ft = Array.isArray(Bt.value) ? Bt.value : [Bt.value];
        let Vt = 0;
        for (let $t = 0; $t < Ft.length; $t++) {
          const Kt = Ft[$t],
            Ht = yt(Kt);
          typeof Kt == "number"
            ? ((Bt.__data[0] = Kt),
              tt.bufferSubData(tt.UNIFORM_BUFFER, It + Vt, Bt.__data))
            : Kt.isMatrix3
            ? ((Bt.__data[0] = Kt.elements[0]),
              (Bt.__data[1] = Kt.elements[1]),
              (Bt.__data[2] = Kt.elements[2]),
              (Bt.__data[3] = Kt.elements[0]),
              (Bt.__data[4] = Kt.elements[3]),
              (Bt.__data[5] = Kt.elements[4]),
              (Bt.__data[6] = Kt.elements[5]),
              (Bt.__data[7] = Kt.elements[0]),
              (Bt.__data[8] = Kt.elements[6]),
              (Bt.__data[9] = Kt.elements[7]),
              (Bt.__data[10] = Kt.elements[8]),
              (Bt.__data[11] = Kt.elements[0]))
            : (Kt.toArray(Bt.__data, Vt),
              (Vt += Ht.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        tt.bufferSubData(tt.UNIFORM_BUFFER, It, Bt.__data);
      }
    }
    tt.bindBuffer(tt.UNIFORM_BUFFER, null);
  }
  function mt(xt, St, At) {
    const Ct = xt.value;
    if (At[St] === void 0) {
      if (typeof Ct == "number") At[St] = Ct;
      else {
        const Mt = Array.isArray(Ct) ? Ct : [Ct],
          wt = [];
        for (let Bt = 0; Bt < Mt.length; Bt++) wt.push(Mt[Bt].clone());
        At[St] = wt;
      }
      return !0;
    } else if (typeof Ct == "number") {
      if (At[St] !== Ct) return (At[St] = Ct), !0;
    } else {
      const Mt = Array.isArray(At[St]) ? At[St] : [At[St]],
        wt = Array.isArray(Ct) ? Ct : [Ct];
      for (let Bt = 0; Bt < Mt.length; Bt++) {
        const It = Mt[Bt];
        if (It.equals(wt[Bt]) === !1) return It.copy(wt[Bt]), !0;
      }
    }
    return !1;
  }
  function vt(xt) {
    const St = xt.uniforms;
    let At = 0;
    const Ct = 16;
    let Mt = 0;
    for (let wt = 0, Bt = St.length; wt < Bt; wt++) {
      const It = St[wt],
        Ft = { boundary: 0, storage: 0 },
        Vt = Array.isArray(It.value) ? It.value : [It.value];
      for (let $t = 0, Kt = Vt.length; $t < Kt; $t++) {
        const Ht = Vt[$t],
          Wt = yt(Ht);
        (Ft.boundary += Wt.boundary), (Ft.storage += Wt.storage);
      }
      if (
        ((It.__data = new Float32Array(
          Ft.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (It.__offset = At),
        wt > 0)
      ) {
        Mt = At % Ct;
        const $t = Ct - Mt;
        Mt !== 0 &&
          $t - Ft.boundary < 0 &&
          ((At += Ct - Mt), (It.__offset = At));
      }
      At += Ft.storage;
    }
    return (
      (Mt = At % Ct),
      Mt > 0 && (At += Ct - Mt),
      (xt.__size = At),
      (xt.__cache = {}),
      this
    );
  }
  function yt(xt) {
    const St = { boundary: 0, storage: 0 };
    return (
      typeof xt == "number"
        ? ((St.boundary = 4), (St.storage = 4))
        : xt.isVector2
        ? ((St.boundary = 8), (St.storage = 8))
        : xt.isVector3 || xt.isColor
        ? ((St.boundary = 16), (St.storage = 12))
        : xt.isVector4
        ? ((St.boundary = 16), (St.storage = 16))
        : xt.isMatrix3
        ? ((St.boundary = 48), (St.storage = 48))
        : xt.isMatrix4
        ? ((St.boundary = 64), (St.storage = 64))
        : xt.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            xt
          ),
      St
    );
  }
  function Et(xt) {
    const St = xt.target;
    St.removeEventListener("dispose", Et);
    const At = ot.indexOf(St.__bindingPointIndex);
    ot.splice(At, 1),
      tt.deleteBuffer(it[St.id]),
      delete it[St.id],
      delete st[St.id];
  }
  function pt() {
    for (const xt in it) tt.deleteBuffer(it[xt]);
    (ot = []), (it = {}), (st = {});
  }
  return { bind: lt, update: ct, dispose: pt };
}
class WebGLRenderer {
  constructor(et = {}) {
    const {
      canvas: nt = createCanvasElement(),
      context: rt = null,
      depth: it = !0,
      stencil: st = !0,
      alpha: ot = !1,
      antialias: at = !1,
      premultipliedAlpha: lt = !0,
      preserveDrawingBuffer: ct = !1,
      powerPreference: ut = "default",
      failIfMajorPerformanceCaveat: ft = !1,
    } = et;
    this.isWebGLRenderer = !0;
    let ht;
    rt !== null ? (ht = rt.getContextAttributes().alpha) : (ht = ot);
    const mt = new Uint32Array(4),
      vt = new Int32Array(4);
    let yt = null,
      Et = null;
    const pt = [],
      xt = [];
    (this.domElement = nt),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = SRGBColorSpace),
      (this._useLegacyLights = !1),
      (this.toneMapping = NoToneMapping),
      (this.toneMappingExposure = 1);
    const St = this;
    let At = !1,
      Ct = 0,
      Mt = 0,
      wt = null,
      Bt = -1,
      It = null;
    const Ft = new Vector4(),
      Vt = new Vector4();
    let $t = null;
    const Kt = new Color(0);
    let Ht = 0,
      Wt = nt.width,
      kt = nt.height,
      Gt = 1,
      Pt = null,
      Rt = null;
    const Nt = new Vector4(0, 0, Wt, kt),
      Dt = new Vector4(0, 0, Wt, kt);
    let zt = !1;
    const Yt = new Frustum();
    let qt = !1,
      Zt = !1,
      Jt = null;
    const mn = new Matrix4(),
      ln = new Vector2(),
      bn = new Vector3(),
      Bn = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function gn() {
      return wt === null ? Gt : 1;
    }
    let jt = rt;
    function yn(sn, wn) {
      for (let Un = 0; Un < sn.length; Un++) {
        const Rn = sn[Un],
          Gn = nt.getContext(Rn, wn);
        if (Gn !== null) return Gn;
      }
      return null;
    }
    try {
      const sn = {
        alpha: !0,
        depth: it,
        stencil: st,
        antialias: at,
        premultipliedAlpha: lt,
        preserveDrawingBuffer: ct,
        powerPreference: ut,
        failIfMajorPerformanceCaveat: ft,
      };
      if (
        ("setAttribute" in nt &&
          nt.setAttribute("data-engine", `three.js r${REVISION}`),
        nt.addEventListener("webglcontextlost", zn, !1),
        nt.addEventListener("webglcontextrestored", Xn, !1),
        nt.addEventListener("webglcontextcreationerror", Qn, !1),
        jt === null)
      ) {
        const wn = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (St.isWebGL1Renderer === !0 && wn.shift(),
          (jt = yn(wn, sn)),
          jt === null)
        )
          throw yn(wn)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        jt instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        jt.getShaderPrecisionFormat === void 0 &&
          (jt.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (sn) {
      throw (console.error("THREE.WebGLRenderer: " + sn.message), sn);
    }
    let pn,
      vn,
      xn,
      Fn,
      _n,
      Dn,
      Tn,
      An,
      Wn,
      Xt,
      Ut,
      hn,
      Ln,
      Cn,
      Mn,
      kn,
      Vn,
      Kn,
      Yn,
      ir,
      On,
      qn,
      dn,
      Pn;
    function Hn() {
      (pn = new WebGLExtensions(jt)),
        (vn = new WebGLCapabilities(jt, pn, et)),
        pn.init(vn),
        (qn = new WebGLUtils(jt, pn, vn)),
        (xn = new WebGLState(jt, pn, vn)),
        (Fn = new WebGLInfo(jt)),
        (_n = new WebGLProperties()),
        (Dn = new WebGLTextures(jt, pn, xn, _n, vn, qn, Fn)),
        (Tn = new WebGLCubeMaps(St)),
        (An = new WebGLCubeUVMaps(St)),
        (Wn = new WebGLAttributes(jt, vn)),
        (dn = new WebGLBindingStates(jt, pn, Wn, vn)),
        (Xt = new WebGLGeometries(jt, Wn, Fn, dn)),
        (Ut = new WebGLObjects(jt, Xt, Wn, Fn)),
        (Yn = new WebGLMorphtargets(jt, vn, Dn)),
        (kn = new WebGLClipping(_n)),
        (hn = new WebGLPrograms(St, Tn, An, pn, vn, dn, kn)),
        (Ln = new WebGLMaterials(St, _n)),
        (Cn = new WebGLRenderLists()),
        (Mn = new WebGLRenderStates(pn, vn)),
        (Kn = new WebGLBackground(St, Tn, An, xn, Ut, ht, lt)),
        (Vn = new WebGLShadowMap(St, Ut, vn)),
        (Pn = new WebGLUniformsGroups(jt, Fn, vn, xn)),
        (ir = new WebGLBufferRenderer(jt, pn, Fn, vn)),
        (On = new WebGLIndexedBufferRenderer(jt, pn, Fn, vn)),
        (Fn.programs = hn.programs),
        (St.capabilities = vn),
        (St.extensions = pn),
        (St.properties = _n),
        (St.renderLists = Cn),
        (St.shadowMap = Vn),
        (St.state = xn),
        (St.info = Fn);
    }
    Hn();
    const Qt = new WebXRManager(St, jt);
    (this.xr = Qt),
      (this.getContext = function () {
        return jt;
      }),
      (this.getContextAttributes = function () {
        return jt.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const sn = pn.get("WEBGL_lose_context");
        sn && sn.loseContext();
      }),
      (this.forceContextRestore = function () {
        const sn = pn.get("WEBGL_lose_context");
        sn && sn.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Gt;
      }),
      (this.setPixelRatio = function (sn) {
        sn !== void 0 && ((Gt = sn), this.setSize(Wt, kt, !1));
      }),
      (this.getSize = function (sn) {
        return sn.set(Wt, kt);
      }),
      (this.setSize = function (sn, wn, Un = !0) {
        if (Qt.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Wt = sn),
          (kt = wn),
          (nt.width = Math.floor(sn * Gt)),
          (nt.height = Math.floor(wn * Gt)),
          Un === !0 &&
            ((nt.style.width = sn + "px"), (nt.style.height = wn + "px")),
          this.setViewport(0, 0, sn, wn);
      }),
      (this.getDrawingBufferSize = function (sn) {
        return sn.set(Wt * Gt, kt * Gt).floor();
      }),
      (this.setDrawingBufferSize = function (sn, wn, Un) {
        (Wt = sn),
          (kt = wn),
          (Gt = Un),
          (nt.width = Math.floor(sn * Un)),
          (nt.height = Math.floor(wn * Un)),
          this.setViewport(0, 0, sn, wn);
      }),
      (this.getCurrentViewport = function (sn) {
        return sn.copy(Ft);
      }),
      (this.getViewport = function (sn) {
        return sn.copy(Nt);
      }),
      (this.setViewport = function (sn, wn, Un, Rn) {
        sn.isVector4 ? Nt.set(sn.x, sn.y, sn.z, sn.w) : Nt.set(sn, wn, Un, Rn),
          xn.viewport(Ft.copy(Nt).multiplyScalar(Gt).floor());
      }),
      (this.getScissor = function (sn) {
        return sn.copy(Dt);
      }),
      (this.setScissor = function (sn, wn, Un, Rn) {
        sn.isVector4 ? Dt.set(sn.x, sn.y, sn.z, sn.w) : Dt.set(sn, wn, Un, Rn),
          xn.scissor(Vt.copy(Dt).multiplyScalar(Gt).floor());
      }),
      (this.getScissorTest = function () {
        return zt;
      }),
      (this.setScissorTest = function (sn) {
        xn.setScissorTest((zt = sn));
      }),
      (this.setOpaqueSort = function (sn) {
        Pt = sn;
      }),
      (this.setTransparentSort = function (sn) {
        Rt = sn;
      }),
      (this.getClearColor = function (sn) {
        return sn.copy(Kn.getClearColor());
      }),
      (this.setClearColor = function () {
        Kn.setClearColor.apply(Kn, arguments);
      }),
      (this.getClearAlpha = function () {
        return Kn.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Kn.setClearAlpha.apply(Kn, arguments);
      }),
      (this.clear = function (sn = !0, wn = !0, Un = !0) {
        let Rn = 0;
        if (sn) {
          let Gn = !1;
          if (wt !== null) {
            const ar = wt.texture.format;
            Gn =
              ar === RGBAIntegerFormat ||
              ar === RGIntegerFormat ||
              ar === RedIntegerFormat;
          }
          if (Gn) {
            const ar = wt.texture.type,
              fr =
                ar === UnsignedByteType ||
                ar === UnsignedIntType ||
                ar === UnsignedShortType ||
                ar === UnsignedInt248Type ||
                ar === UnsignedShort4444Type ||
                ar === UnsignedShort5551Type,
              Zn = Kn.getClearColor(),
              lr = Kn.getClearAlpha(),
              xr = Zn.r,
              Jn = Zn.g,
              dr = Zn.b;
            fr
              ? ((mt[0] = xr),
                (mt[1] = Jn),
                (mt[2] = dr),
                (mt[3] = lr),
                jt.clearBufferuiv(jt.COLOR, 0, mt))
              : ((vt[0] = xr),
                (vt[1] = Jn),
                (vt[2] = dr),
                (vt[3] = lr),
                jt.clearBufferiv(jt.COLOR, 0, vt));
          } else Rn |= jt.COLOR_BUFFER_BIT;
        }
        wn && (Rn |= jt.DEPTH_BUFFER_BIT),
          Un && (Rn |= jt.STENCIL_BUFFER_BIT),
          jt.clear(Rn);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        nt.removeEventListener("webglcontextlost", zn, !1),
          nt.removeEventListener("webglcontextrestored", Xn, !1),
          nt.removeEventListener("webglcontextcreationerror", Qn, !1),
          Cn.dispose(),
          Mn.dispose(),
          _n.dispose(),
          Tn.dispose(),
          An.dispose(),
          Ut.dispose(),
          dn.dispose(),
          Pn.dispose(),
          hn.dispose(),
          Qt.dispose(),
          Qt.removeEventListener("sessionstart", Ar),
          Qt.removeEventListener("sessionend", _r),
          Jt && (Jt.dispose(), (Jt = null)),
          yr.stop();
      });
    function zn(sn) {
      sn.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (At = !0);
    }
    function Xn() {
      console.log("THREE.WebGLRenderer: Context Restored."), (At = !1);
      const sn = Fn.autoReset,
        wn = Vn.enabled,
        Un = Vn.autoUpdate,
        Rn = Vn.needsUpdate,
        Gn = Vn.type;
      Hn(),
        (Fn.autoReset = sn),
        (Vn.enabled = wn),
        (Vn.autoUpdate = Un),
        (Vn.needsUpdate = Rn),
        (Vn.type = Gn);
    }
    function Qn(sn) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        sn.statusMessage
      );
    }
    function tr(sn) {
      const wn = sn.target;
      wn.removeEventListener("dispose", tr), jn(wn);
    }
    function jn(sn) {
      nr(sn), _n.remove(sn);
    }
    function nr(sn) {
      const wn = _n.get(sn).programs;
      wn !== void 0 &&
        (wn.forEach(function (Un) {
          hn.releaseProgram(Un);
        }),
        sn.isShaderMaterial && hn.releaseShaderCache(sn));
    }
    (this.renderBufferDirect = function (sn, wn, Un, Rn, Gn, ar) {
      wn === null && (wn = Bn);
      const fr = Gn.isMesh && Gn.matrixWorld.determinant() < 0,
        Zn = $r(sn, wn, Un, Rn, Gn);
      xn.setMaterial(Rn, fr);
      let lr = Un.index,
        xr = 1;
      if (Rn.wireframe === !0) {
        if (((lr = Xt.getWireframeAttribute(Un)), lr === void 0)) return;
        xr = 2;
      }
      const Jn = Un.drawRange,
        dr = Un.attributes.position;
      let kr = Jn.start * xr,
        Rr = (Jn.start + Jn.count) * xr;
      ar !== null &&
        ((kr = Math.max(kr, ar.start * xr)),
        (Rr = Math.min(Rr, (ar.start + ar.count) * xr))),
        lr !== null
          ? ((kr = Math.max(kr, 0)), (Rr = Math.min(Rr, lr.count)))
          : dr != null &&
            ((kr = Math.max(kr, 0)), (Rr = Math.min(Rr, dr.count)));
      const ns = Rr - kr;
      if (ns < 0 || ns === 1 / 0) return;
      dn.setup(Gn, Rn, Zn, Un, lr);
      let hs,
        Lr = ir;
      if (
        (lr !== null && ((hs = Wn.get(lr)), (Lr = On), Lr.setIndex(hs)),
        Gn.isMesh)
      )
        Rn.wireframe === !0
          ? (xn.setLineWidth(Rn.wireframeLinewidth * gn()),
            Lr.setMode(jt.LINES))
          : Lr.setMode(jt.TRIANGLES);
      else if (Gn.isLine) {
        let mr = Rn.linewidth;
        mr === void 0 && (mr = 1),
          xn.setLineWidth(mr * gn()),
          Gn.isLineSegments
            ? Lr.setMode(jt.LINES)
            : Gn.isLineLoop
            ? Lr.setMode(jt.LINE_LOOP)
            : Lr.setMode(jt.LINE_STRIP);
      } else
        Gn.isPoints
          ? Lr.setMode(jt.POINTS)
          : Gn.isSprite && Lr.setMode(jt.TRIANGLES);
      if (Gn.isInstancedMesh) Lr.renderInstances(kr, ns, Gn.count);
      else if (Un.isInstancedBufferGeometry) {
        const mr =
            Un._maxInstanceCount !== void 0 ? Un._maxInstanceCount : 1 / 0,
          wr = Math.min(Un.instanceCount, mr);
        Lr.renderInstances(kr, ns, wr);
      } else Lr.render(kr, ns);
    }),
      (this.compile = function (sn, wn) {
        function Un(Rn, Gn, ar) {
          Rn.transparent === !0 &&
          Rn.side === DoubleSide &&
          Rn.forceSinglePass === !1
            ? ((Rn.side = BackSide),
              (Rn.needsUpdate = !0),
              Pr(Rn, Gn, ar),
              (Rn.side = FrontSide),
              (Rn.needsUpdate = !0),
              Pr(Rn, Gn, ar),
              (Rn.side = DoubleSide))
            : Pr(Rn, Gn, ar);
        }
        (Et = Mn.get(sn)),
          Et.init(),
          xt.push(Et),
          sn.traverseVisible(function (Rn) {
            Rn.isLight &&
              Rn.layers.test(wn.layers) &&
              (Et.pushLight(Rn), Rn.castShadow && Et.pushShadow(Rn));
          }),
          Et.setupLights(St._useLegacyLights),
          sn.traverse(function (Rn) {
            const Gn = Rn.material;
            if (Gn)
              if (Array.isArray(Gn))
                for (let ar = 0; ar < Gn.length; ar++) {
                  const fr = Gn[ar];
                  Un(fr, sn, Rn);
                }
              else Un(Gn, sn, Rn);
          }),
          xt.pop(),
          (Et = null);
      });
    let or = null;
    function vr(sn) {
      or && or(sn);
    }
    function Ar() {
      yr.stop();
    }
    function _r() {
      yr.start();
    }
    const yr = new WebGLAnimation();
    yr.setAnimationLoop(vr),
      typeof self < "u" && yr.setContext(self),
      (this.setAnimationLoop = function (sn) {
        (or = sn),
          Qt.setAnimationLoop(sn),
          sn === null ? yr.stop() : yr.start();
      }),
      Qt.addEventListener("sessionstart", Ar),
      Qt.addEventListener("sessionend", _r),
      (this.render = function (sn, wn) {
        if (wn !== void 0 && wn.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (At === !0) return;
        sn.matrixWorldAutoUpdate === !0 && sn.updateMatrixWorld(),
          wn.parent === null &&
            wn.matrixWorldAutoUpdate === !0 &&
            wn.updateMatrixWorld(),
          Qt.enabled === !0 &&
            Qt.isPresenting === !0 &&
            (Qt.cameraAutoUpdate === !0 && Qt.updateCamera(wn),
            (wn = Qt.getCamera())),
          sn.isScene === !0 && sn.onBeforeRender(St, sn, wn, wt),
          (Et = Mn.get(sn, xt.length)),
          Et.init(),
          xt.push(Et),
          mn.multiplyMatrices(wn.projectionMatrix, wn.matrixWorldInverse),
          Yt.setFromProjectionMatrix(mn),
          (Zt = this.localClippingEnabled),
          (qt = kn.init(this.clippingPlanes, Zt)),
          (yt = Cn.get(sn, pt.length)),
          yt.init(),
          pt.push(yt),
          Qr(sn, wn, 0, St.sortObjects),
          yt.finish(),
          St.sortObjects === !0 && yt.sort(Pt, Rt),
          this.info.render.frame++,
          qt === !0 && kn.beginShadows();
        const Un = Et.state.shadowsArray;
        if (
          (Vn.render(Un, sn, wn),
          qt === !0 && kn.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Kn.render(yt, sn),
          Et.setupLights(St._useLegacyLights),
          wn.isArrayCamera)
        ) {
          const Rn = wn.cameras;
          for (let Gn = 0, ar = Rn.length; Gn < ar; Gn++) {
            const fr = Rn[Gn];
            Zr(yt, sn, fr, fr.viewport);
          }
        } else Zr(yt, sn, wn);
        wt !== null &&
          (Dn.updateMultisampleRenderTarget(wt),
          Dn.updateRenderTargetMipmap(wt)),
          sn.isScene === !0 && sn.onAfterRender(St, sn, wn),
          dn.resetDefaultState(),
          (Bt = -1),
          (It = null),
          xt.pop(),
          xt.length > 0 ? (Et = xt[xt.length - 1]) : (Et = null),
          pt.pop(),
          pt.length > 0 ? (yt = pt[pt.length - 1]) : (yt = null);
      });
    function Qr(sn, wn, Un, Rn) {
      if (sn.visible === !1) return;
      if (sn.layers.test(wn.layers)) {
        if (sn.isGroup) Un = sn.renderOrder;
        else if (sn.isLOD) sn.autoUpdate === !0 && sn.update(wn);
        else if (sn.isLight)
          Et.pushLight(sn), sn.castShadow && Et.pushShadow(sn);
        else if (sn.isSprite) {
          if (!sn.frustumCulled || Yt.intersectsSprite(sn)) {
            Rn && bn.setFromMatrixPosition(sn.matrixWorld).applyMatrix4(mn);
            const fr = Ut.update(sn),
              Zn = sn.material;
            Zn.visible && yt.push(sn, fr, Zn, Un, bn.z, null);
          }
        } else if (
          (sn.isMesh || sn.isLine || sn.isPoints) &&
          (!sn.frustumCulled || Yt.intersectsObject(sn))
        ) {
          const fr = Ut.update(sn),
            Zn = sn.material;
          if (
            (Rn &&
              (sn.boundingSphere !== void 0
                ? (sn.boundingSphere === null && sn.computeBoundingSphere(),
                  bn.copy(sn.boundingSphere.center))
                : (fr.boundingSphere === null && fr.computeBoundingSphere(),
                  bn.copy(fr.boundingSphere.center)),
              bn.applyMatrix4(sn.matrixWorld).applyMatrix4(mn)),
            Array.isArray(Zn))
          ) {
            const lr = fr.groups;
            for (let xr = 0, Jn = lr.length; xr < Jn; xr++) {
              const dr = lr[xr],
                kr = Zn[dr.materialIndex];
              kr && kr.visible && yt.push(sn, fr, kr, Un, bn.z, dr);
            }
          } else Zn.visible && yt.push(sn, fr, Zn, Un, bn.z, null);
        }
      }
      const ar = sn.children;
      for (let fr = 0, Zn = ar.length; fr < Zn; fr++) Qr(ar[fr], wn, Un, Rn);
    }
    function Zr(sn, wn, Un, Rn) {
      const Gn = sn.opaque,
        ar = sn.transmissive,
        fr = sn.transparent;
      Et.setupLightsView(Un),
        qt === !0 && kn.setGlobalState(St.clippingPlanes, Un),
        ar.length > 0 && Mr(Gn, ar, wn, Un),
        Rn && xn.viewport(Ft.copy(Rn)),
        Gn.length > 0 && Fr(Gn, wn, Un),
        ar.length > 0 && Fr(ar, wn, Un),
        fr.length > 0 && Fr(fr, wn, Un),
        xn.buffers.depth.setTest(!0),
        xn.buffers.depth.setMask(!0),
        xn.buffers.color.setMask(!0),
        xn.setPolygonOffset(!1);
    }
    function Mr(sn, wn, Un, Rn) {
      const Gn = vn.isWebGL2;
      Jt === null &&
        (Jt = new WebGLRenderTarget(1, 1, {
          generateMipmaps: !0,
          type: pn.has("EXT_color_buffer_half_float")
            ? HalfFloatType
            : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: Gn ? 4 : 0,
        })),
        St.getDrawingBufferSize(ln),
        Gn
          ? Jt.setSize(ln.x, ln.y)
          : Jt.setSize(floorPowerOfTwo(ln.x), floorPowerOfTwo(ln.y));
      const ar = St.getRenderTarget();
      St.setRenderTarget(Jt),
        St.getClearColor(Kt),
        (Ht = St.getClearAlpha()),
        Ht < 1 && St.setClearColor(16777215, 0.5),
        St.clear();
      const fr = St.toneMapping;
      (St.toneMapping = NoToneMapping),
        Fr(sn, Un, Rn),
        Dn.updateMultisampleRenderTarget(Jt),
        Dn.updateRenderTargetMipmap(Jt);
      let Zn = !1;
      for (let lr = 0, xr = wn.length; lr < xr; lr++) {
        const Jn = wn[lr],
          dr = Jn.object,
          kr = Jn.geometry,
          Rr = Jn.material,
          ns = Jn.group;
        if (Rr.side === DoubleSide && dr.layers.test(Rn.layers)) {
          const hs = Rr.side;
          (Rr.side = BackSide),
            (Rr.needsUpdate = !0),
            Dr(dr, Un, Rn, kr, Rr, ns),
            (Rr.side = hs),
            (Rr.needsUpdate = !0),
            (Zn = !0);
        }
      }
      Zn === !0 &&
        (Dn.updateMultisampleRenderTarget(Jt), Dn.updateRenderTargetMipmap(Jt)),
        St.setRenderTarget(ar),
        St.setClearColor(Kt, Ht),
        (St.toneMapping = fr);
    }
    function Fr(sn, wn, Un) {
      const Rn = wn.isScene === !0 ? wn.overrideMaterial : null;
      for (let Gn = 0, ar = sn.length; Gn < ar; Gn++) {
        const fr = sn[Gn],
          Zn = fr.object,
          lr = fr.geometry,
          xr = Rn === null ? fr.material : Rn,
          Jn = fr.group;
        Zn.layers.test(Un.layers) && Dr(Zn, wn, Un, lr, xr, Jn);
      }
    }
    function Dr(sn, wn, Un, Rn, Gn, ar) {
      sn.onBeforeRender(St, wn, Un, Rn, Gn, ar),
        sn.modelViewMatrix.multiplyMatrices(
          Un.matrixWorldInverse,
          sn.matrixWorld
        ),
        sn.normalMatrix.getNormalMatrix(sn.modelViewMatrix),
        Gn.onBeforeRender(St, wn, Un, Rn, sn, ar),
        Gn.transparent === !0 &&
        Gn.side === DoubleSide &&
        Gn.forceSinglePass === !1
          ? ((Gn.side = BackSide),
            (Gn.needsUpdate = !0),
            St.renderBufferDirect(Un, wn, Rn, Gn, sn, ar),
            (Gn.side = FrontSide),
            (Gn.needsUpdate = !0),
            St.renderBufferDirect(Un, wn, Rn, Gn, sn, ar),
            (Gn.side = DoubleSide))
          : St.renderBufferDirect(Un, wn, Rn, Gn, sn, ar),
        sn.onAfterRender(St, wn, Un, Rn, Gn, ar);
    }
    function Pr(sn, wn, Un) {
      wn.isScene !== !0 && (wn = Bn);
      const Rn = _n.get(sn),
        Gn = Et.state.lights,
        ar = Et.state.shadowsArray,
        fr = Gn.state.version,
        Zn = hn.getParameters(sn, Gn.state, ar, wn, Un),
        lr = hn.getProgramCacheKey(Zn);
      let xr = Rn.programs;
      (Rn.environment = sn.isMeshStandardMaterial ? wn.environment : null),
        (Rn.fog = wn.fog),
        (Rn.envMap = (sn.isMeshStandardMaterial ? An : Tn).get(
          sn.envMap || Rn.environment
        )),
        xr === void 0 &&
          (sn.addEventListener("dispose", tr),
          (xr = new Map()),
          (Rn.programs = xr));
      let Jn = xr.get(lr);
      if (Jn !== void 0) {
        if (Rn.currentProgram === Jn && Rn.lightsStateVersion === fr)
          return Gr(sn, Zn), Jn;
      } else
        (Zn.uniforms = hn.getUniforms(sn)),
          sn.onBuild(Un, Zn, St),
          sn.onBeforeCompile(Zn, St),
          (Jn = hn.acquireProgram(Zn, lr)),
          xr.set(lr, Jn),
          (Rn.uniforms = Zn.uniforms);
      const dr = Rn.uniforms;
      ((!sn.isShaderMaterial && !sn.isRawShaderMaterial) ||
        sn.clipping === !0) &&
        (dr.clippingPlanes = kn.uniform),
        Gr(sn, Zn),
        (Rn.needsLights = ss(sn)),
        (Rn.lightsStateVersion = fr),
        Rn.needsLights &&
          ((dr.ambientLightColor.value = Gn.state.ambient),
          (dr.lightProbe.value = Gn.state.probe),
          (dr.directionalLights.value = Gn.state.directional),
          (dr.directionalLightShadows.value = Gn.state.directionalShadow),
          (dr.spotLights.value = Gn.state.spot),
          (dr.spotLightShadows.value = Gn.state.spotShadow),
          (dr.rectAreaLights.value = Gn.state.rectArea),
          (dr.ltc_1.value = Gn.state.rectAreaLTC1),
          (dr.ltc_2.value = Gn.state.rectAreaLTC2),
          (dr.pointLights.value = Gn.state.point),
          (dr.pointLightShadows.value = Gn.state.pointShadow),
          (dr.hemisphereLights.value = Gn.state.hemi),
          (dr.directionalShadowMap.value = Gn.state.directionalShadowMap),
          (dr.directionalShadowMatrix.value = Gn.state.directionalShadowMatrix),
          (dr.spotShadowMap.value = Gn.state.spotShadowMap),
          (dr.spotLightMatrix.value = Gn.state.spotLightMatrix),
          (dr.spotLightMap.value = Gn.state.spotLightMap),
          (dr.pointShadowMap.value = Gn.state.pointShadowMap),
          (dr.pointShadowMatrix.value = Gn.state.pointShadowMatrix));
      const kr = Jn.getUniforms(),
        Rr = WebGLUniforms.seqWithValue(kr.seq, dr);
      return (Rn.currentProgram = Jn), (Rn.uniformsList = Rr), Jn;
    }
    function Gr(sn, wn) {
      const Un = _n.get(sn);
      (Un.outputColorSpace = wn.outputColorSpace),
        (Un.instancing = wn.instancing),
        (Un.instancingColor = wn.instancingColor),
        (Un.skinning = wn.skinning),
        (Un.morphTargets = wn.morphTargets),
        (Un.morphNormals = wn.morphNormals),
        (Un.morphColors = wn.morphColors),
        (Un.morphTargetsCount = wn.morphTargetsCount),
        (Un.numClippingPlanes = wn.numClippingPlanes),
        (Un.numIntersection = wn.numClipIntersection),
        (Un.vertexAlphas = wn.vertexAlphas),
        (Un.vertexTangents = wn.vertexTangents),
        (Un.toneMapping = wn.toneMapping);
    }
    function $r(sn, wn, Un, Rn, Gn) {
      wn.isScene !== !0 && (wn = Bn), Dn.resetTextureUnits();
      const ar = wn.fog,
        fr = Rn.isMeshStandardMaterial ? wn.environment : null,
        Zn =
          wt === null
            ? St.outputColorSpace
            : wt.isXRRenderTarget === !0
            ? wt.texture.colorSpace
            : LinearSRGBColorSpace,
        lr = (Rn.isMeshStandardMaterial ? An : Tn).get(Rn.envMap || fr),
        xr =
          Rn.vertexColors === !0 &&
          !!Un.attributes.color &&
          Un.attributes.color.itemSize === 4,
        Jn = !!Un.attributes.tangent && (!!Rn.normalMap || Rn.anisotropy > 0),
        dr = !!Un.morphAttributes.position,
        kr = !!Un.morphAttributes.normal,
        Rr = !!Un.morphAttributes.color;
      let ns = NoToneMapping;
      Rn.toneMapped &&
        (wt === null || wt.isXRRenderTarget === !0) &&
        (ns = St.toneMapping);
      const hs =
          Un.morphAttributes.position ||
          Un.morphAttributes.normal ||
          Un.morphAttributes.color,
        Lr = hs !== void 0 ? hs.length : 0,
        mr = _n.get(Rn),
        wr = Et.state.lights;
      if (qt === !0 && (Zt === !0 || sn !== It)) {
        const _i = sn === It && Rn.id === Bt;
        kn.setState(Rn, sn, _i);
      }
      let gr = !1;
      Rn.version === mr.__version
        ? ((mr.needsLights && mr.lightsStateVersion !== wr.state.version) ||
            mr.outputColorSpace !== Zn ||
            (Gn.isInstancedMesh && mr.instancing === !1) ||
            (!Gn.isInstancedMesh && mr.instancing === !0) ||
            (Gn.isSkinnedMesh && mr.skinning === !1) ||
            (!Gn.isSkinnedMesh && mr.skinning === !0) ||
            (Gn.isInstancedMesh &&
              mr.instancingColor === !0 &&
              Gn.instanceColor === null) ||
            (Gn.isInstancedMesh &&
              mr.instancingColor === !1 &&
              Gn.instanceColor !== null) ||
            mr.envMap !== lr ||
            (Rn.fog === !0 && mr.fog !== ar) ||
            (mr.numClippingPlanes !== void 0 &&
              (mr.numClippingPlanes !== kn.numPlanes ||
                mr.numIntersection !== kn.numIntersection)) ||
            mr.vertexAlphas !== xr ||
            mr.vertexTangents !== Jn ||
            mr.morphTargets !== dr ||
            mr.morphNormals !== kr ||
            mr.morphColors !== Rr ||
            mr.toneMapping !== ns ||
            (vn.isWebGL2 === !0 && mr.morphTargetsCount !== Lr)) &&
          (gr = !0)
        : ((gr = !0), (mr.__version = Rn.version));
      let Kr = mr.currentProgram;
      gr === !0 && (Kr = Pr(Rn, wn, Gn));
      let jr = !1,
        Vr = !1,
        Cs = !1;
      const Or = Kr.getUniforms(),
        Ur = mr.uniforms;
      if (
        (xn.useProgram(Kr.program) && ((jr = !0), (Vr = !0), (Cs = !0)),
        Rn.id !== Bt && ((Bt = Rn.id), (Vr = !0)),
        jr || It !== sn)
      ) {
        Or.setValue(jt, "projectionMatrix", sn.projectionMatrix),
          Or.setValue(jt, "viewMatrix", sn.matrixWorldInverse);
        const _i = Or.map.cameraPosition;
        _i !== void 0 &&
          _i.setValue(jt, bn.setFromMatrixPosition(sn.matrixWorld)),
          vn.logarithmicDepthBuffer &&
            Or.setValue(
              jt,
              "logDepthBufFC",
              2 / (Math.log(sn.far + 1) / Math.LN2)
            ),
          (Rn.isMeshPhongMaterial ||
            Rn.isMeshToonMaterial ||
            Rn.isMeshLambertMaterial ||
            Rn.isMeshBasicMaterial ||
            Rn.isMeshStandardMaterial ||
            Rn.isShaderMaterial) &&
            Or.setValue(jt, "isOrthographic", sn.isOrthographicCamera === !0),
          It !== sn && ((It = sn), (Vr = !0), (Cs = !0));
      }
      if (Gn.isSkinnedMesh) {
        Or.setOptional(jt, Gn, "bindMatrix"),
          Or.setOptional(jt, Gn, "bindMatrixInverse");
        const _i = Gn.skeleton;
        _i &&
          (vn.floatVertexTextures
            ? (_i.boneTexture === null && _i.computeBoneTexture(),
              Or.setValue(jt, "boneTexture", _i.boneTexture, Dn),
              Or.setValue(jt, "boneTextureSize", _i.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const ys = Un.morphAttributes;
      if (
        ((ys.position !== void 0 ||
          ys.normal !== void 0 ||
          (ys.color !== void 0 && vn.isWebGL2 === !0)) &&
          Yn.update(Gn, Un, Kr),
        (Vr || mr.receiveShadow !== Gn.receiveShadow) &&
          ((mr.receiveShadow = Gn.receiveShadow),
          Or.setValue(jt, "receiveShadow", Gn.receiveShadow)),
        Rn.isMeshGouraudMaterial &&
          Rn.envMap !== null &&
          ((Ur.envMap.value = lr),
          (Ur.flipEnvMap.value =
            lr.isCubeTexture && lr.isRenderTargetTexture === !1 ? -1 : 1)),
        Vr &&
          (Or.setValue(jt, "toneMappingExposure", St.toneMappingExposure),
          mr.needsLights && fs(Ur, Cs),
          ar && Rn.fog === !0 && Ln.refreshFogUniforms(Ur, ar),
          Ln.refreshMaterialUniforms(Ur, Rn, Gt, kt, Jt),
          WebGLUniforms.upload(jt, mr.uniformsList, Ur, Dn)),
        Rn.isShaderMaterial &&
          Rn.uniformsNeedUpdate === !0 &&
          (WebGLUniforms.upload(jt, mr.uniformsList, Ur, Dn),
          (Rn.uniformsNeedUpdate = !1)),
        Rn.isSpriteMaterial && Or.setValue(jt, "center", Gn.center),
        Or.setValue(jt, "modelViewMatrix", Gn.modelViewMatrix),
        Or.setValue(jt, "normalMatrix", Gn.normalMatrix),
        Or.setValue(jt, "modelMatrix", Gn.matrixWorld),
        Rn.isShaderMaterial || Rn.isRawShaderMaterial)
      ) {
        const _i = Rn.uniformsGroups;
        for (let Ks = 0, Js = _i.length; Ks < Js; Ks++)
          if (vn.isWebGL2) {
            const ds = _i[Ks];
            Pn.update(ds, Kr), Pn.bind(ds, Kr);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return Kr;
    }
    function fs(sn, wn) {
      (sn.ambientLightColor.needsUpdate = wn),
        (sn.lightProbe.needsUpdate = wn),
        (sn.directionalLights.needsUpdate = wn),
        (sn.directionalLightShadows.needsUpdate = wn),
        (sn.pointLights.needsUpdate = wn),
        (sn.pointLightShadows.needsUpdate = wn),
        (sn.spotLights.needsUpdate = wn),
        (sn.spotLightShadows.needsUpdate = wn),
        (sn.rectAreaLights.needsUpdate = wn),
        (sn.hemisphereLights.needsUpdate = wn);
    }
    function ss(sn) {
      return (
        sn.isMeshLambertMaterial ||
        sn.isMeshToonMaterial ||
        sn.isMeshPhongMaterial ||
        sn.isMeshStandardMaterial ||
        sn.isShadowMaterial ||
        (sn.isShaderMaterial && sn.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return Ct;
    }),
      (this.getActiveMipmapLevel = function () {
        return Mt;
      }),
      (this.getRenderTarget = function () {
        return wt;
      }),
      (this.setRenderTargetTextures = function (sn, wn, Un) {
        (_n.get(sn.texture).__webglTexture = wn),
          (_n.get(sn.depthTexture).__webglTexture = Un);
        const Rn = _n.get(sn);
        (Rn.__hasExternalTextures = !0),
          Rn.__hasExternalTextures &&
            ((Rn.__autoAllocateDepthBuffer = Un === void 0),
            Rn.__autoAllocateDepthBuffer ||
              (pn.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (Rn.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (sn, wn) {
        const Un = _n.get(sn);
        (Un.__webglFramebuffer = wn),
          (Un.__useDefaultFramebuffer = wn === void 0);
      }),
      (this.setRenderTarget = function (sn, wn = 0, Un = 0) {
        (wt = sn), (Ct = wn), (Mt = Un);
        let Rn = !0,
          Gn = null,
          ar = !1,
          fr = !1;
        if (sn) {
          const lr = _n.get(sn);
          lr.__useDefaultFramebuffer !== void 0
            ? (xn.bindFramebuffer(jt.FRAMEBUFFER, null), (Rn = !1))
            : lr.__webglFramebuffer === void 0
            ? Dn.setupRenderTarget(sn)
            : lr.__hasExternalTextures &&
              Dn.rebindTextures(
                sn,
                _n.get(sn.texture).__webglTexture,
                _n.get(sn.depthTexture).__webglTexture
              );
          const xr = sn.texture;
          (xr.isData3DTexture ||
            xr.isDataArrayTexture ||
            xr.isCompressedArrayTexture) &&
            (fr = !0);
          const Jn = _n.get(sn).__webglFramebuffer;
          sn.isWebGLCubeRenderTarget
            ? (Array.isArray(Jn[wn]) ? (Gn = Jn[wn][Un]) : (Gn = Jn[wn]),
              (ar = !0))
            : vn.isWebGL2 && sn.samples > 0 && Dn.useMultisampledRTT(sn) === !1
            ? (Gn = _n.get(sn).__webglMultisampledFramebuffer)
            : Array.isArray(Jn)
            ? (Gn = Jn[Un])
            : (Gn = Jn),
            Ft.copy(sn.viewport),
            Vt.copy(sn.scissor),
            ($t = sn.scissorTest);
        } else
          Ft.copy(Nt).multiplyScalar(Gt).floor(),
            Vt.copy(Dt).multiplyScalar(Gt).floor(),
            ($t = zt);
        if (
          (xn.bindFramebuffer(jt.FRAMEBUFFER, Gn) &&
            vn.drawBuffers &&
            Rn &&
            xn.drawBuffers(sn, Gn),
          xn.viewport(Ft),
          xn.scissor(Vt),
          xn.setScissorTest($t),
          ar)
        ) {
          const lr = _n.get(sn.texture);
          jt.framebufferTexture2D(
            jt.FRAMEBUFFER,
            jt.COLOR_ATTACHMENT0,
            jt.TEXTURE_CUBE_MAP_POSITIVE_X + wn,
            lr.__webglTexture,
            Un
          );
        } else if (fr) {
          const lr = _n.get(sn.texture),
            xr = wn || 0;
          jt.framebufferTextureLayer(
            jt.FRAMEBUFFER,
            jt.COLOR_ATTACHMENT0,
            lr.__webglTexture,
            Un || 0,
            xr
          );
        }
        Bt = -1;
      }),
      (this.readRenderTargetPixels = function (sn, wn, Un, Rn, Gn, ar, fr) {
        if (!(sn && sn.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Zn = _n.get(sn).__webglFramebuffer;
        if (
          (sn.isWebGLCubeRenderTarget && fr !== void 0 && (Zn = Zn[fr]), Zn)
        ) {
          xn.bindFramebuffer(jt.FRAMEBUFFER, Zn);
          try {
            const lr = sn.texture,
              xr = lr.format,
              Jn = lr.type;
            if (
              xr !== RGBAFormat &&
              qn.convert(xr) !==
                jt.getParameter(jt.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const dr =
              Jn === HalfFloatType &&
              (pn.has("EXT_color_buffer_half_float") ||
                (vn.isWebGL2 && pn.has("EXT_color_buffer_float")));
            if (
              Jn !== UnsignedByteType &&
              qn.convert(Jn) !==
                jt.getParameter(jt.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Jn === FloatType &&
                (vn.isWebGL2 ||
                  pn.has("OES_texture_float") ||
                  pn.has("WEBGL_color_buffer_float"))
              ) &&
              !dr
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            wn >= 0 &&
              wn <= sn.width - Rn &&
              Un >= 0 &&
              Un <= sn.height - Gn &&
              jt.readPixels(wn, Un, Rn, Gn, qn.convert(xr), qn.convert(Jn), ar);
          } finally {
            const lr = wt !== null ? _n.get(wt).__webglFramebuffer : null;
            xn.bindFramebuffer(jt.FRAMEBUFFER, lr);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (sn, wn, Un = 0) {
        const Rn = Math.pow(2, -Un),
          Gn = Math.floor(wn.image.width * Rn),
          ar = Math.floor(wn.image.height * Rn);
        Dn.setTexture2D(wn, 0),
          jt.copyTexSubImage2D(jt.TEXTURE_2D, Un, 0, 0, sn.x, sn.y, Gn, ar),
          xn.unbindTexture();
      }),
      (this.copyTextureToTexture = function (sn, wn, Un, Rn = 0) {
        const Gn = wn.image.width,
          ar = wn.image.height,
          fr = qn.convert(Un.format),
          Zn = qn.convert(Un.type);
        Dn.setTexture2D(Un, 0),
          jt.pixelStorei(jt.UNPACK_FLIP_Y_WEBGL, Un.flipY),
          jt.pixelStorei(
            jt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Un.premultiplyAlpha
          ),
          jt.pixelStorei(jt.UNPACK_ALIGNMENT, Un.unpackAlignment),
          wn.isDataTexture
            ? jt.texSubImage2D(
                jt.TEXTURE_2D,
                Rn,
                sn.x,
                sn.y,
                Gn,
                ar,
                fr,
                Zn,
                wn.image.data
              )
            : wn.isCompressedTexture
            ? jt.compressedTexSubImage2D(
                jt.TEXTURE_2D,
                Rn,
                sn.x,
                sn.y,
                wn.mipmaps[0].width,
                wn.mipmaps[0].height,
                fr,
                wn.mipmaps[0].data
              )
            : jt.texSubImage2D(jt.TEXTURE_2D, Rn, sn.x, sn.y, fr, Zn, wn.image),
          Rn === 0 && Un.generateMipmaps && jt.generateMipmap(jt.TEXTURE_2D),
          xn.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (sn, wn, Un, Rn, Gn = 0) {
        if (St.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const ar = sn.max.x - sn.min.x + 1,
          fr = sn.max.y - sn.min.y + 1,
          Zn = sn.max.z - sn.min.z + 1,
          lr = qn.convert(Rn.format),
          xr = qn.convert(Rn.type);
        let Jn;
        if (Rn.isData3DTexture) Dn.setTexture3D(Rn, 0), (Jn = jt.TEXTURE_3D);
        else if (Rn.isDataArrayTexture)
          Dn.setTexture2DArray(Rn, 0), (Jn = jt.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        jt.pixelStorei(jt.UNPACK_FLIP_Y_WEBGL, Rn.flipY),
          jt.pixelStorei(
            jt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Rn.premultiplyAlpha
          ),
          jt.pixelStorei(jt.UNPACK_ALIGNMENT, Rn.unpackAlignment);
        const dr = jt.getParameter(jt.UNPACK_ROW_LENGTH),
          kr = jt.getParameter(jt.UNPACK_IMAGE_HEIGHT),
          Rr = jt.getParameter(jt.UNPACK_SKIP_PIXELS),
          ns = jt.getParameter(jt.UNPACK_SKIP_ROWS),
          hs = jt.getParameter(jt.UNPACK_SKIP_IMAGES),
          Lr = Un.isCompressedTexture ? Un.mipmaps[0] : Un.image;
        jt.pixelStorei(jt.UNPACK_ROW_LENGTH, Lr.width),
          jt.pixelStorei(jt.UNPACK_IMAGE_HEIGHT, Lr.height),
          jt.pixelStorei(jt.UNPACK_SKIP_PIXELS, sn.min.x),
          jt.pixelStorei(jt.UNPACK_SKIP_ROWS, sn.min.y),
          jt.pixelStorei(jt.UNPACK_SKIP_IMAGES, sn.min.z),
          Un.isDataTexture || Un.isData3DTexture
            ? jt.texSubImage3D(
                Jn,
                Gn,
                wn.x,
                wn.y,
                wn.z,
                ar,
                fr,
                Zn,
                lr,
                xr,
                Lr.data
              )
            : Un.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              jt.compressedTexSubImage3D(
                Jn,
                Gn,
                wn.x,
                wn.y,
                wn.z,
                ar,
                fr,
                Zn,
                lr,
                Lr.data
              ))
            : jt.texSubImage3D(
                Jn,
                Gn,
                wn.x,
                wn.y,
                wn.z,
                ar,
                fr,
                Zn,
                lr,
                xr,
                Lr
              ),
          jt.pixelStorei(jt.UNPACK_ROW_LENGTH, dr),
          jt.pixelStorei(jt.UNPACK_IMAGE_HEIGHT, kr),
          jt.pixelStorei(jt.UNPACK_SKIP_PIXELS, Rr),
          jt.pixelStorei(jt.UNPACK_SKIP_ROWS, ns),
          jt.pixelStorei(jt.UNPACK_SKIP_IMAGES, hs),
          Gn === 0 && Rn.generateMipmaps && jt.generateMipmap(Jn),
          xn.unbindTexture();
      }),
      (this.initTexture = function (sn) {
        sn.isCubeTexture
          ? Dn.setTextureCube(sn, 0)
          : sn.isData3DTexture
          ? Dn.setTexture3D(sn, 0)
          : sn.isDataArrayTexture || sn.isCompressedArrayTexture
          ? Dn.setTexture2DArray(sn, 0)
          : Dn.setTexture2D(sn, 0),
          xn.unbindTexture();
      }),
      (this.resetState = function () {
        (Ct = 0), (Mt = 0), (wt = null), xn.reset(), dn.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(et) {
    this._outputColorSpace = et;
    const nt = this.getContext();
    (nt.drawingBufferColorSpace =
      et === DisplayP3ColorSpace ? "display-p3" : "srgb"),
      (nt.unpackColorSpace =
        ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace
          ? "display-p3"
          : "srgb");
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(et) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !et);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    );
  }
  set outputEncoding(et) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace =
        et === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(et) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = et);
  }
}
class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class FogExp2 {
  constructor(et, nt = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Color(et)),
      (this.density = nt);
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Fog {
  constructor(et, nt = 1, rt = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Color(et)),
      (this.near = nt),
      (this.far = rt);
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let Scene$1 = class extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      et.background !== null && (this.background = et.background.clone()),
      et.environment !== null && (this.environment = et.environment.clone()),
      et.fog !== null && (this.fog = et.fog.clone()),
      (this.backgroundBlurriness = et.backgroundBlurriness),
      (this.backgroundIntensity = et.backgroundIntensity),
      et.overrideMaterial !== null &&
        (this.overrideMaterial = et.overrideMaterial.clone()),
      (this.matrixAutoUpdate = et.matrixAutoUpdate),
      this
    );
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      this.fog !== null && (nt.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (nt.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (nt.object.backgroundIntensity = this.backgroundIntensity),
      nt
    );
  }
};
class InterleavedBuffer {
  constructor(et, nt) {
    (this.isInterleavedBuffer = !0),
      (this.array = et),
      (this.stride = nt),
      (this.count = et !== void 0 ? et.length / nt : 0),
      (this.usage = StaticDrawUsage),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = generateUUID$1());
  }
  onUploadCallback() {}
  set needsUpdate(et) {
    et === !0 && this.version++;
  }
  setUsage(et) {
    return (this.usage = et), this;
  }
  copy(et) {
    return (
      (this.array = new et.array.constructor(et.array)),
      (this.count = et.count),
      (this.stride = et.stride),
      (this.usage = et.usage),
      this
    );
  }
  copyAt(et, nt, rt) {
    (et *= this.stride), (rt *= nt.stride);
    for (let it = 0, st = this.stride; it < st; it++)
      this.array[et + it] = nt.array[rt + it];
    return this;
  }
  set(et, nt = 0) {
    return this.array.set(et, nt), this;
  }
  clone(et) {
    et.arrayBuffers === void 0 && (et.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID$1()),
      et.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (et.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const nt = new this.array.constructor(
        et.arrayBuffers[this.array.buffer._uuid]
      ),
      rt = new this.constructor(nt, this.stride);
    return rt.setUsage(this.usage), rt;
  }
  onUpload(et) {
    return (this.onUploadCallback = et), this;
  }
  toJSON(et) {
    return (
      et.arrayBuffers === void 0 && (et.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID$1()),
      et.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (et.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const _vector$5 = new Vector3();
class InterleavedBufferAttribute {
  constructor(et, nt, rt, it = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = et),
      (this.itemSize = nt),
      (this.offset = rt),
      (this.normalized = it);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(et) {
    this.data.needsUpdate = et;
  }
  applyMatrix4(et) {
    for (let nt = 0, rt = this.data.count; nt < rt; nt++)
      _vector$5.fromBufferAttribute(this, nt),
        _vector$5.applyMatrix4(et),
        this.setXYZ(nt, _vector$5.x, _vector$5.y, _vector$5.z);
    return this;
  }
  applyNormalMatrix(et) {
    for (let nt = 0, rt = this.count; nt < rt; nt++)
      _vector$5.fromBufferAttribute(this, nt),
        _vector$5.applyNormalMatrix(et),
        this.setXYZ(nt, _vector$5.x, _vector$5.y, _vector$5.z);
    return this;
  }
  transformDirection(et) {
    for (let nt = 0, rt = this.count; nt < rt; nt++)
      _vector$5.fromBufferAttribute(this, nt),
        _vector$5.transformDirection(et),
        this.setXYZ(nt, _vector$5.x, _vector$5.y, _vector$5.z);
    return this;
  }
  setX(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.data.array[et * this.data.stride + this.offset] = nt),
      this
    );
  }
  setY(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.data.array[et * this.data.stride + this.offset + 1] = nt),
      this
    );
  }
  setZ(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.data.array[et * this.data.stride + this.offset + 2] = nt),
      this
    );
  }
  setW(et, nt) {
    return (
      this.normalized && (nt = normalize(nt, this.array)),
      (this.data.array[et * this.data.stride + this.offset + 3] = nt),
      this
    );
  }
  getX(et) {
    let nt = this.data.array[et * this.data.stride + this.offset];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  getY(et) {
    let nt = this.data.array[et * this.data.stride + this.offset + 1];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  getZ(et) {
    let nt = this.data.array[et * this.data.stride + this.offset + 2];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  getW(et) {
    let nt = this.data.array[et * this.data.stride + this.offset + 3];
    return this.normalized && (nt = denormalize(nt, this.array)), nt;
  }
  setXY(et, nt, rt) {
    return (
      (et = et * this.data.stride + this.offset),
      this.normalized &&
        ((nt = normalize(nt, this.array)), (rt = normalize(rt, this.array))),
      (this.data.array[et + 0] = nt),
      (this.data.array[et + 1] = rt),
      this
    );
  }
  setXYZ(et, nt, rt, it) {
    return (
      (et = et * this.data.stride + this.offset),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array))),
      (this.data.array[et + 0] = nt),
      (this.data.array[et + 1] = rt),
      (this.data.array[et + 2] = it),
      this
    );
  }
  setXYZW(et, nt, rt, it, st) {
    return (
      (et = et * this.data.stride + this.offset),
      this.normalized &&
        ((nt = normalize(nt, this.array)),
        (rt = normalize(rt, this.array)),
        (it = normalize(it, this.array)),
        (st = normalize(st, this.array))),
      (this.data.array[et + 0] = nt),
      (this.data.array[et + 1] = rt),
      (this.data.array[et + 2] = it),
      (this.data.array[et + 3] = st),
      this
    );
  }
  clone(et) {
    if (et === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const nt = [];
      for (let rt = 0; rt < this.count; rt++) {
        const it = rt * this.data.stride + this.offset;
        for (let st = 0; st < this.itemSize; st++)
          nt.push(this.data.array[it + st]);
      }
      return new BufferAttribute(
        new this.array.constructor(nt),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        et.interleavedBuffers === void 0 && (et.interleavedBuffers = {}),
        et.interleavedBuffers[this.data.uuid] === void 0 &&
          (et.interleavedBuffers[this.data.uuid] = this.data.clone(et)),
        new InterleavedBufferAttribute(
          et.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(et) {
    if (et === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const nt = [];
      for (let rt = 0; rt < this.count; rt++) {
        const it = rt * this.data.stride + this.offset;
        for (let st = 0; st < this.itemSize; st++)
          nt.push(this.data.array[it + st]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: nt,
        normalized: this.normalized,
      };
    } else
      return (
        et.interleavedBuffers === void 0 && (et.interleavedBuffers = {}),
        et.interleavedBuffers[this.data.uuid] === void 0 &&
          (et.interleavedBuffers[this.data.uuid] = this.data.toJSON(et)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class SpriteMaterial extends Material {
  constructor(et) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.alphaMap = et.alphaMap),
      (this.rotation = et.rotation),
      (this.sizeAttenuation = et.sizeAttenuation),
      (this.fog = et.fog),
      this
    );
  }
}
let _geometry;
const _intersectPoint = new Vector3(),
  _worldScale = new Vector3(),
  _mvPosition = new Vector3(),
  _alignedPosition = new Vector2(),
  _rotatedPosition = new Vector2(),
  _viewWorldMatrix = new Matrix4(),
  _vA = new Vector3(),
  _vB = new Vector3(),
  _vC = new Vector3(),
  _uvA = new Vector2(),
  _uvB = new Vector2(),
  _uvC = new Vector2();
class Sprite extends Object3D {
  constructor(et = new SpriteMaterial()) {
    if (
      (super(),
      (this.isSprite = !0),
      (this.type = "Sprite"),
      _geometry === void 0)
    ) {
      _geometry = new BufferGeometry();
      const nt = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        rt = new InterleavedBuffer(nt, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]),
        _geometry.setAttribute(
          "position",
          new InterleavedBufferAttribute(rt, 3, 0, !1)
        ),
        _geometry.setAttribute(
          "uv",
          new InterleavedBufferAttribute(rt, 2, 3, !1)
        );
    }
    (this.geometry = _geometry),
      (this.material = et),
      (this.center = new Vector2(0.5, 0.5));
  }
  raycast(et, nt) {
    et.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _worldScale.setFromMatrixScale(this.matrixWorld),
      _viewWorldMatrix.copy(et.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        et.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
      et.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _worldScale.multiplyScalar(-_mvPosition.z);
    const rt = this.material.rotation;
    let it, st;
    rt !== 0 && ((st = Math.cos(rt)), (it = Math.sin(rt)));
    const ot = this.center;
    transformVertex(
      _vA.set(-0.5, -0.5, 0),
      _mvPosition,
      ot,
      _worldScale,
      it,
      st
    ),
      transformVertex(
        _vB.set(0.5, -0.5, 0),
        _mvPosition,
        ot,
        _worldScale,
        it,
        st
      ),
      transformVertex(
        _vC.set(0.5, 0.5, 0),
        _mvPosition,
        ot,
        _worldScale,
        it,
        st
      ),
      _uvA.set(0, 0),
      _uvB.set(1, 0),
      _uvC.set(1, 1);
    let at = et.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
    if (
      at === null &&
      (transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        ot,
        _worldScale,
        it,
        st
      ),
      _uvB.set(0, 1),
      (at = et.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint)),
      at === null)
    )
      return;
    const lt = et.ray.origin.distanceTo(_intersectPoint);
    lt < et.near ||
      lt > et.far ||
      nt.push({
        distance: lt,
        point: _intersectPoint.clone(),
        uv: Triangle.getInterpolation(
          _intersectPoint,
          _vA,
          _vB,
          _vC,
          _uvA,
          _uvB,
          _uvC,
          new Vector2()
        ),
        face: null,
        object: this,
      });
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      et.center !== void 0 && this.center.copy(et.center),
      (this.material = et.material),
      this
    );
  }
}
function transformVertex(tt, et, nt, rt, it, st) {
  _alignedPosition.subVectors(tt, nt).addScalar(0.5).multiply(rt),
    it !== void 0
      ? ((_rotatedPosition.x =
          st * _alignedPosition.x - it * _alignedPosition.y),
        (_rotatedPosition.y =
          it * _alignedPosition.x + st * _alignedPosition.y))
      : _rotatedPosition.copy(_alignedPosition),
    tt.copy(et),
    (tt.x += _rotatedPosition.x),
    (tt.y += _rotatedPosition.y),
    tt.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = new Vector3(),
  _v2$1 = new Vector3();
class LOD extends Object3D {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(et) {
    super.copy(et, !1);
    const nt = et.levels;
    for (let rt = 0, it = nt.length; rt < it; rt++) {
      const st = nt[rt];
      this.addLevel(st.object.clone(), st.distance, st.hysteresis);
    }
    return (this.autoUpdate = et.autoUpdate), this;
  }
  addLevel(et, nt = 0, rt = 0) {
    nt = Math.abs(nt);
    const it = this.levels;
    let st;
    for (st = 0; st < it.length && !(nt < it[st].distance); st++);
    return (
      it.splice(st, 0, { distance: nt, hysteresis: rt, object: et }),
      this.add(et),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(et) {
    const nt = this.levels;
    if (nt.length > 0) {
      let rt, it;
      for (rt = 1, it = nt.length; rt < it; rt++) {
        let st = nt[rt].distance;
        if ((nt[rt].object.visible && (st -= st * nt[rt].hysteresis), et < st))
          break;
      }
      return nt[rt - 1].object;
    }
    return null;
  }
  raycast(et, nt) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const it = et.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(it).raycast(et, nt);
    }
  }
  update(et) {
    const nt = this.levels;
    if (nt.length > 1) {
      _v1$2.setFromMatrixPosition(et.matrixWorld),
        _v2$1.setFromMatrixPosition(this.matrixWorld);
      const rt = _v1$2.distanceTo(_v2$1) / et.zoom;
      nt[0].object.visible = !0;
      let it, st;
      for (it = 1, st = nt.length; it < st; it++) {
        let ot = nt[it].distance;
        if ((nt[it].object.visible && (ot -= ot * nt[it].hysteresis), rt >= ot))
          (nt[it - 1].object.visible = !1), (nt[it].object.visible = !0);
        else break;
      }
      for (this._currentLevel = it - 1; it < st; it++)
        nt[it].object.visible = !1;
    }
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    this.autoUpdate === !1 && (nt.object.autoUpdate = !1),
      (nt.object.levels = []);
    const rt = this.levels;
    for (let it = 0, st = rt.length; it < st; it++) {
      const ot = rt[it];
      nt.object.levels.push({
        object: ot.object.uuid,
        distance: ot.distance,
        hysteresis: ot.hysteresis,
      });
    }
    return nt;
  }
}
const _basePosition = new Vector3(),
  _skinIndex = new Vector4(),
  _skinWeight = new Vector4(),
  _vector3 = new Vector3(),
  _matrix4 = new Matrix4(),
  _vertex = new Vector3(),
  _sphere$3 = new Sphere(),
  _inverseMatrix$2 = new Matrix4(),
  _ray$2 = new Ray();
class SkinnedMesh extends Mesh {
  constructor(et, nt) {
    super(et, nt),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Matrix4()),
      (this.bindMatrixInverse = new Matrix4()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const et = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      this.boundingBox.makeEmpty();
    const nt = et.getAttribute("position");
    for (let rt = 0; rt < nt.count; rt++)
      _vertex.fromBufferAttribute(nt, rt),
        this.applyBoneTransform(rt, _vertex),
        this.boundingBox.expandByPoint(_vertex);
  }
  computeBoundingSphere() {
    const et = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      this.boundingSphere.makeEmpty();
    const nt = et.getAttribute("position");
    for (let rt = 0; rt < nt.count; rt++)
      _vertex.fromBufferAttribute(nt, rt),
        this.applyBoneTransform(rt, _vertex),
        this.boundingSphere.expandByPoint(_vertex);
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.bindMode = et.bindMode),
      this.bindMatrix.copy(et.bindMatrix),
      this.bindMatrixInverse.copy(et.bindMatrixInverse),
      (this.skeleton = et.skeleton),
      et.boundingBox !== null && (this.boundingBox = et.boundingBox.clone()),
      et.boundingSphere !== null &&
        (this.boundingSphere = et.boundingSphere.clone()),
      this
    );
  }
  raycast(et, nt) {
    const rt = this.material,
      it = this.matrixWorld;
    rt !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _sphere$3.copy(this.boundingSphere),
      _sphere$3.applyMatrix4(it),
      et.ray.intersectsSphere(_sphere$3) !== !1 &&
        (_inverseMatrix$2.copy(it).invert(),
        _ray$2.copy(et.ray).applyMatrix4(_inverseMatrix$2),
        !(
          this.boundingBox !== null &&
          _ray$2.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(et, nt, _ray$2)));
  }
  getVertexPosition(et, nt) {
    return super.getVertexPosition(et, nt), this.applyBoneTransform(et, nt), nt;
  }
  bind(et, nt) {
    (this.skeleton = et),
      nt === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (nt = this.matrixWorld)),
      this.bindMatrix.copy(nt),
      this.bindMatrixInverse.copy(nt).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const et = new Vector4(),
      nt = this.geometry.attributes.skinWeight;
    for (let rt = 0, it = nt.count; rt < it; rt++) {
      et.fromBufferAttribute(nt, rt);
      const st = 1 / et.manhattanLength();
      st !== 1 / 0 ? et.multiplyScalar(st) : et.set(1, 0, 0, 0),
        nt.setXYZW(rt, et.x, et.y, et.z, et.w);
    }
  }
  updateMatrixWorld(et) {
    super.updateMatrixWorld(et),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(et, nt) {
    const rt = this.skeleton,
      it = this.geometry;
    _skinIndex.fromBufferAttribute(it.attributes.skinIndex, et),
      _skinWeight.fromBufferAttribute(it.attributes.skinWeight, et),
      _basePosition.copy(nt).applyMatrix4(this.bindMatrix),
      nt.set(0, 0, 0);
    for (let st = 0; st < 4; st++) {
      const ot = _skinWeight.getComponent(st);
      if (ot !== 0) {
        const at = _skinIndex.getComponent(st);
        _matrix4.multiplyMatrices(
          rt.bones[at].matrixWorld,
          rt.boneInverses[at]
        ),
          nt.addScaledVector(
            _vector3.copy(_basePosition).applyMatrix4(_matrix4),
            ot
          );
      }
    }
    return nt.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(et, nt) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(et, nt)
    );
  }
}
class Bone extends Object3D {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class DataTexture extends Texture {
  constructor(
    et = null,
    nt = 1,
    rt = 1,
    it,
    st,
    ot,
    at,
    lt,
    ct = NearestFilter,
    ut = NearestFilter,
    ft,
    ht
  ) {
    super(null, ot, at, lt, ct, ut, it, st, ft, ht),
      (this.isDataTexture = !0),
      (this.image = { data: et, width: nt, height: rt }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const _offsetMatrix = new Matrix4(),
  _identityMatrix$1 = new Matrix4();
class Skeleton {
  constructor(et = [], nt = []) {
    (this.uuid = generateUUID$1()),
      (this.bones = et.slice(0)),
      (this.boneInverses = nt),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const et = this.bones,
      nt = this.boneInverses;
    if (
      ((this.boneMatrices = new Float32Array(et.length * 16)), nt.length === 0)
    )
      this.calculateInverses();
    else if (et.length !== nt.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let rt = 0, it = this.bones.length; rt < it; rt++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let et = 0, nt = this.bones.length; et < nt; et++) {
      const rt = new Matrix4();
      this.bones[et] && rt.copy(this.bones[et].matrixWorld).invert(),
        this.boneInverses.push(rt);
    }
  }
  pose() {
    for (let et = 0, nt = this.bones.length; et < nt; et++) {
      const rt = this.bones[et];
      rt && rt.matrixWorld.copy(this.boneInverses[et]).invert();
    }
    for (let et = 0, nt = this.bones.length; et < nt; et++) {
      const rt = this.bones[et];
      rt &&
        (rt.parent && rt.parent.isBone
          ? (rt.matrix.copy(rt.parent.matrixWorld).invert(),
            rt.matrix.multiply(rt.matrixWorld))
          : rt.matrix.copy(rt.matrixWorld),
        rt.matrix.decompose(rt.position, rt.quaternion, rt.scale));
    }
  }
  update() {
    const et = this.bones,
      nt = this.boneInverses,
      rt = this.boneMatrices,
      it = this.boneTexture;
    for (let st = 0, ot = et.length; st < ot; st++) {
      const at = et[st] ? et[st].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(at, nt[st]),
        _offsetMatrix.toArray(rt, st * 16);
    }
    it !== null && (it.needsUpdate = !0);
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let et = Math.sqrt(this.bones.length * 4);
    (et = ceilPowerOfTwo(et)), (et = Math.max(et, 4));
    const nt = new Float32Array(et * et * 4);
    nt.set(this.boneMatrices);
    const rt = new DataTexture(nt, et, et, RGBAFormat, FloatType);
    return (
      (rt.needsUpdate = !0),
      (this.boneMatrices = nt),
      (this.boneTexture = rt),
      (this.boneTextureSize = et),
      this
    );
  }
  getBoneByName(et) {
    for (let nt = 0, rt = this.bones.length; nt < rt; nt++) {
      const it = this.bones[nt];
      if (it.name === et) return it;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(et, nt) {
    this.uuid = et.uuid;
    for (let rt = 0, it = et.bones.length; rt < it; rt++) {
      const st = et.bones[rt];
      let ot = nt[st];
      ot === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", st),
        (ot = new Bone())),
        this.bones.push(ot),
        this.boneInverses.push(new Matrix4().fromArray(et.boneInverses[rt]));
    }
    return this.init(), this;
  }
  toJSON() {
    const et = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    et.uuid = this.uuid;
    const nt = this.bones,
      rt = this.boneInverses;
    for (let it = 0, st = nt.length; it < st; it++) {
      const ot = nt[it];
      et.bones.push(ot.uuid);
      const at = rt[it];
      et.boneInverses.push(at.toArray());
    }
    return et;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(et, nt, rt, it = 1) {
    super(et, nt, rt),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = it);
  }
  copy(et) {
    return super.copy(et), (this.meshPerAttribute = et.meshPerAttribute), this;
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.meshPerAttribute = this.meshPerAttribute),
      (et.isInstancedBufferAttribute = !0),
      et
    );
  }
}
const _instanceLocalMatrix = new Matrix4(),
  _instanceWorldMatrix = new Matrix4(),
  _instanceIntersects = [],
  _box3 = new Box3(),
  _identity = new Matrix4(),
  _mesh = new Mesh(),
  _sphere$2 = new Sphere();
class InstancedMesh extends Mesh {
  constructor(et, nt, rt) {
    super(et, nt),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new InstancedBufferAttribute(
        new Float32Array(rt * 16),
        16
      )),
      (this.instanceColor = null),
      (this.count = rt),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let it = 0; it < rt; it++) this.setMatrixAt(it, _identity);
  }
  computeBoundingBox() {
    const et = this.geometry,
      nt = this.count;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      et.boundingBox === null && et.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let rt = 0; rt < nt; rt++)
      this.getMatrixAt(rt, _instanceLocalMatrix),
        _box3.copy(et.boundingBox).applyMatrix4(_instanceLocalMatrix),
        this.boundingBox.union(_box3);
  }
  computeBoundingSphere() {
    const et = this.geometry,
      nt = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      et.boundingSphere === null && et.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let rt = 0; rt < nt; rt++)
      this.getMatrixAt(rt, _instanceLocalMatrix),
        _sphere$2.copy(et.boundingSphere).applyMatrix4(_instanceLocalMatrix),
        this.boundingSphere.union(_sphere$2);
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      this.instanceMatrix.copy(et.instanceMatrix),
      et.instanceColor !== null &&
        (this.instanceColor = et.instanceColor.clone()),
      (this.count = et.count),
      et.boundingBox !== null && (this.boundingBox = et.boundingBox.clone()),
      et.boundingSphere !== null &&
        (this.boundingSphere = et.boundingSphere.clone()),
      this
    );
  }
  getColorAt(et, nt) {
    nt.fromArray(this.instanceColor.array, et * 3);
  }
  getMatrixAt(et, nt) {
    nt.fromArray(this.instanceMatrix.array, et * 16);
  }
  raycast(et, nt) {
    const rt = this.matrixWorld,
      it = this.count;
    if (
      ((_mesh.geometry = this.geometry),
      (_mesh.material = this.material),
      _mesh.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$2.copy(this.boundingSphere),
        _sphere$2.applyMatrix4(rt),
        et.ray.intersectsSphere(_sphere$2) !== !1))
    )
      for (let st = 0; st < it; st++) {
        this.getMatrixAt(st, _instanceLocalMatrix),
          _instanceWorldMatrix.multiplyMatrices(rt, _instanceLocalMatrix),
          (_mesh.matrixWorld = _instanceWorldMatrix),
          _mesh.raycast(et, _instanceIntersects);
        for (let ot = 0, at = _instanceIntersects.length; ot < at; ot++) {
          const lt = _instanceIntersects[ot];
          (lt.instanceId = st), (lt.object = this), nt.push(lt);
        }
        _instanceIntersects.length = 0;
      }
  }
  setColorAt(et, nt) {
    this.instanceColor === null &&
      (this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      nt.toArray(this.instanceColor.array, et * 3);
  }
  setMatrixAt(et, nt) {
    nt.toArray(this.instanceMatrix.array, et * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class LineBasicMaterial extends Material {
  constructor(et) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.linewidth = et.linewidth),
      (this.linecap = et.linecap),
      (this.linejoin = et.linejoin),
      (this.fog = et.fog),
      this
    );
  }
}
const _start$1 = new Vector3(),
  _end$1 = new Vector3(),
  _inverseMatrix$1 = new Matrix4(),
  _ray$1$1 = new Ray(),
  _sphere$1 = new Sphere();
let Line$1 = class extends Object3D {
  constructor(et = new BufferGeometry(), nt = new LineBasicMaterial()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = et),
      (this.material = nt),
      this.updateMorphTargets();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.material = Array.isArray(et.material)
        ? et.material.slice()
        : et.material),
      (this.geometry = et.geometry),
      this
    );
  }
  computeLineDistances() {
    const et = this.geometry;
    if (et.index === null) {
      const nt = et.attributes.position,
        rt = [0];
      for (let it = 1, st = nt.count; it < st; it++)
        _start$1.fromBufferAttribute(nt, it - 1),
          _end$1.fromBufferAttribute(nt, it),
          (rt[it] = rt[it - 1]),
          (rt[it] += _start$1.distanceTo(_end$1));
      et.setAttribute("lineDistance", new Float32BufferAttribute(rt, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(et, nt) {
    const rt = this.geometry,
      it = this.matrixWorld,
      st = et.params.Line.threshold,
      ot = rt.drawRange;
    if (
      (rt.boundingSphere === null && rt.computeBoundingSphere(),
      _sphere$1.copy(rt.boundingSphere),
      _sphere$1.applyMatrix4(it),
      (_sphere$1.radius += st),
      et.ray.intersectsSphere(_sphere$1) === !1)
    )
      return;
    _inverseMatrix$1.copy(it).invert(),
      _ray$1$1.copy(et.ray).applyMatrix4(_inverseMatrix$1);
    const at = st / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      lt = at * at,
      ct = new Vector3(),
      ut = new Vector3(),
      ft = new Vector3(),
      ht = new Vector3(),
      mt = this.isLineSegments ? 2 : 1,
      vt = rt.index,
      Et = rt.attributes.position;
    if (vt !== null) {
      const pt = Math.max(0, ot.start),
        xt = Math.min(vt.count, ot.start + ot.count);
      for (let St = pt, At = xt - 1; St < At; St += mt) {
        const Ct = vt.getX(St),
          Mt = vt.getX(St + 1);
        if (
          (ct.fromBufferAttribute(Et, Ct),
          ut.fromBufferAttribute(Et, Mt),
          _ray$1$1.distanceSqToSegment(ct, ut, ht, ft) > lt)
        )
          continue;
        ht.applyMatrix4(this.matrixWorld);
        const Bt = et.ray.origin.distanceTo(ht);
        Bt < et.near ||
          Bt > et.far ||
          nt.push({
            distance: Bt,
            point: ft.clone().applyMatrix4(this.matrixWorld),
            index: St,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const pt = Math.max(0, ot.start),
        xt = Math.min(Et.count, ot.start + ot.count);
      for (let St = pt, At = xt - 1; St < At; St += mt) {
        if (
          (ct.fromBufferAttribute(Et, St),
          ut.fromBufferAttribute(Et, St + 1),
          _ray$1$1.distanceSqToSegment(ct, ut, ht, ft) > lt)
        )
          continue;
        ht.applyMatrix4(this.matrixWorld);
        const Mt = et.ray.origin.distanceTo(ht);
        Mt < et.near ||
          Mt > et.far ||
          nt.push({
            distance: Mt,
            point: ft.clone().applyMatrix4(this.matrixWorld),
            index: St,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const nt = this.geometry.morphAttributes,
      rt = Object.keys(nt);
    if (rt.length > 0) {
      const it = nt[rt[0]];
      if (it !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let st = 0, ot = it.length; st < ot; st++) {
          const at = it[st].name || String(st);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[at] = st);
        }
      }
    }
  }
};
const _start$2 = new Vector3(),
  _end$2 = new Vector3();
class LineSegments extends Line$1 {
  constructor(et, nt) {
    super(et, nt), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const et = this.geometry;
    if (et.index === null) {
      const nt = et.attributes.position,
        rt = [];
      for (let it = 0, st = nt.count; it < st; it += 2)
        _start$2.fromBufferAttribute(nt, it),
          _end$2.fromBufferAttribute(nt, it + 1),
          (rt[it] = it === 0 ? 0 : rt[it - 1]),
          (rt[it + 1] = rt[it] + _start$2.distanceTo(_end$2));
      et.setAttribute("lineDistance", new Float32BufferAttribute(rt, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class LineLoop extends Line$1 {
  constructor(et, nt) {
    super(et, nt), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class PointsMaterial extends Material {
  constructor(et) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.alphaMap = et.alphaMap),
      (this.size = et.size),
      (this.sizeAttenuation = et.sizeAttenuation),
      (this.fog = et.fog),
      this
    );
  }
}
const _inverseMatrix = new Matrix4(),
  _ray$4 = new Ray(),
  _sphere$6 = new Sphere(),
  _position$2 = new Vector3();
class Points extends Object3D {
  constructor(et = new BufferGeometry(), nt = new PointsMaterial()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = et),
      (this.material = nt),
      this.updateMorphTargets();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.material = Array.isArray(et.material)
        ? et.material.slice()
        : et.material),
      (this.geometry = et.geometry),
      this
    );
  }
  raycast(et, nt) {
    const rt = this.geometry,
      it = this.matrixWorld,
      st = et.params.Points.threshold,
      ot = rt.drawRange;
    if (
      (rt.boundingSphere === null && rt.computeBoundingSphere(),
      _sphere$6.copy(rt.boundingSphere),
      _sphere$6.applyMatrix4(it),
      (_sphere$6.radius += st),
      et.ray.intersectsSphere(_sphere$6) === !1)
    )
      return;
    _inverseMatrix.copy(it).invert(),
      _ray$4.copy(et.ray).applyMatrix4(_inverseMatrix);
    const at = st / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      lt = at * at,
      ct = rt.index,
      ft = rt.attributes.position;
    if (ct !== null) {
      const ht = Math.max(0, ot.start),
        mt = Math.min(ct.count, ot.start + ot.count);
      for (let vt = ht, yt = mt; vt < yt; vt++) {
        const Et = ct.getX(vt);
        _position$2.fromBufferAttribute(ft, Et),
          testPoint(_position$2, Et, lt, it, et, nt, this);
      }
    } else {
      const ht = Math.max(0, ot.start),
        mt = Math.min(ft.count, ot.start + ot.count);
      for (let vt = ht, yt = mt; vt < yt; vt++)
        _position$2.fromBufferAttribute(ft, vt),
          testPoint(_position$2, vt, lt, it, et, nt, this);
    }
  }
  updateMorphTargets() {
    const nt = this.geometry.morphAttributes,
      rt = Object.keys(nt);
    if (rt.length > 0) {
      const it = nt[rt[0]];
      if (it !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let st = 0, ot = it.length; st < ot; st++) {
          const at = it[st].name || String(st);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[at] = st);
        }
      }
    }
  }
}
function testPoint(tt, et, nt, rt, it, st, ot) {
  const at = _ray$4.distanceSqToPoint(tt);
  if (at < nt) {
    const lt = new Vector3();
    _ray$4.closestPointToPoint(tt, lt), lt.applyMatrix4(rt);
    const ct = it.ray.origin.distanceTo(lt);
    if (ct < it.near || ct > it.far) return;
    st.push({
      distance: ct,
      distanceToRay: Math.sqrt(at),
      point: lt,
      index: et,
      face: null,
      object: ot,
    });
  }
}
class VideoTexture extends Texture {
  constructor(et, nt, rt, it, st, ot, at, lt, ct) {
    super(et, nt, rt, it, st, ot, at, lt, ct),
      (this.isVideoTexture = !0),
      (this.minFilter = ot !== void 0 ? ot : LinearFilter),
      (this.magFilter = st !== void 0 ? st : LinearFilter),
      (this.generateMipmaps = !1);
    const ut = this;
    function ft() {
      (ut.needsUpdate = !0), et.requestVideoFrameCallback(ft);
    }
    "requestVideoFrameCallback" in et && et.requestVideoFrameCallback(ft);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const et = this.image;
    "requestVideoFrameCallback" in et === !1 &&
      et.readyState >= et.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class FramebufferTexture extends Texture {
  constructor(et, nt) {
    super({ width: et, height: nt }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class CompressedTexture extends Texture {
  constructor(et, nt, rt, it, st, ot, at, lt, ct, ut, ft, ht) {
    super(null, ot, at, lt, ct, ut, it, st, ft, ht),
      (this.isCompressedTexture = !0),
      (this.image = { width: nt, height: rt }),
      (this.mipmaps = et),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(et, nt, rt, it, st, ot) {
    super(et, nt, rt, st, ot),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = it),
      (this.wrapR = ClampToEdgeWrapping);
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(et, nt, rt) {
    super(void 0, et[0].width, et[0].height, nt, rt, CubeReflectionMapping),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = et);
  }
}
class CanvasTexture extends Texture {
  constructor(et, nt, rt, it, st, ot, at, lt, ct) {
    super(et, nt, rt, it, st, ot, at, lt, ct),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Curve {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(et, nt) {
    const rt = this.getUtoTmapping(et);
    return this.getPoint(rt, nt);
  }
  getPoints(et = 5) {
    const nt = [];
    for (let rt = 0; rt <= et; rt++) nt.push(this.getPoint(rt / et));
    return nt;
  }
  getSpacedPoints(et = 5) {
    const nt = [];
    for (let rt = 0; rt <= et; rt++) nt.push(this.getPointAt(rt / et));
    return nt;
  }
  getLength() {
    const et = this.getLengths();
    return et[et.length - 1];
  }
  getLengths(et = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === et + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const nt = [];
    let rt,
      it = this.getPoint(0),
      st = 0;
    nt.push(0);
    for (let ot = 1; ot <= et; ot++)
      (rt = this.getPoint(ot / et)),
        (st += rt.distanceTo(it)),
        nt.push(st),
        (it = rt);
    return (this.cacheArcLengths = nt), nt;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(et, nt) {
    const rt = this.getLengths();
    let it = 0;
    const st = rt.length;
    let ot;
    nt ? (ot = nt) : (ot = et * rt[st - 1]);
    let at = 0,
      lt = st - 1,
      ct;
    for (; at <= lt; )
      if (((it = Math.floor(at + (lt - at) / 2)), (ct = rt[it] - ot), ct < 0))
        at = it + 1;
      else if (ct > 0) lt = it - 1;
      else {
        lt = it;
        break;
      }
    if (((it = lt), rt[it] === ot)) return it / (st - 1);
    const ut = rt[it],
      ht = rt[it + 1] - ut,
      mt = (ot - ut) / ht;
    return (it + mt) / (st - 1);
  }
  getTangent(et, nt) {
    let it = et - 1e-4,
      st = et + 1e-4;
    it < 0 && (it = 0), st > 1 && (st = 1);
    const ot = this.getPoint(it),
      at = this.getPoint(st),
      lt = nt || (ot.isVector2 ? new Vector2() : new Vector3());
    return lt.copy(at).sub(ot).normalize(), lt;
  }
  getTangentAt(et, nt) {
    const rt = this.getUtoTmapping(et);
    return this.getTangent(rt, nt);
  }
  computeFrenetFrames(et, nt) {
    const rt = new Vector3(),
      it = [],
      st = [],
      ot = [],
      at = new Vector3(),
      lt = new Matrix4();
    for (let mt = 0; mt <= et; mt++) {
      const vt = mt / et;
      it[mt] = this.getTangentAt(vt, new Vector3());
    }
    (st[0] = new Vector3()), (ot[0] = new Vector3());
    let ct = Number.MAX_VALUE;
    const ut = Math.abs(it[0].x),
      ft = Math.abs(it[0].y),
      ht = Math.abs(it[0].z);
    ut <= ct && ((ct = ut), rt.set(1, 0, 0)),
      ft <= ct && ((ct = ft), rt.set(0, 1, 0)),
      ht <= ct && rt.set(0, 0, 1),
      at.crossVectors(it[0], rt).normalize(),
      st[0].crossVectors(it[0], at),
      ot[0].crossVectors(it[0], st[0]);
    for (let mt = 1; mt <= et; mt++) {
      if (
        ((st[mt] = st[mt - 1].clone()),
        (ot[mt] = ot[mt - 1].clone()),
        at.crossVectors(it[mt - 1], it[mt]),
        at.length() > Number.EPSILON)
      ) {
        at.normalize();
        const vt = Math.acos(clamp$1(it[mt - 1].dot(it[mt]), -1, 1));
        st[mt].applyMatrix4(lt.makeRotationAxis(at, vt));
      }
      ot[mt].crossVectors(it[mt], st[mt]);
    }
    if (nt === !0) {
      let mt = Math.acos(clamp$1(st[0].dot(st[et]), -1, 1));
      (mt /= et), it[0].dot(at.crossVectors(st[0], st[et])) > 0 && (mt = -mt);
      for (let vt = 1; vt <= et; vt++)
        st[vt].applyMatrix4(lt.makeRotationAxis(it[vt], mt * vt)),
          ot[vt].crossVectors(it[vt], st[vt]);
    }
    return { tangents: it, normals: st, binormals: ot };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    return (this.arcLengthDivisions = et.arcLengthDivisions), this;
  }
  toJSON() {
    const et = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (et.arcLengthDivisions = this.arcLengthDivisions),
      (et.type = this.type),
      et
    );
  }
  fromJSON(et) {
    return (this.arcLengthDivisions = et.arcLengthDivisions), this;
  }
}
class EllipseCurve extends Curve {
  constructor(
    et = 0,
    nt = 0,
    rt = 1,
    it = 1,
    st = 0,
    ot = Math.PI * 2,
    at = !1,
    lt = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = et),
      (this.aY = nt),
      (this.xRadius = rt),
      (this.yRadius = it),
      (this.aStartAngle = st),
      (this.aEndAngle = ot),
      (this.aClockwise = at),
      (this.aRotation = lt);
  }
  getPoint(et, nt) {
    const rt = nt || new Vector2(),
      it = Math.PI * 2;
    let st = this.aEndAngle - this.aStartAngle;
    const ot = Math.abs(st) < Number.EPSILON;
    for (; st < 0; ) st += it;
    for (; st > it; ) st -= it;
    st < Number.EPSILON && (ot ? (st = 0) : (st = it)),
      this.aClockwise === !0 &&
        !ot &&
        (st === it ? (st = -it) : (st = st - it));
    const at = this.aStartAngle + et * st;
    let lt = this.aX + this.xRadius * Math.cos(at),
      ct = this.aY + this.yRadius * Math.sin(at);
    if (this.aRotation !== 0) {
      const ut = Math.cos(this.aRotation),
        ft = Math.sin(this.aRotation),
        ht = lt - this.aX,
        mt = ct - this.aY;
      (lt = ht * ut - mt * ft + this.aX), (ct = ht * ft + mt * ut + this.aY);
    }
    return rt.set(lt, ct);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.aX = et.aX),
      (this.aY = et.aY),
      (this.xRadius = et.xRadius),
      (this.yRadius = et.yRadius),
      (this.aStartAngle = et.aStartAngle),
      (this.aEndAngle = et.aEndAngle),
      (this.aClockwise = et.aClockwise),
      (this.aRotation = et.aRotation),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.aX = this.aX),
      (et.aY = this.aY),
      (et.xRadius = this.xRadius),
      (et.yRadius = this.yRadius),
      (et.aStartAngle = this.aStartAngle),
      (et.aEndAngle = this.aEndAngle),
      (et.aClockwise = this.aClockwise),
      (et.aRotation = this.aRotation),
      et
    );
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      (this.aX = et.aX),
      (this.aY = et.aY),
      (this.xRadius = et.xRadius),
      (this.yRadius = et.yRadius),
      (this.aStartAngle = et.aStartAngle),
      (this.aEndAngle = et.aEndAngle),
      (this.aClockwise = et.aClockwise),
      (this.aRotation = et.aRotation),
      this
    );
  }
}
class ArcCurve extends EllipseCurve {
  constructor(et, nt, rt, it, st, ot) {
    super(et, nt, rt, rt, it, st, ot),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function CubicPoly() {
  let tt = 0,
    et = 0,
    nt = 0,
    rt = 0;
  function it(st, ot, at, lt) {
    (tt = st),
      (et = at),
      (nt = -3 * st + 3 * ot - 2 * at - lt),
      (rt = 2 * st - 2 * ot + at + lt);
  }
  return {
    initCatmullRom: function (st, ot, at, lt, ct) {
      it(ot, at, ct * (at - st), ct * (lt - ot));
    },
    initNonuniformCatmullRom: function (st, ot, at, lt, ct, ut, ft) {
      let ht = (ot - st) / ct - (at - st) / (ct + ut) + (at - ot) / ut,
        mt = (at - ot) / ut - (lt - ot) / (ut + ft) + (lt - at) / ft;
      (ht *= ut), (mt *= ut), it(ot, at, ht, mt);
    },
    calc: function (st) {
      const ot = st * st,
        at = ot * st;
      return tt + et * st + nt * ot + rt * at;
    },
  };
}
const tmp = new Vector3(),
  px = new CubicPoly(),
  py = new CubicPoly(),
  pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(et = [], nt = !1, rt = "centripetal", it = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = et),
      (this.closed = nt),
      (this.curveType = rt),
      (this.tension = it);
  }
  getPoint(et, nt = new Vector3()) {
    const rt = nt,
      it = this.points,
      st = it.length,
      ot = (st - (this.closed ? 0 : 1)) * et;
    let at = Math.floor(ot),
      lt = ot - at;
    this.closed
      ? (at += at > 0 ? 0 : (Math.floor(Math.abs(at) / st) + 1) * st)
      : lt === 0 && at === st - 1 && ((at = st - 2), (lt = 1));
    let ct, ut;
    this.closed || at > 0
      ? (ct = it[(at - 1) % st])
      : (tmp.subVectors(it[0], it[1]).add(it[0]), (ct = tmp));
    const ft = it[at % st],
      ht = it[(at + 1) % st];
    if (
      (this.closed || at + 2 < st
        ? (ut = it[(at + 2) % st])
        : (tmp.subVectors(it[st - 1], it[st - 2]).add(it[st - 1]), (ut = tmp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const mt = this.curveType === "chordal" ? 0.5 : 0.25;
      let vt = Math.pow(ct.distanceToSquared(ft), mt),
        yt = Math.pow(ft.distanceToSquared(ht), mt),
        Et = Math.pow(ht.distanceToSquared(ut), mt);
      yt < 1e-4 && (yt = 1),
        vt < 1e-4 && (vt = yt),
        Et < 1e-4 && (Et = yt),
        px.initNonuniformCatmullRom(ct.x, ft.x, ht.x, ut.x, vt, yt, Et),
        py.initNonuniformCatmullRom(ct.y, ft.y, ht.y, ut.y, vt, yt, Et),
        pz.initNonuniformCatmullRom(ct.z, ft.z, ht.z, ut.z, vt, yt, Et);
    } else
      this.curveType === "catmullrom" &&
        (px.initCatmullRom(ct.x, ft.x, ht.x, ut.x, this.tension),
        py.initCatmullRom(ct.y, ft.y, ht.y, ut.y, this.tension),
        pz.initCatmullRom(ct.z, ft.z, ht.z, ut.z, this.tension));
    return rt.set(px.calc(lt), py.calc(lt), pz.calc(lt)), rt;
  }
  copy(et) {
    super.copy(et), (this.points = []);
    for (let nt = 0, rt = et.points.length; nt < rt; nt++) {
      const it = et.points[nt];
      this.points.push(it.clone());
    }
    return (
      (this.closed = et.closed),
      (this.curveType = et.curveType),
      (this.tension = et.tension),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    et.points = [];
    for (let nt = 0, rt = this.points.length; nt < rt; nt++) {
      const it = this.points[nt];
      et.points.push(it.toArray());
    }
    return (
      (et.closed = this.closed),
      (et.curveType = this.curveType),
      (et.tension = this.tension),
      et
    );
  }
  fromJSON(et) {
    super.fromJSON(et), (this.points = []);
    for (let nt = 0, rt = et.points.length; nt < rt; nt++) {
      const it = et.points[nt];
      this.points.push(new Vector3().fromArray(it));
    }
    return (
      (this.closed = et.closed),
      (this.curveType = et.curveType),
      (this.tension = et.tension),
      this
    );
  }
}
function CatmullRom(tt, et, nt, rt, it) {
  const st = (rt - et) * 0.5,
    ot = (it - nt) * 0.5,
    at = tt * tt,
    lt = tt * at;
  return (
    (2 * nt - 2 * rt + st + ot) * lt +
    (-3 * nt + 3 * rt - 2 * st - ot) * at +
    st * tt +
    nt
  );
}
function QuadraticBezierP0(tt, et) {
  const nt = 1 - tt;
  return nt * nt * et;
}
function QuadraticBezierP1(tt, et) {
  return 2 * (1 - tt) * tt * et;
}
function QuadraticBezierP2(tt, et) {
  return tt * tt * et;
}
function QuadraticBezier(tt, et, nt, rt) {
  return (
    QuadraticBezierP0(tt, et) +
    QuadraticBezierP1(tt, nt) +
    QuadraticBezierP2(tt, rt)
  );
}
function CubicBezierP0(tt, et) {
  const nt = 1 - tt;
  return nt * nt * nt * et;
}
function CubicBezierP1(tt, et) {
  const nt = 1 - tt;
  return 3 * nt * nt * tt * et;
}
function CubicBezierP2(tt, et) {
  return 3 * (1 - tt) * tt * tt * et;
}
function CubicBezierP3(tt, et) {
  return tt * tt * tt * et;
}
function CubicBezier(tt, et, nt, rt, it) {
  return (
    CubicBezierP0(tt, et) +
    CubicBezierP1(tt, nt) +
    CubicBezierP2(tt, rt) +
    CubicBezierP3(tt, it)
  );
}
class CubicBezierCurve extends Curve {
  constructor(
    et = new Vector2(),
    nt = new Vector2(),
    rt = new Vector2(),
    it = new Vector2()
  ) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = et),
      (this.v1 = nt),
      (this.v2 = rt),
      (this.v3 = it);
  }
  getPoint(et, nt = new Vector2()) {
    const rt = nt,
      it = this.v0,
      st = this.v1,
      ot = this.v2,
      at = this.v3;
    return (
      rt.set(
        CubicBezier(et, it.x, st.x, ot.x, at.x),
        CubicBezier(et, it.y, st.y, ot.y, at.y)
      ),
      rt
    );
  }
  copy(et) {
    return (
      super.copy(et),
      this.v0.copy(et.v0),
      this.v1.copy(et.v1),
      this.v2.copy(et.v2),
      this.v3.copy(et.v3),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.v0 = this.v0.toArray()),
      (et.v1 = this.v1.toArray()),
      (et.v2 = this.v2.toArray()),
      (et.v3 = this.v3.toArray()),
      et
    );
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v0.fromArray(et.v0),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this.v3.fromArray(et.v3),
      this
    );
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    et = new Vector3(),
    nt = new Vector3(),
    rt = new Vector3(),
    it = new Vector3()
  ) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = et),
      (this.v1 = nt),
      (this.v2 = rt),
      (this.v3 = it);
  }
  getPoint(et, nt = new Vector3()) {
    const rt = nt,
      it = this.v0,
      st = this.v1,
      ot = this.v2,
      at = this.v3;
    return (
      rt.set(
        CubicBezier(et, it.x, st.x, ot.x, at.x),
        CubicBezier(et, it.y, st.y, ot.y, at.y),
        CubicBezier(et, it.z, st.z, ot.z, at.z)
      ),
      rt
    );
  }
  copy(et) {
    return (
      super.copy(et),
      this.v0.copy(et.v0),
      this.v1.copy(et.v1),
      this.v2.copy(et.v2),
      this.v3.copy(et.v3),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.v0 = this.v0.toArray()),
      (et.v1 = this.v1.toArray()),
      (et.v2 = this.v2.toArray()),
      (et.v3 = this.v3.toArray()),
      et
    );
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v0.fromArray(et.v0),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this.v3.fromArray(et.v3),
      this
    );
  }
}
class LineCurve extends Curve {
  constructor(et = new Vector2(), nt = new Vector2()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = et),
      (this.v2 = nt);
  }
  getPoint(et, nt = new Vector2()) {
    const rt = nt;
    return (
      et === 1
        ? rt.copy(this.v2)
        : (rt.copy(this.v2).sub(this.v1), rt.multiplyScalar(et).add(this.v1)),
      rt
    );
  }
  getPointAt(et, nt) {
    return this.getPoint(et, nt);
  }
  getTangent(et, nt = new Vector2()) {
    return nt.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(et, nt) {
    return this.getTangent(et, nt);
  }
  copy(et) {
    return super.copy(et), this.v1.copy(et.v1), this.v2.copy(et.v2), this;
  }
  toJSON() {
    const et = super.toJSON();
    return (et.v1 = this.v1.toArray()), (et.v2 = this.v2.toArray()), et;
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this
    );
  }
}
class LineCurve3 extends Curve {
  constructor(et = new Vector3(), nt = new Vector3()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = et),
      (this.v2 = nt);
  }
  getPoint(et, nt = new Vector3()) {
    const rt = nt;
    return (
      et === 1
        ? rt.copy(this.v2)
        : (rt.copy(this.v2).sub(this.v1), rt.multiplyScalar(et).add(this.v1)),
      rt
    );
  }
  getPointAt(et, nt) {
    return this.getPoint(et, nt);
  }
  getTangent(et, nt = new Vector3()) {
    return nt.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(et, nt) {
    return this.getTangent(et, nt);
  }
  copy(et) {
    return super.copy(et), this.v1.copy(et.v1), this.v2.copy(et.v2), this;
  }
  toJSON() {
    const et = super.toJSON();
    return (et.v1 = this.v1.toArray()), (et.v2 = this.v2.toArray()), et;
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this
    );
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(et = new Vector2(), nt = new Vector2(), rt = new Vector2()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = et),
      (this.v1 = nt),
      (this.v2 = rt);
  }
  getPoint(et, nt = new Vector2()) {
    const rt = nt,
      it = this.v0,
      st = this.v1,
      ot = this.v2;
    return (
      rt.set(
        QuadraticBezier(et, it.x, st.x, ot.x),
        QuadraticBezier(et, it.y, st.y, ot.y)
      ),
      rt
    );
  }
  copy(et) {
    return (
      super.copy(et),
      this.v0.copy(et.v0),
      this.v1.copy(et.v1),
      this.v2.copy(et.v2),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.v0 = this.v0.toArray()),
      (et.v1 = this.v1.toArray()),
      (et.v2 = this.v2.toArray()),
      et
    );
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v0.fromArray(et.v0),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this
    );
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(et = new Vector3(), nt = new Vector3(), rt = new Vector3()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = et),
      (this.v1 = nt),
      (this.v2 = rt);
  }
  getPoint(et, nt = new Vector3()) {
    const rt = nt,
      it = this.v0,
      st = this.v1,
      ot = this.v2;
    return (
      rt.set(
        QuadraticBezier(et, it.x, st.x, ot.x),
        QuadraticBezier(et, it.y, st.y, ot.y),
        QuadraticBezier(et, it.z, st.z, ot.z)
      ),
      rt
    );
  }
  copy(et) {
    return (
      super.copy(et),
      this.v0.copy(et.v0),
      this.v1.copy(et.v1),
      this.v2.copy(et.v2),
      this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.v0 = this.v0.toArray()),
      (et.v1 = this.v1.toArray()),
      (et.v2 = this.v2.toArray()),
      et
    );
  }
  fromJSON(et) {
    return (
      super.fromJSON(et),
      this.v0.fromArray(et.v0),
      this.v1.fromArray(et.v1),
      this.v2.fromArray(et.v2),
      this
    );
  }
}
class SplineCurve extends Curve {
  constructor(et = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = et);
  }
  getPoint(et, nt = new Vector2()) {
    const rt = nt,
      it = this.points,
      st = (it.length - 1) * et,
      ot = Math.floor(st),
      at = st - ot,
      lt = it[ot === 0 ? ot : ot - 1],
      ct = it[ot],
      ut = it[ot > it.length - 2 ? it.length - 1 : ot + 1],
      ft = it[ot > it.length - 3 ? it.length - 1 : ot + 2];
    return (
      rt.set(
        CatmullRom(at, lt.x, ct.x, ut.x, ft.x),
        CatmullRom(at, lt.y, ct.y, ut.y, ft.y)
      ),
      rt
    );
  }
  copy(et) {
    super.copy(et), (this.points = []);
    for (let nt = 0, rt = et.points.length; nt < rt; nt++) {
      const it = et.points[nt];
      this.points.push(it.clone());
    }
    return this;
  }
  toJSON() {
    const et = super.toJSON();
    et.points = [];
    for (let nt = 0, rt = this.points.length; nt < rt; nt++) {
      const it = this.points[nt];
      et.points.push(it.toArray());
    }
    return et;
  }
  fromJSON(et) {
    super.fromJSON(et), (this.points = []);
    for (let nt = 0, rt = et.points.length; nt < rt; nt++) {
      const it = et.points[nt];
      this.points.push(new Vector2().fromArray(it));
    }
    return this;
  }
}
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
});
class CurvePath extends Curve {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(et) {
    this.curves.push(et);
  }
  closePath() {
    const et = this.curves[0].getPoint(0),
      nt = this.curves[this.curves.length - 1].getPoint(1);
    if (!et.equals(nt)) {
      const rt = et.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[rt](nt, et));
    }
    return this;
  }
  getPoint(et, nt) {
    const rt = et * this.getLength(),
      it = this.getCurveLengths();
    let st = 0;
    for (; st < it.length; ) {
      if (it[st] >= rt) {
        const ot = it[st] - rt,
          at = this.curves[st],
          lt = at.getLength(),
          ct = lt === 0 ? 0 : 1 - ot / lt;
        return at.getPointAt(ct, nt);
      }
      st++;
    }
    return null;
  }
  getLength() {
    const et = this.getCurveLengths();
    return et[et.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const et = [];
    let nt = 0;
    for (let rt = 0, it = this.curves.length; rt < it; rt++)
      (nt += this.curves[rt].getLength()), et.push(nt);
    return (this.cacheLengths = et), et;
  }
  getSpacedPoints(et = 40) {
    const nt = [];
    for (let rt = 0; rt <= et; rt++) nt.push(this.getPoint(rt / et));
    return this.autoClose && nt.push(nt[0]), nt;
  }
  getPoints(et = 12) {
    const nt = [];
    let rt;
    for (let it = 0, st = this.curves; it < st.length; it++) {
      const ot = st[it],
        at = ot.isEllipseCurve
          ? et * 2
          : ot.isLineCurve || ot.isLineCurve3
          ? 1
          : ot.isSplineCurve
          ? et * ot.points.length
          : et,
        lt = ot.getPoints(at);
      for (let ct = 0; ct < lt.length; ct++) {
        const ut = lt[ct];
        (rt && rt.equals(ut)) || (nt.push(ut), (rt = ut));
      }
    }
    return (
      this.autoClose &&
        nt.length > 1 &&
        !nt[nt.length - 1].equals(nt[0]) &&
        nt.push(nt[0]),
      nt
    );
  }
  copy(et) {
    super.copy(et), (this.curves = []);
    for (let nt = 0, rt = et.curves.length; nt < rt; nt++) {
      const it = et.curves[nt];
      this.curves.push(it.clone());
    }
    return (this.autoClose = et.autoClose), this;
  }
  toJSON() {
    const et = super.toJSON();
    (et.autoClose = this.autoClose), (et.curves = []);
    for (let nt = 0, rt = this.curves.length; nt < rt; nt++) {
      const it = this.curves[nt];
      et.curves.push(it.toJSON());
    }
    return et;
  }
  fromJSON(et) {
    super.fromJSON(et), (this.autoClose = et.autoClose), (this.curves = []);
    for (let nt = 0, rt = et.curves.length; nt < rt; nt++) {
      const it = et.curves[nt];
      this.curves.push(new Curves[it.type]().fromJSON(it));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(et) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Vector2()),
      et && this.setFromPoints(et);
  }
  setFromPoints(et) {
    this.moveTo(et[0].x, et[0].y);
    for (let nt = 1, rt = et.length; nt < rt; nt++)
      this.lineTo(et[nt].x, et[nt].y);
    return this;
  }
  moveTo(et, nt) {
    return this.currentPoint.set(et, nt), this;
  }
  lineTo(et, nt) {
    const rt = new LineCurve(this.currentPoint.clone(), new Vector2(et, nt));
    return this.curves.push(rt), this.currentPoint.set(et, nt), this;
  }
  quadraticCurveTo(et, nt, rt, it) {
    const st = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(et, nt),
      new Vector2(rt, it)
    );
    return this.curves.push(st), this.currentPoint.set(rt, it), this;
  }
  bezierCurveTo(et, nt, rt, it, st, ot) {
    const at = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(et, nt),
      new Vector2(rt, it),
      new Vector2(st, ot)
    );
    return this.curves.push(at), this.currentPoint.set(st, ot), this;
  }
  splineThru(et) {
    const nt = [this.currentPoint.clone()].concat(et),
      rt = new SplineCurve(nt);
    return (
      this.curves.push(rt), this.currentPoint.copy(et[et.length - 1]), this
    );
  }
  arc(et, nt, rt, it, st, ot) {
    const at = this.currentPoint.x,
      lt = this.currentPoint.y;
    return this.absarc(et + at, nt + lt, rt, it, st, ot), this;
  }
  absarc(et, nt, rt, it, st, ot) {
    return this.absellipse(et, nt, rt, rt, it, st, ot), this;
  }
  ellipse(et, nt, rt, it, st, ot, at, lt) {
    const ct = this.currentPoint.x,
      ut = this.currentPoint.y;
    return this.absellipse(et + ct, nt + ut, rt, it, st, ot, at, lt), this;
  }
  absellipse(et, nt, rt, it, st, ot, at, lt) {
    const ct = new EllipseCurve(et, nt, rt, it, st, ot, at, lt);
    if (this.curves.length > 0) {
      const ft = ct.getPoint(0);
      ft.equals(this.currentPoint) || this.lineTo(ft.x, ft.y);
    }
    this.curves.push(ct);
    const ut = ct.getPoint(1);
    return this.currentPoint.copy(ut), this;
  }
  copy(et) {
    return super.copy(et), this.currentPoint.copy(et.currentPoint), this;
  }
  toJSON() {
    const et = super.toJSON();
    return (et.currentPoint = this.currentPoint.toArray()), et;
  }
  fromJSON(et) {
    return (
      super.fromJSON(et), this.currentPoint.fromArray(et.currentPoint), this
    );
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    et = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
    nt = 12,
    rt = 0,
    it = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = {
        points: et,
        segments: nt,
        phiStart: rt,
        phiLength: it,
      }),
      (nt = Math.floor(nt)),
      (it = clamp$1(it, 0, Math.PI * 2));
    const st = [],
      ot = [],
      at = [],
      lt = [],
      ct = [],
      ut = 1 / nt,
      ft = new Vector3(),
      ht = new Vector2(),
      mt = new Vector3(),
      vt = new Vector3(),
      yt = new Vector3();
    let Et = 0,
      pt = 0;
    for (let xt = 0; xt <= et.length - 1; xt++)
      switch (xt) {
        case 0:
          (Et = et[xt + 1].x - et[xt].x),
            (pt = et[xt + 1].y - et[xt].y),
            (mt.x = pt * 1),
            (mt.y = -Et),
            (mt.z = pt * 0),
            yt.copy(mt),
            mt.normalize(),
            lt.push(mt.x, mt.y, mt.z);
          break;
        case et.length - 1:
          lt.push(yt.x, yt.y, yt.z);
          break;
        default:
          (Et = et[xt + 1].x - et[xt].x),
            (pt = et[xt + 1].y - et[xt].y),
            (mt.x = pt * 1),
            (mt.y = -Et),
            (mt.z = pt * 0),
            vt.copy(mt),
            (mt.x += yt.x),
            (mt.y += yt.y),
            (mt.z += yt.z),
            mt.normalize(),
            lt.push(mt.x, mt.y, mt.z),
            yt.copy(vt);
      }
    for (let xt = 0; xt <= nt; xt++) {
      const St = rt + xt * ut * it,
        At = Math.sin(St),
        Ct = Math.cos(St);
      for (let Mt = 0; Mt <= et.length - 1; Mt++) {
        (ft.x = et[Mt].x * At),
          (ft.y = et[Mt].y),
          (ft.z = et[Mt].x * Ct),
          ot.push(ft.x, ft.y, ft.z),
          (ht.x = xt / nt),
          (ht.y = Mt / (et.length - 1)),
          at.push(ht.x, ht.y);
        const wt = lt[3 * Mt + 0] * At,
          Bt = lt[3 * Mt + 1],
          It = lt[3 * Mt + 0] * Ct;
        ct.push(wt, Bt, It);
      }
    }
    for (let xt = 0; xt < nt; xt++)
      for (let St = 0; St < et.length - 1; St++) {
        const At = St + xt * et.length,
          Ct = At,
          Mt = At + et.length,
          wt = At + et.length + 1,
          Bt = At + 1;
        st.push(Ct, Mt, Bt), st.push(wt, Bt, Mt);
      }
    this.setIndex(st),
      this.setAttribute("position", new Float32BufferAttribute(ot, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(at, 2)),
      this.setAttribute("normal", new Float32BufferAttribute(ct, 3));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new LatheGeometry(et.points, et.segments, et.phiStart, et.phiLength);
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(et = 1, nt = 1, rt = 4, it = 8) {
    const st = new Path();
    st.absarc(0, -nt / 2, et, Math.PI * 1.5, 0),
      st.absarc(0, nt / 2, et, 0, Math.PI * 0.5),
      super(st.getPoints(rt), it),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: et,
        length: nt,
        capSegments: rt,
        radialSegments: it,
      });
  }
  static fromJSON(et) {
    return new CapsuleGeometry(
      et.radius,
      et.length,
      et.capSegments,
      et.radialSegments
    );
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(et = 1, nt = 32, rt = 0, it = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: et,
        segments: nt,
        thetaStart: rt,
        thetaLength: it,
      }),
      (nt = Math.max(3, nt));
    const st = [],
      ot = [],
      at = [],
      lt = [],
      ct = new Vector3(),
      ut = new Vector2();
    ot.push(0, 0, 0), at.push(0, 0, 1), lt.push(0.5, 0.5);
    for (let ft = 0, ht = 3; ft <= nt; ft++, ht += 3) {
      const mt = rt + (ft / nt) * it;
      (ct.x = et * Math.cos(mt)),
        (ct.y = et * Math.sin(mt)),
        ot.push(ct.x, ct.y, ct.z),
        at.push(0, 0, 1),
        (ut.x = (ot[ht] / et + 1) / 2),
        (ut.y = (ot[ht + 1] / et + 1) / 2),
        lt.push(ut.x, ut.y);
    }
    for (let ft = 1; ft <= nt; ft++) st.push(ft, ft + 1, 0);
    this.setIndex(st),
      this.setAttribute("position", new Float32BufferAttribute(ot, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(at, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(lt, 2));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new CircleGeometry(
      et.radius,
      et.segments,
      et.thetaStart,
      et.thetaLength
    );
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    et = 1,
    nt = 1,
    rt = 1,
    it = 32,
    st = 1,
    ot = !1,
    at = 0,
    lt = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: et,
        radiusBottom: nt,
        height: rt,
        radialSegments: it,
        heightSegments: st,
        openEnded: ot,
        thetaStart: at,
        thetaLength: lt,
      });
    const ct = this;
    (it = Math.floor(it)), (st = Math.floor(st));
    const ut = [],
      ft = [],
      ht = [],
      mt = [];
    let vt = 0;
    const yt = [],
      Et = rt / 2;
    let pt = 0;
    xt(),
      ot === !1 && (et > 0 && St(!0), nt > 0 && St(!1)),
      this.setIndex(ut),
      this.setAttribute("position", new Float32BufferAttribute(ft, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ht, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(mt, 2));
    function xt() {
      const At = new Vector3(),
        Ct = new Vector3();
      let Mt = 0;
      const wt = (nt - et) / rt;
      for (let Bt = 0; Bt <= st; Bt++) {
        const It = [],
          Ft = Bt / st,
          Vt = Ft * (nt - et) + et;
        for (let $t = 0; $t <= it; $t++) {
          const Kt = $t / it,
            Ht = Kt * lt + at,
            Wt = Math.sin(Ht),
            kt = Math.cos(Ht);
          (Ct.x = Vt * Wt),
            (Ct.y = -Ft * rt + Et),
            (Ct.z = Vt * kt),
            ft.push(Ct.x, Ct.y, Ct.z),
            At.set(Wt, wt, kt).normalize(),
            ht.push(At.x, At.y, At.z),
            mt.push(Kt, 1 - Ft),
            It.push(vt++);
        }
        yt.push(It);
      }
      for (let Bt = 0; Bt < it; Bt++)
        for (let It = 0; It < st; It++) {
          const Ft = yt[It][Bt],
            Vt = yt[It + 1][Bt],
            $t = yt[It + 1][Bt + 1],
            Kt = yt[It][Bt + 1];
          ut.push(Ft, Vt, Kt), ut.push(Vt, $t, Kt), (Mt += 6);
        }
      ct.addGroup(pt, Mt, 0), (pt += Mt);
    }
    function St(At) {
      const Ct = vt,
        Mt = new Vector2(),
        wt = new Vector3();
      let Bt = 0;
      const It = At === !0 ? et : nt,
        Ft = At === !0 ? 1 : -1;
      for (let $t = 1; $t <= it; $t++)
        ft.push(0, Et * Ft, 0), ht.push(0, Ft, 0), mt.push(0.5, 0.5), vt++;
      const Vt = vt;
      for (let $t = 0; $t <= it; $t++) {
        const Ht = ($t / it) * lt + at,
          Wt = Math.cos(Ht),
          kt = Math.sin(Ht);
        (wt.x = It * kt),
          (wt.y = Et * Ft),
          (wt.z = It * Wt),
          ft.push(wt.x, wt.y, wt.z),
          ht.push(0, Ft, 0),
          (Mt.x = Wt * 0.5 + 0.5),
          (Mt.y = kt * 0.5 * Ft + 0.5),
          mt.push(Mt.x, Mt.y),
          vt++;
      }
      for (let $t = 0; $t < it; $t++) {
        const Kt = Ct + $t,
          Ht = Vt + $t;
        At === !0 ? ut.push(Ht, Ht + 1, Kt) : ut.push(Ht + 1, Ht, Kt),
          (Bt += 3);
      }
      ct.addGroup(pt, Bt, At === !0 ? 1 : 2), (pt += Bt);
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new CylinderGeometry(
      et.radiusTop,
      et.radiusBottom,
      et.height,
      et.radialSegments,
      et.heightSegments,
      et.openEnded,
      et.thetaStart,
      et.thetaLength
    );
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(
    et = 1,
    nt = 1,
    rt = 32,
    it = 1,
    st = !1,
    ot = 0,
    at = Math.PI * 2
  ) {
    super(0, et, nt, rt, it, st, ot, at),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: et,
        height: nt,
        radialSegments: rt,
        heightSegments: it,
        openEnded: st,
        thetaStart: ot,
        thetaLength: at,
      });
  }
  static fromJSON(et) {
    return new ConeGeometry(
      et.radius,
      et.height,
      et.radialSegments,
      et.heightSegments,
      et.openEnded,
      et.thetaStart,
      et.thetaLength
    );
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(et = [], nt = [], rt = 1, it = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: et, indices: nt, radius: rt, detail: it });
    const st = [],
      ot = [];
    at(it),
      ct(rt),
      ut(),
      this.setAttribute("position", new Float32BufferAttribute(st, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(st.slice(), 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ot, 2)),
      it === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function at(xt) {
      const St = new Vector3(),
        At = new Vector3(),
        Ct = new Vector3();
      for (let Mt = 0; Mt < nt.length; Mt += 3)
        mt(nt[Mt + 0], St),
          mt(nt[Mt + 1], At),
          mt(nt[Mt + 2], Ct),
          lt(St, At, Ct, xt);
    }
    function lt(xt, St, At, Ct) {
      const Mt = Ct + 1,
        wt = [];
      for (let Bt = 0; Bt <= Mt; Bt++) {
        wt[Bt] = [];
        const It = xt.clone().lerp(At, Bt / Mt),
          Ft = St.clone().lerp(At, Bt / Mt),
          Vt = Mt - Bt;
        for (let $t = 0; $t <= Vt; $t++)
          $t === 0 && Bt === Mt
            ? (wt[Bt][$t] = It)
            : (wt[Bt][$t] = It.clone().lerp(Ft, $t / Vt));
      }
      for (let Bt = 0; Bt < Mt; Bt++)
        for (let It = 0; It < 2 * (Mt - Bt) - 1; It++) {
          const Ft = Math.floor(It / 2);
          It % 2 === 0
            ? (ht(wt[Bt][Ft + 1]), ht(wt[Bt + 1][Ft]), ht(wt[Bt][Ft]))
            : (ht(wt[Bt][Ft + 1]), ht(wt[Bt + 1][Ft + 1]), ht(wt[Bt + 1][Ft]));
        }
    }
    function ct(xt) {
      const St = new Vector3();
      for (let At = 0; At < st.length; At += 3)
        (St.x = st[At + 0]),
          (St.y = st[At + 1]),
          (St.z = st[At + 2]),
          St.normalize().multiplyScalar(xt),
          (st[At + 0] = St.x),
          (st[At + 1] = St.y),
          (st[At + 2] = St.z);
    }
    function ut() {
      const xt = new Vector3();
      for (let St = 0; St < st.length; St += 3) {
        (xt.x = st[St + 0]), (xt.y = st[St + 1]), (xt.z = st[St + 2]);
        const At = Et(xt) / 2 / Math.PI + 0.5,
          Ct = pt(xt) / Math.PI + 0.5;
        ot.push(At, 1 - Ct);
      }
      vt(), ft();
    }
    function ft() {
      for (let xt = 0; xt < ot.length; xt += 6) {
        const St = ot[xt + 0],
          At = ot[xt + 2],
          Ct = ot[xt + 4],
          Mt = Math.max(St, At, Ct),
          wt = Math.min(St, At, Ct);
        Mt > 0.9 &&
          wt < 0.1 &&
          (St < 0.2 && (ot[xt + 0] += 1),
          At < 0.2 && (ot[xt + 2] += 1),
          Ct < 0.2 && (ot[xt + 4] += 1));
      }
    }
    function ht(xt) {
      st.push(xt.x, xt.y, xt.z);
    }
    function mt(xt, St) {
      const At = xt * 3;
      (St.x = et[At + 0]), (St.y = et[At + 1]), (St.z = et[At + 2]);
    }
    function vt() {
      const xt = new Vector3(),
        St = new Vector3(),
        At = new Vector3(),
        Ct = new Vector3(),
        Mt = new Vector2(),
        wt = new Vector2(),
        Bt = new Vector2();
      for (let It = 0, Ft = 0; It < st.length; It += 9, Ft += 6) {
        xt.set(st[It + 0], st[It + 1], st[It + 2]),
          St.set(st[It + 3], st[It + 4], st[It + 5]),
          At.set(st[It + 6], st[It + 7], st[It + 8]),
          Mt.set(ot[Ft + 0], ot[Ft + 1]),
          wt.set(ot[Ft + 2], ot[Ft + 3]),
          Bt.set(ot[Ft + 4], ot[Ft + 5]),
          Ct.copy(xt).add(St).add(At).divideScalar(3);
        const Vt = Et(Ct);
        yt(Mt, Ft + 0, xt, Vt), yt(wt, Ft + 2, St, Vt), yt(Bt, Ft + 4, At, Vt);
      }
    }
    function yt(xt, St, At, Ct) {
      Ct < 0 && xt.x === 1 && (ot[St] = xt.x - 1),
        At.x === 0 && At.z === 0 && (ot[St] = Ct / 2 / Math.PI + 0.5);
    }
    function Et(xt) {
      return Math.atan2(xt.z, -xt.x);
    }
    function pt(xt) {
      return Math.atan2(-xt.y, Math.sqrt(xt.x * xt.x + xt.z * xt.z));
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new PolyhedronGeometry(
      et.vertices,
      et.indices,
      et.radius,
      et.details
    );
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(et = 1, nt = 0) {
    const rt = (1 + Math.sqrt(5)) / 2,
      it = 1 / rt,
      st = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -it,
        -rt,
        0,
        -it,
        rt,
        0,
        it,
        -rt,
        0,
        it,
        rt,
        -it,
        -rt,
        0,
        -it,
        rt,
        0,
        it,
        -rt,
        0,
        it,
        rt,
        0,
        -rt,
        0,
        -it,
        rt,
        0,
        -it,
        -rt,
        0,
        it,
        rt,
        0,
        it,
      ],
      ot = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(st, ot, et, nt),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: et, detail: nt });
  }
  static fromJSON(et) {
    return new DodecahedronGeometry(et.radius, et.detail);
  }
}
const _v0 = new Vector3(),
  _v1$1 = new Vector3(),
  _normal = new Vector3(),
  _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(et = null, nt = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: et, thresholdAngle: nt }),
      et !== null)
    ) {
      const it = Math.pow(10, 4),
        st = Math.cos(DEG2RAD * nt),
        ot = et.getIndex(),
        at = et.getAttribute("position"),
        lt = ot ? ot.count : at.count,
        ct = [0, 0, 0],
        ut = ["a", "b", "c"],
        ft = new Array(3),
        ht = {},
        mt = [];
      for (let vt = 0; vt < lt; vt += 3) {
        ot
          ? ((ct[0] = ot.getX(vt)),
            (ct[1] = ot.getX(vt + 1)),
            (ct[2] = ot.getX(vt + 2)))
          : ((ct[0] = vt), (ct[1] = vt + 1), (ct[2] = vt + 2));
        const { a: yt, b: Et, c: pt } = _triangle;
        if (
          (yt.fromBufferAttribute(at, ct[0]),
          Et.fromBufferAttribute(at, ct[1]),
          pt.fromBufferAttribute(at, ct[2]),
          _triangle.getNormal(_normal),
          (ft[0] = `${Math.round(yt.x * it)},${Math.round(
            yt.y * it
          )},${Math.round(yt.z * it)}`),
          (ft[1] = `${Math.round(Et.x * it)},${Math.round(
            Et.y * it
          )},${Math.round(Et.z * it)}`),
          (ft[2] = `${Math.round(pt.x * it)},${Math.round(
            pt.y * it
          )},${Math.round(pt.z * it)}`),
          !(ft[0] === ft[1] || ft[1] === ft[2] || ft[2] === ft[0]))
        )
          for (let xt = 0; xt < 3; xt++) {
            const St = (xt + 1) % 3,
              At = ft[xt],
              Ct = ft[St],
              Mt = _triangle[ut[xt]],
              wt = _triangle[ut[St]],
              Bt = `${At}_${Ct}`,
              It = `${Ct}_${At}`;
            It in ht && ht[It]
              ? (_normal.dot(ht[It].normal) <= st &&
                  (mt.push(Mt.x, Mt.y, Mt.z), mt.push(wt.x, wt.y, wt.z)),
                (ht[It] = null))
              : Bt in ht ||
                (ht[Bt] = {
                  index0: ct[xt],
                  index1: ct[St],
                  normal: _normal.clone(),
                });
          }
      }
      for (const vt in ht)
        if (ht[vt]) {
          const { index0: yt, index1: Et } = ht[vt];
          _v0.fromBufferAttribute(at, yt),
            _v1$1.fromBufferAttribute(at, Et),
            mt.push(_v0.x, _v0.y, _v0.z),
            mt.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      this.setAttribute("position", new Float32BufferAttribute(mt, 3));
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
}
class Shape extends Path {
  constructor(et) {
    super(et),
      (this.uuid = generateUUID$1()),
      (this.type = "Shape"),
      (this.holes = []);
  }
  getPointsHoles(et) {
    const nt = [];
    for (let rt = 0, it = this.holes.length; rt < it; rt++)
      nt[rt] = this.holes[rt].getPoints(et);
    return nt;
  }
  extractPoints(et) {
    return { shape: this.getPoints(et), holes: this.getPointsHoles(et) };
  }
  copy(et) {
    super.copy(et), (this.holes = []);
    for (let nt = 0, rt = et.holes.length; nt < rt; nt++) {
      const it = et.holes[nt];
      this.holes.push(it.clone());
    }
    return this;
  }
  toJSON() {
    const et = super.toJSON();
    (et.uuid = this.uuid), (et.holes = []);
    for (let nt = 0, rt = this.holes.length; nt < rt; nt++) {
      const it = this.holes[nt];
      et.holes.push(it.toJSON());
    }
    return et;
  }
  fromJSON(et) {
    super.fromJSON(et), (this.uuid = et.uuid), (this.holes = []);
    for (let nt = 0, rt = et.holes.length; nt < rt; nt++) {
      const it = et.holes[nt];
      this.holes.push(new Path().fromJSON(it));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function (tt, et, nt = 2) {
    const rt = et && et.length,
      it = rt ? et[0] * nt : tt.length;
    let st = linkedList(tt, 0, it, nt, !0);
    const ot = [];
    if (!st || st.next === st.prev) return ot;
    let at, lt, ct, ut, ft, ht, mt;
    if ((rt && (st = eliminateHoles(tt, et, st, nt)), tt.length > 80 * nt)) {
      (at = ct = tt[0]), (lt = ut = tt[1]);
      for (let vt = nt; vt < it; vt += nt)
        (ft = tt[vt]),
          (ht = tt[vt + 1]),
          ft < at && (at = ft),
          ht < lt && (lt = ht),
          ft > ct && (ct = ft),
          ht > ut && (ut = ht);
      (mt = Math.max(ct - at, ut - lt)), (mt = mt !== 0 ? 32767 / mt : 0);
    }
    return earcutLinked(st, ot, nt, at, lt, mt, 0), ot;
  },
};
function linkedList(tt, et, nt, rt, it) {
  let st, ot;
  if (it === signedArea(tt, et, nt, rt) > 0)
    for (st = et; st < nt; st += rt)
      ot = insertNode(st, tt[st], tt[st + 1], ot);
  else
    for (st = nt - rt; st >= et; st -= rt)
      ot = insertNode(st, tt[st], tt[st + 1], ot);
  return ot && equals(ot, ot.next) && (removeNode(ot), (ot = ot.next)), ot;
}
function filterPoints(tt, et) {
  if (!tt) return tt;
  et || (et = tt);
  let nt = tt,
    rt;
  do
    if (
      ((rt = !1),
      !nt.steiner && (equals(nt, nt.next) || area(nt.prev, nt, nt.next) === 0))
    ) {
      if ((removeNode(nt), (nt = et = nt.prev), nt === nt.next)) break;
      rt = !0;
    } else nt = nt.next;
  while (rt || nt !== et);
  return et;
}
function earcutLinked(tt, et, nt, rt, it, st, ot) {
  if (!tt) return;
  !ot && st && indexCurve(tt, rt, it, st);
  let at = tt,
    lt,
    ct;
  for (; tt.prev !== tt.next; ) {
    if (
      ((lt = tt.prev),
      (ct = tt.next),
      st ? isEarHashed(tt, rt, it, st) : isEar(tt))
    ) {
      et.push((lt.i / nt) | 0),
        et.push((tt.i / nt) | 0),
        et.push((ct.i / nt) | 0),
        removeNode(tt),
        (tt = ct.next),
        (at = ct.next);
      continue;
    }
    if (((tt = ct), tt === at)) {
      ot
        ? ot === 1
          ? ((tt = cureLocalIntersections(filterPoints(tt), et, nt)),
            earcutLinked(tt, et, nt, rt, it, st, 2))
          : ot === 2 && splitEarcut(tt, et, nt, rt, it, st)
        : earcutLinked(filterPoints(tt), et, nt, rt, it, st, 1);
      break;
    }
  }
}
function isEar(tt) {
  const et = tt.prev,
    nt = tt,
    rt = tt.next;
  if (area(et, nt, rt) >= 0) return !1;
  const it = et.x,
    st = nt.x,
    ot = rt.x,
    at = et.y,
    lt = nt.y,
    ct = rt.y,
    ut = it < st ? (it < ot ? it : ot) : st < ot ? st : ot,
    ft = at < lt ? (at < ct ? at : ct) : lt < ct ? lt : ct,
    ht = it > st ? (it > ot ? it : ot) : st > ot ? st : ot,
    mt = at > lt ? (at > ct ? at : ct) : lt > ct ? lt : ct;
  let vt = rt.next;
  for (; vt !== et; ) {
    if (
      vt.x >= ut &&
      vt.x <= ht &&
      vt.y >= ft &&
      vt.y <= mt &&
      pointInTriangle(it, at, st, lt, ot, ct, vt.x, vt.y) &&
      area(vt.prev, vt, vt.next) >= 0
    )
      return !1;
    vt = vt.next;
  }
  return !0;
}
function isEarHashed(tt, et, nt, rt) {
  const it = tt.prev,
    st = tt,
    ot = tt.next;
  if (area(it, st, ot) >= 0) return !1;
  const at = it.x,
    lt = st.x,
    ct = ot.x,
    ut = it.y,
    ft = st.y,
    ht = ot.y,
    mt = at < lt ? (at < ct ? at : ct) : lt < ct ? lt : ct,
    vt = ut < ft ? (ut < ht ? ut : ht) : ft < ht ? ft : ht,
    yt = at > lt ? (at > ct ? at : ct) : lt > ct ? lt : ct,
    Et = ut > ft ? (ut > ht ? ut : ht) : ft > ht ? ft : ht,
    pt = zOrder(mt, vt, et, nt, rt),
    xt = zOrder(yt, Et, et, nt, rt);
  let St = tt.prevZ,
    At = tt.nextZ;
  for (; St && St.z >= pt && At && At.z <= xt; ) {
    if (
      (St.x >= mt &&
        St.x <= yt &&
        St.y >= vt &&
        St.y <= Et &&
        St !== it &&
        St !== ot &&
        pointInTriangle(at, ut, lt, ft, ct, ht, St.x, St.y) &&
        area(St.prev, St, St.next) >= 0) ||
      ((St = St.prevZ),
      At.x >= mt &&
        At.x <= yt &&
        At.y >= vt &&
        At.y <= Et &&
        At !== it &&
        At !== ot &&
        pointInTriangle(at, ut, lt, ft, ct, ht, At.x, At.y) &&
        area(At.prev, At, At.next) >= 0)
    )
      return !1;
    At = At.nextZ;
  }
  for (; St && St.z >= pt; ) {
    if (
      St.x >= mt &&
      St.x <= yt &&
      St.y >= vt &&
      St.y <= Et &&
      St !== it &&
      St !== ot &&
      pointInTriangle(at, ut, lt, ft, ct, ht, St.x, St.y) &&
      area(St.prev, St, St.next) >= 0
    )
      return !1;
    St = St.prevZ;
  }
  for (; At && At.z <= xt; ) {
    if (
      At.x >= mt &&
      At.x <= yt &&
      At.y >= vt &&
      At.y <= Et &&
      At !== it &&
      At !== ot &&
      pointInTriangle(at, ut, lt, ft, ct, ht, At.x, At.y) &&
      area(At.prev, At, At.next) >= 0
    )
      return !1;
    At = At.nextZ;
  }
  return !0;
}
function cureLocalIntersections(tt, et, nt) {
  let rt = tt;
  do {
    const it = rt.prev,
      st = rt.next.next;
    !equals(it, st) &&
      intersects(it, rt, rt.next, st) &&
      locallyInside(it, st) &&
      locallyInside(st, it) &&
      (et.push((it.i / nt) | 0),
      et.push((rt.i / nt) | 0),
      et.push((st.i / nt) | 0),
      removeNode(rt),
      removeNode(rt.next),
      (rt = tt = st)),
      (rt = rt.next);
  } while (rt !== tt);
  return filterPoints(rt);
}
function splitEarcut(tt, et, nt, rt, it, st) {
  let ot = tt;
  do {
    let at = ot.next.next;
    for (; at !== ot.prev; ) {
      if (ot.i !== at.i && isValidDiagonal(ot, at)) {
        let lt = splitPolygon(ot, at);
        (ot = filterPoints(ot, ot.next)),
          (lt = filterPoints(lt, lt.next)),
          earcutLinked(ot, et, nt, rt, it, st, 0),
          earcutLinked(lt, et, nt, rt, it, st, 0);
        return;
      }
      at = at.next;
    }
    ot = ot.next;
  } while (ot !== tt);
}
function eliminateHoles(tt, et, nt, rt) {
  const it = [];
  let st, ot, at, lt, ct;
  for (st = 0, ot = et.length; st < ot; st++)
    (at = et[st] * rt),
      (lt = st < ot - 1 ? et[st + 1] * rt : tt.length),
      (ct = linkedList(tt, at, lt, rt, !1)),
      ct === ct.next && (ct.steiner = !0),
      it.push(getLeftmost(ct));
  for (it.sort(compareX), st = 0; st < it.length; st++)
    nt = eliminateHole(it[st], nt);
  return nt;
}
function compareX(tt, et) {
  return tt.x - et.x;
}
function eliminateHole(tt, et) {
  const nt = findHoleBridge(tt, et);
  if (!nt) return et;
  const rt = splitPolygon(nt, tt);
  return filterPoints(rt, rt.next), filterPoints(nt, nt.next);
}
function findHoleBridge(tt, et) {
  let nt = et,
    rt = -1 / 0,
    it;
  const st = tt.x,
    ot = tt.y;
  do {
    if (ot <= nt.y && ot >= nt.next.y && nt.next.y !== nt.y) {
      const ht = nt.x + ((ot - nt.y) * (nt.next.x - nt.x)) / (nt.next.y - nt.y);
      if (
        ht <= st &&
        ht > rt &&
        ((rt = ht), (it = nt.x < nt.next.x ? nt : nt.next), ht === st)
      )
        return it;
    }
    nt = nt.next;
  } while (nt !== et);
  if (!it) return null;
  const at = it,
    lt = it.x,
    ct = it.y;
  let ut = 1 / 0,
    ft;
  nt = it;
  do
    st >= nt.x &&
      nt.x >= lt &&
      st !== nt.x &&
      pointInTriangle(
        ot < ct ? st : rt,
        ot,
        lt,
        ct,
        ot < ct ? rt : st,
        ot,
        nt.x,
        nt.y
      ) &&
      ((ft = Math.abs(ot - nt.y) / (st - nt.x)),
      locallyInside(nt, tt) &&
        (ft < ut ||
          (ft === ut &&
            (nt.x > it.x ||
              (nt.x === it.x && sectorContainsSector(it, nt))))) &&
        ((it = nt), (ut = ft))),
      (nt = nt.next);
  while (nt !== at);
  return it;
}
function sectorContainsSector(tt, et) {
  return area(tt.prev, tt, et.prev) < 0 && area(et.next, tt, tt.next) < 0;
}
function indexCurve(tt, et, nt, rt) {
  let it = tt;
  do
    it.z === 0 && (it.z = zOrder(it.x, it.y, et, nt, rt)),
      (it.prevZ = it.prev),
      (it.nextZ = it.next),
      (it = it.next);
  while (it !== tt);
  (it.prevZ.nextZ = null), (it.prevZ = null), sortLinked(it);
}
function sortLinked(tt) {
  let et,
    nt,
    rt,
    it,
    st,
    ot,
    at,
    lt,
    ct = 1;
  do {
    for (nt = tt, tt = null, st = null, ot = 0; nt; ) {
      for (
        ot++, rt = nt, at = 0, et = 0;
        et < ct && (at++, (rt = rt.nextZ), !!rt);
        et++
      );
      for (lt = ct; at > 0 || (lt > 0 && rt); )
        at !== 0 && (lt === 0 || !rt || nt.z <= rt.z)
          ? ((it = nt), (nt = nt.nextZ), at--)
          : ((it = rt), (rt = rt.nextZ), lt--),
          st ? (st.nextZ = it) : (tt = it),
          (it.prevZ = st),
          (st = it);
      nt = rt;
    }
    (st.nextZ = null), (ct *= 2);
  } while (ot > 1);
  return tt;
}
function zOrder(tt, et, nt, rt, it) {
  return (
    (tt = ((tt - nt) * it) | 0),
    (et = ((et - rt) * it) | 0),
    (tt = (tt | (tt << 8)) & 16711935),
    (tt = (tt | (tt << 4)) & 252645135),
    (tt = (tt | (tt << 2)) & 858993459),
    (tt = (tt | (tt << 1)) & 1431655765),
    (et = (et | (et << 8)) & 16711935),
    (et = (et | (et << 4)) & 252645135),
    (et = (et | (et << 2)) & 858993459),
    (et = (et | (et << 1)) & 1431655765),
    tt | (et << 1)
  );
}
function getLeftmost(tt) {
  let et = tt,
    nt = tt;
  do
    (et.x < nt.x || (et.x === nt.x && et.y < nt.y)) && (nt = et),
      (et = et.next);
  while (et !== tt);
  return nt;
}
function pointInTriangle(tt, et, nt, rt, it, st, ot, at) {
  return (
    (it - ot) * (et - at) >= (tt - ot) * (st - at) &&
    (tt - ot) * (rt - at) >= (nt - ot) * (et - at) &&
    (nt - ot) * (st - at) >= (it - ot) * (rt - at)
  );
}
function isValidDiagonal(tt, et) {
  return (
    tt.next.i !== et.i &&
    tt.prev.i !== et.i &&
    !intersectsPolygon(tt, et) &&
    ((locallyInside(tt, et) &&
      locallyInside(et, tt) &&
      middleInside(tt, et) &&
      (area(tt.prev, tt, et.prev) || area(tt, et.prev, et))) ||
      (equals(tt, et) &&
        area(tt.prev, tt, tt.next) > 0 &&
        area(et.prev, et, et.next) > 0))
  );
}
function area(tt, et, nt) {
  return (et.y - tt.y) * (nt.x - et.x) - (et.x - tt.x) * (nt.y - et.y);
}
function equals(tt, et) {
  return tt.x === et.x && tt.y === et.y;
}
function intersects(tt, et, nt, rt) {
  const it = sign(area(tt, et, nt)),
    st = sign(area(tt, et, rt)),
    ot = sign(area(nt, rt, tt)),
    at = sign(area(nt, rt, et));
  return !!(
    (it !== st && ot !== at) ||
    (it === 0 && onSegment(tt, nt, et)) ||
    (st === 0 && onSegment(tt, rt, et)) ||
    (ot === 0 && onSegment(nt, tt, rt)) ||
    (at === 0 && onSegment(nt, et, rt))
  );
}
function onSegment(tt, et, nt) {
  return (
    et.x <= Math.max(tt.x, nt.x) &&
    et.x >= Math.min(tt.x, nt.x) &&
    et.y <= Math.max(tt.y, nt.y) &&
    et.y >= Math.min(tt.y, nt.y)
  );
}
function sign(tt) {
  return tt > 0 ? 1 : tt < 0 ? -1 : 0;
}
function intersectsPolygon(tt, et) {
  let nt = tt;
  do {
    if (
      nt.i !== tt.i &&
      nt.next.i !== tt.i &&
      nt.i !== et.i &&
      nt.next.i !== et.i &&
      intersects(nt, nt.next, tt, et)
    )
      return !0;
    nt = nt.next;
  } while (nt !== tt);
  return !1;
}
function locallyInside(tt, et) {
  return area(tt.prev, tt, tt.next) < 0
    ? area(tt, et, tt.next) >= 0 && area(tt, tt.prev, et) >= 0
    : area(tt, et, tt.prev) < 0 || area(tt, tt.next, et) < 0;
}
function middleInside(tt, et) {
  let nt = tt,
    rt = !1;
  const it = (tt.x + et.x) / 2,
    st = (tt.y + et.y) / 2;
  do
    nt.y > st != nt.next.y > st &&
      nt.next.y !== nt.y &&
      it < ((nt.next.x - nt.x) * (st - nt.y)) / (nt.next.y - nt.y) + nt.x &&
      (rt = !rt),
      (nt = nt.next);
  while (nt !== tt);
  return rt;
}
function splitPolygon(tt, et) {
  const nt = new Node(tt.i, tt.x, tt.y),
    rt = new Node(et.i, et.x, et.y),
    it = tt.next,
    st = et.prev;
  return (
    (tt.next = et),
    (et.prev = tt),
    (nt.next = it),
    (it.prev = nt),
    (rt.next = nt),
    (nt.prev = rt),
    (st.next = rt),
    (rt.prev = st),
    rt
  );
}
function insertNode(tt, et, nt, rt) {
  const it = new Node(tt, et, nt);
  return (
    rt
      ? ((it.next = rt.next),
        (it.prev = rt),
        (rt.next.prev = it),
        (rt.next = it))
      : ((it.prev = it), (it.next = it)),
    it
  );
}
function removeNode(tt) {
  (tt.next.prev = tt.prev),
    (tt.prev.next = tt.next),
    tt.prevZ && (tt.prevZ.nextZ = tt.nextZ),
    tt.nextZ && (tt.nextZ.prevZ = tt.prevZ);
}
function Node(tt, et, nt) {
  (this.i = tt),
    (this.x = et),
    (this.y = nt),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function signedArea(tt, et, nt, rt) {
  let it = 0;
  for (let st = et, ot = nt - rt; st < nt; st += rt)
    (it += (tt[ot] - tt[st]) * (tt[st + 1] + tt[ot + 1])), (ot = st);
  return it;
}
class ShapeUtils {
  static area(et) {
    const nt = et.length;
    let rt = 0;
    for (let it = nt - 1, st = 0; st < nt; it = st++)
      rt += et[it].x * et[st].y - et[st].x * et[it].y;
    return rt * 0.5;
  }
  static isClockWise(et) {
    return ShapeUtils.area(et) < 0;
  }
  static triangulateShape(et, nt) {
    const rt = [],
      it = [],
      st = [];
    removeDupEndPts(et), addContour(rt, et);
    let ot = et.length;
    nt.forEach(removeDupEndPts);
    for (let lt = 0; lt < nt.length; lt++)
      it.push(ot), (ot += nt[lt].length), addContour(rt, nt[lt]);
    const at = Earcut.triangulate(rt, it);
    for (let lt = 0; lt < at.length; lt += 3) st.push(at.slice(lt, lt + 3));
    return st;
  }
}
function removeDupEndPts(tt) {
  const et = tt.length;
  et > 2 && tt[et - 1].equals(tt[0]) && tt.pop();
}
function addContour(tt, et) {
  for (let nt = 0; nt < et.length; nt++) tt.push(et[nt].x), tt.push(et[nt].y);
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    et = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    nt = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: et, options: nt }),
      (et = Array.isArray(et) ? et : [et]);
    const rt = this,
      it = [],
      st = [];
    for (let at = 0, lt = et.length; at < lt; at++) {
      const ct = et[at];
      ot(ct);
    }
    this.setAttribute("position", new Float32BufferAttribute(it, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(st, 2)),
      this.computeVertexNormals();
    function ot(at) {
      const lt = [],
        ct = nt.curveSegments !== void 0 ? nt.curveSegments : 12,
        ut = nt.steps !== void 0 ? nt.steps : 1,
        ft = nt.depth !== void 0 ? nt.depth : 1;
      let ht = nt.bevelEnabled !== void 0 ? nt.bevelEnabled : !0,
        mt = nt.bevelThickness !== void 0 ? nt.bevelThickness : 0.2,
        vt = nt.bevelSize !== void 0 ? nt.bevelSize : mt - 0.1,
        yt = nt.bevelOffset !== void 0 ? nt.bevelOffset : 0,
        Et = nt.bevelSegments !== void 0 ? nt.bevelSegments : 3;
      const pt = nt.extrudePath,
        xt = nt.UVGenerator !== void 0 ? nt.UVGenerator : WorldUVGenerator;
      let St,
        At = !1,
        Ct,
        Mt,
        wt,
        Bt;
      pt &&
        ((St = pt.getSpacedPoints(ut)),
        (At = !0),
        (ht = !1),
        (Ct = pt.computeFrenetFrames(ut, !1)),
        (Mt = new Vector3()),
        (wt = new Vector3()),
        (Bt = new Vector3())),
        ht || ((Et = 0), (mt = 0), (vt = 0), (yt = 0));
      const It = at.extractPoints(ct);
      let Ft = It.shape;
      const Vt = It.holes;
      if (!ShapeUtils.isClockWise(Ft)) {
        Ft = Ft.reverse();
        for (let jt = 0, yn = Vt.length; jt < yn; jt++) {
          const pn = Vt[jt];
          ShapeUtils.isClockWise(pn) && (Vt[jt] = pn.reverse());
        }
      }
      const Kt = ShapeUtils.triangulateShape(Ft, Vt),
        Ht = Ft;
      for (let jt = 0, yn = Vt.length; jt < yn; jt++) {
        const pn = Vt[jt];
        Ft = Ft.concat(pn);
      }
      function Wt(jt, yn, pn) {
        return (
          yn || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          jt.clone().addScaledVector(yn, pn)
        );
      }
      const kt = Ft.length,
        Gt = Kt.length;
      function Pt(jt, yn, pn) {
        let vn, xn, Fn;
        const _n = jt.x - yn.x,
          Dn = jt.y - yn.y,
          Tn = pn.x - jt.x,
          An = pn.y - jt.y,
          Wn = _n * _n + Dn * Dn,
          Xt = _n * An - Dn * Tn;
        if (Math.abs(Xt) > Number.EPSILON) {
          const Ut = Math.sqrt(Wn),
            hn = Math.sqrt(Tn * Tn + An * An),
            Ln = yn.x - Dn / Ut,
            Cn = yn.y + _n / Ut,
            Mn = pn.x - An / hn,
            kn = pn.y + Tn / hn,
            Vn = ((Mn - Ln) * An - (kn - Cn) * Tn) / (_n * An - Dn * Tn);
          (vn = Ln + _n * Vn - jt.x), (xn = Cn + Dn * Vn - jt.y);
          const Kn = vn * vn + xn * xn;
          if (Kn <= 2) return new Vector2(vn, xn);
          Fn = Math.sqrt(Kn / 2);
        } else {
          let Ut = !1;
          _n > Number.EPSILON
            ? Tn > Number.EPSILON && (Ut = !0)
            : _n < -Number.EPSILON
            ? Tn < -Number.EPSILON && (Ut = !0)
            : Math.sign(Dn) === Math.sign(An) && (Ut = !0),
            Ut
              ? ((vn = -Dn), (xn = _n), (Fn = Math.sqrt(Wn)))
              : ((vn = _n), (xn = Dn), (Fn = Math.sqrt(Wn / 2)));
        }
        return new Vector2(vn / Fn, xn / Fn);
      }
      const Rt = [];
      for (
        let jt = 0, yn = Ht.length, pn = yn - 1, vn = jt + 1;
        jt < yn;
        jt++, pn++, vn++
      )
        pn === yn && (pn = 0),
          vn === yn && (vn = 0),
          (Rt[jt] = Pt(Ht[jt], Ht[pn], Ht[vn]));
      const Nt = [];
      let Dt,
        zt = Rt.concat();
      for (let jt = 0, yn = Vt.length; jt < yn; jt++) {
        const pn = Vt[jt];
        Dt = [];
        for (
          let vn = 0, xn = pn.length, Fn = xn - 1, _n = vn + 1;
          vn < xn;
          vn++, Fn++, _n++
        )
          Fn === xn && (Fn = 0),
            _n === xn && (_n = 0),
            (Dt[vn] = Pt(pn[vn], pn[Fn], pn[_n]));
        Nt.push(Dt), (zt = zt.concat(Dt));
      }
      for (let jt = 0; jt < Et; jt++) {
        const yn = jt / Et,
          pn = mt * Math.cos((yn * Math.PI) / 2),
          vn = vt * Math.sin((yn * Math.PI) / 2) + yt;
        for (let xn = 0, Fn = Ht.length; xn < Fn; xn++) {
          const _n = Wt(Ht[xn], Rt[xn], vn);
          mn(_n.x, _n.y, -pn);
        }
        for (let xn = 0, Fn = Vt.length; xn < Fn; xn++) {
          const _n = Vt[xn];
          Dt = Nt[xn];
          for (let Dn = 0, Tn = _n.length; Dn < Tn; Dn++) {
            const An = Wt(_n[Dn], Dt[Dn], vn);
            mn(An.x, An.y, -pn);
          }
        }
      }
      const Yt = vt + yt;
      for (let jt = 0; jt < kt; jt++) {
        const yn = ht ? Wt(Ft[jt], zt[jt], Yt) : Ft[jt];
        At
          ? (wt.copy(Ct.normals[0]).multiplyScalar(yn.x),
            Mt.copy(Ct.binormals[0]).multiplyScalar(yn.y),
            Bt.copy(St[0]).add(wt).add(Mt),
            mn(Bt.x, Bt.y, Bt.z))
          : mn(yn.x, yn.y, 0);
      }
      for (let jt = 1; jt <= ut; jt++)
        for (let yn = 0; yn < kt; yn++) {
          const pn = ht ? Wt(Ft[yn], zt[yn], Yt) : Ft[yn];
          At
            ? (wt.copy(Ct.normals[jt]).multiplyScalar(pn.x),
              Mt.copy(Ct.binormals[jt]).multiplyScalar(pn.y),
              Bt.copy(St[jt]).add(wt).add(Mt),
              mn(Bt.x, Bt.y, Bt.z))
            : mn(pn.x, pn.y, (ft / ut) * jt);
        }
      for (let jt = Et - 1; jt >= 0; jt--) {
        const yn = jt / Et,
          pn = mt * Math.cos((yn * Math.PI) / 2),
          vn = vt * Math.sin((yn * Math.PI) / 2) + yt;
        for (let xn = 0, Fn = Ht.length; xn < Fn; xn++) {
          const _n = Wt(Ht[xn], Rt[xn], vn);
          mn(_n.x, _n.y, ft + pn);
        }
        for (let xn = 0, Fn = Vt.length; xn < Fn; xn++) {
          const _n = Vt[xn];
          Dt = Nt[xn];
          for (let Dn = 0, Tn = _n.length; Dn < Tn; Dn++) {
            const An = Wt(_n[Dn], Dt[Dn], vn);
            At
              ? mn(An.x, An.y + St[ut - 1].y, St[ut - 1].x + pn)
              : mn(An.x, An.y, ft + pn);
          }
        }
      }
      qt(), Zt();
      function qt() {
        const jt = it.length / 3;
        if (ht) {
          let yn = 0,
            pn = kt * yn;
          for (let vn = 0; vn < Gt; vn++) {
            const xn = Kt[vn];
            ln(xn[2] + pn, xn[1] + pn, xn[0] + pn);
          }
          (yn = ut + Et * 2), (pn = kt * yn);
          for (let vn = 0; vn < Gt; vn++) {
            const xn = Kt[vn];
            ln(xn[0] + pn, xn[1] + pn, xn[2] + pn);
          }
        } else {
          for (let yn = 0; yn < Gt; yn++) {
            const pn = Kt[yn];
            ln(pn[2], pn[1], pn[0]);
          }
          for (let yn = 0; yn < Gt; yn++) {
            const pn = Kt[yn];
            ln(pn[0] + kt * ut, pn[1] + kt * ut, pn[2] + kt * ut);
          }
        }
        rt.addGroup(jt, it.length / 3 - jt, 0);
      }
      function Zt() {
        const jt = it.length / 3;
        let yn = 0;
        Jt(Ht, yn), (yn += Ht.length);
        for (let pn = 0, vn = Vt.length; pn < vn; pn++) {
          const xn = Vt[pn];
          Jt(xn, yn), (yn += xn.length);
        }
        rt.addGroup(jt, it.length / 3 - jt, 1);
      }
      function Jt(jt, yn) {
        let pn = jt.length;
        for (; --pn >= 0; ) {
          const vn = pn;
          let xn = pn - 1;
          xn < 0 && (xn = jt.length - 1);
          for (let Fn = 0, _n = ut + Et * 2; Fn < _n; Fn++) {
            const Dn = kt * Fn,
              Tn = kt * (Fn + 1),
              An = yn + vn + Dn,
              Wn = yn + xn + Dn,
              Xt = yn + xn + Tn,
              Ut = yn + vn + Tn;
            bn(An, Wn, Xt, Ut);
          }
        }
      }
      function mn(jt, yn, pn) {
        lt.push(jt), lt.push(yn), lt.push(pn);
      }
      function ln(jt, yn, pn) {
        Bn(jt), Bn(yn), Bn(pn);
        const vn = it.length / 3,
          xn = xt.generateTopUV(rt, it, vn - 3, vn - 2, vn - 1);
        gn(xn[0]), gn(xn[1]), gn(xn[2]);
      }
      function bn(jt, yn, pn, vn) {
        Bn(jt), Bn(yn), Bn(vn), Bn(yn), Bn(pn), Bn(vn);
        const xn = it.length / 3,
          Fn = xt.generateSideWallUV(rt, it, xn - 6, xn - 3, xn - 2, xn - 1);
        gn(Fn[0]), gn(Fn[1]), gn(Fn[3]), gn(Fn[1]), gn(Fn[2]), gn(Fn[3]);
      }
      function Bn(jt) {
        it.push(lt[jt * 3 + 0]),
          it.push(lt[jt * 3 + 1]),
          it.push(lt[jt * 3 + 2]);
      }
      function gn(jt) {
        st.push(jt.x), st.push(jt.y);
      }
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  toJSON() {
    const et = super.toJSON(),
      nt = this.parameters.shapes,
      rt = this.parameters.options;
    return toJSON$1(nt, rt, et);
  }
  static fromJSON(et, nt) {
    const rt = [];
    for (let st = 0, ot = et.shapes.length; st < ot; st++) {
      const at = nt[et.shapes[st]];
      rt.push(at);
    }
    const it = et.options.extrudePath;
    return (
      it !== void 0 &&
        (et.options.extrudePath = new Curves[it.type]().fromJSON(it)),
      new ExtrudeGeometry(rt, et.options)
    );
  }
}
const WorldUVGenerator = {
  generateTopUV: function (tt, et, nt, rt, it) {
    const st = et[nt * 3],
      ot = et[nt * 3 + 1],
      at = et[rt * 3],
      lt = et[rt * 3 + 1],
      ct = et[it * 3],
      ut = et[it * 3 + 1];
    return [new Vector2(st, ot), new Vector2(at, lt), new Vector2(ct, ut)];
  },
  generateSideWallUV: function (tt, et, nt, rt, it, st) {
    const ot = et[nt * 3],
      at = et[nt * 3 + 1],
      lt = et[nt * 3 + 2],
      ct = et[rt * 3],
      ut = et[rt * 3 + 1],
      ft = et[rt * 3 + 2],
      ht = et[it * 3],
      mt = et[it * 3 + 1],
      vt = et[it * 3 + 2],
      yt = et[st * 3],
      Et = et[st * 3 + 1],
      pt = et[st * 3 + 2];
    return Math.abs(at - ut) < Math.abs(ot - ct)
      ? [
          new Vector2(ot, 1 - lt),
          new Vector2(ct, 1 - ft),
          new Vector2(ht, 1 - vt),
          new Vector2(yt, 1 - pt),
        ]
      : [
          new Vector2(at, 1 - lt),
          new Vector2(ut, 1 - ft),
          new Vector2(mt, 1 - vt),
          new Vector2(Et, 1 - pt),
        ];
  },
};
function toJSON$1(tt, et, nt) {
  if (((nt.shapes = []), Array.isArray(tt)))
    for (let rt = 0, it = tt.length; rt < it; rt++) {
      const st = tt[rt];
      nt.shapes.push(st.uuid);
    }
  else nt.shapes.push(tt.uuid);
  return (
    (nt.options = Object.assign({}, et)),
    et.extrudePath !== void 0 &&
      (nt.options.extrudePath = et.extrudePath.toJSON()),
    nt
  );
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(et = 1, nt = 0) {
    const rt = (1 + Math.sqrt(5)) / 2,
      it = [
        -1,
        rt,
        0,
        1,
        rt,
        0,
        -1,
        -rt,
        0,
        1,
        -rt,
        0,
        0,
        -1,
        rt,
        0,
        1,
        rt,
        0,
        -1,
        -rt,
        0,
        1,
        -rt,
        rt,
        0,
        -1,
        rt,
        0,
        1,
        -rt,
        0,
        -1,
        -rt,
        0,
        1,
      ],
      st = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(it, st, et, nt),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: et, detail: nt });
  }
  static fromJSON(et) {
    return new IcosahedronGeometry(et.radius, et.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(et = 1, nt = 0) {
    const rt = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      it = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(rt, it, et, nt),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: et, detail: nt });
  }
  static fromJSON(et) {
    return new OctahedronGeometry(et.radius, et.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(et = 0.5, nt = 1, rt = 32, it = 1, st = 0, ot = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: et,
        outerRadius: nt,
        thetaSegments: rt,
        phiSegments: it,
        thetaStart: st,
        thetaLength: ot,
      }),
      (rt = Math.max(3, rt)),
      (it = Math.max(1, it));
    const at = [],
      lt = [],
      ct = [],
      ut = [];
    let ft = et;
    const ht = (nt - et) / it,
      mt = new Vector3(),
      vt = new Vector2();
    for (let yt = 0; yt <= it; yt++) {
      for (let Et = 0; Et <= rt; Et++) {
        const pt = st + (Et / rt) * ot;
        (mt.x = ft * Math.cos(pt)),
          (mt.y = ft * Math.sin(pt)),
          lt.push(mt.x, mt.y, mt.z),
          ct.push(0, 0, 1),
          (vt.x = (mt.x / nt + 1) / 2),
          (vt.y = (mt.y / nt + 1) / 2),
          ut.push(vt.x, vt.y);
      }
      ft += ht;
    }
    for (let yt = 0; yt < it; yt++) {
      const Et = yt * (rt + 1);
      for (let pt = 0; pt < rt; pt++) {
        const xt = pt + Et,
          St = xt,
          At = xt + rt + 1,
          Ct = xt + rt + 2,
          Mt = xt + 1;
        at.push(St, At, Mt), at.push(At, Ct, Mt);
      }
    }
    this.setIndex(at),
      this.setAttribute("position", new Float32BufferAttribute(lt, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ct, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ut, 2));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new RingGeometry(
      et.innerRadius,
      et.outerRadius,
      et.thetaSegments,
      et.phiSegments,
      et.thetaStart,
      et.thetaLength
    );
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    et = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    nt = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: et, curveSegments: nt });
    const rt = [],
      it = [],
      st = [],
      ot = [];
    let at = 0,
      lt = 0;
    if (Array.isArray(et) === !1) ct(et);
    else
      for (let ut = 0; ut < et.length; ut++)
        ct(et[ut]), this.addGroup(at, lt, ut), (at += lt), (lt = 0);
    this.setIndex(rt),
      this.setAttribute("position", new Float32BufferAttribute(it, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(st, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ot, 2));
    function ct(ut) {
      const ft = it.length / 3,
        ht = ut.extractPoints(nt);
      let mt = ht.shape;
      const vt = ht.holes;
      ShapeUtils.isClockWise(mt) === !1 && (mt = mt.reverse());
      for (let Et = 0, pt = vt.length; Et < pt; Et++) {
        const xt = vt[Et];
        ShapeUtils.isClockWise(xt) === !0 && (vt[Et] = xt.reverse());
      }
      const yt = ShapeUtils.triangulateShape(mt, vt);
      for (let Et = 0, pt = vt.length; Et < pt; Et++) {
        const xt = vt[Et];
        mt = mt.concat(xt);
      }
      for (let Et = 0, pt = mt.length; Et < pt; Et++) {
        const xt = mt[Et];
        it.push(xt.x, xt.y, 0), st.push(0, 0, 1), ot.push(xt.x, xt.y);
      }
      for (let Et = 0, pt = yt.length; Et < pt; Et++) {
        const xt = yt[Et],
          St = xt[0] + ft,
          At = xt[1] + ft,
          Ct = xt[2] + ft;
        rt.push(St, At, Ct), (lt += 3);
      }
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  toJSON() {
    const et = super.toJSON(),
      nt = this.parameters.shapes;
    return toJSON(nt, et);
  }
  static fromJSON(et, nt) {
    const rt = [];
    for (let it = 0, st = et.shapes.length; it < st; it++) {
      const ot = nt[et.shapes[it]];
      rt.push(ot);
    }
    return new ShapeGeometry(rt, et.curveSegments);
  }
}
function toJSON(tt, et) {
  if (((et.shapes = []), Array.isArray(tt)))
    for (let nt = 0, rt = tt.length; nt < rt; nt++) {
      const it = tt[nt];
      et.shapes.push(it.uuid);
    }
  else et.shapes.push(tt.uuid);
  return et;
}
class SphereGeometry extends BufferGeometry {
  constructor(
    et = 1,
    nt = 32,
    rt = 16,
    it = 0,
    st = Math.PI * 2,
    ot = 0,
    at = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: et,
        widthSegments: nt,
        heightSegments: rt,
        phiStart: it,
        phiLength: st,
        thetaStart: ot,
        thetaLength: at,
      }),
      (nt = Math.max(3, Math.floor(nt))),
      (rt = Math.max(2, Math.floor(rt)));
    const lt = Math.min(ot + at, Math.PI);
    let ct = 0;
    const ut = [],
      ft = new Vector3(),
      ht = new Vector3(),
      mt = [],
      vt = [],
      yt = [],
      Et = [];
    for (let pt = 0; pt <= rt; pt++) {
      const xt = [],
        St = pt / rt;
      let At = 0;
      pt === 0 && ot === 0
        ? (At = 0.5 / nt)
        : pt === rt && lt === Math.PI && (At = -0.5 / nt);
      for (let Ct = 0; Ct <= nt; Ct++) {
        const Mt = Ct / nt;
        (ft.x = -et * Math.cos(it + Mt * st) * Math.sin(ot + St * at)),
          (ft.y = et * Math.cos(ot + St * at)),
          (ft.z = et * Math.sin(it + Mt * st) * Math.sin(ot + St * at)),
          vt.push(ft.x, ft.y, ft.z),
          ht.copy(ft).normalize(),
          yt.push(ht.x, ht.y, ht.z),
          Et.push(Mt + At, 1 - St),
          xt.push(ct++);
      }
      ut.push(xt);
    }
    for (let pt = 0; pt < rt; pt++)
      for (let xt = 0; xt < nt; xt++) {
        const St = ut[pt][xt + 1],
          At = ut[pt][xt],
          Ct = ut[pt + 1][xt],
          Mt = ut[pt + 1][xt + 1];
        (pt !== 0 || ot > 0) && mt.push(St, At, Mt),
          (pt !== rt - 1 || lt < Math.PI) && mt.push(At, Ct, Mt);
      }
    this.setIndex(mt),
      this.setAttribute("position", new Float32BufferAttribute(vt, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(yt, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(Et, 2));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new SphereGeometry(
      et.radius,
      et.widthSegments,
      et.heightSegments,
      et.phiStart,
      et.phiLength,
      et.thetaStart,
      et.thetaLength
    );
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(et = 1, nt = 0) {
    const rt = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      it = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(rt, it, et, nt),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: et, detail: nt });
  }
  static fromJSON(et) {
    return new TetrahedronGeometry(et.radius, et.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(et = 1, nt = 0.4, rt = 12, it = 48, st = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: et,
        tube: nt,
        radialSegments: rt,
        tubularSegments: it,
        arc: st,
      }),
      (rt = Math.floor(rt)),
      (it = Math.floor(it));
    const ot = [],
      at = [],
      lt = [],
      ct = [],
      ut = new Vector3(),
      ft = new Vector3(),
      ht = new Vector3();
    for (let mt = 0; mt <= rt; mt++)
      for (let vt = 0; vt <= it; vt++) {
        const yt = (vt / it) * st,
          Et = (mt / rt) * Math.PI * 2;
        (ft.x = (et + nt * Math.cos(Et)) * Math.cos(yt)),
          (ft.y = (et + nt * Math.cos(Et)) * Math.sin(yt)),
          (ft.z = nt * Math.sin(Et)),
          at.push(ft.x, ft.y, ft.z),
          (ut.x = et * Math.cos(yt)),
          (ut.y = et * Math.sin(yt)),
          ht.subVectors(ft, ut).normalize(),
          lt.push(ht.x, ht.y, ht.z),
          ct.push(vt / it),
          ct.push(mt / rt);
      }
    for (let mt = 1; mt <= rt; mt++)
      for (let vt = 1; vt <= it; vt++) {
        const yt = (it + 1) * mt + vt - 1,
          Et = (it + 1) * (mt - 1) + vt - 1,
          pt = (it + 1) * (mt - 1) + vt,
          xt = (it + 1) * mt + vt;
        ot.push(yt, Et, xt), ot.push(Et, pt, xt);
      }
    this.setIndex(ot),
      this.setAttribute("position", new Float32BufferAttribute(at, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(lt, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ct, 2));
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new TorusGeometry(
      et.radius,
      et.tube,
      et.radialSegments,
      et.tubularSegments,
      et.arc
    );
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(et = 1, nt = 0.4, rt = 64, it = 8, st = 2, ot = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: et,
        tube: nt,
        tubularSegments: rt,
        radialSegments: it,
        p: st,
        q: ot,
      }),
      (rt = Math.floor(rt)),
      (it = Math.floor(it));
    const at = [],
      lt = [],
      ct = [],
      ut = [],
      ft = new Vector3(),
      ht = new Vector3(),
      mt = new Vector3(),
      vt = new Vector3(),
      yt = new Vector3(),
      Et = new Vector3(),
      pt = new Vector3();
    for (let St = 0; St <= rt; ++St) {
      const At = (St / rt) * st * Math.PI * 2;
      xt(At, st, ot, et, mt),
        xt(At + 0.01, st, ot, et, vt),
        Et.subVectors(vt, mt),
        pt.addVectors(vt, mt),
        yt.crossVectors(Et, pt),
        pt.crossVectors(yt, Et),
        yt.normalize(),
        pt.normalize();
      for (let Ct = 0; Ct <= it; ++Ct) {
        const Mt = (Ct / it) * Math.PI * 2,
          wt = -nt * Math.cos(Mt),
          Bt = nt * Math.sin(Mt);
        (ft.x = mt.x + (wt * pt.x + Bt * yt.x)),
          (ft.y = mt.y + (wt * pt.y + Bt * yt.y)),
          (ft.z = mt.z + (wt * pt.z + Bt * yt.z)),
          lt.push(ft.x, ft.y, ft.z),
          ht.subVectors(ft, mt).normalize(),
          ct.push(ht.x, ht.y, ht.z),
          ut.push(St / rt),
          ut.push(Ct / it);
      }
    }
    for (let St = 1; St <= rt; St++)
      for (let At = 1; At <= it; At++) {
        const Ct = (it + 1) * (St - 1) + (At - 1),
          Mt = (it + 1) * St + (At - 1),
          wt = (it + 1) * St + At,
          Bt = (it + 1) * (St - 1) + At;
        at.push(Ct, Mt, Bt), at.push(Mt, wt, Bt);
      }
    this.setIndex(at),
      this.setAttribute("position", new Float32BufferAttribute(lt, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ct, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ut, 2));
    function xt(St, At, Ct, Mt, wt) {
      const Bt = Math.cos(St),
        It = Math.sin(St),
        Ft = (Ct / At) * St,
        Vt = Math.cos(Ft);
      (wt.x = Mt * (2 + Vt) * 0.5 * Bt),
        (wt.y = Mt * (2 + Vt) * It * 0.5),
        (wt.z = Mt * Math.sin(Ft) * 0.5);
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  static fromJSON(et) {
    return new TorusKnotGeometry(
      et.radius,
      et.tube,
      et.tubularSegments,
      et.radialSegments,
      et.p,
      et.q
    );
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    et = new QuadraticBezierCurve3(
      new Vector3(-1, -1, 0),
      new Vector3(-1, 1, 0),
      new Vector3(1, 1, 0)
    ),
    nt = 64,
    rt = 1,
    it = 8,
    st = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: et,
        tubularSegments: nt,
        radius: rt,
        radialSegments: it,
        closed: st,
      });
    const ot = et.computeFrenetFrames(nt, st);
    (this.tangents = ot.tangents),
      (this.normals = ot.normals),
      (this.binormals = ot.binormals);
    const at = new Vector3(),
      lt = new Vector3(),
      ct = new Vector2();
    let ut = new Vector3();
    const ft = [],
      ht = [],
      mt = [],
      vt = [];
    yt(),
      this.setIndex(vt),
      this.setAttribute("position", new Float32BufferAttribute(ft, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ht, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(mt, 2));
    function yt() {
      for (let St = 0; St < nt; St++) Et(St);
      Et(st === !1 ? nt : 0), xt(), pt();
    }
    function Et(St) {
      ut = et.getPointAt(St / nt, ut);
      const At = ot.normals[St],
        Ct = ot.binormals[St];
      for (let Mt = 0; Mt <= it; Mt++) {
        const wt = (Mt / it) * Math.PI * 2,
          Bt = Math.sin(wt),
          It = -Math.cos(wt);
        (lt.x = It * At.x + Bt * Ct.x),
          (lt.y = It * At.y + Bt * Ct.y),
          (lt.z = It * At.z + Bt * Ct.z),
          lt.normalize(),
          ht.push(lt.x, lt.y, lt.z),
          (at.x = ut.x + rt * lt.x),
          (at.y = ut.y + rt * lt.y),
          (at.z = ut.z + rt * lt.z),
          ft.push(at.x, at.y, at.z);
      }
    }
    function pt() {
      for (let St = 1; St <= nt; St++)
        for (let At = 1; At <= it; At++) {
          const Ct = (it + 1) * (St - 1) + (At - 1),
            Mt = (it + 1) * St + (At - 1),
            wt = (it + 1) * St + At,
            Bt = (it + 1) * (St - 1) + At;
          vt.push(Ct, Mt, Bt), vt.push(Mt, wt, Bt);
        }
    }
    function xt() {
      for (let St = 0; St <= nt; St++)
        for (let At = 0; At <= it; At++)
          (ct.x = St / nt), (ct.y = At / it), mt.push(ct.x, ct.y);
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
  toJSON() {
    const et = super.toJSON();
    return (et.path = this.parameters.path.toJSON()), et;
  }
  static fromJSON(et) {
    return new TubeGeometry(
      new Curves[et.path.type]().fromJSON(et.path),
      et.tubularSegments,
      et.radius,
      et.radialSegments,
      et.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(et = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: et }),
      et !== null)
    ) {
      const nt = [],
        rt = new Set(),
        it = new Vector3(),
        st = new Vector3();
      if (et.index !== null) {
        const ot = et.attributes.position,
          at = et.index;
        let lt = et.groups;
        lt.length === 0 &&
          (lt = [{ start: 0, count: at.count, materialIndex: 0 }]);
        for (let ct = 0, ut = lt.length; ct < ut; ++ct) {
          const ft = lt[ct],
            ht = ft.start,
            mt = ft.count;
          for (let vt = ht, yt = ht + mt; vt < yt; vt += 3)
            for (let Et = 0; Et < 3; Et++) {
              const pt = at.getX(vt + Et),
                xt = at.getX(vt + ((Et + 1) % 3));
              it.fromBufferAttribute(ot, pt),
                st.fromBufferAttribute(ot, xt),
                isUniqueEdge(it, st, rt) === !0 &&
                  (nt.push(it.x, it.y, it.z), nt.push(st.x, st.y, st.z));
            }
        }
      } else {
        const ot = et.attributes.position;
        for (let at = 0, lt = ot.count / 3; at < lt; at++)
          for (let ct = 0; ct < 3; ct++) {
            const ut = 3 * at + ct,
              ft = 3 * at + ((ct + 1) % 3);
            it.fromBufferAttribute(ot, ut),
              st.fromBufferAttribute(ot, ft),
              isUniqueEdge(it, st, rt) === !0 &&
                (nt.push(it.x, it.y, it.z), nt.push(st.x, st.y, st.z));
          }
      }
      this.setAttribute("position", new Float32BufferAttribute(nt, 3));
    }
  }
  copy(et) {
    return (
      super.copy(et), (this.parameters = Object.assign({}, et.parameters)), this
    );
  }
}
function isUniqueEdge(tt, et, nt) {
  const rt = `${tt.x},${tt.y},${tt.z}-${et.x},${et.y},${et.z}`,
    it = `${et.x},${et.y},${et.z}-${tt.x},${tt.y},${tt.z}`;
  return nt.has(rt) === !0 || nt.has(it) === !0
    ? !1
    : (nt.add(rt), nt.add(it), !0);
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry,
});
class ShadowMaterial extends Material {
  constructor(et) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Color(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return super.copy(et), this.color.copy(et.color), (this.fog = et.fog), this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(et) {
    super(et),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class MeshStandardMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.defines = { STANDARD: "" }),
      this.color.copy(et.color),
      (this.roughness = et.roughness),
      (this.metalness = et.metalness),
      (this.map = et.map),
      (this.lightMap = et.lightMap),
      (this.lightMapIntensity = et.lightMapIntensity),
      (this.aoMap = et.aoMap),
      (this.aoMapIntensity = et.aoMapIntensity),
      this.emissive.copy(et.emissive),
      (this.emissiveMap = et.emissiveMap),
      (this.emissiveIntensity = et.emissiveIntensity),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.roughnessMap = et.roughnessMap),
      (this.metalnessMap = et.metalnessMap),
      (this.alphaMap = et.alphaMap),
      (this.envMap = et.envMap),
      (this.envMapIntensity = et.envMapIntensity),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.wireframeLinecap = et.wireframeLinecap),
      (this.wireframeLinejoin = et.wireframeLinejoin),
      (this.flatShading = et.flatShading),
      (this.fog = et.fog),
      this
    );
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(et) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Vector2(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return clamp$1((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (nt) {
          this.ior = (1 + 0.4 * nt) / (1 - 0.4 * nt);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Color(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Color(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Color(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(et);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(et) {
    this._anisotropy > 0 != et > 0 && this.version++, (this._anisotropy = et);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(et) {
    this._clearcoat > 0 != et > 0 && this.version++, (this._clearcoat = et);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(et) {
    this._iridescence > 0 != et > 0 && this.version++, (this._iridescence = et);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(et) {
    this._sheen > 0 != et > 0 && this.version++, (this._sheen = et);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(et) {
    this._transmission > 0 != et > 0 && this.version++,
      (this._transmission = et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = et.anisotropy),
      (this.anisotropyRotation = et.anisotropyRotation),
      (this.anisotropyMap = et.anisotropyMap),
      (this.clearcoat = et.clearcoat),
      (this.clearcoatMap = et.clearcoatMap),
      (this.clearcoatRoughness = et.clearcoatRoughness),
      (this.clearcoatRoughnessMap = et.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = et.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(et.clearcoatNormalScale),
      (this.ior = et.ior),
      (this.iridescence = et.iridescence),
      (this.iridescenceMap = et.iridescenceMap),
      (this.iridescenceIOR = et.iridescenceIOR),
      (this.iridescenceThicknessRange = [...et.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = et.iridescenceThicknessMap),
      (this.sheen = et.sheen),
      this.sheenColor.copy(et.sheenColor),
      (this.sheenColorMap = et.sheenColorMap),
      (this.sheenRoughness = et.sheenRoughness),
      (this.sheenRoughnessMap = et.sheenRoughnessMap),
      (this.transmission = et.transmission),
      (this.transmissionMap = et.transmissionMap),
      (this.thickness = et.thickness),
      (this.thicknessMap = et.thicknessMap),
      (this.attenuationDistance = et.attenuationDistance),
      this.attenuationColor.copy(et.attenuationColor),
      (this.specularIntensity = et.specularIntensity),
      (this.specularIntensityMap = et.specularIntensityMap),
      this.specularColor.copy(et.specularColor),
      (this.specularColorMap = et.specularColorMap),
      this
    );
  }
}
class MeshPhongMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Color(16777215)),
      (this.specular = new Color(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      this.specular.copy(et.specular),
      (this.shininess = et.shininess),
      (this.map = et.map),
      (this.lightMap = et.lightMap),
      (this.lightMapIntensity = et.lightMapIntensity),
      (this.aoMap = et.aoMap),
      (this.aoMapIntensity = et.aoMapIntensity),
      this.emissive.copy(et.emissive),
      (this.emissiveMap = et.emissiveMap),
      (this.emissiveIntensity = et.emissiveIntensity),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.specularMap = et.specularMap),
      (this.alphaMap = et.alphaMap),
      (this.envMap = et.envMap),
      (this.combine = et.combine),
      (this.reflectivity = et.reflectivity),
      (this.refractionRatio = et.refractionRatio),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.wireframeLinecap = et.wireframeLinecap),
      (this.wireframeLinejoin = et.wireframeLinejoin),
      (this.flatShading = et.flatShading),
      (this.fog = et.fog),
      this
    );
  }
}
class MeshToonMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.gradientMap = et.gradientMap),
      (this.lightMap = et.lightMap),
      (this.lightMapIntensity = et.lightMapIntensity),
      (this.aoMap = et.aoMap),
      (this.aoMapIntensity = et.aoMapIntensity),
      this.emissive.copy(et.emissive),
      (this.emissiveMap = et.emissiveMap),
      (this.emissiveIntensity = et.emissiveIntensity),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.alphaMap = et.alphaMap),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.wireframeLinecap = et.wireframeLinecap),
      (this.wireframeLinejoin = et.wireframeLinejoin),
      (this.fog = et.fog),
      this
    );
  }
}
class MeshNormalMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.flatShading = et.flatShading),
      this
    );
  }
}
class MeshLambertMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      this.color.copy(et.color),
      (this.map = et.map),
      (this.lightMap = et.lightMap),
      (this.lightMapIntensity = et.lightMapIntensity),
      (this.aoMap = et.aoMap),
      (this.aoMapIntensity = et.aoMapIntensity),
      this.emissive.copy(et.emissive),
      (this.emissiveMap = et.emissiveMap),
      (this.emissiveIntensity = et.emissiveIntensity),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.specularMap = et.specularMap),
      (this.alphaMap = et.alphaMap),
      (this.envMap = et.envMap),
      (this.combine = et.combine),
      (this.reflectivity = et.reflectivity),
      (this.refractionRatio = et.refractionRatio),
      (this.wireframe = et.wireframe),
      (this.wireframeLinewidth = et.wireframeLinewidth),
      (this.wireframeLinecap = et.wireframeLinecap),
      (this.wireframeLinejoin = et.wireframeLinejoin),
      (this.flatShading = et.flatShading),
      (this.fog = et.fog),
      this
    );
  }
}
class MeshMatcapMaterial extends Material {
  constructor(et) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Color(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.defines = { MATCAP: "" }),
      this.color.copy(et.color),
      (this.matcap = et.matcap),
      (this.map = et.map),
      (this.bumpMap = et.bumpMap),
      (this.bumpScale = et.bumpScale),
      (this.normalMap = et.normalMap),
      (this.normalMapType = et.normalMapType),
      this.normalScale.copy(et.normalScale),
      (this.displacementMap = et.displacementMap),
      (this.displacementScale = et.displacementScale),
      (this.displacementBias = et.displacementBias),
      (this.alphaMap = et.alphaMap),
      (this.flatShading = et.flatShading),
      (this.fog = et.fog),
      this
    );
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(et) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(et);
  }
  copy(et) {
    return (
      super.copy(et),
      (this.scale = et.scale),
      (this.dashSize = et.dashSize),
      (this.gapSize = et.gapSize),
      this
    );
  }
}
function convertArray(tt, et, nt) {
  return !tt || (!nt && tt.constructor === et)
    ? tt
    : typeof et.BYTES_PER_ELEMENT == "number"
    ? new et(tt)
    : Array.prototype.slice.call(tt);
}
function isTypedArray(tt) {
  return ArrayBuffer.isView(tt) && !(tt instanceof DataView);
}
function getKeyframeOrder(tt) {
  function et(it, st) {
    return tt[it] - tt[st];
  }
  const nt = tt.length,
    rt = new Array(nt);
  for (let it = 0; it !== nt; ++it) rt[it] = it;
  return rt.sort(et), rt;
}
function sortedArray(tt, et, nt) {
  const rt = tt.length,
    it = new tt.constructor(rt);
  for (let st = 0, ot = 0; ot !== rt; ++st) {
    const at = nt[st] * et;
    for (let lt = 0; lt !== et; ++lt) it[ot++] = tt[at + lt];
  }
  return it;
}
function flattenJSON(tt, et, nt, rt) {
  let it = 1,
    st = tt[0];
  for (; st !== void 0 && st[rt] === void 0; ) st = tt[it++];
  if (st === void 0) return;
  let ot = st[rt];
  if (ot !== void 0)
    if (Array.isArray(ot))
      do
        (ot = st[rt]),
          ot !== void 0 && (et.push(st.time), nt.push.apply(nt, ot)),
          (st = tt[it++]);
      while (st !== void 0);
    else if (ot.toArray !== void 0)
      do
        (ot = st[rt]),
          ot !== void 0 && (et.push(st.time), ot.toArray(nt, nt.length)),
          (st = tt[it++]);
      while (st !== void 0);
    else
      do
        (ot = st[rt]),
          ot !== void 0 && (et.push(st.time), nt.push(ot)),
          (st = tt[it++]);
      while (st !== void 0);
}
function subclip(tt, et, nt, rt, it = 30) {
  const st = tt.clone();
  st.name = et;
  const ot = [];
  for (let lt = 0; lt < st.tracks.length; ++lt) {
    const ct = st.tracks[lt],
      ut = ct.getValueSize(),
      ft = [],
      ht = [];
    for (let mt = 0; mt < ct.times.length; ++mt) {
      const vt = ct.times[mt] * it;
      if (!(vt < nt || vt >= rt)) {
        ft.push(ct.times[mt]);
        for (let yt = 0; yt < ut; ++yt) ht.push(ct.values[mt * ut + yt]);
      }
    }
    ft.length !== 0 &&
      ((ct.times = convertArray(ft, ct.times.constructor)),
      (ct.values = convertArray(ht, ct.values.constructor)),
      ot.push(ct));
  }
  st.tracks = ot;
  let at = 1 / 0;
  for (let lt = 0; lt < st.tracks.length; ++lt)
    at > st.tracks[lt].times[0] && (at = st.tracks[lt].times[0]);
  for (let lt = 0; lt < st.tracks.length; ++lt) st.tracks[lt].shift(-1 * at);
  return st.resetDuration(), st;
}
function makeClipAdditive(tt, et = 0, nt = tt, rt = 30) {
  rt <= 0 && (rt = 30);
  const it = nt.tracks.length,
    st = et / rt;
  for (let ot = 0; ot < it; ++ot) {
    const at = nt.tracks[ot],
      lt = at.ValueTypeName;
    if (lt === "bool" || lt === "string") continue;
    const ct = tt.tracks.find(function (pt) {
      return pt.name === at.name && pt.ValueTypeName === lt;
    });
    if (ct === void 0) continue;
    let ut = 0;
    const ft = at.getValueSize();
    at.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (ut = ft / 3);
    let ht = 0;
    const mt = ct.getValueSize();
    ct.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (ht = mt / 3);
    const vt = at.times.length - 1;
    let yt;
    if (st <= at.times[0]) {
      const pt = ut,
        xt = ft - ut;
      yt = at.values.slice(pt, xt);
    } else if (st >= at.times[vt]) {
      const pt = vt * ft + ut,
        xt = pt + ft - ut;
      yt = at.values.slice(pt, xt);
    } else {
      const pt = at.createInterpolant(),
        xt = ut,
        St = ft - ut;
      pt.evaluate(st), (yt = pt.resultBuffer.slice(xt, St));
    }
    lt === "quaternion" &&
      new Quaternion().fromArray(yt).normalize().conjugate().toArray(yt);
    const Et = ct.times.length;
    for (let pt = 0; pt < Et; ++pt) {
      const xt = pt * mt + ht;
      if (lt === "quaternion")
        Quaternion.multiplyQuaternionsFlat(ct.values, xt, yt, 0, ct.values, xt);
      else {
        const St = mt - ht * 2;
        for (let At = 0; At < St; ++At) ct.values[xt + At] -= yt[At];
      }
    }
  }
  return (tt.blendMode = AdditiveAnimationBlendMode), tt;
}
const AnimationUtils = {
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive,
};
class Interpolant {
  constructor(et, nt, rt, it) {
    (this.parameterPositions = et),
      (this._cachedIndex = 0),
      (this.resultBuffer = it !== void 0 ? it : new nt.constructor(rt)),
      (this.sampleValues = nt),
      (this.valueSize = rt),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(et) {
    const nt = this.parameterPositions;
    let rt = this._cachedIndex,
      it = nt[rt],
      st = nt[rt - 1];
    e: {
      t: {
        let ot;
        n: {
          r: if (!(et < it)) {
            for (let at = rt + 2; ; ) {
              if (it === void 0) {
                if (et < st) break r;
                return (
                  (rt = nt.length),
                  (this._cachedIndex = rt),
                  this.copySampleValue_(rt - 1)
                );
              }
              if (rt === at) break;
              if (((st = it), (it = nt[++rt]), et < it)) break t;
            }
            ot = nt.length;
            break n;
          }
          if (!(et >= st)) {
            const at = nt[1];
            et < at && ((rt = 2), (st = at));
            for (let lt = rt - 2; ; ) {
              if (st === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (rt === lt) break;
              if (((it = st), (st = nt[--rt - 1]), et >= st)) break t;
            }
            (ot = rt), (rt = 0);
            break n;
          }
          break e;
        }
        for (; rt < ot; ) {
          const at = (rt + ot) >>> 1;
          et < nt[at] ? (ot = at) : (rt = at + 1);
        }
        if (((it = nt[rt]), (st = nt[rt - 1]), st === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (it === void 0)
          return (
            (rt = nt.length),
            (this._cachedIndex = rt),
            this.copySampleValue_(rt - 1)
          );
      }
      (this._cachedIndex = rt), this.intervalChanged_(rt, st, it);
    }
    return this.interpolate_(rt, st, et, it);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(et) {
    const nt = this.resultBuffer,
      rt = this.sampleValues,
      it = this.valueSize,
      st = et * it;
    for (let ot = 0; ot !== it; ++ot) nt[ot] = rt[st + ot];
    return nt;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(et, nt, rt, it) {
    super(et, nt, rt, it),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding,
      });
  }
  intervalChanged_(et, nt, rt) {
    const it = this.parameterPositions;
    let st = et - 2,
      ot = et + 1,
      at = it[st],
      lt = it[ot];
    if (at === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          (st = et), (at = 2 * nt - rt);
          break;
        case WrapAroundEnding:
          (st = it.length - 2), (at = nt + it[st] - it[st + 1]);
          break;
        default:
          (st = et), (at = rt);
      }
    if (lt === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          (ot = et), (lt = 2 * rt - nt);
          break;
        case WrapAroundEnding:
          (ot = 1), (lt = rt + it[1] - it[0]);
          break;
        default:
          (ot = et - 1), (lt = nt);
      }
    const ct = (rt - nt) * 0.5,
      ut = this.valueSize;
    (this._weightPrev = ct / (nt - at)),
      (this._weightNext = ct / (lt - rt)),
      (this._offsetPrev = st * ut),
      (this._offsetNext = ot * ut);
  }
  interpolate_(et, nt, rt, it) {
    const st = this.resultBuffer,
      ot = this.sampleValues,
      at = this.valueSize,
      lt = et * at,
      ct = lt - at,
      ut = this._offsetPrev,
      ft = this._offsetNext,
      ht = this._weightPrev,
      mt = this._weightNext,
      vt = (rt - nt) / (it - nt),
      yt = vt * vt,
      Et = yt * vt,
      pt = -ht * Et + 2 * ht * yt - ht * vt,
      xt = (1 + ht) * Et + (-1.5 - 2 * ht) * yt + (-0.5 + ht) * vt + 1,
      St = (-1 - mt) * Et + (1.5 + mt) * yt + 0.5 * vt,
      At = mt * Et - mt * yt;
    for (let Ct = 0; Ct !== at; ++Ct)
      st[Ct] =
        pt * ot[ut + Ct] +
        xt * ot[ct + Ct] +
        St * ot[lt + Ct] +
        At * ot[ft + Ct];
    return st;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(et, nt, rt, it) {
    super(et, nt, rt, it);
  }
  interpolate_(et, nt, rt, it) {
    const st = this.resultBuffer,
      ot = this.sampleValues,
      at = this.valueSize,
      lt = et * at,
      ct = lt - at,
      ut = (rt - nt) / (it - nt),
      ft = 1 - ut;
    for (let ht = 0; ht !== at; ++ht)
      st[ht] = ot[ct + ht] * ft + ot[lt + ht] * ut;
    return st;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(et, nt, rt, it) {
    super(et, nt, rt, it);
  }
  interpolate_(et) {
    return this.copySampleValue_(et - 1);
  }
}
class KeyframeTrack {
  constructor(et, nt, rt, it) {
    if (et === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (nt === void 0 || nt.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + et);
    (this.name = et),
      (this.times = convertArray(nt, this.TimeBufferType)),
      (this.values = convertArray(rt, this.ValueBufferType)),
      this.setInterpolation(it || this.DefaultInterpolation);
  }
  static toJSON(et) {
    const nt = et.constructor;
    let rt;
    if (nt.toJSON !== this.toJSON) rt = nt.toJSON(et);
    else {
      rt = {
        name: et.name,
        times: convertArray(et.times, Array),
        values: convertArray(et.values, Array),
      };
      const it = et.getInterpolation();
      it !== et.DefaultInterpolation && (rt.interpolation = it);
    }
    return (rt.type = et.ValueTypeName), rt;
  }
  InterpolantFactoryMethodDiscrete(et) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      et
    );
  }
  InterpolantFactoryMethodLinear(et) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      et
    );
  }
  InterpolantFactoryMethodSmooth(et) {
    return new CubicInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      et
    );
  }
  setInterpolation(et) {
    let nt;
    switch (et) {
      case InterpolateDiscrete:
        nt = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        nt = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        nt = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (nt === void 0) {
      const rt =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (et !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(rt);
      return console.warn("THREE.KeyframeTrack:", rt), this;
    }
    return (this.createInterpolant = nt), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(et) {
    if (et !== 0) {
      const nt = this.times;
      for (let rt = 0, it = nt.length; rt !== it; ++rt) nt[rt] += et;
    }
    return this;
  }
  scale(et) {
    if (et !== 1) {
      const nt = this.times;
      for (let rt = 0, it = nt.length; rt !== it; ++rt) nt[rt] *= et;
    }
    return this;
  }
  trim(et, nt) {
    const rt = this.times,
      it = rt.length;
    let st = 0,
      ot = it - 1;
    for (; st !== it && rt[st] < et; ) ++st;
    for (; ot !== -1 && rt[ot] > nt; ) --ot;
    if ((++ot, st !== 0 || ot !== it)) {
      st >= ot && ((ot = Math.max(ot, 1)), (st = ot - 1));
      const at = this.getValueSize();
      (this.times = rt.slice(st, ot)),
        (this.values = this.values.slice(st * at, ot * at));
    }
    return this;
  }
  validate() {
    let et = !0;
    const nt = this.getValueSize();
    nt - Math.floor(nt) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (et = !1));
    const rt = this.times,
      it = this.values,
      st = rt.length;
    st === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (et = !1));
    let ot = null;
    for (let at = 0; at !== st; at++) {
      const lt = rt[at];
      if (typeof lt == "number" && isNaN(lt)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          at,
          lt
        ),
          (et = !1);
        break;
      }
      if (ot !== null && ot > lt) {
        console.error(
          "THREE.KeyframeTrack: Out of order keys.",
          this,
          at,
          lt,
          ot
        ),
          (et = !1);
        break;
      }
      ot = lt;
    }
    if (it !== void 0 && isTypedArray(it))
      for (let at = 0, lt = it.length; at !== lt; ++at) {
        const ct = it[at];
        if (isNaN(ct)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            at,
            ct
          ),
            (et = !1);
          break;
        }
      }
    return et;
  }
  optimize() {
    const et = this.times.slice(),
      nt = this.values.slice(),
      rt = this.getValueSize(),
      it = this.getInterpolation() === InterpolateSmooth,
      st = et.length - 1;
    let ot = 1;
    for (let at = 1; at < st; ++at) {
      let lt = !1;
      const ct = et[at],
        ut = et[at + 1];
      if (ct !== ut && (at !== 1 || ct !== et[0]))
        if (it) lt = !0;
        else {
          const ft = at * rt,
            ht = ft - rt,
            mt = ft + rt;
          for (let vt = 0; vt !== rt; ++vt) {
            const yt = nt[ft + vt];
            if (yt !== nt[ht + vt] || yt !== nt[mt + vt]) {
              lt = !0;
              break;
            }
          }
        }
      if (lt) {
        if (at !== ot) {
          et[ot] = et[at];
          const ft = at * rt,
            ht = ot * rt;
          for (let mt = 0; mt !== rt; ++mt) nt[ht + mt] = nt[ft + mt];
        }
        ++ot;
      }
    }
    if (st > 0) {
      et[ot] = et[st];
      for (let at = st * rt, lt = ot * rt, ct = 0; ct !== rt; ++ct)
        nt[lt + ct] = nt[at + ct];
      ++ot;
    }
    return (
      ot !== et.length
        ? ((this.times = et.slice(0, ot)), (this.values = nt.slice(0, ot * rt)))
        : ((this.times = et), (this.values = nt)),
      this
    );
  }
  clone() {
    const et = this.times.slice(),
      nt = this.values.slice(),
      rt = this.constructor,
      it = new rt(this.name, et, nt);
    return (it.createInterpolant = this.createInterpolant), it;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(et, nt, rt, it) {
    super(et, nt, rt, it);
  }
  interpolate_(et, nt, rt, it) {
    const st = this.resultBuffer,
      ot = this.sampleValues,
      at = this.valueSize,
      lt = (rt - nt) / (it - nt);
    let ct = et * at;
    for (let ut = ct + at; ct !== ut; ct += 4)
      Quaternion.slerpFlat(st, 0, ot, ct - at, ot, ct, lt);
    return st;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(et) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      et
    );
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(et, nt = -1, rt, it = NormalAnimationBlendMode) {
    (this.name = et),
      (this.tracks = rt),
      (this.duration = nt),
      (this.blendMode = it),
      (this.uuid = generateUUID$1()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(et) {
    const nt = [],
      rt = et.tracks,
      it = 1 / (et.fps || 1);
    for (let ot = 0, at = rt.length; ot !== at; ++ot)
      nt.push(parseKeyframeTrack(rt[ot]).scale(it));
    const st = new this(et.name, et.duration, nt, et.blendMode);
    return (st.uuid = et.uuid), st;
  }
  static toJSON(et) {
    const nt = [],
      rt = et.tracks,
      it = {
        name: et.name,
        duration: et.duration,
        tracks: nt,
        uuid: et.uuid,
        blendMode: et.blendMode,
      };
    for (let st = 0, ot = rt.length; st !== ot; ++st)
      nt.push(KeyframeTrack.toJSON(rt[st]));
    return it;
  }
  static CreateFromMorphTargetSequence(et, nt, rt, it) {
    const st = nt.length,
      ot = [];
    for (let at = 0; at < st; at++) {
      let lt = [],
        ct = [];
      lt.push((at + st - 1) % st, at, (at + 1) % st), ct.push(0, 1, 0);
      const ut = getKeyframeOrder(lt);
      (lt = sortedArray(lt, 1, ut)),
        (ct = sortedArray(ct, 1, ut)),
        !it && lt[0] === 0 && (lt.push(st), ct.push(ct[0])),
        ot.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + nt[at].name + "]",
            lt,
            ct
          ).scale(1 / rt)
        );
    }
    return new this(et, -1, ot);
  }
  static findByName(et, nt) {
    let rt = et;
    if (!Array.isArray(et)) {
      const it = et;
      rt = (it.geometry && it.geometry.animations) || it.animations;
    }
    for (let it = 0; it < rt.length; it++)
      if (rt[it].name === nt) return rt[it];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(et, nt, rt) {
    const it = {},
      st = /^([\w-]*?)([\d]+)$/;
    for (let at = 0, lt = et.length; at < lt; at++) {
      const ct = et[at],
        ut = ct.name.match(st);
      if (ut && ut.length > 1) {
        const ft = ut[1];
        let ht = it[ft];
        ht || (it[ft] = ht = []), ht.push(ct);
      }
    }
    const ot = [];
    for (const at in it)
      ot.push(this.CreateFromMorphTargetSequence(at, it[at], nt, rt));
    return ot;
  }
  static parseAnimation(et, nt) {
    if (!et)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const rt = function (ft, ht, mt, vt, yt) {
        if (mt.length !== 0) {
          const Et = [],
            pt = [];
          flattenJSON(mt, Et, pt, vt),
            Et.length !== 0 && yt.push(new ft(ht, Et, pt));
        }
      },
      it = [],
      st = et.name || "default",
      ot = et.fps || 30,
      at = et.blendMode;
    let lt = et.length || -1;
    const ct = et.hierarchy || [];
    for (let ft = 0; ft < ct.length; ft++) {
      const ht = ct[ft].keys;
      if (!(!ht || ht.length === 0))
        if (ht[0].morphTargets) {
          const mt = {};
          let vt;
          for (vt = 0; vt < ht.length; vt++)
            if (ht[vt].morphTargets)
              for (let yt = 0; yt < ht[vt].morphTargets.length; yt++)
                mt[ht[vt].morphTargets[yt]] = -1;
          for (const yt in mt) {
            const Et = [],
              pt = [];
            for (let xt = 0; xt !== ht[vt].morphTargets.length; ++xt) {
              const St = ht[vt];
              Et.push(St.time), pt.push(St.morphTarget === yt ? 1 : 0);
            }
            it.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluence[" + yt + "]",
                Et,
                pt
              )
            );
          }
          lt = mt.length * ot;
        } else {
          const mt = ".bones[" + nt[ft].name + "]";
          rt(VectorKeyframeTrack, mt + ".position", ht, "pos", it),
            rt(QuaternionKeyframeTrack, mt + ".quaternion", ht, "rot", it),
            rt(VectorKeyframeTrack, mt + ".scale", ht, "scl", it);
        }
    }
    return it.length === 0 ? null : new this(st, lt, it, at);
  }
  resetDuration() {
    const et = this.tracks;
    let nt = 0;
    for (let rt = 0, it = et.length; rt !== it; ++rt) {
      const st = this.tracks[rt];
      nt = Math.max(nt, st.times[st.times.length - 1]);
    }
    return (this.duration = nt), this;
  }
  trim() {
    for (let et = 0; et < this.tracks.length; et++)
      this.tracks[et].trim(0, this.duration);
    return this;
  }
  validate() {
    let et = !0;
    for (let nt = 0; nt < this.tracks.length; nt++)
      et = et && this.tracks[nt].validate();
    return et;
  }
  optimize() {
    for (let et = 0; et < this.tracks.length; et++) this.tracks[et].optimize();
    return this;
  }
  clone() {
    const et = [];
    for (let nt = 0; nt < this.tracks.length; nt++)
      et.push(this.tracks[nt].clone());
    return new this.constructor(this.name, this.duration, et, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(tt) {
  switch (tt.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + tt);
}
function parseKeyframeTrack(tt) {
  if (tt.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const et = getTrackTypeForValueTypeName(tt.type);
  if (tt.times === void 0) {
    const nt = [],
      rt = [];
    flattenJSON(tt.keys, nt, rt, "value"), (tt.times = nt), (tt.values = rt);
  }
  return et.parse !== void 0
    ? et.parse(tt)
    : new et(tt.name, tt.times, tt.values, tt.interpolation);
}
const Cache = {
  enabled: !1,
  files: {},
  add: function (tt, et) {
    this.enabled !== !1 && (this.files[tt] = et);
  },
  get: function (tt) {
    if (this.enabled !== !1) return this.files[tt];
  },
  remove: function (tt) {
    delete this.files[tt];
  },
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  constructor(et, nt, rt) {
    const it = this;
    let st = !1,
      ot = 0,
      at = 0,
      lt;
    const ct = [];
    (this.onStart = void 0),
      (this.onLoad = et),
      (this.onProgress = nt),
      (this.onError = rt),
      (this.itemStart = function (ut) {
        at++,
          st === !1 && it.onStart !== void 0 && it.onStart(ut, ot, at),
          (st = !0);
      }),
      (this.itemEnd = function (ut) {
        ot++,
          it.onProgress !== void 0 && it.onProgress(ut, ot, at),
          ot === at && ((st = !1), it.onLoad !== void 0 && it.onLoad());
      }),
      (this.itemError = function (ut) {
        it.onError !== void 0 && it.onError(ut);
      }),
      (this.resolveURL = function (ut) {
        return lt ? lt(ut) : ut;
      }),
      (this.setURLModifier = function (ut) {
        return (lt = ut), this;
      }),
      (this.addHandler = function (ut, ft) {
        return ct.push(ut, ft), this;
      }),
      (this.removeHandler = function (ut) {
        const ft = ct.indexOf(ut);
        return ft !== -1 && ct.splice(ft, 2), this;
      }),
      (this.getHandler = function (ut) {
        for (let ft = 0, ht = ct.length; ft < ht; ft += 2) {
          const mt = ct[ft],
            vt = ct[ft + 1];
          if ((mt.global && (mt.lastIndex = 0), mt.test(ut))) return vt;
        }
        return null;
      });
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(et) {
    (this.manager = et !== void 0 ? et : DefaultLoadingManager),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(et, nt) {
    const rt = this;
    return new Promise(function (it, st) {
      rt.load(et, it, nt, st);
    });
  }
  parse() {}
  setCrossOrigin(et) {
    return (this.crossOrigin = et), this;
  }
  setWithCredentials(et) {
    return (this.withCredentials = et), this;
  }
  setPath(et) {
    return (this.path = et), this;
  }
  setResourcePath(et) {
    return (this.resourcePath = et), this;
  }
  setRequestHeader(et) {
    return (this.requestHeader = et), this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(et, nt) {
    super(et), (this.response = nt);
  }
}
class FileLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    et === void 0 && (et = ""),
      this.path !== void 0 && (et = this.path + et),
      (et = this.manager.resolveURL(et));
    const st = Cache.get(et);
    if (st !== void 0)
      return (
        this.manager.itemStart(et),
        setTimeout(() => {
          nt && nt(st), this.manager.itemEnd(et);
        }, 0),
        st
      );
    if (loading[et] !== void 0) {
      loading[et].push({ onLoad: nt, onProgress: rt, onError: it });
      return;
    }
    (loading[et] = []),
      loading[et].push({ onLoad: nt, onProgress: rt, onError: it });
    const ot = new Request(et, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      at = this.mimeType,
      lt = this.responseType;
    fetch(ot)
      .then((ct) => {
        if (ct.status === 200 || ct.status === 0) {
          if (
            (ct.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              ct.body === void 0 ||
              ct.body.getReader === void 0)
          )
            return ct;
          const ut = loading[et],
            ft = ct.body.getReader(),
            ht =
              ct.headers.get("Content-Length") || ct.headers.get("X-File-Size"),
            mt = ht ? parseInt(ht) : 0,
            vt = mt !== 0;
          let yt = 0;
          const Et = new ReadableStream({
            start(pt) {
              xt();
              function xt() {
                ft.read().then(({ done: St, value: At }) => {
                  if (St) pt.close();
                  else {
                    yt += At.byteLength;
                    const Ct = new ProgressEvent("progress", {
                      lengthComputable: vt,
                      loaded: yt,
                      total: mt,
                    });
                    for (let Mt = 0, wt = ut.length; Mt < wt; Mt++) {
                      const Bt = ut[Mt];
                      Bt.onProgress && Bt.onProgress(Ct);
                    }
                    pt.enqueue(At), xt();
                  }
                });
              }
            },
          });
          return new Response(Et);
        } else
          throw new HttpError(
            `fetch for "${ct.url}" responded with ${ct.status}: ${ct.statusText}`,
            ct
          );
      })
      .then((ct) => {
        switch (lt) {
          case "arraybuffer":
            return ct.arrayBuffer();
          case "blob":
            return ct.blob();
          case "document":
            return ct
              .text()
              .then((ut) => new DOMParser().parseFromString(ut, at));
          case "json":
            return ct.json();
          default:
            if (at === void 0) return ct.text();
            {
              const ft = /charset="?([^;"\s]*)"?/i.exec(at),
                ht = ft && ft[1] ? ft[1].toLowerCase() : void 0,
                mt = new TextDecoder(ht);
              return ct.arrayBuffer().then((vt) => mt.decode(vt));
            }
        }
      })
      .then((ct) => {
        Cache.add(et, ct);
        const ut = loading[et];
        delete loading[et];
        for (let ft = 0, ht = ut.length; ft < ht; ft++) {
          const mt = ut[ft];
          mt.onLoad && mt.onLoad(ct);
        }
      })
      .catch((ct) => {
        const ut = loading[et];
        if (ut === void 0) throw (this.manager.itemError(et), ct);
        delete loading[et];
        for (let ft = 0, ht = ut.length; ft < ht; ft++) {
          const mt = ut[ft];
          mt.onError && mt.onError(ct);
        }
        this.manager.itemError(et);
      })
      .finally(() => {
        this.manager.itemEnd(et);
      }),
      this.manager.itemStart(et);
  }
  setResponseType(et) {
    return (this.responseType = et), this;
  }
  setMimeType(et) {
    return (this.mimeType = et), this;
  }
}
class AnimationLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = new FileLoader(this.manager);
    ot.setPath(this.path),
      ot.setRequestHeader(this.requestHeader),
      ot.setWithCredentials(this.withCredentials),
      ot.load(
        et,
        function (at) {
          try {
            nt(st.parse(JSON.parse(at)));
          } catch (lt) {
            it ? it(lt) : console.error(lt), st.manager.itemError(et);
          }
        },
        rt,
        it
      );
  }
  parse(et) {
    const nt = [];
    for (let rt = 0; rt < et.length; rt++) {
      const it = AnimationClip.parse(et[rt]);
      nt.push(it);
    }
    return nt;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = [],
      at = new CompressedTexture(),
      lt = new FileLoader(this.manager);
    lt.setPath(this.path),
      lt.setResponseType("arraybuffer"),
      lt.setRequestHeader(this.requestHeader),
      lt.setWithCredentials(st.withCredentials);
    let ct = 0;
    function ut(ft) {
      lt.load(
        et[ft],
        function (ht) {
          const mt = st.parse(ht, !0);
          (ot[ft] = {
            width: mt.width,
            height: mt.height,
            format: mt.format,
            mipmaps: mt.mipmaps,
          }),
            (ct += 1),
            ct === 6 &&
              (mt.mipmapCount === 1 && (at.minFilter = LinearFilter),
              (at.image = ot),
              (at.format = mt.format),
              (at.needsUpdate = !0),
              nt && nt(at));
        },
        rt,
        it
      );
    }
    if (Array.isArray(et))
      for (let ft = 0, ht = et.length; ft < ht; ++ft) ut(ft);
    else
      lt.load(
        et,
        function (ft) {
          const ht = st.parse(ft, !0);
          if (ht.isCubemap) {
            const mt = ht.mipmaps.length / ht.mipmapCount;
            for (let vt = 0; vt < mt; vt++) {
              ot[vt] = { mipmaps: [] };
              for (let yt = 0; yt < ht.mipmapCount; yt++)
                ot[vt].mipmaps.push(ht.mipmaps[vt * ht.mipmapCount + yt]),
                  (ot[vt].format = ht.format),
                  (ot[vt].width = ht.width),
                  (ot[vt].height = ht.height);
            }
            at.image = ot;
          } else
            (at.image.width = ht.width),
              (at.image.height = ht.height),
              (at.mipmaps = ht.mipmaps);
          ht.mipmapCount === 1 && (at.minFilter = LinearFilter),
            (at.format = ht.format),
            (at.needsUpdate = !0),
            nt && nt(at);
        },
        rt,
        it
      );
    return at;
  }
}
class ImageLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    this.path !== void 0 && (et = this.path + et),
      (et = this.manager.resolveURL(et));
    const st = this,
      ot = Cache.get(et);
    if (ot !== void 0)
      return (
        st.manager.itemStart(et),
        setTimeout(function () {
          nt && nt(ot), st.manager.itemEnd(et);
        }, 0),
        ot
      );
    const at = createElementNS("img");
    function lt() {
      ut(), Cache.add(et, this), nt && nt(this), st.manager.itemEnd(et);
    }
    function ct(ft) {
      ut(), it && it(ft), st.manager.itemError(et), st.manager.itemEnd(et);
    }
    function ut() {
      at.removeEventListener("load", lt, !1),
        at.removeEventListener("error", ct, !1);
    }
    return (
      at.addEventListener("load", lt, !1),
      at.addEventListener("error", ct, !1),
      et.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (at.crossOrigin = this.crossOrigin),
      st.manager.itemStart(et),
      (at.src = et),
      at
    );
  }
}
class CubeTextureLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = new CubeTexture();
    st.colorSpace = SRGBColorSpace;
    const ot = new ImageLoader(this.manager);
    ot.setCrossOrigin(this.crossOrigin), ot.setPath(this.path);
    let at = 0;
    function lt(ct) {
      ot.load(
        et[ct],
        function (ut) {
          (st.images[ct] = ut),
            at++,
            at === 6 && ((st.needsUpdate = !0), nt && nt(st));
        },
        void 0,
        it
      );
    }
    for (let ct = 0; ct < et.length; ++ct) lt(ct);
    return st;
  }
}
class DataTextureLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = new DataTexture(),
      at = new FileLoader(this.manager);
    return (
      at.setResponseType("arraybuffer"),
      at.setRequestHeader(this.requestHeader),
      at.setPath(this.path),
      at.setWithCredentials(st.withCredentials),
      at.load(
        et,
        function (lt) {
          let ct;
          try {
            ct = st.parse(lt);
          } catch (ut) {
            if (it !== void 0) it(ut);
            else {
              console.error(ut);
              return;
            }
          }
          ct.image !== void 0
            ? (ot.image = ct.image)
            : ct.data !== void 0 &&
              ((ot.image.width = ct.width),
              (ot.image.height = ct.height),
              (ot.image.data = ct.data)),
            (ot.wrapS = ct.wrapS !== void 0 ? ct.wrapS : ClampToEdgeWrapping),
            (ot.wrapT = ct.wrapT !== void 0 ? ct.wrapT : ClampToEdgeWrapping),
            (ot.magFilter =
              ct.magFilter !== void 0 ? ct.magFilter : LinearFilter),
            (ot.minFilter =
              ct.minFilter !== void 0 ? ct.minFilter : LinearFilter),
            (ot.anisotropy = ct.anisotropy !== void 0 ? ct.anisotropy : 1),
            ct.colorSpace !== void 0
              ? (ot.colorSpace = ct.colorSpace)
              : ct.encoding !== void 0 && (ot.encoding = ct.encoding),
            ct.flipY !== void 0 && (ot.flipY = ct.flipY),
            ct.format !== void 0 && (ot.format = ct.format),
            ct.type !== void 0 && (ot.type = ct.type),
            ct.mipmaps !== void 0 &&
              ((ot.mipmaps = ct.mipmaps),
              (ot.minFilter = LinearMipmapLinearFilter)),
            ct.mipmapCount === 1 && (ot.minFilter = LinearFilter),
            ct.generateMipmaps !== void 0 &&
              (ot.generateMipmaps = ct.generateMipmaps),
            (ot.needsUpdate = !0),
            nt && nt(ot, ct);
        },
        rt,
        it
      ),
      ot
    );
  }
}
class TextureLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = new Texture(),
      ot = new ImageLoader(this.manager);
    return (
      ot.setCrossOrigin(this.crossOrigin),
      ot.setPath(this.path),
      ot.load(
        et,
        function (at) {
          (st.image = at), (st.needsUpdate = !0), nt !== void 0 && nt(st);
        },
        rt,
        it
      ),
      st
    );
  }
}
class Light extends Object3D {
  constructor(et, nt = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Color(et)),
      (this.intensity = nt);
  }
  dispose() {}
  copy(et, nt) {
    return (
      super.copy(et, nt),
      this.color.copy(et.color),
      (this.intensity = et.intensity),
      this
    );
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      (nt.object.color = this.color.getHex()),
      (nt.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (nt.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (nt.object.distance = this.distance),
      this.angle !== void 0 && (nt.object.angle = this.angle),
      this.decay !== void 0 && (nt.object.decay = this.decay),
      this.penumbra !== void 0 && (nt.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (nt.object.shadow = this.shadow.toJSON()),
      nt
    );
  }
}
class HemisphereLight extends Light {
  constructor(et, nt, rt) {
    super(et, rt),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Color(nt));
  }
  copy(et, nt) {
    return super.copy(et, nt), this.groundColor.copy(et.groundColor), this;
  }
}
const _projScreenMatrix$1 = new Matrix4(),
  _lightPositionWorld$1 = new Vector3(),
  _lookTarget$1 = new Vector3();
class LightShadow {
  constructor(et) {
    (this.camera = et),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Vector2(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Matrix4()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Frustum()),
      (this._frameExtents = new Vector2(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Vector4(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(et) {
    const nt = this.camera,
      rt = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(et.matrixWorld),
      nt.position.copy(_lightPositionWorld$1),
      _lookTarget$1.setFromMatrixPosition(et.target.matrixWorld),
      nt.lookAt(_lookTarget$1),
      nt.updateMatrixWorld(),
      _projScreenMatrix$1.multiplyMatrices(
        nt.projectionMatrix,
        nt.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
      rt.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      rt.multiply(_projScreenMatrix$1);
  }
  getViewport(et) {
    return this._viewports[et];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(et) {
    return (
      (this.camera = et.camera.clone()),
      (this.bias = et.bias),
      (this.radius = et.radius),
      this.mapSize.copy(et.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const et = {};
    return (
      this.bias !== 0 && (et.bias = this.bias),
      this.normalBias !== 0 && (et.normalBias = this.normalBias),
      this.radius !== 1 && (et.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (et.mapSize = this.mapSize.toArray()),
      (et.camera = this.camera.toJSON(!1).object),
      delete et.camera.matrix,
      et
    );
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(et) {
    const nt = this.camera,
      rt = RAD2DEG * 2 * et.angle * this.focus,
      it = this.mapSize.width / this.mapSize.height,
      st = et.distance || nt.far;
    (rt !== nt.fov || it !== nt.aspect || st !== nt.far) &&
      ((nt.fov = rt),
      (nt.aspect = it),
      (nt.far = st),
      nt.updateProjectionMatrix()),
      super.updateMatrices(et);
  }
  copy(et) {
    return super.copy(et), (this.focus = et.focus), this;
  }
}
class SpotLight extends Light {
  constructor(et, nt, rt = 0, it = Math.PI / 3, st = 0, ot = 2) {
    super(et, nt),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.distance = rt),
      (this.angle = it),
      (this.penumbra = st),
      (this.decay = ot),
      (this.map = null),
      (this.shadow = new SpotLightShadow());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(et) {
    this.intensity = et / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.distance = et.distance),
      (this.angle = et.angle),
      (this.penumbra = et.penumbra),
      (this.decay = et.decay),
      (this.target = et.target.clone()),
      (this.shadow = et.shadow.clone()),
      this
    );
  }
}
const _projScreenMatrix = new Matrix4(),
  _lightPositionWorld = new Vector3(),
  _lookTarget = new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Vector2(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
      ]);
  }
  updateMatrices(et, nt = 0) {
    const rt = this.camera,
      it = this.matrix,
      st = et.distance || rt.far;
    st !== rt.far && ((rt.far = st), rt.updateProjectionMatrix()),
      _lightPositionWorld.setFromMatrixPosition(et.matrixWorld),
      rt.position.copy(_lightPositionWorld),
      _lookTarget.copy(rt.position),
      _lookTarget.add(this._cubeDirections[nt]),
      rt.up.copy(this._cubeUps[nt]),
      rt.lookAt(_lookTarget),
      rt.updateMatrixWorld(),
      it.makeTranslation(
        -_lightPositionWorld.x,
        -_lightPositionWorld.y,
        -_lightPositionWorld.z
      ),
      _projScreenMatrix.multiplyMatrices(
        rt.projectionMatrix,
        rt.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(et, nt, rt = 0, it = 2) {
    super(et, nt),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = rt),
      (this.decay = it),
      (this.shadow = new PointLightShadow());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(et) {
    this.intensity = et / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(et, nt) {
    return (
      super.copy(et, nt),
      (this.distance = et.distance),
      (this.decay = et.decay),
      (this.shadow = et.shadow.clone()),
      this
    );
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0);
  }
}
class DirectionalLight extends Light {
  constructor(et, nt) {
    super(et, nt),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.shadow = new DirectionalLightShadow());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(et) {
    return (
      super.copy(et),
      (this.target = et.target.clone()),
      (this.shadow = et.shadow.clone()),
      this
    );
  }
}
class AmbientLight extends Light {
  constructor(et, nt) {
    super(et, nt), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class RectAreaLight extends Light {
  constructor(et, nt, rt = 10, it = 10) {
    super(et, nt),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = rt),
      (this.height = it);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(et) {
    this.intensity = et / (this.width * this.height * Math.PI);
  }
  copy(et) {
    return (
      super.copy(et), (this.width = et.width), (this.height = et.height), this
    );
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (nt.object.width = this.width), (nt.object.height = this.height), nt;
  }
}
class SphericalHarmonics3 {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let et = 0; et < 9; et++) this.coefficients.push(new Vector3());
  }
  set(et) {
    for (let nt = 0; nt < 9; nt++) this.coefficients[nt].copy(et[nt]);
    return this;
  }
  zero() {
    for (let et = 0; et < 9; et++) this.coefficients[et].set(0, 0, 0);
    return this;
  }
  getAt(et, nt) {
    const rt = et.x,
      it = et.y,
      st = et.z,
      ot = this.coefficients;
    return (
      nt.copy(ot[0]).multiplyScalar(0.282095),
      nt.addScaledVector(ot[1], 0.488603 * it),
      nt.addScaledVector(ot[2], 0.488603 * st),
      nt.addScaledVector(ot[3], 0.488603 * rt),
      nt.addScaledVector(ot[4], 1.092548 * (rt * it)),
      nt.addScaledVector(ot[5], 1.092548 * (it * st)),
      nt.addScaledVector(ot[6], 0.315392 * (3 * st * st - 1)),
      nt.addScaledVector(ot[7], 1.092548 * (rt * st)),
      nt.addScaledVector(ot[8], 0.546274 * (rt * rt - it * it)),
      nt
    );
  }
  getIrradianceAt(et, nt) {
    const rt = et.x,
      it = et.y,
      st = et.z,
      ot = this.coefficients;
    return (
      nt.copy(ot[0]).multiplyScalar(0.886227),
      nt.addScaledVector(ot[1], 2 * 0.511664 * it),
      nt.addScaledVector(ot[2], 2 * 0.511664 * st),
      nt.addScaledVector(ot[3], 2 * 0.511664 * rt),
      nt.addScaledVector(ot[4], 2 * 0.429043 * rt * it),
      nt.addScaledVector(ot[5], 2 * 0.429043 * it * st),
      nt.addScaledVector(ot[6], 0.743125 * st * st - 0.247708),
      nt.addScaledVector(ot[7], 2 * 0.429043 * rt * st),
      nt.addScaledVector(ot[8], 0.429043 * (rt * rt - it * it)),
      nt
    );
  }
  add(et) {
    for (let nt = 0; nt < 9; nt++)
      this.coefficients[nt].add(et.coefficients[nt]);
    return this;
  }
  addScaledSH(et, nt) {
    for (let rt = 0; rt < 9; rt++)
      this.coefficients[rt].addScaledVector(et.coefficients[rt], nt);
    return this;
  }
  scale(et) {
    for (let nt = 0; nt < 9; nt++) this.coefficients[nt].multiplyScalar(et);
    return this;
  }
  lerp(et, nt) {
    for (let rt = 0; rt < 9; rt++)
      this.coefficients[rt].lerp(et.coefficients[rt], nt);
    return this;
  }
  equals(et) {
    for (let nt = 0; nt < 9; nt++)
      if (!this.coefficients[nt].equals(et.coefficients[nt])) return !1;
    return !0;
  }
  copy(et) {
    return this.set(et.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(et, nt = 0) {
    const rt = this.coefficients;
    for (let it = 0; it < 9; it++) rt[it].fromArray(et, nt + it * 3);
    return this;
  }
  toArray(et = [], nt = 0) {
    const rt = this.coefficients;
    for (let it = 0; it < 9; it++) rt[it].toArray(et, nt + it * 3);
    return et;
  }
  static getBasisAt(et, nt) {
    const rt = et.x,
      it = et.y,
      st = et.z;
    (nt[0] = 0.282095),
      (nt[1] = 0.488603 * it),
      (nt[2] = 0.488603 * st),
      (nt[3] = 0.488603 * rt),
      (nt[4] = 1.092548 * rt * it),
      (nt[5] = 1.092548 * it * st),
      (nt[6] = 0.315392 * (3 * st * st - 1)),
      (nt[7] = 1.092548 * rt * st),
      (nt[8] = 0.546274 * (rt * rt - it * it));
  }
}
class LightProbe extends Light {
  constructor(et = new SphericalHarmonics3(), nt = 1) {
    super(void 0, nt), (this.isLightProbe = !0), (this.sh = et);
  }
  copy(et) {
    return super.copy(et), this.sh.copy(et.sh), this;
  }
  fromJSON(et) {
    return (this.intensity = et.intensity), this.sh.fromArray(et.sh), this;
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (nt.object.sh = this.sh.toArray()), nt;
  }
}
class MaterialLoader extends Loader {
  constructor(et) {
    super(et), (this.textures = {});
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = new FileLoader(st.manager);
    ot.setPath(st.path),
      ot.setRequestHeader(st.requestHeader),
      ot.setWithCredentials(st.withCredentials),
      ot.load(
        et,
        function (at) {
          try {
            nt(st.parse(JSON.parse(at)));
          } catch (lt) {
            it ? it(lt) : console.error(lt), st.manager.itemError(et);
          }
        },
        rt,
        it
      );
  }
  parse(et) {
    const nt = this.textures;
    function rt(st) {
      return (
        nt[st] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", st),
        nt[st]
      );
    }
    const it = MaterialLoader.createMaterialFromType(et.type);
    if (
      (et.uuid !== void 0 && (it.uuid = et.uuid),
      et.name !== void 0 && (it.name = et.name),
      et.color !== void 0 && it.color !== void 0 && it.color.setHex(et.color),
      et.roughness !== void 0 && (it.roughness = et.roughness),
      et.metalness !== void 0 && (it.metalness = et.metalness),
      et.sheen !== void 0 && (it.sheen = et.sheen),
      et.sheenColor !== void 0 &&
        (it.sheenColor = new Color().setHex(et.sheenColor)),
      et.sheenRoughness !== void 0 && (it.sheenRoughness = et.sheenRoughness),
      et.emissive !== void 0 &&
        it.emissive !== void 0 &&
        it.emissive.setHex(et.emissive),
      et.specular !== void 0 &&
        it.specular !== void 0 &&
        it.specular.setHex(et.specular),
      et.specularIntensity !== void 0 &&
        (it.specularIntensity = et.specularIntensity),
      et.specularColor !== void 0 &&
        it.specularColor !== void 0 &&
        it.specularColor.setHex(et.specularColor),
      et.shininess !== void 0 && (it.shininess = et.shininess),
      et.clearcoat !== void 0 && (it.clearcoat = et.clearcoat),
      et.clearcoatRoughness !== void 0 &&
        (it.clearcoatRoughness = et.clearcoatRoughness),
      et.iridescence !== void 0 && (it.iridescence = et.iridescence),
      et.iridescenceIOR !== void 0 && (it.iridescenceIOR = et.iridescenceIOR),
      et.iridescenceThicknessRange !== void 0 &&
        (it.iridescenceThicknessRange = et.iridescenceThicknessRange),
      et.transmission !== void 0 && (it.transmission = et.transmission),
      et.thickness !== void 0 && (it.thickness = et.thickness),
      et.attenuationDistance !== void 0 &&
        (it.attenuationDistance = et.attenuationDistance),
      et.attenuationColor !== void 0 &&
        it.attenuationColor !== void 0 &&
        it.attenuationColor.setHex(et.attenuationColor),
      et.anisotropy !== void 0 && (it.anisotropy = et.anisotropy),
      et.anisotropyRotation !== void 0 &&
        (it.anisotropyRotation = et.anisotropyRotation),
      et.fog !== void 0 && (it.fog = et.fog),
      et.flatShading !== void 0 && (it.flatShading = et.flatShading),
      et.blending !== void 0 && (it.blending = et.blending),
      et.combine !== void 0 && (it.combine = et.combine),
      et.side !== void 0 && (it.side = et.side),
      et.shadowSide !== void 0 && (it.shadowSide = et.shadowSide),
      et.opacity !== void 0 && (it.opacity = et.opacity),
      et.transparent !== void 0 && (it.transparent = et.transparent),
      et.alphaTest !== void 0 && (it.alphaTest = et.alphaTest),
      et.alphaHash !== void 0 && (it.alphaHash = et.alphaHash),
      et.depthTest !== void 0 && (it.depthTest = et.depthTest),
      et.depthWrite !== void 0 && (it.depthWrite = et.depthWrite),
      et.colorWrite !== void 0 && (it.colorWrite = et.colorWrite),
      et.stencilWrite !== void 0 && (it.stencilWrite = et.stencilWrite),
      et.stencilWriteMask !== void 0 &&
        (it.stencilWriteMask = et.stencilWriteMask),
      et.stencilFunc !== void 0 && (it.stencilFunc = et.stencilFunc),
      et.stencilRef !== void 0 && (it.stencilRef = et.stencilRef),
      et.stencilFuncMask !== void 0 &&
        (it.stencilFuncMask = et.stencilFuncMask),
      et.stencilFail !== void 0 && (it.stencilFail = et.stencilFail),
      et.stencilZFail !== void 0 && (it.stencilZFail = et.stencilZFail),
      et.stencilZPass !== void 0 && (it.stencilZPass = et.stencilZPass),
      et.wireframe !== void 0 && (it.wireframe = et.wireframe),
      et.wireframeLinewidth !== void 0 &&
        (it.wireframeLinewidth = et.wireframeLinewidth),
      et.wireframeLinecap !== void 0 &&
        (it.wireframeLinecap = et.wireframeLinecap),
      et.wireframeLinejoin !== void 0 &&
        (it.wireframeLinejoin = et.wireframeLinejoin),
      et.rotation !== void 0 && (it.rotation = et.rotation),
      et.linewidth !== void 0 && (it.linewidth = et.linewidth),
      et.dashSize !== void 0 && (it.dashSize = et.dashSize),
      et.gapSize !== void 0 && (it.gapSize = et.gapSize),
      et.scale !== void 0 && (it.scale = et.scale),
      et.polygonOffset !== void 0 && (it.polygonOffset = et.polygonOffset),
      et.polygonOffsetFactor !== void 0 &&
        (it.polygonOffsetFactor = et.polygonOffsetFactor),
      et.polygonOffsetUnits !== void 0 &&
        (it.polygonOffsetUnits = et.polygonOffsetUnits),
      et.dithering !== void 0 && (it.dithering = et.dithering),
      et.alphaToCoverage !== void 0 &&
        (it.alphaToCoverage = et.alphaToCoverage),
      et.premultipliedAlpha !== void 0 &&
        (it.premultipliedAlpha = et.premultipliedAlpha),
      et.forceSinglePass !== void 0 &&
        (it.forceSinglePass = et.forceSinglePass),
      et.visible !== void 0 && (it.visible = et.visible),
      et.toneMapped !== void 0 && (it.toneMapped = et.toneMapped),
      et.userData !== void 0 && (it.userData = et.userData),
      et.vertexColors !== void 0 &&
        (typeof et.vertexColors == "number"
          ? (it.vertexColors = et.vertexColors > 0)
          : (it.vertexColors = et.vertexColors)),
      et.uniforms !== void 0)
    )
      for (const st in et.uniforms) {
        const ot = et.uniforms[st];
        switch (((it.uniforms[st] = {}), ot.type)) {
          case "t":
            it.uniforms[st].value = rt(ot.value);
            break;
          case "c":
            it.uniforms[st].value = new Color().setHex(ot.value);
            break;
          case "v2":
            it.uniforms[st].value = new Vector2().fromArray(ot.value);
            break;
          case "v3":
            it.uniforms[st].value = new Vector3().fromArray(ot.value);
            break;
          case "v4":
            it.uniforms[st].value = new Vector4().fromArray(ot.value);
            break;
          case "m3":
            it.uniforms[st].value = new Matrix3().fromArray(ot.value);
            break;
          case "m4":
            it.uniforms[st].value = new Matrix4().fromArray(ot.value);
            break;
          default:
            it.uniforms[st].value = ot.value;
        }
      }
    if (
      (et.defines !== void 0 && (it.defines = et.defines),
      et.vertexShader !== void 0 && (it.vertexShader = et.vertexShader),
      et.fragmentShader !== void 0 && (it.fragmentShader = et.fragmentShader),
      et.glslVersion !== void 0 && (it.glslVersion = et.glslVersion),
      et.extensions !== void 0)
    )
      for (const st in et.extensions) it.extensions[st] = et.extensions[st];
    if (
      (et.lights !== void 0 && (it.lights = et.lights),
      et.clipping !== void 0 && (it.clipping = et.clipping),
      et.size !== void 0 && (it.size = et.size),
      et.sizeAttenuation !== void 0 &&
        (it.sizeAttenuation = et.sizeAttenuation),
      et.map !== void 0 && (it.map = rt(et.map)),
      et.matcap !== void 0 && (it.matcap = rt(et.matcap)),
      et.alphaMap !== void 0 && (it.alphaMap = rt(et.alphaMap)),
      et.bumpMap !== void 0 && (it.bumpMap = rt(et.bumpMap)),
      et.bumpScale !== void 0 && (it.bumpScale = et.bumpScale),
      et.normalMap !== void 0 && (it.normalMap = rt(et.normalMap)),
      et.normalMapType !== void 0 && (it.normalMapType = et.normalMapType),
      et.normalScale !== void 0)
    ) {
      let st = et.normalScale;
      Array.isArray(st) === !1 && (st = [st, st]),
        (it.normalScale = new Vector2().fromArray(st));
    }
    return (
      et.displacementMap !== void 0 &&
        (it.displacementMap = rt(et.displacementMap)),
      et.displacementScale !== void 0 &&
        (it.displacementScale = et.displacementScale),
      et.displacementBias !== void 0 &&
        (it.displacementBias = et.displacementBias),
      et.roughnessMap !== void 0 && (it.roughnessMap = rt(et.roughnessMap)),
      et.metalnessMap !== void 0 && (it.metalnessMap = rt(et.metalnessMap)),
      et.emissiveMap !== void 0 && (it.emissiveMap = rt(et.emissiveMap)),
      et.emissiveIntensity !== void 0 &&
        (it.emissiveIntensity = et.emissiveIntensity),
      et.specularMap !== void 0 && (it.specularMap = rt(et.specularMap)),
      et.specularIntensityMap !== void 0 &&
        (it.specularIntensityMap = rt(et.specularIntensityMap)),
      et.specularColorMap !== void 0 &&
        (it.specularColorMap = rt(et.specularColorMap)),
      et.envMap !== void 0 && (it.envMap = rt(et.envMap)),
      et.envMapIntensity !== void 0 &&
        (it.envMapIntensity = et.envMapIntensity),
      et.reflectivity !== void 0 && (it.reflectivity = et.reflectivity),
      et.refractionRatio !== void 0 &&
        (it.refractionRatio = et.refractionRatio),
      et.lightMap !== void 0 && (it.lightMap = rt(et.lightMap)),
      et.lightMapIntensity !== void 0 &&
        (it.lightMapIntensity = et.lightMapIntensity),
      et.aoMap !== void 0 && (it.aoMap = rt(et.aoMap)),
      et.aoMapIntensity !== void 0 && (it.aoMapIntensity = et.aoMapIntensity),
      et.gradientMap !== void 0 && (it.gradientMap = rt(et.gradientMap)),
      et.clearcoatMap !== void 0 && (it.clearcoatMap = rt(et.clearcoatMap)),
      et.clearcoatRoughnessMap !== void 0 &&
        (it.clearcoatRoughnessMap = rt(et.clearcoatRoughnessMap)),
      et.clearcoatNormalMap !== void 0 &&
        (it.clearcoatNormalMap = rt(et.clearcoatNormalMap)),
      et.clearcoatNormalScale !== void 0 &&
        (it.clearcoatNormalScale = new Vector2().fromArray(
          et.clearcoatNormalScale
        )),
      et.iridescenceMap !== void 0 &&
        (it.iridescenceMap = rt(et.iridescenceMap)),
      et.iridescenceThicknessMap !== void 0 &&
        (it.iridescenceThicknessMap = rt(et.iridescenceThicknessMap)),
      et.transmissionMap !== void 0 &&
        (it.transmissionMap = rt(et.transmissionMap)),
      et.thicknessMap !== void 0 && (it.thicknessMap = rt(et.thicknessMap)),
      et.anisotropyMap !== void 0 && (it.anisotropyMap = rt(et.anisotropyMap)),
      et.sheenColorMap !== void 0 && (it.sheenColorMap = rt(et.sheenColorMap)),
      et.sheenRoughnessMap !== void 0 &&
        (it.sheenRoughnessMap = rt(et.sheenRoughnessMap)),
      it
    );
  }
  setTextures(et) {
    return (this.textures = et), this;
  }
  static createMaterialFromType(et) {
    const nt = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    };
    return new nt[et]();
  }
}
class LoaderUtils {
  static decodeText(et) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(et);
    let nt = "";
    for (let rt = 0, it = et.length; rt < it; rt++)
      nt += String.fromCharCode(et[rt]);
    try {
      return decodeURIComponent(escape(nt));
    } catch {
      return nt;
    }
  }
  static extractUrlBase(et) {
    const nt = et.lastIndexOf("/");
    return nt === -1 ? "./" : et.slice(0, nt + 1);
  }
  static resolveURL(et, nt) {
    return typeof et != "string" || et === ""
      ? ""
      : (/^https?:\/\//i.test(nt) &&
          /^\//.test(et) &&
          (nt = nt.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(et) ||
        /^data:.*,.*$/i.test(et) ||
        /^blob:.*$/i.test(et)
          ? et
          : nt + et);
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(et) {
    return super.copy(et), (this.instanceCount = et.instanceCount), this;
  }
  toJSON() {
    const et = super.toJSON();
    return (
      (et.instanceCount = this.instanceCount),
      (et.isInstancedBufferGeometry = !0),
      et
    );
  }
}
class BufferGeometryLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = new FileLoader(st.manager);
    ot.setPath(st.path),
      ot.setRequestHeader(st.requestHeader),
      ot.setWithCredentials(st.withCredentials),
      ot.load(
        et,
        function (at) {
          try {
            nt(st.parse(JSON.parse(at)));
          } catch (lt) {
            it ? it(lt) : console.error(lt), st.manager.itemError(et);
          }
        },
        rt,
        it
      );
  }
  parse(et) {
    const nt = {},
      rt = {};
    function it(mt, vt) {
      if (nt[vt] !== void 0) return nt[vt];
      const Et = mt.interleavedBuffers[vt],
        pt = st(mt, Et.buffer),
        xt = getTypedArray(Et.type, pt),
        St = new InterleavedBuffer(xt, Et.stride);
      return (St.uuid = Et.uuid), (nt[vt] = St), St;
    }
    function st(mt, vt) {
      if (rt[vt] !== void 0) return rt[vt];
      const Et = mt.arrayBuffers[vt],
        pt = new Uint32Array(Et).buffer;
      return (rt[vt] = pt), pt;
    }
    const ot = et.isInstancedBufferGeometry
        ? new InstancedBufferGeometry()
        : new BufferGeometry(),
      at = et.data.index;
    if (at !== void 0) {
      const mt = getTypedArray(at.type, at.array);
      ot.setIndex(new BufferAttribute(mt, 1));
    }
    const lt = et.data.attributes;
    for (const mt in lt) {
      const vt = lt[mt];
      let yt;
      if (vt.isInterleavedBufferAttribute) {
        const Et = it(et.data, vt.data);
        yt = new InterleavedBufferAttribute(
          Et,
          vt.itemSize,
          vt.offset,
          vt.normalized
        );
      } else {
        const Et = getTypedArray(vt.type, vt.array),
          pt = vt.isInstancedBufferAttribute
            ? InstancedBufferAttribute
            : BufferAttribute;
        yt = new pt(Et, vt.itemSize, vt.normalized);
      }
      vt.name !== void 0 && (yt.name = vt.name),
        vt.usage !== void 0 && yt.setUsage(vt.usage),
        vt.updateRange !== void 0 &&
          ((yt.updateRange.offset = vt.updateRange.offset),
          (yt.updateRange.count = vt.updateRange.count)),
        ot.setAttribute(mt, yt);
    }
    const ct = et.data.morphAttributes;
    if (ct)
      for (const mt in ct) {
        const vt = ct[mt],
          yt = [];
        for (let Et = 0, pt = vt.length; Et < pt; Et++) {
          const xt = vt[Et];
          let St;
          if (xt.isInterleavedBufferAttribute) {
            const At = it(et.data, xt.data);
            St = new InterleavedBufferAttribute(
              At,
              xt.itemSize,
              xt.offset,
              xt.normalized
            );
          } else {
            const At = getTypedArray(xt.type, xt.array);
            St = new BufferAttribute(At, xt.itemSize, xt.normalized);
          }
          xt.name !== void 0 && (St.name = xt.name), yt.push(St);
        }
        ot.morphAttributes[mt] = yt;
      }
    et.data.morphTargetsRelative && (ot.morphTargetsRelative = !0);
    const ft = et.data.groups || et.data.drawcalls || et.data.offsets;
    if (ft !== void 0)
      for (let mt = 0, vt = ft.length; mt !== vt; ++mt) {
        const yt = ft[mt];
        ot.addGroup(yt.start, yt.count, yt.materialIndex);
      }
    const ht = et.data.boundingSphere;
    if (ht !== void 0) {
      const mt = new Vector3();
      ht.center !== void 0 && mt.fromArray(ht.center),
        (ot.boundingSphere = new Sphere(mt, ht.radius));
    }
    return (
      et.name && (ot.name = et.name),
      et.userData && (ot.userData = et.userData),
      ot
    );
  }
}
class ObjectLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = this.path === "" ? LoaderUtils.extractUrlBase(et) : this.path;
    this.resourcePath = this.resourcePath || ot;
    const at = new FileLoader(this.manager);
    at.setPath(this.path),
      at.setRequestHeader(this.requestHeader),
      at.setWithCredentials(this.withCredentials),
      at.load(
        et,
        function (lt) {
          let ct = null;
          try {
            ct = JSON.parse(lt);
          } catch (ft) {
            it !== void 0 && it(ft),
              console.error(
                "THREE:ObjectLoader: Can't parse " + et + ".",
                ft.message
              );
            return;
          }
          const ut = ct.metadata;
          if (
            ut === void 0 ||
            ut.type === void 0 ||
            ut.type.toLowerCase() === "geometry"
          ) {
            it !== void 0 &&
              it(new Error("THREE.ObjectLoader: Can't load " + et)),
              console.error("THREE.ObjectLoader: Can't load " + et);
            return;
          }
          st.parse(ct, nt);
        },
        rt,
        it
      );
  }
  async loadAsync(et, nt) {
    const rt = this,
      it = this.path === "" ? LoaderUtils.extractUrlBase(et) : this.path;
    this.resourcePath = this.resourcePath || it;
    const st = new FileLoader(this.manager);
    st.setPath(this.path),
      st.setRequestHeader(this.requestHeader),
      st.setWithCredentials(this.withCredentials);
    const ot = await st.loadAsync(et, nt),
      at = JSON.parse(ot),
      lt = at.metadata;
    if (
      lt === void 0 ||
      lt.type === void 0 ||
      lt.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + et);
    return await rt.parseAsync(at);
  }
  parse(et, nt) {
    const rt = this.parseAnimations(et.animations),
      it = this.parseShapes(et.shapes),
      st = this.parseGeometries(et.geometries, it),
      ot = this.parseImages(et.images, function () {
        nt !== void 0 && nt(ct);
      }),
      at = this.parseTextures(et.textures, ot),
      lt = this.parseMaterials(et.materials, at),
      ct = this.parseObject(et.object, st, lt, at, rt),
      ut = this.parseSkeletons(et.skeletons, ct);
    if ((this.bindSkeletons(ct, ut), nt !== void 0)) {
      let ft = !1;
      for (const ht in ot)
        if (ot[ht].data instanceof HTMLImageElement) {
          ft = !0;
          break;
        }
      ft === !1 && nt(ct);
    }
    return ct;
  }
  async parseAsync(et) {
    const nt = this.parseAnimations(et.animations),
      rt = this.parseShapes(et.shapes),
      it = this.parseGeometries(et.geometries, rt),
      st = await this.parseImagesAsync(et.images),
      ot = this.parseTextures(et.textures, st),
      at = this.parseMaterials(et.materials, ot),
      lt = this.parseObject(et.object, it, at, ot, nt),
      ct = this.parseSkeletons(et.skeletons, lt);
    return this.bindSkeletons(lt, ct), lt;
  }
  parseShapes(et) {
    const nt = {};
    if (et !== void 0)
      for (let rt = 0, it = et.length; rt < it; rt++) {
        const st = new Shape().fromJSON(et[rt]);
        nt[st.uuid] = st;
      }
    return nt;
  }
  parseSkeletons(et, nt) {
    const rt = {},
      it = {};
    if (
      (nt.traverse(function (st) {
        st.isBone && (it[st.uuid] = st);
      }),
      et !== void 0)
    )
      for (let st = 0, ot = et.length; st < ot; st++) {
        const at = new Skeleton().fromJSON(et[st], it);
        rt[at.uuid] = at;
      }
    return rt;
  }
  parseGeometries(et, nt) {
    const rt = {};
    if (et !== void 0) {
      const it = new BufferGeometryLoader();
      for (let st = 0, ot = et.length; st < ot; st++) {
        let at;
        const lt = et[st];
        switch (lt.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            at = it.parse(lt);
            break;
          default:
            lt.type in Geometries
              ? (at = Geometries[lt.type].fromJSON(lt, nt))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${lt.type}"`
                );
        }
        (at.uuid = lt.uuid),
          lt.name !== void 0 && (at.name = lt.name),
          lt.userData !== void 0 && (at.userData = lt.userData),
          (rt[lt.uuid] = at);
      }
    }
    return rt;
  }
  parseMaterials(et, nt) {
    const rt = {},
      it = {};
    if (et !== void 0) {
      const st = new MaterialLoader();
      st.setTextures(nt);
      for (let ot = 0, at = et.length; ot < at; ot++) {
        const lt = et[ot];
        rt[lt.uuid] === void 0 && (rt[lt.uuid] = st.parse(lt)),
          (it[lt.uuid] = rt[lt.uuid]);
      }
    }
    return it;
  }
  parseAnimations(et) {
    const nt = {};
    if (et !== void 0)
      for (let rt = 0; rt < et.length; rt++) {
        const it = et[rt],
          st = AnimationClip.parse(it);
        nt[st.uuid] = st;
      }
    return nt;
  }
  parseImages(et, nt) {
    const rt = this,
      it = {};
    let st;
    function ot(lt) {
      return (
        rt.manager.itemStart(lt),
        st.load(
          lt,
          function () {
            rt.manager.itemEnd(lt);
          },
          void 0,
          function () {
            rt.manager.itemError(lt), rt.manager.itemEnd(lt);
          }
        )
      );
    }
    function at(lt) {
      if (typeof lt == "string") {
        const ct = lt,
          ut = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(ct) ? ct : rt.resourcePath + ct;
        return ot(ut);
      } else
        return lt.data
          ? {
              data: getTypedArray(lt.type, lt.data),
              width: lt.width,
              height: lt.height,
            }
          : null;
    }
    if (et !== void 0 && et.length > 0) {
      const lt = new LoadingManager(nt);
      (st = new ImageLoader(lt)), st.setCrossOrigin(this.crossOrigin);
      for (let ct = 0, ut = et.length; ct < ut; ct++) {
        const ft = et[ct],
          ht = ft.url;
        if (Array.isArray(ht)) {
          const mt = [];
          for (let vt = 0, yt = ht.length; vt < yt; vt++) {
            const Et = ht[vt],
              pt = at(Et);
            pt !== null &&
              (pt instanceof HTMLImageElement
                ? mt.push(pt)
                : mt.push(new DataTexture(pt.data, pt.width, pt.height)));
          }
          it[ft.uuid] = new Source(mt);
        } else {
          const mt = at(ft.url);
          it[ft.uuid] = new Source(mt);
        }
      }
    }
    return it;
  }
  async parseImagesAsync(et) {
    const nt = this,
      rt = {};
    let it;
    async function st(ot) {
      if (typeof ot == "string") {
        const at = ot,
          lt = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(at) ? at : nt.resourcePath + at;
        return await it.loadAsync(lt);
      } else
        return ot.data
          ? {
              data: getTypedArray(ot.type, ot.data),
              width: ot.width,
              height: ot.height,
            }
          : null;
    }
    if (et !== void 0 && et.length > 0) {
      (it = new ImageLoader(this.manager)), it.setCrossOrigin(this.crossOrigin);
      for (let ot = 0, at = et.length; ot < at; ot++) {
        const lt = et[ot],
          ct = lt.url;
        if (Array.isArray(ct)) {
          const ut = [];
          for (let ft = 0, ht = ct.length; ft < ht; ft++) {
            const mt = ct[ft],
              vt = await st(mt);
            vt !== null &&
              (vt instanceof HTMLImageElement
                ? ut.push(vt)
                : ut.push(new DataTexture(vt.data, vt.width, vt.height)));
          }
          rt[lt.uuid] = new Source(ut);
        } else {
          const ut = await st(lt.url);
          rt[lt.uuid] = new Source(ut);
        }
      }
    }
    return rt;
  }
  parseTextures(et, nt) {
    function rt(st, ot) {
      return typeof st == "number"
        ? st
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            st
          ),
          ot[st]);
    }
    const it = {};
    if (et !== void 0)
      for (let st = 0, ot = et.length; st < ot; st++) {
        const at = et[st];
        at.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', at.uuid),
          nt[at.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", at.image);
        const lt = nt[at.image],
          ct = lt.data;
        let ut;
        Array.isArray(ct)
          ? ((ut = new CubeTexture()), ct.length === 6 && (ut.needsUpdate = !0))
          : (ct && ct.data ? (ut = new DataTexture()) : (ut = new Texture()),
            ct && (ut.needsUpdate = !0)),
          (ut.source = lt),
          (ut.uuid = at.uuid),
          at.name !== void 0 && (ut.name = at.name),
          at.mapping !== void 0 &&
            (ut.mapping = rt(at.mapping, TEXTURE_MAPPING)),
          at.channel !== void 0 && (ut.channel = at.channel),
          at.offset !== void 0 && ut.offset.fromArray(at.offset),
          at.repeat !== void 0 && ut.repeat.fromArray(at.repeat),
          at.center !== void 0 && ut.center.fromArray(at.center),
          at.rotation !== void 0 && (ut.rotation = at.rotation),
          at.wrap !== void 0 &&
            ((ut.wrapS = rt(at.wrap[0], TEXTURE_WRAPPING)),
            (ut.wrapT = rt(at.wrap[1], TEXTURE_WRAPPING))),
          at.format !== void 0 && (ut.format = at.format),
          at.internalFormat !== void 0 &&
            (ut.internalFormat = at.internalFormat),
          at.type !== void 0 && (ut.type = at.type),
          at.colorSpace !== void 0 && (ut.colorSpace = at.colorSpace),
          at.encoding !== void 0 && (ut.encoding = at.encoding),
          at.minFilter !== void 0 &&
            (ut.minFilter = rt(at.minFilter, TEXTURE_FILTER)),
          at.magFilter !== void 0 &&
            (ut.magFilter = rt(at.magFilter, TEXTURE_FILTER)),
          at.anisotropy !== void 0 && (ut.anisotropy = at.anisotropy),
          at.flipY !== void 0 && (ut.flipY = at.flipY),
          at.generateMipmaps !== void 0 &&
            (ut.generateMipmaps = at.generateMipmaps),
          at.premultiplyAlpha !== void 0 &&
            (ut.premultiplyAlpha = at.premultiplyAlpha),
          at.unpackAlignment !== void 0 &&
            (ut.unpackAlignment = at.unpackAlignment),
          at.compareFunction !== void 0 &&
            (ut.compareFunction = at.compareFunction),
          at.userData !== void 0 && (ut.userData = at.userData),
          (it[at.uuid] = ut);
      }
    return it;
  }
  parseObject(et, nt, rt, it, st) {
    let ot;
    function at(ht) {
      return (
        nt[ht] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", ht),
        nt[ht]
      );
    }
    function lt(ht) {
      if (ht !== void 0) {
        if (Array.isArray(ht)) {
          const mt = [];
          for (let vt = 0, yt = ht.length; vt < yt; vt++) {
            const Et = ht[vt];
            rt[Et] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", Et),
              mt.push(rt[Et]);
          }
          return mt;
        }
        return (
          rt[ht] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", ht),
          rt[ht]
        );
      }
    }
    function ct(ht) {
      return (
        it[ht] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", ht),
        it[ht]
      );
    }
    let ut, ft;
    switch (et.type) {
      case "Scene":
        (ot = new Scene$1()),
          et.background !== void 0 &&
            (Number.isInteger(et.background)
              ? (ot.background = new Color(et.background))
              : (ot.background = ct(et.background))),
          et.environment !== void 0 && (ot.environment = ct(et.environment)),
          et.fog !== void 0 &&
            (et.fog.type === "Fog"
              ? (ot.fog = new Fog(et.fog.color, et.fog.near, et.fog.far))
              : et.fog.type === "FogExp2" &&
                (ot.fog = new FogExp2(et.fog.color, et.fog.density)),
            et.fog.name !== "" && (ot.fog.name = et.fog.name)),
          et.backgroundBlurriness !== void 0 &&
            (ot.backgroundBlurriness = et.backgroundBlurriness),
          et.backgroundIntensity !== void 0 &&
            (ot.backgroundIntensity = et.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (ot = new PerspectiveCamera(et.fov, et.aspect, et.near, et.far)),
          et.focus !== void 0 && (ot.focus = et.focus),
          et.zoom !== void 0 && (ot.zoom = et.zoom),
          et.filmGauge !== void 0 && (ot.filmGauge = et.filmGauge),
          et.filmOffset !== void 0 && (ot.filmOffset = et.filmOffset),
          et.view !== void 0 && (ot.view = Object.assign({}, et.view));
        break;
      case "OrthographicCamera":
        (ot = new OrthographicCamera(
          et.left,
          et.right,
          et.top,
          et.bottom,
          et.near,
          et.far
        )),
          et.zoom !== void 0 && (ot.zoom = et.zoom),
          et.view !== void 0 && (ot.view = Object.assign({}, et.view));
        break;
      case "AmbientLight":
        ot = new AmbientLight(et.color, et.intensity);
        break;
      case "DirectionalLight":
        ot = new DirectionalLight(et.color, et.intensity);
        break;
      case "PointLight":
        ot = new PointLight(et.color, et.intensity, et.distance, et.decay);
        break;
      case "RectAreaLight":
        ot = new RectAreaLight(et.color, et.intensity, et.width, et.height);
        break;
      case "SpotLight":
        ot = new SpotLight(
          et.color,
          et.intensity,
          et.distance,
          et.angle,
          et.penumbra,
          et.decay
        );
        break;
      case "HemisphereLight":
        ot = new HemisphereLight(et.color, et.groundColor, et.intensity);
        break;
      case "LightProbe":
        ot = new LightProbe().fromJSON(et);
        break;
      case "SkinnedMesh":
        (ut = at(et.geometry)),
          (ft = lt(et.material)),
          (ot = new SkinnedMesh(ut, ft)),
          et.bindMode !== void 0 && (ot.bindMode = et.bindMode),
          et.bindMatrix !== void 0 && ot.bindMatrix.fromArray(et.bindMatrix),
          et.skeleton !== void 0 && (ot.skeleton = et.skeleton);
        break;
      case "Mesh":
        (ut = at(et.geometry)), (ft = lt(et.material)), (ot = new Mesh(ut, ft));
        break;
      case "InstancedMesh":
        (ut = at(et.geometry)), (ft = lt(et.material));
        const ht = et.count,
          mt = et.instanceMatrix,
          vt = et.instanceColor;
        (ot = new InstancedMesh(ut, ft, ht)),
          (ot.instanceMatrix = new InstancedBufferAttribute(
            new Float32Array(mt.array),
            16
          )),
          vt !== void 0 &&
            (ot.instanceColor = new InstancedBufferAttribute(
              new Float32Array(vt.array),
              vt.itemSize
            ));
        break;
      case "LOD":
        ot = new LOD();
        break;
      case "Line":
        ot = new Line$1(at(et.geometry), lt(et.material));
        break;
      case "LineLoop":
        ot = new LineLoop(at(et.geometry), lt(et.material));
        break;
      case "LineSegments":
        ot = new LineSegments(at(et.geometry), lt(et.material));
        break;
      case "PointCloud":
      case "Points":
        ot = new Points(at(et.geometry), lt(et.material));
        break;
      case "Sprite":
        ot = new Sprite(lt(et.material));
        break;
      case "Group":
        ot = new Group();
        break;
      case "Bone":
        ot = new Bone();
        break;
      default:
        ot = new Object3D();
    }
    if (
      ((ot.uuid = et.uuid),
      et.name !== void 0 && (ot.name = et.name),
      et.matrix !== void 0
        ? (ot.matrix.fromArray(et.matrix),
          et.matrixAutoUpdate !== void 0 &&
            (ot.matrixAutoUpdate = et.matrixAutoUpdate),
          ot.matrixAutoUpdate &&
            ot.matrix.decompose(ot.position, ot.quaternion, ot.scale))
        : (et.position !== void 0 && ot.position.fromArray(et.position),
          et.rotation !== void 0 && ot.rotation.fromArray(et.rotation),
          et.quaternion !== void 0 && ot.quaternion.fromArray(et.quaternion),
          et.scale !== void 0 && ot.scale.fromArray(et.scale)),
      et.up !== void 0 && ot.up.fromArray(et.up),
      et.castShadow !== void 0 && (ot.castShadow = et.castShadow),
      et.receiveShadow !== void 0 && (ot.receiveShadow = et.receiveShadow),
      et.shadow &&
        (et.shadow.bias !== void 0 && (ot.shadow.bias = et.shadow.bias),
        et.shadow.normalBias !== void 0 &&
          (ot.shadow.normalBias = et.shadow.normalBias),
        et.shadow.radius !== void 0 && (ot.shadow.radius = et.shadow.radius),
        et.shadow.mapSize !== void 0 &&
          ot.shadow.mapSize.fromArray(et.shadow.mapSize),
        et.shadow.camera !== void 0 &&
          (ot.shadow.camera = this.parseObject(et.shadow.camera))),
      et.visible !== void 0 && (ot.visible = et.visible),
      et.frustumCulled !== void 0 && (ot.frustumCulled = et.frustumCulled),
      et.renderOrder !== void 0 && (ot.renderOrder = et.renderOrder),
      et.userData !== void 0 && (ot.userData = et.userData),
      et.layers !== void 0 && (ot.layers.mask = et.layers),
      et.children !== void 0)
    ) {
      const ht = et.children;
      for (let mt = 0; mt < ht.length; mt++)
        ot.add(this.parseObject(ht[mt], nt, rt, it, st));
    }
    if (et.animations !== void 0) {
      const ht = et.animations;
      for (let mt = 0; mt < ht.length; mt++) {
        const vt = ht[mt];
        ot.animations.push(st[vt]);
      }
    }
    if (et.type === "LOD") {
      et.autoUpdate !== void 0 && (ot.autoUpdate = et.autoUpdate);
      const ht = et.levels;
      for (let mt = 0; mt < ht.length; mt++) {
        const vt = ht[mt],
          yt = ot.getObjectByProperty("uuid", vt.object);
        yt !== void 0 && ot.addLevel(yt, vt.distance, vt.hysteresis);
      }
    }
    return ot;
  }
  bindSkeletons(et, nt) {
    Object.keys(nt).length !== 0 &&
      et.traverse(function (rt) {
        if (rt.isSkinnedMesh === !0 && rt.skeleton !== void 0) {
          const it = nt[rt.skeleton];
          it === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                rt.skeleton
              )
            : rt.bind(it, rt.bindMatrix);
        }
      });
  }
}
const TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping,
  },
  TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping,
  },
  TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter,
  };
class ImageBitmapLoader extends Loader {
  constructor(et) {
    super(et),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(et) {
    return (this.options = et), this;
  }
  load(et, nt, rt, it) {
    et === void 0 && (et = ""),
      this.path !== void 0 && (et = this.path + et),
      (et = this.manager.resolveURL(et));
    const st = this,
      ot = Cache.get(et);
    if (ot !== void 0)
      return (
        st.manager.itemStart(et),
        setTimeout(function () {
          nt && nt(ot), st.manager.itemEnd(et);
        }, 0),
        ot
      );
    const at = {};
    (at.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (at.headers = this.requestHeader),
      fetch(et, at)
        .then(function (lt) {
          return lt.blob();
        })
        .then(function (lt) {
          return createImageBitmap(
            lt,
            Object.assign(st.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (lt) {
          Cache.add(et, lt), nt && nt(lt), st.manager.itemEnd(et);
        })
        .catch(function (lt) {
          it && it(lt), st.manager.itemError(et), st.manager.itemEnd(et);
        }),
      st.manager.itemStart(et);
  }
}
let _context;
class AudioContext {
  static getContext() {
    return (
      _context === void 0 &&
        (_context = new (window.AudioContext || window.webkitAudioContext)()),
      _context
    );
  }
  static setContext(et) {
    _context = et;
  }
}
class AudioLoader extends Loader {
  constructor(et) {
    super(et);
  }
  load(et, nt, rt, it) {
    const st = this,
      ot = new FileLoader(this.manager);
    ot.setResponseType("arraybuffer"),
      ot.setPath(this.path),
      ot.setRequestHeader(this.requestHeader),
      ot.setWithCredentials(this.withCredentials),
      ot.load(
        et,
        function (lt) {
          try {
            const ct = lt.slice(0);
            AudioContext.getContext().decodeAudioData(
              ct,
              function (ft) {
                nt(ft);
              },
              at
            );
          } catch (ct) {
            at(ct);
          }
        },
        rt,
        it
      );
    function at(lt) {
      it ? it(lt) : console.error(lt), st.manager.itemError(et);
    }
  }
}
const _eyeRight = new Matrix4(),
  _eyeLeft = new Matrix4(),
  _projectionMatrix = new Matrix4();
class StereoCamera {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new PerspectiveCamera()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new PerspectiveCamera()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(et) {
    const nt = this._cache;
    if (
      nt.focus !== et.focus ||
      nt.fov !== et.fov ||
      nt.aspect !== et.aspect * this.aspect ||
      nt.near !== et.near ||
      nt.far !== et.far ||
      nt.zoom !== et.zoom ||
      nt.eyeSep !== this.eyeSep
    ) {
      (nt.focus = et.focus),
        (nt.fov = et.fov),
        (nt.aspect = et.aspect * this.aspect),
        (nt.near = et.near),
        (nt.far = et.far),
        (nt.zoom = et.zoom),
        (nt.eyeSep = this.eyeSep),
        _projectionMatrix.copy(et.projectionMatrix);
      const it = nt.eyeSep / 2,
        st = (it * nt.near) / nt.focus,
        ot = (nt.near * Math.tan(DEG2RAD * nt.fov * 0.5)) / nt.zoom;
      let at, lt;
      (_eyeLeft.elements[12] = -it),
        (_eyeRight.elements[12] = it),
        (at = -ot * nt.aspect + st),
        (lt = ot * nt.aspect + st),
        (_projectionMatrix.elements[0] = (2 * nt.near) / (lt - at)),
        (_projectionMatrix.elements[8] = (lt + at) / (lt - at)),
        this.cameraL.projectionMatrix.copy(_projectionMatrix),
        (at = -ot * nt.aspect - st),
        (lt = ot * nt.aspect - st),
        (_projectionMatrix.elements[0] = (2 * nt.near) / (lt - at)),
        (_projectionMatrix.elements[8] = (lt + at) / (lt - at)),
        this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(et.matrixWorld).multiply(_eyeLeft),
      this.cameraR.matrixWorld.copy(et.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(et = !0) {
    (this.autoStart = et),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = now$2()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let et = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const nt = now$2();
      (et = (nt - this.oldTime) / 1e3),
        (this.oldTime = nt),
        (this.elapsedTime += et);
    }
    return et;
  }
}
function now$2() {
  return (typeof performance > "u" ? Date : performance).now();
}
const _position$1 = new Vector3(),
  _quaternion$1 = new Quaternion(),
  _scale$1 = new Vector3(),
  _orientation$1 = new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = AudioContext.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Clock());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(et) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = et),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(et) {
    return (
      this.gain.gain.setTargetAtTime(et, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(et) {
    super.updateMatrixWorld(et);
    const nt = this.context.listener,
      rt = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
      nt.positionX)
    ) {
      const it = this.context.currentTime + this.timeDelta;
      nt.positionX.linearRampToValueAtTime(_position$1.x, it),
        nt.positionY.linearRampToValueAtTime(_position$1.y, it),
        nt.positionZ.linearRampToValueAtTime(_position$1.z, it),
        nt.forwardX.linearRampToValueAtTime(_orientation$1.x, it),
        nt.forwardY.linearRampToValueAtTime(_orientation$1.y, it),
        nt.forwardZ.linearRampToValueAtTime(_orientation$1.z, it),
        nt.upX.linearRampToValueAtTime(rt.x, it),
        nt.upY.linearRampToValueAtTime(rt.y, it),
        nt.upZ.linearRampToValueAtTime(rt.z, it);
    } else
      nt.setPosition(_position$1.x, _position$1.y, _position$1.z),
        nt.setOrientation(
          _orientation$1.x,
          _orientation$1.y,
          _orientation$1.z,
          rt.x,
          rt.y,
          rt.z
        );
  }
}
class Audio extends Object3D {
  constructor(et) {
    super(),
      (this.type = "Audio"),
      (this.listener = et),
      (this.context = et.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(et.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(et) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = et),
      this.connect(),
      this
    );
  }
  setMediaElementSource(et) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(et)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(et) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(et)),
      this.connect(),
      this
    );
  }
  setBuffer(et) {
    return (
      (this.buffer = et),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(et = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + et;
    const nt = this.context.createBufferSource();
    return (
      (nt.buffer = this.buffer),
      (nt.loop = this.loop),
      (nt.loopStart = this.loopStart),
      (nt.loopEnd = this.loopEnd),
      (nt.onended = this.onEnded.bind(this)),
      nt.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = nt),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let et = 1, nt = this.filters.length; et < nt; et++)
        this.filters[et - 1].connect(this.filters[et]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let et = 1, nt = this.filters.length; et < nt; et++)
          this.filters[et - 1].disconnect(this.filters[et]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(et) {
    return (
      et || (et = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = et.slice()), this.connect())
        : (this.filters = et.slice()),
      this
    );
  }
  setDetune(et) {
    if (((this.detune = et), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(et) {
    return this.setFilters(et ? [et] : []);
  }
  setPlaybackRate(et) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = et),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(et) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = et),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(et) {
    return (this.loopStart = et), this;
  }
  setLoopEnd(et) {
    return (this.loopEnd = et), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(et) {
    return (
      this.gain.gain.setTargetAtTime(et, this.context.currentTime, 0.01), this
    );
  }
}
const _position = new Vector3(),
  _quaternion = new Quaternion(),
  _scale = new Vector3(),
  _orientation = new Vector3();
class PositionalAudio extends Audio {
  constructor(et) {
    super(et),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(et) {
    return (this.panner.refDistance = et), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(et) {
    return (this.panner.rolloffFactor = et), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(et) {
    return (this.panner.distanceModel = et), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(et) {
    return (this.panner.maxDistance = et), this;
  }
  setDirectionalCone(et, nt, rt) {
    return (
      (this.panner.coneInnerAngle = et),
      (this.panner.coneOuterAngle = nt),
      (this.panner.coneOuterGain = rt),
      this
    );
  }
  updateMatrixWorld(et) {
    if (
      (super.updateMatrixWorld(et),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(_position, _quaternion, _scale),
      _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const nt = this.panner;
    if (nt.positionX) {
      const rt = this.context.currentTime + this.listener.timeDelta;
      nt.positionX.linearRampToValueAtTime(_position.x, rt),
        nt.positionY.linearRampToValueAtTime(_position.y, rt),
        nt.positionZ.linearRampToValueAtTime(_position.z, rt),
        nt.orientationX.linearRampToValueAtTime(_orientation.x, rt),
        nt.orientationY.linearRampToValueAtTime(_orientation.y, rt),
        nt.orientationZ.linearRampToValueAtTime(_orientation.z, rt);
    } else
      nt.setPosition(_position.x, _position.y, _position.z),
        nt.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
}
class AudioAnalyser {
  constructor(et, nt = 2048) {
    (this.analyser = et.context.createAnalyser()),
      (this.analyser.fftSize = nt),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      et.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let et = 0;
    const nt = this.getFrequencyData();
    for (let rt = 0; rt < nt.length; rt++) et += nt[rt];
    return et / nt.length;
  }
}
class PropertyMixer {
  constructor(et, nt, rt) {
    (this.binding = et), (this.valueSize = rt);
    let it, st, ot;
    switch (nt) {
      case "quaternion":
        (it = this._slerp),
          (st = this._slerpAdditive),
          (ot = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(rt * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (it = this._select),
          (st = this._select),
          (ot = this._setAdditiveIdentityOther),
          (this.buffer = new Array(rt * 5));
        break;
      default:
        (it = this._lerp),
          (st = this._lerpAdditive),
          (ot = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(rt * 5));
    }
    (this._mixBufferRegion = it),
      (this._mixBufferRegionAdditive = st),
      (this._setIdentity = ot),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(et, nt) {
    const rt = this.buffer,
      it = this.valueSize,
      st = et * it + it;
    let ot = this.cumulativeWeight;
    if (ot === 0) {
      for (let at = 0; at !== it; ++at) rt[st + at] = rt[at];
      ot = nt;
    } else {
      ot += nt;
      const at = nt / ot;
      this._mixBufferRegion(rt, st, 0, at, it);
    }
    this.cumulativeWeight = ot;
  }
  accumulateAdditive(et) {
    const nt = this.buffer,
      rt = this.valueSize,
      it = rt * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(nt, it, 0, et, rt),
      (this.cumulativeWeightAdditive += et);
  }
  apply(et) {
    const nt = this.valueSize,
      rt = this.buffer,
      it = et * nt + nt,
      st = this.cumulativeWeight,
      ot = this.cumulativeWeightAdditive,
      at = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), st < 1)
    ) {
      const lt = nt * this._origIndex;
      this._mixBufferRegion(rt, it, lt, 1 - st, nt);
    }
    ot > 0 && this._mixBufferRegionAdditive(rt, it, this._addIndex * nt, 1, nt);
    for (let lt = nt, ct = nt + nt; lt !== ct; ++lt)
      if (rt[lt] !== rt[lt + nt]) {
        at.setValue(rt, it);
        break;
      }
  }
  saveOriginalState() {
    const et = this.binding,
      nt = this.buffer,
      rt = this.valueSize,
      it = rt * this._origIndex;
    et.getValue(nt, it);
    for (let st = rt, ot = it; st !== ot; ++st) nt[st] = nt[it + (st % rt)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const et = this.valueSize * 3;
    this.binding.setValue(this.buffer, et);
  }
  _setAdditiveIdentityNumeric() {
    const et = this._addIndex * this.valueSize,
      nt = et + this.valueSize;
    for (let rt = et; rt < nt; rt++) this.buffer[rt] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const et = this._origIndex * this.valueSize,
      nt = this._addIndex * this.valueSize;
    for (let rt = 0; rt < this.valueSize; rt++)
      this.buffer[nt + rt] = this.buffer[et + rt];
  }
  _select(et, nt, rt, it, st) {
    if (it >= 0.5) for (let ot = 0; ot !== st; ++ot) et[nt + ot] = et[rt + ot];
  }
  _slerp(et, nt, rt, it) {
    Quaternion.slerpFlat(et, nt, et, nt, et, rt, it);
  }
  _slerpAdditive(et, nt, rt, it, st) {
    const ot = this._workIndex * st;
    Quaternion.multiplyQuaternionsFlat(et, ot, et, nt, et, rt),
      Quaternion.slerpFlat(et, nt, et, nt, et, ot, it);
  }
  _lerp(et, nt, rt, it, st) {
    const ot = 1 - it;
    for (let at = 0; at !== st; ++at) {
      const lt = nt + at;
      et[lt] = et[lt] * ot + et[rt + at] * it;
    }
  }
  _lerpAdditive(et, nt, rt, it, st) {
    for (let ot = 0; ot !== st; ++ot) {
      const at = nt + ot;
      et[at] = et[at] + et[rt + ot] * it;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
  _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
  _wordChar = "[^" + _RESERVED_CHARS_RE + "]",
  _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
  _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
  _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot),
  _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar),
  _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar),
  _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  ),
  _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(et, nt, rt) {
    const it = rt || PropertyBinding.parseTrackName(nt);
    (this._targetGroup = et), (this._bindings = et.subscribe_(nt, it));
  }
  getValue(et, nt) {
    this.bind();
    const rt = this._targetGroup.nCachedObjects_,
      it = this._bindings[rt];
    it !== void 0 && it.getValue(et, nt);
  }
  setValue(et, nt) {
    const rt = this._bindings;
    for (
      let it = this._targetGroup.nCachedObjects_, st = rt.length;
      it !== st;
      ++it
    )
      rt[it].setValue(et, nt);
  }
  bind() {
    const et = this._bindings;
    for (
      let nt = this._targetGroup.nCachedObjects_, rt = et.length;
      nt !== rt;
      ++nt
    )
      et[nt].bind();
  }
  unbind() {
    const et = this._bindings;
    for (
      let nt = this._targetGroup.nCachedObjects_, rt = et.length;
      nt !== rt;
      ++nt
    )
      et[nt].unbind();
  }
}
class PropertyBinding {
  constructor(et, nt, rt) {
    (this.path = nt),
      (this.parsedPath = rt || PropertyBinding.parseTrackName(nt)),
      (this.node = PropertyBinding.findNode(et, this.parsedPath.nodeName)),
      (this.rootNode = et),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(et, nt, rt) {
    return et && et.isAnimationObjectGroup
      ? new PropertyBinding.Composite(et, nt, rt)
      : new PropertyBinding(et, nt, rt);
  }
  static sanitizeNodeName(et) {
    return et.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(et) {
    const nt = _trackRe.exec(et);
    if (nt === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + et);
    const rt = {
        nodeName: nt[2],
        objectName: nt[3],
        objectIndex: nt[4],
        propertyName: nt[5],
        propertyIndex: nt[6],
      },
      it = rt.nodeName && rt.nodeName.lastIndexOf(".");
    if (it !== void 0 && it !== -1) {
      const st = rt.nodeName.substring(it + 1);
      _supportedObjectNames.indexOf(st) !== -1 &&
        ((rt.nodeName = rt.nodeName.substring(0, it)), (rt.objectName = st));
    }
    if (rt.propertyName === null || rt.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + et
      );
    return rt;
  }
  static findNode(et, nt) {
    if (
      nt === void 0 ||
      nt === "" ||
      nt === "." ||
      nt === -1 ||
      nt === et.name ||
      nt === et.uuid
    )
      return et;
    if (et.skeleton) {
      const rt = et.skeleton.getBoneByName(nt);
      if (rt !== void 0) return rt;
    }
    if (et.children) {
      const rt = function (st) {
          for (let ot = 0; ot < st.length; ot++) {
            const at = st[ot];
            if (at.name === nt || at.uuid === nt) return at;
            const lt = rt(at.children);
            if (lt) return lt;
          }
          return null;
        },
        it = rt(et.children);
      if (it) return it;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(et, nt) {
    et[nt] = this.targetObject[this.propertyName];
  }
  _getValue_array(et, nt) {
    const rt = this.resolvedProperty;
    for (let it = 0, st = rt.length; it !== st; ++it) et[nt++] = rt[it];
  }
  _getValue_arrayElement(et, nt) {
    et[nt] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(et, nt) {
    this.resolvedProperty.toArray(et, nt);
  }
  _setValue_direct(et, nt) {
    this.targetObject[this.propertyName] = et[nt];
  }
  _setValue_direct_setNeedsUpdate(et, nt) {
    (this.targetObject[this.propertyName] = et[nt]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(et, nt) {
    (this.targetObject[this.propertyName] = et[nt]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(et, nt) {
    const rt = this.resolvedProperty;
    for (let it = 0, st = rt.length; it !== st; ++it) rt[it] = et[nt++];
  }
  _setValue_array_setNeedsUpdate(et, nt) {
    const rt = this.resolvedProperty;
    for (let it = 0, st = rt.length; it !== st; ++it) rt[it] = et[nt++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(et, nt) {
    const rt = this.resolvedProperty;
    for (let it = 0, st = rt.length; it !== st; ++it) rt[it] = et[nt++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(et, nt) {
    this.resolvedProperty[this.propertyIndex] = et[nt];
  }
  _setValue_arrayElement_setNeedsUpdate(et, nt) {
    (this.resolvedProperty[this.propertyIndex] = et[nt]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(et, nt) {
    (this.resolvedProperty[this.propertyIndex] = et[nt]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(et, nt) {
    this.resolvedProperty.fromArray(et, nt);
  }
  _setValue_fromArray_setNeedsUpdate(et, nt) {
    this.resolvedProperty.fromArray(et, nt),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(et, nt) {
    this.resolvedProperty.fromArray(et, nt),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(et, nt) {
    this.bind(), this.getValue(et, nt);
  }
  _setValue_unbound(et, nt) {
    this.bind(), this.setValue(et, nt);
  }
  bind() {
    let et = this.node;
    const nt = this.parsedPath,
      rt = nt.objectName,
      it = nt.propertyName;
    let st = nt.propertyIndex;
    if (
      (et ||
        ((et = PropertyBinding.findNode(this.rootNode, nt.nodeName)),
        (this.node = et)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !et)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (rt) {
      let ct = nt.objectIndex;
      switch (rt) {
        case "materials":
          if (!et.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!et.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          et = et.material.materials;
          break;
        case "bones":
          if (!et.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          et = et.skeleton.bones;
          for (let ut = 0; ut < et.length; ut++)
            if (et[ut].name === ct) {
              ct = ut;
              break;
            }
          break;
        case "map":
          if ("map" in et) {
            et = et.map;
            break;
          }
          if (!et.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!et.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          et = et.material.map;
          break;
        default:
          if (et[rt] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          et = et[rt];
      }
      if (ct !== void 0) {
        if (et[ct] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            et
          );
          return;
        }
        et = et[ct];
      }
    }
    const ot = et[it];
    if (ot === void 0) {
      const ct = nt.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          ct +
          "." +
          it +
          " but it wasn't found.",
        et
      );
      return;
    }
    let at = this.Versioning.None;
    (this.targetObject = et),
      et.needsUpdate !== void 0
        ? (at = this.Versioning.NeedsUpdate)
        : et.matrixWorldNeedsUpdate !== void 0 &&
          (at = this.Versioning.MatrixWorldNeedsUpdate);
    let lt = this.BindingType.Direct;
    if (st !== void 0) {
      if (it === "morphTargetInfluences") {
        if (!et.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!et.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        et.morphTargetDictionary[st] !== void 0 &&
          (st = et.morphTargetDictionary[st]);
      }
      (lt = this.BindingType.ArrayElement),
        (this.resolvedProperty = ot),
        (this.propertyIndex = st);
    } else
      ot.fromArray !== void 0 && ot.toArray !== void 0
        ? ((lt = this.BindingType.HasFromToArray), (this.resolvedProperty = ot))
        : Array.isArray(ot)
        ? ((lt = this.BindingType.EntireArray), (this.resolvedProperty = ot))
        : (this.propertyName = it);
    (this.getValue = this.GetterByBindingType[lt]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[lt][at]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class AnimationObjectGroup {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = generateUUID$1()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const et = {};
    this._indicesByUUID = et;
    for (let rt = 0, it = arguments.length; rt !== it; ++rt)
      et[arguments[rt].uuid] = rt;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const nt = this;
    this.stats = {
      objects: {
        get total() {
          return nt._objects.length;
        },
        get inUse() {
          return this.total - nt.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return nt._bindings.length;
      },
    };
  }
  add() {
    const et = this._objects,
      nt = this._indicesByUUID,
      rt = this._paths,
      it = this._parsedPaths,
      st = this._bindings,
      ot = st.length;
    let at,
      lt = et.length,
      ct = this.nCachedObjects_;
    for (let ut = 0, ft = arguments.length; ut !== ft; ++ut) {
      const ht = arguments[ut],
        mt = ht.uuid;
      let vt = nt[mt];
      if (vt === void 0) {
        (vt = lt++), (nt[mt] = vt), et.push(ht);
        for (let yt = 0, Et = ot; yt !== Et; ++yt)
          st[yt].push(new PropertyBinding(ht, rt[yt], it[yt]));
      } else if (vt < ct) {
        at = et[vt];
        const yt = --ct,
          Et = et[yt];
        (nt[Et.uuid] = vt), (et[vt] = Et), (nt[mt] = yt), (et[yt] = ht);
        for (let pt = 0, xt = ot; pt !== xt; ++pt) {
          const St = st[pt],
            At = St[yt];
          let Ct = St[vt];
          (St[vt] = At),
            Ct === void 0 && (Ct = new PropertyBinding(ht, rt[pt], it[pt])),
            (St[yt] = Ct);
        }
      } else
        et[vt] !== at &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = ct;
  }
  remove() {
    const et = this._objects,
      nt = this._indicesByUUID,
      rt = this._bindings,
      it = rt.length;
    let st = this.nCachedObjects_;
    for (let ot = 0, at = arguments.length; ot !== at; ++ot) {
      const lt = arguments[ot],
        ct = lt.uuid,
        ut = nt[ct];
      if (ut !== void 0 && ut >= st) {
        const ft = st++,
          ht = et[ft];
        (nt[ht.uuid] = ut), (et[ut] = ht), (nt[ct] = ft), (et[ft] = lt);
        for (let mt = 0, vt = it; mt !== vt; ++mt) {
          const yt = rt[mt],
            Et = yt[ft],
            pt = yt[ut];
          (yt[ut] = Et), (yt[ft] = pt);
        }
      }
    }
    this.nCachedObjects_ = st;
  }
  uncache() {
    const et = this._objects,
      nt = this._indicesByUUID,
      rt = this._bindings,
      it = rt.length;
    let st = this.nCachedObjects_,
      ot = et.length;
    for (let at = 0, lt = arguments.length; at !== lt; ++at) {
      const ct = arguments[at],
        ut = ct.uuid,
        ft = nt[ut];
      if (ft !== void 0)
        if ((delete nt[ut], ft < st)) {
          const ht = --st,
            mt = et[ht],
            vt = --ot,
            yt = et[vt];
          (nt[mt.uuid] = ft),
            (et[ft] = mt),
            (nt[yt.uuid] = ht),
            (et[ht] = yt),
            et.pop();
          for (let Et = 0, pt = it; Et !== pt; ++Et) {
            const xt = rt[Et],
              St = xt[ht],
              At = xt[vt];
            (xt[ft] = St), (xt[ht] = At), xt.pop();
          }
        } else {
          const ht = --ot,
            mt = et[ht];
          ht > 0 && (nt[mt.uuid] = ft), (et[ft] = mt), et.pop();
          for (let vt = 0, yt = it; vt !== yt; ++vt) {
            const Et = rt[vt];
            (Et[ft] = Et[ht]), Et.pop();
          }
        }
    }
    this.nCachedObjects_ = st;
  }
  subscribe_(et, nt) {
    const rt = this._bindingsIndicesByPath;
    let it = rt[et];
    const st = this._bindings;
    if (it !== void 0) return st[it];
    const ot = this._paths,
      at = this._parsedPaths,
      lt = this._objects,
      ct = lt.length,
      ut = this.nCachedObjects_,
      ft = new Array(ct);
    (it = st.length), (rt[et] = it), ot.push(et), at.push(nt), st.push(ft);
    for (let ht = ut, mt = lt.length; ht !== mt; ++ht) {
      const vt = lt[ht];
      ft[ht] = new PropertyBinding(vt, et, nt);
    }
    return ft;
  }
  unsubscribe_(et) {
    const nt = this._bindingsIndicesByPath,
      rt = nt[et];
    if (rt !== void 0) {
      const it = this._paths,
        st = this._parsedPaths,
        ot = this._bindings,
        at = ot.length - 1,
        lt = ot[at],
        ct = et[at];
      (nt[ct] = rt),
        (ot[rt] = lt),
        ot.pop(),
        (st[rt] = st[at]),
        st.pop(),
        (it[rt] = it[at]),
        it.pop();
    }
  }
}
class AnimationAction {
  constructor(et, nt, rt = null, it = nt.blendMode) {
    (this._mixer = et),
      (this._clip = nt),
      (this._localRoot = rt),
      (this.blendMode = it);
    const st = nt.tracks,
      ot = st.length,
      at = new Array(ot),
      lt = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
    for (let ct = 0; ct !== ot; ++ct) {
      const ut = st[ct].createInterpolant(null);
      (at[ct] = ut), (ut.settings = lt);
    }
    (this._interpolantSettings = lt),
      (this._interpolants = at),
      (this._propertyBindings = new Array(ot)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LoopRepeat),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(et) {
    return (this._startTime = et), this;
  }
  setLoop(et, nt) {
    return (this.loop = et), (this.repetitions = nt), this;
  }
  setEffectiveWeight(et) {
    return (
      (this.weight = et),
      (this._effectiveWeight = this.enabled ? et : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(et) {
    return this._scheduleFading(et, 0, 1);
  }
  fadeOut(et) {
    return this._scheduleFading(et, 1, 0);
  }
  crossFadeFrom(et, nt, rt) {
    if ((et.fadeOut(nt), this.fadeIn(nt), rt)) {
      const it = this._clip.duration,
        st = et._clip.duration,
        ot = st / it,
        at = it / st;
      et.warp(1, ot, nt), this.warp(at, 1, nt);
    }
    return this;
  }
  crossFadeTo(et, nt, rt) {
    return et.crossFadeFrom(this, nt, rt);
  }
  stopFading() {
    const et = this._weightInterpolant;
    return (
      et !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(et)),
      this
    );
  }
  setEffectiveTimeScale(et) {
    return (
      (this.timeScale = et),
      (this._effectiveTimeScale = this.paused ? 0 : et),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(et) {
    return (this.timeScale = this._clip.duration / et), this.stopWarping();
  }
  syncWith(et) {
    return (
      (this.time = et.time), (this.timeScale = et.timeScale), this.stopWarping()
    );
  }
  halt(et) {
    return this.warp(this._effectiveTimeScale, 0, et);
  }
  warp(et, nt, rt) {
    const it = this._mixer,
      st = it.time,
      ot = this.timeScale;
    let at = this._timeScaleInterpolant;
    at === null &&
      ((at = it._lendControlInterpolant()), (this._timeScaleInterpolant = at));
    const lt = at.parameterPositions,
      ct = at.sampleValues;
    return (
      (lt[0] = st),
      (lt[1] = st + rt),
      (ct[0] = et / ot),
      (ct[1] = nt / ot),
      this
    );
  }
  stopWarping() {
    const et = this._timeScaleInterpolant;
    return (
      et !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(et)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(et, nt, rt, it) {
    if (!this.enabled) {
      this._updateWeight(et);
      return;
    }
    const st = this._startTime;
    if (st !== null) {
      const lt = (et - st) * rt;
      lt < 0 || rt === 0
        ? (nt = 0)
        : ((this._startTime = null), (nt = rt * lt));
    }
    nt *= this._updateTimeScale(et);
    const ot = this._updateTime(nt),
      at = this._updateWeight(et);
    if (at > 0) {
      const lt = this._interpolants,
        ct = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let ut = 0, ft = lt.length; ut !== ft; ++ut)
            lt[ut].evaluate(ot), ct[ut].accumulateAdditive(at);
          break;
        case NormalAnimationBlendMode:
        default:
          for (let ut = 0, ft = lt.length; ut !== ft; ++ut)
            lt[ut].evaluate(ot), ct[ut].accumulate(it, at);
      }
    }
  }
  _updateWeight(et) {
    let nt = 0;
    if (this.enabled) {
      nt = this.weight;
      const rt = this._weightInterpolant;
      if (rt !== null) {
        const it = rt.evaluate(et)[0];
        (nt *= it),
          et > rt.parameterPositions[1] &&
            (this.stopFading(), it === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = nt), nt;
  }
  _updateTimeScale(et) {
    let nt = 0;
    if (!this.paused) {
      nt = this.timeScale;
      const rt = this._timeScaleInterpolant;
      if (rt !== null) {
        const it = rt.evaluate(et)[0];
        (nt *= it),
          et > rt.parameterPositions[1] &&
            (this.stopWarping(),
            nt === 0 ? (this.paused = !0) : (this.timeScale = nt));
      }
    }
    return (this._effectiveTimeScale = nt), nt;
  }
  _updateTime(et) {
    const nt = this._clip.duration,
      rt = this.loop;
    let it = this.time + et,
      st = this._loopCount;
    const ot = rt === LoopPingPong;
    if (et === 0) return st === -1 ? it : ot && (st & 1) === 1 ? nt - it : it;
    if (rt === LoopOnce) {
      st === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (it >= nt) it = nt;
        else if (it < 0) it = 0;
        else {
          this.time = it;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = it),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: et < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (st === -1 &&
          (et >= 0
            ? ((st = 0), this._setEndings(!0, this.repetitions === 0, ot))
            : this._setEndings(this.repetitions === 0, !0, ot)),
        it >= nt || it < 0)
      ) {
        const at = Math.floor(it / nt);
        (it -= nt * at), (st += Math.abs(at));
        const lt = this.repetitions - st;
        if (lt <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (it = et > 0 ? nt : 0),
            (this.time = it),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: et > 0 ? 1 : -1,
            });
        else {
          if (lt === 1) {
            const ct = et < 0;
            this._setEndings(ct, !ct, ot);
          } else this._setEndings(!1, !1, ot);
          (this._loopCount = st),
            (this.time = it),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: at,
            });
        }
      } else this.time = it;
      if (ot && (st & 1) === 1) return nt - it;
    }
    return it;
  }
  _setEndings(et, nt, rt) {
    const it = this._interpolantSettings;
    rt
      ? ((it.endingStart = ZeroSlopeEnding), (it.endingEnd = ZeroSlopeEnding))
      : (et
          ? (it.endingStart = this.zeroSlopeAtStart
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (it.endingStart = WrapAroundEnding),
        nt
          ? (it.endingEnd = this.zeroSlopeAtEnd
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (it.endingEnd = WrapAroundEnding));
  }
  _scheduleFading(et, nt, rt) {
    const it = this._mixer,
      st = it.time;
    let ot = this._weightInterpolant;
    ot === null &&
      ((ot = it._lendControlInterpolant()), (this._weightInterpolant = ot));
    const at = ot.parameterPositions,
      lt = ot.sampleValues;
    return (at[0] = st), (lt[0] = nt), (at[1] = st + et), (lt[1] = rt), this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
  constructor(et) {
    super(),
      (this._root = et),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(et, nt) {
    const rt = et._localRoot || this._root,
      it = et._clip.tracks,
      st = it.length,
      ot = et._propertyBindings,
      at = et._interpolants,
      lt = rt.uuid,
      ct = this._bindingsByRootAndName;
    let ut = ct[lt];
    ut === void 0 && ((ut = {}), (ct[lt] = ut));
    for (let ft = 0; ft !== st; ++ft) {
      const ht = it[ft],
        mt = ht.name;
      let vt = ut[mt];
      if (vt !== void 0) ++vt.referenceCount, (ot[ft] = vt);
      else {
        if (((vt = ot[ft]), vt !== void 0)) {
          vt._cacheIndex === null &&
            (++vt.referenceCount, this._addInactiveBinding(vt, lt, mt));
          continue;
        }
        const yt = nt && nt._propertyBindings[ft].binding.parsedPath;
        (vt = new PropertyMixer(
          PropertyBinding.create(rt, mt, yt),
          ht.ValueTypeName,
          ht.getValueSize()
        )),
          ++vt.referenceCount,
          this._addInactiveBinding(vt, lt, mt),
          (ot[ft] = vt);
      }
      at[ft].resultBuffer = vt.buffer;
    }
  }
  _activateAction(et) {
    if (!this._isActiveAction(et)) {
      if (et._cacheIndex === null) {
        const rt = (et._localRoot || this._root).uuid,
          it = et._clip.uuid,
          st = this._actionsByClip[it];
        this._bindAction(et, st && st.knownActions[0]),
          this._addInactiveAction(et, it, rt);
      }
      const nt = et._propertyBindings;
      for (let rt = 0, it = nt.length; rt !== it; ++rt) {
        const st = nt[rt];
        st.useCount++ === 0 && (this._lendBinding(st), st.saveOriginalState());
      }
      this._lendAction(et);
    }
  }
  _deactivateAction(et) {
    if (this._isActiveAction(et)) {
      const nt = et._propertyBindings;
      for (let rt = 0, it = nt.length; rt !== it; ++rt) {
        const st = nt[rt];
        --st.useCount === 0 &&
          (st.restoreOriginalState(), this._takeBackBinding(st));
      }
      this._takeBackAction(et);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const et = this;
    this.stats = {
      actions: {
        get total() {
          return et._actions.length;
        },
        get inUse() {
          return et._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return et._bindings.length;
        },
        get inUse() {
          return et._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return et._controlInterpolants.length;
        },
        get inUse() {
          return et._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(et) {
    const nt = et._cacheIndex;
    return nt !== null && nt < this._nActiveActions;
  }
  _addInactiveAction(et, nt, rt) {
    const it = this._actions,
      st = this._actionsByClip;
    let ot = st[nt];
    if (ot === void 0)
      (ot = { knownActions: [et], actionByRoot: {} }),
        (et._byClipCacheIndex = 0),
        (st[nt] = ot);
    else {
      const at = ot.knownActions;
      (et._byClipCacheIndex = at.length), at.push(et);
    }
    (et._cacheIndex = it.length), it.push(et), (ot.actionByRoot[rt] = et);
  }
  _removeInactiveAction(et) {
    const nt = this._actions,
      rt = nt[nt.length - 1],
      it = et._cacheIndex;
    (rt._cacheIndex = it), (nt[it] = rt), nt.pop(), (et._cacheIndex = null);
    const st = et._clip.uuid,
      ot = this._actionsByClip,
      at = ot[st],
      lt = at.knownActions,
      ct = lt[lt.length - 1],
      ut = et._byClipCacheIndex;
    (ct._byClipCacheIndex = ut),
      (lt[ut] = ct),
      lt.pop(),
      (et._byClipCacheIndex = null);
    const ft = at.actionByRoot,
      ht = (et._localRoot || this._root).uuid;
    delete ft[ht],
      lt.length === 0 && delete ot[st],
      this._removeInactiveBindingsForAction(et);
  }
  _removeInactiveBindingsForAction(et) {
    const nt = et._propertyBindings;
    for (let rt = 0, it = nt.length; rt !== it; ++rt) {
      const st = nt[rt];
      --st.referenceCount === 0 && this._removeInactiveBinding(st);
    }
  }
  _lendAction(et) {
    const nt = this._actions,
      rt = et._cacheIndex,
      it = this._nActiveActions++,
      st = nt[it];
    (et._cacheIndex = it), (nt[it] = et), (st._cacheIndex = rt), (nt[rt] = st);
  }
  _takeBackAction(et) {
    const nt = this._actions,
      rt = et._cacheIndex,
      it = --this._nActiveActions,
      st = nt[it];
    (et._cacheIndex = it), (nt[it] = et), (st._cacheIndex = rt), (nt[rt] = st);
  }
  _addInactiveBinding(et, nt, rt) {
    const it = this._bindingsByRootAndName,
      st = this._bindings;
    let ot = it[nt];
    ot === void 0 && ((ot = {}), (it[nt] = ot)),
      (ot[rt] = et),
      (et._cacheIndex = st.length),
      st.push(et);
  }
  _removeInactiveBinding(et) {
    const nt = this._bindings,
      rt = et.binding,
      it = rt.rootNode.uuid,
      st = rt.path,
      ot = this._bindingsByRootAndName,
      at = ot[it],
      lt = nt[nt.length - 1],
      ct = et._cacheIndex;
    (lt._cacheIndex = ct),
      (nt[ct] = lt),
      nt.pop(),
      delete at[st],
      Object.keys(at).length === 0 && delete ot[it];
  }
  _lendBinding(et) {
    const nt = this._bindings,
      rt = et._cacheIndex,
      it = this._nActiveBindings++,
      st = nt[it];
    (et._cacheIndex = it), (nt[it] = et), (st._cacheIndex = rt), (nt[rt] = st);
  }
  _takeBackBinding(et) {
    const nt = this._bindings,
      rt = et._cacheIndex,
      it = --this._nActiveBindings,
      st = nt[it];
    (et._cacheIndex = it), (nt[it] = et), (st._cacheIndex = rt), (nt[rt] = st);
  }
  _lendControlInterpolant() {
    const et = this._controlInterpolants,
      nt = this._nActiveControlInterpolants++;
    let rt = et[nt];
    return (
      rt === void 0 &&
        ((rt = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          _controlInterpolantsResultBuffer
        )),
        (rt.__cacheIndex = nt),
        (et[nt] = rt)),
      rt
    );
  }
  _takeBackControlInterpolant(et) {
    const nt = this._controlInterpolants,
      rt = et.__cacheIndex,
      it = --this._nActiveControlInterpolants,
      st = nt[it];
    (et.__cacheIndex = it),
      (nt[it] = et),
      (st.__cacheIndex = rt),
      (nt[rt] = st);
  }
  clipAction(et, nt, rt) {
    const it = nt || this._root,
      st = it.uuid;
    let ot = typeof et == "string" ? AnimationClip.findByName(it, et) : et;
    const at = ot !== null ? ot.uuid : et,
      lt = this._actionsByClip[at];
    let ct = null;
    if (
      (rt === void 0 &&
        (ot !== null ? (rt = ot.blendMode) : (rt = NormalAnimationBlendMode)),
      lt !== void 0)
    ) {
      const ft = lt.actionByRoot[st];
      if (ft !== void 0 && ft.blendMode === rt) return ft;
      (ct = lt.knownActions[0]), ot === null && (ot = ct._clip);
    }
    if (ot === null) return null;
    const ut = new AnimationAction(this, ot, nt, rt);
    return this._bindAction(ut, ct), this._addInactiveAction(ut, at, st), ut;
  }
  existingAction(et, nt) {
    const rt = nt || this._root,
      it = rt.uuid,
      st = typeof et == "string" ? AnimationClip.findByName(rt, et) : et,
      ot = st ? st.uuid : et,
      at = this._actionsByClip[ot];
    return (at !== void 0 && at.actionByRoot[it]) || null;
  }
  stopAllAction() {
    const et = this._actions,
      nt = this._nActiveActions;
    for (let rt = nt - 1; rt >= 0; --rt) et[rt].stop();
    return this;
  }
  update(et) {
    et *= this.timeScale;
    const nt = this._actions,
      rt = this._nActiveActions,
      it = (this.time += et),
      st = Math.sign(et),
      ot = (this._accuIndex ^= 1);
    for (let ct = 0; ct !== rt; ++ct) nt[ct]._update(it, et, st, ot);
    const at = this._bindings,
      lt = this._nActiveBindings;
    for (let ct = 0; ct !== lt; ++ct) at[ct].apply(ot);
    return this;
  }
  setTime(et) {
    this.time = 0;
    for (let nt = 0; nt < this._actions.length; nt++)
      this._actions[nt].time = 0;
    return this.update(et);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(et) {
    const nt = this._actions,
      rt = et.uuid,
      it = this._actionsByClip,
      st = it[rt];
    if (st !== void 0) {
      const ot = st.knownActions;
      for (let at = 0, lt = ot.length; at !== lt; ++at) {
        const ct = ot[at];
        this._deactivateAction(ct);
        const ut = ct._cacheIndex,
          ft = nt[nt.length - 1];
        (ct._cacheIndex = null),
          (ct._byClipCacheIndex = null),
          (ft._cacheIndex = ut),
          (nt[ut] = ft),
          nt.pop(),
          this._removeInactiveBindingsForAction(ct);
      }
      delete it[rt];
    }
  }
  uncacheRoot(et) {
    const nt = et.uuid,
      rt = this._actionsByClip;
    for (const ot in rt) {
      const at = rt[ot].actionByRoot,
        lt = at[nt];
      lt !== void 0 &&
        (this._deactivateAction(lt), this._removeInactiveAction(lt));
    }
    const it = this._bindingsByRootAndName,
      st = it[nt];
    if (st !== void 0)
      for (const ot in st) {
        const at = st[ot];
        at.restoreOriginalState(), this._removeInactiveBinding(at);
      }
  }
  uncacheAction(et, nt) {
    const rt = this.existingAction(et, nt);
    rt !== null && (this._deactivateAction(rt), this._removeInactiveAction(rt));
  }
}
class Uniform {
  constructor(et) {
    this.value = et;
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let _id = 0;
class UniformsGroup extends EventDispatcher {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: _id++ }),
      (this.name = ""),
      (this.usage = StaticDrawUsage),
      (this.uniforms = []);
  }
  add(et) {
    return this.uniforms.push(et), this;
  }
  remove(et) {
    const nt = this.uniforms.indexOf(et);
    return nt !== -1 && this.uniforms.splice(nt, 1), this;
  }
  setName(et) {
    return (this.name = et), this;
  }
  setUsage(et) {
    return (this.usage = et), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(et) {
    (this.name = et.name), (this.usage = et.usage);
    const nt = et.uniforms;
    this.uniforms.length = 0;
    for (let rt = 0, it = nt.length; rt < it; rt++)
      this.uniforms.push(nt[rt].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(et, nt, rt = 1) {
    super(et, nt),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = rt);
  }
  copy(et) {
    return super.copy(et), (this.meshPerAttribute = et.meshPerAttribute), this;
  }
  clone(et) {
    const nt = super.clone(et);
    return (nt.meshPerAttribute = this.meshPerAttribute), nt;
  }
  toJSON(et) {
    const nt = super.toJSON(et);
    return (
      (nt.isInstancedInterleavedBuffer = !0),
      (nt.meshPerAttribute = this.meshPerAttribute),
      nt
    );
  }
}
class GLBufferAttribute {
  constructor(et, nt, rt, it, st) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = et),
      (this.type = nt),
      (this.itemSize = rt),
      (this.elementSize = it),
      (this.count = st),
      (this.version = 0);
  }
  set needsUpdate(et) {
    et === !0 && this.version++;
  }
  setBuffer(et) {
    return (this.buffer = et), this;
  }
  setType(et, nt) {
    return (this.type = et), (this.elementSize = nt), this;
  }
  setItemSize(et) {
    return (this.itemSize = et), this;
  }
  setCount(et) {
    return (this.count = et), this;
  }
}
class Raycaster {
  constructor(et, nt, rt = 0, it = 1 / 0) {
    (this.ray = new Ray(et, nt)),
      (this.near = rt),
      (this.far = it),
      (this.camera = null),
      (this.layers = new Layers()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(et, nt) {
    this.ray.set(et, nt);
  }
  setFromCamera(et, nt) {
    nt.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(nt.matrixWorld),
        this.ray.direction
          .set(et.x, et.y, 0.5)
          .unproject(nt)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = nt))
      : nt.isOrthographicCamera
      ? (this.ray.origin
          .set(et.x, et.y, (nt.near + nt.far) / (nt.near - nt.far))
          .unproject(nt),
        this.ray.direction.set(0, 0, -1).transformDirection(nt.matrixWorld),
        (this.camera = nt))
      : console.error("THREE.Raycaster: Unsupported camera type: " + nt.type);
  }
  intersectObject(et, nt = !0, rt = []) {
    return intersectObject(et, this, rt, nt), rt.sort(ascSort), rt;
  }
  intersectObjects(et, nt = !0, rt = []) {
    for (let it = 0, st = et.length; it < st; it++)
      intersectObject(et[it], this, rt, nt);
    return rt.sort(ascSort), rt;
  }
}
function ascSort(tt, et) {
  return tt.distance - et.distance;
}
function intersectObject(tt, et, nt, rt) {
  if ((tt.layers.test(et.layers) && tt.raycast(et, nt), rt === !0)) {
    const it = tt.children;
    for (let st = 0, ot = it.length; st < ot; st++)
      intersectObject(it[st], et, nt, !0);
  }
}
class Spherical {
  constructor(et = 1, nt = 0, rt = 0) {
    return (this.radius = et), (this.phi = nt), (this.theta = rt), this;
  }
  set(et, nt, rt) {
    return (this.radius = et), (this.phi = nt), (this.theta = rt), this;
  }
  copy(et) {
    return (
      (this.radius = et.radius),
      (this.phi = et.phi),
      (this.theta = et.theta),
      this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(et) {
    return this.setFromCartesianCoords(et.x, et.y, et.z);
  }
  setFromCartesianCoords(et, nt, rt) {
    return (
      (this.radius = Math.sqrt(et * et + nt * nt + rt * rt)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(et, rt)),
          (this.phi = Math.acos(clamp$1(nt / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(et = 1, nt = 0, rt = 0) {
    return (this.radius = et), (this.theta = nt), (this.y = rt), this;
  }
  set(et, nt, rt) {
    return (this.radius = et), (this.theta = nt), (this.y = rt), this;
  }
  copy(et) {
    return (
      (this.radius = et.radius), (this.theta = et.theta), (this.y = et.y), this
    );
  }
  setFromVector3(et) {
    return this.setFromCartesianCoords(et.x, et.y, et.z);
  }
  setFromCartesianCoords(et, nt, rt) {
    return (
      (this.radius = Math.sqrt(et * et + rt * rt)),
      (this.theta = Math.atan2(et, rt)),
      (this.y = nt),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$4 = new Vector2();
class Box2 {
  constructor(
    et = new Vector2(1 / 0, 1 / 0),
    nt = new Vector2(-1 / 0, -1 / 0)
  ) {
    (this.isBox2 = !0), (this.min = et), (this.max = nt);
  }
  set(et, nt) {
    return this.min.copy(et), this.max.copy(nt), this;
  }
  setFromPoints(et) {
    this.makeEmpty();
    for (let nt = 0, rt = et.length; nt < rt; nt++) this.expandByPoint(et[nt]);
    return this;
  }
  setFromCenterAndSize(et, nt) {
    const rt = _vector$4.copy(nt).multiplyScalar(0.5);
    return this.min.copy(et).sub(rt), this.max.copy(et).add(rt), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(et) {
    return this.min.copy(et.min), this.max.copy(et.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(et) {
    return this.isEmpty()
      ? et.set(0, 0)
      : et.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(et) {
    return this.isEmpty() ? et.set(0, 0) : et.subVectors(this.max, this.min);
  }
  expandByPoint(et) {
    return this.min.min(et), this.max.max(et), this;
  }
  expandByVector(et) {
    return this.min.sub(et), this.max.add(et), this;
  }
  expandByScalar(et) {
    return this.min.addScalar(-et), this.max.addScalar(et), this;
  }
  containsPoint(et) {
    return !(
      et.x < this.min.x ||
      et.x > this.max.x ||
      et.y < this.min.y ||
      et.y > this.max.y
    );
  }
  containsBox(et) {
    return (
      this.min.x <= et.min.x &&
      et.max.x <= this.max.x &&
      this.min.y <= et.min.y &&
      et.max.y <= this.max.y
    );
  }
  getParameter(et, nt) {
    return nt.set(
      (et.x - this.min.x) / (this.max.x - this.min.x),
      (et.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(et) {
    return !(
      et.max.x < this.min.x ||
      et.min.x > this.max.x ||
      et.max.y < this.min.y ||
      et.min.y > this.max.y
    );
  }
  clampPoint(et, nt) {
    return nt.copy(et).clamp(this.min, this.max);
  }
  distanceToPoint(et) {
    return this.clampPoint(et, _vector$4).distanceTo(et);
  }
  intersect(et) {
    return (
      this.min.max(et.min),
      this.max.min(et.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(et) {
    return this.min.min(et.min), this.max.max(et.max), this;
  }
  translate(et) {
    return this.min.add(et), this.max.add(et), this;
  }
  equals(et) {
    return et.min.equals(this.min) && et.max.equals(this.max);
  }
}
const _startP = new Vector3(),
  _startEnd = new Vector3();
class Line3 {
  constructor(et = new Vector3(), nt = new Vector3()) {
    (this.start = et), (this.end = nt);
  }
  set(et, nt) {
    return this.start.copy(et), this.end.copy(nt), this;
  }
  copy(et) {
    return this.start.copy(et.start), this.end.copy(et.end), this;
  }
  getCenter(et) {
    return et.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(et) {
    return et.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(et, nt) {
    return this.delta(nt).multiplyScalar(et).add(this.start);
  }
  closestPointToPointParameter(et, nt) {
    _startP.subVectors(et, this.start),
      _startEnd.subVectors(this.end, this.start);
    const rt = _startEnd.dot(_startEnd);
    let st = _startEnd.dot(_startP) / rt;
    return nt && (st = clamp$1(st, 0, 1)), st;
  }
  closestPointToPoint(et, nt, rt) {
    const it = this.closestPointToPointParameter(et, nt);
    return this.delta(rt).multiplyScalar(it).add(this.start);
  }
  applyMatrix4(et) {
    return this.start.applyMatrix4(et), this.end.applyMatrix4(et), this;
  }
  equals(et) {
    return et.start.equals(this.start) && et.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = new Vector3();
class SpotLightHelper extends Object3D {
  constructor(et, nt) {
    super(),
      (this.light = et),
      (this.matrix = et.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = nt),
      (this.type = "SpotLightHelper");
    const rt = new BufferGeometry(),
      it = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let ot = 0, at = 1, lt = 32; ot < lt; ot++, at++) {
      const ct = (ot / lt) * Math.PI * 2,
        ut = (at / lt) * Math.PI * 2;
      it.push(Math.cos(ct), Math.sin(ct), 1, Math.cos(ut), Math.sin(ut), 1);
    }
    rt.setAttribute("position", new Float32BufferAttribute(it, 3));
    const st = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.cone = new LineSegments(rt, st)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const et = this.light.distance ? this.light.distance : 1e3,
      nt = et * Math.tan(this.light.angle);
    this.cone.scale.set(nt, nt, et),
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(_vector$3),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const _vector$2 = new Vector3(),
  _boneMatrix = new Matrix4(),
  _matrixWorldInv = new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(et) {
    const nt = getBoneList(et),
      rt = new BufferGeometry(),
      it = [],
      st = [],
      ot = new Color(0, 0, 1),
      at = new Color(0, 1, 0);
    for (let ct = 0; ct < nt.length; ct++) {
      const ut = nt[ct];
      ut.parent &&
        ut.parent.isBone &&
        (it.push(0, 0, 0),
        it.push(0, 0, 0),
        st.push(ot.r, ot.g, ot.b),
        st.push(at.r, at.g, at.b));
    }
    rt.setAttribute("position", new Float32BufferAttribute(it, 3)),
      rt.setAttribute("color", new Float32BufferAttribute(st, 3));
    const lt = new LineBasicMaterial({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(rt, lt),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = et),
      (this.bones = nt),
      (this.matrix = et.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(et) {
    const nt = this.bones,
      rt = this.geometry,
      it = rt.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let st = 0, ot = 0; st < nt.length; st++) {
      const at = nt[st];
      at.parent &&
        at.parent.isBone &&
        (_boneMatrix.multiplyMatrices(_matrixWorldInv, at.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        it.setXYZ(ot, _vector$2.x, _vector$2.y, _vector$2.z),
        _boneMatrix.multiplyMatrices(_matrixWorldInv, at.parent.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        it.setXYZ(ot + 1, _vector$2.x, _vector$2.y, _vector$2.z),
        (ot += 2));
    }
    (rt.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(et);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function getBoneList(tt) {
  const et = [];
  tt.isBone === !0 && et.push(tt);
  for (let nt = 0; nt < tt.children.length; nt++)
    et.push.apply(et, getBoneList(tt.children[nt]));
  return et;
}
class PointLightHelper extends Mesh {
  constructor(et, nt, rt) {
    const it = new SphereGeometry(nt, 4, 2),
      st = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(it, st),
      (this.light = et),
      (this.color = rt),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const _vector$1 = new Vector3(),
  _color1 = new Color(),
  _color2 = new Color();
class HemisphereLightHelper extends Object3D {
  constructor(et, nt, rt) {
    super(),
      (this.light = et),
      (this.matrix = et.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = rt),
      (this.type = "HemisphereLightHelper");
    const it = new OctahedronGeometry(nt);
    it.rotateY(Math.PI * 0.5),
      (this.material = new MeshBasicMaterial({
        wireframe: !0,
        fog: !1,
        toneMapped: !1,
      })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const st = it.getAttribute("position"),
      ot = new Float32Array(st.count * 3);
    it.setAttribute("color", new BufferAttribute(ot, 3)),
      this.add(new Mesh(it, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const et = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const nt = et.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let rt = 0, it = nt.count; rt < it; rt++) {
        const st = rt < it / 2 ? _color1 : _color2;
        nt.setXYZ(rt, st.r, st.g, st.b);
      }
      nt.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      et.lookAt(
        _vector$1.setFromMatrixPosition(this.light.matrixWorld).negate()
      );
  }
}
class GridHelper extends LineSegments {
  constructor(et = 10, nt = 10, rt = 4473924, it = 8947848) {
    (rt = new Color(rt)), (it = new Color(it));
    const st = nt / 2,
      ot = et / nt,
      at = et / 2,
      lt = [],
      ct = [];
    for (let ht = 0, mt = 0, vt = -at; ht <= nt; ht++, vt += ot) {
      lt.push(-at, 0, vt, at, 0, vt), lt.push(vt, 0, -at, vt, 0, at);
      const yt = ht === st ? rt : it;
      yt.toArray(ct, mt),
        (mt += 3),
        yt.toArray(ct, mt),
        (mt += 3),
        yt.toArray(ct, mt),
        (mt += 3),
        yt.toArray(ct, mt),
        (mt += 3);
    }
    const ut = new BufferGeometry();
    ut.setAttribute("position", new Float32BufferAttribute(lt, 3)),
      ut.setAttribute("color", new Float32BufferAttribute(ct, 3));
    const ft = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(ut, ft), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PolarGridHelper extends LineSegments {
  constructor(et = 10, nt = 16, rt = 8, it = 64, st = 4473924, ot = 8947848) {
    (st = new Color(st)), (ot = new Color(ot));
    const at = [],
      lt = [];
    if (nt > 1)
      for (let ft = 0; ft < nt; ft++) {
        const ht = (ft / nt) * (Math.PI * 2),
          mt = Math.sin(ht) * et,
          vt = Math.cos(ht) * et;
        at.push(0, 0, 0), at.push(mt, 0, vt);
        const yt = ft & 1 ? st : ot;
        lt.push(yt.r, yt.g, yt.b), lt.push(yt.r, yt.g, yt.b);
      }
    for (let ft = 0; ft < rt; ft++) {
      const ht = ft & 1 ? st : ot,
        mt = et - (et / rt) * ft;
      for (let vt = 0; vt < it; vt++) {
        let yt = (vt / it) * (Math.PI * 2),
          Et = Math.sin(yt) * mt,
          pt = Math.cos(yt) * mt;
        at.push(Et, 0, pt),
          lt.push(ht.r, ht.g, ht.b),
          (yt = ((vt + 1) / it) * (Math.PI * 2)),
          (Et = Math.sin(yt) * mt),
          (pt = Math.cos(yt) * mt),
          at.push(Et, 0, pt),
          lt.push(ht.r, ht.g, ht.b);
      }
    }
    const ct = new BufferGeometry();
    ct.setAttribute("position", new Float32BufferAttribute(at, 3)),
      ct.setAttribute("color", new Float32BufferAttribute(lt, 3));
    const ut = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(ct, ut), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _v1 = new Vector3(),
  _v2 = new Vector3(),
  _v3 = new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(et, nt, rt) {
    super(),
      (this.light = et),
      (this.matrix = et.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = rt),
      (this.type = "DirectionalLightHelper"),
      nt === void 0 && (nt = 1);
    let it = new BufferGeometry();
    it.setAttribute(
      "position",
      new Float32BufferAttribute(
        [-nt, nt, 0, nt, nt, 0, nt, -nt, 0, -nt, -nt, 0, -nt, nt, 0],
        3
      )
    );
    const st = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Line$1(it, st)),
      this.add(this.lightPlane),
      (it = new BufferGeometry()),
      it.setAttribute(
        "position",
        new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
      ),
      (this.targetLine = new Line$1(it, st)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      _v1.setFromMatrixPosition(this.light.matrixWorld),
      _v2.setFromMatrixPosition(this.light.target.matrixWorld),
      _v3.subVectors(_v2, _v1),
      this.lightPlane.lookAt(_v2),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(_v2),
      (this.targetLine.scale.z = _v3.length());
  }
}
const _vector$c = new Vector3(),
  _camera = new Camera();
class CameraHelper extends LineSegments {
  constructor(et) {
    const nt = new BufferGeometry(),
      rt = new LineBasicMaterial({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1,
      }),
      it = [],
      st = [],
      ot = {};
    at("n1", "n2"),
      at("n2", "n4"),
      at("n4", "n3"),
      at("n3", "n1"),
      at("f1", "f2"),
      at("f2", "f4"),
      at("f4", "f3"),
      at("f3", "f1"),
      at("n1", "f1"),
      at("n2", "f2"),
      at("n3", "f3"),
      at("n4", "f4"),
      at("p", "n1"),
      at("p", "n2"),
      at("p", "n3"),
      at("p", "n4"),
      at("u1", "u2"),
      at("u2", "u3"),
      at("u3", "u1"),
      at("c", "t"),
      at("p", "c"),
      at("cn1", "cn2"),
      at("cn3", "cn4"),
      at("cf1", "cf2"),
      at("cf3", "cf4");
    function at(vt, yt) {
      lt(vt), lt(yt);
    }
    function lt(vt) {
      it.push(0, 0, 0),
        st.push(0, 0, 0),
        ot[vt] === void 0 && (ot[vt] = []),
        ot[vt].push(it.length / 3 - 1);
    }
    nt.setAttribute("position", new Float32BufferAttribute(it, 3)),
      nt.setAttribute("color", new Float32BufferAttribute(st, 3)),
      super(nt, rt),
      (this.type = "CameraHelper"),
      (this.camera = et),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = et.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = ot),
      this.update();
    const ct = new Color(16755200),
      ut = new Color(16711680),
      ft = new Color(43775),
      ht = new Color(16777215),
      mt = new Color(3355443);
    this.setColors(ct, ut, ft, ht, mt);
  }
  setColors(et, nt, rt, it, st) {
    const at = this.geometry.getAttribute("color");
    at.setXYZ(0, et.r, et.g, et.b),
      at.setXYZ(1, et.r, et.g, et.b),
      at.setXYZ(2, et.r, et.g, et.b),
      at.setXYZ(3, et.r, et.g, et.b),
      at.setXYZ(4, et.r, et.g, et.b),
      at.setXYZ(5, et.r, et.g, et.b),
      at.setXYZ(6, et.r, et.g, et.b),
      at.setXYZ(7, et.r, et.g, et.b),
      at.setXYZ(8, et.r, et.g, et.b),
      at.setXYZ(9, et.r, et.g, et.b),
      at.setXYZ(10, et.r, et.g, et.b),
      at.setXYZ(11, et.r, et.g, et.b),
      at.setXYZ(12, et.r, et.g, et.b),
      at.setXYZ(13, et.r, et.g, et.b),
      at.setXYZ(14, et.r, et.g, et.b),
      at.setXYZ(15, et.r, et.g, et.b),
      at.setXYZ(16, et.r, et.g, et.b),
      at.setXYZ(17, et.r, et.g, et.b),
      at.setXYZ(18, et.r, et.g, et.b),
      at.setXYZ(19, et.r, et.g, et.b),
      at.setXYZ(20, et.r, et.g, et.b),
      at.setXYZ(21, et.r, et.g, et.b),
      at.setXYZ(22, et.r, et.g, et.b),
      at.setXYZ(23, et.r, et.g, et.b),
      at.setXYZ(24, nt.r, nt.g, nt.b),
      at.setXYZ(25, nt.r, nt.g, nt.b),
      at.setXYZ(26, nt.r, nt.g, nt.b),
      at.setXYZ(27, nt.r, nt.g, nt.b),
      at.setXYZ(28, nt.r, nt.g, nt.b),
      at.setXYZ(29, nt.r, nt.g, nt.b),
      at.setXYZ(30, nt.r, nt.g, nt.b),
      at.setXYZ(31, nt.r, nt.g, nt.b),
      at.setXYZ(32, rt.r, rt.g, rt.b),
      at.setXYZ(33, rt.r, rt.g, rt.b),
      at.setXYZ(34, rt.r, rt.g, rt.b),
      at.setXYZ(35, rt.r, rt.g, rt.b),
      at.setXYZ(36, rt.r, rt.g, rt.b),
      at.setXYZ(37, rt.r, rt.g, rt.b),
      at.setXYZ(38, it.r, it.g, it.b),
      at.setXYZ(39, it.r, it.g, it.b),
      at.setXYZ(40, st.r, st.g, st.b),
      at.setXYZ(41, st.r, st.g, st.b),
      at.setXYZ(42, st.r, st.g, st.b),
      at.setXYZ(43, st.r, st.g, st.b),
      at.setXYZ(44, st.r, st.g, st.b),
      at.setXYZ(45, st.r, st.g, st.b),
      at.setXYZ(46, st.r, st.g, st.b),
      at.setXYZ(47, st.r, st.g, st.b),
      at.setXYZ(48, st.r, st.g, st.b),
      at.setXYZ(49, st.r, st.g, st.b),
      (at.needsUpdate = !0);
  }
  update() {
    const et = this.geometry,
      nt = this.pointMap,
      rt = 1,
      it = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      setPoint("c", nt, et, _camera, 0, 0, -1),
      setPoint("t", nt, et, _camera, 0, 0, 1),
      setPoint("n1", nt, et, _camera, -rt, -it, -1),
      setPoint("n2", nt, et, _camera, rt, -it, -1),
      setPoint("n3", nt, et, _camera, -rt, it, -1),
      setPoint("n4", nt, et, _camera, rt, it, -1),
      setPoint("f1", nt, et, _camera, -rt, -it, 1),
      setPoint("f2", nt, et, _camera, rt, -it, 1),
      setPoint("f3", nt, et, _camera, -rt, it, 1),
      setPoint("f4", nt, et, _camera, rt, it, 1),
      setPoint("u1", nt, et, _camera, rt * 0.7, it * 1.1, -1),
      setPoint("u2", nt, et, _camera, -rt * 0.7, it * 1.1, -1),
      setPoint("u3", nt, et, _camera, 0, it * 2, -1),
      setPoint("cf1", nt, et, _camera, -rt, 0, 1),
      setPoint("cf2", nt, et, _camera, rt, 0, 1),
      setPoint("cf3", nt, et, _camera, 0, -it, 1),
      setPoint("cf4", nt, et, _camera, 0, it, 1),
      setPoint("cn1", nt, et, _camera, -rt, 0, -1),
      setPoint("cn2", nt, et, _camera, rt, 0, -1),
      setPoint("cn3", nt, et, _camera, 0, -it, -1),
      setPoint("cn4", nt, et, _camera, 0, it, -1),
      (et.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function setPoint(tt, et, nt, rt, it, st, ot) {
  _vector$c.set(it, st, ot).unproject(rt);
  const at = et[tt];
  if (at !== void 0) {
    const lt = nt.getAttribute("position");
    for (let ct = 0, ut = at.length; ct < ut; ct++)
      lt.setXYZ(at[ct], _vector$c.x, _vector$c.y, _vector$c.z);
  }
}
const _box$4 = new Box3();
class BoxHelper extends LineSegments {
  constructor(et, nt = 16776960) {
    const rt = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      it = new Float32Array(8 * 3),
      st = new BufferGeometry();
    st.setIndex(new BufferAttribute(rt, 1)),
      st.setAttribute("position", new BufferAttribute(it, 3)),
      super(st, new LineBasicMaterial({ color: nt, toneMapped: !1 })),
      (this.object = et),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(et) {
    if (
      (et !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && _box$4.setFromObject(this.object),
      _box$4.isEmpty())
    )
      return;
    const nt = _box$4.min,
      rt = _box$4.max,
      it = this.geometry.attributes.position,
      st = it.array;
    (st[0] = rt.x),
      (st[1] = rt.y),
      (st[2] = rt.z),
      (st[3] = nt.x),
      (st[4] = rt.y),
      (st[5] = rt.z),
      (st[6] = nt.x),
      (st[7] = nt.y),
      (st[8] = rt.z),
      (st[9] = rt.x),
      (st[10] = nt.y),
      (st[11] = rt.z),
      (st[12] = rt.x),
      (st[13] = rt.y),
      (st[14] = nt.z),
      (st[15] = nt.x),
      (st[16] = rt.y),
      (st[17] = nt.z),
      (st[18] = nt.x),
      (st[19] = nt.y),
      (st[20] = nt.z),
      (st[21] = rt.x),
      (st[22] = nt.y),
      (st[23] = nt.z),
      (it.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(et) {
    return (this.object = et), this.update(), this;
  }
  copy(et, nt) {
    return super.copy(et, nt), (this.object = et.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Box3Helper extends LineSegments {
  constructor(et, nt = 16776960) {
    const rt = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      it = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      st = new BufferGeometry();
    st.setIndex(new BufferAttribute(rt, 1)),
      st.setAttribute("position", new Float32BufferAttribute(it, 3)),
      super(st, new LineBasicMaterial({ color: nt, toneMapped: !1 })),
      (this.box = et),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(et) {
    const nt = this.box;
    nt.isEmpty() ||
      (nt.getCenter(this.position),
      nt.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(et));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PlaneHelper extends Line$1 {
  constructor(et, nt = 1, rt = 16776960) {
    const it = rt,
      st = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      ot = new BufferGeometry();
    ot.setAttribute("position", new Float32BufferAttribute(st, 3)),
      ot.computeBoundingSphere(),
      super(ot, new LineBasicMaterial({ color: it, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = et),
      (this.size = nt);
    const at = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      lt = new BufferGeometry();
    lt.setAttribute("position", new Float32BufferAttribute(at, 3)),
      lt.computeBoundingSphere(),
      this.add(
        new Mesh(
          lt,
          new MeshBasicMaterial({
            color: it,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(et) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(et);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const _axis = new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(
    et = new Vector3(0, 0, 1),
    nt = new Vector3(0, 0, 0),
    rt = 1,
    it = 16776960,
    st = rt * 0.2,
    ot = st * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      _lineGeometry === void 0 &&
        ((_lineGeometry = new BufferGeometry()),
        _lineGeometry.setAttribute(
          "position",
          new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        ),
        (_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1)),
        _coneGeometry.translate(0, -0.5, 0)),
      this.position.copy(nt),
      (this.line = new Line$1(
        _lineGeometry,
        new LineBasicMaterial({ color: it, toneMapped: !1 })
      )),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Mesh(
        _coneGeometry,
        new MeshBasicMaterial({ color: it, toneMapped: !1 })
      )),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(et),
      this.setLength(rt, st, ot);
  }
  setDirection(et) {
    if (et.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (et.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(et.z, 0, -et.x).normalize();
      const nt = Math.acos(et.y);
      this.quaternion.setFromAxisAngle(_axis, nt);
    }
  }
  setLength(et, nt = et * 0.2, rt = nt * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, et - nt), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(rt, nt, rt),
      (this.cone.position.y = et),
      this.cone.updateMatrix();
  }
  setColor(et) {
    this.line.material.color.set(et), this.cone.material.color.set(et);
  }
  copy(et) {
    return (
      super.copy(et, !1), this.line.copy(et.line), this.cone.copy(et.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class AxesHelper extends LineSegments {
  constructor(et = 1) {
    const nt = [0, 0, 0, et, 0, 0, 0, 0, 0, 0, et, 0, 0, 0, 0, 0, 0, et],
      rt = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      it = new BufferGeometry();
    it.setAttribute("position", new Float32BufferAttribute(nt, 3)),
      it.setAttribute("color", new Float32BufferAttribute(rt, 3));
    const st = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(it, st), (this.type = "AxesHelper");
  }
  setColors(et, nt, rt) {
    const it = new Color(),
      st = this.geometry.attributes.color.array;
    return (
      it.set(et),
      it.toArray(st, 0),
      it.toArray(st, 3),
      it.set(nt),
      it.toArray(st, 6),
      it.toArray(st, 9),
      it.set(rt),
      it.toArray(st, 12),
      it.toArray(st, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Color()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(et, nt) {
    return (
      (this.currentPath = new Path()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(et, nt),
      this
    );
  }
  lineTo(et, nt) {
    return this.currentPath.lineTo(et, nt), this;
  }
  quadraticCurveTo(et, nt, rt, it) {
    return this.currentPath.quadraticCurveTo(et, nt, rt, it), this;
  }
  bezierCurveTo(et, nt, rt, it, st, ot) {
    return this.currentPath.bezierCurveTo(et, nt, rt, it, st, ot), this;
  }
  splineThru(et) {
    return this.currentPath.splineThru(et), this;
  }
  toShapes(et) {
    function nt(pt) {
      const xt = [];
      for (let St = 0, At = pt.length; St < At; St++) {
        const Ct = pt[St],
          Mt = new Shape();
        (Mt.curves = Ct.curves), xt.push(Mt);
      }
      return xt;
    }
    function rt(pt, xt) {
      const St = xt.length;
      let At = !1;
      for (let Ct = St - 1, Mt = 0; Mt < St; Ct = Mt++) {
        let wt = xt[Ct],
          Bt = xt[Mt],
          It = Bt.x - wt.x,
          Ft = Bt.y - wt.y;
        if (Math.abs(Ft) > Number.EPSILON) {
          if (
            (Ft < 0 && ((wt = xt[Mt]), (It = -It), (Bt = xt[Ct]), (Ft = -Ft)),
            pt.y < wt.y || pt.y > Bt.y)
          )
            continue;
          if (pt.y === wt.y) {
            if (pt.x === wt.x) return !0;
          } else {
            const Vt = Ft * (pt.x - wt.x) - It * (pt.y - wt.y);
            if (Vt === 0) return !0;
            if (Vt < 0) continue;
            At = !At;
          }
        } else {
          if (pt.y !== wt.y) continue;
          if ((Bt.x <= pt.x && pt.x <= wt.x) || (wt.x <= pt.x && pt.x <= Bt.x))
            return !0;
        }
      }
      return At;
    }
    const it = ShapeUtils.isClockWise,
      st = this.subPaths;
    if (st.length === 0) return [];
    let ot, at, lt;
    const ct = [];
    if (st.length === 1)
      return (
        (at = st[0]),
        (lt = new Shape()),
        (lt.curves = at.curves),
        ct.push(lt),
        ct
      );
    let ut = !it(st[0].getPoints());
    ut = et ? !ut : ut;
    const ft = [],
      ht = [];
    let mt = [],
      vt = 0,
      yt;
    (ht[vt] = void 0), (mt[vt] = []);
    for (let pt = 0, xt = st.length; pt < xt; pt++)
      (at = st[pt]),
        (yt = at.getPoints()),
        (ot = it(yt)),
        (ot = et ? !ot : ot),
        ot
          ? (!ut && ht[vt] && vt++,
            (ht[vt] = { s: new Shape(), p: yt }),
            (ht[vt].s.curves = at.curves),
            ut && vt++,
            (mt[vt] = []))
          : mt[vt].push({ h: at, p: yt[0] });
    if (!ht[0]) return nt(st);
    if (ht.length > 1) {
      let pt = !1,
        xt = 0;
      for (let St = 0, At = ht.length; St < At; St++) ft[St] = [];
      for (let St = 0, At = ht.length; St < At; St++) {
        const Ct = mt[St];
        for (let Mt = 0; Mt < Ct.length; Mt++) {
          const wt = Ct[Mt];
          let Bt = !0;
          for (let It = 0; It < ht.length; It++)
            rt(wt.p, ht[It].p) &&
              (St !== It && xt++,
              Bt ? ((Bt = !1), ft[It].push(wt)) : (pt = !0));
          Bt && ft[St].push(wt);
        }
      }
      xt > 0 && pt === !1 && (mt = ft);
    }
    let Et;
    for (let pt = 0, xt = ht.length; pt < xt; pt++) {
      (lt = ht[pt].s), ct.push(lt), (Et = mt[pt]);
      for (let St = 0, At = Et.length; St < At; St++) lt.holes.push(Et[St].h);
    }
    return ct;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: REVISION } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = REVISION));
const THREE = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping,
      AddEquation,
      AddOperation,
      AdditiveAnimationBlendMode,
      AdditiveBlending,
      AlphaFormat,
      AlwaysCompare,
      AlwaysDepth,
      AlwaysStencilFunc,
      AmbientLight,
      AnimationAction,
      AnimationClip,
      AnimationLoader,
      AnimationMixer,
      AnimationObjectGroup,
      AnimationUtils,
      ArcCurve,
      ArrayCamera,
      ArrowHelper,
      Audio,
      AudioAnalyser,
      AudioContext,
      AudioListener,
      AudioLoader,
      AxesHelper,
      BackSide,
      BasicDepthPacking,
      BasicShadowMap,
      Bone,
      BooleanKeyframeTrack,
      Box2,
      Box3,
      Box3Helper,
      BoxGeometry,
      BoxHelper,
      BufferAttribute,
      BufferGeometry,
      BufferGeometryLoader,
      ByteType,
      Cache,
      Camera,
      CameraHelper,
      CanvasTexture,
      CapsuleGeometry,
      CatmullRomCurve3,
      CineonToneMapping,
      CircleGeometry,
      ClampToEdgeWrapping,
      Clock,
      Color,
      ColorKeyframeTrack,
      ColorManagement,
      CompressedArrayTexture,
      CompressedCubeTexture,
      CompressedTexture,
      CompressedTextureLoader,
      ConeGeometry,
      CubeCamera,
      CubeReflectionMapping,
      CubeRefractionMapping,
      CubeTexture,
      CubeTextureLoader,
      CubeUVReflectionMapping,
      CubicBezierCurve,
      CubicBezierCurve3,
      CubicInterpolant,
      CullFaceBack,
      CullFaceFront,
      CullFaceFrontBack,
      CullFaceNone,
      Curve,
      CurvePath,
      CustomBlending,
      CustomToneMapping,
      CylinderGeometry,
      Cylindrical,
      Data3DTexture,
      DataArrayTexture,
      DataTexture,
      DataTextureLoader,
      DataUtils,
      DecrementStencilOp,
      DecrementWrapStencilOp,
      DefaultLoadingManager,
      DepthFormat,
      DepthStencilFormat,
      DepthTexture,
      DirectionalLight,
      DirectionalLightHelper,
      DiscreteInterpolant,
      DisplayP3ColorSpace,
      DodecahedronGeometry,
      DoubleSide,
      DstAlphaFactor,
      DstColorFactor,
      DynamicCopyUsage,
      DynamicDrawUsage,
      DynamicReadUsage,
      EdgesGeometry,
      EllipseCurve,
      EqualCompare,
      EqualDepth,
      EqualStencilFunc,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      Euler,
      EventDispatcher,
      ExtrudeGeometry,
      FileLoader,
      Float16BufferAttribute,
      Float32BufferAttribute,
      Float64BufferAttribute,
      FloatType,
      Fog,
      FogExp2,
      FramebufferTexture,
      FrontSide,
      Frustum,
      GLBufferAttribute,
      GLSL1,
      GLSL3,
      GreaterCompare,
      GreaterDepth,
      GreaterEqualCompare,
      GreaterEqualDepth,
      GreaterEqualStencilFunc,
      GreaterStencilFunc,
      GridHelper,
      Group,
      HalfFloatType,
      HemisphereLight,
      HemisphereLightHelper,
      IcosahedronGeometry,
      ImageBitmapLoader,
      ImageLoader,
      ImageUtils,
      IncrementStencilOp,
      IncrementWrapStencilOp,
      InstancedBufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InstancedMesh,
      Int16BufferAttribute,
      Int32BufferAttribute,
      Int8BufferAttribute,
      IntType,
      InterleavedBuffer,
      InterleavedBufferAttribute,
      Interpolant,
      InterpolateDiscrete,
      InterpolateLinear,
      InterpolateSmooth,
      InvertStencilOp,
      KeepStencilOp,
      KeyframeTrack,
      LOD,
      LatheGeometry,
      Layers,
      LessCompare,
      LessDepth,
      LessEqualCompare,
      LessEqualDepth,
      LessEqualStencilFunc,
      LessStencilFunc,
      Light,
      LightProbe,
      Line: Line$1,
      Line3,
      LineBasicMaterial,
      LineCurve,
      LineCurve3,
      LineDashedMaterial,
      LineLoop,
      LineSegments,
      LinearDisplayP3ColorSpace,
      LinearEncoding,
      LinearFilter,
      LinearInterpolant,
      LinearMipMapLinearFilter,
      LinearMipMapNearestFilter,
      LinearMipmapLinearFilter,
      LinearMipmapNearestFilter,
      LinearSRGBColorSpace,
      LinearToneMapping,
      LinearTransfer,
      Loader,
      LoaderUtils,
      LoadingManager,
      LoopOnce,
      LoopPingPong,
      LoopRepeat,
      LuminanceAlphaFormat,
      LuminanceFormat,
      MOUSE,
      Material,
      MaterialLoader,
      MathUtils,
      Matrix3,
      Matrix4,
      MaxEquation,
      Mesh,
      MeshBasicMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshLambertMaterial,
      MeshMatcapMaterial,
      MeshNormalMaterial,
      MeshPhongMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshToonMaterial,
      MinEquation,
      MirroredRepeatWrapping,
      MixOperation,
      MultiplyBlending,
      MultiplyOperation,
      NearestFilter,
      NearestMipMapLinearFilter,
      NearestMipMapNearestFilter,
      NearestMipmapLinearFilter,
      NearestMipmapNearestFilter,
      NeverCompare,
      NeverDepth,
      NeverStencilFunc,
      NoBlending,
      NoColorSpace,
      NoToneMapping,
      NormalAnimationBlendMode,
      NormalBlending,
      NotEqualCompare,
      NotEqualDepth,
      NotEqualStencilFunc,
      NumberKeyframeTrack,
      Object3D,
      ObjectLoader,
      ObjectSpaceNormalMap,
      OctahedronGeometry,
      OneFactor,
      OneMinusDstAlphaFactor,
      OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor,
      OrthographicCamera,
      P3Primaries,
      PCFShadowMap,
      PCFSoftShadowMap,
      PMREMGenerator,
      Path,
      PerspectiveCamera,
      Plane,
      PlaneGeometry,
      PlaneHelper,
      PointLight,
      PointLightHelper,
      Points,
      PointsMaterial,
      PolarGridHelper,
      PolyhedronGeometry,
      PositionalAudio,
      PropertyBinding,
      PropertyMixer,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      Quaternion,
      QuaternionKeyframeTrack,
      QuaternionLinearInterpolant,
      RED_GREEN_RGTC2_Format,
      RED_RGTC1_Format,
      REVISION,
      RGBADepthPacking,
      RGBAFormat,
      RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format,
      RGB_BPTC_SIGNED_Format,
      RGB_BPTC_UNSIGNED_Format,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format,
      RGFormat,
      RGIntegerFormat,
      RawShaderMaterial,
      Ray,
      Raycaster,
      Rec709Primaries,
      RectAreaLight,
      RedFormat,
      RedIntegerFormat,
      ReinhardToneMapping,
      RenderTarget,
      RepeatWrapping,
      ReplaceStencilOp,
      ReverseSubtractEquation,
      RingGeometry,
      SIGNED_RED_GREEN_RGTC2_Format,
      SIGNED_RED_RGTC1_Format,
      SRGBColorSpace,
      SRGBTransfer,
      Scene: Scene$1,
      ShaderChunk,
      ShaderLib,
      ShaderMaterial,
      ShadowMaterial,
      Shape,
      ShapeGeometry,
      ShapePath,
      ShapeUtils,
      ShortType,
      Skeleton,
      SkeletonHelper,
      SkinnedMesh,
      Source,
      Sphere,
      SphereGeometry,
      Spherical,
      SphericalHarmonics3,
      SplineCurve,
      SpotLight,
      SpotLightHelper,
      Sprite,
      SpriteMaterial,
      SrcAlphaFactor,
      SrcAlphaSaturateFactor,
      SrcColorFactor,
      StaticCopyUsage,
      StaticDrawUsage,
      StaticReadUsage,
      StereoCamera,
      StreamCopyUsage,
      StreamDrawUsage,
      StreamReadUsage,
      StringKeyframeTrack,
      SubtractEquation,
      SubtractiveBlending,
      TOUCH,
      TangentSpaceNormalMap,
      TetrahedronGeometry,
      Texture,
      TextureLoader,
      TorusGeometry,
      TorusKnotGeometry,
      Triangle,
      TriangleFanDrawMode,
      TriangleStripDrawMode,
      TrianglesDrawMode,
      TubeGeometry,
      TwoPassDoubleSide,
      UVMapping,
      Uint16BufferAttribute,
      Uint32BufferAttribute,
      Uint8BufferAttribute,
      Uint8ClampedBufferAttribute,
      Uniform,
      UniformsGroup,
      UniformsLib,
      UniformsUtils,
      UnsignedByteType,
      UnsignedInt248Type,
      UnsignedIntType,
      UnsignedShort4444Type,
      UnsignedShort5551Type,
      UnsignedShortType,
      VSMShadowMap,
      Vector2,
      Vector3,
      Vector4,
      VectorKeyframeTrack,
      VideoTexture,
      WebGL1Renderer,
      WebGL3DRenderTarget,
      WebGLArrayRenderTarget,
      WebGLCoordinateSystem,
      WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets,
      WebGLRenderTarget,
      WebGLRenderer,
      WebGLUtils,
      WebGPUCoordinateSystem,
      WireframeGeometry,
      WrapAroundEnding,
      ZeroCurvatureEnding,
      ZeroFactor,
      ZeroSlopeEnding,
      ZeroStencilOp,
      _SRGBAFormat,
      createCanvasElement,
      sRGBEncoding,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var constants = { exports: {} },
  reactReconcilerConstants_production_min = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ reactReconcilerConstants_production_min.ConcurrentRoot = 1;
reactReconcilerConstants_production_min.ContinuousEventPriority = 4;
reactReconcilerConstants_production_min.DefaultEventPriority = 16;
reactReconcilerConstants_production_min.DiscreteEventPriority = 1;
reactReconcilerConstants_production_min.IdleEventPriority = 536870912;
reactReconcilerConstants_production_min.LegacyRoot = 0;
constants.exports = reactReconcilerConstants_production_min;
var constantsExports = constants.exports;
function createStore$2(tt) {
  let et;
  const nt = new Set(),
    rt = (ct, ut) => {
      const ft = typeof ct == "function" ? ct(et) : ct;
      if (ft !== et) {
        const ht = et;
        (et = ut ? ft : Object.assign({}, et, ft)),
          nt.forEach((mt) => mt(et, ht));
      }
    },
    it = () => et,
    st = (ct, ut = it, ft = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let ht = ut(et);
      function mt() {
        const vt = ut(et);
        if (!ft(ht, vt)) {
          const yt = ht;
          ct((ht = vt), yt);
        }
      }
      return nt.add(mt), () => nt.delete(mt);
    },
    lt = {
      setState: rt,
      getState: it,
      subscribe: (ct, ut, ft) =>
        ut || ft ? st(ct, ut, ft) : (nt.add(ct), () => nt.delete(ct)),
      destroy: () => nt.clear(),
    };
  return (et = tt(rt, it, lt)), lt;
}
const isSSR =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  useIsomorphicLayoutEffect$2 = isSSR
    ? reactExports.useEffect
    : reactExports.useLayoutEffect;
function create(tt) {
  const et = typeof tt == "function" ? createStore$2(tt) : tt,
    nt = (rt = et.getState, it = Object.is) => {
      const [, st] = reactExports.useReducer((Et) => Et + 1, 0),
        ot = et.getState(),
        at = reactExports.useRef(ot),
        lt = reactExports.useRef(rt),
        ct = reactExports.useRef(it),
        ut = reactExports.useRef(!1),
        ft = reactExports.useRef();
      ft.current === void 0 && (ft.current = rt(ot));
      let ht,
        mt = !1;
      (at.current !== ot ||
        lt.current !== rt ||
        ct.current !== it ||
        ut.current) &&
        ((ht = rt(ot)), (mt = !it(ft.current, ht))),
        useIsomorphicLayoutEffect$2(() => {
          mt && (ft.current = ht),
            (at.current = ot),
            (lt.current = rt),
            (ct.current = it),
            (ut.current = !1);
        });
      const vt = reactExports.useRef(ot);
      useIsomorphicLayoutEffect$2(() => {
        const Et = () => {
            try {
              const xt = et.getState(),
                St = lt.current(xt);
              ct.current(ft.current, St) ||
                ((at.current = xt), (ft.current = St), st());
            } catch {
              (ut.current = !0), st();
            }
          },
          pt = et.subscribe(Et);
        return et.getState() !== vt.current && Et(), pt;
      }, []);
      const yt = mt ? ht : ft.current;
      return reactExports.useDebugValue(yt), yt;
    };
  return (
    Object.assign(nt, et),
    (nt[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const rt = [nt, et];
      return {
        next() {
          const it = rt.length <= 0;
          return { value: rt.shift(), done: it };
        },
      };
    }),
    nt
  );
}
var reactReconciler = { exports: {} },
  scheduler = { exports: {} },
  scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (tt) {
  function et(Pt, Rt) {
    var Nt = Pt.length;
    Pt.push(Rt);
    e: for (; 0 < Nt; ) {
      var Dt = (Nt - 1) >>> 1,
        zt = Pt[Dt];
      if (0 < it(zt, Rt)) (Pt[Dt] = Rt), (Pt[Nt] = zt), (Nt = Dt);
      else break e;
    }
  }
  function nt(Pt) {
    return Pt.length === 0 ? null : Pt[0];
  }
  function rt(Pt) {
    if (Pt.length === 0) return null;
    var Rt = Pt[0],
      Nt = Pt.pop();
    if (Nt !== Rt) {
      Pt[0] = Nt;
      e: for (var Dt = 0, zt = Pt.length, Yt = zt >>> 1; Dt < Yt; ) {
        var qt = 2 * (Dt + 1) - 1,
          Zt = Pt[qt],
          Jt = qt + 1,
          mn = Pt[Jt];
        if (0 > it(Zt, Nt))
          Jt < zt && 0 > it(mn, Zt)
            ? ((Pt[Dt] = mn), (Pt[Jt] = Nt), (Dt = Jt))
            : ((Pt[Dt] = Zt), (Pt[qt] = Nt), (Dt = qt));
        else if (Jt < zt && 0 > it(mn, Nt))
          (Pt[Dt] = mn), (Pt[Jt] = Nt), (Dt = Jt);
        else break e;
      }
    }
    return Rt;
  }
  function it(Pt, Rt) {
    var Nt = Pt.sortIndex - Rt.sortIndex;
    return Nt !== 0 ? Nt : Pt.id - Rt.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var st = performance;
    tt.unstable_now = function () {
      return st.now();
    };
  } else {
    var ot = Date,
      at = ot.now();
    tt.unstable_now = function () {
      return ot.now() - at;
    };
  }
  var lt = [],
    ct = [],
    ut = 1,
    ft = null,
    ht = 3,
    mt = !1,
    vt = !1,
    yt = !1,
    Et = typeof setTimeout == "function" ? setTimeout : null,
    pt = typeof clearTimeout == "function" ? clearTimeout : null,
    xt = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function St(Pt) {
    for (var Rt = nt(ct); Rt !== null; ) {
      if (Rt.callback === null) rt(ct);
      else if (Rt.startTime <= Pt)
        rt(ct), (Rt.sortIndex = Rt.expirationTime), et(lt, Rt);
      else break;
      Rt = nt(ct);
    }
  }
  function At(Pt) {
    if (((yt = !1), St(Pt), !vt))
      if (nt(lt) !== null) (vt = !0), kt(Ct);
      else {
        var Rt = nt(ct);
        Rt !== null && Gt(At, Rt.startTime - Pt);
      }
  }
  function Ct(Pt, Rt) {
    (vt = !1), yt && ((yt = !1), pt(Bt), (Bt = -1)), (mt = !0);
    var Nt = ht;
    try {
      for (
        St(Rt), ft = nt(lt);
        ft !== null && (!(ft.expirationTime > Rt) || (Pt && !Vt()));

      ) {
        var Dt = ft.callback;
        if (typeof Dt == "function") {
          (ft.callback = null), (ht = ft.priorityLevel);
          var zt = Dt(ft.expirationTime <= Rt);
          (Rt = tt.unstable_now()),
            typeof zt == "function"
              ? (ft.callback = zt)
              : ft === nt(lt) && rt(lt),
            St(Rt);
        } else rt(lt);
        ft = nt(lt);
      }
      if (ft !== null) var Yt = !0;
      else {
        var qt = nt(ct);
        qt !== null && Gt(At, qt.startTime - Rt), (Yt = !1);
      }
      return Yt;
    } finally {
      (ft = null), (ht = Nt), (mt = !1);
    }
  }
  var Mt = !1,
    wt = null,
    Bt = -1,
    It = 5,
    Ft = -1;
  function Vt() {
    return !(tt.unstable_now() - Ft < It);
  }
  function $t() {
    if (wt !== null) {
      var Pt = tt.unstable_now();
      Ft = Pt;
      var Rt = !0;
      try {
        Rt = wt(!0, Pt);
      } finally {
        Rt ? Kt() : ((Mt = !1), (wt = null));
      }
    } else Mt = !1;
  }
  var Kt;
  if (typeof xt == "function")
    Kt = function () {
      xt($t);
    };
  else if (typeof MessageChannel < "u") {
    var Ht = new MessageChannel(),
      Wt = Ht.port2;
    (Ht.port1.onmessage = $t),
      (Kt = function () {
        Wt.postMessage(null);
      });
  } else
    Kt = function () {
      Et($t, 0);
    };
  function kt(Pt) {
    (wt = Pt), Mt || ((Mt = !0), Kt());
  }
  function Gt(Pt, Rt) {
    Bt = Et(function () {
      Pt(tt.unstable_now());
    }, Rt);
  }
  (tt.unstable_IdlePriority = 5),
    (tt.unstable_ImmediatePriority = 1),
    (tt.unstable_LowPriority = 4),
    (tt.unstable_NormalPriority = 3),
    (tt.unstable_Profiling = null),
    (tt.unstable_UserBlockingPriority = 2),
    (tt.unstable_cancelCallback = function (Pt) {
      Pt.callback = null;
    }),
    (tt.unstable_continueExecution = function () {
      vt || mt || ((vt = !0), kt(Ct));
    }),
    (tt.unstable_forceFrameRate = function (Pt) {
      0 > Pt || 125 < Pt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (It = 0 < Pt ? Math.floor(1e3 / Pt) : 5);
    }),
    (tt.unstable_getCurrentPriorityLevel = function () {
      return ht;
    }),
    (tt.unstable_getFirstCallbackNode = function () {
      return nt(lt);
    }),
    (tt.unstable_next = function (Pt) {
      switch (ht) {
        case 1:
        case 2:
        case 3:
          var Rt = 3;
          break;
        default:
          Rt = ht;
      }
      var Nt = ht;
      ht = Rt;
      try {
        return Pt();
      } finally {
        ht = Nt;
      }
    }),
    (tt.unstable_pauseExecution = function () {}),
    (tt.unstable_requestPaint = function () {}),
    (tt.unstable_runWithPriority = function (Pt, Rt) {
      switch (Pt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Pt = 3;
      }
      var Nt = ht;
      ht = Pt;
      try {
        return Rt();
      } finally {
        ht = Nt;
      }
    }),
    (tt.unstable_scheduleCallback = function (Pt, Rt, Nt) {
      var Dt = tt.unstable_now();
      switch (
        (typeof Nt == "object" && Nt !== null
          ? ((Nt = Nt.delay),
            (Nt = typeof Nt == "number" && 0 < Nt ? Dt + Nt : Dt))
          : (Nt = Dt),
        Pt)
      ) {
        case 1:
          var zt = -1;
          break;
        case 2:
          zt = 250;
          break;
        case 5:
          zt = 1073741823;
          break;
        case 4:
          zt = 1e4;
          break;
        default:
          zt = 5e3;
      }
      return (
        (zt = Nt + zt),
        (Pt = {
          id: ut++,
          callback: Rt,
          priorityLevel: Pt,
          startTime: Nt,
          expirationTime: zt,
          sortIndex: -1,
        }),
        Nt > Dt
          ? ((Pt.sortIndex = Nt),
            et(ct, Pt),
            nt(lt) === null &&
              Pt === nt(ct) &&
              (yt ? (pt(Bt), (Bt = -1)) : (yt = !0), Gt(At, Nt - Dt)))
          : ((Pt.sortIndex = zt), et(lt, Pt), vt || mt || ((vt = !0), kt(Ct))),
        Pt
      );
    }),
    (tt.unstable_shouldYield = Vt),
    (tt.unstable_wrapCallback = function (Pt) {
      var Rt = ht;
      return function () {
        var Nt = ht;
        ht = Rt;
        try {
          return Pt.apply(this, arguments);
        } finally {
          ht = Nt;
        }
      };
    });
})(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var reactReconciler_production_min = function (et) {
  var nt = {},
    rt = reactExports,
    it = schedulerExports,
    st = Object.assign;
  function ot(dt) {
    for (
      var gt = "https://reactjs.org/docs/error-decoder.html?invariant=" + dt,
        bt = 1;
      bt < arguments.length;
      bt++
    )
      gt += "&args[]=" + encodeURIComponent(arguments[bt]);
    return (
      "Minified React error #" +
      dt +
      "; visit " +
      gt +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var at = rt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    lt = Symbol.for("react.element"),
    ct = Symbol.for("react.portal"),
    ut = Symbol.for("react.fragment"),
    ft = Symbol.for("react.strict_mode"),
    ht = Symbol.for("react.profiler"),
    mt = Symbol.for("react.provider"),
    vt = Symbol.for("react.context"),
    yt = Symbol.for("react.forward_ref"),
    Et = Symbol.for("react.suspense"),
    pt = Symbol.for("react.suspense_list"),
    xt = Symbol.for("react.memo"),
    St = Symbol.for("react.lazy"),
    At = Symbol.for("react.offscreen"),
    Ct = Symbol.iterator;
  function Mt(dt) {
    return dt === null || typeof dt != "object"
      ? null
      : ((dt = (Ct && dt[Ct]) || dt["@@iterator"]),
        typeof dt == "function" ? dt : null);
  }
  function wt(dt) {
    if (dt == null) return null;
    if (typeof dt == "function") return dt.displayName || dt.name || null;
    if (typeof dt == "string") return dt;
    switch (dt) {
      case ut:
        return "Fragment";
      case ct:
        return "Portal";
      case ht:
        return "Profiler";
      case ft:
        return "StrictMode";
      case Et:
        return "Suspense";
      case pt:
        return "SuspenseList";
    }
    if (typeof dt == "object")
      switch (dt.$$typeof) {
        case vt:
          return (dt.displayName || "Context") + ".Consumer";
        case mt:
          return (dt._context.displayName || "Context") + ".Provider";
        case yt:
          var gt = dt.render;
          return (
            (dt = dt.displayName),
            dt ||
              ((dt = gt.displayName || gt.name || ""),
              (dt = dt !== "" ? "ForwardRef(" + dt + ")" : "ForwardRef")),
            dt
          );
        case xt:
          return (
            (gt = dt.displayName || null),
            gt !== null ? gt : wt(dt.type) || "Memo"
          );
        case St:
          (gt = dt._payload), (dt = dt._init);
          try {
            return wt(dt(gt));
          } catch {}
      }
    return null;
  }
  function Bt(dt) {
    var gt = dt.type;
    switch (dt.tag) {
      case 24:
        return "Cache";
      case 9:
        return (gt.displayName || "Context") + ".Consumer";
      case 10:
        return (gt._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (dt = gt.render),
          (dt = dt.displayName || dt.name || ""),
          gt.displayName ||
            (dt !== "" ? "ForwardRef(" + dt + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return gt;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return wt(gt);
      case 8:
        return gt === ft ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof gt == "function") return gt.displayName || gt.name || null;
        if (typeof gt == "string") return gt;
    }
    return null;
  }
  function It(dt) {
    var gt = dt,
      bt = dt;
    if (dt.alternate) for (; gt.return; ) gt = gt.return;
    else {
      dt = gt;
      do (gt = dt), gt.flags & 4098 && (bt = gt.return), (dt = gt.return);
      while (dt);
    }
    return gt.tag === 3 ? bt : null;
  }
  function Ft(dt) {
    if (It(dt) !== dt) throw Error(ot(188));
  }
  function Vt(dt) {
    var gt = dt.alternate;
    if (!gt) {
      if (((gt = It(dt)), gt === null)) throw Error(ot(188));
      return gt !== dt ? null : dt;
    }
    for (var bt = dt, Tt = gt; ; ) {
      var Lt = bt.return;
      if (Lt === null) break;
      var Ot = Lt.alternate;
      if (Ot === null) {
        if (((Tt = Lt.return), Tt !== null)) {
          bt = Tt;
          continue;
        }
        break;
      }
      if (Lt.child === Ot.child) {
        for (Ot = Lt.child; Ot; ) {
          if (Ot === bt) return Ft(Lt), dt;
          if (Ot === Tt) return Ft(Lt), gt;
          Ot = Ot.sibling;
        }
        throw Error(ot(188));
      }
      if (bt.return !== Tt.return) (bt = Lt), (Tt = Ot);
      else {
        for (var cn = !1, Sn = Lt.child; Sn; ) {
          if (Sn === bt) {
            (cn = !0), (bt = Lt), (Tt = Ot);
            break;
          }
          if (Sn === Tt) {
            (cn = !0), (Tt = Lt), (bt = Ot);
            break;
          }
          Sn = Sn.sibling;
        }
        if (!cn) {
          for (Sn = Ot.child; Sn; ) {
            if (Sn === bt) {
              (cn = !0), (bt = Ot), (Tt = Lt);
              break;
            }
            if (Sn === Tt) {
              (cn = !0), (Tt = Ot), (bt = Lt);
              break;
            }
            Sn = Sn.sibling;
          }
          if (!cn) throw Error(ot(189));
        }
      }
      if (bt.alternate !== Tt) throw Error(ot(190));
    }
    if (bt.tag !== 3) throw Error(ot(188));
    return bt.stateNode.current === bt ? dt : gt;
  }
  function $t(dt) {
    return (dt = Vt(dt)), dt !== null ? Kt(dt) : null;
  }
  function Kt(dt) {
    if (dt.tag === 5 || dt.tag === 6) return dt;
    for (dt = dt.child; dt !== null; ) {
      var gt = Kt(dt);
      if (gt !== null) return gt;
      dt = dt.sibling;
    }
    return null;
  }
  function Ht(dt) {
    if (dt.tag === 5 || dt.tag === 6) return dt;
    for (dt = dt.child; dt !== null; ) {
      if (dt.tag !== 4) {
        var gt = Ht(dt);
        if (gt !== null) return gt;
      }
      dt = dt.sibling;
    }
    return null;
  }
  var Wt = Array.isArray,
    kt = et.getPublicInstance,
    Gt = et.getRootHostContext,
    Pt = et.getChildHostContext,
    Rt = et.prepareForCommit,
    Nt = et.resetAfterCommit,
    Dt = et.createInstance,
    zt = et.appendInitialChild,
    Yt = et.finalizeInitialChildren,
    qt = et.prepareUpdate,
    Zt = et.shouldSetTextContent,
    Jt = et.createTextInstance,
    mn = et.scheduleTimeout,
    ln = et.cancelTimeout,
    bn = et.noTimeout,
    Bn = et.isPrimaryRenderer,
    gn = et.supportsMutation,
    jt = et.supportsPersistence,
    yn = et.supportsHydration,
    pn = et.getInstanceFromNode,
    vn = et.preparePortalMount,
    xn = et.getCurrentEventPriority,
    Fn = et.detachDeletedInstance,
    _n = et.supportsMicrotasks,
    Dn = et.scheduleMicrotask,
    Tn = et.supportsTestSelectors,
    An = et.findFiberRoot,
    Wn = et.getBoundingRect,
    Xt = et.getTextContent,
    Ut = et.isHiddenSubtree,
    hn = et.matchAccessibilityRole,
    Ln = et.setFocusIfFocusable,
    Cn = et.setupIntersectionObserver,
    Mn = et.appendChild,
    kn = et.appendChildToContainer,
    Vn = et.commitTextUpdate,
    Kn = et.commitMount,
    Yn = et.commitUpdate,
    ir = et.insertBefore,
    On = et.insertInContainerBefore,
    qn = et.removeChild,
    dn = et.removeChildFromContainer,
    Pn = et.resetTextContent,
    Hn = et.hideInstance,
    Qt = et.hideTextInstance,
    zn = et.unhideInstance,
    Xn = et.unhideTextInstance,
    Qn = et.clearContainer,
    tr = et.cloneInstance,
    jn = et.createContainerChildSet,
    nr = et.appendChildToContainerChildSet,
    or = et.finalizeContainerChildren,
    vr = et.replaceContainerChildren,
    Ar = et.cloneHiddenInstance,
    _r = et.cloneHiddenTextInstance,
    yr = et.canHydrateInstance,
    Qr = et.canHydrateTextInstance,
    Zr = et.canHydrateSuspenseInstance,
    Mr = et.isSuspenseInstancePending,
    Fr = et.isSuspenseInstanceFallback,
    Dr = et.registerSuspenseInstanceRetry,
    Pr = et.getNextHydratableSibling,
    Gr = et.getFirstHydratableChild,
    $r = et.getFirstHydratableChildWithinContainer,
    fs = et.getFirstHydratableChildWithinSuspenseInstance,
    ss = et.hydrateInstance,
    sn = et.hydrateTextInstance,
    wn = et.hydrateSuspenseInstance,
    Un = et.getNextHydratableInstanceAfterSuspenseInstance,
    Rn = et.commitHydratedContainer,
    Gn = et.commitHydratedSuspenseInstance,
    ar = et.clearSuspenseBoundary,
    fr = et.clearSuspenseBoundaryFromContainer,
    Zn = et.shouldDeleteUnhydratedTailInstances,
    lr = et.didNotMatchHydratedContainerTextInstance,
    xr = et.didNotMatchHydratedTextInstance,
    Jn;
  function dr(dt) {
    if (Jn === void 0)
      try {
        throw Error();
      } catch (bt) {
        var gt = bt.stack.trim().match(/\n( *(at )?)/);
        Jn = (gt && gt[1]) || "";
      }
    return (
      `
` +
      Jn +
      dt
    );
  }
  var kr = !1;
  function Rr(dt, gt) {
    if (!dt || kr) return "";
    kr = !0;
    var bt = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (gt)
        if (
          ((gt = function () {
            throw Error();
          }),
          Object.defineProperty(gt.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(gt, []);
          } catch (er) {
            var Tt = er;
          }
          Reflect.construct(dt, [], gt);
        } else {
          try {
            gt.call();
          } catch (er) {
            Tt = er;
          }
          dt.call(gt.prototype);
        }
      else {
        try {
          throw Error();
        } catch (er) {
          Tt = er;
        }
        dt();
      }
    } catch (er) {
      if (er && Tt && typeof er.stack == "string") {
        for (
          var Lt = er.stack.split(`
`),
            Ot = Tt.stack.split(`
`),
            cn = Lt.length - 1,
            Sn = Ot.length - 1;
          1 <= cn && 0 <= Sn && Lt[cn] !== Ot[Sn];

        )
          Sn--;
        for (; 1 <= cn && 0 <= Sn; cn--, Sn--)
          if (Lt[cn] !== Ot[Sn]) {
            if (cn !== 1 || Sn !== 1)
              do
                if ((cn--, Sn--, 0 > Sn || Lt[cn] !== Ot[Sn])) {
                  var $n =
                    `
` + Lt[cn].replace(" at new ", " at ");
                  return (
                    dt.displayName &&
                      $n.includes("<anonymous>") &&
                      ($n = $n.replace("<anonymous>", dt.displayName)),
                    $n
                  );
                }
              while (1 <= cn && 0 <= Sn);
            break;
          }
      }
    } finally {
      (kr = !1), (Error.prepareStackTrace = bt);
    }
    return (dt = dt ? dt.displayName || dt.name : "") ? dr(dt) : "";
  }
  var ns = Object.prototype.hasOwnProperty,
    hs = [],
    Lr = -1;
  function mr(dt) {
    return { current: dt };
  }
  function wr(dt) {
    0 > Lr || ((dt.current = hs[Lr]), (hs[Lr] = null), Lr--);
  }
  function gr(dt, gt) {
    Lr++, (hs[Lr] = dt.current), (dt.current = gt);
  }
  var Kr = {},
    jr = mr(Kr),
    Vr = mr(!1),
    Cs = Kr;
  function Or(dt, gt) {
    var bt = dt.type.contextTypes;
    if (!bt) return Kr;
    var Tt = dt.stateNode;
    if (Tt && Tt.__reactInternalMemoizedUnmaskedChildContext === gt)
      return Tt.__reactInternalMemoizedMaskedChildContext;
    var Lt = {},
      Ot;
    for (Ot in bt) Lt[Ot] = gt[Ot];
    return (
      Tt &&
        ((dt = dt.stateNode),
        (dt.__reactInternalMemoizedUnmaskedChildContext = gt),
        (dt.__reactInternalMemoizedMaskedChildContext = Lt)),
      Lt
    );
  }
  function Ur(dt) {
    return (dt = dt.childContextTypes), dt != null;
  }
  function ys() {
    wr(Vr), wr(jr);
  }
  function _i(dt, gt, bt) {
    if (jr.current !== Kr) throw Error(ot(168));
    gr(jr, gt), gr(Vr, bt);
  }
  function Ks(dt, gt, bt) {
    var Tt = dt.stateNode;
    if (((gt = gt.childContextTypes), typeof Tt.getChildContext != "function"))
      return bt;
    Tt = Tt.getChildContext();
    for (var Lt in Tt)
      if (!(Lt in gt)) throw Error(ot(108, Bt(dt) || "Unknown", Lt));
    return st({}, bt, Tt);
  }
  function Js(dt) {
    return (
      (dt =
        ((dt = dt.stateNode) && dt.__reactInternalMemoizedMergedChildContext) ||
        Kr),
      (Cs = jr.current),
      gr(jr, dt),
      gr(Vr, Vr.current),
      !0
    );
  }
  function ds(dt, gt, bt) {
    var Tt = dt.stateNode;
    if (!Tt) throw Error(ot(169));
    bt
      ? ((dt = Ks(dt, gt, Cs)),
        (Tt.__reactInternalMemoizedMergedChildContext = dt),
        wr(Vr),
        wr(jr),
        gr(jr, dt))
      : wr(Vr),
      gr(Vr, bt);
  }
  var Rs = Math.clz32 ? Math.clz32 : Ul,
    Uo = Math.log,
    Ao = Math.LN2;
  function Ul(dt) {
    return (dt >>>= 0), dt === 0 ? 32 : (31 - ((Uo(dt) / Ao) | 0)) | 0;
  }
  var no = 64,
    ro = 4194304;
  function io(dt) {
    switch (dt & -dt) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return dt & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return dt & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return dt;
    }
  }
  function bo(dt, gt) {
    var bt = dt.pendingLanes;
    if (bt === 0) return 0;
    var Tt = 0,
      Lt = dt.suspendedLanes,
      Ot = dt.pingedLanes,
      cn = bt & 268435455;
    if (cn !== 0) {
      var Sn = cn & ~Lt;
      Sn !== 0 ? (Tt = io(Sn)) : ((Ot &= cn), Ot !== 0 && (Tt = io(Ot)));
    } else
      (cn = bt & ~Lt), cn !== 0 ? (Tt = io(cn)) : Ot !== 0 && (Tt = io(Ot));
    if (Tt === 0) return 0;
    if (
      gt !== 0 &&
      gt !== Tt &&
      !(gt & Lt) &&
      ((Lt = Tt & -Tt),
      (Ot = gt & -gt),
      Lt >= Ot || (Lt === 16 && (Ot & 4194240) !== 0))
    )
      return gt;
    if ((Tt & 4 && (Tt |= bt & 16), (gt = dt.entangledLanes), gt !== 0))
      for (dt = dt.entanglements, gt &= Tt; 0 < gt; )
        (bt = 31 - Rs(gt)), (Lt = 1 << bt), (Tt |= dt[bt]), (gt &= ~Lt);
    return Tt;
  }
  function Gl(dt, gt) {
    switch (dt) {
      case 1:
      case 2:
      case 4:
        return gt + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return gt + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function na(dt, gt) {
    for (
      var bt = dt.suspendedLanes,
        Tt = dt.pingedLanes,
        Lt = dt.expirationTimes,
        Ot = dt.pendingLanes;
      0 < Ot;

    ) {
      var cn = 31 - Rs(Ot),
        Sn = 1 << cn,
        $n = Lt[cn];
      $n === -1
        ? (!(Sn & bt) || Sn & Tt) && (Lt[cn] = Gl(Sn, gt))
        : $n <= gt && (dt.expiredLanes |= Sn),
        (Ot &= ~Sn);
    }
  }
  function so(dt) {
    return (
      (dt = dt.pendingLanes & -1073741825),
      dt !== 0 ? dt : dt & 1073741824 ? 1073741824 : 0
    );
  }
  function Go(dt) {
    for (var gt = [], bt = 0; 31 > bt; bt++) gt.push(dt);
    return gt;
  }
  function Ys(dt, gt, bt) {
    (dt.pendingLanes |= gt),
      gt !== 536870912 && ((dt.suspendedLanes = 0), (dt.pingedLanes = 0)),
      (dt = dt.eventTimes),
      (gt = 31 - Rs(gt)),
      (dt[gt] = bt);
  }
  function ho(dt, gt) {
    var bt = dt.pendingLanes & ~gt;
    (dt.pendingLanes = gt),
      (dt.suspendedLanes = 0),
      (dt.pingedLanes = 0),
      (dt.expiredLanes &= gt),
      (dt.mutableReadLanes &= gt),
      (dt.entangledLanes &= gt),
      (gt = dt.entanglements);
    var Tt = dt.eventTimes;
    for (dt = dt.expirationTimes; 0 < bt; ) {
      var Lt = 31 - Rs(bt),
        Ot = 1 << Lt;
      (gt[Lt] = 0), (Tt[Lt] = -1), (dt[Lt] = -1), (bt &= ~Ot);
    }
  }
  function qs(dt, gt) {
    var bt = (dt.entangledLanes |= gt);
    for (dt = dt.entanglements; bt; ) {
      var Tt = 31 - Rs(bt),
        Lt = 1 << Tt;
      (Lt & gt) | (dt[Tt] & gt) && (dt[Tt] |= gt), (bt &= ~Lt);
    }
  }
  var Tr = 0;
  function ga(dt) {
    return (
      (dt &= -dt), 1 < dt ? (4 < dt ? (dt & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var oo = it.unstable_scheduleCallback,
    $o = it.unstable_cancelCallback,
    _a = it.unstable_shouldYield,
    $l = it.unstable_requestPaint,
    Hr = it.unstable_now,
    Co = it.unstable_ImmediatePriority,
    Vl = it.unstable_UserBlockingPriority,
    _s = it.unstable_NormalPriority,
    xa = it.unstable_IdlePriority,
    Mo = null,
    Bs = null;
  function ba(dt) {
    if (Bs && typeof Bs.onCommitFiberRoot == "function")
      try {
        Bs.onCommitFiberRoot(Mo, dt, void 0, (dt.current.flags & 128) === 128);
      } catch {}
  }
  function zl(dt, gt) {
    return (
      (dt === gt && (dt !== 0 || 1 / dt === 1 / gt)) || (dt !== dt && gt !== gt)
    );
  }
  var Is = typeof Object.is == "function" ? Object.is : zl,
    xs = null,
    Qs = !1,
    Ns = !1;
  function $a(dt) {
    xs === null ? (xs = [dt]) : xs.push(dt);
  }
  function yl(dt) {
    (Qs = !0), $a(dt);
  }
  function Ms() {
    if (!Ns && xs !== null) {
      Ns = !0;
      var dt = 0,
        gt = Tr;
      try {
        var bt = xs;
        for (Tr = 1; dt < bt.length; dt++) {
          var Tt = bt[dt];
          do Tt = Tt(!0);
          while (Tt !== null);
        }
        (xs = null), (Qs = !1);
      } catch (Lt) {
        throw (xs !== null && (xs = xs.slice(dt + 1)), oo(Co, Ms), Lt);
      } finally {
        (Tr = gt), (Ns = !1);
      }
    }
    return null;
  }
  var To = at.ReactCurrentBatchConfig;
  function wo(dt, gt) {
    if (Is(dt, gt)) return !0;
    if (
      typeof dt != "object" ||
      dt === null ||
      typeof gt != "object" ||
      gt === null
    )
      return !1;
    var bt = Object.keys(dt),
      Tt = Object.keys(gt);
    if (bt.length !== Tt.length) return !1;
    for (Tt = 0; Tt < bt.length; Tt++) {
      var Lt = bt[Tt];
      if (!ns.call(gt, Lt) || !Is(dt[Lt], gt[Lt])) return !1;
    }
    return !0;
  }
  function Po(dt) {
    switch (dt.tag) {
      case 5:
        return dr(dt.type);
      case 16:
        return dr("Lazy");
      case 13:
        return dr("Suspense");
      case 19:
        return dr("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (dt = Rr(dt.type, !1)), dt;
      case 11:
        return (dt = Rr(dt.type.render, !1)), dt;
      case 1:
        return (dt = Rr(dt.type, !0)), dt;
      default:
        return "";
    }
  }
  function Ss(dt, gt) {
    if (dt && dt.defaultProps) {
      (gt = st({}, gt)), (dt = dt.defaultProps);
      for (var bt in dt) gt[bt] === void 0 && (gt[bt] = dt[bt]);
      return gt;
    }
    return gt;
  }
  var os = mr(null),
    Vo = null,
    js = null,
    po = null;
  function zo() {
    po = js = Vo = null;
  }
  function Hl(dt, gt, bt) {
    Bn
      ? (gr(os, gt._currentValue), (gt._currentValue = bt))
      : (gr(os, gt._currentValue2), (gt._currentValue2 = bt));
  }
  function as(dt) {
    var gt = os.current;
    wr(os), Bn ? (dt._currentValue = gt) : (dt._currentValue2 = gt);
  }
  function Es(dt, gt, bt) {
    for (; dt !== null; ) {
      var Tt = dt.alternate;
      if (
        ((dt.childLanes & gt) !== gt
          ? ((dt.childLanes |= gt), Tt !== null && (Tt.childLanes |= gt))
          : Tt !== null && (Tt.childLanes & gt) !== gt && (Tt.childLanes |= gt),
        dt === bt)
      )
        break;
      dt = dt.return;
    }
  }
  function Jr(dt, gt) {
    (Vo = dt),
      (po = js = null),
      (dt = dt.dependencies),
      dt !== null &&
        dt.firstContext !== null &&
        (dt.lanes & gt && (ks = !0), (dt.firstContext = null));
  }
  function Yr(dt) {
    var gt = Bn ? dt._currentValue : dt._currentValue2;
    if (po !== dt)
      if (
        ((dt = { context: dt, memoizedValue: gt, next: null }), js === null)
      ) {
        if (Vo === null) throw Error(ot(308));
        (js = dt), (Vo.dependencies = { lanes: 0, firstContext: dt });
      } else js = js.next = dt;
    return gt;
  }
  var Ls = null,
    mo = !1;
  function Ru(dt) {
    dt.updateQueue = {
      baseState: dt.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function xp(dt, gt) {
    (dt = dt.updateQueue),
      gt.updateQueue === dt &&
        (gt.updateQueue = {
          baseState: dt.baseState,
          firstBaseUpdate: dt.firstBaseUpdate,
          lastBaseUpdate: dt.lastBaseUpdate,
          shared: dt.shared,
          effects: dt.effects,
        });
  }
  function ao(dt, gt) {
    return {
      eventTime: dt,
      lane: gt,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function go(dt, gt) {
    var bt = dt.updateQueue;
    bt !== null &&
      ((bt = bt.shared),
      es !== null && dt.mode & 1 && !(Cr & 2)
        ? ((dt = bt.interleaved),
          dt === null
            ? ((gt.next = gt), Ls === null ? (Ls = [bt]) : Ls.push(bt))
            : ((gt.next = dt.next), (dt.next = gt)),
          (bt.interleaved = gt))
        : ((dt = bt.pending),
          dt === null ? (gt.next = gt) : ((gt.next = dt.next), (dt.next = gt)),
          (bt.pending = gt)));
  }
  function Wl(dt, gt, bt) {
    if (
      ((gt = gt.updateQueue),
      gt !== null && ((gt = gt.shared), (bt & 4194240) !== 0))
    ) {
      var Tt = gt.lanes;
      (Tt &= dt.pendingLanes), (bt |= Tt), (gt.lanes = bt), qs(dt, bt);
    }
  }
  function Sp(dt, gt) {
    var bt = dt.updateQueue,
      Tt = dt.alternate;
    if (Tt !== null && ((Tt = Tt.updateQueue), bt === Tt)) {
      var Lt = null,
        Ot = null;
      if (((bt = bt.firstBaseUpdate), bt !== null)) {
        do {
          var cn = {
            eventTime: bt.eventTime,
            lane: bt.lane,
            tag: bt.tag,
            payload: bt.payload,
            callback: bt.callback,
            next: null,
          };
          Ot === null ? (Lt = Ot = cn) : (Ot = Ot.next = cn), (bt = bt.next);
        } while (bt !== null);
        Ot === null ? (Lt = Ot = gt) : (Ot = Ot.next = gt);
      } else Lt = Ot = gt;
      (bt = {
        baseState: Tt.baseState,
        firstBaseUpdate: Lt,
        lastBaseUpdate: Ot,
        shared: Tt.shared,
        effects: Tt.effects,
      }),
        (dt.updateQueue = bt);
      return;
    }
    (dt = bt.lastBaseUpdate),
      dt === null ? (bt.firstBaseUpdate = gt) : (dt.next = gt),
      (bt.lastBaseUpdate = gt);
  }
  function Xl(dt, gt, bt, Tt) {
    var Lt = dt.updateQueue;
    mo = !1;
    var Ot = Lt.firstBaseUpdate,
      cn = Lt.lastBaseUpdate,
      Sn = Lt.shared.pending;
    if (Sn !== null) {
      Lt.shared.pending = null;
      var $n = Sn,
        er = $n.next;
      ($n.next = null), cn === null ? (Ot = er) : (cn.next = er), (cn = $n);
      var cr = dt.alternate;
      cr !== null &&
        ((cr = cr.updateQueue),
        (Sn = cr.lastBaseUpdate),
        Sn !== cn &&
          (Sn === null ? (cr.firstBaseUpdate = er) : (Sn.next = er),
          (cr.lastBaseUpdate = $n)));
    }
    if (Ot !== null) {
      var Sr = Lt.baseState;
      (cn = 0), (cr = er = $n = null), (Sn = Ot);
      do {
        var pr = Sn.lane,
          Nr = Sn.eventTime;
        if ((Tt & pr) === pr) {
          cr !== null &&
            (cr = cr.next =
              {
                eventTime: Nr,
                lane: 0,
                tag: Sn.tag,
                payload: Sn.payload,
                callback: Sn.callback,
                next: null,
              });
          e: {
            var hr = dt,
              vs = Sn;
            switch (((pr = gt), (Nr = bt), vs.tag)) {
              case 1:
                if (((hr = vs.payload), typeof hr == "function")) {
                  Sr = hr.call(Nr, Sr, pr);
                  break e;
                }
                Sr = hr;
                break e;
              case 3:
                hr.flags = (hr.flags & -65537) | 128;
              case 0:
                if (
                  ((hr = vs.payload),
                  (pr = typeof hr == "function" ? hr.call(Nr, Sr, pr) : hr),
                  pr == null)
                )
                  break e;
                Sr = st({}, Sr, pr);
                break e;
              case 2:
                mo = !0;
            }
          }
          Sn.callback !== null &&
            Sn.lane !== 0 &&
            ((dt.flags |= 64),
            (pr = Lt.effects),
            pr === null ? (Lt.effects = [Sn]) : pr.push(Sn));
        } else
          (Nr = {
            eventTime: Nr,
            lane: pr,
            tag: Sn.tag,
            payload: Sn.payload,
            callback: Sn.callback,
            next: null,
          }),
            cr === null ? ((er = cr = Nr), ($n = Sr)) : (cr = cr.next = Nr),
            (cn |= pr);
        if (((Sn = Sn.next), Sn === null)) {
          if (((Sn = Lt.shared.pending), Sn === null)) break;
          (pr = Sn),
            (Sn = pr.next),
            (pr.next = null),
            (Lt.lastBaseUpdate = pr),
            (Lt.shared.pending = null);
        }
      } while (1);
      if (
        (cr === null && ($n = Sr),
        (Lt.baseState = $n),
        (Lt.firstBaseUpdate = er),
        (Lt.lastBaseUpdate = cr),
        (gt = Lt.shared.interleaved),
        gt !== null)
      ) {
        Lt = gt;
        do (cn |= Lt.lane), (Lt = Lt.next);
        while (Lt !== gt);
      } else Ot === null && (Lt.shared.lanes = 0);
      (Qo |= cn), (dt.lanes = cn), (dt.memoizedState = Sr);
    }
  }
  function Ep(dt, gt, bt) {
    if (((dt = gt.effects), (gt.effects = null), dt !== null))
      for (gt = 0; gt < dt.length; gt++) {
        var Tt = dt[gt],
          Lt = Tt.callback;
        if (Lt !== null) {
          if (((Tt.callback = null), (Tt = bt), typeof Lt != "function"))
            throw Error(ot(191, Lt));
          Lt.call(Tt);
        }
      }
  }
  var Ap = new rt.Component().refs;
  function Bu(dt, gt, bt, Tt) {
    (gt = dt.memoizedState),
      (bt = bt(Tt, gt)),
      (bt = bt == null ? gt : st({}, gt, bt)),
      (dt.memoizedState = bt),
      dt.lanes === 0 && (dt.updateQueue.baseState = bt);
  }
  var Kl = {
    isMounted: function (dt) {
      return (dt = dt._reactInternals) ? It(dt) === dt : !1;
    },
    enqueueSetState: function (dt, gt, bt) {
      dt = dt._reactInternals;
      var Tt = bs(),
        Lt = _o(dt),
        Ot = ao(Tt, Lt);
      (Ot.payload = gt),
        bt != null && (Ot.callback = bt),
        go(dt, Ot),
        (gt = zs(dt, Lt, Tt)),
        gt !== null && Wl(gt, dt, Lt);
    },
    enqueueReplaceState: function (dt, gt, bt) {
      dt = dt._reactInternals;
      var Tt = bs(),
        Lt = _o(dt),
        Ot = ao(Tt, Lt);
      (Ot.tag = 1),
        (Ot.payload = gt),
        bt != null && (Ot.callback = bt),
        go(dt, Ot),
        (gt = zs(dt, Lt, Tt)),
        gt !== null && Wl(gt, dt, Lt);
    },
    enqueueForceUpdate: function (dt, gt) {
      dt = dt._reactInternals;
      var bt = bs(),
        Tt = _o(dt),
        Lt = ao(bt, Tt);
      (Lt.tag = 2),
        gt != null && (Lt.callback = gt),
        go(dt, Lt),
        (gt = zs(dt, Tt, bt)),
        gt !== null && Wl(gt, dt, Tt);
    },
  };
  function bp(dt, gt, bt, Tt, Lt, Ot, cn) {
    return (
      (dt = dt.stateNode),
      typeof dt.shouldComponentUpdate == "function"
        ? dt.shouldComponentUpdate(Tt, Ot, cn)
        : gt.prototype && gt.prototype.isPureReactComponent
        ? !wo(bt, Tt) || !wo(Lt, Ot)
        : !0
    );
  }
  function Cp(dt, gt, bt) {
    var Tt = !1,
      Lt = Kr,
      Ot = gt.contextType;
    return (
      typeof Ot == "object" && Ot !== null
        ? (Ot = Yr(Ot))
        : ((Lt = Ur(gt) ? Cs : jr.current),
          (Tt = gt.contextTypes),
          (Ot = (Tt = Tt != null) ? Or(dt, Lt) : Kr)),
      (gt = new gt(bt, Ot)),
      (dt.memoizedState =
        gt.state !== null && gt.state !== void 0 ? gt.state : null),
      (gt.updater = Kl),
      (dt.stateNode = gt),
      (gt._reactInternals = dt),
      Tt &&
        ((dt = dt.stateNode),
        (dt.__reactInternalMemoizedUnmaskedChildContext = Lt),
        (dt.__reactInternalMemoizedMaskedChildContext = Ot)),
      gt
    );
  }
  function Mp(dt, gt, bt, Tt) {
    (dt = gt.state),
      typeof gt.componentWillReceiveProps == "function" &&
        gt.componentWillReceiveProps(bt, Tt),
      typeof gt.UNSAFE_componentWillReceiveProps == "function" &&
        gt.UNSAFE_componentWillReceiveProps(bt, Tt),
      gt.state !== dt && Kl.enqueueReplaceState(gt, gt.state, null);
  }
  function Iu(dt, gt, bt, Tt) {
    var Lt = dt.stateNode;
    (Lt.props = bt), (Lt.state = dt.memoizedState), (Lt.refs = Ap), Ru(dt);
    var Ot = gt.contextType;
    typeof Ot == "object" && Ot !== null
      ? (Lt.context = Yr(Ot))
      : ((Ot = Ur(gt) ? Cs : jr.current), (Lt.context = Or(dt, Ot))),
      (Lt.state = dt.memoizedState),
      (Ot = gt.getDerivedStateFromProps),
      typeof Ot == "function" &&
        (Bu(dt, gt, Ot, bt), (Lt.state = dt.memoizedState)),
      typeof gt.getDerivedStateFromProps == "function" ||
        typeof Lt.getSnapshotBeforeUpdate == "function" ||
        (typeof Lt.UNSAFE_componentWillMount != "function" &&
          typeof Lt.componentWillMount != "function") ||
        ((gt = Lt.state),
        typeof Lt.componentWillMount == "function" && Lt.componentWillMount(),
        typeof Lt.UNSAFE_componentWillMount == "function" &&
          Lt.UNSAFE_componentWillMount(),
        gt !== Lt.state && Kl.enqueueReplaceState(Lt, Lt.state, null),
        Xl(dt, bt, Lt, Tt),
        (Lt.state = dt.memoizedState)),
      typeof Lt.componentDidMount == "function" && (dt.flags |= 4194308);
  }
  var Ho = [],
    Wo = 0,
    Jl = null,
    Yl = 0,
    Us = [],
    Gs = 0,
    Ro = null,
    lo = 1,
    co = "";
  function Bo(dt, gt) {
    (Ho[Wo++] = Yl), (Ho[Wo++] = Jl), (Jl = dt), (Yl = gt);
  }
  function Tp(dt, gt, bt) {
    (Us[Gs++] = lo), (Us[Gs++] = co), (Us[Gs++] = Ro), (Ro = dt);
    var Tt = lo;
    dt = co;
    var Lt = 32 - Rs(Tt) - 1;
    (Tt &= ~(1 << Lt)), (bt += 1);
    var Ot = 32 - Rs(gt) + Lt;
    if (30 < Ot) {
      var cn = Lt - (Lt % 5);
      (Ot = (Tt & ((1 << cn) - 1)).toString(32)),
        (Tt >>= cn),
        (Lt -= cn),
        (lo = (1 << (32 - Rs(gt) + Lt)) | (bt << Lt) | Tt),
        (co = Ot + dt);
    } else (lo = (1 << Ot) | (bt << Lt) | Tt), (co = dt);
  }
  function Lu(dt) {
    dt.return !== null && (Bo(dt, 1), Tp(dt, 1, 0));
  }
  function Fu(dt) {
    for (; dt === Jl; )
      (Jl = Ho[--Wo]), (Ho[Wo] = null), (Yl = Ho[--Wo]), (Ho[Wo] = null);
    for (; dt === Ro; )
      (Ro = Us[--Gs]),
        (Us[Gs] = null),
        (co = Us[--Gs]),
        (Us[Gs] = null),
        (lo = Us[--Gs]),
        (Us[Gs] = null);
  }
  var Fs = null,
    Ds = null,
    zr = !1,
    _l = !1,
    Xs = null;
  function wp(dt, gt) {
    var bt = Hs(5, null, null, 0);
    (bt.elementType = "DELETED"),
      (bt.stateNode = gt),
      (bt.return = dt),
      (gt = dt.deletions),
      gt === null ? ((dt.deletions = [bt]), (dt.flags |= 16)) : gt.push(bt);
  }
  function Pp(dt, gt) {
    switch (dt.tag) {
      case 5:
        return (
          (gt = yr(gt, dt.type, dt.pendingProps)),
          gt !== null ? ((dt.stateNode = gt), (Fs = dt), (Ds = Gr(gt)), !0) : !1
        );
      case 6:
        return (
          (gt = Qr(gt, dt.pendingProps)),
          gt !== null ? ((dt.stateNode = gt), (Fs = dt), (Ds = null), !0) : !1
        );
      case 13:
        if (((gt = Zr(gt)), gt !== null)) {
          var bt = Ro !== null ? { id: lo, overflow: co } : null;
          return (
            (dt.memoizedState = {
              dehydrated: gt,
              treeContext: bt,
              retryLane: 1073741824,
            }),
            (bt = Hs(18, null, null, 0)),
            (bt.stateNode = gt),
            (bt.return = dt),
            (dt.child = bt),
            (Fs = dt),
            (Ds = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function Du(dt) {
    return (dt.mode & 1) !== 0 && (dt.flags & 128) === 0;
  }
  function ku(dt) {
    if (zr) {
      var gt = Ds;
      if (gt) {
        var bt = gt;
        if (!Pp(dt, gt)) {
          if (Du(dt)) throw Error(ot(418));
          gt = Pr(bt);
          var Tt = Fs;
          gt && Pp(dt, gt)
            ? wp(Tt, bt)
            : ((dt.flags = (dt.flags & -4097) | 2), (zr = !1), (Fs = dt));
        }
      } else {
        if (Du(dt)) throw Error(ot(418));
        (dt.flags = (dt.flags & -4097) | 2), (zr = !1), (Fs = dt);
      }
    }
  }
  function Rp(dt) {
    for (
      dt = dt.return;
      dt !== null && dt.tag !== 5 && dt.tag !== 3 && dt.tag !== 13;

    )
      dt = dt.return;
    Fs = dt;
  }
  function xl(dt) {
    if (!yn || dt !== Fs) return !1;
    if (!zr) return Rp(dt), (zr = !0), !1;
    if (
      dt.tag !== 3 &&
      (dt.tag !== 5 || (Zn(dt.type) && !Zt(dt.type, dt.memoizedProps)))
    ) {
      var gt = Ds;
      if (gt) {
        if (Du(dt)) {
          for (dt = Ds; dt; ) dt = Pr(dt);
          throw Error(ot(418));
        }
        for (; gt; ) wp(dt, gt), (gt = Pr(gt));
      }
    }
    if ((Rp(dt), dt.tag === 13)) {
      if (!yn) throw Error(ot(316));
      if (
        ((dt = dt.memoizedState),
        (dt = dt !== null ? dt.dehydrated : null),
        !dt)
      )
        throw Error(ot(317));
      Ds = Un(dt);
    } else Ds = Fs ? Pr(dt.stateNode) : null;
    return !0;
  }
  function jo() {
    yn && ((Ds = Fs = null), (_l = zr = !1));
  }
  function Ou(dt) {
    Xs === null ? (Xs = [dt]) : Xs.push(dt);
  }
  function Sl(dt, gt, bt) {
    if (
      ((dt = bt.ref),
      dt !== null && typeof dt != "function" && typeof dt != "object")
    ) {
      if (bt._owner) {
        if (((bt = bt._owner), bt)) {
          if (bt.tag !== 1) throw Error(ot(309));
          var Tt = bt.stateNode;
        }
        if (!Tt) throw Error(ot(147, dt));
        var Lt = Tt,
          Ot = "" + dt;
        return gt !== null &&
          gt.ref !== null &&
          typeof gt.ref == "function" &&
          gt.ref._stringRef === Ot
          ? gt.ref
          : ((gt = function (cn) {
              var Sn = Lt.refs;
              Sn === Ap && (Sn = Lt.refs = {}),
                cn === null ? delete Sn[Ot] : (Sn[Ot] = cn);
            }),
            (gt._stringRef = Ot),
            gt);
      }
      if (typeof dt != "string") throw Error(ot(284));
      if (!bt._owner) throw Error(ot(290, dt));
    }
    return dt;
  }
  function Ql(dt, gt) {
    throw (
      ((dt = Object.prototype.toString.call(gt)),
      Error(
        ot(
          31,
          dt === "[object Object]"
            ? "object with keys {" + Object.keys(gt).join(", ") + "}"
            : dt
        )
      ))
    );
  }
  function Bp(dt) {
    var gt = dt._init;
    return gt(dt._payload);
  }
  function Ip(dt) {
    function gt(In, En) {
      if (dt) {
        var Nn = In.deletions;
        Nn === null ? ((In.deletions = [En]), (In.flags |= 16)) : Nn.push(En);
      }
    }
    function bt(In, En) {
      if (!dt) return null;
      for (; En !== null; ) gt(In, En), (En = En.sibling);
      return null;
    }
    function Tt(In, En) {
      for (In = new Map(); En !== null; )
        En.key !== null ? In.set(En.key, En) : In.set(En.index, En),
          (En = En.sibling);
      return In;
    }
    function Lt(In, En) {
      return (In = So(In, En)), (In.index = 0), (In.sibling = null), In;
    }
    function Ot(In, En, Nn) {
      return (
        (In.index = Nn),
        dt
          ? ((Nn = In.alternate),
            Nn !== null
              ? ((Nn = Nn.index), Nn < En ? ((In.flags |= 2), En) : Nn)
              : ((In.flags |= 2), En))
          : ((In.flags |= 1048576), En)
      );
    }
    function cn(In) {
      return dt && In.alternate === null && (In.flags |= 2), In;
    }
    function Sn(In, En, Nn, sr) {
      return En === null || En.tag !== 6
        ? ((En = vp(Nn, In.mode, sr)), (En.return = In), En)
        : ((En = Lt(En, Nn)), (En.return = In), En);
    }
    function $n(In, En, Nn, sr) {
      var ur = Nn.type;
      return ur === ut
        ? cr(In, En, Nn.props.children, sr, Nn.key)
        : En !== null &&
          (En.elementType === ur ||
            (typeof ur == "object" &&
              ur !== null &&
              ur.$$typeof === St &&
              Bp(ur) === En.type))
        ? ((sr = Lt(En, Nn.props)),
          (sr.ref = Sl(In, En, Nn)),
          (sr.return = In),
          sr)
        : ((sr = wu(Nn.type, Nn.key, Nn.props, null, In.mode, sr)),
          (sr.ref = Sl(In, En, Nn)),
          (sr.return = In),
          sr);
    }
    function er(In, En, Nn, sr) {
      return En === null ||
        En.tag !== 4 ||
        En.stateNode.containerInfo !== Nn.containerInfo ||
        En.stateNode.implementation !== Nn.implementation
        ? ((En = yp(Nn, In.mode, sr)), (En.return = In), En)
        : ((En = Lt(En, Nn.children || [])), (En.return = In), En);
    }
    function cr(In, En, Nn, sr, ur) {
      return En === null || En.tag !== 7
        ? ((En = No(Nn, In.mode, sr, ur)), (En.return = In), En)
        : ((En = Lt(En, Nn)), (En.return = In), En);
    }
    function Sr(In, En, Nn) {
      if ((typeof En == "string" && En !== "") || typeof En == "number")
        return (En = vp("" + En, In.mode, Nn)), (En.return = In), En;
      if (typeof En == "object" && En !== null) {
        switch (En.$$typeof) {
          case lt:
            return (
              (Nn = wu(En.type, En.key, En.props, null, In.mode, Nn)),
              (Nn.ref = Sl(In, null, En)),
              (Nn.return = In),
              Nn
            );
          case ct:
            return (En = yp(En, In.mode, Nn)), (En.return = In), En;
          case St:
            var sr = En._init;
            return Sr(In, sr(En._payload), Nn);
        }
        if (Wt(En) || Mt(En))
          return (En = No(En, In.mode, Nn, null)), (En.return = In), En;
        Ql(In, En);
      }
      return null;
    }
    function pr(In, En, Nn, sr) {
      var ur = En !== null ? En.key : null;
      if ((typeof Nn == "string" && Nn !== "") || typeof Nn == "number")
        return ur !== null ? null : Sn(In, En, "" + Nn, sr);
      if (typeof Nn == "object" && Nn !== null) {
        switch (Nn.$$typeof) {
          case lt:
            return Nn.key === ur ? $n(In, En, Nn, sr) : null;
          case ct:
            return Nn.key === ur ? er(In, En, Nn, sr) : null;
          case St:
            return (ur = Nn._init), pr(In, En, ur(Nn._payload), sr);
        }
        if (Wt(Nn) || Mt(Nn))
          return ur !== null ? null : cr(In, En, Nn, sr, null);
        Ql(In, Nn);
      }
      return null;
    }
    function Nr(In, En, Nn, sr, ur) {
      if ((typeof sr == "string" && sr !== "") || typeof sr == "number")
        return (In = In.get(Nn) || null), Sn(En, In, "" + sr, ur);
      if (typeof sr == "object" && sr !== null) {
        switch (sr.$$typeof) {
          case lt:
            return (
              (In = In.get(sr.key === null ? Nn : sr.key) || null),
              $n(En, In, sr, ur)
            );
          case ct:
            return (
              (In = In.get(sr.key === null ? Nn : sr.key) || null),
              er(En, In, sr, ur)
            );
          case St:
            var br = sr._init;
            return Nr(In, En, Nn, br(sr._payload), ur);
        }
        if (Wt(sr) || Mt(sr))
          return (In = In.get(Nn) || null), cr(En, In, sr, ur, null);
        Ql(En, sr);
      }
      return null;
    }
    function hr(In, En, Nn, sr) {
      for (
        var ur = null, br = null, Er = En, Br = (En = 0), cs = null;
        Er !== null && Br < Nn.length;
        Br++
      ) {
        Er.index > Br ? ((cs = Er), (Er = null)) : (cs = Er.sibling);
        var Ir = pr(In, Er, Nn[Br], sr);
        if (Ir === null) {
          Er === null && (Er = cs);
          break;
        }
        dt && Er && Ir.alternate === null && gt(In, Er),
          (En = Ot(Ir, En, Br)),
          br === null ? (ur = Ir) : (br.sibling = Ir),
          (br = Ir),
          (Er = cs);
      }
      if (Br === Nn.length) return bt(In, Er), zr && Bo(In, Br), ur;
      if (Er === null) {
        for (; Br < Nn.length; Br++)
          (Er = Sr(In, Nn[Br], sr)),
            Er !== null &&
              ((En = Ot(Er, En, Br)),
              br === null ? (ur = Er) : (br.sibling = Er),
              (br = Er));
        return zr && Bo(In, Br), ur;
      }
      for (Er = Tt(In, Er); Br < Nn.length; Br++)
        (cs = Nr(Er, In, Br, Nn[Br], sr)),
          cs !== null &&
            (dt &&
              cs.alternate !== null &&
              Er.delete(cs.key === null ? Br : cs.key),
            (En = Ot(cs, En, Br)),
            br === null ? (ur = cs) : (br.sibling = cs),
            (br = cs));
      return (
        dt &&
          Er.forEach(function (Eo) {
            return gt(In, Eo);
          }),
        zr && Bo(In, Br),
        ur
      );
    }
    function vs(In, En, Nn, sr) {
      var ur = Mt(Nn);
      if (typeof ur != "function") throw Error(ot(150));
      if (((Nn = ur.call(Nn)), Nn == null)) throw Error(ot(151));
      for (
        var br = (ur = null), Er = En, Br = (En = 0), cs = null, Ir = Nn.next();
        Er !== null && !Ir.done;
        Br++, Ir = Nn.next()
      ) {
        Er.index > Br ? ((cs = Er), (Er = null)) : (cs = Er.sibling);
        var Eo = pr(In, Er, Ir.value, sr);
        if (Eo === null) {
          Er === null && (Er = cs);
          break;
        }
        dt && Er && Eo.alternate === null && gt(In, Er),
          (En = Ot(Eo, En, Br)),
          br === null ? (ur = Eo) : (br.sibling = Eo),
          (br = Eo),
          (Er = cs);
      }
      if (Ir.done) return bt(In, Er), zr && Bo(In, Br), ur;
      if (Er === null) {
        for (; !Ir.done; Br++, Ir = Nn.next())
          (Ir = Sr(In, Ir.value, sr)),
            Ir !== null &&
              ((En = Ot(Ir, En, Br)),
              br === null ? (ur = Ir) : (br.sibling = Ir),
              (br = Ir));
        return zr && Bo(In, Br), ur;
      }
      for (Er = Tt(In, Er); !Ir.done; Br++, Ir = Nn.next())
        (Ir = Nr(Er, In, Br, Ir.value, sr)),
          Ir !== null &&
            (dt &&
              Ir.alternate !== null &&
              Er.delete(Ir.key === null ? Br : Ir.key),
            (En = Ot(Ir, En, Br)),
            br === null ? (ur = Ir) : (br.sibling = Ir),
            (br = Ir));
      return (
        dt &&
          Er.forEach(function (Sv) {
            return gt(In, Sv);
          }),
        zr && Bo(In, Br),
        ur
      );
    }
    function Ws(In, En, Nn, sr) {
      if (
        (typeof Nn == "object" &&
          Nn !== null &&
          Nn.type === ut &&
          Nn.key === null &&
          (Nn = Nn.props.children),
        typeof Nn == "object" && Nn !== null)
      ) {
        switch (Nn.$$typeof) {
          case lt:
            e: {
              for (var ur = Nn.key, br = En; br !== null; ) {
                if (br.key === ur) {
                  if (((ur = Nn.type), ur === ut)) {
                    if (br.tag === 7) {
                      bt(In, br.sibling),
                        (En = Lt(br, Nn.props.children)),
                        (En.return = In),
                        (In = En);
                      break e;
                    }
                  } else if (
                    br.elementType === ur ||
                    (typeof ur == "object" &&
                      ur !== null &&
                      ur.$$typeof === St &&
                      Bp(ur) === br.type)
                  ) {
                    bt(In, br.sibling),
                      (En = Lt(br, Nn.props)),
                      (En.ref = Sl(In, br, Nn)),
                      (En.return = In),
                      (In = En);
                    break e;
                  }
                  bt(In, br);
                  break;
                } else gt(In, br);
                br = br.sibling;
              }
              Nn.type === ut
                ? ((En = No(Nn.props.children, In.mode, sr, Nn.key)),
                  (En.return = In),
                  (In = En))
                : ((sr = wu(Nn.type, Nn.key, Nn.props, null, In.mode, sr)),
                  (sr.ref = Sl(In, En, Nn)),
                  (sr.return = In),
                  (In = sr));
            }
            return cn(In);
          case ct:
            e: {
              for (br = Nn.key; En !== null; ) {
                if (En.key === br)
                  if (
                    En.tag === 4 &&
                    En.stateNode.containerInfo === Nn.containerInfo &&
                    En.stateNode.implementation === Nn.implementation
                  ) {
                    bt(In, En.sibling),
                      (En = Lt(En, Nn.children || [])),
                      (En.return = In),
                      (In = En);
                    break e;
                  } else {
                    bt(In, En);
                    break;
                  }
                else gt(In, En);
                En = En.sibling;
              }
              (En = yp(Nn, In.mode, sr)), (En.return = In), (In = En);
            }
            return cn(In);
          case St:
            return (br = Nn._init), Ws(In, En, br(Nn._payload), sr);
        }
        if (Wt(Nn)) return hr(In, En, Nn, sr);
        if (Mt(Nn)) return vs(In, En, Nn, sr);
        Ql(In, Nn);
      }
      return (typeof Nn == "string" && Nn !== "") || typeof Nn == "number"
        ? ((Nn = "" + Nn),
          En !== null && En.tag === 6
            ? (bt(In, En.sibling),
              (En = Lt(En, Nn)),
              (En.return = In),
              (In = En))
            : (bt(In, En),
              (En = vp(Nn, In.mode, sr)),
              (En.return = In),
              (In = En)),
          cn(In))
        : bt(In, En);
    }
    return Ws;
  }
  var Xo = Ip(!0),
    Lp = Ip(!1),
    El = {},
    $s = mr(El),
    Al = mr(El),
    Ko = mr(El);
  function Zs(dt) {
    if (dt === El) throw Error(ot(174));
    return dt;
  }
  function Nu(dt, gt) {
    gr(Ko, gt), gr(Al, dt), gr($s, El), (dt = Gt(gt)), wr($s), gr($s, dt);
  }
  function Jo() {
    wr($s), wr(Al), wr(Ko);
  }
  function Fp(dt) {
    var gt = Zs(Ko.current),
      bt = Zs($s.current);
    (gt = Pt(bt, dt.type, gt)), bt !== gt && (gr(Al, dt), gr($s, gt));
  }
  function Uu(dt) {
    Al.current === dt && (wr($s), wr(Al));
  }
  var Wr = mr(0);
  function Zl(dt) {
    for (var gt = dt; gt !== null; ) {
      if (gt.tag === 13) {
        var bt = gt.memoizedState;
        if (
          bt !== null &&
          ((bt = bt.dehydrated), bt === null || Mr(bt) || Fr(bt))
        )
          return gt;
      } else if (gt.tag === 19 && gt.memoizedProps.revealOrder !== void 0) {
        if (gt.flags & 128) return gt;
      } else if (gt.child !== null) {
        (gt.child.return = gt), (gt = gt.child);
        continue;
      }
      if (gt === dt) break;
      for (; gt.sibling === null; ) {
        if (gt.return === null || gt.return === dt) return null;
        gt = gt.return;
      }
      (gt.sibling.return = gt.return), (gt = gt.sibling);
    }
    return null;
  }
  var Gu = [];
  function $u() {
    for (var dt = 0; dt < Gu.length; dt++) {
      var gt = Gu[dt];
      Bn
        ? (gt._workInProgressVersionPrimary = null)
        : (gt._workInProgressVersionSecondary = null);
    }
    Gu.length = 0;
  }
  var _c = at.ReactCurrentDispatcher,
    Vs = at.ReactCurrentBatchConfig,
    Yo = 0,
    Xr = null,
    ps = null,
    ls = null,
    eu = !1,
    Cl = !1,
    Ml = 0,
    Xm = 0;
  function ms() {
    throw Error(ot(321));
  }
  function Vu(dt, gt) {
    if (gt === null) return !1;
    for (var bt = 0; bt < gt.length && bt < dt.length; bt++)
      if (!Is(dt[bt], gt[bt])) return !1;
    return !0;
  }
  function zu(dt, gt, bt, Tt, Lt, Ot) {
    if (
      ((Yo = Ot),
      (Xr = gt),
      (gt.memoizedState = null),
      (gt.updateQueue = null),
      (gt.lanes = 0),
      (_c.current = dt === null || dt.memoizedState === null ? qm : Qm),
      (dt = bt(Tt, Lt)),
      Cl)
    ) {
      Ot = 0;
      do {
        if (((Cl = !1), (Ml = 0), 25 <= Ot)) throw Error(ot(301));
        (Ot += 1),
          (ls = ps = null),
          (gt.updateQueue = null),
          (_c.current = Zm),
          (dt = bt(Tt, Lt));
      } while (Cl);
    }
    if (
      ((_c.current = su),
      (gt = ps !== null && ps.next !== null),
      (Yo = 0),
      (ls = ps = Xr = null),
      (eu = !1),
      gt)
    )
      throw Error(ot(300));
    return dt;
  }
  function Hu() {
    var dt = Ml !== 0;
    return (Ml = 0), dt;
  }
  function uo() {
    var dt = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return ls === null ? (Xr.memoizedState = ls = dt) : (ls = ls.next = dt), ls;
  }
  function eo() {
    if (ps === null) {
      var dt = Xr.alternate;
      dt = dt !== null ? dt.memoizedState : null;
    } else dt = ps.next;
    var gt = ls === null ? Xr.memoizedState : ls.next;
    if (gt !== null) (ls = gt), (ps = dt);
    else {
      if (dt === null) throw Error(ot(310));
      (ps = dt),
        (dt = {
          memoizedState: ps.memoizedState,
          baseState: ps.baseState,
          baseQueue: ps.baseQueue,
          queue: ps.queue,
          next: null,
        }),
        ls === null ? (Xr.memoizedState = ls = dt) : (ls = ls.next = dt);
    }
    return ls;
  }
  function Io(dt, gt) {
    return typeof gt == "function" ? gt(dt) : gt;
  }
  function tu(dt) {
    var gt = eo(),
      bt = gt.queue;
    if (bt === null) throw Error(ot(311));
    bt.lastRenderedReducer = dt;
    var Tt = ps,
      Lt = Tt.baseQueue,
      Ot = bt.pending;
    if (Ot !== null) {
      if (Lt !== null) {
        var cn = Lt.next;
        (Lt.next = Ot.next), (Ot.next = cn);
      }
      (Tt.baseQueue = Lt = Ot), (bt.pending = null);
    }
    if (Lt !== null) {
      (Ot = Lt.next), (Tt = Tt.baseState);
      var Sn = (cn = null),
        $n = null,
        er = Ot;
      do {
        var cr = er.lane;
        if ((Yo & cr) === cr)
          $n !== null &&
            ($n = $n.next =
              {
                lane: 0,
                action: er.action,
                hasEagerState: er.hasEagerState,
                eagerState: er.eagerState,
                next: null,
              }),
            (Tt = er.hasEagerState ? er.eagerState : dt(Tt, er.action));
        else {
          var Sr = {
            lane: cr,
            action: er.action,
            hasEagerState: er.hasEagerState,
            eagerState: er.eagerState,
            next: null,
          };
          $n === null ? ((Sn = $n = Sr), (cn = Tt)) : ($n = $n.next = Sr),
            (Xr.lanes |= cr),
            (Qo |= cr);
        }
        er = er.next;
      } while (er !== null && er !== Ot);
      $n === null ? (cn = Tt) : ($n.next = Sn),
        Is(Tt, gt.memoizedState) || (ks = !0),
        (gt.memoizedState = Tt),
        (gt.baseState = cn),
        (gt.baseQueue = $n),
        (bt.lastRenderedState = Tt);
    }
    if (((dt = bt.interleaved), dt !== null)) {
      Lt = dt;
      do (Ot = Lt.lane), (Xr.lanes |= Ot), (Qo |= Ot), (Lt = Lt.next);
      while (Lt !== dt);
    } else Lt === null && (bt.lanes = 0);
    return [gt.memoizedState, bt.dispatch];
  }
  function nu(dt) {
    var gt = eo(),
      bt = gt.queue;
    if (bt === null) throw Error(ot(311));
    bt.lastRenderedReducer = dt;
    var Tt = bt.dispatch,
      Lt = bt.pending,
      Ot = gt.memoizedState;
    if (Lt !== null) {
      bt.pending = null;
      var cn = (Lt = Lt.next);
      do (Ot = dt(Ot, cn.action)), (cn = cn.next);
      while (cn !== Lt);
      Is(Ot, gt.memoizedState) || (ks = !0),
        (gt.memoizedState = Ot),
        gt.baseQueue === null && (gt.baseState = Ot),
        (bt.lastRenderedState = Ot);
    }
    return [Ot, Tt];
  }
  function Dp() {}
  function kp(dt, gt) {
    var bt = Xr,
      Tt = eo(),
      Lt = gt(),
      Ot = !Is(Tt.memoizedState, Lt);
    if (
      (Ot && ((Tt.memoizedState = Lt), (ks = !0)),
      (Tt = Tt.queue),
      Pl(Up.bind(null, bt, Tt, dt), [dt]),
      Tt.getSnapshot !== gt || Ot || (ls !== null && ls.memoizedState.tag & 1))
    ) {
      if (
        ((bt.flags |= 2048),
        Tl(9, Np.bind(null, bt, Tt, Lt, gt), void 0, null),
        es === null)
      )
        throw Error(ot(349));
      Yo & 30 || Op(bt, gt, Lt);
    }
    return Lt;
  }
  function Op(dt, gt, bt) {
    (dt.flags |= 16384),
      (dt = { getSnapshot: gt, value: bt }),
      (gt = Xr.updateQueue),
      gt === null
        ? ((gt = { lastEffect: null, stores: null }),
          (Xr.updateQueue = gt),
          (gt.stores = [dt]))
        : ((bt = gt.stores), bt === null ? (gt.stores = [dt]) : bt.push(dt));
  }
  function Np(dt, gt, bt, Tt) {
    (gt.value = bt), (gt.getSnapshot = Tt), Gp(gt) && zs(dt, 1, -1);
  }
  function Up(dt, gt, bt) {
    return bt(function () {
      Gp(gt) && zs(dt, 1, -1);
    });
  }
  function Gp(dt) {
    var gt = dt.getSnapshot;
    dt = dt.value;
    try {
      var bt = gt();
      return !Is(dt, bt);
    } catch {
      return !0;
    }
  }
  function Wu(dt) {
    var gt = uo();
    return (
      typeof dt == "function" && (dt = dt()),
      (gt.memoizedState = gt.baseState = dt),
      (dt = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Io,
        lastRenderedState: dt,
      }),
      (gt.queue = dt),
      (dt = dt.dispatch = Ym.bind(null, Xr, dt)),
      [gt.memoizedState, dt]
    );
  }
  function Tl(dt, gt, bt, Tt) {
    return (
      (dt = { tag: dt, create: gt, destroy: bt, deps: Tt, next: null }),
      (gt = Xr.updateQueue),
      gt === null
        ? ((gt = { lastEffect: null, stores: null }),
          (Xr.updateQueue = gt),
          (gt.lastEffect = dt.next = dt))
        : ((bt = gt.lastEffect),
          bt === null
            ? (gt.lastEffect = dt.next = dt)
            : ((Tt = bt.next),
              (bt.next = dt),
              (dt.next = Tt),
              (gt.lastEffect = dt))),
      dt
    );
  }
  function $p() {
    return eo().memoizedState;
  }
  function ru(dt, gt, bt, Tt) {
    var Lt = uo();
    (Xr.flags |= dt),
      (Lt.memoizedState = Tl(1 | gt, bt, void 0, Tt === void 0 ? null : Tt));
  }
  function iu(dt, gt, bt, Tt) {
    var Lt = eo();
    Tt = Tt === void 0 ? null : Tt;
    var Ot = void 0;
    if (ps !== null) {
      var cn = ps.memoizedState;
      if (((Ot = cn.destroy), Tt !== null && Vu(Tt, cn.deps))) {
        Lt.memoizedState = Tl(gt, bt, Ot, Tt);
        return;
      }
    }
    (Xr.flags |= dt), (Lt.memoizedState = Tl(1 | gt, bt, Ot, Tt));
  }
  function ju(dt, gt) {
    return ru(8390656, 8, dt, gt);
  }
  function Pl(dt, gt) {
    return iu(2048, 8, dt, gt);
  }
  function Vp(dt, gt) {
    return iu(4, 2, dt, gt);
  }
  function zp(dt, gt) {
    return iu(4, 4, dt, gt);
  }
  function Hp(dt, gt) {
    if (typeof gt == "function")
      return (
        (dt = dt()),
        gt(dt),
        function () {
          gt(null);
        }
      );
    if (gt != null)
      return (
        (dt = dt()),
        (gt.current = dt),
        function () {
          gt.current = null;
        }
      );
  }
  function Wp(dt, gt, bt) {
    return (
      (bt = bt != null ? bt.concat([dt]) : null),
      iu(4, 4, Hp.bind(null, gt, dt), bt)
    );
  }
  function Xu() {}
  function jp(dt, gt) {
    var bt = eo();
    gt = gt === void 0 ? null : gt;
    var Tt = bt.memoizedState;
    return Tt !== null && gt !== null && Vu(gt, Tt[1])
      ? Tt[0]
      : ((bt.memoizedState = [dt, gt]), dt);
  }
  function Xp(dt, gt) {
    var bt = eo();
    gt = gt === void 0 ? null : gt;
    var Tt = bt.memoizedState;
    return Tt !== null && gt !== null && Vu(gt, Tt[1])
      ? Tt[0]
      : ((dt = dt()), (bt.memoizedState = [dt, gt]), dt);
  }
  function Km(dt, gt) {
    var bt = Tr;
    (Tr = bt !== 0 && 4 > bt ? bt : 4), dt(!0);
    var Tt = Vs.transition;
    Vs.transition = {};
    try {
      dt(!1), gt();
    } finally {
      (Tr = bt), (Vs.transition = Tt);
    }
  }
  function Kp() {
    return eo().memoizedState;
  }
  function Jm(dt, gt, bt) {
    var Tt = _o(dt);
    (bt = {
      lane: Tt,
      action: bt,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Jp(dt)
        ? Yp(gt, bt)
        : (qp(dt, gt, bt),
          (bt = bs()),
          (dt = zs(dt, Tt, bt)),
          dt !== null && Qp(dt, gt, Tt));
  }
  function Ym(dt, gt, bt) {
    var Tt = _o(dt),
      Lt = {
        lane: Tt,
        action: bt,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Jp(dt)) Yp(gt, Lt);
    else {
      qp(dt, gt, Lt);
      var Ot = dt.alternate;
      if (
        dt.lanes === 0 &&
        (Ot === null || Ot.lanes === 0) &&
        ((Ot = gt.lastRenderedReducer), Ot !== null)
      )
        try {
          var cn = gt.lastRenderedState,
            Sn = Ot(cn, bt);
          if (((Lt.hasEagerState = !0), (Lt.eagerState = Sn), Is(Sn, cn)))
            return;
        } catch {
        } finally {
        }
      (bt = bs()), (dt = zs(dt, Tt, bt)), dt !== null && Qp(dt, gt, Tt);
    }
  }
  function Jp(dt) {
    var gt = dt.alternate;
    return dt === Xr || (gt !== null && gt === Xr);
  }
  function Yp(dt, gt) {
    Cl = eu = !0;
    var bt = dt.pending;
    bt === null ? (gt.next = gt) : ((gt.next = bt.next), (bt.next = gt)),
      (dt.pending = gt);
  }
  function qp(dt, gt, bt) {
    es !== null && dt.mode & 1 && !(Cr & 2)
      ? ((dt = gt.interleaved),
        dt === null
          ? ((bt.next = bt), Ls === null ? (Ls = [gt]) : Ls.push(gt))
          : ((bt.next = dt.next), (dt.next = bt)),
        (gt.interleaved = bt))
      : ((dt = gt.pending),
        dt === null ? (bt.next = bt) : ((bt.next = dt.next), (dt.next = bt)),
        (gt.pending = bt));
  }
  function Qp(dt, gt, bt) {
    if (bt & 4194240) {
      var Tt = gt.lanes;
      (Tt &= dt.pendingLanes), (bt |= Tt), (gt.lanes = bt), qs(dt, bt);
    }
  }
  var su = {
      readContext: Yr,
      useCallback: ms,
      useContext: ms,
      useEffect: ms,
      useImperativeHandle: ms,
      useInsertionEffect: ms,
      useLayoutEffect: ms,
      useMemo: ms,
      useReducer: ms,
      useRef: ms,
      useState: ms,
      useDebugValue: ms,
      useDeferredValue: ms,
      useTransition: ms,
      useMutableSource: ms,
      useSyncExternalStore: ms,
      useId: ms,
      unstable_isNewReconciler: !1,
    },
    qm = {
      readContext: Yr,
      useCallback: function (dt, gt) {
        return (uo().memoizedState = [dt, gt === void 0 ? null : gt]), dt;
      },
      useContext: Yr,
      useEffect: ju,
      useImperativeHandle: function (dt, gt, bt) {
        return (
          (bt = bt != null ? bt.concat([dt]) : null),
          ru(4194308, 4, Hp.bind(null, gt, dt), bt)
        );
      },
      useLayoutEffect: function (dt, gt) {
        return ru(4194308, 4, dt, gt);
      },
      useInsertionEffect: function (dt, gt) {
        return ru(4, 2, dt, gt);
      },
      useMemo: function (dt, gt) {
        var bt = uo();
        return (
          (gt = gt === void 0 ? null : gt),
          (dt = dt()),
          (bt.memoizedState = [dt, gt]),
          dt
        );
      },
      useReducer: function (dt, gt, bt) {
        var Tt = uo();
        return (
          (gt = bt !== void 0 ? bt(gt) : gt),
          (Tt.memoizedState = Tt.baseState = gt),
          (dt = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: dt,
            lastRenderedState: gt,
          }),
          (Tt.queue = dt),
          (dt = dt.dispatch = Jm.bind(null, Xr, dt)),
          [Tt.memoizedState, dt]
        );
      },
      useRef: function (dt) {
        var gt = uo();
        return (dt = { current: dt }), (gt.memoizedState = dt);
      },
      useState: Wu,
      useDebugValue: Xu,
      useDeferredValue: function (dt) {
        var gt = Wu(dt),
          bt = gt[0],
          Tt = gt[1];
        return (
          ju(
            function () {
              var Lt = Vs.transition;
              Vs.transition = {};
              try {
                Tt(dt);
              } finally {
                Vs.transition = Lt;
              }
            },
            [dt]
          ),
          bt
        );
      },
      useTransition: function () {
        var dt = Wu(!1),
          gt = dt[0];
        return (dt = Km.bind(null, dt[1])), (uo().memoizedState = dt), [gt, dt];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (dt, gt, bt) {
        var Tt = Xr,
          Lt = uo();
        if (zr) {
          if (bt === void 0) throw Error(ot(407));
          bt = bt();
        } else {
          if (((bt = gt()), es === null)) throw Error(ot(349));
          Yo & 30 || Op(Tt, gt, bt);
        }
        Lt.memoizedState = bt;
        var Ot = { value: bt, getSnapshot: gt };
        return (
          (Lt.queue = Ot),
          ju(Up.bind(null, Tt, Ot, dt), [dt]),
          (Tt.flags |= 2048),
          Tl(9, Np.bind(null, Tt, Ot, bt, gt), void 0, null),
          bt
        );
      },
      useId: function () {
        var dt = uo(),
          gt = es.identifierPrefix;
        if (zr) {
          var bt = co,
            Tt = lo;
          (bt = (Tt & ~(1 << (32 - Rs(Tt) - 1))).toString(32) + bt),
            (gt = ":" + gt + "R" + bt),
            (bt = Ml++),
            0 < bt && (gt += "H" + bt.toString(32)),
            (gt += ":");
        } else (bt = Xm++), (gt = ":" + gt + "r" + bt.toString(32) + ":");
        return (dt.memoizedState = gt);
      },
      unstable_isNewReconciler: !1,
    },
    Qm = {
      readContext: Yr,
      useCallback: jp,
      useContext: Yr,
      useEffect: Pl,
      useImperativeHandle: Wp,
      useInsertionEffect: Vp,
      useLayoutEffect: zp,
      useMemo: Xp,
      useReducer: tu,
      useRef: $p,
      useState: function () {
        return tu(Io);
      },
      useDebugValue: Xu,
      useDeferredValue: function (dt) {
        var gt = tu(Io),
          bt = gt[0],
          Tt = gt[1];
        return (
          Pl(
            function () {
              var Lt = Vs.transition;
              Vs.transition = {};
              try {
                Tt(dt);
              } finally {
                Vs.transition = Lt;
              }
            },
            [dt]
          ),
          bt
        );
      },
      useTransition: function () {
        var dt = tu(Io)[0],
          gt = eo().memoizedState;
        return [dt, gt];
      },
      useMutableSource: Dp,
      useSyncExternalStore: kp,
      useId: Kp,
      unstable_isNewReconciler: !1,
    },
    Zm = {
      readContext: Yr,
      useCallback: jp,
      useContext: Yr,
      useEffect: Pl,
      useImperativeHandle: Wp,
      useInsertionEffect: Vp,
      useLayoutEffect: zp,
      useMemo: Xp,
      useReducer: nu,
      useRef: $p,
      useState: function () {
        return nu(Io);
      },
      useDebugValue: Xu,
      useDeferredValue: function (dt) {
        var gt = nu(Io),
          bt = gt[0],
          Tt = gt[1];
        return (
          Pl(
            function () {
              var Lt = Vs.transition;
              Vs.transition = {};
              try {
                Tt(dt);
              } finally {
                Vs.transition = Lt;
              }
            },
            [dt]
          ),
          bt
        );
      },
      useTransition: function () {
        var dt = nu(Io)[0],
          gt = eo().memoizedState;
        return [dt, gt];
      },
      useMutableSource: Dp,
      useSyncExternalStore: kp,
      useId: Kp,
      unstable_isNewReconciler: !1,
    };
  function Ku(dt, gt) {
    try {
      var bt = "",
        Tt = gt;
      do (bt += Po(Tt)), (Tt = Tt.return);
      while (Tt);
      var Lt = bt;
    } catch (Ot) {
      Lt =
        `
Error generating stack: ` +
        Ot.message +
        `
` +
        Ot.stack;
    }
    return { value: dt, source: gt, stack: Lt };
  }
  function Ju(dt, gt) {
    try {
      console.error(gt.value);
    } catch (bt) {
      setTimeout(function () {
        throw bt;
      });
    }
  }
  var _g = typeof WeakMap == "function" ? WeakMap : Map;
  function Zp(dt, gt, bt) {
    (bt = ao(-1, bt)), (bt.tag = 3), (bt.payload = { element: null });
    var Tt = gt.value;
    return (
      (bt.callback = function () {
        Su || ((Su = !0), (up = Tt)), Ju(dt, gt);
      }),
      bt
    );
  }
  function em(dt, gt, bt) {
    (bt = ao(-1, bt)), (bt.tag = 3);
    var Tt = dt.type.getDerivedStateFromError;
    if (typeof Tt == "function") {
      var Lt = gt.value;
      (bt.payload = function () {
        return Tt(Lt);
      }),
        (bt.callback = function () {
          Ju(dt, gt);
        });
    }
    var Ot = dt.stateNode;
    return (
      Ot !== null &&
        typeof Ot.componentDidCatch == "function" &&
        (bt.callback = function () {
          Ju(dt, gt),
            typeof Tt != "function" &&
              (vo === null ? (vo = new Set([this])) : vo.add(this));
          var cn = gt.stack;
          this.componentDidCatch(gt.value, {
            componentStack: cn !== null ? cn : "",
          });
        }),
      bt
    );
  }
  function tm(dt, gt, bt) {
    var Tt = dt.pingCache;
    if (Tt === null) {
      Tt = dt.pingCache = new _g();
      var Lt = new Set();
      Tt.set(gt, Lt);
    } else
      (Lt = Tt.get(gt)), Lt === void 0 && ((Lt = new Set()), Tt.set(gt, Lt));
    Lt.has(bt) ||
      (Lt.add(bt), (dt = dv.bind(null, dt, gt, bt)), gt.then(dt, dt));
  }
  function nm(dt) {
    do {
      var gt;
      if (
        ((gt = dt.tag === 13) &&
          ((gt = dt.memoizedState),
          (gt = gt !== null ? gt.dehydrated !== null : !0)),
        gt)
      )
        return dt;
      dt = dt.return;
    } while (dt !== null);
    return null;
  }
  function rm(dt, gt, bt, Tt, Lt) {
    return dt.mode & 1
      ? ((dt.flags |= 65536), (dt.lanes = Lt), dt)
      : (dt === gt
          ? (dt.flags |= 65536)
          : ((dt.flags |= 128),
            (bt.flags |= 131072),
            (bt.flags &= -52805),
            bt.tag === 1 &&
              (bt.alternate === null
                ? (bt.tag = 17)
                : ((gt = ao(-1, 1)), (gt.tag = 2), go(bt, gt))),
            (bt.lanes |= 1)),
        dt);
  }
  function to(dt) {
    dt.flags |= 4;
  }
  function im(dt, gt) {
    if (dt !== null && dt.child === gt.child) return !0;
    if (gt.flags & 16) return !1;
    for (dt = gt.child; dt !== null; ) {
      if (dt.flags & 12854 || dt.subtreeFlags & 12854) return !1;
      dt = dt.sibling;
    }
    return !0;
  }
  var Rl, Bl, ou, au;
  if (gn)
    (Rl = function (dt, gt) {
      for (var bt = gt.child; bt !== null; ) {
        if (bt.tag === 5 || bt.tag === 6) zt(dt, bt.stateNode);
        else if (bt.tag !== 4 && bt.child !== null) {
          (bt.child.return = bt), (bt = bt.child);
          continue;
        }
        if (bt === gt) break;
        for (; bt.sibling === null; ) {
          if (bt.return === null || bt.return === gt) return;
          bt = bt.return;
        }
        (bt.sibling.return = bt.return), (bt = bt.sibling);
      }
    }),
      (Bl = function () {}),
      (ou = function (dt, gt, bt, Tt, Lt) {
        if (((dt = dt.memoizedProps), dt !== Tt)) {
          var Ot = gt.stateNode,
            cn = Zs($s.current);
          (bt = qt(Ot, bt, dt, Tt, Lt, cn)), (gt.updateQueue = bt) && to(gt);
        }
      }),
      (au = function (dt, gt, bt, Tt) {
        bt !== Tt && to(gt);
      });
  else if (jt) {
    Rl = function (dt, gt, bt, Tt) {
      for (var Lt = gt.child; Lt !== null; ) {
        if (Lt.tag === 5) {
          var Ot = Lt.stateNode;
          bt && Tt && (Ot = Ar(Ot, Lt.type, Lt.memoizedProps, Lt)), zt(dt, Ot);
        } else if (Lt.tag === 6)
          (Ot = Lt.stateNode),
            bt && Tt && (Ot = _r(Ot, Lt.memoizedProps, Lt)),
            zt(dt, Ot);
        else if (Lt.tag !== 4) {
          if (Lt.tag === 22 && Lt.memoizedState !== null)
            (Ot = Lt.child),
              Ot !== null && (Ot.return = Lt),
              Rl(dt, Lt, !0, !0);
          else if (Lt.child !== null) {
            (Lt.child.return = Lt), (Lt = Lt.child);
            continue;
          }
        }
        if (Lt === gt) break;
        for (; Lt.sibling === null; ) {
          if (Lt.return === null || Lt.return === gt) return;
          Lt = Lt.return;
        }
        (Lt.sibling.return = Lt.return), (Lt = Lt.sibling);
      }
    };
    var sm = function (dt, gt, bt, Tt) {
      for (var Lt = gt.child; Lt !== null; ) {
        if (Lt.tag === 5) {
          var Ot = Lt.stateNode;
          bt && Tt && (Ot = Ar(Ot, Lt.type, Lt.memoizedProps, Lt)), nr(dt, Ot);
        } else if (Lt.tag === 6)
          (Ot = Lt.stateNode),
            bt && Tt && (Ot = _r(Ot, Lt.memoizedProps, Lt)),
            nr(dt, Ot);
        else if (Lt.tag !== 4) {
          if (Lt.tag === 22 && Lt.memoizedState !== null)
            (Ot = Lt.child),
              Ot !== null && (Ot.return = Lt),
              sm(dt, Lt, !0, !0);
          else if (Lt.child !== null) {
            (Lt.child.return = Lt), (Lt = Lt.child);
            continue;
          }
        }
        if (Lt === gt) break;
        for (; Lt.sibling === null; ) {
          if (Lt.return === null || Lt.return === gt) return;
          Lt = Lt.return;
        }
        (Lt.sibling.return = Lt.return), (Lt = Lt.sibling);
      }
    };
    (Bl = function (dt, gt) {
      var bt = gt.stateNode;
      if (!im(dt, gt)) {
        dt = bt.containerInfo;
        var Tt = jn(dt);
        sm(Tt, gt, !1, !1), (bt.pendingChildren = Tt), to(gt), or(dt, Tt);
      }
    }),
      (ou = function (dt, gt, bt, Tt, Lt) {
        var Ot = dt.stateNode,
          cn = dt.memoizedProps;
        if ((dt = im(dt, gt)) && cn === Tt) gt.stateNode = Ot;
        else {
          var Sn = gt.stateNode,
            $n = Zs($s.current),
            er = null;
          cn !== Tt && (er = qt(Sn, bt, cn, Tt, Lt, $n)),
            dt && er === null
              ? (gt.stateNode = Ot)
              : ((Ot = tr(Ot, er, bt, cn, Tt, gt, dt, Sn)),
                Yt(Ot, bt, Tt, Lt, $n) && to(gt),
                (gt.stateNode = Ot),
                dt ? to(gt) : Rl(Ot, gt, !1, !1));
        }
      }),
      (au = function (dt, gt, bt, Tt) {
        bt !== Tt
          ? ((dt = Zs(Ko.current)),
            (bt = Zs($s.current)),
            (gt.stateNode = Jt(Tt, dt, bt, gt)),
            to(gt))
          : (gt.stateNode = dt.stateNode);
      });
  } else (Bl = function () {}), (ou = function () {}), (au = function () {});
  function Il(dt, gt) {
    if (!zr)
      switch (dt.tailMode) {
        case "hidden":
          gt = dt.tail;
          for (var bt = null; gt !== null; )
            gt.alternate !== null && (bt = gt), (gt = gt.sibling);
          bt === null ? (dt.tail = null) : (bt.sibling = null);
          break;
        case "collapsed":
          bt = dt.tail;
          for (var Tt = null; bt !== null; )
            bt.alternate !== null && (Tt = bt), (bt = bt.sibling);
          Tt === null
            ? gt || dt.tail === null
              ? (dt.tail = null)
              : (dt.tail.sibling = null)
            : (Tt.sibling = null);
      }
  }
  function gs(dt) {
    var gt = dt.alternate !== null && dt.alternate.child === dt.child,
      bt = 0,
      Tt = 0;
    if (gt)
      for (var Lt = dt.child; Lt !== null; )
        (bt |= Lt.lanes | Lt.childLanes),
          (Tt |= Lt.subtreeFlags & 14680064),
          (Tt |= Lt.flags & 14680064),
          (Lt.return = dt),
          (Lt = Lt.sibling);
    else
      for (Lt = dt.child; Lt !== null; )
        (bt |= Lt.lanes | Lt.childLanes),
          (Tt |= Lt.subtreeFlags),
          (Tt |= Lt.flags),
          (Lt.return = dt),
          (Lt = Lt.sibling);
    return (dt.subtreeFlags |= Tt), (dt.childLanes = bt), gt;
  }
  function ev(dt, gt, bt) {
    var Tt = gt.pendingProps;
    switch ((Fu(gt), gt.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return gs(gt), null;
      case 1:
        return Ur(gt.type) && ys(), gs(gt), null;
      case 3:
        return (
          (Tt = gt.stateNode),
          Jo(),
          wr(Vr),
          wr(jr),
          $u(),
          Tt.pendingContext &&
            ((Tt.context = Tt.pendingContext), (Tt.pendingContext = null)),
          (dt === null || dt.child === null) &&
            (xl(gt)
              ? to(gt)
              : dt === null ||
                (dt.memoizedState.isDehydrated && !(gt.flags & 256)) ||
                ((gt.flags |= 1024), Xs !== null && (dp(Xs), (Xs = null)))),
          Bl(dt, gt),
          gs(gt),
          null
        );
      case 5:
        Uu(gt), (bt = Zs(Ko.current));
        var Lt = gt.type;
        if (dt !== null && gt.stateNode != null)
          ou(dt, gt, Lt, Tt, bt),
            dt.ref !== gt.ref && ((gt.flags |= 512), (gt.flags |= 2097152));
        else {
          if (!Tt) {
            if (gt.stateNode === null) throw Error(ot(166));
            return gs(gt), null;
          }
          if (((dt = Zs($s.current)), xl(gt))) {
            if (!yn) throw Error(ot(175));
            (dt = ss(gt.stateNode, gt.type, gt.memoizedProps, bt, dt, gt, !_l)),
              (gt.updateQueue = dt),
              dt !== null && to(gt);
          } else {
            var Ot = Dt(Lt, Tt, bt, dt, gt);
            Rl(Ot, gt, !1, !1),
              (gt.stateNode = Ot),
              Yt(Ot, Lt, Tt, bt, dt) && to(gt);
          }
          gt.ref !== null && ((gt.flags |= 512), (gt.flags |= 2097152));
        }
        return gs(gt), null;
      case 6:
        if (dt && gt.stateNode != null) au(dt, gt, dt.memoizedProps, Tt);
        else {
          if (typeof Tt != "string" && gt.stateNode === null)
            throw Error(ot(166));
          if (((dt = Zs(Ko.current)), (bt = Zs($s.current)), xl(gt))) {
            if (!yn) throw Error(ot(176));
            if (
              ((dt = gt.stateNode),
              (Tt = gt.memoizedProps),
              (bt = sn(dt, Tt, gt, !_l)) && ((Lt = Fs), Lt !== null))
            )
              switch (((Ot = (Lt.mode & 1) !== 0), Lt.tag)) {
                case 3:
                  lr(Lt.stateNode.containerInfo, dt, Tt, Ot);
                  break;
                case 5:
                  xr(Lt.type, Lt.memoizedProps, Lt.stateNode, dt, Tt, Ot);
              }
            bt && to(gt);
          } else gt.stateNode = Jt(Tt, dt, bt, gt);
        }
        return gs(gt), null;
      case 13:
        if (
          (wr(Wr),
          (Tt = gt.memoizedState),
          zr && Ds !== null && gt.mode & 1 && !(gt.flags & 128))
        ) {
          for (dt = Ds; dt; ) dt = Pr(dt);
          return jo(), (gt.flags |= 98560), gt;
        }
        if (Tt !== null && Tt.dehydrated !== null) {
          if (((Tt = xl(gt)), dt === null)) {
            if (!Tt) throw Error(ot(318));
            if (!yn) throw Error(ot(344));
            if (
              ((dt = gt.memoizedState),
              (dt = dt !== null ? dt.dehydrated : null),
              !dt)
            )
              throw Error(ot(317));
            wn(dt, gt);
          } else
            jo(),
              !(gt.flags & 128) && (gt.memoizedState = null),
              (gt.flags |= 4);
          return gs(gt), null;
        }
        return (
          Xs !== null && (dp(Xs), (Xs = null)),
          gt.flags & 128
            ? ((gt.lanes = bt), gt)
            : ((Tt = Tt !== null),
              (bt = !1),
              dt === null ? xl(gt) : (bt = dt.memoizedState !== null),
              Tt &&
                !bt &&
                ((gt.child.flags |= 8192),
                gt.mode & 1 &&
                  (dt === null || Wr.current & 1
                    ? rs === 0 && (rs = 3)
                    : mp())),
              gt.updateQueue !== null && (gt.flags |= 4),
              gs(gt),
              null)
        );
      case 4:
        return (
          Jo(),
          Bl(dt, gt),
          dt === null && vn(gt.stateNode.containerInfo),
          gs(gt),
          null
        );
      case 10:
        return as(gt.type._context), gs(gt), null;
      case 17:
        return Ur(gt.type) && ys(), gs(gt), null;
      case 19:
        if ((wr(Wr), (Lt = gt.memoizedState), Lt === null)) return gs(gt), null;
        if (((Tt = (gt.flags & 128) !== 0), (Ot = Lt.rendering), Ot === null))
          if (Tt) Il(Lt, !1);
          else {
            if (rs !== 0 || (dt !== null && dt.flags & 128))
              for (dt = gt.child; dt !== null; ) {
                if (((Ot = Zl(dt)), Ot !== null)) {
                  for (
                    gt.flags |= 128,
                      Il(Lt, !1),
                      dt = Ot.updateQueue,
                      dt !== null && ((gt.updateQueue = dt), (gt.flags |= 4)),
                      gt.subtreeFlags = 0,
                      dt = bt,
                      Tt = gt.child;
                    Tt !== null;

                  )
                    (bt = Tt),
                      (Lt = dt),
                      (bt.flags &= 14680066),
                      (Ot = bt.alternate),
                      Ot === null
                        ? ((bt.childLanes = 0),
                          (bt.lanes = Lt),
                          (bt.child = null),
                          (bt.subtreeFlags = 0),
                          (bt.memoizedProps = null),
                          (bt.memoizedState = null),
                          (bt.updateQueue = null),
                          (bt.dependencies = null),
                          (bt.stateNode = null))
                        : ((bt.childLanes = Ot.childLanes),
                          (bt.lanes = Ot.lanes),
                          (bt.child = Ot.child),
                          (bt.subtreeFlags = 0),
                          (bt.deletions = null),
                          (bt.memoizedProps = Ot.memoizedProps),
                          (bt.memoizedState = Ot.memoizedState),
                          (bt.updateQueue = Ot.updateQueue),
                          (bt.type = Ot.type),
                          (Lt = Ot.dependencies),
                          (bt.dependencies =
                            Lt === null
                              ? null
                              : {
                                  lanes: Lt.lanes,
                                  firstContext: Lt.firstContext,
                                })),
                      (Tt = Tt.sibling);
                  return gr(Wr, (Wr.current & 1) | 2), gt.child;
                }
                dt = dt.sibling;
              }
            Lt.tail !== null &&
              Hr() > cp &&
              ((gt.flags |= 128), (Tt = !0), Il(Lt, !1), (gt.lanes = 4194304));
          }
        else {
          if (!Tt)
            if (((dt = Zl(Ot)), dt !== null)) {
              if (
                ((gt.flags |= 128),
                (Tt = !0),
                (dt = dt.updateQueue),
                dt !== null && ((gt.updateQueue = dt), (gt.flags |= 4)),
                Il(Lt, !0),
                Lt.tail === null &&
                  Lt.tailMode === "hidden" &&
                  !Ot.alternate &&
                  !zr)
              )
                return gs(gt), null;
            } else
              2 * Hr() - Lt.renderingStartTime > cp &&
                bt !== 1073741824 &&
                ((gt.flags |= 128),
                (Tt = !0),
                Il(Lt, !1),
                (gt.lanes = 4194304));
          Lt.isBackwards
            ? ((Ot.sibling = gt.child), (gt.child = Ot))
            : ((dt = Lt.last),
              dt !== null ? (dt.sibling = Ot) : (gt.child = Ot),
              (Lt.last = Ot));
        }
        return Lt.tail !== null
          ? ((gt = Lt.tail),
            (Lt.rendering = gt),
            (Lt.tail = gt.sibling),
            (Lt.renderingStartTime = Hr()),
            (gt.sibling = null),
            (dt = Wr.current),
            gr(Wr, Tt ? (dt & 1) | 2 : dt & 1),
            gt)
          : (gs(gt), null);
      case 22:
      case 23:
        return (
          pp(),
          (Tt = gt.memoizedState !== null),
          dt !== null &&
            (dt.memoizedState !== null) !== Tt &&
            (gt.flags |= 8192),
          Tt && gt.mode & 1
            ? Os & 1073741824 &&
              (gs(gt), gn && gt.subtreeFlags & 6 && (gt.flags |= 8192))
            : gs(gt),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(ot(156, gt.tag));
  }
  var tv = at.ReactCurrentOwner,
    ks = !1;
  function As(dt, gt, bt, Tt) {
    gt.child = dt === null ? Lp(gt, null, bt, Tt) : Xo(gt, dt.child, bt, Tt);
  }
  function om(dt, gt, bt, Tt, Lt) {
    bt = bt.render;
    var Ot = gt.ref;
    return (
      Jr(gt, Lt),
      (Tt = zu(dt, gt, bt, Tt, Ot, Lt)),
      (bt = Hu()),
      dt !== null && !ks
        ? ((gt.updateQueue = dt.updateQueue),
          (gt.flags &= -2053),
          (dt.lanes &= ~Lt),
          fo(dt, gt, Lt))
        : (zr && bt && Lu(gt), (gt.flags |= 1), As(dt, gt, Tt, Lt), gt.child)
    );
  }
  function am(dt, gt, bt, Tt, Lt) {
    if (dt === null) {
      var Ot = bt.type;
      return typeof Ot == "function" &&
        !gp(Ot) &&
        Ot.defaultProps === void 0 &&
        bt.compare === null &&
        bt.defaultProps === void 0
        ? ((gt.tag = 15), (gt.type = Ot), lm(dt, gt, Ot, Tt, Lt))
        : ((dt = wu(bt.type, null, Tt, gt, gt.mode, Lt)),
          (dt.ref = gt.ref),
          (dt.return = gt),
          (gt.child = dt));
    }
    if (((Ot = dt.child), !(dt.lanes & Lt))) {
      var cn = Ot.memoizedProps;
      if (
        ((bt = bt.compare),
        (bt = bt !== null ? bt : wo),
        bt(cn, Tt) && dt.ref === gt.ref)
      )
        return fo(dt, gt, Lt);
    }
    return (
      (gt.flags |= 1),
      (dt = So(Ot, Tt)),
      (dt.ref = gt.ref),
      (dt.return = gt),
      (gt.child = dt)
    );
  }
  function lm(dt, gt, bt, Tt, Lt) {
    if (dt !== null && wo(dt.memoizedProps, Tt) && dt.ref === gt.ref)
      if (((ks = !1), (dt.lanes & Lt) !== 0)) dt.flags & 131072 && (ks = !0);
      else return (gt.lanes = dt.lanes), fo(dt, gt, Lt);
    return Yu(dt, gt, bt, Tt, Lt);
  }
  function cm(dt, gt, bt) {
    var Tt = gt.pendingProps,
      Lt = Tt.children,
      Ot = dt !== null ? dt.memoizedState : null;
    if (Tt.mode === "hidden")
      if (!(gt.mode & 1))
        (gt.memoizedState = { baseLanes: 0, cachePool: null }),
          gr(qo, Os),
          (Os |= bt);
      else if (bt & 1073741824)
        (gt.memoizedState = { baseLanes: 0, cachePool: null }),
          (Tt = Ot !== null ? Ot.baseLanes : bt),
          gr(qo, Os),
          (Os |= Tt);
      else
        return (
          (dt = Ot !== null ? Ot.baseLanes | bt : bt),
          (gt.lanes = gt.childLanes = 1073741824),
          (gt.memoizedState = { baseLanes: dt, cachePool: null }),
          (gt.updateQueue = null),
          gr(qo, Os),
          (Os |= dt),
          null
        );
    else
      Ot !== null
        ? ((Tt = Ot.baseLanes | bt), (gt.memoizedState = null))
        : (Tt = bt),
        gr(qo, Os),
        (Os |= Tt);
    return As(dt, gt, Lt, bt), gt.child;
  }
  function um(dt, gt) {
    var bt = gt.ref;
    ((dt === null && bt !== null) || (dt !== null && dt.ref !== bt)) &&
      ((gt.flags |= 512), (gt.flags |= 2097152));
  }
  function Yu(dt, gt, bt, Tt, Lt) {
    var Ot = Ur(bt) ? Cs : jr.current;
    return (
      (Ot = Or(gt, Ot)),
      Jr(gt, Lt),
      (bt = zu(dt, gt, bt, Tt, Ot, Lt)),
      (Tt = Hu()),
      dt !== null && !ks
        ? ((gt.updateQueue = dt.updateQueue),
          (gt.flags &= -2053),
          (dt.lanes &= ~Lt),
          fo(dt, gt, Lt))
        : (zr && Tt && Lu(gt), (gt.flags |= 1), As(dt, gt, bt, Lt), gt.child)
    );
  }
  function fm(dt, gt, bt, Tt, Lt) {
    if (Ur(bt)) {
      var Ot = !0;
      Js(gt);
    } else Ot = !1;
    if ((Jr(gt, Lt), gt.stateNode === null))
      dt !== null &&
        ((dt.alternate = null), (gt.alternate = null), (gt.flags |= 2)),
        Cp(gt, bt, Tt),
        Iu(gt, bt, Tt, Lt),
        (Tt = !0);
    else if (dt === null) {
      var cn = gt.stateNode,
        Sn = gt.memoizedProps;
      cn.props = Sn;
      var $n = cn.context,
        er = bt.contextType;
      typeof er == "object" && er !== null
        ? (er = Yr(er))
        : ((er = Ur(bt) ? Cs : jr.current), (er = Or(gt, er)));
      var cr = bt.getDerivedStateFromProps,
        Sr =
          typeof cr == "function" ||
          typeof cn.getSnapshotBeforeUpdate == "function";
      Sr ||
        (typeof cn.UNSAFE_componentWillReceiveProps != "function" &&
          typeof cn.componentWillReceiveProps != "function") ||
        ((Sn !== Tt || $n !== er) && Mp(gt, cn, Tt, er)),
        (mo = !1);
      var pr = gt.memoizedState;
      (cn.state = pr),
        Xl(gt, Tt, cn, Lt),
        ($n = gt.memoizedState),
        Sn !== Tt || pr !== $n || Vr.current || mo
          ? (typeof cr == "function" &&
              (Bu(gt, bt, cr, Tt), ($n = gt.memoizedState)),
            (Sn = mo || bp(gt, bt, Sn, Tt, pr, $n, er))
              ? (Sr ||
                  (typeof cn.UNSAFE_componentWillMount != "function" &&
                    typeof cn.componentWillMount != "function") ||
                  (typeof cn.componentWillMount == "function" &&
                    cn.componentWillMount(),
                  typeof cn.UNSAFE_componentWillMount == "function" &&
                    cn.UNSAFE_componentWillMount()),
                typeof cn.componentDidMount == "function" &&
                  (gt.flags |= 4194308))
              : (typeof cn.componentDidMount == "function" &&
                  (gt.flags |= 4194308),
                (gt.memoizedProps = Tt),
                (gt.memoizedState = $n)),
            (cn.props = Tt),
            (cn.state = $n),
            (cn.context = er),
            (Tt = Sn))
          : (typeof cn.componentDidMount == "function" && (gt.flags |= 4194308),
            (Tt = !1));
    } else {
      (cn = gt.stateNode),
        xp(dt, gt),
        (Sn = gt.memoizedProps),
        (er = gt.type === gt.elementType ? Sn : Ss(gt.type, Sn)),
        (cn.props = er),
        (Sr = gt.pendingProps),
        (pr = cn.context),
        ($n = bt.contextType),
        typeof $n == "object" && $n !== null
          ? ($n = Yr($n))
          : (($n = Ur(bt) ? Cs : jr.current), ($n = Or(gt, $n)));
      var Nr = bt.getDerivedStateFromProps;
      (cr =
        typeof Nr == "function" ||
        typeof cn.getSnapshotBeforeUpdate == "function") ||
        (typeof cn.UNSAFE_componentWillReceiveProps != "function" &&
          typeof cn.componentWillReceiveProps != "function") ||
        ((Sn !== Sr || pr !== $n) && Mp(gt, cn, Tt, $n)),
        (mo = !1),
        (pr = gt.memoizedState),
        (cn.state = pr),
        Xl(gt, Tt, cn, Lt);
      var hr = gt.memoizedState;
      Sn !== Sr || pr !== hr || Vr.current || mo
        ? (typeof Nr == "function" &&
            (Bu(gt, bt, Nr, Tt), (hr = gt.memoizedState)),
          (er = mo || bp(gt, bt, er, Tt, pr, hr, $n) || !1)
            ? (cr ||
                (typeof cn.UNSAFE_componentWillUpdate != "function" &&
                  typeof cn.componentWillUpdate != "function") ||
                (typeof cn.componentWillUpdate == "function" &&
                  cn.componentWillUpdate(Tt, hr, $n),
                typeof cn.UNSAFE_componentWillUpdate == "function" &&
                  cn.UNSAFE_componentWillUpdate(Tt, hr, $n)),
              typeof cn.componentDidUpdate == "function" && (gt.flags |= 4),
              typeof cn.getSnapshotBeforeUpdate == "function" &&
                (gt.flags |= 1024))
            : (typeof cn.componentDidUpdate != "function" ||
                (Sn === dt.memoizedProps && pr === dt.memoizedState) ||
                (gt.flags |= 4),
              typeof cn.getSnapshotBeforeUpdate != "function" ||
                (Sn === dt.memoizedProps && pr === dt.memoizedState) ||
                (gt.flags |= 1024),
              (gt.memoizedProps = Tt),
              (gt.memoizedState = hr)),
          (cn.props = Tt),
          (cn.state = hr),
          (cn.context = $n),
          (Tt = er))
        : (typeof cn.componentDidUpdate != "function" ||
            (Sn === dt.memoizedProps && pr === dt.memoizedState) ||
            (gt.flags |= 4),
          typeof cn.getSnapshotBeforeUpdate != "function" ||
            (Sn === dt.memoizedProps && pr === dt.memoizedState) ||
            (gt.flags |= 1024),
          (Tt = !1));
    }
    return qu(dt, gt, bt, Tt, Ot, Lt);
  }
  function qu(dt, gt, bt, Tt, Lt, Ot) {
    um(dt, gt);
    var cn = (gt.flags & 128) !== 0;
    if (!Tt && !cn) return Lt && ds(gt, bt, !1), fo(dt, gt, Ot);
    (Tt = gt.stateNode), (tv.current = gt);
    var Sn =
      cn && typeof bt.getDerivedStateFromError != "function"
        ? null
        : Tt.render();
    return (
      (gt.flags |= 1),
      dt !== null && cn
        ? ((gt.child = Xo(gt, dt.child, null, Ot)),
          (gt.child = Xo(gt, null, Sn, Ot)))
        : As(dt, gt, Sn, Ot),
      (gt.memoizedState = Tt.state),
      Lt && ds(gt, bt, !0),
      gt.child
    );
  }
  function hm(dt) {
    var gt = dt.stateNode;
    gt.pendingContext
      ? _i(dt, gt.pendingContext, gt.pendingContext !== gt.context)
      : gt.context && _i(dt, gt.context, !1),
      Nu(dt, gt.containerInfo);
  }
  function dm(dt, gt, bt, Tt, Lt) {
    return jo(), Ou(Lt), (gt.flags |= 256), As(dt, gt, bt, Tt), gt.child;
  }
  var lu = { dehydrated: null, treeContext: null, retryLane: 0 };
  function cu(dt) {
    return { baseLanes: dt, cachePool: null };
  }
  function pm(dt, gt, bt) {
    var Tt = gt.pendingProps,
      Lt = Wr.current,
      Ot = !1,
      cn = (gt.flags & 128) !== 0,
      Sn;
    if (
      ((Sn = cn) ||
        (Sn = dt !== null && dt.memoizedState === null ? !1 : (Lt & 2) !== 0),
      Sn
        ? ((Ot = !0), (gt.flags &= -129))
        : (dt === null || dt.memoizedState !== null) && (Lt |= 1),
      gr(Wr, Lt & 1),
      dt === null)
    )
      return (
        ku(gt),
        (dt = gt.memoizedState),
        dt !== null && ((dt = dt.dehydrated), dt !== null)
          ? (gt.mode & 1
              ? Fr(dt)
                ? (gt.lanes = 8)
                : (gt.lanes = 1073741824)
              : (gt.lanes = 1),
            null)
          : ((Lt = Tt.children),
            (dt = Tt.fallback),
            Ot
              ? ((Tt = gt.mode),
                (Ot = gt.child),
                (Lt = { mode: "hidden", children: Lt }),
                !(Tt & 1) && Ot !== null
                  ? ((Ot.childLanes = 0), (Ot.pendingProps = Lt))
                  : (Ot = Pu(Lt, Tt, 0, null)),
                (dt = No(dt, Tt, bt, null)),
                (Ot.return = gt),
                (dt.return = gt),
                (Ot.sibling = dt),
                (gt.child = Ot),
                (gt.child.memoizedState = cu(bt)),
                (gt.memoizedState = lu),
                dt)
              : Qu(gt, Lt))
      );
    if (((Lt = dt.memoizedState), Lt !== null)) {
      if (((Sn = Lt.dehydrated), Sn !== null)) {
        if (cn)
          return gt.flags & 256
            ? ((gt.flags &= -257), uu(dt, gt, bt, Error(ot(422))))
            : gt.memoizedState !== null
            ? ((gt.child = dt.child), (gt.flags |= 128), null)
            : ((Ot = Tt.fallback),
              (Lt = gt.mode),
              (Tt = Pu(
                { mode: "visible", children: Tt.children },
                Lt,
                0,
                null
              )),
              (Ot = No(Ot, Lt, bt, null)),
              (Ot.flags |= 2),
              (Tt.return = gt),
              (Ot.return = gt),
              (Tt.sibling = Ot),
              (gt.child = Tt),
              gt.mode & 1 && Xo(gt, dt.child, null, bt),
              (gt.child.memoizedState = cu(bt)),
              (gt.memoizedState = lu),
              Ot);
        if (!(gt.mode & 1)) gt = uu(dt, gt, bt, null);
        else if (Fr(Sn)) gt = uu(dt, gt, bt, Error(ot(419)));
        else if (((Tt = (bt & dt.childLanes) !== 0), ks || Tt)) {
          if (((Tt = es), Tt !== null)) {
            switch (bt & -bt) {
              case 4:
                Ot = 2;
                break;
              case 16:
                Ot = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                Ot = 32;
                break;
              case 536870912:
                Ot = 268435456;
                break;
              default:
                Ot = 0;
            }
            (Tt = Ot & (Tt.suspendedLanes | bt) ? 0 : Ot),
              Tt !== 0 &&
                Tt !== Lt.retryLane &&
                ((Lt.retryLane = Tt), zs(dt, Tt, -1));
          }
          mp(), (gt = uu(dt, gt, bt, Error(ot(421))));
        } else
          Mr(Sn)
            ? ((gt.flags |= 128),
              (gt.child = dt.child),
              (gt = pv.bind(null, dt)),
              Dr(Sn, gt),
              (gt = null))
            : ((bt = Lt.treeContext),
              yn &&
                ((Ds = fs(Sn)),
                (Fs = gt),
                (zr = !0),
                (Xs = null),
                (_l = !1),
                bt !== null &&
                  ((Us[Gs++] = lo),
                  (Us[Gs++] = co),
                  (Us[Gs++] = Ro),
                  (lo = bt.id),
                  (co = bt.overflow),
                  (Ro = gt))),
              (gt = Qu(gt, gt.pendingProps.children)),
              (gt.flags |= 4096));
        return gt;
      }
      return Ot
        ? ((Tt = gm(dt, gt, Tt.children, Tt.fallback, bt)),
          (Ot = gt.child),
          (Lt = dt.child.memoizedState),
          (Ot.memoizedState =
            Lt === null
              ? cu(bt)
              : { baseLanes: Lt.baseLanes | bt, cachePool: null }),
          (Ot.childLanes = dt.childLanes & ~bt),
          (gt.memoizedState = lu),
          Tt)
        : ((bt = mm(dt, gt, Tt.children, bt)), (gt.memoizedState = null), bt);
    }
    return Ot
      ? ((Tt = gm(dt, gt, Tt.children, Tt.fallback, bt)),
        (Ot = gt.child),
        (Lt = dt.child.memoizedState),
        (Ot.memoizedState =
          Lt === null
            ? cu(bt)
            : { baseLanes: Lt.baseLanes | bt, cachePool: null }),
        (Ot.childLanes = dt.childLanes & ~bt),
        (gt.memoizedState = lu),
        Tt)
      : ((bt = mm(dt, gt, Tt.children, bt)), (gt.memoizedState = null), bt);
  }
  function Qu(dt, gt) {
    return (
      (gt = Pu({ mode: "visible", children: gt }, dt.mode, 0, null)),
      (gt.return = dt),
      (dt.child = gt)
    );
  }
  function mm(dt, gt, bt, Tt) {
    var Lt = dt.child;
    return (
      (dt = Lt.sibling),
      (bt = So(Lt, { mode: "visible", children: bt })),
      !(gt.mode & 1) && (bt.lanes = Tt),
      (bt.return = gt),
      (bt.sibling = null),
      dt !== null &&
        ((Tt = gt.deletions),
        Tt === null ? ((gt.deletions = [dt]), (gt.flags |= 16)) : Tt.push(dt)),
      (gt.child = bt)
    );
  }
  function gm(dt, gt, bt, Tt, Lt) {
    var Ot = gt.mode;
    dt = dt.child;
    var cn = dt.sibling,
      Sn = { mode: "hidden", children: bt };
    return (
      !(Ot & 1) && gt.child !== dt
        ? ((bt = gt.child),
          (bt.childLanes = 0),
          (bt.pendingProps = Sn),
          (gt.deletions = null))
        : ((bt = So(dt, Sn)), (bt.subtreeFlags = dt.subtreeFlags & 14680064)),
      cn !== null
        ? (Tt = So(cn, Tt))
        : ((Tt = No(Tt, Ot, Lt, null)), (Tt.flags |= 2)),
      (Tt.return = gt),
      (bt.return = gt),
      (bt.sibling = Tt),
      (gt.child = bt),
      Tt
    );
  }
  function uu(dt, gt, bt, Tt) {
    return (
      Tt !== null && Ou(Tt),
      Xo(gt, dt.child, null, bt),
      (dt = Qu(gt, gt.pendingProps.children)),
      (dt.flags |= 2),
      (gt.memoizedState = null),
      dt
    );
  }
  function vm(dt, gt, bt) {
    dt.lanes |= gt;
    var Tt = dt.alternate;
    Tt !== null && (Tt.lanes |= gt), Es(dt.return, gt, bt);
  }
  function Zu(dt, gt, bt, Tt, Lt) {
    var Ot = dt.memoizedState;
    Ot === null
      ? (dt.memoizedState = {
          isBackwards: gt,
          rendering: null,
          renderingStartTime: 0,
          last: Tt,
          tail: bt,
          tailMode: Lt,
        })
      : ((Ot.isBackwards = gt),
        (Ot.rendering = null),
        (Ot.renderingStartTime = 0),
        (Ot.last = Tt),
        (Ot.tail = bt),
        (Ot.tailMode = Lt));
  }
  function ym(dt, gt, bt) {
    var Tt = gt.pendingProps,
      Lt = Tt.revealOrder,
      Ot = Tt.tail;
    if ((As(dt, gt, Tt.children, bt), (Tt = Wr.current), Tt & 2))
      (Tt = (Tt & 1) | 2), (gt.flags |= 128);
    else {
      if (dt !== null && dt.flags & 128)
        e: for (dt = gt.child; dt !== null; ) {
          if (dt.tag === 13) dt.memoizedState !== null && vm(dt, bt, gt);
          else if (dt.tag === 19) vm(dt, bt, gt);
          else if (dt.child !== null) {
            (dt.child.return = dt), (dt = dt.child);
            continue;
          }
          if (dt === gt) break e;
          for (; dt.sibling === null; ) {
            if (dt.return === null || dt.return === gt) break e;
            dt = dt.return;
          }
          (dt.sibling.return = dt.return), (dt = dt.sibling);
        }
      Tt &= 1;
    }
    if ((gr(Wr, Tt), !(gt.mode & 1))) gt.memoizedState = null;
    else
      switch (Lt) {
        case "forwards":
          for (bt = gt.child, Lt = null; bt !== null; )
            (dt = bt.alternate),
              dt !== null && Zl(dt) === null && (Lt = bt),
              (bt = bt.sibling);
          (bt = Lt),
            bt === null
              ? ((Lt = gt.child), (gt.child = null))
              : ((Lt = bt.sibling), (bt.sibling = null)),
            Zu(gt, !1, Lt, bt, Ot);
          break;
        case "backwards":
          for (bt = null, Lt = gt.child, gt.child = null; Lt !== null; ) {
            if (((dt = Lt.alternate), dt !== null && Zl(dt) === null)) {
              gt.child = Lt;
              break;
            }
            (dt = Lt.sibling), (Lt.sibling = bt), (bt = Lt), (Lt = dt);
          }
          Zu(gt, !0, bt, null, Ot);
          break;
        case "together":
          Zu(gt, !1, null, null, void 0);
          break;
        default:
          gt.memoizedState = null;
      }
    return gt.child;
  }
  function fo(dt, gt, bt) {
    if (
      (dt !== null && (gt.dependencies = dt.dependencies),
      (Qo |= gt.lanes),
      !(bt & gt.childLanes))
    )
      return null;
    if (dt !== null && gt.child !== dt.child) throw Error(ot(153));
    if (gt.child !== null) {
      for (
        dt = gt.child,
          bt = So(dt, dt.pendingProps),
          gt.child = bt,
          bt.return = gt;
        dt.sibling !== null;

      )
        (dt = dt.sibling),
          (bt = bt.sibling = So(dt, dt.pendingProps)),
          (bt.return = gt);
      bt.sibling = null;
    }
    return gt.child;
  }
  function nv(dt, gt, bt) {
    switch (gt.tag) {
      case 3:
        hm(gt), jo();
        break;
      case 5:
        Fp(gt);
        break;
      case 1:
        Ur(gt.type) && Js(gt);
        break;
      case 4:
        Nu(gt, gt.stateNode.containerInfo);
        break;
      case 10:
        Hl(gt, gt.type._context, gt.memoizedProps.value);
        break;
      case 13:
        var Tt = gt.memoizedState;
        if (Tt !== null)
          return Tt.dehydrated !== null
            ? (gr(Wr, Wr.current & 1), (gt.flags |= 128), null)
            : bt & gt.child.childLanes
            ? pm(dt, gt, bt)
            : (gr(Wr, Wr.current & 1),
              (dt = fo(dt, gt, bt)),
              dt !== null ? dt.sibling : null);
        gr(Wr, Wr.current & 1);
        break;
      case 19:
        if (((Tt = (bt & gt.childLanes) !== 0), dt.flags & 128)) {
          if (Tt) return ym(dt, gt, bt);
          gt.flags |= 128;
        }
        var Lt = gt.memoizedState;
        if (
          (Lt !== null &&
            ((Lt.rendering = null), (Lt.tail = null), (Lt.lastEffect = null)),
          gr(Wr, Wr.current),
          Tt)
        )
          break;
        return null;
      case 22:
      case 23:
        return (gt.lanes = 0), cm(dt, gt, bt);
    }
    return fo(dt, gt, bt);
  }
  function rv(dt, gt) {
    switch ((Fu(gt), gt.tag)) {
      case 1:
        return (
          Ur(gt.type) && ys(),
          (dt = gt.flags),
          dt & 65536 ? ((gt.flags = (dt & -65537) | 128), gt) : null
        );
      case 3:
        return (
          Jo(),
          wr(Vr),
          wr(jr),
          $u(),
          (dt = gt.flags),
          dt & 65536 && !(dt & 128)
            ? ((gt.flags = (dt & -65537) | 128), gt)
            : null
        );
      case 5:
        return Uu(gt), null;
      case 13:
        if (
          (wr(Wr),
          (dt = gt.memoizedState),
          dt !== null && dt.dehydrated !== null)
        ) {
          if (gt.alternate === null) throw Error(ot(340));
          jo();
        }
        return (
          (dt = gt.flags),
          dt & 65536 ? ((gt.flags = (dt & -65537) | 128), gt) : null
        );
      case 19:
        return wr(Wr), null;
      case 4:
        return Jo(), null;
      case 10:
        return as(gt.type._context), null;
      case 22:
      case 23:
        return pp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var fu = !1,
    Lo = !1,
    iv = typeof WeakSet == "function" ? WeakSet : Set,
    rr = null;
  function hu(dt, gt) {
    var bt = dt.ref;
    if (bt !== null)
      if (typeof bt == "function")
        try {
          bt(null);
        } catch (Tt) {
          Ps(dt, gt, Tt);
        }
      else bt.current = null;
  }
  function _f(dt, gt, bt) {
    try {
      bt();
    } catch (Tt) {
      Ps(dt, gt, Tt);
    }
  }
  var _m = !1;
  function sv(dt, gt) {
    for (Rt(dt.containerInfo), rr = gt; rr !== null; )
      if (
        ((dt = rr),
        (gt = dt.child),
        (dt.subtreeFlags & 1028) !== 0 && gt !== null)
      )
        (gt.return = dt), (rr = gt);
      else
        for (; rr !== null; ) {
          dt = rr;
          try {
            var bt = dt.alternate;
            if (dt.flags & 1024)
              switch (dt.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (bt !== null) {
                    var Tt = bt.memoizedProps,
                      Lt = bt.memoizedState,
                      Ot = dt.stateNode,
                      cn = Ot.getSnapshotBeforeUpdate(
                        dt.elementType === dt.type ? Tt : Ss(dt.type, Tt),
                        Lt
                      );
                    Ot.__reactInternalSnapshotBeforeUpdate = cn;
                  }
                  break;
                case 3:
                  gn && Qn(dt.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(ot(163));
              }
          } catch (Sn) {
            Ps(dt, dt.return, Sn);
          }
          if (((gt = dt.sibling), gt !== null)) {
            (gt.return = dt.return), (rr = gt);
            break;
          }
          rr = dt.return;
        }
    return (bt = _m), (_m = !1), bt;
  }
  function Fo(dt, gt, bt) {
    var Tt = gt.updateQueue;
    if (((Tt = Tt !== null ? Tt.lastEffect : null), Tt !== null)) {
      var Lt = (Tt = Tt.next);
      do {
        if ((Lt.tag & dt) === dt) {
          var Ot = Lt.destroy;
          (Lt.destroy = void 0), Ot !== void 0 && _f(gt, bt, Ot);
        }
        Lt = Lt.next;
      } while (Lt !== Tt);
    }
  }
  function Ll(dt, gt) {
    if (
      ((gt = gt.updateQueue),
      (gt = gt !== null ? gt.lastEffect : null),
      gt !== null)
    ) {
      var bt = (gt = gt.next);
      do {
        if ((bt.tag & dt) === dt) {
          var Tt = bt.create;
          bt.destroy = Tt();
        }
        bt = bt.next;
      } while (bt !== gt);
    }
  }
  function _h(dt) {
    var gt = dt.ref;
    if (gt !== null) {
      var bt = dt.stateNode;
      switch (dt.tag) {
        case 5:
          dt = kt(bt);
          break;
        default:
          dt = bt;
      }
      typeof gt == "function" ? gt(dt) : (gt.current = dt);
    }
  }
  function xm(dt, gt, bt) {
    if (Bs && typeof Bs.onCommitFiberUnmount == "function")
      try {
        Bs.onCommitFiberUnmount(Mo, gt);
      } catch {}
    switch (gt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((dt = gt.updateQueue),
          dt !== null && ((dt = dt.lastEffect), dt !== null))
        ) {
          var Tt = (dt = dt.next);
          do {
            var Lt = Tt,
              Ot = Lt.destroy;
            (Lt = Lt.tag),
              Ot !== void 0 && (Lt & 2 || Lt & 4) && _f(gt, bt, Ot),
              (Tt = Tt.next);
          } while (Tt !== dt);
        }
        break;
      case 1:
        if (
          (hu(gt, bt),
          (dt = gt.stateNode),
          typeof dt.componentWillUnmount == "function")
        )
          try {
            (dt.props = gt.memoizedProps),
              (dt.state = gt.memoizedState),
              dt.componentWillUnmount();
          } catch (cn) {
            Ps(gt, bt, cn);
          }
        break;
      case 5:
        hu(gt, bt);
        break;
      case 4:
        gn
          ? Mm(dt, gt, bt)
          : jt &&
            jt &&
            ((gt = gt.stateNode.containerInfo), (bt = jn(gt)), vr(gt, bt));
    }
  }
  function Sm(dt, gt, bt) {
    for (var Tt = gt; ; )
      if ((xm(dt, Tt, bt), Tt.child === null || (gn && Tt.tag === 4))) {
        if (Tt === gt) break;
        for (; Tt.sibling === null; ) {
          if (Tt.return === null || Tt.return === gt) return;
          Tt = Tt.return;
        }
        (Tt.sibling.return = Tt.return), (Tt = Tt.sibling);
      } else (Tt.child.return = Tt), (Tt = Tt.child);
  }
  function Em(dt) {
    var gt = dt.alternate;
    gt !== null && ((dt.alternate = null), Em(gt)),
      (dt.child = null),
      (dt.deletions = null),
      (dt.sibling = null),
      dt.tag === 5 && ((gt = dt.stateNode), gt !== null && Fn(gt)),
      (dt.stateNode = null),
      (dt.return = null),
      (dt.dependencies = null),
      (dt.memoizedProps = null),
      (dt.memoizedState = null),
      (dt.pendingProps = null),
      (dt.stateNode = null),
      (dt.updateQueue = null);
  }
  function Am(dt) {
    return dt.tag === 5 || dt.tag === 3 || dt.tag === 4;
  }
  function bm(dt) {
    e: for (;;) {
      for (; dt.sibling === null; ) {
        if (dt.return === null || Am(dt.return)) return null;
        dt = dt.return;
      }
      for (
        dt.sibling.return = dt.return, dt = dt.sibling;
        dt.tag !== 5 && dt.tag !== 6 && dt.tag !== 18;

      ) {
        if (dt.flags & 2 || dt.child === null || dt.tag === 4) continue e;
        (dt.child.return = dt), (dt = dt.child);
      }
      if (!(dt.flags & 2)) return dt.stateNode;
    }
  }
  function Cm(dt) {
    if (gn) {
      e: {
        for (var gt = dt.return; gt !== null; ) {
          if (Am(gt)) break e;
          gt = gt.return;
        }
        throw Error(ot(160));
      }
      var bt = gt;
      switch (bt.tag) {
        case 5:
          (gt = bt.stateNode),
            bt.flags & 32 && (Pn(gt), (bt.flags &= -33)),
            (bt = bm(dt)),
            ep(dt, bt, gt);
          break;
        case 3:
        case 4:
          (gt = bt.stateNode.containerInfo), (bt = bm(dt)), _d(dt, bt, gt);
          break;
        default:
          throw Error(ot(161));
      }
    }
  }
  function _d(dt, gt, bt) {
    var Tt = dt.tag;
    if (Tt === 5 || Tt === 6)
      (dt = dt.stateNode), gt ? On(bt, dt, gt) : kn(bt, dt);
    else if (Tt !== 4 && ((dt = dt.child), dt !== null))
      for (_d(dt, gt, bt), dt = dt.sibling; dt !== null; )
        _d(dt, gt, bt), (dt = dt.sibling);
  }
  function ep(dt, gt, bt) {
    var Tt = dt.tag;
    if (Tt === 5 || Tt === 6)
      (dt = dt.stateNode), gt ? ir(bt, dt, gt) : Mn(bt, dt);
    else if (Tt !== 4 && ((dt = dt.child), dt !== null))
      for (ep(dt, gt, bt), dt = dt.sibling; dt !== null; )
        ep(dt, gt, bt), (dt = dt.sibling);
  }
  function Mm(dt, gt, bt) {
    for (var Tt = gt, Lt = !1, Ot, cn; ; ) {
      if (!Lt) {
        Lt = Tt.return;
        e: for (;;) {
          if (Lt === null) throw Error(ot(160));
          switch (((Ot = Lt.stateNode), Lt.tag)) {
            case 5:
              cn = !1;
              break e;
            case 3:
              (Ot = Ot.containerInfo), (cn = !0);
              break e;
            case 4:
              (Ot = Ot.containerInfo), (cn = !0);
              break e;
          }
          Lt = Lt.return;
        }
        Lt = !0;
      }
      if (Tt.tag === 5 || Tt.tag === 6)
        Sm(dt, Tt, bt), cn ? dn(Ot, Tt.stateNode) : qn(Ot, Tt.stateNode);
      else if (Tt.tag === 18) cn ? fr(Ot, Tt.stateNode) : ar(Ot, Tt.stateNode);
      else if (Tt.tag === 4) {
        if (Tt.child !== null) {
          (Ot = Tt.stateNode.containerInfo),
            (cn = !0),
            (Tt.child.return = Tt),
            (Tt = Tt.child);
          continue;
        }
      } else if ((xm(dt, Tt, bt), Tt.child !== null)) {
        (Tt.child.return = Tt), (Tt = Tt.child);
        continue;
      }
      if (Tt === gt) break;
      for (; Tt.sibling === null; ) {
        if (Tt.return === null || Tt.return === gt) return;
        (Tt = Tt.return), Tt.tag === 4 && (Lt = !1);
      }
      (Tt.sibling.return = Tt.return), (Tt = Tt.sibling);
    }
  }
  function tp(dt, gt) {
    if (gn) {
      switch (gt.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Fo(3, gt, gt.return), Ll(3, gt), Fo(5, gt, gt.return);
          return;
        case 1:
          return;
        case 5:
          var bt = gt.stateNode;
          if (bt != null) {
            var Tt = gt.memoizedProps;
            dt = dt !== null ? dt.memoizedProps : Tt;
            var Lt = gt.type,
              Ot = gt.updateQueue;
            (gt.updateQueue = null), Ot !== null && Yn(bt, Ot, Lt, dt, Tt, gt);
          }
          return;
        case 6:
          if (gt.stateNode === null) throw Error(ot(162));
          (bt = gt.memoizedProps),
            Vn(gt.stateNode, dt !== null ? dt.memoizedProps : bt, bt);
          return;
        case 3:
          yn &&
            dt !== null &&
            dt.memoizedState.isDehydrated &&
            Rn(gt.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          du(gt);
          return;
        case 19:
          du(gt);
          return;
        case 17:
          return;
      }
      throw Error(ot(163));
    }
    switch (gt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Fo(3, gt, gt.return), Ll(3, gt), Fo(5, gt, gt.return);
        return;
      case 12:
        return;
      case 13:
        du(gt);
        return;
      case 19:
        du(gt);
        return;
      case 3:
        yn &&
          dt !== null &&
          dt.memoizedState.isDehydrated &&
          Rn(gt.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (jt) {
      switch (gt.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (gt = gt.stateNode), vr(gt.containerInfo, gt.pendingChildren);
          break e;
      }
      throw Error(ot(163));
    }
  }
  function du(dt) {
    var gt = dt.updateQueue;
    if (gt !== null) {
      dt.updateQueue = null;
      var bt = dt.stateNode;
      bt === null && (bt = dt.stateNode = new iv()),
        gt.forEach(function (Tt) {
          var Lt = mv.bind(null, dt, Tt);
          bt.has(Tt) || (bt.add(Tt), Tt.then(Lt, Lt));
        });
    }
  }
  function ov(dt, gt) {
    for (rr = gt; rr !== null; ) {
      gt = rr;
      var bt = gt.deletions;
      if (bt !== null)
        for (var Tt = 0; Tt < bt.length; Tt++) {
          var Lt = bt[Tt];
          try {
            var Ot = dt;
            gn ? Mm(Ot, Lt, gt) : Sm(Ot, Lt, gt);
            var cn = Lt.alternate;
            cn !== null && (cn.return = null), (Lt.return = null);
          } catch (ur) {
            Ps(Lt, gt, ur);
          }
        }
      if (((bt = gt.child), gt.subtreeFlags & 12854 && bt !== null))
        (bt.return = gt), (rr = bt);
      else
        for (; rr !== null; ) {
          gt = rr;
          try {
            var Sn = gt.flags;
            if ((Sn & 32 && gn && Pn(gt.stateNode), Sn & 512)) {
              var $n = gt.alternate;
              if ($n !== null) {
                var er = $n.ref;
                er !== null &&
                  (typeof er == "function" ? er(null) : (er.current = null));
              }
            }
            if (Sn & 8192)
              switch (gt.tag) {
                case 13:
                  if (gt.memoizedState !== null) {
                    var cr = gt.alternate;
                    (cr === null || cr.memoizedState === null) && (lp = Hr());
                  }
                  break;
                case 22:
                  var Sr = gt.memoizedState !== null,
                    pr = gt.alternate,
                    Nr = pr !== null && pr.memoizedState !== null;
                  if (((bt = gt), gn)) {
                    e: if (((Tt = bt), (Lt = Sr), (Ot = null), gn))
                      for (var hr = Tt; ; ) {
                        if (hr.tag === 5) {
                          if (Ot === null) {
                            Ot = hr;
                            var vs = hr.stateNode;
                            Lt ? Hn(vs) : zn(hr.stateNode, hr.memoizedProps);
                          }
                        } else if (hr.tag === 6) {
                          if (Ot === null) {
                            var Ws = hr.stateNode;
                            Lt ? Qt(Ws) : Xn(Ws, hr.memoizedProps);
                          }
                        } else if (
                          ((hr.tag !== 22 && hr.tag !== 23) ||
                            hr.memoizedState === null ||
                            hr === Tt) &&
                          hr.child !== null
                        ) {
                          (hr.child.return = hr), (hr = hr.child);
                          continue;
                        }
                        if (hr === Tt) break;
                        for (; hr.sibling === null; ) {
                          if (hr.return === null || hr.return === Tt) break e;
                          Ot === hr && (Ot = null), (hr = hr.return);
                        }
                        Ot === hr && (Ot = null),
                          (hr.sibling.return = hr.return),
                          (hr = hr.sibling);
                      }
                  }
                  if (Sr && !Nr && bt.mode & 1) {
                    rr = bt;
                    for (var In = bt.child; In !== null; ) {
                      for (bt = rr = In; rr !== null; ) {
                        Tt = rr;
                        var En = Tt.child;
                        switch (Tt.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Fo(4, Tt, Tt.return);
                            break;
                          case 1:
                            hu(Tt, Tt.return);
                            var Nn = Tt.stateNode;
                            if (typeof Nn.componentWillUnmount == "function") {
                              var sr = Tt.return;
                              try {
                                (Nn.props = Tt.memoizedProps),
                                  (Nn.state = Tt.memoizedState),
                                  Nn.componentWillUnmount();
                              } catch (ur) {
                                Ps(Tt, sr, ur);
                              }
                            }
                            break;
                          case 5:
                            hu(Tt, Tt.return);
                            break;
                          case 22:
                            if (Tt.memoizedState !== null) {
                              Pm(bt);
                              continue;
                            }
                        }
                        En !== null ? ((En.return = Tt), (rr = En)) : Pm(bt);
                      }
                      In = In.sibling;
                    }
                  }
              }
            switch (Sn & 4102) {
              case 2:
                Cm(gt), (gt.flags &= -3);
                break;
              case 6:
                Cm(gt), (gt.flags &= -3), tp(gt.alternate, gt);
                break;
              case 4096:
                gt.flags &= -4097;
                break;
              case 4100:
                (gt.flags &= -4097), tp(gt.alternate, gt);
                break;
              case 4:
                tp(gt.alternate, gt);
            }
          } catch (ur) {
            Ps(gt, gt.return, ur);
          }
          if (((bt = gt.sibling), bt !== null)) {
            (bt.return = gt.return), (rr = bt);
            break;
          }
          rr = gt.return;
        }
    }
  }
  function av(dt, gt, bt) {
    (rr = dt), Tm(dt);
  }
  function Tm(dt, gt, bt) {
    for (var Tt = (dt.mode & 1) !== 0; rr !== null; ) {
      var Lt = rr,
        Ot = Lt.child;
      if (Lt.tag === 22 && Tt) {
        var cn = Lt.memoizedState !== null || fu;
        if (!cn) {
          var Sn = Lt.alternate,
            $n = (Sn !== null && Sn.memoizedState !== null) || Lo;
          Sn = fu;
          var er = Lo;
          if (((fu = cn), (Lo = $n) && !er))
            for (rr = Lt; rr !== null; )
              (cn = rr),
                ($n = cn.child),
                cn.tag === 22 && cn.memoizedState !== null
                  ? Rm(Lt)
                  : $n !== null
                  ? (($n.return = cn), (rr = $n))
                  : Rm(Lt);
          for (; Ot !== null; ) (rr = Ot), Tm(Ot), (Ot = Ot.sibling);
          (rr = Lt), (fu = Sn), (Lo = er);
        }
        wm(dt);
      } else
        Lt.subtreeFlags & 8772 && Ot !== null
          ? ((Ot.return = Lt), (rr = Ot))
          : wm(dt);
    }
  }
  function wm(dt) {
    for (; rr !== null; ) {
      var gt = rr;
      if (gt.flags & 8772) {
        var bt = gt.alternate;
        try {
          if (gt.flags & 8772)
            switch (gt.tag) {
              case 0:
              case 11:
              case 15:
                Lo || Ll(5, gt);
                break;
              case 1:
                var Tt = gt.stateNode;
                if (gt.flags & 4 && !Lo)
                  if (bt === null) Tt.componentDidMount();
                  else {
                    var Lt =
                      gt.elementType === gt.type
                        ? bt.memoizedProps
                        : Ss(gt.type, bt.memoizedProps);
                    Tt.componentDidUpdate(
                      Lt,
                      bt.memoizedState,
                      Tt.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var Ot = gt.updateQueue;
                Ot !== null && Ep(gt, Ot, Tt);
                break;
              case 3:
                var cn = gt.updateQueue;
                if (cn !== null) {
                  if (((bt = null), gt.child !== null))
                    switch (gt.child.tag) {
                      case 5:
                        bt = kt(gt.child.stateNode);
                        break;
                      case 1:
                        bt = gt.child.stateNode;
                    }
                  Ep(gt, cn, bt);
                }
                break;
              case 5:
                var Sn = gt.stateNode;
                bt === null &&
                  gt.flags & 4 &&
                  Kn(Sn, gt.type, gt.memoizedProps, gt);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (yn && gt.memoizedState === null) {
                  var $n = gt.alternate;
                  if ($n !== null) {
                    var er = $n.memoizedState;
                    if (er !== null) {
                      var cr = er.dehydrated;
                      cr !== null && Gn(cr);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(ot(163));
            }
          Lo || (gt.flags & 512 && _h(gt));
        } catch (Sr) {
          Ps(gt, gt.return, Sr);
        }
      }
      if (gt === dt) {
        rr = null;
        break;
      }
      if (((bt = gt.sibling), bt !== null)) {
        (bt.return = gt.return), (rr = bt);
        break;
      }
      rr = gt.return;
    }
  }
  function Pm(dt) {
    for (; rr !== null; ) {
      var gt = rr;
      if (gt === dt) {
        rr = null;
        break;
      }
      var bt = gt.sibling;
      if (bt !== null) {
        (bt.return = gt.return), (rr = bt);
        break;
      }
      rr = gt.return;
    }
  }
  function Rm(dt) {
    for (; rr !== null; ) {
      var gt = rr;
      try {
        switch (gt.tag) {
          case 0:
          case 11:
          case 15:
            var bt = gt.return;
            try {
              Ll(4, gt);
            } catch ($n) {
              Ps(gt, bt, $n);
            }
            break;
          case 1:
            var Tt = gt.stateNode;
            if (typeof Tt.componentDidMount == "function") {
              var Lt = gt.return;
              try {
                Tt.componentDidMount();
              } catch ($n) {
                Ps(gt, Lt, $n);
              }
            }
            var Ot = gt.return;
            try {
              _h(gt);
            } catch ($n) {
              Ps(gt, Ot, $n);
            }
            break;
          case 5:
            var cn = gt.return;
            try {
              _h(gt);
            } catch ($n) {
              Ps(gt, cn, $n);
            }
        }
      } catch ($n) {
        Ps(gt, gt.return, $n);
      }
      if (gt === dt) {
        rr = null;
        break;
      }
      var Sn = gt.sibling;
      if (Sn !== null) {
        (Sn.return = gt.return), (rr = Sn);
        break;
      }
      rr = gt.return;
    }
  }
  var pu = 0,
    mu = 1,
    gu = 2,
    vu = 3,
    yu = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Fl = Symbol.for;
    (pu = Fl("selector.component")),
      (mu = Fl("selector.has_pseudo_class")),
      (gu = Fl("selector.role")),
      (vu = Fl("selector.test_id")),
      (yu = Fl("selector.text"));
  }
  function np(dt) {
    var gt = pn(dt);
    if (gt != null) {
      if (typeof gt.memoizedProps["data-testname"] != "string")
        throw Error(ot(364));
      return gt;
    }
    if (((dt = An(dt)), dt === null)) throw Error(ot(362));
    return dt.stateNode.current;
  }
  function rp(dt, gt) {
    switch (gt.$$typeof) {
      case pu:
        if (dt.type === gt.value) return !0;
        break;
      case mu:
        e: {
          (gt = gt.value), (dt = [dt, 0]);
          for (var bt = 0; bt < dt.length; ) {
            var Tt = dt[bt++],
              Lt = dt[bt++],
              Ot = gt[Lt];
            if (Tt.tag !== 5 || !Ut(Tt)) {
              for (; Ot != null && rp(Tt, Ot); ) Lt++, (Ot = gt[Lt]);
              if (Lt === gt.length) {
                gt = !0;
                break e;
              } else
                for (Tt = Tt.child; Tt !== null; )
                  dt.push(Tt, Lt), (Tt = Tt.sibling);
            }
          }
          gt = !1;
        }
        return gt;
      case gu:
        if (dt.tag === 5 && hn(dt.stateNode, gt.value)) return !0;
        break;
      case yu:
        if (
          (dt.tag === 5 || dt.tag === 6) &&
          ((dt = Xt(dt)), dt !== null && 0 <= dt.indexOf(gt.value))
        )
          return !0;
        break;
      case vu:
        if (
          dt.tag === 5 &&
          ((dt = dt.memoizedProps["data-testname"]),
          typeof dt == "string" && dt.toLowerCase() === gt.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(ot(365));
    }
    return !1;
  }
  function ip(dt) {
    switch (dt.$$typeof) {
      case pu:
        return "<" + (wt(dt.value) || "Unknown") + ">";
      case mu:
        return ":has(" + (ip(dt) || "") + ")";
      case gu:
        return '[role="' + dt.value + '"]';
      case yu:
        return '"' + dt.value + '"';
      case vu:
        return '[data-testname="' + dt.value + '"]';
      default:
        throw Error(ot(365));
    }
  }
  function Bm(dt, gt) {
    var bt = [];
    dt = [dt, 0];
    for (var Tt = 0; Tt < dt.length; ) {
      var Lt = dt[Tt++],
        Ot = dt[Tt++],
        cn = gt[Ot];
      if (Lt.tag !== 5 || !Ut(Lt)) {
        for (; cn != null && rp(Lt, cn); ) Ot++, (cn = gt[Ot]);
        if (Ot === gt.length) bt.push(Lt);
        else
          for (Lt = Lt.child; Lt !== null; ) dt.push(Lt, Ot), (Lt = Lt.sibling);
      }
    }
    return bt;
  }
  function sp(dt, gt) {
    if (!Tn) throw Error(ot(363));
    (dt = np(dt)), (dt = Bm(dt, gt)), (gt = []), (dt = Array.from(dt));
    for (var bt = 0; bt < dt.length; ) {
      var Tt = dt[bt++];
      if (Tt.tag === 5) Ut(Tt) || gt.push(Tt.stateNode);
      else for (Tt = Tt.child; Tt !== null; ) dt.push(Tt), (Tt = Tt.sibling);
    }
    return gt;
  }
  var lv = Math.ceil,
    _u = at.ReactCurrentDispatcher,
    op = at.ReactCurrentOwner,
    qr = at.ReactCurrentBatchConfig,
    Cr = 0,
    es = null,
    ts = null,
    us = 0,
    Os = 0,
    qo = mr(0),
    rs = 0,
    Dl = null,
    Qo = 0,
    xu = 0,
    ap = 0,
    Ol = null,
    Ts = null,
    lp = 0,
    cp = 1 / 0;
  function Zo() {
    cp = Hr() + 500;
  }
  var Su = !1,
    up = null,
    vo = null,
    Eu = !1,
    yo = null,
    Au = 0,
    Nl = 0,
    fp = null,
    bu = -1,
    Cu = 0;
  function bs() {
    return Cr & 6 ? Hr() : bu !== -1 ? bu : (bu = Hr());
  }
  function _o(dt) {
    return dt.mode & 1
      ? Cr & 2 && us !== 0
        ? us & -us
        : To.transition !== null
        ? (Cu === 0 &&
            ((dt = no), (no <<= 1), !(no & 4194240) && (no = 64), (Cu = dt)),
          Cu)
        : ((dt = Tr), dt !== 0 ? dt : xn())
      : 1;
  }
  function zs(dt, gt, bt) {
    if (50 < Nl) throw ((Nl = 0), (fp = null), Error(ot(185)));
    var Tt = Mu(dt, gt);
    return Tt === null
      ? null
      : (Ys(Tt, gt, bt),
        (!(Cr & 2) || Tt !== es) &&
          (Tt === es && (!(Cr & 2) && (xu |= gt), rs === 4 && xo(Tt, us)),
          ws(Tt, bt),
          gt === 1 && Cr === 0 && !(dt.mode & 1) && (Zo(), Qs && Ms())),
        Tt);
  }
  function Mu(dt, gt) {
    dt.lanes |= gt;
    var bt = dt.alternate;
    for (
      bt !== null && (bt.lanes |= gt), bt = dt, dt = dt.return;
      dt !== null;

    )
      (dt.childLanes |= gt),
        (bt = dt.alternate),
        bt !== null && (bt.childLanes |= gt),
        (bt = dt),
        (dt = dt.return);
    return bt.tag === 3 ? bt.stateNode : null;
  }
  function ws(dt, gt) {
    var bt = dt.callbackNode;
    na(dt, gt);
    var Tt = bo(dt, dt === es ? us : 0);
    if (Tt === 0)
      bt !== null && $o(bt),
        (dt.callbackNode = null),
        (dt.callbackPriority = 0);
    else if (((gt = Tt & -Tt), dt.callbackPriority !== gt)) {
      if ((bt != null && $o(bt), gt === 1))
        dt.tag === 0 ? yl(Lm.bind(null, dt)) : $a(Lm.bind(null, dt)),
          _n
            ? Dn(function () {
                Cr === 0 && Ms();
              })
            : oo(Co, Ms),
          (bt = null);
      else {
        switch (ga(Tt)) {
          case 1:
            bt = Co;
            break;
          case 4:
            bt = Vl;
            break;
          case 16:
            bt = _s;
            break;
          case 536870912:
            bt = xa;
            break;
          default:
            bt = _s;
        }
        bt = Vm(bt, Im.bind(null, dt));
      }
      (dt.callbackPriority = gt), (dt.callbackNode = bt);
    }
  }
  function Im(dt, gt) {
    if (((bu = -1), (Cu = 0), Cr & 6)) throw Error(ot(327));
    var bt = dt.callbackNode;
    if (Oo() && dt.callbackNode !== bt) return null;
    var Tt = bo(dt, dt === es ? us : 0);
    if (Tt === 0) return null;
    if (Tt & 30 || Tt & dt.expiredLanes || gt) gt = Tu(dt, Tt);
    else {
      gt = Tt;
      var Lt = Cr;
      Cr |= 2;
      var Ot = km();
      (es !== dt || us !== gt) && (Zo(), Do(dt, gt));
      do
        try {
          fv();
          break;
        } catch (Sn) {
          Dm(dt, Sn);
        }
      while (1);
      zo(),
        (_u.current = Ot),
        (Cr = Lt),
        ts !== null ? (gt = 0) : ((es = null), (us = 0), (gt = rs));
    }
    if (gt !== 0) {
      if (
        (gt === 2 &&
          ((Lt = so(dt)), Lt !== 0 && ((Tt = Lt), (gt = hp(dt, Lt)))),
        gt === 1)
      )
        throw ((bt = Dl), Do(dt, 0), xo(dt, Tt), ws(dt, Hr()), bt);
      if (gt === 6) xo(dt, Tt);
      else {
        if (
          ((Lt = dt.current.alternate),
          !(Tt & 30) &&
            !cv(Lt) &&
            ((gt = Tu(dt, Tt)),
            gt === 2 &&
              ((Ot = so(dt)), Ot !== 0 && ((Tt = Ot), (gt = hp(dt, Ot)))),
            gt === 1))
        )
          throw ((bt = Dl), Do(dt, 0), xo(dt, Tt), ws(dt, Hr()), bt);
        switch (((dt.finishedWork = Lt), (dt.finishedLanes = Tt), gt)) {
          case 0:
          case 1:
            throw Error(ot(345));
          case 2:
            ko(dt, Ts);
            break;
          case 3:
            if (
              (xo(dt, Tt),
              (Tt & 130023424) === Tt && ((gt = lp + 500 - Hr()), 10 < gt))
            ) {
              if (bo(dt, 0) !== 0) break;
              if (((Lt = dt.suspendedLanes), (Lt & Tt) !== Tt)) {
                bs(), (dt.pingedLanes |= dt.suspendedLanes & Lt);
                break;
              }
              dt.timeoutHandle = mn(ko.bind(null, dt, Ts), gt);
              break;
            }
            ko(dt, Ts);
            break;
          case 4:
            if ((xo(dt, Tt), (Tt & 4194240) === Tt)) break;
            for (gt = dt.eventTimes, Lt = -1; 0 < Tt; ) {
              var cn = 31 - Rs(Tt);
              (Ot = 1 << cn), (cn = gt[cn]), cn > Lt && (Lt = cn), (Tt &= ~Ot);
            }
            if (
              ((Tt = Lt),
              (Tt = Hr() - Tt),
              (Tt =
                (120 > Tt
                  ? 120
                  : 480 > Tt
                  ? 480
                  : 1080 > Tt
                  ? 1080
                  : 1920 > Tt
                  ? 1920
                  : 3e3 > Tt
                  ? 3e3
                  : 4320 > Tt
                  ? 4320
                  : 1960 * lv(Tt / 1960)) - Tt),
              10 < Tt)
            ) {
              dt.timeoutHandle = mn(ko.bind(null, dt, Ts), Tt);
              break;
            }
            ko(dt, Ts);
            break;
          case 5:
            ko(dt, Ts);
            break;
          default:
            throw Error(ot(329));
        }
      }
    }
    return ws(dt, Hr()), dt.callbackNode === bt ? Im.bind(null, dt) : null;
  }
  function hp(dt, gt) {
    var bt = Ol;
    return (
      dt.current.memoizedState.isDehydrated && (Do(dt, gt).flags |= 256),
      (dt = Tu(dt, gt)),
      dt !== 2 && ((gt = Ts), (Ts = bt), gt !== null && dp(gt)),
      dt
    );
  }
  function dp(dt) {
    Ts === null ? (Ts = dt) : Ts.push.apply(Ts, dt);
  }
  function cv(dt) {
    for (var gt = dt; ; ) {
      if (gt.flags & 16384) {
        var bt = gt.updateQueue;
        if (bt !== null && ((bt = bt.stores), bt !== null))
          for (var Tt = 0; Tt < bt.length; Tt++) {
            var Lt = bt[Tt],
              Ot = Lt.getSnapshot;
            Lt = Lt.value;
            try {
              if (!Is(Ot(), Lt)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((bt = gt.child), gt.subtreeFlags & 16384 && bt !== null))
        (bt.return = gt), (gt = bt);
      else {
        if (gt === dt) break;
        for (; gt.sibling === null; ) {
          if (gt.return === null || gt.return === dt) return !0;
          gt = gt.return;
        }
        (gt.sibling.return = gt.return), (gt = gt.sibling);
      }
    }
    return !0;
  }
  function xo(dt, gt) {
    for (
      gt &= ~ap,
        gt &= ~xu,
        dt.suspendedLanes |= gt,
        dt.pingedLanes &= ~gt,
        dt = dt.expirationTimes;
      0 < gt;

    ) {
      var bt = 31 - Rs(gt),
        Tt = 1 << bt;
      (dt[bt] = -1), (gt &= ~Tt);
    }
  }
  function Lm(dt) {
    if (Cr & 6) throw Error(ot(327));
    Oo();
    var gt = bo(dt, 0);
    if (!(gt & 1)) return ws(dt, Hr()), null;
    var bt = Tu(dt, gt);
    if (dt.tag !== 0 && bt === 2) {
      var Tt = so(dt);
      Tt !== 0 && ((gt = Tt), (bt = hp(dt, Tt)));
    }
    if (bt === 1) throw ((bt = Dl), Do(dt, 0), xo(dt, gt), ws(dt, Hr()), bt);
    if (bt === 6) throw Error(ot(345));
    return (
      (dt.finishedWork = dt.current.alternate),
      (dt.finishedLanes = gt),
      ko(dt, Ts),
      ws(dt, Hr()),
      null
    );
  }
  function Fm(dt) {
    yo !== null && yo.tag === 0 && !(Cr & 6) && Oo();
    var gt = Cr;
    Cr |= 1;
    var bt = qr.transition,
      Tt = Tr;
    try {
      if (((qr.transition = null), (Tr = 1), dt)) return dt();
    } finally {
      (Tr = Tt), (qr.transition = bt), (Cr = gt), !(Cr & 6) && Ms();
    }
  }
  function pp() {
    (Os = qo.current), wr(qo);
  }
  function Do(dt, gt) {
    (dt.finishedWork = null), (dt.finishedLanes = 0);
    var bt = dt.timeoutHandle;
    if ((bt !== bn && ((dt.timeoutHandle = bn), ln(bt)), ts !== null))
      for (bt = ts.return; bt !== null; ) {
        var Tt = bt;
        switch ((Fu(Tt), Tt.tag)) {
          case 1:
            (Tt = Tt.type.childContextTypes), Tt != null && ys();
            break;
          case 3:
            Jo(), wr(Vr), wr(jr), $u();
            break;
          case 5:
            Uu(Tt);
            break;
          case 4:
            Jo();
            break;
          case 13:
            wr(Wr);
            break;
          case 19:
            wr(Wr);
            break;
          case 10:
            as(Tt.type._context);
            break;
          case 22:
          case 23:
            pp();
        }
        bt = bt.return;
      }
    if (
      ((es = dt),
      (ts = dt = So(dt.current, null)),
      (us = Os = gt),
      (rs = 0),
      (Dl = null),
      (ap = xu = Qo = 0),
      (Ts = Ol = null),
      Ls !== null)
    ) {
      for (gt = 0; gt < Ls.length; gt++)
        if (((bt = Ls[gt]), (Tt = bt.interleaved), Tt !== null)) {
          bt.interleaved = null;
          var Lt = Tt.next,
            Ot = bt.pending;
          if (Ot !== null) {
            var cn = Ot.next;
            (Ot.next = Lt), (Tt.next = cn);
          }
          bt.pending = Tt;
        }
      Ls = null;
    }
    return dt;
  }
  function Dm(dt, gt) {
    do {
      var bt = ts;
      try {
        if ((zo(), (_c.current = su), eu)) {
          for (var Tt = Xr.memoizedState; Tt !== null; ) {
            var Lt = Tt.queue;
            Lt !== null && (Lt.pending = null), (Tt = Tt.next);
          }
          eu = !1;
        }
        if (
          ((Yo = 0),
          (ls = ps = Xr = null),
          (Cl = !1),
          (Ml = 0),
          (op.current = null),
          bt === null || bt.return === null)
        ) {
          (rs = 1), (Dl = gt), (ts = null);
          break;
        }
        e: {
          var Ot = dt,
            cn = bt.return,
            Sn = bt,
            $n = gt;
          if (
            ((gt = us),
            (Sn.flags |= 32768),
            $n !== null &&
              typeof $n == "object" &&
              typeof $n.then == "function")
          ) {
            var er = $n,
              cr = Sn,
              Sr = cr.tag;
            if (!(cr.mode & 1) && (Sr === 0 || Sr === 11 || Sr === 15)) {
              var pr = cr.alternate;
              pr
                ? ((cr.updateQueue = pr.updateQueue),
                  (cr.memoizedState = pr.memoizedState),
                  (cr.lanes = pr.lanes))
                : ((cr.updateQueue = null), (cr.memoizedState = null));
            }
            var Nr = nm(cn);
            if (Nr !== null) {
              (Nr.flags &= -257),
                rm(Nr, cn, Sn, Ot, gt),
                Nr.mode & 1 && tm(Ot, er, gt),
                (gt = Nr),
                ($n = er);
              var hr = gt.updateQueue;
              if (hr === null) {
                var vs = new Set();
                vs.add($n), (gt.updateQueue = vs);
              } else hr.add($n);
              break e;
            } else {
              if (!(gt & 1)) {
                tm(Ot, er, gt), mp();
                break e;
              }
              $n = Error(ot(426));
            }
          } else if (zr && Sn.mode & 1) {
            var Ws = nm(cn);
            if (Ws !== null) {
              !(Ws.flags & 65536) && (Ws.flags |= 256),
                rm(Ws, cn, Sn, Ot, gt),
                Ou($n);
              break e;
            }
          }
          (Ot = $n),
            rs !== 4 && (rs = 2),
            Ol === null ? (Ol = [Ot]) : Ol.push(Ot),
            ($n = Ku($n, Sn)),
            (Sn = cn);
          do {
            switch (Sn.tag) {
              case 3:
                (Sn.flags |= 65536), (gt &= -gt), (Sn.lanes |= gt);
                var In = Zp(Sn, $n, gt);
                Sp(Sn, In);
                break e;
              case 1:
                Ot = $n;
                var En = Sn.type,
                  Nn = Sn.stateNode;
                if (
                  !(Sn.flags & 128) &&
                  (typeof En.getDerivedStateFromError == "function" ||
                    (Nn !== null &&
                      typeof Nn.componentDidCatch == "function" &&
                      (vo === null || !vo.has(Nn))))
                ) {
                  (Sn.flags |= 65536), (gt &= -gt), (Sn.lanes |= gt);
                  var sr = em(Sn, Ot, gt);
                  Sp(Sn, sr);
                  break e;
                }
            }
            Sn = Sn.return;
          } while (Sn !== null);
        }
        Nm(bt);
      } catch (ur) {
        (gt = ur), ts === bt && bt !== null && (ts = bt = bt.return);
        continue;
      }
      break;
    } while (1);
  }
  function km() {
    var dt = _u.current;
    return (_u.current = su), dt === null ? su : dt;
  }
  function mp() {
    (rs === 0 || rs === 3 || rs === 2) && (rs = 4),
      es === null || (!(Qo & 268435455) && !(xu & 268435455)) || xo(es, us);
  }
  function Tu(dt, gt) {
    var bt = Cr;
    Cr |= 2;
    var Tt = km();
    (es === dt && us === gt) || Do(dt, gt);
    do
      try {
        uv();
        break;
      } catch (Lt) {
        Dm(dt, Lt);
      }
    while (1);
    if ((zo(), (Cr = bt), (_u.current = Tt), ts !== null)) throw Error(ot(261));
    return (es = null), (us = 0), rs;
  }
  function uv() {
    for (; ts !== null; ) Om(ts);
  }
  function fv() {
    for (; ts !== null && !_a(); ) Om(ts);
  }
  function Om(dt) {
    var gt = $m(dt.alternate, dt, Os);
    (dt.memoizedProps = dt.pendingProps),
      gt === null ? Nm(dt) : (ts = gt),
      (op.current = null);
  }
  function Nm(dt) {
    var gt = dt;
    do {
      var bt = gt.alternate;
      if (((dt = gt.return), gt.flags & 32768)) {
        if (((bt = rv(bt, gt)), bt !== null)) {
          (bt.flags &= 32767), (ts = bt);
          return;
        }
        if (dt !== null)
          (dt.flags |= 32768), (dt.subtreeFlags = 0), (dt.deletions = null);
        else {
          (rs = 6), (ts = null);
          return;
        }
      } else if (((bt = ev(bt, gt, Os)), bt !== null)) {
        ts = bt;
        return;
      }
      if (((gt = gt.sibling), gt !== null)) {
        ts = gt;
        return;
      }
      ts = gt = dt;
    } while (gt !== null);
    rs === 0 && (rs = 5);
  }
  function ko(dt, gt) {
    var bt = Tr,
      Tt = qr.transition;
    try {
      (qr.transition = null), (Tr = 1), hv(dt, gt, bt);
    } finally {
      (qr.transition = Tt), (Tr = bt);
    }
    return null;
  }
  function hv(dt, gt, bt) {
    do Oo();
    while (yo !== null);
    if (Cr & 6) throw Error(ot(327));
    var Tt = dt.finishedWork,
      Lt = dt.finishedLanes;
    if (Tt === null) return null;
    if (((dt.finishedWork = null), (dt.finishedLanes = 0), Tt === dt.current))
      throw Error(ot(177));
    (dt.callbackNode = null), (dt.callbackPriority = 0);
    var Ot = Tt.lanes | Tt.childLanes;
    if (
      (ho(dt, Ot),
      dt === es && ((ts = es = null), (us = 0)),
      (!(Tt.subtreeFlags & 2064) && !(Tt.flags & 2064)) ||
        Eu ||
        ((Eu = !0),
        Vm(_s, function () {
          return Oo(), null;
        })),
      (Ot = (Tt.flags & 15990) !== 0),
      Tt.subtreeFlags & 15990 || Ot)
    ) {
      (Ot = qr.transition), (qr.transition = null);
      var cn = Tr;
      Tr = 1;
      var Sn = Cr;
      (Cr |= 4),
        (op.current = null),
        sv(dt, Tt),
        ov(dt, Tt),
        Nt(dt.containerInfo),
        (dt.current = Tt),
        av(Tt),
        $l(),
        (Cr = Sn),
        (Tr = cn),
        (qr.transition = Ot);
    } else dt.current = Tt;
    if (
      (Eu && ((Eu = !1), (yo = dt), (Au = Lt)),
      (Ot = dt.pendingLanes),
      Ot === 0 && (vo = null),
      ba(Tt.stateNode),
      ws(dt, Hr()),
      gt !== null)
    )
      for (bt = dt.onRecoverableError, Tt = 0; Tt < gt.length; Tt++) bt(gt[Tt]);
    if (Su) throw ((Su = !1), (dt = up), (up = null), dt);
    return (
      Au & 1 && dt.tag !== 0 && Oo(),
      (Ot = dt.pendingLanes),
      Ot & 1 ? (dt === fp ? Nl++ : ((Nl = 0), (fp = dt))) : (Nl = 0),
      Ms(),
      null
    );
  }
  function Oo() {
    if (yo !== null) {
      var dt = ga(Au),
        gt = qr.transition,
        bt = Tr;
      try {
        if (((qr.transition = null), (Tr = 16 > dt ? 16 : dt), yo === null))
          var Tt = !1;
        else {
          if (((dt = yo), (yo = null), (Au = 0), Cr & 6)) throw Error(ot(331));
          var Lt = Cr;
          for (Cr |= 4, rr = dt.current; rr !== null; ) {
            var Ot = rr,
              cn = Ot.child;
            if (rr.flags & 16) {
              var Sn = Ot.deletions;
              if (Sn !== null) {
                for (var $n = 0; $n < Sn.length; $n++) {
                  var er = Sn[$n];
                  for (rr = er; rr !== null; ) {
                    var cr = rr;
                    switch (cr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Fo(8, cr, Ot);
                    }
                    var Sr = cr.child;
                    if (Sr !== null) (Sr.return = cr), (rr = Sr);
                    else
                      for (; rr !== null; ) {
                        cr = rr;
                        var pr = cr.sibling,
                          Nr = cr.return;
                        if ((Em(cr), cr === er)) {
                          rr = null;
                          break;
                        }
                        if (pr !== null) {
                          (pr.return = Nr), (rr = pr);
                          break;
                        }
                        rr = Nr;
                      }
                  }
                }
                var hr = Ot.alternate;
                if (hr !== null) {
                  var vs = hr.child;
                  if (vs !== null) {
                    hr.child = null;
                    do {
                      var Ws = vs.sibling;
                      (vs.sibling = null), (vs = Ws);
                    } while (vs !== null);
                  }
                }
                rr = Ot;
              }
            }
            if (Ot.subtreeFlags & 2064 && cn !== null)
              (cn.return = Ot), (rr = cn);
            else
              e: for (; rr !== null; ) {
                if (((Ot = rr), Ot.flags & 2048))
                  switch (Ot.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Fo(9, Ot, Ot.return);
                  }
                var In = Ot.sibling;
                if (In !== null) {
                  (In.return = Ot.return), (rr = In);
                  break e;
                }
                rr = Ot.return;
              }
          }
          var En = dt.current;
          for (rr = En; rr !== null; ) {
            cn = rr;
            var Nn = cn.child;
            if (cn.subtreeFlags & 2064 && Nn !== null)
              (Nn.return = cn), (rr = Nn);
            else
              e: for (cn = En; rr !== null; ) {
                if (((Sn = rr), Sn.flags & 2048))
                  try {
                    switch (Sn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ll(9, Sn);
                    }
                  } catch (ur) {
                    Ps(Sn, Sn.return, ur);
                  }
                if (Sn === cn) {
                  rr = null;
                  break e;
                }
                var sr = Sn.sibling;
                if (sr !== null) {
                  (sr.return = Sn.return), (rr = sr);
                  break e;
                }
                rr = Sn.return;
              }
          }
          if (
            ((Cr = Lt),
            Ms(),
            Bs && typeof Bs.onPostCommitFiberRoot == "function")
          )
            try {
              Bs.onPostCommitFiberRoot(Mo, dt);
            } catch {}
          Tt = !0;
        }
        return Tt;
      } finally {
        (Tr = bt), (qr.transition = gt);
      }
    }
    return !1;
  }
  function Um(dt, gt, bt) {
    (gt = Ku(bt, gt)),
      (gt = Zp(dt, gt, 1)),
      go(dt, gt),
      (gt = bs()),
      (dt = Mu(dt, 1)),
      dt !== null && (Ys(dt, 1, gt), ws(dt, gt));
  }
  function Ps(dt, gt, bt) {
    if (dt.tag === 3) Um(dt, dt, bt);
    else
      for (; gt !== null; ) {
        if (gt.tag === 3) {
          Um(gt, dt, bt);
          break;
        } else if (gt.tag === 1) {
          var Tt = gt.stateNode;
          if (
            typeof gt.type.getDerivedStateFromError == "function" ||
            (typeof Tt.componentDidCatch == "function" &&
              (vo === null || !vo.has(Tt)))
          ) {
            (dt = Ku(bt, dt)),
              (dt = em(gt, dt, 1)),
              go(gt, dt),
              (dt = bs()),
              (gt = Mu(gt, 1)),
              gt !== null && (Ys(gt, 1, dt), ws(gt, dt));
            break;
          }
        }
        gt = gt.return;
      }
  }
  function dv(dt, gt, bt) {
    var Tt = dt.pingCache;
    Tt !== null && Tt.delete(gt),
      (gt = bs()),
      (dt.pingedLanes |= dt.suspendedLanes & bt),
      es === dt &&
        (us & bt) === bt &&
        (rs === 4 || (rs === 3 && (us & 130023424) === us && 500 > Hr() - lp)
          ? Do(dt, 0)
          : (ap |= bt)),
      ws(dt, gt);
  }
  function Gm(dt, gt) {
    gt === 0 &&
      (dt.mode & 1
        ? ((gt = ro), (ro <<= 1), !(ro & 130023424) && (ro = 4194304))
        : (gt = 1));
    var bt = bs();
    (dt = Mu(dt, gt)), dt !== null && (Ys(dt, gt, bt), ws(dt, bt));
  }
  function pv(dt) {
    var gt = dt.memoizedState,
      bt = 0;
    gt !== null && (bt = gt.retryLane), Gm(dt, bt);
  }
  function mv(dt, gt) {
    var bt = 0;
    switch (dt.tag) {
      case 13:
        var Tt = dt.stateNode,
          Lt = dt.memoizedState;
        Lt !== null && (bt = Lt.retryLane);
        break;
      case 19:
        Tt = dt.stateNode;
        break;
      default:
        throw Error(ot(314));
    }
    Tt !== null && Tt.delete(gt), Gm(dt, bt);
  }
  var $m;
  $m = function (dt, gt, bt) {
    if (dt !== null)
      if (dt.memoizedProps !== gt.pendingProps || Vr.current) ks = !0;
      else {
        if (!(dt.lanes & bt) && !(gt.flags & 128))
          return (ks = !1), nv(dt, gt, bt);
        ks = !!(dt.flags & 131072);
      }
    else (ks = !1), zr && gt.flags & 1048576 && Tp(gt, Yl, gt.index);
    switch (((gt.lanes = 0), gt.tag)) {
      case 2:
        var Tt = gt.type;
        dt !== null &&
          ((dt.alternate = null), (gt.alternate = null), (gt.flags |= 2)),
          (dt = gt.pendingProps);
        var Lt = Or(gt, jr.current);
        Jr(gt, bt), (Lt = zu(null, gt, Tt, dt, Lt, bt));
        var Ot = Hu();
        return (
          (gt.flags |= 1),
          typeof Lt == "object" &&
          Lt !== null &&
          typeof Lt.render == "function" &&
          Lt.$$typeof === void 0
            ? ((gt.tag = 1),
              (gt.memoizedState = null),
              (gt.updateQueue = null),
              Ur(Tt) ? ((Ot = !0), Js(gt)) : (Ot = !1),
              (gt.memoizedState =
                Lt.state !== null && Lt.state !== void 0 ? Lt.state : null),
              Ru(gt),
              (Lt.updater = Kl),
              (gt.stateNode = Lt),
              (Lt._reactInternals = gt),
              Iu(gt, Tt, dt, bt),
              (gt = qu(null, gt, Tt, !0, Ot, bt)))
            : ((gt.tag = 0),
              zr && Ot && Lu(gt),
              As(null, gt, Lt, bt),
              (gt = gt.child)),
          gt
        );
      case 16:
        Tt = gt.elementType;
        e: {
          switch (
            (dt !== null &&
              ((dt.alternate = null), (gt.alternate = null), (gt.flags |= 2)),
            (dt = gt.pendingProps),
            (Lt = Tt._init),
            (Tt = Lt(Tt._payload)),
            (gt.type = Tt),
            (Lt = gt.tag = vv(Tt)),
            (dt = Ss(Tt, dt)),
            Lt)
          ) {
            case 0:
              gt = Yu(null, gt, Tt, dt, bt);
              break e;
            case 1:
              gt = fm(null, gt, Tt, dt, bt);
              break e;
            case 11:
              gt = om(null, gt, Tt, dt, bt);
              break e;
            case 14:
              gt = am(null, gt, Tt, Ss(Tt.type, dt), bt);
              break e;
          }
          throw Error(ot(306, Tt, ""));
        }
        return gt;
      case 0:
        return (
          (Tt = gt.type),
          (Lt = gt.pendingProps),
          (Lt = gt.elementType === Tt ? Lt : Ss(Tt, Lt)),
          Yu(dt, gt, Tt, Lt, bt)
        );
      case 1:
        return (
          (Tt = gt.type),
          (Lt = gt.pendingProps),
          (Lt = gt.elementType === Tt ? Lt : Ss(Tt, Lt)),
          fm(dt, gt, Tt, Lt, bt)
        );
      case 3:
        e: {
          if ((hm(gt), dt === null)) throw Error(ot(387));
          (Tt = gt.pendingProps),
            (Ot = gt.memoizedState),
            (Lt = Ot.element),
            xp(dt, gt),
            Xl(gt, Tt, null, bt);
          var cn = gt.memoizedState;
          if (((Tt = cn.element), yn && Ot.isDehydrated))
            if (
              ((Ot = {
                element: Tt,
                isDehydrated: !1,
                cache: cn.cache,
                transitions: cn.transitions,
              }),
              (gt.updateQueue.baseState = Ot),
              (gt.memoizedState = Ot),
              gt.flags & 256)
            ) {
              (Lt = Error(ot(423))), (gt = dm(dt, gt, Tt, bt, Lt));
              break e;
            } else if (Tt !== Lt) {
              (Lt = Error(ot(424))), (gt = dm(dt, gt, Tt, bt, Lt));
              break e;
            } else
              for (
                yn &&
                  ((Ds = $r(gt.stateNode.containerInfo)),
                  (Fs = gt),
                  (zr = !0),
                  (Xs = null),
                  (_l = !1)),
                  bt = Lp(gt, null, Tt, bt),
                  gt.child = bt;
                bt;

              )
                (bt.flags = (bt.flags & -3) | 4096), (bt = bt.sibling);
          else {
            if ((jo(), Tt === Lt)) {
              gt = fo(dt, gt, bt);
              break e;
            }
            As(dt, gt, Tt, bt);
          }
          gt = gt.child;
        }
        return gt;
      case 5:
        return (
          Fp(gt),
          dt === null && ku(gt),
          (Tt = gt.type),
          (Lt = gt.pendingProps),
          (Ot = dt !== null ? dt.memoizedProps : null),
          (cn = Lt.children),
          Zt(Tt, Lt)
            ? (cn = null)
            : Ot !== null && Zt(Tt, Ot) && (gt.flags |= 32),
          um(dt, gt),
          As(dt, gt, cn, bt),
          gt.child
        );
      case 6:
        return dt === null && ku(gt), null;
      case 13:
        return pm(dt, gt, bt);
      case 4:
        return (
          Nu(gt, gt.stateNode.containerInfo),
          (Tt = gt.pendingProps),
          dt === null ? (gt.child = Xo(gt, null, Tt, bt)) : As(dt, gt, Tt, bt),
          gt.child
        );
      case 11:
        return (
          (Tt = gt.type),
          (Lt = gt.pendingProps),
          (Lt = gt.elementType === Tt ? Lt : Ss(Tt, Lt)),
          om(dt, gt, Tt, Lt, bt)
        );
      case 7:
        return As(dt, gt, gt.pendingProps, bt), gt.child;
      case 8:
        return As(dt, gt, gt.pendingProps.children, bt), gt.child;
      case 12:
        return As(dt, gt, gt.pendingProps.children, bt), gt.child;
      case 10:
        e: {
          if (
            ((Tt = gt.type._context),
            (Lt = gt.pendingProps),
            (Ot = gt.memoizedProps),
            (cn = Lt.value),
            Hl(gt, Tt, cn),
            Ot !== null)
          )
            if (Is(Ot.value, cn)) {
              if (Ot.children === Lt.children && !Vr.current) {
                gt = fo(dt, gt, bt);
                break e;
              }
            } else
              for (
                Ot = gt.child, Ot !== null && (Ot.return = gt);
                Ot !== null;

              ) {
                var Sn = Ot.dependencies;
                if (Sn !== null) {
                  cn = Ot.child;
                  for (var $n = Sn.firstContext; $n !== null; ) {
                    if ($n.context === Tt) {
                      if (Ot.tag === 1) {
                        ($n = ao(-1, bt & -bt)), ($n.tag = 2);
                        var er = Ot.updateQueue;
                        if (er !== null) {
                          er = er.shared;
                          var cr = er.pending;
                          cr === null
                            ? ($n.next = $n)
                            : (($n.next = cr.next), (cr.next = $n)),
                            (er.pending = $n);
                        }
                      }
                      (Ot.lanes |= bt),
                        ($n = Ot.alternate),
                        $n !== null && ($n.lanes |= bt),
                        Es(Ot.return, bt, gt),
                        (Sn.lanes |= bt);
                      break;
                    }
                    $n = $n.next;
                  }
                } else if (Ot.tag === 10)
                  cn = Ot.type === gt.type ? null : Ot.child;
                else if (Ot.tag === 18) {
                  if (((cn = Ot.return), cn === null)) throw Error(ot(341));
                  (cn.lanes |= bt),
                    (Sn = cn.alternate),
                    Sn !== null && (Sn.lanes |= bt),
                    Es(cn, bt, gt),
                    (cn = Ot.sibling);
                } else cn = Ot.child;
                if (cn !== null) cn.return = Ot;
                else
                  for (cn = Ot; cn !== null; ) {
                    if (cn === gt) {
                      cn = null;
                      break;
                    }
                    if (((Ot = cn.sibling), Ot !== null)) {
                      (Ot.return = cn.return), (cn = Ot);
                      break;
                    }
                    cn = cn.return;
                  }
                Ot = cn;
              }
          As(dt, gt, Lt.children, bt), (gt = gt.child);
        }
        return gt;
      case 9:
        return (
          (Lt = gt.type),
          (Tt = gt.pendingProps.children),
          Jr(gt, bt),
          (Lt = Yr(Lt)),
          (Tt = Tt(Lt)),
          (gt.flags |= 1),
          As(dt, gt, Tt, bt),
          gt.child
        );
      case 14:
        return (
          (Tt = gt.type),
          (Lt = Ss(Tt, gt.pendingProps)),
          (Lt = Ss(Tt.type, Lt)),
          am(dt, gt, Tt, Lt, bt)
        );
      case 15:
        return lm(dt, gt, gt.type, gt.pendingProps, bt);
      case 17:
        return (
          (Tt = gt.type),
          (Lt = gt.pendingProps),
          (Lt = gt.elementType === Tt ? Lt : Ss(Tt, Lt)),
          dt !== null &&
            ((dt.alternate = null), (gt.alternate = null), (gt.flags |= 2)),
          (gt.tag = 1),
          Ur(Tt) ? ((dt = !0), Js(gt)) : (dt = !1),
          Jr(gt, bt),
          Cp(gt, Tt, Lt),
          Iu(gt, Tt, Lt, bt),
          qu(null, gt, Tt, !0, dt, bt)
        );
      case 19:
        return ym(dt, gt, bt);
      case 22:
        return cm(dt, gt, bt);
    }
    throw Error(ot(156, gt.tag));
  };
  function Vm(dt, gt) {
    return oo(dt, gt);
  }
  function gv(dt, gt, bt, Tt) {
    (this.tag = dt),
      (this.key = bt),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = gt),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = Tt),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Hs(dt, gt, bt, Tt) {
    return new gv(dt, gt, bt, Tt);
  }
  function gp(dt) {
    return (dt = dt.prototype), !(!dt || !dt.isReactComponent);
  }
  function vv(dt) {
    if (typeof dt == "function") return gp(dt) ? 1 : 0;
    if (dt != null) {
      if (((dt = dt.$$typeof), dt === yt)) return 11;
      if (dt === xt) return 14;
    }
    return 2;
  }
  function So(dt, gt) {
    var bt = dt.alternate;
    return (
      bt === null
        ? ((bt = Hs(dt.tag, gt, dt.key, dt.mode)),
          (bt.elementType = dt.elementType),
          (bt.type = dt.type),
          (bt.stateNode = dt.stateNode),
          (bt.alternate = dt),
          (dt.alternate = bt))
        : ((bt.pendingProps = gt),
          (bt.type = dt.type),
          (bt.flags = 0),
          (bt.subtreeFlags = 0),
          (bt.deletions = null)),
      (bt.flags = dt.flags & 14680064),
      (bt.childLanes = dt.childLanes),
      (bt.lanes = dt.lanes),
      (bt.child = dt.child),
      (bt.memoizedProps = dt.memoizedProps),
      (bt.memoizedState = dt.memoizedState),
      (bt.updateQueue = dt.updateQueue),
      (gt = dt.dependencies),
      (bt.dependencies =
        gt === null
          ? null
          : { lanes: gt.lanes, firstContext: gt.firstContext }),
      (bt.sibling = dt.sibling),
      (bt.index = dt.index),
      (bt.ref = dt.ref),
      bt
    );
  }
  function wu(dt, gt, bt, Tt, Lt, Ot) {
    var cn = 2;
    if (((Tt = dt), typeof dt == "function")) gp(dt) && (cn = 1);
    else if (typeof dt == "string") cn = 5;
    else
      e: switch (dt) {
        case ut:
          return No(bt.children, Lt, Ot, gt);
        case ft:
          (cn = 8), (Lt |= 8);
          break;
        case ht:
          return (
            (dt = Hs(12, bt, gt, Lt | 2)),
            (dt.elementType = ht),
            (dt.lanes = Ot),
            dt
          );
        case Et:
          return (
            (dt = Hs(13, bt, gt, Lt)),
            (dt.elementType = Et),
            (dt.lanes = Ot),
            dt
          );
        case pt:
          return (
            (dt = Hs(19, bt, gt, Lt)),
            (dt.elementType = pt),
            (dt.lanes = Ot),
            dt
          );
        case At:
          return Pu(bt, Lt, Ot, gt);
        default:
          if (typeof dt == "object" && dt !== null)
            switch (dt.$$typeof) {
              case mt:
                cn = 10;
                break e;
              case vt:
                cn = 9;
                break e;
              case yt:
                cn = 11;
                break e;
              case xt:
                cn = 14;
                break e;
              case St:
                (cn = 16), (Tt = null);
                break e;
            }
          throw Error(ot(130, dt == null ? dt : typeof dt, ""));
      }
    return (
      (gt = Hs(cn, bt, gt, Lt)),
      (gt.elementType = dt),
      (gt.type = Tt),
      (gt.lanes = Ot),
      gt
    );
  }
  function No(dt, gt, bt, Tt) {
    return (dt = Hs(7, dt, Tt, gt)), (dt.lanes = bt), dt;
  }
  function Pu(dt, gt, bt, Tt) {
    return (
      (dt = Hs(22, dt, Tt, gt)),
      (dt.elementType = At),
      (dt.lanes = bt),
      (dt.stateNode = {}),
      dt
    );
  }
  function vp(dt, gt, bt) {
    return (dt = Hs(6, dt, null, gt)), (dt.lanes = bt), dt;
  }
  function yp(dt, gt, bt) {
    return (
      (gt = Hs(4, dt.children !== null ? dt.children : [], dt.key, gt)),
      (gt.lanes = bt),
      (gt.stateNode = {
        containerInfo: dt.containerInfo,
        pendingChildren: null,
        implementation: dt.implementation,
      }),
      gt
    );
  }
  function yv(dt, gt, bt, Tt, Lt) {
    (this.tag = gt),
      (this.containerInfo = dt),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = bn),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Go(0)),
      (this.expirationTimes = Go(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Go(0)),
      (this.identifierPrefix = Tt),
      (this.onRecoverableError = Lt),
      yn && (this.mutableSourceEagerHydrationData = null);
  }
  function zm(dt, gt, bt, Tt, Lt, Ot, cn, Sn, $n) {
    return (
      (dt = new yv(dt, gt, bt, Sn, $n)),
      gt === 1 ? ((gt = 1), Ot === !0 && (gt |= 8)) : (gt = 0),
      (Ot = Hs(3, null, null, gt)),
      (dt.current = Ot),
      (Ot.stateNode = dt),
      (Ot.memoizedState = {
        element: Tt,
        isDehydrated: bt,
        cache: null,
        transitions: null,
      }),
      Ru(Ot),
      dt
    );
  }
  function Hm(dt) {
    if (!dt) return Kr;
    dt = dt._reactInternals;
    e: {
      if (It(dt) !== dt || dt.tag !== 1) throw Error(ot(170));
      var gt = dt;
      do {
        switch (gt.tag) {
          case 3:
            gt = gt.stateNode.context;
            break e;
          case 1:
            if (Ur(gt.type)) {
              gt = gt.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        gt = gt.return;
      } while (gt !== null);
      throw Error(ot(171));
    }
    if (dt.tag === 1) {
      var bt = dt.type;
      if (Ur(bt)) return Ks(dt, bt, gt);
    }
    return gt;
  }
  function Wm(dt) {
    var gt = dt._reactInternals;
    if (gt === void 0)
      throw typeof dt.render == "function"
        ? Error(ot(188))
        : ((dt = Object.keys(dt).join(",")), Error(ot(268, dt)));
    return (dt = $t(gt)), dt === null ? null : dt.stateNode;
  }
  function jm(dt, gt) {
    if (((dt = dt.memoizedState), dt !== null && dt.dehydrated !== null)) {
      var bt = dt.retryLane;
      dt.retryLane = bt !== 0 && bt < gt ? bt : gt;
    }
  }
  function _p(dt, gt) {
    jm(dt, gt), (dt = dt.alternate) && jm(dt, gt);
  }
  function _v(dt) {
    return (dt = $t(dt)), dt === null ? null : dt.stateNode;
  }
  function xv() {
    return null;
  }
  return (
    (nt.attemptContinuousHydration = function (dt) {
      if (dt.tag === 13) {
        var gt = bs();
        zs(dt, 134217728, gt), _p(dt, 134217728);
      }
    }),
    (nt.attemptHydrationAtCurrentPriority = function (dt) {
      if (dt.tag === 13) {
        var gt = bs(),
          bt = _o(dt);
        zs(dt, bt, gt), _p(dt, bt);
      }
    }),
    (nt.attemptSynchronousHydration = function (dt) {
      switch (dt.tag) {
        case 3:
          var gt = dt.stateNode;
          if (gt.current.memoizedState.isDehydrated) {
            var bt = io(gt.pendingLanes);
            bt !== 0 &&
              (qs(gt, bt | 1), ws(gt, Hr()), !(Cr & 6) && (Zo(), Ms()));
          }
          break;
        case 13:
          var Tt = bs();
          Fm(function () {
            return zs(dt, 1, Tt);
          }),
            _p(dt, 1);
      }
    }),
    (nt.batchedUpdates = function (dt, gt) {
      var bt = Cr;
      Cr |= 1;
      try {
        return dt(gt);
      } finally {
        (Cr = bt), Cr === 0 && (Zo(), Qs && Ms());
      }
    }),
    (nt.createComponentSelector = function (dt) {
      return { $$typeof: pu, value: dt };
    }),
    (nt.createContainer = function (dt, gt, bt, Tt, Lt, Ot, cn) {
      return zm(dt, gt, !1, null, bt, Tt, Lt, Ot, cn);
    }),
    (nt.createHasPseudoClassSelector = function (dt) {
      return { $$typeof: mu, value: dt };
    }),
    (nt.createHydrationContainer = function (
      dt,
      gt,
      bt,
      Tt,
      Lt,
      Ot,
      cn,
      Sn,
      $n
    ) {
      return (
        (dt = zm(bt, Tt, !0, dt, Lt, Ot, cn, Sn, $n)),
        (dt.context = Hm(null)),
        (bt = dt.current),
        (Tt = bs()),
        (Lt = _o(bt)),
        (Ot = ao(Tt, Lt)),
        (Ot.callback = gt ?? null),
        go(bt, Ot),
        (dt.current.lanes = Lt),
        Ys(dt, Lt, Tt),
        ws(dt, Tt),
        dt
      );
    }),
    (nt.createPortal = function (dt, gt, bt) {
      var Tt =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: ct,
        key: Tt == null ? null : "" + Tt,
        children: dt,
        containerInfo: gt,
        implementation: bt,
      };
    }),
    (nt.createRoleSelector = function (dt) {
      return { $$typeof: gu, value: dt };
    }),
    (nt.createTestNameSelector = function (dt) {
      return { $$typeof: vu, value: dt };
    }),
    (nt.createTextSelector = function (dt) {
      return { $$typeof: yu, value: dt };
    }),
    (nt.deferredUpdates = function (dt) {
      var gt = Tr,
        bt = qr.transition;
      try {
        return (qr.transition = null), (Tr = 16), dt();
      } finally {
        (Tr = gt), (qr.transition = bt);
      }
    }),
    (nt.discreteUpdates = function (dt, gt, bt, Tt, Lt) {
      var Ot = Tr,
        cn = qr.transition;
      try {
        return (qr.transition = null), (Tr = 1), dt(gt, bt, Tt, Lt);
      } finally {
        (Tr = Ot), (qr.transition = cn), Cr === 0 && Zo();
      }
    }),
    (nt.findAllNodes = sp),
    (nt.findBoundingRects = function (dt, gt) {
      if (!Tn) throw Error(ot(363));
      (gt = sp(dt, gt)), (dt = []);
      for (var bt = 0; bt < gt.length; bt++) dt.push(Wn(gt[bt]));
      for (gt = dt.length - 1; 0 < gt; gt--) {
        bt = dt[gt];
        for (
          var Tt = bt.x,
            Lt = Tt + bt.width,
            Ot = bt.y,
            cn = Ot + bt.height,
            Sn = gt - 1;
          0 <= Sn;
          Sn--
        )
          if (gt !== Sn) {
            var $n = dt[Sn],
              er = $n.x,
              cr = er + $n.width,
              Sr = $n.y,
              pr = Sr + $n.height;
            if (Tt >= er && Ot >= Sr && Lt <= cr && cn <= pr) {
              dt.splice(gt, 1);
              break;
            } else if (
              Tt !== er ||
              bt.width !== $n.width ||
              pr < Ot ||
              Sr > cn
            ) {
              if (
                !(Ot !== Sr || bt.height !== $n.height || cr < Tt || er > Lt)
              ) {
                er > Tt && (($n.width += er - Tt), ($n.x = Tt)),
                  cr < Lt && ($n.width = Lt - er),
                  dt.splice(gt, 1);
                break;
              }
            } else {
              Sr > Ot && (($n.height += Sr - Ot), ($n.y = Ot)),
                pr < cn && ($n.height = cn - Sr),
                dt.splice(gt, 1);
              break;
            }
          }
      }
      return dt;
    }),
    (nt.findHostInstance = Wm),
    (nt.findHostInstanceWithNoPortals = function (dt) {
      return (
        (dt = Vt(dt)),
        (dt = dt !== null ? Ht(dt) : null),
        dt === null ? null : dt.stateNode
      );
    }),
    (nt.findHostInstanceWithWarning = function (dt) {
      return Wm(dt);
    }),
    (nt.flushControlled = function (dt) {
      var gt = Cr;
      Cr |= 1;
      var bt = qr.transition,
        Tt = Tr;
      try {
        (qr.transition = null), (Tr = 1), dt();
      } finally {
        (Tr = Tt), (qr.transition = bt), (Cr = gt), Cr === 0 && (Zo(), Ms());
      }
    }),
    (nt.flushPassiveEffects = Oo),
    (nt.flushSync = Fm),
    (nt.focusWithin = function (dt, gt) {
      if (!Tn) throw Error(ot(363));
      for (
        dt = np(dt), gt = Bm(dt, gt), gt = Array.from(gt), dt = 0;
        dt < gt.length;

      ) {
        var bt = gt[dt++];
        if (!Ut(bt)) {
          if (bt.tag === 5 && Ln(bt.stateNode)) return !0;
          for (bt = bt.child; bt !== null; ) gt.push(bt), (bt = bt.sibling);
        }
      }
      return !1;
    }),
    (nt.getCurrentUpdatePriority = function () {
      return Tr;
    }),
    (nt.getFindAllNodesFailureDescription = function (dt, gt) {
      if (!Tn) throw Error(ot(363));
      var bt = 0,
        Tt = [];
      dt = [np(dt), 0];
      for (var Lt = 0; Lt < dt.length; ) {
        var Ot = dt[Lt++],
          cn = dt[Lt++],
          Sn = gt[cn];
        if (
          (Ot.tag !== 5 || !Ut(Ot)) &&
          (rp(Ot, Sn) && (Tt.push(ip(Sn)), cn++, cn > bt && (bt = cn)),
          cn < gt.length)
        )
          for (Ot = Ot.child; Ot !== null; ) dt.push(Ot, cn), (Ot = Ot.sibling);
      }
      if (bt < gt.length) {
        for (dt = []; bt < gt.length; bt++) dt.push(ip(gt[bt]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (Tt.join(" > ") +
            `

No matching component was found for:
  `) +
          dt.join(" > ")
        );
      }
      return null;
    }),
    (nt.getPublicRootInstance = function (dt) {
      if (((dt = dt.current), !dt.child)) return null;
      switch (dt.child.tag) {
        case 5:
          return kt(dt.child.stateNode);
        default:
          return dt.child.stateNode;
      }
    }),
    (nt.injectIntoDevTools = function (dt) {
      if (
        ((dt = {
          bundleType: dt.bundleType,
          version: dt.version,
          rendererPackageName: dt.rendererPackageName,
          rendererConfig: dt.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: at.ReactCurrentDispatcher,
          findHostInstanceByFiber: _v,
          findFiberByHostInstance: dt.findFiberByHostInstance || xv,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        dt = !1;
      else {
        var gt = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (gt.isDisabled || !gt.supportsFiber) dt = !0;
        else {
          try {
            (Mo = gt.inject(dt)), (Bs = gt);
          } catch {}
          dt = !!gt.checkDCE;
        }
      }
      return dt;
    }),
    (nt.isAlreadyRendering = function () {
      return !1;
    }),
    (nt.observeVisibleRects = function (dt, gt, bt, Tt) {
      if (!Tn) throw Error(ot(363));
      dt = sp(dt, gt);
      var Lt = Cn(dt, bt, Tt).disconnect;
      return {
        disconnect: function () {
          Lt();
        },
      };
    }),
    (nt.registerMutableSourceForHydration = function (dt, gt) {
      var bt = gt._getVersion;
      (bt = bt(gt._source)),
        dt.mutableSourceEagerHydrationData == null
          ? (dt.mutableSourceEagerHydrationData = [gt, bt])
          : dt.mutableSourceEagerHydrationData.push(gt, bt);
    }),
    (nt.runWithPriority = function (dt, gt) {
      var bt = Tr;
      try {
        return (Tr = dt), gt();
      } finally {
        Tr = bt;
      }
    }),
    (nt.shouldError = function () {
      return null;
    }),
    (nt.shouldSuspend = function () {
      return !1;
    }),
    (nt.updateContainer = function (dt, gt, bt, Tt) {
      var Lt = gt.current,
        Ot = bs(),
        cn = _o(Lt);
      return (
        (bt = Hm(bt)),
        gt.context === null ? (gt.context = bt) : (gt.pendingContext = bt),
        (gt = ao(Ot, cn)),
        (gt.payload = { element: dt }),
        (Tt = Tt === void 0 ? null : Tt),
        Tt !== null && (gt.callback = Tt),
        go(Lt, gt),
        (dt = zs(Lt, cn, Ot)),
        dt !== null && Wl(dt, Lt, cn),
        cn
      );
    }),
    nt
  );
};
reactReconciler.exports = reactReconciler_production_min;
var reactReconcilerExports = reactReconciler.exports;
const Reconciler = getDefaultExportFromCjs(reactReconcilerExports),
  isPromise = (tt) => typeof tt == "object" && typeof tt.then == "function",
  globalCache = [];
function shallowEqualArrays(tt, et, nt = (rt, it) => rt === it) {
  if (tt === et) return !0;
  if (!tt || !et) return !1;
  const rt = tt.length;
  if (et.length !== rt) return !1;
  for (let it = 0; it < rt; it++) if (!nt(tt[it], et[it])) return !1;
  return !0;
}
function query(tt, et = null, nt = !1, rt = {}) {
  et === null && (et = [tt]);
  for (const st of globalCache)
    if (shallowEqualArrays(et, st.keys, st.equal)) {
      if (nt) return;
      if (Object.prototype.hasOwnProperty.call(st, "error")) throw st.error;
      if (Object.prototype.hasOwnProperty.call(st, "response"))
        return (
          rt.lifespan &&
            rt.lifespan > 0 &&
            (st.timeout && clearTimeout(st.timeout),
            (st.timeout = setTimeout(st.remove, rt.lifespan))),
          st.response
        );
      if (!nt) throw st.promise;
    }
  const it = {
    keys: et,
    equal: rt.equal,
    remove: () => {
      const st = globalCache.indexOf(it);
      st !== -1 && globalCache.splice(st, 1);
    },
    promise: (isPromise(tt) ? tt : tt(...et))
      .then((st) => {
        (it.response = st),
          rt.lifespan &&
            rt.lifespan > 0 &&
            (it.timeout = setTimeout(it.remove, rt.lifespan));
      })
      .catch((st) => (it.error = st)),
  };
  if ((globalCache.push(it), !nt)) throw it.promise;
}
const suspend = (tt, et, nt) => query(tt, et, !1, nt),
  preload = (tt, et, nt) => void query(tt, et, !0, nt),
  clear = (tt) => {
    if (tt === void 0 || tt.length === 0)
      globalCache.splice(0, globalCache.length);
    else {
      const et = globalCache.find((nt) =>
        shallowEqualArrays(tt, nt.keys, nt.equal)
      );
      et && et.remove();
    }
  },
  catalogue = {},
  extend = (tt) => void Object.assign(catalogue, tt);
function createRenderer(tt, et) {
  function nt(ut, { args: ft = [], attach: ht, ...mt }, vt) {
    let yt = `${ut[0].toUpperCase()}${ut.slice(1)}`,
      Et;
    if (ut === "primitive") {
      if (mt.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const pt = mt.object;
      Et = prepare$1(pt, { type: ut, root: vt, attach: ht, primitive: !0 });
    } else {
      const pt = catalogue[yt];
      if (!pt)
        throw new Error(
          `R3F: ${yt} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(ft))
        throw new Error("R3F: The args prop must be an array!");
      Et = prepare$1(new pt(...ft), {
        type: ut,
        root: vt,
        attach: ht,
        memoizedProps: { args: ft },
      });
    }
    return (
      Et.__r3f.attach === void 0 &&
        (Et instanceof BufferGeometry
          ? (Et.__r3f.attach = "geometry")
          : Et instanceof Material && (Et.__r3f.attach = "material")),
      yt !== "inject" && applyProps$1(Et, mt),
      Et
    );
  }
  function rt(ut, ft) {
    let ht = !1;
    if (ft) {
      var mt, vt;
      (mt = ft.__r3f) != null && mt.attach
        ? attach(ut, ft, ft.__r3f.attach)
        : ft.isObject3D && ut.isObject3D && (ut.add(ft), (ht = !0)),
        ht || (vt = ut.__r3f) == null || vt.objects.push(ft),
        ft.__r3f || prepare$1(ft, {}),
        (ft.__r3f.parent = ut),
        updateInstance(ft),
        invalidateInstance(ft);
    }
  }
  function it(ut, ft, ht) {
    let mt = !1;
    if (ft) {
      var vt, yt;
      if ((vt = ft.__r3f) != null && vt.attach) attach(ut, ft, ft.__r3f.attach);
      else if (ft.isObject3D && ut.isObject3D) {
        (ft.parent = ut), ft.dispatchEvent({ type: "added" });
        const Et = ut.children.filter((xt) => xt !== ft),
          pt = Et.indexOf(ht);
        (ut.children = [...Et.slice(0, pt), ft, ...Et.slice(pt)]), (mt = !0);
      }
      mt || (yt = ut.__r3f) == null || yt.objects.push(ft),
        ft.__r3f || prepare$1(ft, {}),
        (ft.__r3f.parent = ut),
        updateInstance(ft),
        invalidateInstance(ft);
    }
  }
  function st(ut, ft, ht = !1) {
    ut && [...ut].forEach((mt) => ot(ft, mt, ht));
  }
  function ot(ut, ft, ht) {
    if (ft) {
      var mt, vt, yt;
      if (
        (ft.__r3f && (ft.__r3f.parent = null),
        (mt = ut.__r3f) != null &&
          mt.objects &&
          (ut.__r3f.objects = ut.__r3f.objects.filter((At) => At !== ft)),
        (vt = ft.__r3f) != null && vt.attach)
      )
        detach(ut, ft, ft.__r3f.attach);
      else if (ft.isObject3D && ut.isObject3D) {
        var Et;
        ut.remove(ft),
          (Et = ft.__r3f) != null &&
            Et.root &&
            removeInteractivity(ft.__r3f.root, ft);
      }
      const xt = (yt = ft.__r3f) == null ? void 0 : yt.primitive,
        St = ht === void 0 ? ft.dispose !== null && !xt : ht;
      if (!xt) {
        var pt;
        st((pt = ft.__r3f) == null ? void 0 : pt.objects, ft, St),
          st(ft.children, ft, St);
      }
      delete ft.__r3f,
        St &&
          ft.dispose &&
          ft.type !== "Scene" &&
          schedulerExports.unstable_scheduleCallback(
            schedulerExports.unstable_IdlePriority,
            () => {
              try {
                ft.dispose();
              } catch {}
            }
          ),
        invalidateInstance(ut);
    }
  }
  function at(ut, ft, ht, mt) {
    var vt;
    const yt = (vt = ut.__r3f) == null ? void 0 : vt.parent;
    if (!yt) return;
    const Et = nt(ft, ht, ut.__r3f.root);
    if (ut.children) {
      for (const pt of ut.children) pt.__r3f && rt(Et, pt);
      ut.children = ut.children.filter((pt) => !pt.__r3f);
    }
    ut.__r3f.objects.forEach((pt) => rt(Et, pt)),
      (ut.__r3f.objects = []),
      ut.__r3f.autoRemovedBeforeAppend || ot(yt, ut),
      Et.parent && (Et.__r3f.autoRemovedBeforeAppend = !0),
      rt(yt, Et),
      Et.raycast &&
        Et.__r3f.eventCount &&
        Et.__r3f.root.getState().internal.interaction.push(Et),
      [mt, mt.alternate].forEach((pt) => {
        pt !== null &&
          ((pt.stateNode = Et),
          pt.ref &&
            (typeof pt.ref == "function" ? pt.ref(Et) : (pt.ref.current = Et)));
      });
  }
  const lt = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: Reconciler({
      createInstance: nt,
      removeChild: ot,
      appendChild: rt,
      appendInitialChild: rt,
      insertBefore: it,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (ut, ft) => {
        if (!ft) return;
        const ht = ut.getState().scene;
        ht.__r3f && ((ht.__r3f.root = ut), rt(ht, ft));
      },
      removeChildFromContainer: (ut, ft) => {
        ft && ot(ut.getState().scene, ft);
      },
      insertInContainerBefore: (ut, ft, ht) => {
        if (!ft || !ht) return;
        const mt = ut.getState().scene;
        mt.__r3f && it(mt, ft, ht);
      },
      getRootHostContext: () => null,
      getChildHostContext: (ut) => ut,
      finalizeInitialChildren(ut) {
        var ft;
        return !!((ft = ut == null ? void 0 : ut.__r3f) != null ? ft : {})
          .handlers;
      },
      prepareUpdate(ut, ft, ht, mt) {
        var vt;
        if (
          ((vt = ut == null ? void 0 : ut.__r3f) != null ? vt : {}).primitive &&
          mt.object &&
          mt.object !== ut
        )
          return [!0];
        {
          const { args: Et = [], children: pt, ...xt } = mt,
            { args: St = [], children: At, ...Ct } = ht;
          if (!Array.isArray(Et))
            throw new Error("R3F: the args prop must be an array!");
          if (Et.some((wt, Bt) => wt !== St[Bt])) return [!0];
          const Mt = diffProps(ut, xt, Ct, !0);
          return Mt.changes.length ? [!1, Mt] : null;
        }
      },
      commitUpdate(ut, [ft, ht], mt, vt, yt, Et) {
        ft ? at(ut, mt, yt, Et) : applyProps$1(ut, ht);
      },
      commitMount(ut, ft, ht, mt) {
        var vt;
        const yt = (vt = ut.__r3f) != null ? vt : {};
        ut.raycast &&
          yt.handlers &&
          yt.eventCount &&
          ut.__r3f.root.getState().internal.interaction.push(ut);
      },
      getPublicInstance: (ut) => ut,
      prepareForCommit: () => null,
      preparePortalMount: (ut) => prepare$1(ut.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(ut) {
        var ft;
        const { attach: ht, parent: mt } = (ft = ut.__r3f) != null ? ft : {};
        ht && mt && detach(mt, ut, ht),
          ut.isObject3D && (ut.visible = !1),
          invalidateInstance(ut);
      },
      unhideInstance(ut, ft) {
        var ht;
        const { attach: mt, parent: vt } = (ht = ut.__r3f) != null ? ht : {};
        mt && vt && attach(vt, ut, mt),
          ((ut.isObject3D && ft.visible == null) || ft.visible) &&
            (ut.visible = !0),
          invalidateInstance(ut);
      },
      createTextInstance: lt,
      hideTextInstance: lt,
      unhideTextInstance: lt,
      getCurrentEventPriority: () =>
        et ? et() : constantsExports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && is.fun(performance.now)
          ? performance.now
          : is.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: applyProps$1,
  };
}
var _window$document, _window$navigator;
const hasColorSpace = (tt) => "colorSpace" in tt || "outputColorSpace" in tt,
  getColorManagement = () => {
    var tt;
    return (tt = catalogue.ColorManagement) != null ? tt : null;
  },
  isOrthographicCamera = (tt) => tt && tt.isOrthographicCamera,
  isRef = (tt) => tt && tt.hasOwnProperty("current"),
  useIsomorphicLayoutEffect$1 =
    typeof window < "u" &&
    (((_window$document = window.document) != null &&
      _window$document.createElement) ||
      ((_window$navigator = window.navigator) == null
        ? void 0
        : _window$navigator.product) === "ReactNative")
      ? reactExports.useLayoutEffect
      : reactExports.useEffect;
function useMutableCallback(tt) {
  const et = reactExports.useRef(tt);
  return useIsomorphicLayoutEffect$1(() => void (et.current = tt), [tt]), et;
}
function Block({ set: tt }) {
  return (
    useIsomorphicLayoutEffect$1(
      () => (tt(new Promise(() => null)), () => tt(!1)),
      [tt]
    ),
    null
  );
}
class ErrorBoundary extends reactExports.Component {
  constructor(...et) {
    super(...et), (this.state = { error: !1 });
  }
  componentDidCatch(et) {
    this.props.set(et);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
ErrorBoundary.getDerivedStateFromError = () => ({ error: !0 });
const DEFAULT = "__default",
  DEFAULTS = new Map(),
  isDiffSet = (tt) => tt && !!tt.memoized && !!tt.changes;
function calculateDpr(tt) {
  var et;
  const nt =
    typeof window < "u" ? ((et = window.devicePixelRatio) != null ? et : 2) : 1;
  return Array.isArray(tt) ? Math.min(Math.max(tt[0], nt), tt[1]) : tt;
}
const getRootState = (tt) => {
    var et;
    return (et = tt.__r3f) == null ? void 0 : et.root.getState();
  },
  is = {
    obj: (tt) => tt === Object(tt) && !is.arr(tt) && typeof tt != "function",
    fun: (tt) => typeof tt == "function",
    str: (tt) => typeof tt == "string",
    num: (tt) => typeof tt == "number",
    boo: (tt) => typeof tt == "boolean",
    und: (tt) => tt === void 0,
    arr: (tt) => Array.isArray(tt),
    equ(
      tt,
      et,
      {
        arrays: nt = "shallow",
        objects: rt = "reference",
        strict: it = !0,
      } = {}
    ) {
      if (typeof tt != typeof et || !!tt != !!et) return !1;
      if (is.str(tt) || is.num(tt)) return tt === et;
      const st = is.obj(tt);
      if (st && rt === "reference") return tt === et;
      const ot = is.arr(tt);
      if (ot && nt === "reference") return tt === et;
      if ((ot || st) && tt === et) return !0;
      let at;
      for (at in tt) if (!(at in et)) return !1;
      if (st && nt === "shallow" && rt === "shallow") {
        for (at in it ? et : tt)
          if (!is.equ(tt[at], et[at], { strict: it, objects: "reference" }))
            return !1;
      } else for (at in it ? et : tt) if (tt[at] !== et[at]) return !1;
      if (is.und(at)) {
        if (
          (ot && tt.length === 0 && et.length === 0) ||
          (st && Object.keys(tt).length === 0 && Object.keys(et).length === 0)
        )
          return !0;
        if (tt !== et) return !1;
      }
      return !0;
    },
  };
function buildGraph(tt) {
  const et = { nodes: {}, materials: {} };
  return (
    tt &&
      tt.traverse((nt) => {
        nt.name && (et.nodes[nt.name] = nt),
          nt.material &&
            !et.materials[nt.material.name] &&
            (et.materials[nt.material.name] = nt.material);
      }),
    et
  );
}
function dispose(tt) {
  tt.dispose && tt.type !== "Scene" && tt.dispose();
  for (const et in tt) et.dispose == null || et.dispose(), delete tt[et];
}
function prepare$1(tt, et) {
  const nt = tt;
  return (
    (nt.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...et,
    }),
    tt
  );
}
function resolve(tt, et) {
  let nt = tt;
  if (et.includes("-")) {
    const rt = et.split("-"),
      it = rt.pop();
    return (nt = rt.reduce((st, ot) => st[ot], tt)), { target: nt, key: it };
  } else return { target: nt, key: et };
}
const INDEX_REGEX = /-\d+$/;
function attach(tt, et, nt) {
  if (is.str(nt)) {
    if (INDEX_REGEX.test(nt)) {
      const st = nt.replace(INDEX_REGEX, ""),
        { target: ot, key: at } = resolve(tt, st);
      Array.isArray(ot[at]) || (ot[at] = []);
    }
    const { target: rt, key: it } = resolve(tt, nt);
    (et.__r3f.previousAttach = rt[it]), (rt[it] = et);
  } else et.__r3f.previousAttach = nt(tt, et);
}
function detach(tt, et, nt) {
  var rt, it;
  if (is.str(nt)) {
    const { target: st, key: ot } = resolve(tt, nt),
      at = et.__r3f.previousAttach;
    at === void 0 ? delete st[ot] : (st[ot] = at);
  } else
    (rt = et.__r3f) == null ||
      rt.previousAttach == null ||
      rt.previousAttach(tt, et);
  (it = et.__r3f) == null || delete it.previousAttach;
}
function diffProps(
  tt,
  { children: et, key: nt, ref: rt, ...it },
  { children: st, key: ot, ref: at, ...lt } = {},
  ct = !1
) {
  var ut;
  const ft = (ut = tt == null ? void 0 : tt.__r3f) != null ? ut : {},
    ht = Object.entries(it),
    mt = [];
  if (ct) {
    const yt = Object.keys(lt);
    for (let Et = 0; Et < yt.length; Et++)
      it.hasOwnProperty(yt[Et]) || ht.unshift([yt[Et], DEFAULT + "remove"]);
  }
  ht.forEach(([yt, Et]) => {
    var pt;
    if (
      ((pt = tt.__r3f) != null && pt.primitive && yt === "object") ||
      is.equ(Et, lt[yt])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(yt))
      return mt.push([yt, Et, !0, []]);
    let xt = [];
    yt.includes("-") && (xt = yt.split("-")), mt.push([yt, Et, !1, xt]);
    for (const St in it) {
      const At = it[St];
      St.startsWith(`${yt}-`) && mt.push([St, At, !1, St.split("-")]);
    }
  });
  const vt = { ...it };
  return (
    ft.memoizedProps &&
      ft.memoizedProps.args &&
      (vt.args = ft.memoizedProps.args),
    ft.memoizedProps &&
      ft.memoizedProps.attach &&
      (vt.attach = ft.memoizedProps.attach),
    { memoized: vt, changes: mt }
  );
}
const __DEV__ = typeof process < "u" && !1;
function applyProps$1(tt, et) {
  var nt, rt, it;
  const st = (nt = tt.__r3f) != null ? nt : {},
    ot = st.root,
    at =
      (rt = ot == null || ot.getState == null ? void 0 : ot.getState()) != null
        ? rt
        : {},
    { memoized: lt, changes: ct } = isDiffSet(et) ? et : diffProps(tt, et),
    ut = st.eventCount;
  tt.__r3f && (tt.__r3f.memoizedProps = lt);
  for (let ht = 0; ht < ct.length; ht++) {
    let [mt, vt, yt, Et] = ct[ht];
    if (hasColorSpace(tt)) {
      const At = "srgb",
        Ct = "srgb-linear";
      mt === "encoding"
        ? ((mt = "colorSpace"), (vt = vt === 3001 ? At : Ct))
        : mt === "outputEncoding" &&
          ((mt = "outputColorSpace"), (vt = vt === 3001 ? At : Ct));
    }
    let pt = tt,
      xt = pt[mt];
    if (
      Et.length &&
      ((xt = Et.reduce((St, At) => St[At], tt)), !(xt && xt.set))
    ) {
      const [St, ...At] = Et.reverse();
      (pt = At.reverse().reduce((Ct, Mt) => Ct[Mt], tt)), (mt = St);
    }
    if (vt === DEFAULT + "remove")
      if (pt.constructor) {
        let St = DEFAULTS.get(pt.constructor);
        St || ((St = new pt.constructor()), DEFAULTS.set(pt.constructor, St)),
          (vt = St[mt]);
      } else vt = 0;
    if (yt)
      vt ? (st.handlers[mt] = vt) : delete st.handlers[mt],
        (st.eventCount = Object.keys(st.handlers).length);
    else if (xt && xt.set && (xt.copy || xt instanceof Layers)) {
      if (Array.isArray(vt)) xt.fromArray ? xt.fromArray(vt) : xt.set(...vt);
      else if (
        xt.copy &&
        vt &&
        vt.constructor &&
        (__DEV__
          ? xt.constructor.name === vt.constructor.name
          : xt.constructor === vt.constructor)
      )
        xt.copy(vt);
      else if (vt !== void 0) {
        const St = xt instanceof Color;
        !St && xt.setScalar
          ? xt.setScalar(vt)
          : xt instanceof Layers && vt instanceof Layers
          ? (xt.mask = vt.mask)
          : xt.set(vt),
          !getColorManagement() && !at.linear && St && xt.convertSRGBToLinear();
      }
    } else if (
      ((pt[mt] = vt),
      pt[mt] instanceof Texture &&
        pt[mt].format === RGBAFormat &&
        pt[mt].type === UnsignedByteType)
    ) {
      const St = pt[mt];
      hasColorSpace(St) && hasColorSpace(at.gl)
        ? (St.colorSpace = at.gl.outputColorSpace)
        : (St.encoding = at.gl.outputEncoding);
    }
    invalidateInstance(tt);
  }
  if (st.parent && at.internal && tt.raycast && ut !== st.eventCount) {
    const ht = at.internal.interaction.indexOf(tt);
    ht > -1 && at.internal.interaction.splice(ht, 1),
      st.eventCount && at.internal.interaction.push(tt);
  }
  return (
    !(ct.length === 1 && ct[0][0] === "onUpdate") &&
      ct.length &&
      (it = tt.__r3f) != null &&
      it.parent &&
      updateInstance(tt),
    tt
  );
}
function invalidateInstance(tt) {
  var et, nt;
  const rt =
    (et = tt.__r3f) == null || (nt = et.root) == null || nt.getState == null
      ? void 0
      : nt.getState();
  rt && rt.internal.frames === 0 && rt.invalidate();
}
function updateInstance(tt) {
  tt.onUpdate == null || tt.onUpdate(tt);
}
function updateCamera(tt, et) {
  tt.manual ||
    (isOrthographicCamera(tt)
      ? ((tt.left = et.width / -2),
        (tt.right = et.width / 2),
        (tt.top = et.height / 2),
        (tt.bottom = et.height / -2))
      : (tt.aspect = et.width / et.height),
    tt.updateProjectionMatrix(),
    tt.updateMatrixWorld());
}
function makeId(tt) {
  return (tt.eventObject || tt.object).uuid + "/" + tt.index + tt.instanceId;
}
function getEventPriority() {
  var tt;
  const et = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!et) return constantsExports.DefaultEventPriority;
  switch ((tt = et.event) == null ? void 0 : tt.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return constantsExports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return constantsExports.ContinuousEventPriority;
    default:
      return constantsExports.DefaultEventPriority;
  }
}
function releaseInternalPointerCapture(tt, et, nt, rt) {
  const it = nt.get(et);
  it &&
    (nt.delete(et),
    nt.size === 0 && (tt.delete(rt), it.target.releasePointerCapture(rt)));
}
function removeInteractivity(tt, et) {
  const { internal: nt } = tt.getState();
  (nt.interaction = nt.interaction.filter((rt) => rt !== et)),
    (nt.initialHits = nt.initialHits.filter((rt) => rt !== et)),
    nt.hovered.forEach((rt, it) => {
      (rt.eventObject === et || rt.object === et) && nt.hovered.delete(it);
    }),
    nt.capturedMap.forEach((rt, it) => {
      releaseInternalPointerCapture(nt.capturedMap, et, rt, it);
    });
}
function createEvents(tt) {
  function et(lt) {
    const { internal: ct } = tt.getState(),
      ut = lt.offsetX - ct.initialClick[0],
      ft = lt.offsetY - ct.initialClick[1];
    return Math.round(Math.sqrt(ut * ut + ft * ft));
  }
  function nt(lt) {
    return lt.filter((ct) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((ut) => {
        var ft;
        return (ft = ct.__r3f) == null ? void 0 : ft.handlers["onPointer" + ut];
      })
    );
  }
  function rt(lt, ct) {
    const ut = tt.getState(),
      ft = new Set(),
      ht = [],
      mt = ct ? ct(ut.internal.interaction) : ut.internal.interaction;
    for (let pt = 0; pt < mt.length; pt++) {
      const xt = getRootState(mt[pt]);
      xt && (xt.raycaster.camera = void 0);
    }
    ut.previousRoot || ut.events.compute == null || ut.events.compute(lt, ut);
    function vt(pt) {
      const xt = getRootState(pt);
      if (!xt || !xt.events.enabled || xt.raycaster.camera === null) return [];
      if (xt.raycaster.camera === void 0) {
        var St;
        xt.events.compute == null ||
          xt.events.compute(
            lt,
            xt,
            (St = xt.previousRoot) == null ? void 0 : St.getState()
          ),
          xt.raycaster.camera === void 0 && (xt.raycaster.camera = null);
      }
      return xt.raycaster.camera ? xt.raycaster.intersectObject(pt, !0) : [];
    }
    let yt = mt
      .flatMap(vt)
      .sort((pt, xt) => {
        const St = getRootState(pt.object),
          At = getRootState(xt.object);
        return !St || !At
          ? pt.distance - xt.distance
          : At.events.priority - St.events.priority ||
              pt.distance - xt.distance;
      })
      .filter((pt) => {
        const xt = makeId(pt);
        return ft.has(xt) ? !1 : (ft.add(xt), !0);
      });
    ut.events.filter && (yt = ut.events.filter(yt, ut));
    for (const pt of yt) {
      let xt = pt.object;
      for (; xt; ) {
        var Et;
        (Et = xt.__r3f) != null &&
          Et.eventCount &&
          ht.push({ ...pt, eventObject: xt }),
          (xt = xt.parent);
      }
    }
    if ("pointerId" in lt && ut.internal.capturedMap.has(lt.pointerId))
      for (let pt of ut.internal.capturedMap.get(lt.pointerId).values())
        ft.has(makeId(pt.intersection)) || ht.push(pt.intersection);
    return ht;
  }
  function it(lt, ct, ut, ft) {
    const ht = tt.getState();
    if (lt.length) {
      const mt = { stopped: !1 };
      for (const vt of lt) {
        const yt = getRootState(vt.object) || ht,
          { raycaster: Et, pointer: pt, camera: xt, internal: St } = yt,
          At = new Vector3(pt.x, pt.y, 0).unproject(xt),
          Ct = (Ft) => {
            var Vt, $t;
            return (Vt =
              ($t = St.capturedMap.get(Ft)) == null
                ? void 0
                : $t.has(vt.eventObject)) != null
              ? Vt
              : !1;
          },
          Mt = (Ft) => {
            const Vt = { intersection: vt, target: ct.target };
            St.capturedMap.has(Ft)
              ? St.capturedMap.get(Ft).set(vt.eventObject, Vt)
              : St.capturedMap.set(Ft, new Map([[vt.eventObject, Vt]])),
              ct.target.setPointerCapture(Ft);
          },
          wt = (Ft) => {
            const Vt = St.capturedMap.get(Ft);
            Vt &&
              releaseInternalPointerCapture(
                St.capturedMap,
                vt.eventObject,
                Vt,
                Ft
              );
          };
        let Bt = {};
        for (let Ft in ct) {
          let Vt = ct[Ft];
          typeof Vt != "function" && (Bt[Ft] = Vt);
        }
        let It = {
          ...vt,
          ...Bt,
          pointer: pt,
          intersections: lt,
          stopped: mt.stopped,
          delta: ut,
          unprojectedPoint: At,
          ray: Et.ray,
          camera: xt,
          stopPropagation() {
            const Ft = "pointerId" in ct && St.capturedMap.get(ct.pointerId);
            if (
              (!Ft || Ft.has(vt.eventObject)) &&
              ((It.stopped = mt.stopped = !0),
              St.hovered.size &&
                Array.from(St.hovered.values()).find(
                  (Vt) => Vt.eventObject === vt.eventObject
                ))
            ) {
              const Vt = lt.slice(0, lt.indexOf(vt));
              st([...Vt, vt]);
            }
          },
          target: {
            hasPointerCapture: Ct,
            setPointerCapture: Mt,
            releasePointerCapture: wt,
          },
          currentTarget: {
            hasPointerCapture: Ct,
            setPointerCapture: Mt,
            releasePointerCapture: wt,
          },
          nativeEvent: ct,
        };
        if ((ft(It), mt.stopped === !0)) break;
      }
    }
    return lt;
  }
  function st(lt) {
    const { internal: ct } = tt.getState();
    for (const ut of ct.hovered.values())
      if (
        !lt.length ||
        !lt.find(
          (ft) =>
            ft.object === ut.object &&
            ft.index === ut.index &&
            ft.instanceId === ut.instanceId
        )
      ) {
        const ht = ut.eventObject.__r3f,
          mt = ht == null ? void 0 : ht.handlers;
        if ((ct.hovered.delete(makeId(ut)), ht != null && ht.eventCount)) {
          const vt = { ...ut, intersections: lt };
          mt.onPointerOut == null || mt.onPointerOut(vt),
            mt.onPointerLeave == null || mt.onPointerLeave(vt);
        }
      }
  }
  function ot(lt, ct) {
    for (let ut = 0; ut < ct.length; ut++) {
      const ft = ct[ut].__r3f;
      ft == null ||
        ft.handlers.onPointerMissed == null ||
        ft.handlers.onPointerMissed(lt);
    }
  }
  function at(lt) {
    switch (lt) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => st([]);
      case "onLostPointerCapture":
        return (ct) => {
          const { internal: ut } = tt.getState();
          "pointerId" in ct &&
            ut.capturedMap.has(ct.pointerId) &&
            requestAnimationFrame(() => {
              ut.capturedMap.has(ct.pointerId) &&
                (ut.capturedMap.delete(ct.pointerId), st([]));
            });
        };
    }
    return function (ut) {
      const { onPointerMissed: ft, internal: ht } = tt.getState();
      ht.lastEvent.current = ut;
      const mt = lt === "onPointerMove",
        vt =
          lt === "onClick" || lt === "onContextMenu" || lt === "onDoubleClick",
        Et = rt(ut, mt ? nt : void 0),
        pt = vt ? et(ut) : 0;
      lt === "onPointerDown" &&
        ((ht.initialClick = [ut.offsetX, ut.offsetY]),
        (ht.initialHits = Et.map((St) => St.eventObject))),
        vt && !Et.length && pt <= 2 && (ot(ut, ht.interaction), ft && ft(ut)),
        mt && st(Et);
      function xt(St) {
        const At = St.eventObject,
          Ct = At.__r3f,
          Mt = Ct == null ? void 0 : Ct.handlers;
        if (Ct != null && Ct.eventCount)
          if (mt) {
            if (
              Mt.onPointerOver ||
              Mt.onPointerEnter ||
              Mt.onPointerOut ||
              Mt.onPointerLeave
            ) {
              const wt = makeId(St),
                Bt = ht.hovered.get(wt);
              Bt
                ? Bt.stopped && St.stopPropagation()
                : (ht.hovered.set(wt, St),
                  Mt.onPointerOver == null || Mt.onPointerOver(St),
                  Mt.onPointerEnter == null || Mt.onPointerEnter(St));
            }
            Mt.onPointerMove == null || Mt.onPointerMove(St);
          } else {
            const wt = Mt[lt];
            wt
              ? (!vt || ht.initialHits.includes(At)) &&
                (ot(
                  ut,
                  ht.interaction.filter((Bt) => !ht.initialHits.includes(Bt))
                ),
                wt(St))
              : vt &&
                ht.initialHits.includes(At) &&
                ot(
                  ut,
                  ht.interaction.filter((Bt) => !ht.initialHits.includes(Bt))
                );
          }
      }
      it(Et, ut, pt, xt);
    };
  }
  return { handlePointer: at };
}
const isRenderer = (tt) => !!(tt != null && tt.render),
  context = reactExports.createContext(null),
  createStore$1 = (tt, et) => {
    const nt = create((at, lt) => {
        const ct = new Vector3(),
          ut = new Vector3(),
          ft = new Vector3();
        function ht(pt = lt().camera, xt = ut, St = lt().size) {
          const { width: At, height: Ct, top: Mt, left: wt } = St,
            Bt = At / Ct;
          xt instanceof Vector3 ? ft.copy(xt) : ft.set(...xt);
          const It = pt.getWorldPosition(ct).distanceTo(ft);
          if (isOrthographicCamera(pt))
            return {
              width: At / pt.zoom,
              height: Ct / pt.zoom,
              top: Mt,
              left: wt,
              factor: 1,
              distance: It,
              aspect: Bt,
            };
          {
            const Ft = (pt.fov * Math.PI) / 180,
              Vt = 2 * Math.tan(Ft / 2) * It,
              $t = Vt * (At / Ct);
            return {
              width: $t,
              height: Vt,
              top: Mt,
              left: wt,
              factor: At / $t,
              distance: It,
              aspect: Bt,
            };
          }
        }
        let mt;
        const vt = (pt) =>
            at((xt) => ({ performance: { ...xt.performance, current: pt } })),
          yt = new Vector2();
        return {
          set: at,
          get: lt,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (pt = 1) => tt(lt(), pt),
          advance: (pt, xt) => et(pt, xt, lt()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Clock(),
          pointer: yt,
          mouse: yt,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const pt = lt();
              mt && clearTimeout(mt),
                pt.performance.current !== pt.performance.min &&
                  vt(pt.performance.min),
                (mt = setTimeout(
                  () => vt(lt().performance.max),
                  pt.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: ht,
          },
          setEvents: (pt) =>
            at((xt) => ({ ...xt, events: { ...xt.events, ...pt } })),
          setSize: (pt, xt, St, At, Ct) => {
            const Mt = lt().camera,
              wt = {
                width: pt,
                height: xt,
                top: At || 0,
                left: Ct || 0,
                updateStyle: St,
              };
            at((Bt) => ({
              size: wt,
              viewport: { ...Bt.viewport, ...ht(Mt, ut, wt) },
            }));
          },
          setDpr: (pt) =>
            at((xt) => {
              const St = calculateDpr(pt);
              return {
                viewport: {
                  ...xt.viewport,
                  dpr: St,
                  initialDpr: xt.viewport.initialDpr || St,
                },
              };
            }),
          setFrameloop: (pt = "always") => {
            const xt = lt().clock;
            xt.stop(),
              (xt.elapsedTime = 0),
              pt !== "never" && (xt.start(), (xt.elapsedTime = 0)),
              at(() => ({ frameloop: pt }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: reactExports.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (pt, xt, St) => {
              const At = lt().internal;
              return (
                (At.priority = At.priority + (xt > 0 ? 1 : 0)),
                At.subscribers.push({ ref: pt, priority: xt, store: St }),
                (At.subscribers = At.subscribers.sort(
                  (Ct, Mt) => Ct.priority - Mt.priority
                )),
                () => {
                  const Ct = lt().internal;
                  Ct != null &&
                    Ct.subscribers &&
                    ((Ct.priority = Ct.priority - (xt > 0 ? 1 : 0)),
                    (Ct.subscribers = Ct.subscribers.filter(
                      (Mt) => Mt.ref !== pt
                    )));
                }
              );
            },
          },
        };
      }),
      rt = nt.getState();
    let it = rt.size,
      st = rt.viewport.dpr,
      ot = rt.camera;
    return (
      nt.subscribe(() => {
        const {
          camera: at,
          size: lt,
          viewport: ct,
          gl: ut,
          set: ft,
        } = nt.getState();
        if (lt.width !== it.width || lt.height !== it.height || ct.dpr !== st) {
          var ht;
          (it = lt),
            (st = ct.dpr),
            updateCamera(at, lt),
            ut.setPixelRatio(ct.dpr);
          const mt =
            (ht = lt.updateStyle) != null
              ? ht
              : typeof HTMLCanvasElement < "u" &&
                ut.domElement instanceof HTMLCanvasElement;
          ut.setSize(lt.width, lt.height, mt);
        }
        at !== ot &&
          ((ot = at),
          ft((mt) => ({
            viewport: { ...mt.viewport, ...mt.viewport.getCurrentViewport(at) },
          })));
      }),
      nt.subscribe((at) => tt(at)),
      nt
    );
  };
let i$1,
  globalEffects = new Set(),
  globalAfterEffects = new Set(),
  globalTailEffects = new Set();
function run(tt, et) {
  if (tt.size) for (const { callback: nt } of tt.values()) nt(et);
}
function flushGlobalEffects(tt, et) {
  switch (tt) {
    case "before":
      return run(globalEffects, et);
    case "after":
      return run(globalAfterEffects, et);
    case "tail":
      return run(globalTailEffects, et);
  }
}
let subscribers, subscription;
function render$1(tt, et, nt) {
  let rt = et.clock.getDelta();
  for (
    et.frameloop === "never" &&
      typeof tt == "number" &&
      ((rt = tt - et.clock.elapsedTime),
      (et.clock.oldTime = et.clock.elapsedTime),
      (et.clock.elapsedTime = tt)),
      subscribers = et.internal.subscribers,
      i$1 = 0;
    i$1 < subscribers.length;
    i$1++
  )
    (subscription = subscribers[i$1]),
      subscription.ref.current(subscription.store.getState(), rt, nt);
  return (
    !et.internal.priority && et.gl.render && et.gl.render(et.scene, et.camera),
    (et.internal.frames = Math.max(0, et.internal.frames - 1)),
    et.frameloop === "always" ? 1 : et.internal.frames
  );
}
function createLoop(tt) {
  let et = !1,
    nt,
    rt,
    it;
  function st(lt) {
    (rt = requestAnimationFrame(st)),
      (et = !0),
      (nt = 0),
      flushGlobalEffects("before", lt);
    for (const ut of tt.values()) {
      var ct;
      (it = ut.store.getState()),
        it.internal.active &&
          (it.frameloop === "always" || it.internal.frames > 0) &&
          !((ct = it.gl.xr) != null && ct.isPresenting) &&
          (nt += render$1(lt, it));
    }
    if ((flushGlobalEffects("after", lt), nt === 0))
      return (
        flushGlobalEffects("tail", lt), (et = !1), cancelAnimationFrame(rt)
      );
  }
  function ot(lt, ct = 1) {
    var ut;
    if (!lt) return tt.forEach((ft) => ot(ft.store.getState()), ct);
    ((ut = lt.gl.xr) != null && ut.isPresenting) ||
      !lt.internal.active ||
      lt.frameloop === "never" ||
      ((lt.internal.frames = Math.min(60, lt.internal.frames + ct)),
      et || ((et = !0), requestAnimationFrame(st)));
  }
  function at(lt, ct = !0, ut, ft) {
    if ((ct && flushGlobalEffects("before", lt), ut)) render$1(lt, ut, ft);
    else for (const ht of tt.values()) render$1(lt, ht.store.getState());
    ct && flushGlobalEffects("after", lt);
  }
  return { loop: st, invalidate: ot, advance: at };
}
function useStore$1() {
  const tt = reactExports.useContext(context);
  if (!tt)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return tt;
}
function useThree(tt = (nt) => nt, et) {
  return useStore$1()(tt, et);
}
function useFrame(tt, et = 0) {
  const nt = useStore$1(),
    rt = nt.getState().internal.subscribe,
    it = useMutableCallback(tt);
  return useIsomorphicLayoutEffect$1(() => rt(it, et, nt), [et, rt, nt]), null;
}
const memoizedLoaders = new WeakMap();
function loadingFn(tt, et) {
  return function (nt, ...rt) {
    let it = memoizedLoaders.get(nt);
    return (
      it || ((it = new nt()), memoizedLoaders.set(nt, it)),
      tt && tt(it),
      Promise.all(
        rt.map(
          (st) =>
            new Promise((ot, at) =>
              it.load(
                st,
                (lt) => {
                  lt.scene && Object.assign(lt, buildGraph(lt.scene)), ot(lt);
                },
                et,
                (lt) =>
                  at(
                    new Error(
                      `Could not load ${st}: ${
                        lt == null ? void 0 : lt.message
                      }`
                    )
                  )
              )
            )
        )
      ).finally(() => (it.dispose == null ? void 0 : it.dispose()))
    );
  };
}
function useLoader(tt, et, nt, rt) {
  const it = Array.isArray(et) ? et : [et],
    st = suspend(loadingFn(nt, rt), [tt, ...it], { equal: is.equ });
  return Array.isArray(et) ? st : st[0];
}
useLoader.preload = function (tt, et, nt) {
  const rt = Array.isArray(et) ? et : [et];
  return preload(loadingFn(nt), [tt, ...rt]);
};
useLoader.clear = function (tt, et) {
  const nt = Array.isArray(et) ? et : [et];
  return clear([tt, ...nt]);
};
const roots = new Map(),
  { invalidate, advance } = createLoop(roots),
  { reconciler, applyProps } = createRenderer(roots, getEventPriority),
  shallowLoose = { objects: "shallow", strict: !1 },
  createRendererInstance = (tt, et) => {
    const nt = typeof tt == "function" ? tt(et) : tt;
    return isRenderer(nt)
      ? nt
      : new WebGLRenderer({
          powerPreference: "high-performance",
          canvas: et,
          antialias: !0,
          alpha: !0,
          ...tt,
        });
  };
function computeInitialSize(tt, et) {
  const nt = typeof HTMLCanvasElement < "u" && tt instanceof HTMLCanvasElement;
  if (et) {
    const {
      width: rt,
      height: it,
      top: st,
      left: ot,
      updateStyle: at = nt,
    } = et;
    return { width: rt, height: it, top: st, left: ot, updateStyle: at };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    tt instanceof HTMLCanvasElement &&
    tt.parentElement
  ) {
    const {
      width: rt,
      height: it,
      top: st,
      left: ot,
    } = tt.parentElement.getBoundingClientRect();
    return { width: rt, height: it, top: st, left: ot, updateStyle: nt };
  } else if (typeof OffscreenCanvas < "u" && tt instanceof OffscreenCanvas)
    return {
      width: tt.width,
      height: tt.height,
      top: 0,
      left: 0,
      updateStyle: nt,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function createRoot(tt) {
  const et = roots.get(tt),
    nt = et == null ? void 0 : et.fiber,
    rt = et == null ? void 0 : et.store;
  et && console.warn("R3F.createRoot should only be called once!");
  const it = typeof reportError == "function" ? reportError : console.error,
    st = rt || createStore$1(invalidate, advance),
    ot =
      nt ||
      reconciler.createContainer(
        st,
        constantsExports.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        it,
        null
      );
  et || roots.set(tt, { fiber: ot, store: st });
  let at,
    lt = !1,
    ct;
  return {
    configure(ut = {}) {
      let {
          gl: ft,
          size: ht,
          scene: mt,
          events: vt,
          onCreated: yt,
          shadows: Et = !1,
          linear: pt = !1,
          flat: xt = !1,
          legacy: St = !1,
          orthographic: At = !1,
          frameloop: Ct = "always",
          dpr: Mt = [1, 2],
          performance: wt,
          raycaster: Bt,
          camera: It,
          onPointerMissed: Ft,
        } = ut,
        Vt = st.getState(),
        $t = Vt.gl;
      Vt.gl || Vt.set({ gl: ($t = createRendererInstance(ft, tt)) });
      let Kt = Vt.raycaster;
      Kt || Vt.set({ raycaster: (Kt = new Raycaster()) });
      const { params: Ht, ...Wt } = Bt || {};
      if (
        (is.equ(Wt, Kt, shallowLoose) || applyProps(Kt, { ...Wt }),
        is.equ(Ht, Kt.params, shallowLoose) ||
          applyProps(Kt, { params: { ...Kt.params, ...Ht } }),
        !Vt.camera || (Vt.camera === ct && !is.equ(ct, It, shallowLoose)))
      ) {
        ct = It;
        const zt = It instanceof Camera,
          Yt = zt
            ? It
            : At
            ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3)
            : new PerspectiveCamera(75, 0, 0.1, 1e3);
        zt ||
          ((Yt.position.z = 5),
          It && applyProps(Yt, It),
          !Vt.camera && !(It != null && It.rotation) && Yt.lookAt(0, 0, 0)),
          Vt.set({ camera: Yt }),
          (Kt.camera = Yt);
      }
      if (!Vt.scene) {
        let zt;
        mt instanceof Scene$1
          ? (zt = mt)
          : ((zt = new Scene$1()), mt && applyProps(zt, mt)),
          Vt.set({ scene: prepare$1(zt) });
      }
      if (!Vt.xr) {
        var kt;
        const zt = (Zt, Jt) => {
            const mn = st.getState();
            mn.frameloop !== "never" && advance(Zt, !0, mn, Jt);
          },
          Yt = () => {
            const Zt = st.getState();
            (Zt.gl.xr.enabled = Zt.gl.xr.isPresenting),
              Zt.gl.xr.setAnimationLoop(Zt.gl.xr.isPresenting ? zt : null),
              Zt.gl.xr.isPresenting || invalidate(Zt);
          },
          qt = {
            connect() {
              const Zt = st.getState().gl;
              Zt.xr.addEventListener("sessionstart", Yt),
                Zt.xr.addEventListener("sessionend", Yt);
            },
            disconnect() {
              const Zt = st.getState().gl;
              Zt.xr.removeEventListener("sessionstart", Yt),
                Zt.xr.removeEventListener("sessionend", Yt);
            },
          };
        typeof ((kt = $t.xr) == null ? void 0 : kt.addEventListener) ==
          "function" && qt.connect(),
          Vt.set({ xr: qt });
      }
      if ($t.shadowMap) {
        const zt = $t.shadowMap.enabled,
          Yt = $t.shadowMap.type;
        if ((($t.shadowMap.enabled = !!Et), is.boo(Et)))
          $t.shadowMap.type = PCFSoftShadowMap;
        else if (is.str(Et)) {
          var Gt;
          const qt = {
            basic: BasicShadowMap,
            percentage: PCFShadowMap,
            soft: PCFSoftShadowMap,
            variance: VSMShadowMap,
          };
          $t.shadowMap.type = (Gt = qt[Et]) != null ? Gt : PCFSoftShadowMap;
        } else is.obj(Et) && Object.assign($t.shadowMap, Et);
        (zt !== $t.shadowMap.enabled || Yt !== $t.shadowMap.type) &&
          ($t.shadowMap.needsUpdate = !0);
      }
      const Pt = getColorManagement();
      Pt &&
        ("enabled" in Pt
          ? (Pt.enabled = !St)
          : "legacyMode" in Pt && (Pt.legacyMode = St)),
        applyProps($t, {
          outputEncoding: pt ? 3e3 : 3001,
          toneMapping: xt ? NoToneMapping : ACESFilmicToneMapping,
        }),
        Vt.legacy !== St && Vt.set(() => ({ legacy: St })),
        Vt.linear !== pt && Vt.set(() => ({ linear: pt })),
        Vt.flat !== xt && Vt.set(() => ({ flat: xt })),
        ft &&
          !is.fun(ft) &&
          !isRenderer(ft) &&
          !is.equ(ft, $t, shallowLoose) &&
          applyProps($t, ft),
        vt && !Vt.events.handlers && Vt.set({ events: vt(st) });
      const Dt = computeInitialSize(tt, ht);
      return (
        is.equ(Dt, Vt.size, shallowLoose) ||
          Vt.setSize(Dt.width, Dt.height, Dt.updateStyle, Dt.top, Dt.left),
        Mt && Vt.viewport.dpr !== calculateDpr(Mt) && Vt.setDpr(Mt),
        Vt.frameloop !== Ct && Vt.setFrameloop(Ct),
        Vt.onPointerMissed || Vt.set({ onPointerMissed: Ft }),
        wt &&
          !is.equ(wt, Vt.performance, shallowLoose) &&
          Vt.set((zt) => ({ performance: { ...zt.performance, ...wt } })),
        (at = yt),
        (lt = !0),
        this
      );
    },
    render(ut) {
      return (
        lt || this.configure(),
        reconciler.updateContainer(
          reactExports.createElement(Provider$1, {
            store: st,
            children: ut,
            onCreated: at,
            rootElement: tt,
          }),
          ot,
          null,
          () => {}
        ),
        st
      );
    },
    unmount() {
      unmountComponentAtNode(tt);
    },
  };
}
function Provider$1({
  store: tt,
  children: et,
  onCreated: nt,
  rootElement: rt,
}) {
  return (
    useIsomorphicLayoutEffect$1(() => {
      const it = tt.getState();
      it.set((st) => ({ internal: { ...st.internal, active: !0 } })),
        nt && nt(it),
        tt.getState().events.connected ||
          it.events.connect == null ||
          it.events.connect(rt);
    }, []),
    reactExports.createElement(context.Provider, { value: tt }, et)
  );
}
function unmountComponentAtNode(tt, et) {
  const nt = roots.get(tt),
    rt = nt == null ? void 0 : nt.fiber;
  if (rt) {
    const it = nt == null ? void 0 : nt.store.getState();
    it && (it.internal.active = !1),
      reconciler.updateContainer(null, rt, null, () => {
        it &&
          setTimeout(() => {
            try {
              var st, ot, at, lt;
              it.events.disconnect == null || it.events.disconnect(),
                (st = it.gl) == null ||
                  (ot = st.renderLists) == null ||
                  ot.dispose == null ||
                  ot.dispose(),
                (at = it.gl) == null ||
                  at.forceContextLoss == null ||
                  at.forceContextLoss(),
                (lt = it.gl) != null && lt.xr && it.xr.disconnect(),
                dispose(it),
                roots.delete(tt),
                et && et(tt);
            } catch {}
          }, 500);
      });
  }
}
reconciler.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: reactExports.version,
});
function _extends() {
  return (
    (_extends = Object.assign
      ? Object.assign.bind()
      : function (tt) {
          for (var et = 1; et < arguments.length; et++) {
            var nt = arguments[et];
            for (var rt in nt)
              Object.prototype.hasOwnProperty.call(nt, rt) && (tt[rt] = nt[rt]);
          }
          return tt;
        }),
    _extends.apply(this, arguments)
  );
}
function debounce$1(tt, et, nt) {
  var rt, it, st, ot, at;
  et == null && (et = 100);
  function lt() {
    var ut = Date.now() - ot;
    ut < et && ut >= 0
      ? (rt = setTimeout(lt, et - ut))
      : ((rt = null), nt || ((at = tt.apply(st, it)), (st = it = null)));
  }
  var ct = function () {
    (st = this), (it = arguments), (ot = Date.now());
    var ut = nt && !rt;
    return (
      rt || (rt = setTimeout(lt, et)),
      ut && ((at = tt.apply(st, it)), (st = it = null)),
      at
    );
  };
  return (
    (ct.clear = function () {
      rt && (clearTimeout(rt), (rt = null));
    }),
    (ct.flush = function () {
      rt &&
        ((at = tt.apply(st, it)),
        (st = it = null),
        clearTimeout(rt),
        (rt = null));
    }),
    ct
  );
}
debounce$1.debounce = debounce$1;
var debounce_1 = debounce$1;
const createDebounce = getDefaultExportFromCjs(debounce_1);
function useMeasure(tt) {
  let {
    debounce: et,
    scroll: nt,
    polyfill: rt,
    offsetSize: it,
  } = tt === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : tt;
  const st = rt || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!st)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [ot, at] = reactExports.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    lt = reactExports.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: ot,
    }),
    ct = et ? (typeof et == "number" ? et : et.scroll) : null,
    ut = et ? (typeof et == "number" ? et : et.resize) : null,
    ft = reactExports.useRef(!1);
  reactExports.useEffect(
    () => ((ft.current = !0), () => void (ft.current = !1))
  );
  const [ht, mt, vt] = reactExports.useMemo(() => {
    const xt = () => {
      if (!lt.current.element) return;
      const {
          left: St,
          top: At,
          width: Ct,
          height: Mt,
          bottom: wt,
          right: Bt,
          x: It,
          y: Ft,
        } = lt.current.element.getBoundingClientRect(),
        Vt = {
          left: St,
          top: At,
          width: Ct,
          height: Mt,
          bottom: wt,
          right: Bt,
          x: It,
          y: Ft,
        };
      lt.current.element instanceof HTMLElement &&
        it &&
        ((Vt.height = lt.current.element.offsetHeight),
        (Vt.width = lt.current.element.offsetWidth)),
        Object.freeze(Vt),
        ft.current &&
          !areBoundsEqual(lt.current.lastBounds, Vt) &&
          at((lt.current.lastBounds = Vt));
    };
    return [
      xt,
      ut ? createDebounce(xt, ut) : xt,
      ct ? createDebounce(xt, ct) : xt,
    ];
  }, [at, it, ct, ut]);
  function yt() {
    lt.current.scrollContainers &&
      (lt.current.scrollContainers.forEach((xt) =>
        xt.removeEventListener("scroll", vt, !0)
      ),
      (lt.current.scrollContainers = null)),
      lt.current.resizeObserver &&
        (lt.current.resizeObserver.disconnect(),
        (lt.current.resizeObserver = null));
  }
  function Et() {
    lt.current.element &&
      ((lt.current.resizeObserver = new st(vt)),
      lt.current.resizeObserver.observe(lt.current.element),
      nt &&
        lt.current.scrollContainers &&
        lt.current.scrollContainers.forEach((xt) =>
          xt.addEventListener("scroll", vt, { capture: !0, passive: !0 })
        ));
  }
  const pt = (xt) => {
    !xt ||
      xt === lt.current.element ||
      (yt(),
      (lt.current.element = xt),
      (lt.current.scrollContainers = findScrollContainers(xt)),
      Et());
  };
  return (
    useOnWindowScroll(vt, !!nt),
    useOnWindowResize(mt),
    reactExports.useEffect(() => {
      yt(), Et();
    }, [nt, vt, mt]),
    reactExports.useEffect(() => yt, []),
    [pt, ot, ht]
  );
}
function useOnWindowResize(tt) {
  reactExports.useEffect(() => {
    const et = tt;
    return (
      window.addEventListener("resize", et),
      () => void window.removeEventListener("resize", et)
    );
  }, [tt]);
}
function useOnWindowScroll(tt, et) {
  reactExports.useEffect(() => {
    if (et) {
      const nt = tt;
      return (
        window.addEventListener("scroll", nt, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", nt, !0)
      );
    }
  }, [tt, et]);
}
function findScrollContainers(tt) {
  const et = [];
  if (!tt || tt === document.body) return et;
  const {
    overflow: nt,
    overflowX: rt,
    overflowY: it,
  } = window.getComputedStyle(tt);
  return (
    [nt, rt, it].some((st) => st === "auto" || st === "scroll") && et.push(tt),
    [...et, ...findScrollContainers(tt.parentElement)]
  );
}
const keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  areBoundsEqual = (tt, et) => keys.every((nt) => tt[nt] === et[nt]);
var __defProp$8 = Object.defineProperty,
  __defProps$1 = Object.defineProperties,
  __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols$1 = Object.getOwnPropertySymbols,
  __hasOwnProp$1 = Object.prototype.hasOwnProperty,
  __propIsEnum$1 = Object.prototype.propertyIsEnumerable,
  __defNormalProp$8 = (tt, et, nt) =>
    et in tt
      ? __defProp$8(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __spreadValues$1 = (tt, et) => {
    for (var nt in et || (et = {}))
      __hasOwnProp$1.call(et, nt) && __defNormalProp$8(tt, nt, et[nt]);
    if (__getOwnPropSymbols$1)
      for (var nt of __getOwnPropSymbols$1(et))
        __propIsEnum$1.call(et, nt) && __defNormalProp$8(tt, nt, et[nt]);
    return tt;
  },
  __spreadProps$1 = (tt, et) => __defProps$1(tt, __getOwnPropDescs$1(et));
function traverseFiber(tt, et, nt) {
  if (!tt) return;
  if (nt(tt) === !0) return tt;
  let rt = et ? tt.return : tt.child;
  for (; rt; ) {
    const it = traverseFiber(rt, et, nt);
    if (it) return it;
    rt = et ? null : rt.sibling;
  }
}
function wrapContext(tt) {
  try {
    return Object.defineProperties(tt, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return tt;
  }
}
const FiberContext = wrapContext(reactExports.createContext(null));
class FiberProvider extends reactExports.Component {
  render() {
    return reactExports.createElement(
      FiberContext.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner, ReactCurrentDispatcher } =
  reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function useFiber() {
  const tt = reactExports.useContext(FiberContext);
  if (tt === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const et = reactExports.useId();
  return reactExports.useMemo(() => {
    for (const rt of [
      ReactCurrentOwner == null ? void 0 : ReactCurrentOwner.current,
      tt,
      tt == null ? void 0 : tt.alternate,
    ]) {
      if (!rt) continue;
      const it = traverseFiber(rt, !1, (st) => {
        let ot = st.memoizedState;
        for (; ot; ) {
          if (ot.memoizedState === et) return !0;
          ot = ot.next;
        }
      });
      if (it) return it;
    }
  }, [tt, et]);
}
function useContextMap() {
  var tt, et;
  const nt = useFiber(),
    [rt] = reactExports.useState(() => new Map());
  rt.clear();
  let it = nt;
  for (; it; ) {
    const st = (tt = it.type) == null ? void 0 : tt._context;
    st &&
      st !== FiberContext &&
      !rt.has(st) &&
      rt.set(
        st,
        (et =
          ReactCurrentDispatcher == null
            ? void 0
            : ReactCurrentDispatcher.current) == null
          ? void 0
          : et.readContext(wrapContext(st))
      ),
      (it = it.return);
  }
  return rt;
}
function useContextBridge() {
  const tt = useContextMap();
  return reactExports.useMemo(
    () =>
      Array.from(tt.keys()).reduce(
        (et, nt) => (rt) =>
          reactExports.createElement(
            et,
            null,
            reactExports.createElement(
              nt.Provider,
              __spreadProps$1(__spreadValues$1({}, rt), { value: tt.get(nt) })
            )
          ),
        (et) =>
          reactExports.createElement(FiberProvider, __spreadValues$1({}, et))
      ),
    [tt]
  );
}
const DOM_EVENTS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function createPointerEvents(tt) {
  const { handlePointer: et } = createEvents(tt);
  return {
    priority: 1,
    enabled: !0,
    compute(nt, rt, it) {
      rt.pointer.set(
        (nt.offsetX / rt.size.width) * 2 - 1,
        -(nt.offsetY / rt.size.height) * 2 + 1
      ),
        rt.raycaster.setFromCamera(rt.pointer, rt.camera);
    },
    connected: void 0,
    handlers: Object.keys(DOM_EVENTS).reduce(
      (nt, rt) => ({ ...nt, [rt]: et(rt) }),
      {}
    ),
    update: () => {
      var nt;
      const { events: rt, internal: it } = tt.getState();
      (nt = it.lastEvent) != null &&
        nt.current &&
        rt.handlers &&
        rt.handlers.onPointerMove(it.lastEvent.current);
    },
    connect: (nt) => {
      var rt;
      const { set: it, events: st } = tt.getState();
      st.disconnect == null || st.disconnect(),
        it((ot) => ({ events: { ...ot.events, connected: nt } })),
        Object.entries((rt = st.handlers) != null ? rt : []).forEach(
          ([ot, at]) => {
            const [lt, ct] = DOM_EVENTS[ot];
            nt.addEventListener(lt, at, { passive: ct });
          }
        );
    },
    disconnect: () => {
      const { set: nt, events: rt } = tt.getState();
      if (rt.connected) {
        var it;
        Object.entries((it = rt.handlers) != null ? it : []).forEach(
          ([st, ot]) => {
            if (rt && rt.connected instanceof HTMLElement) {
              const [at] = DOM_EVENTS[st];
              rt.connected.removeEventListener(at, ot);
            }
          }
        ),
          nt((st) => ({ events: { ...st.events, connected: void 0 } }));
      }
    },
  };
}
const CanvasImpl = reactExports.forwardRef(function (
    {
      children: et,
      fallback: nt,
      resize: rt,
      style: it,
      gl: st,
      events: ot = createPointerEvents,
      eventSource: at,
      eventPrefix: lt,
      shadows: ct,
      linear: ut,
      flat: ft,
      legacy: ht,
      orthographic: mt,
      frameloop: vt,
      dpr: yt,
      performance: Et,
      raycaster: pt,
      camera: xt,
      scene: St,
      onPointerMissed: At,
      onCreated: Ct,
      ...Mt
    },
    wt
  ) {
    reactExports.useMemo(() => extend(THREE), []);
    const Bt = useContextBridge(),
      [It, Ft] = useMeasure({
        scroll: !0,
        debounce: { scroll: 50, resize: 0 },
        ...rt,
      }),
      Vt = reactExports.useRef(null),
      $t = reactExports.useRef(null);
    reactExports.useImperativeHandle(wt, () => Vt.current);
    const Kt = useMutableCallback(At),
      [Ht, Wt] = reactExports.useState(!1),
      [kt, Gt] = reactExports.useState(!1);
    if (Ht) throw Ht;
    if (kt) throw kt;
    const Pt = reactExports.useRef(null);
    useIsomorphicLayoutEffect$1(() => {
      const Nt = Vt.current;
      Ft.width > 0 &&
        Ft.height > 0 &&
        Nt &&
        (Pt.current || (Pt.current = createRoot(Nt)),
        Pt.current.configure({
          gl: st,
          events: ot,
          shadows: ct,
          linear: ut,
          flat: ft,
          legacy: ht,
          orthographic: mt,
          frameloop: vt,
          dpr: yt,
          performance: Et,
          raycaster: pt,
          camera: xt,
          scene: St,
          size: Ft,
          onPointerMissed: (...Dt) =>
            Kt.current == null ? void 0 : Kt.current(...Dt),
          onCreated: (Dt) => {
            Dt.events.connect == null ||
              Dt.events.connect(
                at ? (isRef(at) ? at.current : at) : $t.current
              ),
              lt &&
                Dt.setEvents({
                  compute: (zt, Yt) => {
                    const qt = zt[lt + "X"],
                      Zt = zt[lt + "Y"];
                    Yt.pointer.set(
                      (qt / Yt.size.width) * 2 - 1,
                      -(Zt / Yt.size.height) * 2 + 1
                    ),
                      Yt.raycaster.setFromCamera(Yt.pointer, Yt.camera);
                  },
                }),
              Ct == null || Ct(Dt);
          },
        }),
        Pt.current.render(
          reactExports.createElement(
            Bt,
            null,
            reactExports.createElement(
              ErrorBoundary,
              { set: Gt },
              reactExports.createElement(
                reactExports.Suspense,
                { fallback: reactExports.createElement(Block, { set: Wt }) },
                et
              )
            )
          )
        ));
    }),
      reactExports.useEffect(() => {
        const Nt = Vt.current;
        if (Nt) return () => unmountComponentAtNode(Nt);
      }, []);
    const Rt = at ? "none" : "auto";
    return reactExports.createElement(
      "div",
      _extends(
        {
          ref: $t,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: Rt,
            ...it,
          },
        },
        Mt
      ),
      reactExports.createElement(
        "div",
        { ref: It, style: { width: "100%", height: "100%" } },
        reactExports.createElement(
          "canvas",
          { ref: Vt, style: { display: "block" } },
          nt
        )
      )
    );
  }),
  Canvas = reactExports.forwardRef(function (et, nt) {
    return reactExports.createElement(
      FiberProvider,
      null,
      reactExports.createElement(CanvasImpl, _extends({}, et, { ref: nt }))
    );
  }),
  v1 = new Vector3(),
  v2 = new Vector3(),
  v3 = new Vector3();
function defaultCalculatePosition(tt, et, nt) {
  const rt = v1.setFromMatrixPosition(tt.matrixWorld);
  rt.project(et);
  const it = nt.width / 2,
    st = nt.height / 2;
  return [rt.x * it + it, -(rt.y * st) + st];
}
function isObjectBehindCamera(tt, et) {
  const nt = v1.setFromMatrixPosition(tt.matrixWorld),
    rt = v2.setFromMatrixPosition(et.matrixWorld),
    it = nt.sub(rt),
    st = et.getWorldDirection(v3);
  return it.angleTo(st) > Math.PI / 2;
}
function isObjectVisible(tt, et, nt, rt) {
  const it = v1.setFromMatrixPosition(tt.matrixWorld),
    st = it.clone();
  st.project(et), nt.setFromCamera(st, et);
  const ot = nt.intersectObjects(rt, !0);
  if (ot.length) {
    const at = ot[0].distance;
    return it.distanceTo(nt.ray.origin) < at;
  }
  return !0;
}
function objectScale(tt, et) {
  if (et instanceof OrthographicCamera) return et.zoom;
  if (et instanceof PerspectiveCamera) {
    const nt = v1.setFromMatrixPosition(tt.matrixWorld),
      rt = v2.setFromMatrixPosition(et.matrixWorld),
      it = (et.fov * Math.PI) / 180,
      st = nt.distanceTo(rt);
    return 1 / (2 * Math.tan(it / 2) * st);
  } else return 1;
}
function objectZIndex(tt, et, nt) {
  if (et instanceof PerspectiveCamera || et instanceof OrthographicCamera) {
    const rt = v1.setFromMatrixPosition(tt.matrixWorld),
      it = v2.setFromMatrixPosition(et.matrixWorld),
      st = rt.distanceTo(it),
      ot = (nt[1] - nt[0]) / (et.far - et.near),
      at = nt[1] - ot * et.far;
    return Math.round(ot * st + at);
  }
}
const epsilon = (tt) => (Math.abs(tt) < 1e-10 ? 0 : tt);
function getCSSMatrix(tt, et, nt = "") {
  let rt = "matrix3d(";
  for (let it = 0; it !== 16; it++)
    rt += epsilon(et[it] * tt.elements[it]) + (it !== 15 ? "," : ")");
  return nt + rt;
}
const getCameraCSSMatrix = (
    (tt) => (et) =>
      getCSSMatrix(et, tt)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  getObjectCSSMatrix = (
    (tt) => (et, nt) =>
      getCSSMatrix(et, tt(nt), "translate(-50%,-50%)")
  )((tt) => [
    1 / tt,
    1 / tt,
    1 / tt,
    1,
    -1 / tt,
    -1 / tt,
    -1 / tt,
    -1,
    1 / tt,
    1 / tt,
    1 / tt,
    1,
    1,
    1,
    1,
    1,
  ]);
function isRefObject(tt) {
  return tt && typeof tt == "object" && "current" in tt;
}
const Html = reactExports.forwardRef(
  (
    {
      children: tt,
      eps: et = 0.001,
      style: nt,
      className: rt,
      prepend: it,
      center: st,
      fullscreen: ot,
      portal: at,
      distanceFactor: lt,
      sprite: ct = !1,
      transform: ut = !1,
      occlude: ft,
      onOcclude: ht,
      castShadow: mt,
      receiveShadow: vt,
      material: yt,
      geometry: Et,
      zIndexRange: pt = [16777271, 0],
      calculatePosition: xt = defaultCalculatePosition,
      as: St = "div",
      wrapperClass: At,
      pointerEvents: Ct = "auto",
      ...Mt
    },
    wt
  ) => {
    const {
        gl: Bt,
        camera: It,
        scene: Ft,
        size: Vt,
        raycaster: $t,
        events: Kt,
        viewport: Ht,
      } = useThree(),
      [Wt] = reactExports.useState(() => document.createElement(St)),
      kt = reactExports.useRef(),
      Gt = reactExports.useRef(null),
      Pt = reactExports.useRef(0),
      Rt = reactExports.useRef([0, 0]),
      Nt = reactExports.useRef(null),
      Dt = reactExports.useRef(null),
      zt =
        (at == null ? void 0 : at.current) ||
        Kt.connected ||
        Bt.domElement.parentNode,
      Yt = reactExports.useRef(null),
      qt = reactExports.useRef(!1),
      Zt = reactExports.useMemo(
        () =>
          (ft && ft !== "blending") ||
          (Array.isArray(ft) && ft.length && isRefObject(ft[0])),
        [ft]
      );
    reactExports.useLayoutEffect(() => {
      const Bn = Bt.domElement;
      ft && ft === "blending"
        ? ((Bn.style.zIndex = `${Math.floor(pt[0] / 2)}`),
          (Bn.style.position = "absolute"),
          (Bn.style.pointerEvents = "none"))
        : ((Bn.style.zIndex = null),
          (Bn.style.position = null),
          (Bn.style.pointerEvents = null));
    }, [ft]),
      reactExports.useLayoutEffect(() => {
        if (Gt.current) {
          const Bn = (kt.current = createRoot$1(Wt));
          if ((Ft.updateMatrixWorld(), ut))
            Wt.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const gn = xt(Gt.current, It, Vt);
            Wt.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${gn[0]}px,${gn[1]}px,0);transform-origin:0 0;`;
          }
          return (
            zt && (it ? zt.prepend(Wt) : zt.appendChild(Wt)),
            () => {
              zt && zt.removeChild(Wt), Bn.unmount();
            }
          );
        }
      }, [zt, ut]),
      reactExports.useLayoutEffect(() => {
        At && (Wt.className = At);
      }, [At]);
    const Jt = reactExports.useMemo(
        () =>
          ut
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: Vt.width,
                height: Vt.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: st ? "translate3d(-50%,-50%,0)" : "none",
                ...(ot && {
                  top: -Vt.height / 2,
                  left: -Vt.width / 2,
                  width: Vt.width,
                  height: Vt.height,
                }),
                ...nt,
              },
        [nt, st, ot, Vt, ut]
      ),
      mn = reactExports.useMemo(
        () => ({ position: "absolute", pointerEvents: Ct }),
        [Ct]
      );
    reactExports.useLayoutEffect(() => {
      if (((qt.current = !1), ut)) {
        var Bn;
        (Bn = kt.current) == null ||
          Bn.render(
            reactExports.createElement(
              "div",
              { ref: Nt, style: Jt },
              reactExports.createElement(
                "div",
                { ref: Dt, style: mn },
                reactExports.createElement("div", {
                  ref: wt,
                  className: rt,
                  style: nt,
                  children: tt,
                })
              )
            )
          );
      } else {
        var gn;
        (gn = kt.current) == null ||
          gn.render(
            reactExports.createElement("div", {
              ref: wt,
              style: Jt,
              className: rt,
              children: tt,
            })
          );
      }
    });
    const ln = reactExports.useRef(!0);
    useFrame((Bn) => {
      if (Gt.current) {
        It.updateMatrixWorld(), Gt.current.updateWorldMatrix(!0, !1);
        const gn = ut ? Rt.current : xt(Gt.current, It, Vt);
        if (
          ut ||
          Math.abs(Pt.current - It.zoom) > et ||
          Math.abs(Rt.current[0] - gn[0]) > et ||
          Math.abs(Rt.current[1] - gn[1]) > et
        ) {
          const jt = isObjectBehindCamera(Gt.current, It);
          let yn = !1;
          Zt &&
            (Array.isArray(ft)
              ? (yn = ft.map((Fn) => Fn.current))
              : ft !== "blending" && (yn = [Ft]));
          const pn = ln.current;
          if (yn) {
            const Fn = isObjectVisible(Gt.current, It, $t, yn);
            ln.current = Fn && !jt;
          } else ln.current = !jt;
          pn !== ln.current &&
            (ht
              ? ht(!ln.current)
              : (Wt.style.display = ln.current ? "block" : "none"));
          const vn = Math.floor(pt[0] / 2),
            xn = ft ? (Zt ? [pt[0], vn] : [vn - 1, 0]) : pt;
          if (((Wt.style.zIndex = `${objectZIndex(Gt.current, It, xn)}`), ut)) {
            const [Fn, _n] = [Vt.width / 2, Vt.height / 2],
              Dn = It.projectionMatrix.elements[5] * _n,
              {
                isOrthographicCamera: Tn,
                top: An,
                left: Wn,
                bottom: Xt,
                right: Ut,
              } = It,
              hn = getCameraCSSMatrix(It.matrixWorldInverse),
              Ln = Tn
                ? `scale(${Dn})translate(${epsilon(-(Ut + Wn) / 2)}px,${epsilon(
                    (An + Xt) / 2
                  )}px)`
                : `translateZ(${Dn}px)`;
            let Cn = Gt.current.matrixWorld;
            ct &&
              ((Cn = It.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Cn)
                .scale(Gt.current.scale)),
              (Cn.elements[3] = Cn.elements[7] = Cn.elements[11] = 0),
              (Cn.elements[15] = 1)),
              (Wt.style.width = Vt.width + "px"),
              (Wt.style.height = Vt.height + "px"),
              (Wt.style.perspective = Tn ? "" : `${Dn}px`),
              Nt.current &&
                Dt.current &&
                ((Nt.current.style.transform = `${Ln}${hn}translate(${Fn}px,${_n}px)`),
                (Dt.current.style.transform = getObjectCSSMatrix(
                  Cn,
                  1 / ((lt || 10) / 400)
                )));
          } else {
            const Fn = lt === void 0 ? 1 : objectScale(Gt.current, It) * lt;
            Wt.style.transform = `translate3d(${gn[0]}px,${gn[1]}px,0) scale(${Fn})`;
          }
          (Rt.current = gn), (Pt.current = It.zoom);
        }
      }
      if (!Zt && Yt.current && !qt.current)
        if (ut) {
          if (Nt.current) {
            const gn = Nt.current.children[0];
            if (gn != null && gn.clientWidth && gn != null && gn.clientHeight) {
              const { isOrthographicCamera: jt } = It;
              if (jt || Et)
                Mt.scale &&
                  (Array.isArray(Mt.scale)
                    ? Mt.scale instanceof Vector3
                      ? Yt.current.scale.copy(Mt.scale.clone().divideScalar(1))
                      : Yt.current.scale.set(
                          1 / Mt.scale[0],
                          1 / Mt.scale[1],
                          1 / Mt.scale[2]
                        )
                    : Yt.current.scale.setScalar(1 / Mt.scale));
              else {
                const yn = (lt || 10) / 400,
                  pn = gn.clientWidth * yn,
                  vn = gn.clientHeight * yn;
                Yt.current.scale.set(pn, vn, 1);
              }
              qt.current = !0;
            }
          }
        } else {
          const gn = Wt.children[0];
          if (gn != null && gn.clientWidth && gn != null && gn.clientHeight) {
            const jt = 1 / Ht.factor,
              yn = gn.clientWidth * jt,
              pn = gn.clientHeight * jt;
            Yt.current.scale.set(yn, pn, 1), (qt.current = !0);
          }
          Yt.current.lookAt(Bn.camera.position);
        }
    });
    const bn = reactExports.useMemo(
      () => ({
        vertexShader: ut
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [ut]
    );
    return reactExports.createElement(
      "group",
      _extends({}, Mt, { ref: Gt }),
      ft &&
        !Zt &&
        reactExports.createElement(
          "mesh",
          { castShadow: mt, receiveShadow: vt, ref: Yt },
          Et || reactExports.createElement("planeGeometry", null),
          yt ||
            reactExports.createElement("shaderMaterial", {
              side: DoubleSide,
              vertexShader: bn.vertexShader,
              fragmentShader: bn.fragmentShader,
            })
        )
    );
  }
);
function mergeRefs(tt) {
  return function (et) {
    tt.forEach(function (nt) {
      typeof nt == "function" ? nt(et) : nt != null && (nt.current = et);
    });
  };
}
function toTrianglesDrawMode(tt, et) {
  if (et === TrianglesDrawMode)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      tt
    );
  if (et === TriangleFanDrawMode || et === TriangleStripDrawMode) {
    let nt = tt.getIndex();
    if (nt === null) {
      const ot = [],
        at = tt.getAttribute("position");
      if (at !== void 0) {
        for (let lt = 0; lt < at.count; lt++) ot.push(lt);
        tt.setIndex(ot), (nt = tt.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          tt
        );
    }
    const rt = nt.count - 2,
      it = [];
    if (nt)
      if (et === TriangleFanDrawMode)
        for (let ot = 1; ot <= rt; ot++)
          it.push(nt.getX(0)), it.push(nt.getX(ot)), it.push(nt.getX(ot + 1));
      else
        for (let ot = 0; ot < rt; ot++)
          ot % 2 === 0
            ? (it.push(nt.getX(ot)),
              it.push(nt.getX(ot + 1)),
              it.push(nt.getX(ot + 2)))
            : (it.push(nt.getX(ot + 2)),
              it.push(nt.getX(ot + 1)),
              it.push(nt.getX(ot)));
    it.length / 3 !== rt &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const st = tt.clone();
    return st.setIndex(it), st.clearGroups(), st;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        et
      ),
      tt
    );
}
const version$1 = parseInt(REVISION.replace(/\D+/g, ""));
var __defProp$7 = Object.defineProperty,
  __defNormalProp$7 = (tt, et, nt) =>
    et in tt
      ? __defProp$7(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$6 = (tt, et, nt) => (
    __defNormalProp$7(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
const _ray$1 = new Ray(),
  _plane = new Plane(),
  TILT_LIMIT = Math.cos(70 * (Math.PI / 180)),
  moduloWrapAround = (tt, et) => ((tt % et) + et) % et;
let OrbitControls$1 = class extends EventDispatcher {
  constructor(et, nt) {
    super(),
      __publicField$6(this, "object"),
      __publicField$6(this, "domElement"),
      __publicField$6(this, "enabled", !0),
      __publicField$6(this, "target", new Vector3()),
      __publicField$6(this, "minDistance", 0),
      __publicField$6(this, "maxDistance", 1 / 0),
      __publicField$6(this, "minZoom", 0),
      __publicField$6(this, "maxZoom", 1 / 0),
      __publicField$6(this, "minPolarAngle", 0),
      __publicField$6(this, "maxPolarAngle", Math.PI),
      __publicField$6(this, "minAzimuthAngle", -1 / 0),
      __publicField$6(this, "maxAzimuthAngle", 1 / 0),
      __publicField$6(this, "enableDamping", !1),
      __publicField$6(this, "dampingFactor", 0.05),
      __publicField$6(this, "enableZoom", !0),
      __publicField$6(this, "zoomSpeed", 1),
      __publicField$6(this, "enableRotate", !0),
      __publicField$6(this, "rotateSpeed", 1),
      __publicField$6(this, "enablePan", !0),
      __publicField$6(this, "panSpeed", 1),
      __publicField$6(this, "screenSpacePanning", !0),
      __publicField$6(this, "keyPanSpeed", 7),
      __publicField$6(this, "zoomToCursor", !1),
      __publicField$6(this, "autoRotate", !1),
      __publicField$6(this, "autoRotateSpeed", 2),
      __publicField$6(this, "reverseOrbit", !1),
      __publicField$6(this, "reverseHorizontalOrbit", !1),
      __publicField$6(this, "reverseVerticalOrbit", !1),
      __publicField$6(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      __publicField$6(this, "mouseButtons", {
        LEFT: MOUSE.ROTATE,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.PAN,
      }),
      __publicField$6(this, "touches", {
        ONE: TOUCH.ROTATE,
        TWO: TOUCH.DOLLY_PAN,
      }),
      __publicField$6(this, "target0"),
      __publicField$6(this, "position0"),
      __publicField$6(this, "zoom0"),
      __publicField$6(this, "_domElementKeyEvents", null),
      __publicField$6(this, "getPolarAngle"),
      __publicField$6(this, "getAzimuthalAngle"),
      __publicField$6(this, "setPolarAngle"),
      __publicField$6(this, "setAzimuthalAngle"),
      __publicField$6(this, "getDistance"),
      __publicField$6(this, "listenToKeyEvents"),
      __publicField$6(this, "stopListenToKeyEvents"),
      __publicField$6(this, "saveState"),
      __publicField$6(this, "reset"),
      __publicField$6(this, "update"),
      __publicField$6(this, "connect"),
      __publicField$6(this, "dispose"),
      (this.object = et),
      (this.domElement = nt),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => ut.phi),
      (this.getAzimuthalAngle = () => ut.theta),
      (this.setPolarAngle = (dn) => {
        let Pn = moduloWrapAround(dn, 2 * Math.PI),
          Hn = ut.phi;
        Hn < 0 && (Hn += 2 * Math.PI), Pn < 0 && (Pn += 2 * Math.PI);
        let Qt = Math.abs(Pn - Hn);
        2 * Math.PI - Qt < Qt &&
          (Pn < Hn ? (Pn += 2 * Math.PI) : (Hn += 2 * Math.PI)),
          (ft.phi = Pn - Hn),
          rt.update();
      }),
      (this.setAzimuthalAngle = (dn) => {
        let Pn = moduloWrapAround(dn, 2 * Math.PI),
          Hn = ut.theta;
        Hn < 0 && (Hn += 2 * Math.PI), Pn < 0 && (Pn += 2 * Math.PI);
        let Qt = Math.abs(Pn - Hn);
        2 * Math.PI - Qt < Qt &&
          (Pn < Hn ? (Pn += 2 * Math.PI) : (Hn += 2 * Math.PI)),
          (ft.theta = Pn - Hn),
          rt.update();
      }),
      (this.getDistance = () => rt.object.position.distanceTo(rt.target)),
      (this.listenToKeyEvents = (dn) => {
        dn.addEventListener("keydown", Mn), (this._domElementKeyEvents = dn);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Mn),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        rt.target0.copy(rt.target),
          rt.position0.copy(rt.object.position),
          (rt.zoom0 = rt.object.zoom);
      }),
      (this.reset = () => {
        rt.target.copy(rt.target0),
          rt.object.position.copy(rt.position0),
          (rt.object.zoom = rt.zoom0),
          rt.object.updateProjectionMatrix(),
          rt.dispatchEvent(it),
          rt.update(),
          (lt = at.NONE);
      }),
      (this.update = (() => {
        const dn = new Vector3(),
          Pn = new Vector3(0, 1, 0),
          Hn = new Quaternion().setFromUnitVectors(et.up, Pn),
          Qt = Hn.clone().invert(),
          zn = new Vector3(),
          Xn = new Quaternion(),
          Qn = 2 * Math.PI;
        return function () {
          const jn = rt.object.position;
          Hn.setFromUnitVectors(et.up, Pn),
            Qt.copy(Hn).invert(),
            dn.copy(jn).sub(rt.target),
            dn.applyQuaternion(Hn),
            ut.setFromVector3(dn),
            rt.autoRotate && lt === at.NONE && Ht($t()),
            rt.enableDamping
              ? ((ut.theta += ft.theta * rt.dampingFactor),
                (ut.phi += ft.phi * rt.dampingFactor))
              : ((ut.theta += ft.theta), (ut.phi += ft.phi));
          let nr = rt.minAzimuthAngle,
            or = rt.maxAzimuthAngle;
          isFinite(nr) &&
            isFinite(or) &&
            (nr < -Math.PI ? (nr += Qn) : nr > Math.PI && (nr -= Qn),
            or < -Math.PI ? (or += Qn) : or > Math.PI && (or -= Qn),
            nr <= or
              ? (ut.theta = Math.max(nr, Math.min(or, ut.theta)))
              : (ut.theta =
                  ut.theta > (nr + or) / 2
                    ? Math.max(nr, ut.theta)
                    : Math.min(or, ut.theta))),
            (ut.phi = Math.max(
              rt.minPolarAngle,
              Math.min(rt.maxPolarAngle, ut.phi)
            )),
            ut.makeSafe(),
            rt.enableDamping === !0
              ? rt.target.addScaledVector(mt, rt.dampingFactor)
              : rt.target.add(mt),
            (rt.zoomToCursor && It) || rt.object.isOrthographicCamera
              ? (ut.radius = zt(ut.radius))
              : (ut.radius = zt(ut.radius * ht)),
            dn.setFromSpherical(ut),
            dn.applyQuaternion(Qt),
            jn.copy(rt.target).add(dn),
            rt.object.lookAt(rt.target),
            rt.enableDamping === !0
              ? ((ft.theta *= 1 - rt.dampingFactor),
                (ft.phi *= 1 - rt.dampingFactor),
                mt.multiplyScalar(1 - rt.dampingFactor))
              : (ft.set(0, 0, 0), mt.set(0, 0, 0));
          let vr = !1;
          if (rt.zoomToCursor && It) {
            let Ar = null;
            if (
              rt.object instanceof PerspectiveCamera &&
              rt.object.isPerspectiveCamera
            ) {
              const _r = dn.length();
              Ar = zt(_r * ht);
              const yr = _r - Ar;
              rt.object.position.addScaledVector(wt, yr),
                rt.object.updateMatrixWorld();
            } else if (rt.object.isOrthographicCamera) {
              const _r = new Vector3(Bt.x, Bt.y, 0);
              _r.unproject(rt.object),
                (rt.object.zoom = Math.max(
                  rt.minZoom,
                  Math.min(rt.maxZoom, rt.object.zoom / ht)
                )),
                rt.object.updateProjectionMatrix(),
                (vr = !0);
              const yr = new Vector3(Bt.x, Bt.y, 0);
              yr.unproject(rt.object),
                rt.object.position.sub(yr).add(_r),
                rt.object.updateMatrixWorld(),
                (Ar = dn.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (rt.zoomToCursor = !1);
            Ar !== null &&
              (rt.screenSpacePanning
                ? rt.target
                    .set(0, 0, -1)
                    .transformDirection(rt.object.matrix)
                    .multiplyScalar(Ar)
                    .add(rt.object.position)
                : (_ray$1.origin.copy(rt.object.position),
                  _ray$1.direction
                    .set(0, 0, -1)
                    .transformDirection(rt.object.matrix),
                  Math.abs(rt.object.up.dot(_ray$1.direction)) < TILT_LIMIT
                    ? et.lookAt(rt.target)
                    : (_plane.setFromNormalAndCoplanarPoint(
                        rt.object.up,
                        rt.target
                      ),
                      _ray$1.intersectPlane(_plane, rt.target))));
          } else
            rt.object instanceof OrthographicCamera &&
              rt.object.isOrthographicCamera &&
              ((rt.object.zoom = Math.max(
                rt.minZoom,
                Math.min(rt.maxZoom, rt.object.zoom / ht)
              )),
              rt.object.updateProjectionMatrix(),
              (vr = !0));
          return (
            (ht = 1),
            (It = !1),
            vr ||
            zn.distanceToSquared(rt.object.position) > ct ||
            8 * (1 - Xn.dot(rt.object.quaternion)) > ct
              ? (rt.dispatchEvent(it),
                zn.copy(rt.object.position),
                Xn.copy(rt.object.quaternion),
                (vr = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (dn) => {
        dn === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (rt.domElement = dn),
          (rt.domElement.style.touchAction = "none"),
          rt.domElement.addEventListener("contextmenu", Kn),
          rt.domElement.addEventListener("pointerdown", An),
          rt.domElement.addEventListener("pointercancel", Ut),
          rt.domElement.addEventListener("wheel", Cn);
      }),
      (this.dispose = () => {
        var dn, Pn, Hn, Qt, zn, Xn;
        (dn = rt.domElement) == null ||
          dn.removeEventListener("contextmenu", Kn),
          (Pn = rt.domElement) == null ||
            Pn.removeEventListener("pointerdown", An),
          (Hn = rt.domElement) == null ||
            Hn.removeEventListener("pointercancel", Ut),
          (Qt = rt.domElement) == null || Qt.removeEventListener("wheel", Cn),
          (zn = rt.domElement) == null ||
            zn.ownerDocument.removeEventListener("pointermove", Wn),
          (Xn = rt.domElement) == null ||
            Xn.ownerDocument.removeEventListener("pointerup", Xt),
          rt._domElementKeyEvents !== null &&
            rt._domElementKeyEvents.removeEventListener("keydown", Mn);
      });
    const rt = this,
      it = { type: "change" },
      st = { type: "start" },
      ot = { type: "end" },
      at = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let lt = at.NONE;
    const ct = 1e-6,
      ut = new Spherical(),
      ft = new Spherical();
    let ht = 1;
    const mt = new Vector3(),
      vt = new Vector2(),
      yt = new Vector2(),
      Et = new Vector2(),
      pt = new Vector2(),
      xt = new Vector2(),
      St = new Vector2(),
      At = new Vector2(),
      Ct = new Vector2(),
      Mt = new Vector2(),
      wt = new Vector3(),
      Bt = new Vector2();
    let It = !1;
    const Ft = [],
      Vt = {};
    function $t() {
      return ((2 * Math.PI) / 60 / 60) * rt.autoRotateSpeed;
    }
    function Kt() {
      return Math.pow(0.95, rt.zoomSpeed);
    }
    function Ht(dn) {
      rt.reverseOrbit || rt.reverseHorizontalOrbit
        ? (ft.theta += dn)
        : (ft.theta -= dn);
    }
    function Wt(dn) {
      rt.reverseOrbit || rt.reverseVerticalOrbit
        ? (ft.phi += dn)
        : (ft.phi -= dn);
    }
    const kt = (() => {
        const dn = new Vector3();
        return function (Hn, Qt) {
          dn.setFromMatrixColumn(Qt, 0), dn.multiplyScalar(-Hn), mt.add(dn);
        };
      })(),
      Gt = (() => {
        const dn = new Vector3();
        return function (Hn, Qt) {
          rt.screenSpacePanning === !0
            ? dn.setFromMatrixColumn(Qt, 1)
            : (dn.setFromMatrixColumn(Qt, 0),
              dn.crossVectors(rt.object.up, dn)),
            dn.multiplyScalar(Hn),
            mt.add(dn);
        };
      })(),
      Pt = (() => {
        const dn = new Vector3();
        return function (Hn, Qt) {
          const zn = rt.domElement;
          if (
            zn &&
            rt.object instanceof PerspectiveCamera &&
            rt.object.isPerspectiveCamera
          ) {
            const Xn = rt.object.position;
            dn.copy(Xn).sub(rt.target);
            let Qn = dn.length();
            (Qn *= Math.tan(((rt.object.fov / 2) * Math.PI) / 180)),
              kt((2 * Hn * Qn) / zn.clientHeight, rt.object.matrix),
              Gt((2 * Qt * Qn) / zn.clientHeight, rt.object.matrix);
          } else
            zn &&
            rt.object instanceof OrthographicCamera &&
            rt.object.isOrthographicCamera
              ? (kt(
                  (Hn * (rt.object.right - rt.object.left)) /
                    rt.object.zoom /
                    zn.clientWidth,
                  rt.object.matrix
                ),
                Gt(
                  (Qt * (rt.object.top - rt.object.bottom)) /
                    rt.object.zoom /
                    zn.clientHeight,
                  rt.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (rt.enablePan = !1));
        };
      })();
    function Rt(dn) {
      (rt.object instanceof PerspectiveCamera &&
        rt.object.isPerspectiveCamera) ||
      (rt.object instanceof OrthographicCamera &&
        rt.object.isOrthographicCamera)
        ? (ht /= dn)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (rt.enableZoom = !1));
    }
    function Nt(dn) {
      (rt.object instanceof PerspectiveCamera &&
        rt.object.isPerspectiveCamera) ||
      (rt.object instanceof OrthographicCamera &&
        rt.object.isOrthographicCamera)
        ? (ht *= dn)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (rt.enableZoom = !1));
    }
    function Dt(dn) {
      if (!rt.zoomToCursor || !rt.domElement) return;
      It = !0;
      const Pn = rt.domElement.getBoundingClientRect(),
        Hn = dn.clientX - Pn.left,
        Qt = dn.clientY - Pn.top,
        zn = Pn.width,
        Xn = Pn.height;
      (Bt.x = (Hn / zn) * 2 - 1),
        (Bt.y = -(Qt / Xn) * 2 + 1),
        wt
          .set(Bt.x, Bt.y, 1)
          .unproject(rt.object)
          .sub(rt.object.position)
          .normalize();
    }
    function zt(dn) {
      return Math.max(rt.minDistance, Math.min(rt.maxDistance, dn));
    }
    function Yt(dn) {
      vt.set(dn.clientX, dn.clientY);
    }
    function qt(dn) {
      Dt(dn), At.set(dn.clientX, dn.clientY);
    }
    function Zt(dn) {
      pt.set(dn.clientX, dn.clientY);
    }
    function Jt(dn) {
      yt.set(dn.clientX, dn.clientY),
        Et.subVectors(yt, vt).multiplyScalar(rt.rotateSpeed);
      const Pn = rt.domElement;
      Pn &&
        (Ht((2 * Math.PI * Et.x) / Pn.clientHeight),
        Wt((2 * Math.PI * Et.y) / Pn.clientHeight)),
        vt.copy(yt),
        rt.update();
    }
    function mn(dn) {
      Ct.set(dn.clientX, dn.clientY),
        Mt.subVectors(Ct, At),
        Mt.y > 0 ? Rt(Kt()) : Mt.y < 0 && Nt(Kt()),
        At.copy(Ct),
        rt.update();
    }
    function ln(dn) {
      xt.set(dn.clientX, dn.clientY),
        St.subVectors(xt, pt).multiplyScalar(rt.panSpeed),
        Pt(St.x, St.y),
        pt.copy(xt),
        rt.update();
    }
    function bn(dn) {
      Dt(dn), dn.deltaY < 0 ? Nt(Kt()) : dn.deltaY > 0 && Rt(Kt()), rt.update();
    }
    function Bn(dn) {
      let Pn = !1;
      switch (dn.code) {
        case rt.keys.UP:
          Pt(0, rt.keyPanSpeed), (Pn = !0);
          break;
        case rt.keys.BOTTOM:
          Pt(0, -rt.keyPanSpeed), (Pn = !0);
          break;
        case rt.keys.LEFT:
          Pt(rt.keyPanSpeed, 0), (Pn = !0);
          break;
        case rt.keys.RIGHT:
          Pt(-rt.keyPanSpeed, 0), (Pn = !0);
          break;
      }
      Pn && (dn.preventDefault(), rt.update());
    }
    function gn() {
      if (Ft.length == 1) vt.set(Ft[0].pageX, Ft[0].pageY);
      else {
        const dn = 0.5 * (Ft[0].pageX + Ft[1].pageX),
          Pn = 0.5 * (Ft[0].pageY + Ft[1].pageY);
        vt.set(dn, Pn);
      }
    }
    function jt() {
      if (Ft.length == 1) pt.set(Ft[0].pageX, Ft[0].pageY);
      else {
        const dn = 0.5 * (Ft[0].pageX + Ft[1].pageX),
          Pn = 0.5 * (Ft[0].pageY + Ft[1].pageY);
        pt.set(dn, Pn);
      }
    }
    function yn() {
      const dn = Ft[0].pageX - Ft[1].pageX,
        Pn = Ft[0].pageY - Ft[1].pageY,
        Hn = Math.sqrt(dn * dn + Pn * Pn);
      At.set(0, Hn);
    }
    function pn() {
      rt.enableZoom && yn(), rt.enablePan && jt();
    }
    function vn() {
      rt.enableZoom && yn(), rt.enableRotate && gn();
    }
    function xn(dn) {
      if (Ft.length == 1) yt.set(dn.pageX, dn.pageY);
      else {
        const Hn = qn(dn),
          Qt = 0.5 * (dn.pageX + Hn.x),
          zn = 0.5 * (dn.pageY + Hn.y);
        yt.set(Qt, zn);
      }
      Et.subVectors(yt, vt).multiplyScalar(rt.rotateSpeed);
      const Pn = rt.domElement;
      Pn &&
        (Ht((2 * Math.PI * Et.x) / Pn.clientHeight),
        Wt((2 * Math.PI * Et.y) / Pn.clientHeight)),
        vt.copy(yt);
    }
    function Fn(dn) {
      if (Ft.length == 1) xt.set(dn.pageX, dn.pageY);
      else {
        const Pn = qn(dn),
          Hn = 0.5 * (dn.pageX + Pn.x),
          Qt = 0.5 * (dn.pageY + Pn.y);
        xt.set(Hn, Qt);
      }
      St.subVectors(xt, pt).multiplyScalar(rt.panSpeed),
        Pt(St.x, St.y),
        pt.copy(xt);
    }
    function _n(dn) {
      const Pn = qn(dn),
        Hn = dn.pageX - Pn.x,
        Qt = dn.pageY - Pn.y,
        zn = Math.sqrt(Hn * Hn + Qt * Qt);
      Ct.set(0, zn),
        Mt.set(0, Math.pow(Ct.y / At.y, rt.zoomSpeed)),
        Rt(Mt.y),
        At.copy(Ct);
    }
    function Dn(dn) {
      rt.enableZoom && _n(dn), rt.enablePan && Fn(dn);
    }
    function Tn(dn) {
      rt.enableZoom && _n(dn), rt.enableRotate && xn(dn);
    }
    function An(dn) {
      var Pn, Hn;
      rt.enabled !== !1 &&
        (Ft.length === 0 &&
          ((Pn = rt.domElement) == null ||
            Pn.ownerDocument.addEventListener("pointermove", Wn),
          (Hn = rt.domElement) == null ||
            Hn.ownerDocument.addEventListener("pointerup", Xt)),
        Yn(dn),
        dn.pointerType === "touch" ? kn(dn) : hn(dn));
    }
    function Wn(dn) {
      rt.enabled !== !1 && (dn.pointerType === "touch" ? Vn(dn) : Ln(dn));
    }
    function Xt(dn) {
      var Pn, Hn, Qt;
      ir(dn),
        Ft.length === 0 &&
          ((Pn = rt.domElement) == null ||
            Pn.releasePointerCapture(dn.pointerId),
          (Hn = rt.domElement) == null ||
            Hn.ownerDocument.removeEventListener("pointermove", Wn),
          (Qt = rt.domElement) == null ||
            Qt.ownerDocument.removeEventListener("pointerup", Xt)),
        rt.dispatchEvent(ot),
        (lt = at.NONE);
    }
    function Ut(dn) {
      ir(dn);
    }
    function hn(dn) {
      let Pn;
      switch (dn.button) {
        case 0:
          Pn = rt.mouseButtons.LEFT;
          break;
        case 1:
          Pn = rt.mouseButtons.MIDDLE;
          break;
        case 2:
          Pn = rt.mouseButtons.RIGHT;
          break;
        default:
          Pn = -1;
      }
      switch (Pn) {
        case MOUSE.DOLLY:
          if (rt.enableZoom === !1) return;
          qt(dn), (lt = at.DOLLY);
          break;
        case MOUSE.ROTATE:
          if (dn.ctrlKey || dn.metaKey || dn.shiftKey) {
            if (rt.enablePan === !1) return;
            Zt(dn), (lt = at.PAN);
          } else {
            if (rt.enableRotate === !1) return;
            Yt(dn), (lt = at.ROTATE);
          }
          break;
        case MOUSE.PAN:
          if (dn.ctrlKey || dn.metaKey || dn.shiftKey) {
            if (rt.enableRotate === !1) return;
            Yt(dn), (lt = at.ROTATE);
          } else {
            if (rt.enablePan === !1) return;
            Zt(dn), (lt = at.PAN);
          }
          break;
        default:
          lt = at.NONE;
      }
      lt !== at.NONE && rt.dispatchEvent(st);
    }
    function Ln(dn) {
      if (rt.enabled !== !1)
        switch (lt) {
          case at.ROTATE:
            if (rt.enableRotate === !1) return;
            Jt(dn);
            break;
          case at.DOLLY:
            if (rt.enableZoom === !1) return;
            mn(dn);
            break;
          case at.PAN:
            if (rt.enablePan === !1) return;
            ln(dn);
            break;
        }
    }
    function Cn(dn) {
      rt.enabled === !1 ||
        rt.enableZoom === !1 ||
        (lt !== at.NONE && lt !== at.ROTATE) ||
        (dn.preventDefault(),
        rt.dispatchEvent(st),
        bn(dn),
        rt.dispatchEvent(ot));
    }
    function Mn(dn) {
      rt.enabled === !1 || rt.enablePan === !1 || Bn(dn);
    }
    function kn(dn) {
      switch ((On(dn), Ft.length)) {
        case 1:
          switch (rt.touches.ONE) {
            case TOUCH.ROTATE:
              if (rt.enableRotate === !1) return;
              gn(), (lt = at.TOUCH_ROTATE);
              break;
            case TOUCH.PAN:
              if (rt.enablePan === !1) return;
              jt(), (lt = at.TOUCH_PAN);
              break;
            default:
              lt = at.NONE;
          }
          break;
        case 2:
          switch (rt.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (rt.enableZoom === !1 && rt.enablePan === !1) return;
              pn(), (lt = at.TOUCH_DOLLY_PAN);
              break;
            case TOUCH.DOLLY_ROTATE:
              if (rt.enableZoom === !1 && rt.enableRotate === !1) return;
              vn(), (lt = at.TOUCH_DOLLY_ROTATE);
              break;
            default:
              lt = at.NONE;
          }
          break;
        default:
          lt = at.NONE;
      }
      lt !== at.NONE && rt.dispatchEvent(st);
    }
    function Vn(dn) {
      switch ((On(dn), lt)) {
        case at.TOUCH_ROTATE:
          if (rt.enableRotate === !1) return;
          xn(dn), rt.update();
          break;
        case at.TOUCH_PAN:
          if (rt.enablePan === !1) return;
          Fn(dn), rt.update();
          break;
        case at.TOUCH_DOLLY_PAN:
          if (rt.enableZoom === !1 && rt.enablePan === !1) return;
          Dn(dn), rt.update();
          break;
        case at.TOUCH_DOLLY_ROTATE:
          if (rt.enableZoom === !1 && rt.enableRotate === !1) return;
          Tn(dn), rt.update();
          break;
        default:
          lt = at.NONE;
      }
    }
    function Kn(dn) {
      rt.enabled !== !1 && dn.preventDefault();
    }
    function Yn(dn) {
      Ft.push(dn);
    }
    function ir(dn) {
      delete Vt[dn.pointerId];
      for (let Pn = 0; Pn < Ft.length; Pn++)
        if (Ft[Pn].pointerId == dn.pointerId) {
          Ft.splice(Pn, 1);
          return;
        }
    }
    function On(dn) {
      let Pn = Vt[dn.pointerId];
      Pn === void 0 && ((Pn = new Vector2()), (Vt[dn.pointerId] = Pn)),
        Pn.set(dn.pageX, dn.pageY);
    }
    function qn(dn) {
      const Pn = dn.pointerId === Ft[0].pointerId ? Ft[1] : Ft[0];
      return Vt[Pn.pointerId];
    }
    nt !== void 0 && this.connect(nt), this.update();
  }
};
var __defProp$6 = Object.defineProperty,
  __defNormalProp$6 = (tt, et, nt) =>
    et in tt
      ? __defProp$6(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$5 = (tt, et, nt) => (
    __defNormalProp$6(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
class Pass {
  constructor() {
    __publicField$5(this, "enabled", !0),
      __publicField$5(this, "needsSwap", !0),
      __publicField$5(this, "clear", !1),
      __publicField$5(this, "renderToScreen", !1);
  }
  setSize(et, nt) {}
  render(et, nt, rt, it, st) {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
}
class FullScreenQuad {
  constructor(et) {
    __publicField$5(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1)),
      __publicField$5(this, "geometry", new PlaneGeometry(2, 2)),
      __publicField$5(this, "mesh"),
      (this.mesh = new Mesh(this.geometry, et));
  }
  get material() {
    return this.mesh.material;
  }
  set material(et) {
    this.mesh.material = et;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(et) {
    et.render(this.mesh, this.camera);
  }
}
var __defProp$5 = Object.defineProperty,
  __defNormalProp$5 = (tt, et, nt) =>
    et in tt
      ? __defProp$5(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$4 = (tt, et, nt) => (
    __defNormalProp$5(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
class ShaderPass extends Pass {
  constructor(et, nt = "tDiffuse") {
    super(),
      __publicField$4(this, "textureID"),
      __publicField$4(this, "uniforms"),
      __publicField$4(this, "material"),
      __publicField$4(this, "fsQuad"),
      (this.textureID = nt),
      et instanceof ShaderMaterial
        ? ((this.uniforms = et.uniforms), (this.material = et))
        : ((this.uniforms = UniformsUtils.clone(et.uniforms)),
          (this.material = new ShaderMaterial({
            defines: Object.assign({}, et.defines),
            uniforms: this.uniforms,
            vertexShader: et.vertexShader,
            fragmentShader: et.fragmentShader,
          }))),
      (this.fsQuad = new FullScreenQuad(this.material));
  }
  render(et, nt, rt) {
    this.uniforms[this.textureID] &&
      (this.uniforms[this.textureID].value = rt.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (et.setRenderTarget(null), this.fsQuad.render(et))
        : (et.setRenderTarget(nt),
          this.clear &&
            et.clear(et.autoClearColor, et.autoClearDepth, et.autoClearStencil),
          this.fsQuad.render(et));
  }
}
const CopyShader = {
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}",
    ].join(`
`),
    fragmentShader: [
      "uniform float opacity;",
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 texel = texture2D( tDiffuse, vUv );",
      "	gl_FragColor = opacity * texel;",
      "}",
    ].join(`
`),
  },
  LuminosityHighPassShader = {
    shaderID: "luminosityHighPass",
    uniforms: {
      tDiffuse: { value: null },
      luminosityThreshold: { value: 1 },
      smoothWidth: { value: 1 },
      defaultColor: { value: new Color(0) },
      defaultOpacity: { value: 0 },
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}",
    ].join(`
`),
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform vec3 defaultColor;",
      "uniform float defaultOpacity;",
      "uniform float luminosityThreshold;",
      "uniform float smoothWidth;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 texel = texture2D( tDiffuse, vUv );",
      "	vec3 luma = vec3( 0.299, 0.587, 0.114 );",
      "	float v = dot( texel.xyz, luma );",
      "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",
      "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",
      "	gl_FragColor = mix( outputColor, texel, alpha );",
      "}",
    ].join(`
`),
  };
var __defProp$4 = Object.defineProperty,
  __defNormalProp$4 = (tt, et, nt) =>
    et in tt
      ? __defProp$4(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$3 = (tt, et, nt) => (
    __defNormalProp$4(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
const _UnrealBloomPass = class extends Pass {
  constructor(tt, et, nt, rt) {
    super(),
      (this.strength = et !== void 0 ? et : 1),
      (this.radius = nt),
      (this.threshold = rt),
      (this.resolution =
        tt !== void 0 ? new Vector2(tt.x, tt.y) : new Vector2(256, 256)),
      (this.clearColor = new Color(0, 0, 0)),
      (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let it = Math.round(this.resolution.x / 2),
      st = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new WebGLRenderTarget(it, st, {
      type: HalfFloatType,
    })),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let ut = 0; ut < this.nMips; ut++) {
      const ft = new WebGLRenderTarget(it, st, { type: HalfFloatType });
      (ft.texture.name = "UnrealBloomPass.h" + ut),
        (ft.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(ft);
      const ht = new WebGLRenderTarget(it, st, { type: HalfFloatType });
      (ht.texture.name = "UnrealBloomPass.v" + ut),
        (ht.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(ht),
        (it = Math.round(it / 2)),
        (st = Math.round(st / 2));
    }
    const ot = LuminosityHighPassShader;
    (this.highPassUniforms = UniformsUtils.clone(ot.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = rt),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: ot.vertexShader,
        fragmentShader: ot.fragmentShader,
        defines: {},
      })),
      (this.separableBlurMaterials = []);
    const at = [3, 5, 7, 9, 11];
    (it = Math.round(this.resolution.x / 2)),
      (st = Math.round(this.resolution.y / 2));
    for (let ut = 0; ut < this.nMips; ut++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(at[ut])),
        (this.separableBlurMaterials[ut].uniforms.texSize.value = new Vector2(
          it,
          st
        )),
        (it = Math.round(it / 2)),
        (st = Math.round(st / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = et),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
      (this.compositeMaterial.needsUpdate = !0);
    const lt = [1, 0.8, 0.6, 0.4, 0.2];
    (this.compositeMaterial.uniforms.bloomFactors.value = lt),
      (this.bloomTintColors = [
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors);
    const ct = CopyShader;
    (this.copyUniforms = UniformsUtils.clone(ct.uniforms)),
      (this.copyUniforms.opacity.value = 1),
      (this.materialCopy = new ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: ct.vertexShader,
        fragmentShader: ct.fragmentShader,
        blending: AdditiveBlending,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color()),
      (this.oldClearAlpha = 1),
      (this.basic = new MeshBasicMaterial()),
      (this.fsQuad = new FullScreenQuad(null));
  }
  dispose() {
    for (let tt = 0; tt < this.renderTargetsHorizontal.length; tt++)
      this.renderTargetsHorizontal[tt].dispose();
    for (let tt = 0; tt < this.renderTargetsVertical.length; tt++)
      this.renderTargetsVertical[tt].dispose();
    this.renderTargetBright.dispose();
    for (let tt = 0; tt < this.separableBlurMaterials.length; tt++)
      this.separableBlurMaterials[tt].dispose();
    this.compositeMaterial.dispose(),
      this.materialCopy.dispose(),
      this.basic.dispose(),
      this.fsQuad.dispose();
  }
  setSize(tt, et) {
    let nt = Math.round(tt / 2),
      rt = Math.round(et / 2);
    this.renderTargetBright.setSize(nt, rt);
    for (let it = 0; it < this.nMips; it++)
      this.renderTargetsHorizontal[it].setSize(nt, rt),
        this.renderTargetsVertical[it].setSize(nt, rt),
        (this.separableBlurMaterials[it].uniforms.texSize.value = new Vector2(
          nt,
          rt
        )),
        (nt = Math.round(nt / 2)),
        (rt = Math.round(rt / 2));
  }
  render(tt, et, nt, rt, it) {
    tt.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = tt.getClearAlpha());
    const st = tt.autoClear;
    (tt.autoClear = !1),
      tt.setClearColor(this.clearColor, 0),
      it && tt.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = nt.texture),
        tt.setRenderTarget(null),
        tt.clear(),
        this.fsQuad.render(tt)),
      (this.highPassUniforms.tDiffuse.value = nt.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      tt.setRenderTarget(this.renderTargetBright),
      tt.clear(),
      this.fsQuad.render(tt);
    let ot = this.renderTargetBright;
    for (let at = 0; at < this.nMips; at++)
      (this.fsQuad.material = this.separableBlurMaterials[at]),
        (this.separableBlurMaterials[at].uniforms.colorTexture.value =
          ot.texture),
        (this.separableBlurMaterials[at].uniforms.direction.value =
          _UnrealBloomPass.BlurDirectionX),
        tt.setRenderTarget(this.renderTargetsHorizontal[at]),
        tt.clear(),
        this.fsQuad.render(tt),
        (this.separableBlurMaterials[at].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[at].texture),
        (this.separableBlurMaterials[at].uniforms.direction.value =
          _UnrealBloomPass.BlurDirectionY),
        tt.setRenderTarget(this.renderTargetsVertical[at]),
        tt.clear(),
        this.fsQuad.render(tt),
        (ot = this.renderTargetsVertical[at]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      tt.setRenderTarget(this.renderTargetsHorizontal[0]),
      tt.clear(),
      this.fsQuad.render(tt),
      (this.fsQuad.material = this.materialCopy),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      it && tt.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (tt.setRenderTarget(null), this.fsQuad.render(tt))
        : (tt.setRenderTarget(nt), this.fsQuad.render(tt)),
      tt.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (tt.autoClear = st);
  }
  getSeperableBlurMaterial(tt) {
    return new ShaderMaterial({
      defines: { KERNEL_RADIUS: tt, SIGMA: tt },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new Vector2(0.5, 0.5) },
        direction: { value: new Vector2(0.5, 0.5) },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`,
    });
  }
  getCompositeMaterial(tt) {
    return new ShaderMaterial({
      defines: { NUM_MIPS: tt },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`,
    });
  }
};
let UnrealBloomPass = _UnrealBloomPass;
__publicField$3(UnrealBloomPass, "BlurDirectionX", new Vector2(1, 0));
__publicField$3(UnrealBloomPass, "BlurDirectionY", new Vector2(0, 1));
var __defProp$3 = Object.defineProperty,
  __defNormalProp$3 = (tt, et, nt) =>
    et in tt
      ? __defProp$3(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$2 = (tt, et, nt) => (
    __defNormalProp$3(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
class MaskPass extends Pass {
  constructor(et, nt) {
    super(),
      __publicField$2(this, "scene"),
      __publicField$2(this, "camera"),
      __publicField$2(this, "inverse"),
      (this.scene = et),
      (this.camera = nt),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }
  render(et, nt, rt) {
    const it = et.getContext(),
      st = et.state;
    st.buffers.color.setMask(!1),
      st.buffers.depth.setMask(!1),
      st.buffers.color.setLocked(!0),
      st.buffers.depth.setLocked(!0);
    let ot, at;
    this.inverse ? ((ot = 0), (at = 1)) : ((ot = 1), (at = 0)),
      st.buffers.stencil.setTest(!0),
      st.buffers.stencil.setOp(it.REPLACE, it.REPLACE, it.REPLACE),
      st.buffers.stencil.setFunc(it.ALWAYS, ot, 4294967295),
      st.buffers.stencil.setClear(at),
      st.buffers.stencil.setLocked(!0),
      et.setRenderTarget(rt),
      this.clear && et.clear(),
      et.render(this.scene, this.camera),
      et.setRenderTarget(nt),
      this.clear && et.clear(),
      et.render(this.scene, this.camera),
      st.buffers.color.setLocked(!1),
      st.buffers.depth.setLocked(!1),
      st.buffers.stencil.setLocked(!1),
      st.buffers.stencil.setFunc(it.EQUAL, 1, 4294967295),
      st.buffers.stencil.setOp(it.KEEP, it.KEEP, it.KEEP),
      st.buffers.stencil.setLocked(!0);
  }
}
class ClearMaskPass extends Pass {
  constructor() {
    super(), (this.needsSwap = !1);
  }
  render(et) {
    et.state.buffers.stencil.setLocked(!1),
      et.state.buffers.stencil.setTest(!1);
  }
}
var __defProp$2 = Object.defineProperty,
  __defNormalProp$2 = (tt, et, nt) =>
    et in tt
      ? __defProp$2(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField$1 = (tt, et, nt) => (
    __defNormalProp$2(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
class EffectComposer {
  constructor(et, nt) {
    if (
      (__publicField$1(this, "renderer"),
      __publicField$1(this, "_pixelRatio"),
      __publicField$1(this, "_width"),
      __publicField$1(this, "_height"),
      __publicField$1(this, "renderTarget1"),
      __publicField$1(this, "renderTarget2"),
      __publicField$1(this, "writeBuffer"),
      __publicField$1(this, "readBuffer"),
      __publicField$1(this, "renderToScreen"),
      __publicField$1(this, "passes", []),
      __publicField$1(this, "copyPass"),
      __publicField$1(this, "clock"),
      (this.renderer = et),
      nt === void 0)
    ) {
      const rt = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat,
        },
        it = et.getSize(new Vector2());
      (this._pixelRatio = et.getPixelRatio()),
        (this._width = it.width),
        (this._height = it.height),
        (nt = new WebGLRenderTarget(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          rt
        )),
        (nt.texture.name = "EffectComposer.rt1");
    } else
      (this._pixelRatio = 1),
        (this._width = nt.width),
        (this._height = nt.height);
    (this.renderTarget1 = nt),
      (this.renderTarget2 = nt.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      CopyShader === void 0 &&
        console.error("THREE.EffectComposer relies on CopyShader"),
      ShaderPass === void 0 &&
        console.error("THREE.EffectComposer relies on ShaderPass"),
      (this.copyPass = new ShaderPass(CopyShader)),
      (this.copyPass.material.blending = NoBlending),
      (this.clock = new Clock());
  }
  swapBuffers() {
    const et = this.readBuffer;
    (this.readBuffer = this.writeBuffer), (this.writeBuffer = et);
  }
  addPass(et) {
    this.passes.push(et),
      et.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  insertPass(et, nt) {
    this.passes.splice(nt, 0, et),
      et.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  removePass(et) {
    const nt = this.passes.indexOf(et);
    nt !== -1 && this.passes.splice(nt, 1);
  }
  isLastEnabledPass(et) {
    for (let nt = et + 1; nt < this.passes.length; nt++)
      if (this.passes[nt].enabled) return !1;
    return !0;
  }
  render(et) {
    et === void 0 && (et = this.clock.getDelta());
    const nt = this.renderer.getRenderTarget();
    let rt = !1;
    const it = this.passes.length;
    for (let st = 0; st < it; st++) {
      const ot = this.passes[st];
      if (ot.enabled !== !1) {
        if (
          ((ot.renderToScreen =
            this.renderToScreen && this.isLastEnabledPass(st)),
          ot.render(this.renderer, this.writeBuffer, this.readBuffer, et, rt),
          ot.needsSwap)
        ) {
          if (rt) {
            const at = this.renderer.getContext(),
              lt = this.renderer.state.buffers.stencil;
            lt.setFunc(at.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                et
              ),
              lt.setFunc(at.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        MaskPass !== void 0 &&
          (ot instanceof MaskPass
            ? (rt = !0)
            : ot instanceof ClearMaskPass && (rt = !1));
      }
    }
    this.renderer.setRenderTarget(nt);
  }
  reset(et) {
    if (et === void 0) {
      const nt = this.renderer.getSize(new Vector2());
      (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = nt.width),
        (this._height = nt.height),
        (et = this.renderTarget1.clone()),
        et.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = et),
      (this.renderTarget2 = et.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2);
  }
  setSize(et, nt) {
    (this._width = et), (this._height = nt);
    const rt = this._width * this._pixelRatio,
      it = this._height * this._pixelRatio;
    this.renderTarget1.setSize(rt, it), this.renderTarget2.setSize(rt, it);
    for (let st = 0; st < this.passes.length; st++)
      this.passes[st].setSize(rt, it);
  }
  setPixelRatio(et) {
    (this._pixelRatio = et), this.setSize(this._width, this._height);
  }
}
var __defProp$1 = Object.defineProperty,
  __defNormalProp$1 = (tt, et, nt) =>
    et in tt
      ? __defProp$1(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt),
  __publicField = (tt, et, nt) => (
    __defNormalProp$1(tt, typeof et != "symbol" ? et + "" : et, nt), nt
  );
class RenderPass extends Pass {
  constructor(et, nt, rt, it, st = 0) {
    super(),
      __publicField(this, "scene"),
      __publicField(this, "camera"),
      __publicField(this, "overrideMaterial"),
      __publicField(this, "clearColor"),
      __publicField(this, "clearAlpha"),
      __publicField(this, "clearDepth", !1),
      __publicField(this, "_oldClearColor", new Color()),
      (this.scene = et),
      (this.camera = nt),
      (this.overrideMaterial = rt),
      (this.clearColor = it),
      (this.clearAlpha = st),
      (this.clear = !0),
      (this.needsSwap = !1);
  }
  render(et, nt, rt) {
    let it = et.autoClear;
    et.autoClear = !1;
    let st,
      ot = null;
    this.overrideMaterial !== void 0 &&
      ((ot = this.scene.overrideMaterial),
      (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor &&
        (et.getClearColor(this._oldClearColor),
        (st = et.getClearAlpha()),
        et.setClearColor(this.clearColor, this.clearAlpha)),
      this.clearDepth && et.clearDepth(),
      et.setRenderTarget(this.renderToScreen ? null : rt),
      this.clear &&
        et.clear(et.autoClearColor, et.autoClearDepth, et.autoClearStencil),
      et.render(this.scene, this.camera),
      this.clearColor && et.setClearColor(this._oldClearColor, st),
      this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = ot),
      (et.autoClear = it);
  }
}
class GLTFLoader extends Loader {
  constructor(et) {
    super(et),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (nt) {
        return new GLTFMaterialsClearcoatExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFTextureBasisUExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFTextureWebPExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFTextureAVIFExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsSheenExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsTransmissionExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsVolumeExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsIorExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsEmissiveStrengthExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsSpecularExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsIridescenceExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMaterialsAnisotropyExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFLightsExtension(nt);
      }),
      this.register(function (nt) {
        return new GLTFMeshoptCompression(nt);
      }),
      this.register(function (nt) {
        return new GLTFMeshGpuInstancing(nt);
      });
  }
  load(et, nt, rt, it) {
    const st = this;
    let ot;
    this.resourcePath !== ""
      ? (ot = this.resourcePath)
      : this.path !== ""
      ? (ot = this.path)
      : (ot = LoaderUtils.extractUrlBase(et)),
      this.manager.itemStart(et);
    const at = function (ct) {
        it ? it(ct) : console.error(ct),
          st.manager.itemError(et),
          st.manager.itemEnd(et);
      },
      lt = new FileLoader(this.manager);
    lt.setPath(this.path),
      lt.setResponseType("arraybuffer"),
      lt.setRequestHeader(this.requestHeader),
      lt.setWithCredentials(this.withCredentials),
      lt.load(
        et,
        function (ct) {
          try {
            st.parse(
              ct,
              ot,
              function (ut) {
                nt(ut), st.manager.itemEnd(et);
              },
              at
            );
          } catch (ut) {
            at(ut);
          }
        },
        rt,
        at
      );
  }
  setDRACOLoader(et) {
    return (this.dracoLoader = et), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(et) {
    return (this.ktx2Loader = et), this;
  }
  setMeshoptDecoder(et) {
    return (this.meshoptDecoder = et), this;
  }
  register(et) {
    return (
      this.pluginCallbacks.indexOf(et) === -1 && this.pluginCallbacks.push(et),
      this
    );
  }
  unregister(et) {
    return (
      this.pluginCallbacks.indexOf(et) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(et), 1),
      this
    );
  }
  parse(et, nt, rt, it) {
    let st;
    const ot = {},
      at = {};
    if (typeof et == "string") st = JSON.parse(et);
    else if (et instanceof ArrayBuffer)
      if (
        LoaderUtils.decodeText(new Uint8Array(et.slice(0, 4))) ===
        BINARY_EXTENSION_HEADER_MAGIC
      ) {
        try {
          ot[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(et);
        } catch (ut) {
          it && it(ut);
          return;
        }
        st = JSON.parse(ot[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else st = JSON.parse(LoaderUtils.decodeText(new Uint8Array(et)));
    else st = et;
    if (st.asset === void 0 || st.asset.version[0] < 2) {
      it &&
        it(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const lt = new GLTFParser(st, {
      path: nt || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    lt.fileLoader.setRequestHeader(this.requestHeader);
    for (let ct = 0; ct < this.pluginCallbacks.length; ct++) {
      const ut = this.pluginCallbacks[ct](lt);
      (at[ut.name] = ut), (ot[ut.name] = !0);
    }
    if (st.extensionsUsed)
      for (let ct = 0; ct < st.extensionsUsed.length; ++ct) {
        const ut = st.extensionsUsed[ct],
          ft = st.extensionsRequired || [];
        switch (ut) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            ot[ut] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            ot[ut] = new GLTFDracoMeshCompressionExtension(
              st,
              this.dracoLoader
            );
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            ot[ut] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            ot[ut] = new GLTFMeshQuantizationExtension();
            break;
          default:
            ft.indexOf(ut) >= 0 &&
              at[ut] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + ut + '".');
        }
      }
    lt.setExtensions(ot), lt.setPlugins(at), lt.parse(rt, it);
  }
  parseAsync(et, nt) {
    const rt = this;
    return new Promise(function (it, st) {
      rt.parse(et, nt, it, st);
    });
  }
}
function GLTFRegistry() {
  let tt = {};
  return {
    get: function (et) {
      return tt[et];
    },
    add: function (et, nt) {
      tt[et] = nt;
    },
    remove: function (et) {
      delete tt[et];
    },
    removeAll: function () {
      tt = {};
    },
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class GLTFLightsExtension {
  constructor(et) {
    (this.parser = et),
      (this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const et = this.parser,
      nt = this.parser.json.nodes || [];
    for (let rt = 0, it = nt.length; rt < it; rt++) {
      const st = nt[rt];
      st.extensions &&
        st.extensions[this.name] &&
        st.extensions[this.name].light !== void 0 &&
        et._addNodeRef(this.cache, st.extensions[this.name].light);
    }
  }
  _loadLight(et) {
    const nt = this.parser,
      rt = "light:" + et;
    let it = nt.cache.get(rt);
    if (it) return it;
    const st = nt.json,
      lt = (((st.extensions && st.extensions[this.name]) || {}).lights || [])[
        et
      ];
    let ct;
    const ut = new Color(16777215);
    lt.color !== void 0 && ut.fromArray(lt.color);
    const ft = lt.range !== void 0 ? lt.range : 0;
    switch (lt.type) {
      case "directional":
        (ct = new DirectionalLight(ut)),
          ct.target.position.set(0, 0, -1),
          ct.add(ct.target);
        break;
      case "point":
        (ct = new PointLight(ut)), (ct.distance = ft);
        break;
      case "spot":
        (ct = new SpotLight(ut)),
          (ct.distance = ft),
          (lt.spot = lt.spot || {}),
          (lt.spot.innerConeAngle =
            lt.spot.innerConeAngle !== void 0 ? lt.spot.innerConeAngle : 0),
          (lt.spot.outerConeAngle =
            lt.spot.outerConeAngle !== void 0
              ? lt.spot.outerConeAngle
              : Math.PI / 4),
          (ct.angle = lt.spot.outerConeAngle),
          (ct.penumbra = 1 - lt.spot.innerConeAngle / lt.spot.outerConeAngle),
          ct.target.position.set(0, 0, -1),
          ct.add(ct.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lt.type);
    }
    return (
      ct.position.set(0, 0, 0),
      (ct.decay = 2),
      assignExtrasToUserData(ct, lt),
      lt.intensity !== void 0 && (ct.intensity = lt.intensity),
      (ct.name = nt.createUniqueName(lt.name || "light_" + et)),
      (it = Promise.resolve(ct)),
      nt.cache.add(rt, it),
      it
    );
  }
  getDependency(et, nt) {
    if (et === "light") return this._loadLight(nt);
  }
  createNodeAttachment(et) {
    const nt = this,
      rt = this.parser,
      st = rt.json.nodes[et],
      at = ((st.extensions && st.extensions[this.name]) || {}).light;
    return at === void 0
      ? null
      : this._loadLight(at).then(function (lt) {
          return rt._getNodeRef(nt.cache, at, lt);
        });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(et, nt, rt) {
    const it = [];
    (et.color = new Color(1, 1, 1)), (et.opacity = 1);
    const st = nt.pbrMetallicRoughness;
    if (st) {
      if (Array.isArray(st.baseColorFactor)) {
        const ot = st.baseColorFactor;
        et.color.fromArray(ot), (et.opacity = ot[3]);
      }
      st.baseColorTexture !== void 0 &&
        it.push(rt.assignTexture(et, "map", st.baseColorTexture, 3001));
    }
    return Promise.all(it);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(et) {
    (this.parser = et),
      (this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(et, nt) {
    const it = this.parser.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = it.extensions[this.name].emissiveStrength;
    return st !== void 0 && (nt.emissiveIntensity = st), Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    if (
      (ot.clearcoatFactor !== void 0 && (nt.clearcoat = ot.clearcoatFactor),
      ot.clearcoatTexture !== void 0 &&
        st.push(rt.assignTexture(nt, "clearcoatMap", ot.clearcoatTexture)),
      ot.clearcoatRoughnessFactor !== void 0 &&
        (nt.clearcoatRoughness = ot.clearcoatRoughnessFactor),
      ot.clearcoatRoughnessTexture !== void 0 &&
        st.push(
          rt.assignTexture(
            nt,
            "clearcoatRoughnessMap",
            ot.clearcoatRoughnessTexture
          )
        ),
      ot.clearcoatNormalTexture !== void 0 &&
        (st.push(
          rt.assignTexture(nt, "clearcoatNormalMap", ot.clearcoatNormalTexture)
        ),
        ot.clearcoatNormalTexture.scale !== void 0))
    ) {
      const at = ot.clearcoatNormalTexture.scale;
      nt.clearcoatNormalScale = new Vector2(at, at);
    }
    return Promise.all(st);
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    return (
      ot.iridescenceFactor !== void 0 &&
        (nt.iridescence = ot.iridescenceFactor),
      ot.iridescenceTexture !== void 0 &&
        st.push(rt.assignTexture(nt, "iridescenceMap", ot.iridescenceTexture)),
      ot.iridescenceIor !== void 0 && (nt.iridescenceIOR = ot.iridescenceIor),
      nt.iridescenceThicknessRange === void 0 &&
        (nt.iridescenceThicknessRange = [100, 400]),
      ot.iridescenceThicknessMinimum !== void 0 &&
        (nt.iridescenceThicknessRange[0] = ot.iridescenceThicknessMinimum),
      ot.iridescenceThicknessMaximum !== void 0 &&
        (nt.iridescenceThicknessRange[1] = ot.iridescenceThicknessMaximum),
      ot.iridescenceThicknessTexture !== void 0 &&
        st.push(
          rt.assignTexture(
            nt,
            "iridescenceThicknessMap",
            ot.iridescenceThicknessTexture
          )
        ),
      Promise.all(st)
    );
  }
}
class GLTFMaterialsSheenExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [];
    (nt.sheenColor = new Color(0, 0, 0)),
      (nt.sheenRoughness = 0),
      (nt.sheen = 1);
    const ot = it.extensions[this.name];
    return (
      ot.sheenColorFactor !== void 0 &&
        nt.sheenColor.fromArray(ot.sheenColorFactor),
      ot.sheenRoughnessFactor !== void 0 &&
        (nt.sheenRoughness = ot.sheenRoughnessFactor),
      ot.sheenColorTexture !== void 0 &&
        st.push(
          rt.assignTexture(nt, "sheenColorMap", ot.sheenColorTexture, 3001)
        ),
      ot.sheenRoughnessTexture !== void 0 &&
        st.push(
          rt.assignTexture(nt, "sheenRoughnessMap", ot.sheenRoughnessTexture)
        ),
      Promise.all(st)
    );
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    return (
      ot.transmissionFactor !== void 0 &&
        (nt.transmission = ot.transmissionFactor),
      ot.transmissionTexture !== void 0 &&
        st.push(
          rt.assignTexture(nt, "transmissionMap", ot.transmissionTexture)
        ),
      Promise.all(st)
    );
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    (nt.thickness = ot.thicknessFactor !== void 0 ? ot.thicknessFactor : 0),
      ot.thicknessTexture !== void 0 &&
        st.push(rt.assignTexture(nt, "thicknessMap", ot.thicknessTexture)),
      (nt.attenuationDistance = ot.attenuationDistance || 1 / 0);
    const at = ot.attenuationColor || [1, 1, 1];
    return (
      (nt.attenuationColor = new Color(at[0], at[1], at[2])), Promise.all(st)
    );
  }
}
class GLTFMaterialsIorExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_IOR);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const it = this.parser.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = it.extensions[this.name];
    return (nt.ior = st.ior !== void 0 ? st.ior : 1.5), Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    (nt.specularIntensity =
      ot.specularFactor !== void 0 ? ot.specularFactor : 1),
      ot.specularTexture !== void 0 &&
        st.push(
          rt.assignTexture(nt, "specularIntensityMap", ot.specularTexture)
        );
    const at = ot.specularColorFactor || [1, 1, 1];
    return (
      (nt.specularColor = new Color(at[0], at[1], at[2])),
      ot.specularColorTexture !== void 0 &&
        st.push(
          rt.assignTexture(
            nt,
            "specularColorMap",
            ot.specularColorTexture,
            3001
          )
        ),
      Promise.all(st)
    );
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(et) {
    const rt = this.parser.json.materials[et];
    return !rt.extensions || !rt.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(et, nt) {
    const rt = this.parser,
      it = rt.json.materials[et];
    if (!it.extensions || !it.extensions[this.name]) return Promise.resolve();
    const st = [],
      ot = it.extensions[this.name];
    return (
      ot.anisotropyStrength !== void 0 &&
        (nt.anisotropy = ot.anisotropyStrength),
      ot.anisotropyRotation !== void 0 &&
        (nt.anisotropyRotation = ot.anisotropyRotation),
      ot.anisotropyTexture !== void 0 &&
        st.push(rt.assignTexture(nt, "anisotropyMap", ot.anisotropyTexture)),
      Promise.all(st)
    );
  }
}
class GLTFTextureBasisUExtension {
  constructor(et) {
    (this.parser = et), (this.name = EXTENSIONS.KHR_TEXTURE_BASISU);
  }
  loadTexture(et) {
    const nt = this.parser,
      rt = nt.json,
      it = rt.textures[et];
    if (!it.extensions || !it.extensions[this.name]) return null;
    const st = it.extensions[this.name],
      ot = nt.options.ktx2Loader;
    if (!ot) {
      if (
        rt.extensionsRequired &&
        rt.extensionsRequired.indexOf(this.name) >= 0
      )
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return nt.loadTextureImage(et, st.source, ot);
  }
}
class GLTFTextureWebPExtension {
  constructor(et) {
    (this.parser = et),
      (this.name = EXTENSIONS.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(et) {
    const nt = this.name,
      rt = this.parser,
      it = rt.json,
      st = it.textures[et];
    if (!st.extensions || !st.extensions[nt]) return null;
    const ot = st.extensions[nt],
      at = it.images[ot.source];
    let lt = rt.textureLoader;
    if (at.uri) {
      const ct = rt.options.manager.getHandler(at.uri);
      ct !== null && (lt = ct);
    }
    return this.detectSupport().then(function (ct) {
      if (ct) return rt.loadTextureImage(et, ot.source, lt);
      if (it.extensionsRequired && it.extensionsRequired.indexOf(nt) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return rt.loadTexture(et);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (et) {
          const nt = new Image();
          (nt.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (nt.onload = nt.onerror =
              function () {
                et(nt.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class GLTFTextureAVIFExtension {
  constructor(et) {
    (this.parser = et),
      (this.name = EXTENSIONS.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(et) {
    const nt = this.name,
      rt = this.parser,
      it = rt.json,
      st = it.textures[et];
    if (!st.extensions || !st.extensions[nt]) return null;
    const ot = st.extensions[nt],
      at = it.images[ot.source];
    let lt = rt.textureLoader;
    if (at.uri) {
      const ct = rt.options.manager.getHandler(at.uri);
      ct !== null && (lt = ct);
    }
    return this.detectSupport().then(function (ct) {
      if (ct) return rt.loadTextureImage(et, ot.source, lt);
      if (it.extensionsRequired && it.extensionsRequired.indexOf(nt) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return rt.loadTexture(et);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (et) {
          const nt = new Image();
          (nt.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (nt.onload = nt.onerror =
              function () {
                et(nt.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class GLTFMeshoptCompression {
  constructor(et) {
    (this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION), (this.parser = et);
  }
  loadBufferView(et) {
    const nt = this.parser.json,
      rt = nt.bufferViews[et];
    if (rt.extensions && rt.extensions[this.name]) {
      const it = rt.extensions[this.name],
        st = this.parser.getDependency("buffer", it.buffer),
        ot = this.parser.options.meshoptDecoder;
      if (!ot || !ot.supported) {
        if (
          nt.extensionsRequired &&
          nt.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return st.then(function (at) {
        const lt = it.byteOffset || 0,
          ct = it.byteLength || 0,
          ut = it.count,
          ft = it.byteStride,
          ht = new Uint8Array(at, lt, ct);
        return ot.decodeGltfBufferAsync
          ? ot
              .decodeGltfBufferAsync(ut, ft, ht, it.mode, it.filter)
              .then(function (mt) {
                return mt.buffer;
              })
          : ot.ready.then(function () {
              const mt = new ArrayBuffer(ut * ft);
              return (
                ot.decodeGltfBuffer(
                  new Uint8Array(mt),
                  ut,
                  ft,
                  ht,
                  it.mode,
                  it.filter
                ),
                mt
              );
            });
      });
    } else return null;
  }
}
class GLTFMeshGpuInstancing {
  constructor(et) {
    (this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING), (this.parser = et);
  }
  createNodeMesh(et) {
    const nt = this.parser.json,
      rt = nt.nodes[et];
    if (!rt.extensions || !rt.extensions[this.name] || rt.mesh === void 0)
      return null;
    const it = nt.meshes[rt.mesh];
    for (const ct of it.primitives)
      if (
        ct.mode !== WEBGL_CONSTANTS.TRIANGLES &&
        ct.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
        ct.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
        ct.mode !== void 0
      )
        return null;
    const ot = rt.extensions[this.name].attributes,
      at = [],
      lt = {};
    for (const ct in ot)
      at.push(
        this.parser
          .getDependency("accessor", ot[ct])
          .then((ut) => ((lt[ct] = ut), lt[ct]))
      );
    return at.length < 1
      ? null
      : (at.push(this.parser.createNodeMesh(et)),
        Promise.all(at).then((ct) => {
          const ut = ct.pop(),
            ft = ut.isGroup ? ut.children : [ut],
            ht = ct[0].count,
            mt = [];
          for (const vt of ft) {
            const yt = new Matrix4(),
              Et = new Vector3(),
              pt = new Quaternion(),
              xt = new Vector3(1, 1, 1),
              St = new InstancedMesh(vt.geometry, vt.material, ht);
            for (let At = 0; At < ht; At++)
              lt.TRANSLATION && Et.fromBufferAttribute(lt.TRANSLATION, At),
                lt.ROTATION && pt.fromBufferAttribute(lt.ROTATION, At),
                lt.SCALE && xt.fromBufferAttribute(lt.SCALE, At),
                St.setMatrixAt(At, yt.compose(Et, pt, xt));
            for (const At in lt)
              At !== "TRANSLATION" &&
                At !== "ROTATION" &&
                At !== "SCALE" &&
                vt.geometry.setAttribute(At, lt[At]);
            Object3D.prototype.copy.call(St, vt),
              this.parser.assignFinalMaterial(St),
              mt.push(St);
          }
          return ut.isGroup ? (ut.clear(), ut.add(...mt), ut) : mt[0];
        }));
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF",
  BINARY_EXTENSION_HEADER_LENGTH = 12,
  BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(et) {
    (this.name = EXTENSIONS.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null);
    const nt = new DataView(et, 0, BINARY_EXTENSION_HEADER_LENGTH);
    if (
      ((this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(et.slice(0, 4))),
        version: nt.getUint32(4, !0),
        length: nt.getUint32(8, !0),
      }),
      this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const rt = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
      it = new DataView(et, BINARY_EXTENSION_HEADER_LENGTH);
    let st = 0;
    for (; st < rt; ) {
      const ot = it.getUint32(st, !0);
      st += 4;
      const at = it.getUint32(st, !0);
      if (((st += 4), at === BINARY_EXTENSION_CHUNK_TYPES.JSON)) {
        const lt = new Uint8Array(et, BINARY_EXTENSION_HEADER_LENGTH + st, ot);
        this.content = LoaderUtils.decodeText(lt);
      } else if (at === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const lt = BINARY_EXTENSION_HEADER_LENGTH + st;
        this.body = et.slice(lt, lt + ot);
      }
      st += ot;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(et, nt) {
    if (!nt)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION),
      (this.json = et),
      (this.dracoLoader = nt),
      this.dracoLoader.preload();
  }
  decodePrimitive(et, nt) {
    const rt = this.json,
      it = this.dracoLoader,
      st = et.extensions[this.name].bufferView,
      ot = et.extensions[this.name].attributes,
      at = {},
      lt = {},
      ct = {};
    for (const ut in ot) {
      const ft = ATTRIBUTES[ut] || ut.toLowerCase();
      at[ft] = ot[ut];
    }
    for (const ut in et.attributes) {
      const ft = ATTRIBUTES[ut] || ut.toLowerCase();
      if (ot[ut] !== void 0) {
        const ht = rt.accessors[et.attributes[ut]],
          mt = WEBGL_COMPONENT_TYPES[ht.componentType];
        (ct[ft] = mt.name), (lt[ft] = ht.normalized === !0);
      }
    }
    return nt.getDependency("bufferView", st).then(function (ut) {
      return new Promise(function (ft) {
        it.decodeDracoFile(
          ut,
          function (ht) {
            for (const mt in ht.attributes) {
              const vt = ht.attributes[mt],
                yt = lt[mt];
              yt !== void 0 && (vt.normalized = yt);
            }
            ft(ht);
          },
          at,
          ct
        );
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(et, nt) {
    return (
      ((nt.texCoord === void 0 || nt.texCoord === et.channel) &&
        nt.offset === void 0 &&
        nt.rotation === void 0 &&
        nt.scale === void 0) ||
        ((et = et.clone()),
        nt.texCoord !== void 0 && (et.channel = nt.texCoord),
        nt.offset !== void 0 && et.offset.fromArray(nt.offset),
        nt.rotation !== void 0 && (et.rotation = nt.rotation),
        nt.scale !== void 0 && et.repeat.fromArray(nt.scale),
        (et.needsUpdate = !0)),
      et
    );
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(et, nt, rt, it) {
    super(et, nt, rt, it);
  }
  copySampleValue_(et) {
    const nt = this.resultBuffer,
      rt = this.sampleValues,
      it = this.valueSize,
      st = et * it * 3 + it;
    for (let ot = 0; ot !== it; ot++) nt[ot] = rt[st + ot];
    return nt;
  }
  interpolate_(et, nt, rt, it) {
    const st = this.resultBuffer,
      ot = this.sampleValues,
      at = this.valueSize,
      lt = at * 2,
      ct = at * 3,
      ut = it - nt,
      ft = (rt - nt) / ut,
      ht = ft * ft,
      mt = ht * ft,
      vt = et * ct,
      yt = vt - ct,
      Et = -2 * mt + 3 * ht,
      pt = mt - ht,
      xt = 1 - Et,
      St = pt - ht + ft;
    for (let At = 0; At !== at; At++) {
      const Ct = ot[yt + At + at],
        Mt = ot[yt + At + lt] * ut,
        wt = ot[vt + At + at],
        Bt = ot[vt + At] * ut;
      st[At] = xt * Ct + St * Mt + Et * wt + pt * Bt;
    }
    return st;
  }
}
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(et, nt, rt, it) {
    const st = super.interpolate_(et, nt, rt, it);
    return _q.fromArray(st).normalize().toArray(st), st;
  }
}
const WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter,
  },
  WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping,
  },
  WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
  },
  ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(version$1 >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete,
  },
  ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function createDefaultMaterial(tt) {
  return (
    tt.DefaultMaterial === void 0 &&
      (tt.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide,
      })),
    tt.DefaultMaterial
  );
}
function addUnknownExtensionsToUserData(tt, et, nt) {
  for (const rt in nt.extensions)
    tt[rt] === void 0 &&
      ((et.userData.gltfExtensions = et.userData.gltfExtensions || {}),
      (et.userData.gltfExtensions[rt] = nt.extensions[rt]));
}
function assignExtrasToUserData(tt, et) {
  et.extras !== void 0 &&
    (typeof et.extras == "object"
      ? Object.assign(tt.userData, et.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + et.extras
        ));
}
function addMorphTargets(tt, et, nt) {
  let rt = !1,
    it = !1,
    st = !1;
  for (let ct = 0, ut = et.length; ct < ut; ct++) {
    const ft = et[ct];
    if (
      (ft.POSITION !== void 0 && (rt = !0),
      ft.NORMAL !== void 0 && (it = !0),
      ft.COLOR_0 !== void 0 && (st = !0),
      rt && it && st)
    )
      break;
  }
  if (!rt && !it && !st) return Promise.resolve(tt);
  const ot = [],
    at = [],
    lt = [];
  for (let ct = 0, ut = et.length; ct < ut; ct++) {
    const ft = et[ct];
    if (rt) {
      const ht =
        ft.POSITION !== void 0
          ? nt.getDependency("accessor", ft.POSITION)
          : tt.attributes.position;
      ot.push(ht);
    }
    if (it) {
      const ht =
        ft.NORMAL !== void 0
          ? nt.getDependency("accessor", ft.NORMAL)
          : tt.attributes.normal;
      at.push(ht);
    }
    if (st) {
      const ht =
        ft.COLOR_0 !== void 0
          ? nt.getDependency("accessor", ft.COLOR_0)
          : tt.attributes.color;
      lt.push(ht);
    }
  }
  return Promise.all([Promise.all(ot), Promise.all(at), Promise.all(lt)]).then(
    function (ct) {
      const ut = ct[0],
        ft = ct[1],
        ht = ct[2];
      return (
        rt && (tt.morphAttributes.position = ut),
        it && (tt.morphAttributes.normal = ft),
        st && (tt.morphAttributes.color = ht),
        (tt.morphTargetsRelative = !0),
        tt
      );
    }
  );
}
function updateMorphTargets(tt, et) {
  if ((tt.updateMorphTargets(), et.weights !== void 0))
    for (let nt = 0, rt = et.weights.length; nt < rt; nt++)
      tt.morphTargetInfluences[nt] = et.weights[nt];
  if (et.extras && Array.isArray(et.extras.targetNames)) {
    const nt = et.extras.targetNames;
    if (tt.morphTargetInfluences.length === nt.length) {
      tt.morphTargetDictionary = {};
      for (let rt = 0, it = nt.length; rt < it; rt++)
        tt.morphTargetDictionary[nt[rt]] = rt;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function createPrimitiveKey(tt) {
  let et;
  const nt =
    tt.extensions && tt.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (
    (nt
      ? (et =
          "draco:" +
          nt.bufferView +
          ":" +
          nt.indices +
          ":" +
          createAttributesKey(nt.attributes))
      : (et =
          tt.indices +
          ":" +
          createAttributesKey(tt.attributes) +
          ":" +
          tt.mode),
    tt.targets !== void 0)
  )
    for (let rt = 0, it = tt.targets.length; rt < it; rt++)
      et += ":" + createAttributesKey(tt.targets[rt]);
  return et;
}
function createAttributesKey(tt) {
  let et = "";
  const nt = Object.keys(tt).sort();
  for (let rt = 0, it = nt.length; rt < it; rt++)
    et += nt[rt] + ":" + tt[nt[rt]] + ";";
  return et;
}
function getNormalizedComponentScale(tt) {
  switch (tt) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function getImageURIMimeType(tt) {
  return tt.search(/\.jpe?g($|\?)/i) > 0 ||
    tt.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : tt.search(/\.webp($|\?)/i) > 0 || tt.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(et = {}, nt = {}) {
    (this.json = et),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = nt),
      (this.cache = new GLTFRegistry()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let rt = !1,
      it = !1,
      st = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((rt = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (it = navigator.userAgent.indexOf("Firefox") > -1),
      (st = it ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || rt || (it && st < 98)
        ? (this.textureLoader = new TextureLoader(this.options.manager))
        : (this.textureLoader = new ImageBitmapLoader(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new FileLoader(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(et) {
    this.extensions = et;
  }
  setPlugins(et) {
    this.plugins = et;
  }
  parse(et, nt) {
    const rt = this,
      it = this.json,
      st = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (ot) {
        return ot._markDefs && ot._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (ot) {
          return ot.beforeRoot && ot.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            rt.getDependencies("scene"),
            rt.getDependencies("animation"),
            rt.getDependencies("camera"),
          ]);
        })
        .then(function (ot) {
          const at = {
            scene: ot[0][it.scene || 0],
            scenes: ot[0],
            animations: ot[1],
            cameras: ot[2],
            asset: it.asset,
            parser: rt,
            userData: {},
          };
          addUnknownExtensionsToUserData(st, at, it),
            assignExtrasToUserData(at, it),
            Promise.all(
              rt._invokeAll(function (lt) {
                return lt.afterRoot && lt.afterRoot(at);
              })
            ).then(function () {
              et(at);
            });
        })
        .catch(nt);
  }
  _markDefs() {
    const et = this.json.nodes || [],
      nt = this.json.skins || [],
      rt = this.json.meshes || [];
    for (let it = 0, st = nt.length; it < st; it++) {
      const ot = nt[it].joints;
      for (let at = 0, lt = ot.length; at < lt; at++) et[ot[at]].isBone = !0;
    }
    for (let it = 0, st = et.length; it < st; it++) {
      const ot = et[it];
      ot.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, ot.mesh),
        ot.skin !== void 0 && (rt[ot.mesh].isSkinnedMesh = !0)),
        ot.camera !== void 0 && this._addNodeRef(this.cameraCache, ot.camera);
    }
  }
  _addNodeRef(et, nt) {
    nt !== void 0 &&
      (et.refs[nt] === void 0 && (et.refs[nt] = et.uses[nt] = 0),
      et.refs[nt]++);
  }
  _getNodeRef(et, nt, rt) {
    if (et.refs[nt] <= 1) return rt;
    const it = rt.clone(),
      st = (ot, at) => {
        const lt = this.associations.get(ot);
        lt != null && this.associations.set(at, lt);
        for (const [ct, ut] of ot.children.entries()) st(ut, at.children[ct]);
      };
    return st(rt, it), (it.name += "_instance_" + et.uses[nt]++), it;
  }
  _invokeOne(et) {
    const nt = Object.values(this.plugins);
    nt.push(this);
    for (let rt = 0; rt < nt.length; rt++) {
      const it = et(nt[rt]);
      if (it) return it;
    }
    return null;
  }
  _invokeAll(et) {
    const nt = Object.values(this.plugins);
    nt.unshift(this);
    const rt = [];
    for (let it = 0; it < nt.length; it++) {
      const st = et(nt[it]);
      st && rt.push(st);
    }
    return rt;
  }
  getDependency(et, nt) {
    const rt = et + ":" + nt;
    let it = this.cache.get(rt);
    if (!it) {
      switch (et) {
        case "scene":
          it = this.loadScene(nt);
          break;
        case "node":
          it = this._invokeOne(function (st) {
            return st.loadNode && st.loadNode(nt);
          });
          break;
        case "mesh":
          it = this._invokeOne(function (st) {
            return st.loadMesh && st.loadMesh(nt);
          });
          break;
        case "accessor":
          it = this.loadAccessor(nt);
          break;
        case "bufferView":
          it = this._invokeOne(function (st) {
            return st.loadBufferView && st.loadBufferView(nt);
          });
          break;
        case "buffer":
          it = this.loadBuffer(nt);
          break;
        case "material":
          it = this._invokeOne(function (st) {
            return st.loadMaterial && st.loadMaterial(nt);
          });
          break;
        case "texture":
          it = this._invokeOne(function (st) {
            return st.loadTexture && st.loadTexture(nt);
          });
          break;
        case "skin":
          it = this.loadSkin(nt);
          break;
        case "animation":
          it = this._invokeOne(function (st) {
            return st.loadAnimation && st.loadAnimation(nt);
          });
          break;
        case "camera":
          it = this.loadCamera(nt);
          break;
        default:
          if (
            ((it = this._invokeOne(function (st) {
              return st != this && st.getDependency && st.getDependency(et, nt);
            })),
            !it)
          )
            throw new Error("Unknown type: " + et);
          break;
      }
      this.cache.add(rt, it);
    }
    return it;
  }
  getDependencies(et) {
    let nt = this.cache.get(et);
    if (!nt) {
      const rt = this,
        it = this.json[et + (et === "mesh" ? "es" : "s")] || [];
      (nt = Promise.all(
        it.map(function (st, ot) {
          return rt.getDependency(et, ot);
        })
      )),
        this.cache.add(et, nt);
    }
    return nt;
  }
  loadBuffer(et) {
    const nt = this.json.buffers[et],
      rt = this.fileLoader;
    if (nt.type && nt.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + nt.type + " buffer type is not supported."
      );
    if (nt.uri === void 0 && et === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const it = this.options;
    return new Promise(function (st, ot) {
      rt.load(LoaderUtils.resolveURL(nt.uri, it.path), st, void 0, function () {
        ot(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + nt.uri + '".')
        );
      });
    });
  }
  loadBufferView(et) {
    const nt = this.json.bufferViews[et];
    return this.getDependency("buffer", nt.buffer).then(function (rt) {
      const it = nt.byteLength || 0,
        st = nt.byteOffset || 0;
      return rt.slice(st, st + it);
    });
  }
  loadAccessor(et) {
    const nt = this,
      rt = this.json,
      it = this.json.accessors[et];
    if (it.bufferView === void 0 && it.sparse === void 0) {
      const ot = WEBGL_TYPE_SIZES[it.type],
        at = WEBGL_COMPONENT_TYPES[it.componentType],
        lt = it.normalized === !0,
        ct = new at(it.count * ot);
      return Promise.resolve(new BufferAttribute(ct, ot, lt));
    }
    const st = [];
    return (
      it.bufferView !== void 0
        ? st.push(this.getDependency("bufferView", it.bufferView))
        : st.push(null),
      it.sparse !== void 0 &&
        (st.push(
          this.getDependency("bufferView", it.sparse.indices.bufferView)
        ),
        st.push(this.getDependency("bufferView", it.sparse.values.bufferView))),
      Promise.all(st).then(function (ot) {
        const at = ot[0],
          lt = WEBGL_TYPE_SIZES[it.type],
          ct = WEBGL_COMPONENT_TYPES[it.componentType],
          ut = ct.BYTES_PER_ELEMENT,
          ft = ut * lt,
          ht = it.byteOffset || 0,
          mt =
            it.bufferView !== void 0
              ? rt.bufferViews[it.bufferView].byteStride
              : void 0,
          vt = it.normalized === !0;
        let yt, Et;
        if (mt && mt !== ft) {
          const pt = Math.floor(ht / mt),
            xt =
              "InterleavedBuffer:" +
              it.bufferView +
              ":" +
              it.componentType +
              ":" +
              pt +
              ":" +
              it.count;
          let St = nt.cache.get(xt);
          St ||
            ((yt = new ct(at, pt * mt, (it.count * mt) / ut)),
            (St = new InterleavedBuffer(yt, mt / ut)),
            nt.cache.add(xt, St)),
            (Et = new InterleavedBufferAttribute(St, lt, (ht % mt) / ut, vt));
        } else at === null ? (yt = new ct(it.count * lt)) : (yt = new ct(at, ht, it.count * lt)), (Et = new BufferAttribute(yt, lt, vt));
        if (it.sparse !== void 0) {
          const pt = WEBGL_TYPE_SIZES.SCALAR,
            xt = WEBGL_COMPONENT_TYPES[it.sparse.indices.componentType],
            St = it.sparse.indices.byteOffset || 0,
            At = it.sparse.values.byteOffset || 0,
            Ct = new xt(ot[1], St, it.sparse.count * pt),
            Mt = new ct(ot[2], At, it.sparse.count * lt);
          at !== null &&
            (Et = new BufferAttribute(
              Et.array.slice(),
              Et.itemSize,
              Et.normalized
            ));
          for (let wt = 0, Bt = Ct.length; wt < Bt; wt++) {
            const It = Ct[wt];
            if (
              (Et.setX(It, Mt[wt * lt]),
              lt >= 2 && Et.setY(It, Mt[wt * lt + 1]),
              lt >= 3 && Et.setZ(It, Mt[wt * lt + 2]),
              lt >= 4 && Et.setW(It, Mt[wt * lt + 3]),
              lt >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return Et;
      })
    );
  }
  loadTexture(et) {
    const nt = this.json,
      rt = this.options,
      st = nt.textures[et].source,
      ot = nt.images[st];
    let at = this.textureLoader;
    if (ot.uri) {
      const lt = rt.manager.getHandler(ot.uri);
      lt !== null && (at = lt);
    }
    return this.loadTextureImage(et, st, at);
  }
  loadTextureImage(et, nt, rt) {
    const it = this,
      st = this.json,
      ot = st.textures[et],
      at = st.images[nt],
      lt = (at.uri || at.bufferView) + ":" + ot.sampler;
    if (this.textureCache[lt]) return this.textureCache[lt];
    const ct = this.loadImageSource(nt, rt)
      .then(function (ut) {
        (ut.flipY = !1),
          (ut.name = ot.name || at.name || ""),
          ut.name === "" &&
            typeof at.uri == "string" &&
            at.uri.startsWith("data:image/") === !1 &&
            (ut.name = at.uri);
        const ht = (st.samplers || {})[ot.sampler] || {};
        return (
          (ut.magFilter = WEBGL_FILTERS[ht.magFilter] || LinearFilter),
          (ut.minFilter =
            WEBGL_FILTERS[ht.minFilter] || LinearMipmapLinearFilter),
          (ut.wrapS = WEBGL_WRAPPINGS[ht.wrapS] || RepeatWrapping),
          (ut.wrapT = WEBGL_WRAPPINGS[ht.wrapT] || RepeatWrapping),
          it.associations.set(ut, { textures: et }),
          ut
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[lt] = ct), ct;
  }
  loadImageSource(et, nt) {
    const rt = this,
      it = this.json,
      st = this.options;
    if (this.sourceCache[et] !== void 0)
      return this.sourceCache[et].then((ft) => ft.clone());
    const ot = it.images[et],
      at = self.URL || self.webkitURL;
    let lt = ot.uri || "",
      ct = !1;
    if (ot.bufferView !== void 0)
      lt = rt.getDependency("bufferView", ot.bufferView).then(function (ft) {
        ct = !0;
        const ht = new Blob([ft], { type: ot.mimeType });
        return (lt = at.createObjectURL(ht)), lt;
      });
    else if (ot.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + et + " is missing URI and bufferView"
      );
    const ut = Promise.resolve(lt)
      .then(function (ft) {
        return new Promise(function (ht, mt) {
          let vt = ht;
          nt.isImageBitmapLoader === !0 &&
            (vt = function (yt) {
              const Et = new Texture(yt);
              (Et.needsUpdate = !0), ht(Et);
            }),
            nt.load(LoaderUtils.resolveURL(ft, st.path), vt, void 0, mt);
        });
      })
      .then(function (ft) {
        return (
          ct === !0 && at.revokeObjectURL(lt),
          (ft.userData.mimeType = ot.mimeType || getImageURIMimeType(ot.uri)),
          ft
        );
      })
      .catch(function (ft) {
        throw (
          (console.error("THREE.GLTFLoader: Couldn't load texture", lt), ft)
        );
      });
    return (this.sourceCache[et] = ut), ut;
  }
  assignTexture(et, nt, rt, it) {
    const st = this;
    return this.getDependency("texture", rt.index).then(function (ot) {
      if (!ot) return null;
      if (
        (rt.texCoord !== void 0 &&
          rt.texCoord > 0 &&
          ((ot = ot.clone()), (ot.channel = rt.texCoord)),
        st.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM])
      ) {
        const at =
          rt.extensions !== void 0
            ? rt.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (at) {
          const lt = st.associations.get(ot);
          (ot = st.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(
            ot,
            at
          )),
            st.associations.set(ot, lt);
        }
      }
      return (
        it !== void 0 &&
          ("colorSpace" in ot
            ? (ot.colorSpace = it === 3001 ? "srgb" : "srgb-linear")
            : (ot.encoding = it)),
        (et[nt] = ot),
        ot
      );
    });
  }
  assignFinalMaterial(et) {
    const nt = et.geometry;
    let rt = et.material;
    const it = nt.attributes.tangent === void 0,
      st = nt.attributes.color !== void 0,
      ot = nt.attributes.normal === void 0;
    if (et.isPoints) {
      const at = "PointsMaterial:" + rt.uuid;
      let lt = this.cache.get(at);
      lt ||
        ((lt = new PointsMaterial()),
        Material.prototype.copy.call(lt, rt),
        lt.color.copy(rt.color),
        (lt.map = rt.map),
        (lt.sizeAttenuation = !1),
        this.cache.add(at, lt)),
        (rt = lt);
    } else if (et.isLine) {
      const at = "LineBasicMaterial:" + rt.uuid;
      let lt = this.cache.get(at);
      lt ||
        ((lt = new LineBasicMaterial()),
        Material.prototype.copy.call(lt, rt),
        lt.color.copy(rt.color),
        (lt.map = rt.map),
        this.cache.add(at, lt)),
        (rt = lt);
    }
    if (it || st || ot) {
      let at = "ClonedMaterial:" + rt.uuid + ":";
      it && (at += "derivative-tangents:"),
        st && (at += "vertex-colors:"),
        ot && (at += "flat-shading:");
      let lt = this.cache.get(at);
      lt ||
        ((lt = rt.clone()),
        st && (lt.vertexColors = !0),
        ot && (lt.flatShading = !0),
        it &&
          (lt.normalScale && (lt.normalScale.y *= -1),
          lt.clearcoatNormalScale && (lt.clearcoatNormalScale.y *= -1)),
        this.cache.add(at, lt),
        this.associations.set(lt, this.associations.get(rt))),
        (rt = lt);
    }
    et.material = rt;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(et) {
    const nt = this,
      rt = this.json,
      it = this.extensions,
      st = rt.materials[et];
    let ot;
    const at = {},
      lt = st.extensions || {},
      ct = [];
    if (lt[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const ft = it[EXTENSIONS.KHR_MATERIALS_UNLIT];
      (ot = ft.getMaterialType()), ct.push(ft.extendParams(at, st, nt));
    } else {
      const ft = st.pbrMetallicRoughness || {};
      if (
        ((at.color = new Color(1, 1, 1)),
        (at.opacity = 1),
        Array.isArray(ft.baseColorFactor))
      ) {
        const ht = ft.baseColorFactor;
        at.color.fromArray(ht), (at.opacity = ht[3]);
      }
      ft.baseColorTexture !== void 0 &&
        ct.push(nt.assignTexture(at, "map", ft.baseColorTexture, 3001)),
        (at.metalness = ft.metallicFactor !== void 0 ? ft.metallicFactor : 1),
        (at.roughness = ft.roughnessFactor !== void 0 ? ft.roughnessFactor : 1),
        ft.metallicRoughnessTexture !== void 0 &&
          (ct.push(
            nt.assignTexture(at, "metalnessMap", ft.metallicRoughnessTexture)
          ),
          ct.push(
            nt.assignTexture(at, "roughnessMap", ft.metallicRoughnessTexture)
          )),
        (ot = this._invokeOne(function (ht) {
          return ht.getMaterialType && ht.getMaterialType(et);
        })),
        ct.push(
          Promise.all(
            this._invokeAll(function (ht) {
              return ht.extendMaterialParams && ht.extendMaterialParams(et, at);
            })
          )
        );
    }
    st.doubleSided === !0 && (at.side = DoubleSide);
    const ut = st.alphaMode || ALPHA_MODES.OPAQUE;
    if (
      (ut === ALPHA_MODES.BLEND
        ? ((at.transparent = !0), (at.depthWrite = !1))
        : ((at.transparent = !1),
          ut === ALPHA_MODES.MASK &&
            (at.alphaTest = st.alphaCutoff !== void 0 ? st.alphaCutoff : 0.5)),
      st.normalTexture !== void 0 &&
        ot !== MeshBasicMaterial &&
        (ct.push(nt.assignTexture(at, "normalMap", st.normalTexture)),
        (at.normalScale = new Vector2(1, 1)),
        st.normalTexture.scale !== void 0))
    ) {
      const ft = st.normalTexture.scale;
      at.normalScale.set(ft, ft);
    }
    return (
      st.occlusionTexture !== void 0 &&
        ot !== MeshBasicMaterial &&
        (ct.push(nt.assignTexture(at, "aoMap", st.occlusionTexture)),
        st.occlusionTexture.strength !== void 0 &&
          (at.aoMapIntensity = st.occlusionTexture.strength)),
      st.emissiveFactor !== void 0 &&
        ot !== MeshBasicMaterial &&
        (at.emissive = new Color().fromArray(st.emissiveFactor)),
      st.emissiveTexture !== void 0 &&
        ot !== MeshBasicMaterial &&
        ct.push(nt.assignTexture(at, "emissiveMap", st.emissiveTexture, 3001)),
      Promise.all(ct).then(function () {
        const ft = new ot(at);
        return (
          st.name && (ft.name = st.name),
          assignExtrasToUserData(ft, st),
          nt.associations.set(ft, { materials: et }),
          st.extensions && addUnknownExtensionsToUserData(it, ft, st),
          ft
        );
      })
    );
  }
  createUniqueName(et) {
    const nt = PropertyBinding.sanitizeNodeName(et || "");
    return nt in this.nodeNamesUsed
      ? nt + "_" + ++this.nodeNamesUsed[nt]
      : ((this.nodeNamesUsed[nt] = 0), nt);
  }
  loadGeometries(et) {
    const nt = this,
      rt = this.extensions,
      it = this.primitiveCache;
    function st(at) {
      return rt[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(at, nt)
        .then(function (lt) {
          return addPrimitiveAttributes(lt, at, nt);
        });
    }
    const ot = [];
    for (let at = 0, lt = et.length; at < lt; at++) {
      const ct = et[at],
        ut = createPrimitiveKey(ct),
        ft = it[ut];
      if (ft) ot.push(ft.promise);
      else {
        let ht;
        ct.extensions && ct.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
          ? (ht = st(ct))
          : (ht = addPrimitiveAttributes(new BufferGeometry(), ct, nt)),
          (it[ut] = { primitive: ct, promise: ht }),
          ot.push(ht);
      }
    }
    return Promise.all(ot);
  }
  loadMesh(et) {
    const nt = this,
      rt = this.json,
      it = this.extensions,
      st = rt.meshes[et],
      ot = st.primitives,
      at = [];
    for (let lt = 0, ct = ot.length; lt < ct; lt++) {
      const ut =
        ot[lt].material === void 0
          ? createDefaultMaterial(this.cache)
          : this.getDependency("material", ot[lt].material);
      at.push(ut);
    }
    return (
      at.push(nt.loadGeometries(ot)),
      Promise.all(at).then(function (lt) {
        const ct = lt.slice(0, lt.length - 1),
          ut = lt[lt.length - 1],
          ft = [];
        for (let mt = 0, vt = ut.length; mt < vt; mt++) {
          const yt = ut[mt],
            Et = ot[mt];
          let pt;
          const xt = ct[mt];
          if (
            Et.mode === WEBGL_CONSTANTS.TRIANGLES ||
            Et.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
            Et.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
            Et.mode === void 0
          )
            (pt =
              st.isSkinnedMesh === !0
                ? new SkinnedMesh(yt, xt)
                : new Mesh(yt, xt)),
              pt.isSkinnedMesh === !0 && pt.normalizeSkinWeights(),
              Et.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP
                ? (pt.geometry = toTrianglesDrawMode(
                    pt.geometry,
                    TriangleStripDrawMode
                  ))
                : Et.mode === WEBGL_CONSTANTS.TRIANGLE_FAN &&
                  (pt.geometry = toTrianglesDrawMode(
                    pt.geometry,
                    TriangleFanDrawMode
                  ));
          else if (Et.mode === WEBGL_CONSTANTS.LINES)
            pt = new LineSegments(yt, xt);
          else if (Et.mode === WEBGL_CONSTANTS.LINE_STRIP)
            pt = new Line$1(yt, xt);
          else if (Et.mode === WEBGL_CONSTANTS.LINE_LOOP)
            pt = new LineLoop(yt, xt);
          else if (Et.mode === WEBGL_CONSTANTS.POINTS) pt = new Points(yt, xt);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + Et.mode
            );
          Object.keys(pt.geometry.morphAttributes).length > 0 &&
            updateMorphTargets(pt, st),
            (pt.name = nt.createUniqueName(st.name || "mesh_" + et)),
            assignExtrasToUserData(pt, st),
            Et.extensions && addUnknownExtensionsToUserData(it, pt, Et),
            nt.assignFinalMaterial(pt),
            ft.push(pt);
        }
        for (let mt = 0, vt = ft.length; mt < vt; mt++)
          nt.associations.set(ft[mt], { meshes: et, primitives: mt });
        if (ft.length === 1)
          return (
            st.extensions && addUnknownExtensionsToUserData(it, ft[0], st),
            ft[0]
          );
        const ht = new Group();
        st.extensions && addUnknownExtensionsToUserData(it, ht, st),
          nt.associations.set(ht, { meshes: et });
        for (let mt = 0, vt = ft.length; mt < vt; mt++) ht.add(ft[mt]);
        return ht;
      })
    );
  }
  loadCamera(et) {
    let nt;
    const rt = this.json.cameras[et],
      it = rt[rt.type];
    if (!it) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      rt.type === "perspective"
        ? (nt = new PerspectiveCamera(
            MathUtils.radToDeg(it.yfov),
            it.aspectRatio || 1,
            it.znear || 1,
            it.zfar || 2e6
          ))
        : rt.type === "orthographic" &&
          (nt = new OrthographicCamera(
            -it.xmag,
            it.xmag,
            it.ymag,
            -it.ymag,
            it.znear,
            it.zfar
          )),
      rt.name && (nt.name = this.createUniqueName(rt.name)),
      assignExtrasToUserData(nt, rt),
      Promise.resolve(nt)
    );
  }
  loadSkin(et) {
    const nt = this.json.skins[et],
      rt = [];
    for (let it = 0, st = nt.joints.length; it < st; it++)
      rt.push(this._loadNodeShallow(nt.joints[it]));
    return (
      nt.inverseBindMatrices !== void 0
        ? rt.push(this.getDependency("accessor", nt.inverseBindMatrices))
        : rt.push(null),
      Promise.all(rt).then(function (it) {
        const st = it.pop(),
          ot = it,
          at = [],
          lt = [];
        for (let ct = 0, ut = ot.length; ct < ut; ct++) {
          const ft = ot[ct];
          if (ft) {
            at.push(ft);
            const ht = new Matrix4();
            st !== null && ht.fromArray(st.array, ct * 16), lt.push(ht);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              nt.joints[ct]
            );
        }
        return new Skeleton(at, lt);
      })
    );
  }
  loadAnimation(et) {
    const rt = this.json.animations[et],
      it = rt.name ? rt.name : "animation_" + et,
      st = [],
      ot = [],
      at = [],
      lt = [],
      ct = [];
    for (let ut = 0, ft = rt.channels.length; ut < ft; ut++) {
      const ht = rt.channels[ut],
        mt = rt.samplers[ht.sampler],
        vt = ht.target,
        yt = vt.node,
        Et = rt.parameters !== void 0 ? rt.parameters[mt.input] : mt.input,
        pt = rt.parameters !== void 0 ? rt.parameters[mt.output] : mt.output;
      vt.node !== void 0 &&
        (st.push(this.getDependency("node", yt)),
        ot.push(this.getDependency("accessor", Et)),
        at.push(this.getDependency("accessor", pt)),
        lt.push(mt),
        ct.push(vt));
    }
    return Promise.all([
      Promise.all(st),
      Promise.all(ot),
      Promise.all(at),
      Promise.all(lt),
      Promise.all(ct),
    ]).then(function (ut) {
      const ft = ut[0],
        ht = ut[1],
        mt = ut[2],
        vt = ut[3],
        yt = ut[4],
        Et = [];
      for (let pt = 0, xt = ft.length; pt < xt; pt++) {
        const St = ft[pt],
          At = ht[pt],
          Ct = mt[pt],
          Mt = vt[pt],
          wt = yt[pt];
        if (St === void 0) continue;
        St.updateMatrix();
        let Bt;
        switch (PATH_PROPERTIES[wt.path]) {
          case PATH_PROPERTIES.weights:
            Bt = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            Bt = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            Bt = VectorKeyframeTrack;
            break;
        }
        const It = St.name ? St.name : St.uuid,
          Ft =
            Mt.interpolation !== void 0
              ? INTERPOLATION[Mt.interpolation]
              : InterpolateLinear,
          Vt = [];
        PATH_PROPERTIES[wt.path] === PATH_PROPERTIES.weights
          ? St.traverse(function (Kt) {
              Kt.morphTargetInfluences && Vt.push(Kt.name ? Kt.name : Kt.uuid);
            })
          : Vt.push(It);
        let $t = Ct.array;
        if (Ct.normalized) {
          const Kt = getNormalizedComponentScale($t.constructor),
            Ht = new Float32Array($t.length);
          for (let Wt = 0, kt = $t.length; Wt < kt; Wt++) Ht[Wt] = $t[Wt] * Kt;
          $t = Ht;
        }
        for (let Kt = 0, Ht = Vt.length; Kt < Ht; Kt++) {
          const Wt = new Bt(
            Vt[Kt] + "." + PATH_PROPERTIES[wt.path],
            At.array,
            $t,
            Ft
          );
          Mt.interpolation === "CUBICSPLINE" &&
            ((Wt.createInterpolant = function (Gt) {
              const Pt =
                this instanceof QuaternionKeyframeTrack
                  ? GLTFCubicSplineQuaternionInterpolant
                  : GLTFCubicSplineInterpolant;
              return new Pt(
                this.times,
                this.values,
                this.getValueSize() / 3,
                Gt
              );
            }),
            (Wt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            Et.push(Wt);
        }
      }
      return new AnimationClip(it, void 0, Et);
    });
  }
  createNodeMesh(et) {
    const nt = this.json,
      rt = this,
      it = nt.nodes[et];
    return it.mesh === void 0
      ? null
      : rt.getDependency("mesh", it.mesh).then(function (st) {
          const ot = rt._getNodeRef(rt.meshCache, it.mesh, st);
          return (
            it.weights !== void 0 &&
              ot.traverse(function (at) {
                if (at.isMesh)
                  for (let lt = 0, ct = it.weights.length; lt < ct; lt++)
                    at.morphTargetInfluences[lt] = it.weights[lt];
              }),
            ot
          );
        });
  }
  loadNode(et) {
    const nt = this.json,
      rt = this,
      it = nt.nodes[et],
      st = rt._loadNodeShallow(et),
      ot = [],
      at = it.children || [];
    for (let ct = 0, ut = at.length; ct < ut; ct++)
      ot.push(rt.getDependency("node", at[ct]));
    const lt =
      it.skin === void 0
        ? Promise.resolve(null)
        : rt.getDependency("skin", it.skin);
    return Promise.all([st, Promise.all(ot), lt]).then(function (ct) {
      const ut = ct[0],
        ft = ct[1],
        ht = ct[2];
      ht !== null &&
        ut.traverse(function (mt) {
          mt.isSkinnedMesh && mt.bind(ht, _identityMatrix);
        });
      for (let mt = 0, vt = ft.length; mt < vt; mt++) ut.add(ft[mt]);
      return ut;
    });
  }
  _loadNodeShallow(et) {
    const nt = this.json,
      rt = this.extensions,
      it = this;
    if (this.nodeCache[et] !== void 0) return this.nodeCache[et];
    const st = nt.nodes[et],
      ot = st.name ? it.createUniqueName(st.name) : "",
      at = [],
      lt = it._invokeOne(function (ct) {
        return ct.createNodeMesh && ct.createNodeMesh(et);
      });
    return (
      lt && at.push(lt),
      st.camera !== void 0 &&
        at.push(
          it.getDependency("camera", st.camera).then(function (ct) {
            return it._getNodeRef(it.cameraCache, st.camera, ct);
          })
        ),
      it
        ._invokeAll(function (ct) {
          return ct.createNodeAttachment && ct.createNodeAttachment(et);
        })
        .forEach(function (ct) {
          at.push(ct);
        }),
      (this.nodeCache[et] = Promise.all(at).then(function (ct) {
        let ut;
        if (
          (st.isBone === !0
            ? (ut = new Bone())
            : ct.length > 1
            ? (ut = new Group())
            : ct.length === 1
            ? (ut = ct[0])
            : (ut = new Object3D()),
          ut !== ct[0])
        )
          for (let ft = 0, ht = ct.length; ft < ht; ft++) ut.add(ct[ft]);
        if (
          (st.name && ((ut.userData.name = st.name), (ut.name = ot)),
          assignExtrasToUserData(ut, st),
          st.extensions && addUnknownExtensionsToUserData(rt, ut, st),
          st.matrix !== void 0)
        ) {
          const ft = new Matrix4();
          ft.fromArray(st.matrix), ut.applyMatrix4(ft);
        } else st.translation !== void 0 && ut.position.fromArray(st.translation), st.rotation !== void 0 && ut.quaternion.fromArray(st.rotation), st.scale !== void 0 && ut.scale.fromArray(st.scale);
        return (
          it.associations.has(ut) || it.associations.set(ut, {}),
          (it.associations.get(ut).nodes = et),
          ut
        );
      })),
      this.nodeCache[et]
    );
  }
  loadScene(et) {
    const nt = this.extensions,
      rt = this.json.scenes[et],
      it = this,
      st = new Group();
    rt.name && (st.name = it.createUniqueName(rt.name)),
      assignExtrasToUserData(st, rt),
      rt.extensions && addUnknownExtensionsToUserData(nt, st, rt);
    const ot = rt.nodes || [],
      at = [];
    for (let lt = 0, ct = ot.length; lt < ct; lt++)
      at.push(it.getDependency("node", ot[lt]));
    return Promise.all(at).then(function (lt) {
      for (let ut = 0, ft = lt.length; ut < ft; ut++) st.add(lt[ut]);
      const ct = (ut) => {
        const ft = new Map();
        for (const [ht, mt] of it.associations)
          (ht instanceof Material || ht instanceof Texture) && ft.set(ht, mt);
        return (
          ut.traverse((ht) => {
            const mt = it.associations.get(ht);
            mt != null && ft.set(ht, mt);
          }),
          ft
        );
      };
      return (it.associations = ct(st)), st;
    });
  }
}
function computeBounds(tt, et, nt) {
  const rt = et.attributes,
    it = new Box3();
  if (rt.POSITION !== void 0) {
    const at = nt.json.accessors[rt.POSITION],
      lt = at.min,
      ct = at.max;
    if (lt !== void 0 && ct !== void 0) {
      if (
        (it.set(
          new Vector3(lt[0], lt[1], lt[2]),
          new Vector3(ct[0], ct[1], ct[2])
        ),
        at.normalized)
      ) {
        const ut = getNormalizedComponentScale(
          WEBGL_COMPONENT_TYPES[at.componentType]
        );
        it.min.multiplyScalar(ut), it.max.multiplyScalar(ut);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const st = et.targets;
  if (st !== void 0) {
    const at = new Vector3(),
      lt = new Vector3();
    for (let ct = 0, ut = st.length; ct < ut; ct++) {
      const ft = st[ct];
      if (ft.POSITION !== void 0) {
        const ht = nt.json.accessors[ft.POSITION],
          mt = ht.min,
          vt = ht.max;
        if (mt !== void 0 && vt !== void 0) {
          if (
            (lt.setX(Math.max(Math.abs(mt[0]), Math.abs(vt[0]))),
            lt.setY(Math.max(Math.abs(mt[1]), Math.abs(vt[1]))),
            lt.setZ(Math.max(Math.abs(mt[2]), Math.abs(vt[2]))),
            ht.normalized)
          ) {
            const yt = getNormalizedComponentScale(
              WEBGL_COMPONENT_TYPES[ht.componentType]
            );
            lt.multiplyScalar(yt);
          }
          at.max(lt);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    it.expandByVector(at);
  }
  tt.boundingBox = it;
  const ot = new Sphere();
  it.getCenter(ot.center),
    (ot.radius = it.min.distanceTo(it.max) / 2),
    (tt.boundingSphere = ot);
}
function addPrimitiveAttributes(tt, et, nt) {
  const rt = et.attributes,
    it = [];
  function st(ot, at) {
    return nt.getDependency("accessor", ot).then(function (lt) {
      tt.setAttribute(at, lt);
    });
  }
  for (const ot in rt) {
    const at = ATTRIBUTES[ot] || ot.toLowerCase();
    at in tt.attributes || it.push(st(rt[ot], at));
  }
  if (et.indices !== void 0 && !tt.index) {
    const ot = nt.getDependency("accessor", et.indices).then(function (at) {
      tt.setIndex(at);
    });
    it.push(ot);
  }
  return (
    assignExtrasToUserData(tt, et),
    computeBounds(tt, et, nt),
    Promise.all(it).then(function () {
      return et.targets !== void 0 ? addMorphTargets(tt, et.targets, nt) : tt;
    })
  );
}
const GammaCorrectionShader = {
    uniforms: { tDiffuse: { value: null } },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}",
    ].join(`
`),
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 tex = texture2D( tDiffuse, vUv );",
      "	gl_FragColor = LinearTosRGB( tex );",
      "}",
    ].join(`
`),
  },
  _taskCache = new WeakMap();
class DRACOLoader extends Loader {
  constructor(et) {
    super(et),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(et) {
    return (this.decoderPath = et), this;
  }
  setDecoderConfig(et) {
    return (this.decoderConfig = et), this;
  }
  setWorkerLimit(et) {
    return (this.workerLimit = et), this;
  }
  load(et, nt, rt, it) {
    const st = new FileLoader(this.manager);
    st.setPath(this.path),
      st.setResponseType("arraybuffer"),
      st.setRequestHeader(this.requestHeader),
      st.setWithCredentials(this.withCredentials),
      st.load(
        et,
        (ot) => {
          const at = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(ot, at).then(nt).catch(it);
        },
        rt,
        it
      );
  }
  decodeDracoFile(et, nt, rt, it) {
    const st = {
      attributeIDs: rt || this.defaultAttributeIDs,
      attributeTypes: it || this.defaultAttributeTypes,
      useUniqueIDs: !!rt,
    };
    this.decodeGeometry(et, st).then(nt);
  }
  decodeGeometry(et, nt) {
    for (const lt in nt.attributeTypes) {
      const ct = nt.attributeTypes[lt];
      ct.BYTES_PER_ELEMENT !== void 0 && (nt.attributeTypes[lt] = ct.name);
    }
    const rt = JSON.stringify(nt);
    if (_taskCache.has(et)) {
      const lt = _taskCache.get(et);
      if (lt.key === rt) return lt.promise;
      if (et.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let it;
    const st = this.workerNextTaskID++,
      ot = et.byteLength,
      at = this._getWorker(st, ot)
        .then(
          (lt) => (
            (it = lt),
            new Promise((ct, ut) => {
              (it._callbacks[st] = { resolve: ct, reject: ut }),
                it.postMessage(
                  { type: "decode", id: st, taskConfig: nt, buffer: et },
                  [et]
                );
            })
          )
        )
        .then((lt) => this._createGeometry(lt.geometry));
    return (
      at
        .catch(() => !0)
        .then(() => {
          it && st && this._releaseTask(it, st);
        }),
      _taskCache.set(et, { key: rt, promise: at }),
      at
    );
  }
  _createGeometry(et) {
    const nt = new BufferGeometry();
    et.index && nt.setIndex(new BufferAttribute(et.index.array, 1));
    for (let rt = 0; rt < et.attributes.length; rt++) {
      const it = et.attributes[rt],
        st = it.name,
        ot = it.array,
        at = it.itemSize;
      nt.setAttribute(st, new BufferAttribute(ot, at));
    }
    return nt;
  }
  _loadLibrary(et, nt) {
    const rt = new FileLoader(this.manager);
    return (
      rt.setPath(this.decoderPath),
      rt.setResponseType(nt),
      rt.setWithCredentials(this.withCredentials),
      new Promise((it, st) => {
        rt.load(et, it, void 0, st);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const et =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      nt = [];
    return (
      et
        ? nt.push(this._loadLibrary("draco_decoder.js", "text"))
        : (nt.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          nt.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(nt).then((rt) => {
        const it = rt[0];
        et || (this.decoderConfig.wasmBinary = rt[1]);
        const st = DRACOWorker.toString(),
          ot = [
            "/* draco decoder */",
            it,
            "",
            "/* worker */",
            st.substring(st.indexOf("{") + 1, st.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([ot]));
      })),
      this.decoderPending
    );
  }
  _getWorker(et, nt) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const it = new Worker(this.workerSourceURL);
        (it._callbacks = {}),
          (it._taskCosts = {}),
          (it._taskLoad = 0),
          it.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (it.onmessage = function (st) {
            const ot = st.data;
            switch (ot.type) {
              case "decode":
                it._callbacks[ot.id].resolve(ot);
                break;
              case "error":
                it._callbacks[ot.id].reject(ot);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + ot.type + '"'
                );
            }
          }),
          this.workerPool.push(it);
      } else
        this.workerPool.sort(function (it, st) {
          return it._taskLoad > st._taskLoad ? -1 : 1;
        });
      const rt = this.workerPool[this.workerPool.length - 1];
      return (rt._taskCosts[et] = nt), (rt._taskLoad += nt), rt;
    });
  }
  _releaseTask(et, nt) {
    (et._taskLoad -= et._taskCosts[nt]),
      delete et._callbacks[nt],
      delete et._taskCosts[nt];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((et) => et._taskLoad)
    );
  }
  dispose() {
    for (let et = 0; et < this.workerPool.length; ++et)
      this.workerPool[et].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function DRACOWorker() {
  let tt, et;
  onmessage = function (ot) {
    const at = ot.data;
    switch (at.type) {
      case "init":
        (tt = at.decoderConfig),
          (et = new Promise(function (ut) {
            (tt.onModuleLoaded = function (ft) {
              ut({ draco: ft });
            }),
              DracoDecoderModule(tt);
          }));
        break;
      case "decode":
        const lt = at.buffer,
          ct = at.taskConfig;
        et.then((ut) => {
          const ft = ut.draco,
            ht = new ft.Decoder(),
            mt = new ft.DecoderBuffer();
          mt.Init(new Int8Array(lt), lt.byteLength);
          try {
            const vt = nt(ft, ht, mt, ct),
              yt = vt.attributes.map((Et) => Et.array.buffer);
            vt.index && yt.push(vt.index.array.buffer),
              self.postMessage({ type: "decode", id: at.id, geometry: vt }, yt);
          } catch (vt) {
            console.error(vt),
              self.postMessage({ type: "error", id: at.id, error: vt.message });
          } finally {
            ft.destroy(mt), ft.destroy(ht);
          }
        });
        break;
    }
  };
  function nt(ot, at, lt, ct) {
    const ut = ct.attributeIDs,
      ft = ct.attributeTypes;
    let ht, mt;
    const vt = at.GetEncodedGeometryType(lt);
    if (vt === ot.TRIANGULAR_MESH)
      (ht = new ot.Mesh()), (mt = at.DecodeBufferToMesh(lt, ht));
    else if (vt === ot.POINT_CLOUD)
      (ht = new ot.PointCloud()), (mt = at.DecodeBufferToPointCloud(lt, ht));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!mt.ok() || ht.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + mt.error_msg());
    const yt = { index: null, attributes: [] };
    for (const Et in ut) {
      const pt = self[ft[Et]];
      let xt, St;
      if (ct.useUniqueIDs)
        (St = ut[Et]), (xt = at.GetAttributeByUniqueId(ht, St));
      else {
        if (((St = at.GetAttributeId(ht, ot[ut[Et]])), St === -1)) continue;
        xt = at.GetAttribute(ht, St);
      }
      yt.attributes.push(it(ot, at, ht, Et, pt, xt));
    }
    return (
      vt === ot.TRIANGULAR_MESH && (yt.index = rt(ot, at, ht)),
      ot.destroy(ht),
      yt
    );
  }
  function rt(ot, at, lt) {
    const ut = lt.num_faces() * 3,
      ft = ut * 4,
      ht = ot._malloc(ft);
    at.GetTrianglesUInt32Array(lt, ft, ht);
    const mt = new Uint32Array(ot.HEAPF32.buffer, ht, ut).slice();
    return ot._free(ht), { array: mt, itemSize: 1 };
  }
  function it(ot, at, lt, ct, ut, ft) {
    const ht = ft.num_components(),
      vt = lt.num_points() * ht,
      yt = vt * ut.BYTES_PER_ELEMENT,
      Et = st(ot, ut),
      pt = ot._malloc(yt);
    at.GetAttributeDataArrayForAllPoints(lt, ft, Et, yt, pt);
    const xt = new ut(ot.HEAPF32.buffer, pt, vt).slice();
    return ot._free(pt), { name: ct, array: xt, itemSize: ht };
  }
  function st(ot, at) {
    switch (at) {
      case Float32Array:
        return ot.DT_FLOAT32;
      case Int8Array:
        return ot.DT_INT8;
      case Int16Array:
        return ot.DT_INT16;
      case Int32Array:
        return ot.DT_INT32;
      case Uint8Array:
        return ot.DT_UINT8;
      case Uint16Array:
        return ot.DT_UINT16;
      case Uint32Array:
        return ot.DT_UINT32;
    }
  }
}
const _box$1 = new Box3(),
  _vector = new Vector3();
class LineSegmentsGeometry extends InstancedBufferGeometry {
  constructor() {
    super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = "LineSegmentsGeometry");
    const et = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      nt = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      rt = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(rt),
      this.setAttribute("position", new Float32BufferAttribute(et, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(nt, 2));
  }
  applyMatrix4(et) {
    const nt = this.attributes.instanceStart,
      rt = this.attributes.instanceEnd;
    return (
      nt !== void 0 &&
        (nt.applyMatrix4(et), rt.applyMatrix4(et), (nt.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  setPositions(et) {
    let nt;
    et instanceof Float32Array
      ? (nt = et)
      : Array.isArray(et) && (nt = new Float32Array(et));
    const rt = new InstancedInterleavedBuffer(nt, 6, 1);
    return (
      this.setAttribute(
        "instanceStart",
        new InterleavedBufferAttribute(rt, 3, 0)
      ),
      this.setAttribute(
        "instanceEnd",
        new InterleavedBufferAttribute(rt, 3, 3)
      ),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    );
  }
  setColors(et) {
    let nt;
    et instanceof Float32Array
      ? (nt = et)
      : Array.isArray(et) && (nt = new Float32Array(et));
    const rt = new InstancedInterleavedBuffer(nt, 6, 1);
    return (
      this.setAttribute(
        "instanceColorStart",
        new InterleavedBufferAttribute(rt, 3, 0)
      ),
      this.setAttribute(
        "instanceColorEnd",
        new InterleavedBufferAttribute(rt, 3, 3)
      ),
      this
    );
  }
  fromWireframeGeometry(et) {
    return this.setPositions(et.attributes.position.array), this;
  }
  fromEdgesGeometry(et) {
    return this.setPositions(et.attributes.position.array), this;
  }
  fromMesh(et) {
    return this.fromWireframeGeometry(new WireframeGeometry(et.geometry)), this;
  }
  fromLineSegments(et) {
    const nt = et.geometry;
    return this.setPositions(nt.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const et = this.attributes.instanceStart,
      nt = this.attributes.instanceEnd;
    et !== void 0 &&
      nt !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(et),
      _box$1.setFromBufferAttribute(nt),
      this.boundingBox.union(_box$1));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      this.boundingBox === null && this.computeBoundingBox();
    const et = this.attributes.instanceStart,
      nt = this.attributes.instanceEnd;
    if (et !== void 0 && nt !== void 0) {
      const rt = this.boundingSphere.center;
      this.boundingBox.getCenter(rt);
      let it = 0;
      for (let st = 0, ot = et.count; st < ot; st++)
        _vector.fromBufferAttribute(et, st),
          (it = Math.max(it, rt.distanceToSquared(_vector))),
          _vector.fromBufferAttribute(nt, st),
          (it = Math.max(it, rt.distanceToSquared(_vector)));
      (this.boundingSphere.radius = Math.sqrt(it)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this
          );
    }
  }
  toJSON() {}
  applyMatrix(et) {
    return (
      console.warn(
        "THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."
      ),
      this.applyMatrix4(et)
    );
  }
}
class LineGeometry extends LineSegmentsGeometry {
  constructor() {
    super(), (this.isLineGeometry = !0), (this.type = "LineGeometry");
  }
  setPositions(et) {
    const nt = et.length - 3,
      rt = new Float32Array(2 * nt);
    for (let it = 0; it < nt; it += 3)
      (rt[2 * it] = et[it]),
        (rt[2 * it + 1] = et[it + 1]),
        (rt[2 * it + 2] = et[it + 2]),
        (rt[2 * it + 3] = et[it + 3]),
        (rt[2 * it + 4] = et[it + 4]),
        (rt[2 * it + 5] = et[it + 5]);
    return super.setPositions(rt), this;
  }
  setColors(et) {
    const nt = et.length - 3,
      rt = new Float32Array(2 * nt);
    for (let it = 0; it < nt; it += 3)
      (rt[2 * it] = et[it]),
        (rt[2 * it + 1] = et[it + 1]),
        (rt[2 * it + 2] = et[it + 2]),
        (rt[2 * it + 3] = et[it + 3]),
        (rt[2 * it + 4] = et[it + 4]),
        (rt[2 * it + 5] = et[it + 5]);
    return super.setColors(rt), this;
  }
  fromLine(et) {
    const nt = et.geometry;
    return this.setPositions(nt.attributes.position.array), this;
  }
}
class LineMaterial extends ShaderMaterial {
  constructor(et) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(
        UniformsUtils.merge([
          UniformsLib.common,
          UniformsLib.fog,
          {
            worldUnits: { value: 1 },
            linewidth: { value: 1 },
            resolution: { value: new Vector2(1, 1) },
            dashOffset: { value: 0 },
            dashScale: { value: 1 },
            dashSize: { value: 1 },
            gapSize: { value: 1 },
          },
        ])
      ),
      vertexShader: `
				#include <common>
				#include <color_pars_vertex>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				attribute vec3 instanceColorStart;
				attribute vec3 instanceColorEnd;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
      fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <color_pars_fragment>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );

					#include <logdepthbuf_fragment>
					#include <color_fragment>

					gl_FragColor = vec4( diffuseColor.rgb, alpha );

					#include <tonemapping_fragment>
					#include <${
            parseInt(REVISION.replace(/\D+/g, "")) >= 154
              ? "colorspace_fragment"
              : "encodings_fragment"
          }>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (nt) {
            this.uniforms.diffuse.value = nt;
          },
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (nt) {
            nt === !0
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS;
          },
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (nt) {
            this.uniforms.linewidth.value = nt;
          },
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return "USE_DASH" in this.defines;
          },
          set(nt) {
            !!nt != "USE_DASH" in this.defines && (this.needsUpdate = !0),
              nt === !0
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH;
          },
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (nt) {
            this.uniforms.dashScale.value = nt;
          },
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (nt) {
            this.uniforms.dashSize.value = nt;
          },
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (nt) {
            this.uniforms.dashOffset.value = nt;
          },
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (nt) {
            this.uniforms.gapSize.value = nt;
          },
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (nt) {
            this.uniforms.opacity.value = nt;
          },
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (nt) {
            this.uniforms.resolution.value.copy(nt);
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return "USE_ALPHA_TO_COVERAGE" in this.defines;
          },
          set: function (nt) {
            !!nt != "USE_ALPHA_TO_COVERAGE" in this.defines &&
              (this.needsUpdate = !0),
              nt === !0
                ? ((this.defines.USE_ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1));
          },
        },
      }),
      this.setValues(et);
  }
}
const _start = new Vector3(),
  _end = new Vector3(),
  _start4 = new Vector4(),
  _end4 = new Vector4(),
  _ssOrigin = new Vector4(),
  _ssOrigin3 = new Vector3(),
  _mvMatrix = new Matrix4(),
  _line = new Line3(),
  _closestPoint = new Vector3(),
  _box = new Box3(),
  _sphere = new Sphere(),
  _clipToWorldVector = new Vector4();
let _ray, _instanceStart, _instanceEnd, _lineWidth;
function getWorldSpaceHalfWidth(tt, et, nt) {
  return (
    _clipToWorldVector.set(0, 0, -et, 1).applyMatrix4(tt.projectionMatrix),
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w),
    (_clipToWorldVector.x = _lineWidth / nt.width),
    (_clipToWorldVector.y = _lineWidth / nt.height),
    _clipToWorldVector.applyMatrix4(tt.projectionMatrixInverse),
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w),
    Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))
  );
}
function raycastWorldUnits(tt, et) {
  for (let nt = 0, rt = _instanceStart.count; nt < rt; nt++) {
    _line.start.fromBufferAttribute(_instanceStart, nt),
      _line.end.fromBufferAttribute(_instanceEnd, nt);
    const it = new Vector3(),
      st = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, st, it),
      st.distanceTo(it) < _lineWidth * 0.5 &&
        et.push({
          point: st,
          pointOnLine: it,
          distance: _ray.origin.distanceTo(st),
          object: tt,
          face: null,
          faceIndex: nt,
          uv: null,
          uv2: null,
        });
  }
}
function raycastScreenSpace(tt, et, nt) {
  const rt = et.projectionMatrix,
    st = tt.material.resolution,
    ot = tt.matrixWorld,
    at = tt.geometry,
    lt = at.attributes.instanceStart,
    ct = at.attributes.instanceEnd,
    ut = -et.near;
  _ray.at(1, _ssOrigin),
    (_ssOrigin.w = 1),
    _ssOrigin.applyMatrix4(et.matrixWorldInverse),
    _ssOrigin.applyMatrix4(rt),
    _ssOrigin.multiplyScalar(1 / _ssOrigin.w),
    (_ssOrigin.x *= st.x / 2),
    (_ssOrigin.y *= st.y / 2),
    (_ssOrigin.z = 0),
    _ssOrigin3.copy(_ssOrigin),
    _mvMatrix.multiplyMatrices(et.matrixWorldInverse, ot);
  for (let ft = 0, ht = lt.count; ft < ht; ft++) {
    if (
      (_start4.fromBufferAttribute(lt, ft),
      _end4.fromBufferAttribute(ct, ft),
      (_start4.w = 1),
      (_end4.w = 1),
      _start4.applyMatrix4(_mvMatrix),
      _end4.applyMatrix4(_mvMatrix),
      _start4.z > ut && _end4.z > ut)
    )
      continue;
    if (_start4.z > ut) {
      const xt = _start4.z - _end4.z,
        St = (_start4.z - ut) / xt;
      _start4.lerp(_end4, St);
    } else if (_end4.z > ut) {
      const xt = _end4.z - _start4.z,
        St = (_end4.z - ut) / xt;
      _end4.lerp(_start4, St);
    }
    _start4.applyMatrix4(rt),
      _end4.applyMatrix4(rt),
      _start4.multiplyScalar(1 / _start4.w),
      _end4.multiplyScalar(1 / _end4.w),
      (_start4.x *= st.x / 2),
      (_start4.y *= st.y / 2),
      (_end4.x *= st.x / 2),
      (_end4.y *= st.y / 2),
      _line.start.copy(_start4),
      (_line.start.z = 0),
      _line.end.copy(_end4),
      (_line.end.z = 0);
    const vt = _line.closestPointToPointParameter(_ssOrigin3, !0);
    _line.at(vt, _closestPoint);
    const yt = MathUtils.lerp(_start4.z, _end4.z, vt),
      Et = yt >= -1 && yt <= 1,
      pt = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (Et && pt) {
      _line.start.fromBufferAttribute(lt, ft),
        _line.end.fromBufferAttribute(ct, ft),
        _line.start.applyMatrix4(ot),
        _line.end.applyMatrix4(ot);
      const xt = new Vector3(),
        St = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, St, xt),
        nt.push({
          point: St,
          pointOnLine: xt,
          distance: _ray.origin.distanceTo(St),
          object: tt,
          face: null,
          faceIndex: ft,
          uv: null,
          uv2: null,
        });
    }
  }
}
class LineSegments2 extends Mesh {
  constructor(
    et = new LineSegmentsGeometry(),
    nt = new LineMaterial({ color: Math.random() * 16777215 })
  ) {
    super(et, nt), (this.isLineSegments2 = !0), (this.type = "LineSegments2");
  }
  computeLineDistances() {
    const et = this.geometry,
      nt = et.attributes.instanceStart,
      rt = et.attributes.instanceEnd,
      it = new Float32Array(2 * nt.count);
    for (let ot = 0, at = 0, lt = nt.count; ot < lt; ot++, at += 2)
      _start.fromBufferAttribute(nt, ot),
        _end.fromBufferAttribute(rt, ot),
        (it[at] = at === 0 ? 0 : it[at - 1]),
        (it[at + 1] = it[at] + _start.distanceTo(_end));
    const st = new InstancedInterleavedBuffer(it, 2, 1);
    return (
      et.setAttribute(
        "instanceDistanceStart",
        new InterleavedBufferAttribute(st, 1, 0)
      ),
      et.setAttribute(
        "instanceDistanceEnd",
        new InterleavedBufferAttribute(st, 1, 1)
      ),
      this
    );
  }
  raycast(et, nt) {
    const rt = this.material.worldUnits,
      it = et.camera;
    it === null &&
      !rt &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
      );
    const st = (et.params.Line2 !== void 0 && et.params.Line2.threshold) || 0;
    _ray = et.ray;
    const ot = this.matrixWorld,
      at = this.geometry,
      lt = this.material;
    (_lineWidth = lt.linewidth + st),
      (_instanceStart = at.attributes.instanceStart),
      (_instanceEnd = at.attributes.instanceEnd),
      at.boundingSphere === null && at.computeBoundingSphere(),
      _sphere.copy(at.boundingSphere).applyMatrix4(ot);
    let ct;
    if (rt) ct = _lineWidth * 0.5;
    else {
      const ft = Math.max(it.near, _sphere.distanceToPoint(_ray.origin));
      ct = getWorldSpaceHalfWidth(it, ft, lt.resolution);
    }
    if (((_sphere.radius += ct), _ray.intersectsSphere(_sphere) === !1)) return;
    at.boundingBox === null && at.computeBoundingBox(),
      _box.copy(at.boundingBox).applyMatrix4(ot);
    let ut;
    if (rt) ut = _lineWidth * 0.5;
    else {
      const ft = Math.max(it.near, _box.distanceToPoint(_ray.origin));
      ut = getWorldSpaceHalfWidth(it, ft, lt.resolution);
    }
    _box.expandByScalar(ut),
      _ray.intersectsBox(_box) !== !1 &&
        (rt ? raycastWorldUnits(this, nt) : raycastScreenSpace(this, it, nt));
  }
}
class Line2 extends LineSegments2 {
  constructor(
    et = new LineGeometry(),
    nt = new LineMaterial({ color: Math.random() * 16777215 })
  ) {
    super(et, nt), (this.isLine2 = !0), (this.type = "Line2");
  }
}
let generated;
const MeshoptDecoder = () => {
    if (generated) return generated;
    const tt =
        "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
      et =
        "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
      nt = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1,
        0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0,
        11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      rt = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
        128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
        107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
        44, 45, 74, 156, 154, 70, 167,
      ]);
    if (typeof WebAssembly != "object") return { supported: !1 };
    let it = tt;
    WebAssembly.validate(nt) && (it = et);
    let st;
    const ot = WebAssembly.instantiate(at(it), {}).then((ft) => {
      (st = ft.instance), st.exports.__wasm_call_ctors();
    });
    function at(ft) {
      const ht = new Uint8Array(ft.length);
      for (let vt = 0; vt < ft.length; ++vt) {
        const yt = ft.charCodeAt(vt);
        ht[vt] =
          yt > 96
            ? yt - 71
            : yt > 64
            ? yt - 65
            : yt > 47
            ? yt + 4
            : yt > 46
            ? 63
            : 62;
      }
      let mt = 0;
      for (let vt = 0; vt < ft.length; ++vt)
        ht[mt++] = ht[vt] < 60 ? rt[ht[vt]] : (ht[vt] - 60) * 64 + ht[++vt];
      return ht.buffer.slice(0, mt);
    }
    function lt(ft, ht, mt, vt, yt, Et) {
      const pt = st.exports.sbrk,
        xt = (mt + 3) & -4,
        St = pt(xt * vt),
        At = pt(yt.length),
        Ct = new Uint8Array(st.exports.memory.buffer);
      Ct.set(yt, At);
      const Mt = ft(St, mt, vt, At, yt.length);
      if (
        (Mt === 0 && Et && Et(St, xt, vt),
        ht.set(Ct.subarray(St, St + mt * vt)),
        pt(St - pt(0)),
        Mt !== 0)
      )
        throw new Error(`Malformed buffer data: ${Mt}`);
    }
    const ct = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp",
      },
      ut = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence",
      };
    return (
      (generated = {
        ready: ot,
        supported: !0,
        decodeVertexBuffer(ft, ht, mt, vt, yt) {
          lt(
            st.exports.meshopt_decodeVertexBuffer,
            ft,
            ht,
            mt,
            vt,
            st.exports[ct[yt]]
          );
        },
        decodeIndexBuffer(ft, ht, mt, vt) {
          lt(st.exports.meshopt_decodeIndexBuffer, ft, ht, mt, vt);
        },
        decodeIndexSequence(ft, ht, mt, vt) {
          lt(st.exports.meshopt_decodeIndexSequence, ft, ht, mt, vt);
        },
        decodeGltfBuffer(ft, ht, mt, vt, yt, Et) {
          lt(st.exports[ut[yt]], ft, ht, mt, vt, st.exports[ct[Et]]);
        },
      }),
      generated
    );
  },
  Line = reactExports.forwardRef(function (
    {
      points: et,
      color: nt = "black",
      vertexColors: rt,
      linewidth: it,
      lineWidth: st,
      segments: ot,
      dashed: at,
      ...lt
    },
    ct
  ) {
    const ut = useThree((vt) => vt.size),
      ft = reactExports.useMemo(
        () => (ot ? new LineSegments2() : new Line2()),
        [ot]
      ),
      [ht] = reactExports.useState(() => new LineMaterial()),
      mt = reactExports.useMemo(() => {
        const vt = ot ? new LineSegmentsGeometry() : new LineGeometry(),
          yt = et.map((Et) => {
            const pt = Array.isArray(Et);
            return Et instanceof Vector3
              ? [Et.x, Et.y, Et.z]
              : Et instanceof Vector2
              ? [Et.x, Et.y, 0]
              : pt && Et.length === 3
              ? [Et[0], Et[1], Et[2]]
              : pt && Et.length === 2
              ? [Et[0], Et[1], 0]
              : Et;
          });
        if ((vt.setPositions(yt.flat()), rt)) {
          const Et = rt.map((pt) => (pt instanceof Color ? pt.toArray() : pt));
          vt.setColors(Et.flat());
        }
        return vt;
      }, [et, ot, rt]);
    return (
      reactExports.useLayoutEffect(() => {
        ft.computeLineDistances();
      }, [et, ft]),
      reactExports.useLayoutEffect(() => {
        at ? (ht.defines.USE_DASH = "") : delete ht.defines.USE_DASH,
          (ht.needsUpdate = !0);
      }, [at, ht]),
      reactExports.useEffect(() => () => mt.dispose(), [mt]),
      reactExports.createElement(
        "primitive",
        _extends({ object: ft, ref: ct }, lt),
        reactExports.createElement("primitive", {
          object: mt,
          attach: "geometry",
        }),
        reactExports.createElement(
          "primitive",
          _extends(
            {
              object: ht,
              attach: "material",
              color: nt,
              vertexColors: !!rt,
              resolution: [ut.width, ut.height],
              linewidth: it ?? st,
              dashed: at,
            },
            lt
          )
        )
      )
    );
  });
function workerBootstrap() {
  var tt = Object.create(null);
  function et(it, st) {
    var ot = it.id,
      at = it.name,
      lt = it.dependencies;
    lt === void 0 && (lt = []);
    var ct = it.init;
    ct === void 0 && (ct = function () {});
    var ut = it.getTransferables;
    if ((ut === void 0 && (ut = null), !tt[ot]))
      try {
        (lt = lt.map(function (ht) {
          return (
            ht &&
              ht.isWorkerModule &&
              (et(ht, function (mt) {
                if (mt instanceof Error) throw mt;
              }),
              (ht = tt[ht.id].value)),
            ht
          );
        })),
          (ct = rt("<" + at + ">.init", ct)),
          ut && (ut = rt("<" + at + ">.getTransferables", ut));
        var ft = null;
        typeof ct == "function"
          ? (ft = ct.apply(void 0, lt))
          : console.error("worker module init function failed to rehydrate"),
          (tt[ot] = { id: ot, value: ft, getTransferables: ut }),
          st(ft);
      } catch (ht) {
        (ht && ht.noLog) || console.error(ht), st(ht);
      }
  }
  function nt(it, st) {
    var ot,
      at = it.id,
      lt = it.args;
    (!tt[at] || typeof tt[at].value != "function") &&
      st(
        new Error(
          "Worker module " +
            at +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var ct = (ot = tt[at]).value.apply(ot, lt);
      ct && typeof ct.then == "function"
        ? ct.then(ut, function (ft) {
            return st(ft instanceof Error ? ft : new Error("" + ft));
          })
        : ut(ct);
    } catch (ft) {
      st(ft);
    }
    function ut(ft) {
      try {
        var ht = tt[at].getTransferables && tt[at].getTransferables(ft);
        (!ht || !Array.isArray(ht) || !ht.length) && (ht = void 0), st(ft, ht);
      } catch (mt) {
        console.error(mt), st(mt);
      }
    }
  }
  function rt(it, st) {
    var ot = void 0;
    self.troikaDefine = function (lt) {
      return (ot = lt);
    };
    var at = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            it.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            st +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(at);
    } catch (lt) {
      console.error(lt);
    }
    return URL.revokeObjectURL(at), delete self.troikaDefine, ot;
  }
  self.addEventListener("message", function (it) {
    var st = it.data,
      ot = st.messageId,
      at = st.action,
      lt = st.data;
    try {
      at === "registerModule" &&
        et(lt, function (ct) {
          ct instanceof Error
            ? postMessage({ messageId: ot, success: !1, error: ct.message })
            : postMessage({
                messageId: ot,
                success: !0,
                result: { isCallable: typeof ct == "function" },
              });
        }),
        at === "callModule" &&
          nt(lt, function (ct, ut) {
            ct instanceof Error
              ? postMessage({ messageId: ot, success: !1, error: ct.message })
              : postMessage(
                  { messageId: ot, success: !0, result: ct },
                  ut || void 0
                );
          });
    } catch (ct) {
      postMessage({ messageId: ot, success: !1, error: ct.stack });
    }
  });
}
function defineMainThreadModule(tt) {
  var et = function () {
    for (var nt = [], rt = arguments.length; rt--; ) nt[rt] = arguments[rt];
    return et._getInitResult().then(function (it) {
      if (typeof it == "function") return it.apply(void 0, nt);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (et._getInitResult = function () {
      var nt = tt.dependencies,
        rt = tt.init;
      nt = Array.isArray(nt)
        ? nt.map(function (st) {
            return st && st._getInitResult ? st._getInitResult() : st;
          })
        : [];
      var it = Promise.all(nt).then(function (st) {
        return rt.apply(null, st);
      });
      return (
        (et._getInitResult = function () {
          return it;
        }),
        it
      );
    }),
    et
  );
}
var supportsWorkers = function () {
    var tt = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var et = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        et.terminate(), (tt = !0);
      } catch (nt) {
        typeof process < "u",
          console.log(
            "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
              nt.message +
              "]"
          );
      }
    return (
      (supportsWorkers = function () {
        return tt;
      }),
      tt
    );
  },
  _workerModuleId = 0,
  _messageId = 0,
  _allowInitAsString = !1,
  workers = Object.create(null),
  registeredModules = Object.create(null),
  openRequests = Object.create(null);
function defineWorkerModule(tt) {
  if ((!tt || typeof tt.init != "function") && !_allowInitAsString)
    throw new Error("requires `options.init` function");
  var et = tt.dependencies,
    nt = tt.init,
    rt = tt.getTransferables,
    it = tt.workerId;
  if (!supportsWorkers()) return defineMainThreadModule(tt);
  it == null && (it = "#default");
  var st = "workerModule" + ++_workerModuleId,
    ot = tt.name || st,
    at = null;
  et =
    et &&
    et.map(function (ct) {
      return (
        typeof ct == "function" &&
          !ct.workerModuleData &&
          ((_allowInitAsString = !0),
          (ct = defineWorkerModule({
            workerId: it,
            name: "<" + ot + "> function dependency: " + ct.name,
            init:
              `function(){return (
` +
              stringifyFunction(ct) +
              `
)}`,
          })),
          (_allowInitAsString = !1)),
        ct && ct.workerModuleData && (ct = ct.workerModuleData),
        ct
      );
    });
  function lt() {
    for (var ct = [], ut = arguments.length; ut--; ) ct[ut] = arguments[ut];
    if (!at) {
      at = callWorker(it, "registerModule", lt.workerModuleData);
      var ft = function () {
        (at = null), registeredModules[it].delete(ft);
      };
      (registeredModules[it] || (registeredModules[it] = new Set())).add(ft);
    }
    return at.then(function (ht) {
      var mt = ht.isCallable;
      if (mt) return callWorker(it, "callModule", { id: st, args: ct });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (lt.workerModuleData = {
      isWorkerModule: !0,
      id: st,
      name: ot,
      dependencies: et,
      init: stringifyFunction(nt),
      getTransferables: rt && stringifyFunction(rt),
    }),
    lt
  );
}
function terminateWorker(tt) {
  registeredModules[tt] &&
    registeredModules[tt].forEach(function (et) {
      et();
    }),
    workers[tt] && (workers[tt].terminate(), delete workers[tt]);
}
function stringifyFunction(tt) {
  var et = tt.toString();
  return (
    !/^function/.test(et) && /^\w+\s*\(/.test(et) && (et = "function " + et), et
  );
}
function getWorker(tt) {
  var et = workers[tt];
  if (!et) {
    var nt = stringifyFunction(workerBootstrap);
    (et = workers[tt] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                tt.replace(/\*/g, "") +
                ` **/

;(` +
                nt +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (et.onmessage = function (rt) {
        var it = rt.data,
          st = it.messageId,
          ot = openRequests[st];
        if (!ot)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete openRequests[st], ot(it);
      });
  }
  return et;
}
function callWorker(tt, et, nt) {
  return new Promise(function (rt, it) {
    var st = ++_messageId;
    (openRequests[st] = function (ot) {
      ot.success
        ? rt(ot.result)
        : it(new Error("Error in worker " + et + " call: " + ot.error));
    }),
      getWorker(tt).postMessage({ messageId: st, action: et, data: nt });
  });
}
function SDFGenerator() {
  var tt = (function (et) {
    function nt(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt) {
      var mn = 1 - Zt;
      (Jt.x = mn * mn * Rt + 2 * mn * Zt * Dt + Zt * Zt * Yt),
        (Jt.y = mn * mn * Nt + 2 * mn * Zt * zt + Zt * Zt * qt);
    }
    function rt(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln) {
      var bn = 1 - mn;
      (ln.x =
        bn * bn * bn * Rt +
        3 * bn * bn * mn * Dt +
        3 * bn * mn * mn * Yt +
        mn * mn * mn * Zt),
        (ln.y =
          bn * bn * bn * Nt +
          3 * bn * bn * mn * zt +
          3 * bn * mn * mn * qt +
          mn * mn * mn * Jt);
    }
    function it(Rt, Nt) {
      for (
        var Dt = /([MLQCZ])([^MLQCZ]*)/g, zt, Yt, qt, Zt, Jt;
        (zt = Dt.exec(Rt));

      ) {
        var mn = zt[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (ln) {
            return parseFloat(ln);
          });
        switch (zt[1]) {
          case "M":
            (Zt = Yt = mn[0]), (Jt = qt = mn[1]);
            break;
          case "L":
            (mn[0] !== Zt || mn[1] !== Jt) &&
              Nt("L", Zt, Jt, (Zt = mn[0]), (Jt = mn[1]));
            break;
          case "Q": {
            Nt("Q", Zt, Jt, (Zt = mn[2]), (Jt = mn[3]), mn[0], mn[1]);
            break;
          }
          case "C": {
            Nt(
              "C",
              Zt,
              Jt,
              (Zt = mn[4]),
              (Jt = mn[5]),
              mn[0],
              mn[1],
              mn[2],
              mn[3]
            );
            break;
          }
          case "Z":
            (Zt !== Yt || Jt !== qt) && Nt("L", Zt, Jt, Yt, qt);
            break;
        }
      }
    }
    function st(Rt, Nt, Dt) {
      Dt === void 0 && (Dt = 16);
      var zt = { x: 0, y: 0 };
      it(Rt, function (Yt, qt, Zt, Jt, mn, ln, bn, Bn, gn) {
        switch (Yt) {
          case "L":
            Nt(qt, Zt, Jt, mn);
            break;
          case "Q": {
            for (var jt = qt, yn = Zt, pn = 1; pn < Dt; pn++)
              nt(qt, Zt, ln, bn, Jt, mn, pn / (Dt - 1), zt),
                Nt(jt, yn, zt.x, zt.y),
                (jt = zt.x),
                (yn = zt.y);
            break;
          }
          case "C": {
            for (var vn = qt, xn = Zt, Fn = 1; Fn < Dt; Fn++)
              rt(qt, Zt, ln, bn, Bn, gn, Jt, mn, Fn / (Dt - 1), zt),
                Nt(vn, xn, zt.x, zt.y),
                (vn = zt.x),
                (xn = zt.y);
            break;
          }
        }
      });
    }
    var ot =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      at =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      lt = new WeakMap(),
      ct = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function ut(Rt, Nt) {
      var Dt = Rt.getContext ? Rt.getContext("webgl", ct) : Rt,
        zt = lt.get(Dt);
      if (!zt) {
        let vn = function (An) {
            var Wn = qt[An];
            if (!Wn && ((Wn = qt[An] = Dt.getExtension(An)), !Wn))
              throw new Error(An + " not supported");
            return Wn;
          },
          xn = function (An, Wn) {
            var Xt = Dt.createShader(Wn);
            return Dt.shaderSource(Xt, An), Dt.compileShader(Xt), Xt;
          },
          Fn = function (An, Wn, Xt, Ut) {
            if (!Zt[An]) {
              var hn = {},
                Ln = {},
                Cn = Dt.createProgram();
              Dt.attachShader(Cn, xn(Wn, Dt.VERTEX_SHADER)),
                Dt.attachShader(Cn, xn(Xt, Dt.FRAGMENT_SHADER)),
                Dt.linkProgram(Cn),
                (Zt[An] = {
                  program: Cn,
                  transaction: function (kn) {
                    Dt.useProgram(Cn),
                      kn({
                        setUniform: function (Kn, Yn) {
                          for (
                            var ir = [], On = arguments.length - 2;
                            On-- > 0;

                          )
                            ir[On] = arguments[On + 2];
                          var qn =
                            Ln[Yn] || (Ln[Yn] = Dt.getUniformLocation(Cn, Yn));
                          Dt["uniform" + Kn].apply(Dt, [qn].concat(ir));
                        },
                        setAttribute: function (Kn, Yn, ir, On, qn) {
                          var dn = hn[Kn];
                          dn ||
                            (dn = hn[Kn] =
                              {
                                buf: Dt.createBuffer(),
                                loc: Dt.getAttribLocation(Cn, Kn),
                                data: null,
                              }),
                            Dt.bindBuffer(Dt.ARRAY_BUFFER, dn.buf),
                            Dt.vertexAttribPointer(
                              dn.loc,
                              Yn,
                              Dt.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            Dt.enableVertexAttribArray(dn.loc),
                            Yt
                              ? Dt.vertexAttribDivisor(dn.loc, On)
                              : vn(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(dn.loc, On),
                            qn !== dn.data &&
                              (Dt.bufferData(Dt.ARRAY_BUFFER, qn, ir),
                              (dn.data = qn));
                        },
                      });
                  },
                });
            }
            Zt[An].transaction(Ut);
          },
          _n = function (An, Wn) {
            mn++;
            try {
              Dt.activeTexture(Dt.TEXTURE0 + mn);
              var Xt = Jt[An];
              Xt ||
                ((Xt = Jt[An] = Dt.createTexture()),
                Dt.bindTexture(Dt.TEXTURE_2D, Xt),
                Dt.texParameteri(
                  Dt.TEXTURE_2D,
                  Dt.TEXTURE_MIN_FILTER,
                  Dt.NEAREST
                ),
                Dt.texParameteri(
                  Dt.TEXTURE_2D,
                  Dt.TEXTURE_MAG_FILTER,
                  Dt.NEAREST
                )),
                Dt.bindTexture(Dt.TEXTURE_2D, Xt),
                Wn(Xt, mn);
            } finally {
              mn--;
            }
          },
          Dn = function (An, Wn, Xt) {
            var Ut = Dt.createFramebuffer();
            ln.push(Ut),
              Dt.bindFramebuffer(Dt.FRAMEBUFFER, Ut),
              Dt.activeTexture(Dt.TEXTURE0 + Wn),
              Dt.bindTexture(Dt.TEXTURE_2D, An),
              Dt.framebufferTexture2D(
                Dt.FRAMEBUFFER,
                Dt.COLOR_ATTACHMENT0,
                Dt.TEXTURE_2D,
                An,
                0
              );
            try {
              Xt(Ut);
            } finally {
              Dt.deleteFramebuffer(Ut),
                Dt.bindFramebuffer(Dt.FRAMEBUFFER, ln[--ln.length - 1] || null);
            }
          },
          Tn = function () {
            (qt = {}), (Zt = {}), (Jt = {}), (mn = -1), (ln.length = 0);
          };
        var bn = vn,
          Bn = xn,
          gn = Fn,
          jt = _n,
          yn = Dn,
          pn = Tn,
          Yt =
            typeof WebGL2RenderingContext < "u" &&
            Dt instanceof WebGL2RenderingContext,
          qt = {},
          Zt = {},
          Jt = {},
          mn = -1,
          ln = [];
        Dt.canvas.addEventListener(
          "webglcontextlost",
          function (An) {
            Tn(), An.preventDefault();
          },
          !1
        ),
          lt.set(
            Dt,
            (zt = {
              gl: Dt,
              isWebGL2: Yt,
              getExtension: vn,
              withProgram: Fn,
              withTexture: _n,
              withTextureFramebuffer: Dn,
              handleContextLoss: Tn,
            })
          );
      }
      Nt(zt);
    }
    function ft(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt) {
      Zt === void 0 && (Zt = 15),
        Jt === void 0 && (Jt = null),
        ut(Rt, function (mn) {
          var ln = mn.gl,
            bn = mn.withProgram,
            Bn = mn.withTexture;
          Bn("copy", function (gn, jt) {
            ln.texImage2D(
              ln.TEXTURE_2D,
              0,
              ln.RGBA,
              Yt,
              qt,
              0,
              ln.RGBA,
              ln.UNSIGNED_BYTE,
              Nt
            ),
              bn("copy", ot, at, function (yn) {
                var pn = yn.setUniform,
                  vn = yn.setAttribute;
                vn(
                  "aUV",
                  2,
                  ln.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  pn("1i", "image", jt),
                  ln.bindFramebuffer(ln.FRAMEBUFFER, Jt || null),
                  ln.disable(ln.BLEND),
                  ln.colorMask(Zt & 8, Zt & 4, Zt & 2, Zt & 1),
                  ln.viewport(Dt, zt, Yt, qt),
                  ln.scissor(Dt, zt, Yt, qt),
                  ln.drawArrays(ln.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function ht(Rt, Nt, Dt) {
      var zt = Rt.width,
        Yt = Rt.height;
      ut(Rt, function (qt) {
        var Zt = qt.gl,
          Jt = new Uint8Array(zt * Yt * 4);
        Zt.readPixels(0, 0, zt, Yt, Zt.RGBA, Zt.UNSIGNED_BYTE, Jt),
          (Rt.width = Nt),
          (Rt.height = Dt),
          ft(Zt, Jt, 0, 0, zt, Yt);
      });
    }
    var mt = Object.freeze({
      __proto__: null,
      withWebGLContext: ut,
      renderImageData: ft,
      resizeWebGLCanvasWithoutClearing: ht,
    });
    function vt(Rt, Nt, Dt, zt, Yt, qt) {
      qt === void 0 && (qt = 1);
      var Zt = new Uint8Array(Rt * Nt),
        Jt = zt[2] - zt[0],
        mn = zt[3] - zt[1],
        ln = [];
      st(Dt, function (vn, xn, Fn, _n) {
        ln.push({
          x1: vn,
          y1: xn,
          x2: Fn,
          y2: _n,
          minX: Math.min(vn, Fn),
          minY: Math.min(xn, _n),
          maxX: Math.max(vn, Fn),
          maxY: Math.max(xn, _n),
        });
      }),
        ln.sort(function (vn, xn) {
          return vn.maxX - xn.maxX;
        });
      for (var bn = 0; bn < Rt; bn++)
        for (var Bn = 0; Bn < Nt; Bn++) {
          var gn = yn(
              zt[0] + (Jt * (bn + 0.5)) / Rt,
              zt[1] + (mn * (Bn + 0.5)) / Nt
            ),
            jt = Math.pow(1 - Math.abs(gn) / Yt, qt) / 2;
          gn < 0 && (jt = 1 - jt),
            (jt = Math.max(0, Math.min(255, Math.round(jt * 255)))),
            (Zt[Bn * Rt + bn] = jt);
        }
      return Zt;
      function yn(vn, xn) {
        for (var Fn = 1 / 0, _n = 1 / 0, Dn = ln.length; Dn--; ) {
          var Tn = ln[Dn];
          if (Tn.maxX + _n <= vn) break;
          if (vn + _n > Tn.minX && xn - _n < Tn.maxY && xn + _n > Tn.minY) {
            var An = pt(vn, xn, Tn.x1, Tn.y1, Tn.x2, Tn.y2);
            An < Fn && ((Fn = An), (_n = Math.sqrt(Fn)));
          }
        }
        return pn(vn, xn) && (_n = -_n), _n;
      }
      function pn(vn, xn) {
        for (var Fn = 0, _n = ln.length; _n--; ) {
          var Dn = ln[_n];
          if (Dn.maxX <= vn) break;
          var Tn =
            Dn.y1 > xn != Dn.y2 > xn &&
            vn < ((Dn.x2 - Dn.x1) * (xn - Dn.y1)) / (Dn.y2 - Dn.y1) + Dn.x1;
          Tn && (Fn += Dn.y1 < Dn.y2 ? 1 : -1);
        }
        return Fn !== 0;
      }
    }
    function yt(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln) {
      qt === void 0 && (qt = 1),
        Jt === void 0 && (Jt = 0),
        mn === void 0 && (mn = 0),
        ln === void 0 && (ln = 0),
        Et(Rt, Nt, Dt, zt, Yt, qt, Zt, null, Jt, mn, ln);
    }
    function Et(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln, bn) {
      qt === void 0 && (qt = 1),
        mn === void 0 && (mn = 0),
        ln === void 0 && (ln = 0),
        bn === void 0 && (bn = 0);
      for (
        var Bn = vt(Rt, Nt, Dt, zt, Yt, qt),
          gn = new Uint8Array(Bn.length * 4),
          jt = 0;
        jt < Bn.length;
        jt++
      )
        gn[jt * 4 + bn] = Bn[jt];
      ft(Zt, gn, mn, ln, Rt, Nt, 1 << (3 - bn), Jt);
    }
    function pt(Rt, Nt, Dt, zt, Yt, qt) {
      var Zt = Yt - Dt,
        Jt = qt - zt,
        mn = Zt * Zt + Jt * Jt,
        ln = mn
          ? Math.max(0, Math.min(1, ((Rt - Dt) * Zt + (Nt - zt) * Jt) / mn))
          : 0,
        bn = Rt - (Dt + ln * Zt),
        Bn = Nt - (zt + ln * Jt);
      return bn * bn + Bn * Bn;
    }
    var xt = Object.freeze({
        __proto__: null,
        generate: vt,
        generateIntoCanvas: yt,
        generateIntoFramebuffer: Et,
      }),
      St =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      At =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      Ct =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      Mt = new Float32Array([0, 0, 2, 0, 0, 2]),
      wt = null,
      Bt = !1,
      It = {},
      Ft = new WeakMap();
    function Vt(Rt) {
      if (!Bt && !Wt(Rt)) throw new Error("WebGL generation not supported");
    }
    function $t(Rt, Nt, Dt, zt, Yt, qt, Zt) {
      if (
        (qt === void 0 && (qt = 1),
        Zt === void 0 && (Zt = null),
        !Zt && ((Zt = wt), !Zt))
      ) {
        var Jt =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!Jt) throw new Error("OffscreenCanvas or DOM canvas not supported");
        Zt = wt = Jt.getContext("webgl", { depth: !1 });
      }
      Vt(Zt);
      var mn = new Uint8Array(Rt * Nt * 4);
      ut(Zt, function (gn) {
        var jt = gn.gl,
          yn = gn.withTexture,
          pn = gn.withTextureFramebuffer;
        yn("readable", function (vn, xn) {
          jt.texImage2D(
            jt.TEXTURE_2D,
            0,
            jt.RGBA,
            Rt,
            Nt,
            0,
            jt.RGBA,
            jt.UNSIGNED_BYTE,
            null
          ),
            pn(vn, xn, function (Fn) {
              Ht(Rt, Nt, Dt, zt, Yt, qt, jt, Fn, 0, 0, 0),
                jt.readPixels(0, 0, Rt, Nt, jt.RGBA, jt.UNSIGNED_BYTE, mn);
            });
        });
      });
      for (
        var ln = new Uint8Array(Rt * Nt), bn = 0, Bn = 0;
        bn < mn.length;
        bn += 4
      )
        ln[Bn++] = mn[bn];
      return ln;
    }
    function Kt(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln) {
      qt === void 0 && (qt = 1),
        Jt === void 0 && (Jt = 0),
        mn === void 0 && (mn = 0),
        ln === void 0 && (ln = 0),
        Ht(Rt, Nt, Dt, zt, Yt, qt, Zt, null, Jt, mn, ln);
    }
    function Ht(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln, bn) {
      qt === void 0 && (qt = 1),
        mn === void 0 && (mn = 0),
        ln === void 0 && (ln = 0),
        bn === void 0 && (bn = 0),
        Vt(Zt);
      var Bn = [];
      st(Dt, function (gn, jt, yn, pn) {
        Bn.push(gn, jt, yn, pn);
      }),
        (Bn = new Float32Array(Bn)),
        ut(Zt, function (gn) {
          var jt = gn.gl,
            yn = gn.isWebGL2,
            pn = gn.getExtension,
            vn = gn.withProgram,
            xn = gn.withTexture,
            Fn = gn.withTextureFramebuffer,
            _n = gn.handleContextLoss;
          if (
            (xn("rawDistances", function (Dn, Tn) {
              (Rt !== Dn._lastWidth || Nt !== Dn._lastHeight) &&
                jt.texImage2D(
                  jt.TEXTURE_2D,
                  0,
                  jt.RGBA,
                  (Dn._lastWidth = Rt),
                  (Dn._lastHeight = Nt),
                  0,
                  jt.RGBA,
                  jt.UNSIGNED_BYTE,
                  null
                ),
                vn("main", St, At, function (An) {
                  var Wn = An.setAttribute,
                    Xt = An.setUniform,
                    Ut = !yn && pn("ANGLE_instanced_arrays"),
                    hn = !yn && pn("EXT_blend_minmax");
                  Wn("aUV", 2, jt.STATIC_DRAW, 0, Mt),
                    Wn("aLineSegment", 4, jt.DYNAMIC_DRAW, 1, Bn),
                    Xt.apply(void 0, ["4f", "uGlyphBounds"].concat(zt)),
                    Xt("1f", "uMaxDistance", Yt),
                    Xt("1f", "uExponent", qt),
                    Fn(Dn, Tn, function (Ln) {
                      jt.enable(jt.BLEND),
                        jt.colorMask(!0, !0, !0, !0),
                        jt.viewport(0, 0, Rt, Nt),
                        jt.scissor(0, 0, Rt, Nt),
                        jt.blendFunc(jt.ONE, jt.ONE),
                        jt.blendEquationSeparate(
                          jt.FUNC_ADD,
                          yn ? jt.MAX : hn.MAX_EXT
                        ),
                        jt.clear(jt.COLOR_BUFFER_BIT),
                        yn
                          ? jt.drawArraysInstanced(
                              jt.TRIANGLES,
                              0,
                              3,
                              Bn.length / 4
                            )
                          : Ut.drawArraysInstancedANGLE(
                              jt.TRIANGLES,
                              0,
                              3,
                              Bn.length / 4
                            );
                    });
                }),
                vn("post", ot, Ct, function (An) {
                  An.setAttribute("aUV", 2, jt.STATIC_DRAW, 0, Mt),
                    An.setUniform("1i", "tex", Tn),
                    jt.bindFramebuffer(jt.FRAMEBUFFER, Jt),
                    jt.disable(jt.BLEND),
                    jt.colorMask(bn === 0, bn === 1, bn === 2, bn === 3),
                    jt.viewport(mn, ln, Rt, Nt),
                    jt.scissor(mn, ln, Rt, Nt),
                    jt.drawArrays(jt.TRIANGLES, 0, 3);
                });
            }),
            jt.isContextLost())
          )
            throw (_n(), new Error("webgl context lost"));
        });
    }
    function Wt(Rt) {
      var Nt = !Rt || Rt === wt ? It : Rt.canvas || Rt,
        Dt = Ft.get(Nt);
      if (Dt === void 0) {
        Bt = !0;
        var zt = null;
        try {
          var Yt = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            qt = $t(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, Rt);
          (Dt =
            qt &&
            Yt.length === qt.length &&
            qt.every(function (Zt, Jt) {
              return Zt === Yt[Jt];
            })),
            Dt || ((zt = "bad trial run results"), console.info(Yt, qt));
        } catch (Zt) {
          (Dt = !1), (zt = Zt.message);
        }
        zt && console.warn("WebGL SDF generation not supported:", zt),
          (Bt = !1),
          Ft.set(Nt, Dt);
      }
      return Dt;
    }
    var kt = Object.freeze({
      __proto__: null,
      generate: $t,
      generateIntoCanvas: Kt,
      generateIntoFramebuffer: Ht,
      isSupported: Wt,
    });
    function Gt(Rt, Nt, Dt, zt, Yt, qt) {
      Yt === void 0 && (Yt = Math.max(zt[2] - zt[0], zt[3] - zt[1]) / 2),
        qt === void 0 && (qt = 1);
      try {
        return $t.apply(kt, arguments);
      } catch (Zt) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Zt),
          vt.apply(xt, arguments)
        );
      }
    }
    function Pt(Rt, Nt, Dt, zt, Yt, qt, Zt, Jt, mn, ln) {
      Yt === void 0 && (Yt = Math.max(zt[2] - zt[0], zt[3] - zt[1]) / 2),
        qt === void 0 && (qt = 1),
        Jt === void 0 && (Jt = 0),
        mn === void 0 && (mn = 0),
        ln === void 0 && (ln = 0);
      try {
        return Kt.apply(kt, arguments);
      } catch (bn) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", bn),
          yt.apply(xt, arguments)
        );
      }
    }
    return (
      (et.forEachPathCommand = it),
      (et.generate = Gt),
      (et.generateIntoCanvas = Pt),
      (et.javascript = xt),
      (et.pathToLineSegments = st),
      (et.webgl = kt),
      (et.webglUtils = mt),
      Object.defineProperty(et, "__esModule", { value: !0 }),
      et
    );
  })({});
  return tt;
}
function bidiFactory() {
  var tt = (function (et) {
    var nt = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      rt = {},
      it = {};
    (rt.L = 1),
      (it[1] = "L"),
      Object.keys(nt).forEach(function (_n, Dn) {
        (rt[_n] = 1 << (Dn + 1)), (it[rt[_n]] = _n);
      }),
      Object.freeze(rt);
    var st = rt.LRI | rt.RLI | rt.FSI,
      ot = rt.L | rt.R | rt.AL,
      at = rt.B | rt.S | rt.WS | rt.ON | rt.FSI | rt.LRI | rt.RLI | rt.PDI,
      lt = rt.BN | rt.RLE | rt.LRE | rt.RLO | rt.LRO | rt.PDF,
      ct = rt.S | rt.WS | rt.B | st | rt.PDI | lt,
      ut = null;
    function ft() {
      if (!ut) {
        ut = new Map();
        var _n = function (Tn) {
          if (nt.hasOwnProperty(Tn)) {
            var An = 0;
            nt[Tn].split(",").forEach(function (Wn) {
              var Xt = Wn.split("+"),
                Ut = Xt[0],
                hn = Xt[1];
              (Ut = parseInt(Ut, 36)),
                (hn = hn ? parseInt(hn, 36) : 0),
                ut.set((An += Ut), rt[Tn]);
              for (var Ln = 0; Ln < hn; Ln++) ut.set(++An, rt[Tn]);
            });
          }
        };
        for (var Dn in nt) _n(Dn);
      }
    }
    function ht(_n) {
      return ft(), ut.get(_n.codePointAt(0)) || rt.L;
    }
    function mt(_n) {
      return it[ht(_n)];
    }
    var vt = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function yt(_n, Dn) {
      var Tn = 36,
        An = 0,
        Wn = new Map(),
        Xt = Dn && new Map(),
        Ut;
      return (
        _n.split(",").forEach(function hn(Ln) {
          if (Ln.indexOf("+") !== -1) for (var Cn = +Ln; Cn--; ) hn(Ut);
          else {
            Ut = Ln;
            var Mn = Ln.split(">"),
              kn = Mn[0],
              Vn = Mn[1];
            (kn = String.fromCodePoint((An += parseInt(kn, Tn)))),
              (Vn = String.fromCodePoint((An += parseInt(Vn, Tn)))),
              Wn.set(kn, Vn),
              Dn && Xt.set(Vn, kn);
          }
        }),
        { map: Wn, reverseMap: Xt }
      );
    }
    var Et, pt, xt;
    function St() {
      if (!Et) {
        var _n = yt(vt.pairs, !0),
          Dn = _n.map,
          Tn = _n.reverseMap;
        (Et = Dn), (pt = Tn), (xt = yt(vt.canonical, !1).map);
      }
    }
    function At(_n) {
      return St(), Et.get(_n) || null;
    }
    function Ct(_n) {
      return St(), pt.get(_n) || null;
    }
    function Mt(_n) {
      return St(), xt.get(_n) || null;
    }
    var wt = rt.L,
      Bt = rt.R,
      It = rt.EN,
      Ft = rt.ES,
      Vt = rt.ET,
      $t = rt.AN,
      Kt = rt.CS,
      Ht = rt.B,
      Wt = rt.S,
      kt = rt.ON,
      Gt = rt.BN,
      Pt = rt.NSM,
      Rt = rt.AL,
      Nt = rt.LRO,
      Dt = rt.RLO,
      zt = rt.LRE,
      Yt = rt.RLE,
      qt = rt.PDF,
      Zt = rt.LRI,
      Jt = rt.RLI,
      mn = rt.FSI,
      ln = rt.PDI;
    function bn(_n, Dn) {
      for (
        var Tn = 125, An = new Uint32Array(_n.length), Wn = 0;
        Wn < _n.length;
        Wn++
      )
        An[Wn] = ht(_n[Wn]);
      var Xt = new Map();
      function Ut(as, Es) {
        var Jr = An[as];
        (An[as] = Es),
          Xt.set(Jr, Xt.get(Jr) - 1),
          Jr & at && Xt.set(at, Xt.get(at) - 1),
          Xt.set(Es, (Xt.get(Es) || 0) + 1),
          Es & at && Xt.set(at, (Xt.get(at) || 0) + 1);
      }
      for (
        var hn = new Uint8Array(_n.length),
          Ln = new Map(),
          Cn = [],
          Mn = null,
          kn = 0;
        kn < _n.length;
        kn++
      )
        Mn ||
          Cn.push(
            (Mn = {
              start: kn,
              end: _n.length - 1,
              level: Dn === "rtl" ? 1 : Dn === "ltr" ? 0 : zo(kn, !1),
            })
          ),
          An[kn] & Ht && ((Mn.end = kn), (Mn = null));
      for (
        var Vn = Yt | zt | Dt | Nt | st | ln | qt | Ht,
          Kn = function (as) {
            return as + (as & 1 ? 1 : 2);
          },
          Yn = function (as) {
            return as + (as & 1 ? 2 : 1);
          },
          ir = 0;
        ir < Cn.length;
        ir++
      ) {
        Mn = Cn[ir];
        var On = [{ _level: Mn.level, _override: 0, _isolate: 0 }],
          qn = void 0,
          dn = 0,
          Pn = 0,
          Hn = 0;
        Xt.clear();
        for (var Qt = Mn.start; Qt <= Mn.end; Qt++) {
          var zn = An[Qt];
          if (
            ((qn = On[On.length - 1]),
            Xt.set(zn, (Xt.get(zn) || 0) + 1),
            zn & at && Xt.set(at, (Xt.get(at) || 0) + 1),
            zn & Vn)
          )
            if (zn & (Yt | zt)) {
              hn[Qt] = qn._level;
              var Xn = (zn === Yt ? Yn : Kn)(qn._level);
              Xn <= Tn && !dn && !Pn
                ? On.push({ _level: Xn, _override: 0, _isolate: 0 })
                : dn || Pn++;
            } else if (zn & (Dt | Nt)) {
              hn[Qt] = qn._level;
              var Qn = (zn === Dt ? Yn : Kn)(qn._level);
              Qn <= Tn && !dn && !Pn
                ? On.push({
                    _level: Qn,
                    _override: zn & Dt ? Bt : wt,
                    _isolate: 0,
                  })
                : dn || Pn++;
            } else if (zn & st) {
              zn & mn && (zn = zo(Qt + 1, !0) === 1 ? Jt : Zt),
                (hn[Qt] = qn._level),
                qn._override && Ut(Qt, qn._override);
              var tr = (zn === Jt ? Yn : Kn)(qn._level);
              tr <= Tn && dn === 0 && Pn === 0
                ? (Hn++,
                  On.push({
                    _level: tr,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: Qt,
                  }))
                : dn++;
            } else if (zn & ln) {
              if (dn > 0) dn--;
              else if (Hn > 0) {
                for (Pn = 0; !On[On.length - 1]._isolate; ) On.pop();
                var jn = On[On.length - 1]._isolInitIndex;
                jn != null && (Ln.set(jn, Qt), Ln.set(Qt, jn)), On.pop(), Hn--;
              }
              (qn = On[On.length - 1]),
                (hn[Qt] = qn._level),
                qn._override && Ut(Qt, qn._override);
            } else
              zn & qt
                ? (dn === 0 &&
                    (Pn > 0
                      ? Pn--
                      : !qn._isolate &&
                        On.length > 1 &&
                        (On.pop(), (qn = On[On.length - 1]))),
                  (hn[Qt] = qn._level))
                : zn & Ht && (hn[Qt] = Mn.level);
          else
            (hn[Qt] = qn._level),
              qn._override && zn !== Gt && Ut(Qt, qn._override);
        }
        for (var nr = [], or = null, vr = Mn.start; vr <= Mn.end; vr++) {
          var Ar = An[vr];
          if (!(Ar & lt)) {
            var _r = hn[vr],
              yr = Ar & st,
              Qr = Ar === ln;
            or && _r === or._level
              ? ((or._end = vr), (or._endsWithIsolInit = yr))
              : nr.push(
                  (or = {
                    _start: vr,
                    _end: vr,
                    _level: _r,
                    _startsWithPDI: Qr,
                    _endsWithIsolInit: yr,
                  })
                );
          }
        }
        for (var Zr = [], Mr = 0; Mr < nr.length; Mr++) {
          var Fr = nr[Mr];
          if (!Fr._startsWithPDI || (Fr._startsWithPDI && !Ln.has(Fr._start))) {
            for (
              var Dr = [(or = Fr)], Pr = void 0;
              or && or._endsWithIsolInit && (Pr = Ln.get(or._end)) != null;

            )
              for (var Gr = Mr + 1; Gr < nr.length; Gr++)
                if (nr[Gr]._start === Pr) {
                  Dr.push((or = nr[Gr]));
                  break;
                }
            for (var $r = [], fs = 0; fs < Dr.length; fs++)
              for (var ss = Dr[fs], sn = ss._start; sn <= ss._end; sn++)
                $r.push(sn);
            for (
              var wn = hn[$r[0]], Un = Mn.level, Rn = $r[0] - 1;
              Rn >= 0;
              Rn--
            )
              if (!(An[Rn] & lt)) {
                Un = hn[Rn];
                break;
              }
            var Gn = $r[$r.length - 1],
              ar = hn[Gn],
              fr = Mn.level;
            if (!(An[Gn] & st)) {
              for (var Zn = Gn + 1; Zn <= Mn.end; Zn++)
                if (!(An[Zn] & lt)) {
                  fr = hn[Zn];
                  break;
                }
            }
            Zr.push({
              _seqIndices: $r,
              _sosType: Math.max(Un, wn) % 2 ? Bt : wt,
              _eosType: Math.max(fr, ar) % 2 ? Bt : wt,
            });
          }
        }
        for (var lr = 0; lr < Zr.length; lr++) {
          var xr = Zr[lr],
            Jn = xr._seqIndices,
            dr = xr._sosType,
            kr = xr._eosType,
            Rr = hn[Jn[0]] & 1 ? Bt : wt;
          if (Xt.get(Pt))
            for (var ns = 0; ns < Jn.length; ns++) {
              var hs = Jn[ns];
              if (An[hs] & Pt) {
                for (var Lr = dr, mr = ns - 1; mr >= 0; mr--)
                  if (!(An[Jn[mr]] & lt)) {
                    Lr = An[Jn[mr]];
                    break;
                  }
                Ut(hs, Lr & (st | ln) ? kt : Lr);
              }
            }
          if (Xt.get(It))
            for (var wr = 0; wr < Jn.length; wr++) {
              var gr = Jn[wr];
              if (An[gr] & It)
                for (var Kr = wr - 1; Kr >= -1; Kr--) {
                  var jr = Kr === -1 ? dr : An[Jn[Kr]];
                  if (jr & ot) {
                    jr === Rt && Ut(gr, $t);
                    break;
                  }
                }
            }
          if (Xt.get(Rt))
            for (var Vr = 0; Vr < Jn.length; Vr++) {
              var Cs = Jn[Vr];
              An[Cs] & Rt && Ut(Cs, Bt);
            }
          if (Xt.get(Ft) || Xt.get(Kt))
            for (var Or = 1; Or < Jn.length - 1; Or++) {
              var Ur = Jn[Or];
              if (An[Ur] & (Ft | Kt)) {
                for (
                  var ys = 0, _i = 0, Ks = Or - 1;
                  Ks >= 0 && ((ys = An[Jn[Ks]]), !!(ys & lt));
                  Ks--
                );
                for (
                  var Js = Or + 1;
                  Js < Jn.length && ((_i = An[Jn[Js]]), !!(_i & lt));
                  Js++
                );
                ys === _i &&
                  (An[Ur] === Ft ? ys === It : ys & (It | $t)) &&
                  Ut(Ur, ys);
              }
            }
          if (Xt.get(It))
            for (var ds = 0; ds < Jn.length; ds++) {
              var Rs = Jn[ds];
              if (An[Rs] & It) {
                for (var Uo = ds - 1; Uo >= 0 && An[Jn[Uo]] & (Vt | lt); Uo--)
                  Ut(Jn[Uo], It);
                for (ds++; ds < Jn.length && An[Jn[ds]] & (Vt | lt | It); ds++)
                  An[Jn[ds]] !== It && Ut(Jn[ds], It);
              }
            }
          if (Xt.get(Vt) || Xt.get(Ft) || Xt.get(Kt))
            for (var Ao = 0; Ao < Jn.length; Ao++) {
              var Ul = Jn[Ao];
              if (An[Ul] & (Vt | Ft | Kt)) {
                Ut(Ul, kt);
                for (var no = Ao - 1; no >= 0 && An[Jn[no]] & lt; no--)
                  Ut(Jn[no], kt);
                for (var ro = Ao + 1; ro < Jn.length && An[Jn[ro]] & lt; ro++)
                  Ut(Jn[ro], kt);
              }
            }
          if (Xt.get(It))
            for (var io = 0, bo = dr; io < Jn.length; io++) {
              var Gl = Jn[io],
                na = An[Gl];
              na & It ? bo === wt && Ut(Gl, wt) : na & ot && (bo = na);
            }
          if (Xt.get(at)) {
            var so = Bt | It | $t,
              Go = so | wt,
              Ys = [];
            {
              for (var ho = [], qs = 0; qs < Jn.length; qs++)
                if (An[Jn[qs]] & at) {
                  var Tr = _n[Jn[qs]],
                    ga = void 0;
                  if (At(Tr) !== null)
                    if (ho.length < 63) ho.push({ char: Tr, seqIndex: qs });
                    else break;
                  else if ((ga = Ct(Tr)) !== null)
                    for (var oo = ho.length - 1; oo >= 0; oo--) {
                      var $o = ho[oo].char;
                      if ($o === ga || $o === Ct(Mt(Tr)) || At(Mt($o)) === Tr) {
                        Ys.push([ho[oo].seqIndex, qs]), (ho.length = oo);
                        break;
                      }
                    }
                }
              Ys.sort(function (as, Es) {
                return as[0] - Es[0];
              });
            }
            for (var _a = 0; _a < Ys.length; _a++) {
              for (
                var $l = Ys[_a],
                  Hr = $l[0],
                  Co = $l[1],
                  Vl = !1,
                  _s = 0,
                  xa = Hr + 1;
                xa < Co;
                xa++
              ) {
                var Mo = Jn[xa];
                if (An[Mo] & Go) {
                  Vl = !0;
                  var Bs = An[Mo] & so ? Bt : wt;
                  if (Bs === Rr) {
                    _s = Bs;
                    break;
                  }
                }
              }
              if (Vl && !_s) {
                _s = dr;
                for (var ba = Hr - 1; ba >= 0; ba--) {
                  var zl = Jn[ba];
                  if (An[zl] & Go) {
                    var Is = An[zl] & so ? Bt : wt;
                    Is !== Rr ? (_s = Is) : (_s = Rr);
                    break;
                  }
                }
              }
              if (_s) {
                if (((An[Jn[Hr]] = An[Jn[Co]] = _s), _s !== Rr)) {
                  for (var xs = Hr + 1; xs < Jn.length; xs++)
                    if (!(An[Jn[xs]] & lt)) {
                      ht(_n[Jn[xs]]) & Pt && (An[Jn[xs]] = _s);
                      break;
                    }
                }
                if (_s !== Rr) {
                  for (var Qs = Co + 1; Qs < Jn.length; Qs++)
                    if (!(An[Jn[Qs]] & lt)) {
                      ht(_n[Jn[Qs]]) & Pt && (An[Jn[Qs]] = _s);
                      break;
                    }
                }
              }
            }
            for (var Ns = 0; Ns < Jn.length; Ns++)
              if (An[Jn[Ns]] & at) {
                for (var $a = Ns, yl = Ns, Ms = dr, To = Ns - 1; To >= 0; To--)
                  if (An[Jn[To]] & lt) $a = To;
                  else {
                    Ms = An[Jn[To]] & so ? Bt : wt;
                    break;
                  }
                for (var wo = kr, Po = Ns + 1; Po < Jn.length; Po++)
                  if (An[Jn[Po]] & (at | lt)) yl = Po;
                  else {
                    wo = An[Jn[Po]] & so ? Bt : wt;
                    break;
                  }
                for (var Ss = $a; Ss <= yl; Ss++)
                  An[Jn[Ss]] = Ms === wo ? Ms : Rr;
                Ns = yl;
              }
          }
        }
        for (var os = Mn.start; os <= Mn.end; os++) {
          var Vo = hn[os],
            js = An[os];
          if (
            (Vo & 1
              ? js & (wt | It | $t) && hn[os]++
              : js & Bt
              ? hn[os]++
              : js & ($t | It) && (hn[os] += 2),
            js & lt && (hn[os] = os === 0 ? Mn.level : hn[os - 1]),
            os === Mn.end || ht(_n[os]) & (Wt | Ht))
          )
            for (var po = os; po >= 0 && ht(_n[po]) & ct; po--)
              hn[po] = Mn.level;
        }
      }
      return { levels: hn, paragraphs: Cn };
      function zo(as, Es) {
        for (var Jr = as; Jr < _n.length; Jr++) {
          var Yr = An[Jr];
          if (Yr & (Bt | Rt)) return 1;
          if (Yr & (Ht | wt) || (Es && Yr === ln)) return 0;
          if (Yr & st) {
            var Ls = Hl(Jr);
            Jr = Ls === -1 ? _n.length : Ls;
          }
        }
        return 0;
      }
      function Hl(as) {
        for (var Es = 1, Jr = as + 1; Jr < _n.length; Jr++) {
          var Yr = An[Jr];
          if (Yr & Ht) break;
          if (Yr & ln) {
            if (--Es === 0) return Jr;
          } else Yr & st && Es++;
        }
        return -1;
      }
    }
    var Bn =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      gn;
    function jt() {
      if (!gn) {
        var _n = yt(Bn, !0),
          Dn = _n.map,
          Tn = _n.reverseMap;
        Tn.forEach(function (An, Wn) {
          Dn.set(Wn, An);
        }),
          (gn = Dn);
      }
    }
    function yn(_n) {
      return jt(), gn.get(_n) || null;
    }
    function pn(_n, Dn, Tn, An) {
      var Wn = _n.length;
      (Tn = Math.max(0, Tn == null ? 0 : +Tn)),
        (An = Math.min(Wn - 1, An == null ? Wn - 1 : +An));
      for (var Xt = new Map(), Ut = Tn; Ut <= An; Ut++)
        if (Dn[Ut] & 1) {
          var hn = yn(_n[Ut]);
          hn !== null && Xt.set(Ut, hn);
        }
      return Xt;
    }
    function vn(_n, Dn, Tn, An) {
      var Wn = _n.length;
      (Tn = Math.max(0, Tn == null ? 0 : +Tn)),
        (An = Math.min(Wn - 1, An == null ? Wn - 1 : +An));
      var Xt = [];
      return (
        Dn.paragraphs.forEach(function (Ut) {
          var hn = Math.max(Tn, Ut.start),
            Ln = Math.min(An, Ut.end);
          if (hn < Ln) {
            for (
              var Cn = Dn.levels.slice(hn, Ln + 1), Mn = Ln;
              Mn >= hn && ht(_n[Mn]) & ct;
              Mn--
            )
              Cn[Mn] = Ut.level;
            for (var kn = Ut.level, Vn = 1 / 0, Kn = 0; Kn < Cn.length; Kn++) {
              var Yn = Cn[Kn];
              Yn > kn && (kn = Yn), Yn < Vn && (Vn = Yn | 1);
            }
            for (var ir = kn; ir >= Vn; ir--)
              for (var On = 0; On < Cn.length; On++)
                if (Cn[On] >= ir) {
                  for (var qn = On; On + 1 < Cn.length && Cn[On + 1] >= ir; )
                    On++;
                  On > qn && Xt.push([qn + hn, On + hn]);
                }
          }
        }),
        Xt
      );
    }
    function xn(_n, Dn, Tn, An) {
      var Wn = Fn(_n, Dn, Tn, An),
        Xt = [].concat(_n);
      return (
        Wn.forEach(function (Ut, hn) {
          Xt[hn] = (Dn.levels[Ut] & 1 ? yn(_n[Ut]) : null) || _n[Ut];
        }),
        Xt.join("")
      );
    }
    function Fn(_n, Dn, Tn, An) {
      for (var Wn = vn(_n, Dn, Tn, An), Xt = [], Ut = 0; Ut < _n.length; Ut++)
        Xt[Ut] = Ut;
      return (
        Wn.forEach(function (hn) {
          for (
            var Ln = hn[0],
              Cn = hn[1],
              Mn = Xt.slice(Ln, Cn + 1),
              kn = Mn.length;
            kn--;

          )
            Xt[Cn - kn] = Mn[kn];
        }),
        Xt
      );
    }
    return (
      (et.closingToOpeningBracket = Ct),
      (et.getBidiCharType = ht),
      (et.getBidiCharTypeName = mt),
      (et.getCanonicalBracket = Mt),
      (et.getEmbeddingLevels = bn),
      (et.getMirroredCharacter = yn),
      (et.getMirroredCharactersMap = pn),
      (et.getReorderSegments = vn),
      (et.getReorderedIndices = Fn),
      (et.getReorderedString = xn),
      (et.openingToClosingBracket = At),
      Object.defineProperty(et, "__esModule", { value: !0 }),
      et
    );
  })({});
  return tt;
}
const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(tt) {
  const et = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function nt(rt, it) {
    let st = ShaderChunk[it];
    return st ? expandShaderIncludes(st) : rt;
  }
  return tt.replace(et, nt);
}
const _lut = [];
for (let tt = 0; tt < 256; tt++)
  _lut[tt] = (tt < 16 ? "0" : "") + tt.toString(16);
function generateUUID() {
  const tt = (Math.random() * 4294967295) | 0,
    et = (Math.random() * 4294967295) | 0,
    nt = (Math.random() * 4294967295) | 0,
    rt = (Math.random() * 4294967295) | 0;
  return (
    _lut[tt & 255] +
    _lut[(tt >> 8) & 255] +
    _lut[(tt >> 16) & 255] +
    _lut[(tt >> 24) & 255] +
    "-" +
    _lut[et & 255] +
    _lut[(et >> 8) & 255] +
    "-" +
    _lut[((et >> 16) & 15) | 64] +
    _lut[(et >> 24) & 255] +
    "-" +
    _lut[(nt & 63) | 128] +
    _lut[(nt >> 8) & 255] +
    "-" +
    _lut[(nt >> 16) & 255] +
    _lut[(nt >> 24) & 255] +
    _lut[rt & 255] +
    _lut[(rt >> 8) & 255] +
    _lut[(rt >> 16) & 255] +
    _lut[(rt >> 24) & 255]
  ).toUpperCase();
}
const assign$2 =
    Object.assign ||
    function () {
      let tt = arguments[0];
      for (let et = 1, nt = arguments.length; et < nt; et++) {
        let rt = arguments[et];
        if (rt)
          for (let it in rt)
            Object.prototype.hasOwnProperty.call(rt, it) && (tt[it] = rt[it]);
      }
      return tt;
    },
  epoch = Date.now(),
  CONSTRUCTOR_CACHE = new WeakMap(),
  SHADER_UPGRADE_CACHE = new Map();
let materialInstanceId = 1e10;
function createDerivedMaterial(tt, et) {
  const nt = getKeyForOptions(et);
  let rt = CONSTRUCTOR_CACHE.get(tt);
  if ((rt || CONSTRUCTOR_CACHE.set(tt, (rt = Object.create(null))), rt[nt]))
    return new rt[nt]();
  const it = `_onBeforeCompile${nt}`,
    st = function (ct, ut) {
      tt.onBeforeCompile.call(this, ct, ut);
      const ft =
        this.customProgramCacheKey() +
        "|" +
        ct.vertexShader +
        "|" +
        ct.fragmentShader;
      let ht = SHADER_UPGRADE_CACHE[ft];
      if (!ht) {
        const mt = upgradeShaders(this, ct, et, nt);
        ht = SHADER_UPGRADE_CACHE[ft] = mt;
      }
      (ct.vertexShader = ht.vertexShader),
        (ct.fragmentShader = ht.fragmentShader),
        assign$2(ct.uniforms, this.uniforms),
        et.timeUniform &&
          (ct.uniforms[et.timeUniform] = {
            get value() {
              return Date.now() - epoch;
            },
          }),
        this[it] && this[it](ct);
    },
    ot = function () {
      return at(et.chained ? tt : tt.clone());
    },
    at = function (ct) {
      const ut = Object.create(ct, lt);
      return (
        Object.defineProperty(ut, "baseMaterial", { value: tt }),
        Object.defineProperty(ut, "id", { value: materialInstanceId++ }),
        (ut.uuid = generateUUID()),
        (ut.uniforms = assign$2({}, ct.uniforms, et.uniforms)),
        (ut.defines = assign$2({}, ct.defines, et.defines)),
        (ut.defines[`TROIKA_DERIVED_MATERIAL_${nt}`] = ""),
        (ut.extensions = assign$2({}, ct.extensions, et.extensions)),
        (ut._listeners = void 0),
        ut
      );
    },
    lt = {
      constructor: { value: ot },
      isDerivedMaterial: { value: !0 },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return tt.customProgramCacheKey() + "|" + nt;
        },
      },
      onBeforeCompile: {
        get() {
          return st;
        },
        set(ct) {
          this[it] = ct;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (ct) {
          return (
            tt.copy.call(this, ct),
            !tt.isShaderMaterial &&
              !tt.isDerivedMaterial &&
              (assign$2(this.extensions, ct.extensions),
              assign$2(this.defines, ct.defines),
              assign$2(this.uniforms, UniformsUtils.clone(ct.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const ct = new tt.constructor();
          return at(ct).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let ct = this._depthMaterial;
          return (
            ct ||
              ((ct = this._depthMaterial =
                createDerivedMaterial(
                  tt.isDerivedMaterial
                    ? tt.getDepthMaterial()
                    : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
                  et
                )),
              (ct.defines.IS_DEPTH_MATERIAL = ""),
              (ct.uniforms = this.uniforms)),
            ct
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let ct = this._distanceMaterial;
          return (
            ct ||
              ((ct = this._distanceMaterial =
                createDerivedMaterial(
                  tt.isDerivedMaterial
                    ? tt.getDistanceMaterial()
                    : new MeshDistanceMaterial(),
                  et
                )),
              (ct.defines.IS_DISTANCE_MATERIAL = ""),
              (ct.uniforms = this.uniforms)),
            ct
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: ct, _distanceMaterial: ut } = this;
          ct && ct.dispose(), ut && ut.dispose(), tt.dispose.call(this);
        },
      },
    };
  return (rt[nt] = ot), new ot();
}
function upgradeShaders(tt, { vertexShader: et, fragmentShader: nt }, rt, it) {
  let {
    vertexDefs: st,
    vertexMainIntro: ot,
    vertexMainOutro: at,
    vertexTransform: lt,
    fragmentDefs: ct,
    fragmentMainIntro: ut,
    fragmentMainOutro: ft,
    fragmentColorTransform: ht,
    customRewriter: mt,
    timeUniform: vt,
  } = rt;
  if (
    ((st = st || ""),
    (ot = ot || ""),
    (at = at || ""),
    (ct = ct || ""),
    (ut = ut || ""),
    (ft = ft || ""),
    (lt || mt) && (et = expandShaderIncludes(et)),
    (ht || mt) &&
      ((nt = nt.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (nt = expandShaderIncludes(nt))),
    mt)
  ) {
    let yt = mt({ vertexShader: et, fragmentShader: nt });
    (et = yt.vertexShader), (nt = yt.fragmentShader);
  }
  if (ht) {
    let yt = [];
    (nt = nt.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (Et) => (yt.push(Et), "")
    )),
      (ft = `${ht}
${yt.join(`
`)}
${ft}`);
  }
  if (vt) {
    const yt = `
uniform float ${vt};
`;
    (st = yt + st), (ct = yt + ct);
  }
  return (
    lt &&
      ((et = `vec3 troika_position_${it};
vec3 troika_normal_${it};
vec2 troika_uv_${it};
${et}
`),
      (st = `${st}
void troikaVertexTransform${it}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${lt}
}
`),
      (ot = `
troika_position_${it} = vec3(position);
troika_normal_${it} = vec3(normal);
troika_uv_${it} = vec2(uv);
troikaVertexTransform${it}(troika_position_${it}, troika_normal_${it}, troika_uv_${it});
${ot}
`),
      (et = et.replace(/\b(position|normal|uv)\b/g, (yt, Et, pt, xt) =>
        /\battribute\s+vec[23]\s+$/.test(xt.substr(0, pt))
          ? Et
          : `troika_${Et}_${it}`
      )),
      (tt.map && tt.map.channel > 0) ||
        (et = et.replace(/\bMAP_UV\b/g, `troika_uv_${it}`))),
    (et = injectIntoShaderCode(et, it, st, ot, at)),
    (nt = injectIntoShaderCode(nt, it, ct, ut, ft)),
    { vertexShader: et, fragmentShader: nt }
  );
}
function injectIntoShaderCode(tt, et, nt, rt, it) {
  return (
    (rt || it || nt) &&
      ((tt = tt.replace(
        voidMainRegExp,
        `
${nt}
void troikaOrigMain${et}() {`
      )),
      (tt += `
void main() {
  ${rt}
  troikaOrigMain${et}();
  ${it}
}`)),
    tt
  );
}
function optionsJsonReplacer(tt, et) {
  return tt === "uniforms"
    ? void 0
    : typeof et == "function"
    ? et.toString()
    : et;
}
let _idCtr = 0;
const optionsHashesToIds = new Map();
function getKeyForOptions(tt) {
  const et = JSON.stringify(tt, optionsJsonReplacer);
  let nt = optionsHashesToIds.get(et);
  return nt == null && optionsHashesToIds.set(et, (nt = ++_idCtr)), nt;
}
function createTypesetter(tt, et, nt) {
  const { defaultFontURL: rt } = nt,
    it = Object.create(null),
    st = 1 / 0,
    ot =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    at = "[^\\S\\u00A0]",
    lt = new RegExp(
      `${at}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function ct(xt, St) {
    function At() {
      const Ct = (Mt) => {
        console.error(
          `Failure loading font ${xt}${xt === rt ? "" : "; trying fallback"}`,
          Mt
        ),
          xt !== rt && ((xt = rt), At());
      };
      try {
        const Mt = new XMLHttpRequest();
        Mt.open("get", xt, !0),
          (Mt.responseType = "arraybuffer"),
          (Mt.onload = function () {
            if (Mt.status >= 400) Ct(new Error(Mt.statusText));
            else if (Mt.status > 0)
              try {
                const wt = tt(Mt.response);
                St(wt);
              } catch (wt) {
                Ct(wt);
              }
          }),
          (Mt.onerror = Ct),
          Mt.send();
      } catch (Mt) {
        Ct(Mt);
      }
    }
    At();
  }
  function ut(xt, St) {
    xt || (xt = rt);
    let At = it[xt];
    At
      ? At.pending
        ? At.pending.push(St)
        : St(At)
      : ((it[xt] = { pending: [St] }),
        ct(xt, (Ct) => {
          let Mt = it[xt].pending;
          (it[xt] = Ct), Mt.forEach((wt) => wt(Ct));
        }));
  }
  function ft(
    {
      text: xt = "",
      font: St = rt,
      sdfGlyphSize: At = 64,
      fontSize: Ct = 1,
      letterSpacing: Mt = 0,
      lineHeight: wt = "normal",
      maxWidth: Bt = st,
      direction: It,
      textAlign: Ft = "left",
      textIndent: Vt = 0,
      whiteSpace: $t = "normal",
      overflowWrap: Kt = "normal",
      anchorX: Ht = 0,
      anchorY: Wt = 0,
      includeCaretPositions: kt = !1,
      chunkedBoundsSize: Gt = 8192,
      colorRanges: Pt = null,
    },
    Rt,
    Nt = !1
  ) {
    const Dt = yt(),
      zt = { fontLoad: 0, typesetting: 0 };
    xt.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (xt = xt
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (Ct = +Ct),
      (Mt = +Mt),
      (Bt = +Bt),
      (wt = wt || "normal"),
      (Vt = +Vt),
      ut(St, (Yt) => {
        const qt = isFinite(Bt);
        let Zt = null,
          Jt = null,
          mn = null,
          ln = null,
          bn = null,
          Bn = null,
          gn = null,
          jt = 0,
          yn = 0,
          pn = $t !== "nowrap";
        const {
          ascender: vn,
          descender: xn,
          unitsPerEm: Fn,
          lineGap: _n,
          capHeight: Dn,
          xHeight: Tn,
        } = Yt;
        zt.fontLoad = yt() - Dt;
        const An = yt(),
          Wn = Ct / Fn;
        wt === "normal" && (wt = (vn - xn + _n) / Fn), (wt = wt * Ct);
        const Xt = (wt - (vn - xn) * Wn) / 2,
          Ut = -(vn * Wn + Xt),
          hn = Math.min(wt, (vn - xn) * Wn),
          Ln = ((vn + xn) / 2) * Wn - hn / 2;
        let Cn = Vt,
          Mn = new Et();
        const kn = [Mn];
        Yt.forEachGlyph(xt, Ct, Mt, (Yn, ir, On) => {
          const qn = xt.charAt(On),
            dn = Yn.advanceWidth * Wn,
            Pn = Mn.count;
          let Hn;
          if (
            ("isEmpty" in Yn ||
              ((Yn.isWhitespace = !!qn && new RegExp(at).test(qn)),
              (Yn.canBreakAfter = !!qn && lt.test(qn)),
              (Yn.isEmpty =
                Yn.xMin === Yn.xMax || Yn.yMin === Yn.yMax || ot.test(qn))),
            !Yn.isWhitespace && !Yn.isEmpty && yn++,
            pn && qt && !Yn.isWhitespace && ir + dn + Cn > Bt && Pn)
          ) {
            if (Mn.glyphAt(Pn - 1).glyphObj.canBreakAfter)
              (Hn = new Et()), (Cn = -ir);
            else
              for (let zn = Pn; zn--; )
                if (zn === 0 && Kt === "break-word") {
                  (Hn = new Et()), (Cn = -ir);
                  break;
                } else if (Mn.glyphAt(zn).glyphObj.canBreakAfter) {
                  Hn = Mn.splitAt(zn + 1);
                  const Xn = Hn.glyphAt(0).x;
                  Cn -= Xn;
                  for (let Qn = Hn.count; Qn--; ) Hn.glyphAt(Qn).x -= Xn;
                  break;
                }
            Hn && ((Mn.isSoftWrapped = !0), (Mn = Hn), kn.push(Mn), (jt = Bt));
          }
          let Qt = Mn.glyphAt(Mn.count);
          (Qt.glyphObj = Yn),
            (Qt.x = ir + Cn),
            (Qt.width = dn),
            (Qt.charIndex = On),
            qn ===
              `
` && ((Mn = new Et()), kn.push(Mn), (Cn = -(ir + dn + Mt * Ct) + Vt));
        }),
          kn.forEach((Yn) => {
            for (let ir = Yn.count; ir--; ) {
              let { glyphObj: On, x: qn, width: dn } = Yn.glyphAt(ir);
              if (!On.isWhitespace) {
                (Yn.width = qn + dn), Yn.width > jt && (jt = Yn.width);
                return;
              }
            }
          });
        let Vn = 0,
          Kn = 0;
        if (
          (Ht &&
            (typeof Ht == "number"
              ? (Vn = -Ht)
              : typeof Ht == "string" &&
                (Vn =
                  -jt *
                  (Ht === "left"
                    ? 0
                    : Ht === "center"
                    ? 0.5
                    : Ht === "right"
                    ? 1
                    : mt(Ht)))),
          Wt)
        ) {
          if (typeof Wt == "number") Kn = -Wt;
          else if (typeof Wt == "string") {
            let Yn = kn.length * wt;
            Kn =
              Wt === "top"
                ? 0
                : Wt === "top-baseline"
                ? -Ut
                : Wt === "top-cap"
                ? -Ut - Dn * Wn
                : Wt === "top-ex"
                ? -Ut - Tn * Wn
                : Wt === "middle"
                ? Yn / 2
                : Wt === "bottom"
                ? Yn
                : Wt === "bottom-baseline"
                ? Yn - Xt + xn * Wn
                : mt(Wt) * Yn;
          }
        }
        if (!Nt) {
          const Yn = et.getEmbeddingLevels(xt, It);
          (Zt = new Uint16Array(yn)),
            (Jt = new Float32Array(yn * 2)),
            (mn = {}),
            (Bn = [st, st, -st, -st]),
            (gn = []);
          let ir = Ut;
          kt && (bn = new Float32Array(xt.length * 3)),
            Pt && (ln = new Uint8Array(yn * 3));
          let On = 0,
            qn = -1,
            dn = -1,
            Pn,
            Hn;
          if (
            (kn.forEach((Qt, zn) => {
              let { count: Xn, width: Qn } = Qt;
              if (Xn > 0) {
                let tr = 0;
                for (
                  let _r = Xn;
                  _r-- && Qt.glyphAt(_r).glyphObj.isWhitespace;

                )
                  tr++;
                let jn = 0,
                  nr = 0;
                if (Ft === "center") jn = (jt - Qn) / 2;
                else if (Ft === "right") jn = jt - Qn;
                else if (Ft === "justify" && Qt.isSoftWrapped) {
                  let _r = 0;
                  for (let yr = Xn - tr; yr--; )
                    Qt.glyphAt(yr).glyphObj.isWhitespace && _r++;
                  nr = (jt - Qn) / _r;
                }
                if (nr || jn) {
                  let _r = 0;
                  for (let yr = 0; yr < Xn; yr++) {
                    let Qr = Qt.glyphAt(yr);
                    const Zr = Qr.glyphObj;
                    (Qr.x += jn + _r),
                      nr !== 0 &&
                        Zr.isWhitespace &&
                        yr < Xn - tr &&
                        ((_r += nr), (Qr.width += nr));
                  }
                }
                const or = et.getReorderSegments(
                  xt,
                  Yn,
                  Qt.glyphAt(0).charIndex,
                  Qt.glyphAt(Qt.count - 1).charIndex
                );
                for (let _r = 0; _r < or.length; _r++) {
                  const [yr, Qr] = or[_r];
                  let Zr = 1 / 0,
                    Mr = -1 / 0;
                  for (let Fr = 0; Fr < Xn; Fr++)
                    if (Qt.glyphAt(Fr).charIndex >= yr) {
                      let Dr = Fr,
                        Pr = Fr;
                      for (; Pr < Xn; Pr++) {
                        let Gr = Qt.glyphAt(Pr);
                        if (Gr.charIndex > Qr) break;
                        Pr < Xn - tr &&
                          ((Zr = Math.min(Zr, Gr.x)),
                          (Mr = Math.max(Mr, Gr.x + Gr.width)));
                      }
                      for (let Gr = Dr; Gr < Pr; Gr++) {
                        const $r = Qt.glyphAt(Gr);
                        $r.x = Mr - ($r.x + $r.width - Zr);
                      }
                      break;
                    }
                }
                let vr;
                const Ar = (_r) => (vr = _r);
                for (let _r = 0; _r < Xn; _r++) {
                  let yr = Qt.glyphAt(_r);
                  vr = yr.glyphObj;
                  const Qr = vr.index,
                    Zr = Yn.levels[yr.charIndex] & 1;
                  if (Zr) {
                    const Mr = et.getMirroredCharacter(xt[yr.charIndex]);
                    Mr && Yt.forEachGlyph(Mr, 0, 0, Ar);
                  }
                  if (kt) {
                    const { charIndex: Mr } = yr,
                      Fr = yr.x + Vn,
                      Dr = yr.x + yr.width + Vn;
                    (bn[Mr * 3] = Zr ? Dr : Fr),
                      (bn[Mr * 3 + 1] = Zr ? Fr : Dr),
                      (bn[Mr * 3 + 2] = ir + Ln + Kn);
                    const Pr = Mr - qn;
                    Pr > 1 && vt(bn, qn, Pr), (qn = Mr);
                  }
                  if (Pt) {
                    const { charIndex: Mr } = yr;
                    for (; Mr > dn; )
                      dn++, Pt.hasOwnProperty(dn) && (Hn = Pt[dn]);
                  }
                  if (!vr.isWhitespace && !vr.isEmpty) {
                    const Mr = On++;
                    mn[Qr] ||
                      (mn[Qr] = {
                        path: vr.path,
                        pathBounds: [vr.xMin, vr.yMin, vr.xMax, vr.yMax],
                      });
                    const Fr = yr.x + Vn,
                      Dr = ir + Kn;
                    (Jt[Mr * 2] = Fr), (Jt[Mr * 2 + 1] = Dr);
                    const Pr = Fr + vr.xMin * Wn,
                      Gr = Dr + vr.yMin * Wn,
                      $r = Fr + vr.xMax * Wn,
                      fs = Dr + vr.yMax * Wn;
                    Pr < Bn[0] && (Bn[0] = Pr),
                      Gr < Bn[1] && (Bn[1] = Gr),
                      $r > Bn[2] && (Bn[2] = $r),
                      fs > Bn[3] && (Bn[3] = fs),
                      Mr % Gt === 0 &&
                        ((Pn = {
                          start: Mr,
                          end: Mr,
                          rect: [st, st, -st, -st],
                        }),
                        gn.push(Pn)),
                      Pn.end++;
                    const ss = Pn.rect;
                    if (
                      (Pr < ss[0] && (ss[0] = Pr),
                      Gr < ss[1] && (ss[1] = Gr),
                      $r > ss[2] && (ss[2] = $r),
                      fs > ss[3] && (ss[3] = fs),
                      (Zt[Mr] = Qr),
                      Pt)
                    ) {
                      const sn = Mr * 3;
                      (ln[sn] = (Hn >> 16) & 255),
                        (ln[sn + 1] = (Hn >> 8) & 255),
                        (ln[sn + 2] = Hn & 255);
                    }
                  }
                }
              }
              ir -= wt;
            }),
            bn)
          ) {
            const Qt = xt.length - qn;
            Qt > 1 && vt(bn, qn, Qt);
          }
        }
        (zt.typesetting = yt() - An),
          Rt({
            glyphIds: Zt,
            glyphPositions: Jt,
            glyphData: mn,
            caretPositions: bn,
            caretHeight: hn,
            glyphColors: ln,
            chunkedBounds: gn,
            fontSize: Ct,
            unitsPerEm: Fn,
            ascender: vn * Wn,
            descender: xn * Wn,
            capHeight: Dn * Wn,
            xHeight: Tn * Wn,
            lineHeight: wt,
            topBaseline: Ut,
            blockBounds: [Vn, Kn - kn.length * wt, Vn + jt, Kn],
            visibleBounds: Bn,
            timings: zt,
          });
      });
  }
  function ht(xt, St) {
    ft(
      xt,
      (At) => {
        const [Ct, Mt, wt, Bt] = At.blockBounds;
        St({ width: wt - Ct, height: Bt - Mt });
      },
      { metricsOnly: !0 }
    );
  }
  function mt(xt) {
    let St = xt.match(/^([\d.]+)%$/),
      At = St ? parseFloat(St[1]) : NaN;
    return isNaN(At) ? 0 : At / 100;
  }
  function vt(xt, St, At) {
    const Ct = xt[St * 3],
      Mt = xt[St * 3 + 1],
      wt = xt[St * 3 + 2],
      Bt = (Mt - Ct) / At;
    for (let It = 0; It < At; It++) {
      const Ft = (St + It) * 3;
      (xt[Ft] = Ct + Bt * It),
        (xt[Ft + 1] = Ct + Bt * (It + 1)),
        (xt[Ft + 2] = wt);
    }
  }
  function yt() {
    return (self.performance || Date).now();
  }
  function Et() {
    this.data = [];
  }
  const pt = ["glyphObj", "x", "width", "charIndex"];
  return (
    (Et.prototype = {
      width: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / pt.length);
      },
      glyphAt(xt) {
        let St = Et.flyweight;
        return (St.data = this.data), (St.index = xt), St;
      },
      splitAt(xt) {
        let St = new Et();
        return (St.data = this.data.splice(xt * pt.length)), St;
      },
    }),
    (Et.flyweight = pt.reduce(
      (xt, St, At, Ct) => (
        Object.defineProperty(xt, St, {
          get() {
            return this.data[this.index * pt.length + At];
          },
          set(Mt) {
            this.data[this.index * pt.length + At] = Mt;
          },
        }),
        xt
      ),
      { data: null, index: 0 }
    )),
    { typeset: ft, measure: ht, loadFont: ut }
  );
}
const now = () => (self.performance || Date).now(),
  mainThreadGenerator = SDFGenerator();
let warned;
function generateSDF(tt, et, nt, rt, it, st, ot, at, lt, ct, ut = !0) {
  return ut
    ? generateSDF_GL(tt, et, nt, rt, it, st, ot, at, lt, ct).then(
        null,
        (ft) => (
          warned ||
            (console.warn(
              "WebGL SDF generation failed, falling back to JS",
              ft
            ),
            (warned = !0)),
          generateSDF_JS_Worker(tt, et, nt, rt, it, st, ot, at, lt, ct)
        )
      )
    : generateSDF_JS_Worker(tt, et, nt, rt, it, st, ot, at, lt, ct);
}
const queue = [],
  chunkTimeBudget = 5;
let timer = 0;
function nextChunk() {
  const tt = now();
  for (; queue.length && now() - tt < chunkTimeBudget; ) queue.shift()();
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
const generateSDF_GL = (...tt) =>
    new Promise((et, nt) => {
      queue.push(() => {
        const rt = now();
        try {
          mainThreadGenerator.webgl.generateIntoCanvas(...tt),
            et({ timing: now() - rt });
        } catch (it) {
          nt(it);
        }
      }),
        timer || (timer = setTimeout(nextChunk, 0));
    }),
  threadCount = 4,
  idleTimeout = 2e3,
  threads = {};
let callNum = 0;
function generateSDF_JS_Worker(tt, et, nt, rt, it, st, ot, at, lt, ct) {
  const ut = "TroikaTextSDFGenerator_JS_" + (callNum++ % threadCount);
  let ft = threads[ut];
  return (
    ft ||
      (ft = threads[ut] =
        {
          workerModule: defineWorkerModule({
            name: ut,
            workerId: ut,
            dependencies: [SDFGenerator, now],
            init(ht, mt) {
              const vt = ht().javascript.generate;
              return function (...yt) {
                const Et = mt();
                return { textureData: vt(...yt), timing: mt() - Et };
              };
            },
            getTransferables(ht) {
              return [ht.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    ft.requests++,
    clearTimeout(ft.idleTimer),
    ft
      .workerModule(tt, et, nt, rt, it, st)
      .then(({ textureData: ht, timing: mt }) => {
        const vt = now(),
          yt = new Uint8Array(ht.length * 4);
        for (let Et = 0; Et < ht.length; Et++) yt[Et * 4 + ct] = ht[Et];
        return (
          mainThreadGenerator.webglUtils.renderImageData(
            ot,
            yt,
            at,
            lt,
            tt,
            et,
            1 << (3 - ct)
          ),
          (mt += now() - vt),
          --ft.requests === 0 &&
            (ft.idleTimer = setTimeout(() => {
              terminateWorker(ut);
            }, idleTimeout)),
          { timing: mt }
        );
      })
  );
}
function warmUpSDFCanvas(tt) {
  tt._warm || (mainThreadGenerator.webgl.isSupported(tt), (tt._warm = !0));
}
const resizeWebGLCanvasWithoutClearing =
  mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function typrFactory() {
  return (
    typeof window > "u" && (self.window = self),
    (function (tt) {
      var et = {
        parse: function (it) {
          var st = et._bin,
            ot = new Uint8Array(it);
          if (st.readASCII(ot, 0, 4) == "ttcf") {
            var at = 4;
            st.readUshort(ot, at), (at += 2), st.readUshort(ot, at), (at += 2);
            var lt = st.readUint(ot, at);
            at += 4;
            for (var ct = [], ut = 0; ut < lt; ut++) {
              var ft = st.readUint(ot, at);
              (at += 4), ct.push(et._readFont(ot, ft));
            }
            return ct;
          }
          return [et._readFont(ot, 0)];
        },
        _readFont: function (it, st) {
          var ot = et._bin,
            at = st;
          ot.readFixed(it, st), (st += 4);
          var lt = ot.readUshort(it, st);
          (st += 2),
            ot.readUshort(it, st),
            (st += 2),
            ot.readUshort(it, st),
            (st += 2),
            ot.readUshort(it, st),
            (st += 2);
          for (
            var ct = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              ut = { _data: it, _offset: at },
              ft = {},
              ht = 0;
            ht < lt;
            ht++
          ) {
            var mt = ot.readASCII(it, st, 4);
            (st += 4), ot.readUint(it, st), (st += 4);
            var vt = ot.readUint(it, st);
            st += 4;
            var yt = ot.readUint(it, st);
            (st += 4), (ft[mt] = { offset: vt, length: yt });
          }
          for (ht = 0; ht < ct.length; ht++) {
            var Et = ct[ht];
            ft[Et] &&
              (ut[Et.trim()] = et[Et.trim()].parse(
                it,
                ft[Et].offset,
                ft[Et].length,
                ut
              ));
          }
          return ut;
        },
        _tabOffset: function (it, st, ot) {
          for (
            var at = et._bin,
              lt = at.readUshort(it, ot + 4),
              ct = ot + 12,
              ut = 0;
            ut < lt;
            ut++
          ) {
            var ft = at.readASCII(it, ct, 4);
            (ct += 4), at.readUint(it, ct), (ct += 4);
            var ht = at.readUint(it, ct);
            if (((ct += 4), at.readUint(it, ct), (ct += 4), ft == st))
              return ht;
          }
          return 0;
        },
      };
      (et._bin = {
        readFixed: function (it, st) {
          return (
            ((it[st] << 8) | it[st + 1]) +
            ((it[st + 2] << 8) | it[st + 3]) / 65540
          );
        },
        readF2dot14: function (it, st) {
          return et._bin.readShort(it, st) / 16384;
        },
        readInt: function (it, st) {
          return et._bin._view(it).getInt32(st);
        },
        readInt8: function (it, st) {
          return et._bin._view(it).getInt8(st);
        },
        readShort: function (it, st) {
          return et._bin._view(it).getInt16(st);
        },
        readUshort: function (it, st) {
          return et._bin._view(it).getUint16(st);
        },
        readUshorts: function (it, st, ot) {
          for (var at = [], lt = 0; lt < ot; lt++)
            at.push(et._bin.readUshort(it, st + 2 * lt));
          return at;
        },
        readUint: function (it, st) {
          return et._bin._view(it).getUint32(st);
        },
        readUint64: function (it, st) {
          return (
            4294967296 * et._bin.readUint(it, st) + et._bin.readUint(it, st + 4)
          );
        },
        readASCII: function (it, st, ot) {
          for (var at = "", lt = 0; lt < ot; lt++)
            at += String.fromCharCode(it[st + lt]);
          return at;
        },
        readUnicode: function (it, st, ot) {
          for (var at = "", lt = 0; lt < ot; lt++) {
            var ct = (it[st++] << 8) | it[st++];
            at += String.fromCharCode(ct);
          }
          return at;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (it, st, ot) {
          var at = et._bin._tdec;
          return at && st == 0 && ot == it.length
            ? at.decode(it)
            : et._bin.readASCII(it, st, ot);
        },
        readBytes: function (it, st, ot) {
          for (var at = [], lt = 0; lt < ot; lt++) at.push(it[st + lt]);
          return at;
        },
        readASCIIArray: function (it, st, ot) {
          for (var at = [], lt = 0; lt < ot; lt++)
            at.push(String.fromCharCode(it[st + lt]));
          return at;
        },
        _view: function (it) {
          return (
            it._dataView ||
            (it._dataView = it.buffer
              ? new DataView(it.buffer, it.byteOffset, it.byteLength)
              : new DataView(new Uint8Array(it).buffer))
          );
        },
      }),
        (et._lctf = {}),
        (et._lctf.parse = function (it, st, ot, at, lt) {
          var ct = et._bin,
            ut = {},
            ft = st;
          ct.readFixed(it, st), (st += 4);
          var ht = ct.readUshort(it, st);
          st += 2;
          var mt = ct.readUshort(it, st);
          st += 2;
          var vt = ct.readUshort(it, st);
          return (
            (st += 2),
            (ut.scriptList = et._lctf.readScriptList(it, ft + ht)),
            (ut.featureList = et._lctf.readFeatureList(it, ft + mt)),
            (ut.lookupList = et._lctf.readLookupList(it, ft + vt, lt)),
            ut
          );
        }),
        (et._lctf.readLookupList = function (it, st, ot) {
          var at = et._bin,
            lt = st,
            ct = [],
            ut = at.readUshort(it, st);
          st += 2;
          for (var ft = 0; ft < ut; ft++) {
            var ht = at.readUshort(it, st);
            st += 2;
            var mt = et._lctf.readLookupTable(it, lt + ht, ot);
            ct.push(mt);
          }
          return ct;
        }),
        (et._lctf.readLookupTable = function (it, st, ot) {
          var at = et._bin,
            lt = st,
            ct = { tabs: [] };
          (ct.ltype = at.readUshort(it, st)),
            (st += 2),
            (ct.flag = at.readUshort(it, st)),
            (st += 2);
          var ut = at.readUshort(it, st);
          st += 2;
          for (var ft = ct.ltype, ht = 0; ht < ut; ht++) {
            var mt = at.readUshort(it, st);
            st += 2;
            var vt = ot(it, ft, lt + mt, ct);
            ct.tabs.push(vt);
          }
          return ct;
        }),
        (et._lctf.numOfOnes = function (it) {
          for (var st = 0, ot = 0; ot < 32; ot++) (it >>> ot) & 1 && st++;
          return st;
        }),
        (et._lctf.readClassDef = function (it, st) {
          var ot = et._bin,
            at = [],
            lt = ot.readUshort(it, st);
          if (((st += 2), lt == 1)) {
            var ct = ot.readUshort(it, st);
            st += 2;
            var ut = ot.readUshort(it, st);
            st += 2;
            for (var ft = 0; ft < ut; ft++)
              at.push(ct + ft),
                at.push(ct + ft),
                at.push(ot.readUshort(it, st)),
                (st += 2);
          }
          if (lt == 2) {
            var ht = ot.readUshort(it, st);
            for (st += 2, ft = 0; ft < ht; ft++)
              at.push(ot.readUshort(it, st)),
                (st += 2),
                at.push(ot.readUshort(it, st)),
                (st += 2),
                at.push(ot.readUshort(it, st)),
                (st += 2);
          }
          return at;
        }),
        (et._lctf.getInterval = function (it, st) {
          for (var ot = 0; ot < it.length; ot += 3) {
            var at = it[ot],
              lt = it[ot + 1];
            if ((it[ot + 2], at <= st && st <= lt)) return ot;
          }
          return -1;
        }),
        (et._lctf.readCoverage = function (it, st) {
          var ot = et._bin,
            at = {};
          (at.fmt = ot.readUshort(it, st)), (st += 2);
          var lt = ot.readUshort(it, st);
          return (
            (st += 2),
            at.fmt == 1 && (at.tab = ot.readUshorts(it, st, lt)),
            at.fmt == 2 && (at.tab = ot.readUshorts(it, st, 3 * lt)),
            at
          );
        }),
        (et._lctf.coverageIndex = function (it, st) {
          var ot = it.tab;
          if (it.fmt == 1) return ot.indexOf(st);
          if (it.fmt == 2) {
            var at = et._lctf.getInterval(ot, st);
            if (at != -1) return ot[at + 2] + (st - ot[at]);
          }
          return -1;
        }),
        (et._lctf.readFeatureList = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = [],
            ct = ot.readUshort(it, st);
          st += 2;
          for (var ut = 0; ut < ct; ut++) {
            var ft = ot.readASCII(it, st, 4);
            st += 4;
            var ht = ot.readUshort(it, st);
            st += 2;
            var mt = et._lctf.readFeatureTable(it, at + ht);
            (mt.tag = ft.trim()), lt.push(mt);
          }
          return lt;
        }),
        (et._lctf.readFeatureTable = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = {},
            ct = ot.readUshort(it, st);
          (st += 2), ct > 0 && (lt.featureParams = at + ct);
          var ut = ot.readUshort(it, st);
          (st += 2), (lt.tab = []);
          for (var ft = 0; ft < ut; ft++)
            lt.tab.push(ot.readUshort(it, st + 2 * ft));
          return lt;
        }),
        (et._lctf.readScriptList = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = {},
            ct = ot.readUshort(it, st);
          st += 2;
          for (var ut = 0; ut < ct; ut++) {
            var ft = ot.readASCII(it, st, 4);
            st += 4;
            var ht = ot.readUshort(it, st);
            (st += 2), (lt[ft.trim()] = et._lctf.readScriptTable(it, at + ht));
          }
          return lt;
        }),
        (et._lctf.readScriptTable = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = {},
            ct = ot.readUshort(it, st);
          (st += 2), (lt.default = et._lctf.readLangSysTable(it, at + ct));
          var ut = ot.readUshort(it, st);
          st += 2;
          for (var ft = 0; ft < ut; ft++) {
            var ht = ot.readASCII(it, st, 4);
            st += 4;
            var mt = ot.readUshort(it, st);
            (st += 2), (lt[ht.trim()] = et._lctf.readLangSysTable(it, at + mt));
          }
          return lt;
        }),
        (et._lctf.readLangSysTable = function (it, st) {
          var ot = et._bin,
            at = {};
          ot.readUshort(it, st),
            (st += 2),
            (at.reqFeature = ot.readUshort(it, st)),
            (st += 2);
          var lt = ot.readUshort(it, st);
          return (st += 2), (at.features = ot.readUshorts(it, st, lt)), at;
        }),
        (et.CFF = {}),
        (et.CFF.parse = function (it, st, ot) {
          var at = et._bin;
          (it = new Uint8Array(it.buffer, st, ot))[(st = 0)],
            it[++st],
            it[++st],
            it[++st],
            st++;
          var lt = [];
          st = et.CFF.readIndex(it, st, lt);
          for (var ct = [], ut = 0; ut < lt.length - 1; ut++)
            ct.push(at.readASCII(it, st + lt[ut], lt[ut + 1] - lt[ut]));
          st += lt[lt.length - 1];
          var ft = [];
          st = et.CFF.readIndex(it, st, ft);
          var ht = [];
          for (ut = 0; ut < ft.length - 1; ut++)
            ht.push(et.CFF.readDict(it, st + ft[ut], st + ft[ut + 1]));
          st += ft[ft.length - 1];
          var mt = ht[0],
            vt = [];
          st = et.CFF.readIndex(it, st, vt);
          var yt = [];
          for (ut = 0; ut < vt.length - 1; ut++)
            yt.push(at.readASCII(it, st + vt[ut], vt[ut + 1] - vt[ut]));
          if (
            ((st += vt[vt.length - 1]),
            et.CFF.readSubrs(it, st, mt),
            mt.CharStrings)
          ) {
            (st = mt.CharStrings),
              (vt = []),
              (st = et.CFF.readIndex(it, st, vt));
            var Et = [];
            for (ut = 0; ut < vt.length - 1; ut++)
              Et.push(at.readBytes(it, st + vt[ut], vt[ut + 1] - vt[ut]));
            mt.CharStrings = Et;
          }
          if (mt.ROS) {
            st = mt.FDArray;
            var pt = [];
            for (
              st = et.CFF.readIndex(it, st, pt), mt.FDArray = [], ut = 0;
              ut < pt.length - 1;
              ut++
            ) {
              var xt = et.CFF.readDict(it, st + pt[ut], st + pt[ut + 1]);
              et.CFF._readFDict(it, xt, yt), mt.FDArray.push(xt);
            }
            (st += pt[pt.length - 1]), (st = mt.FDSelect), (mt.FDSelect = []);
            var St = it[st];
            if ((st++, St != 3)) throw St;
            var At = at.readUshort(it, st);
            for (st += 2, ut = 0; ut < At + 1; ut++)
              mt.FDSelect.push(at.readUshort(it, st), it[st + 2]), (st += 3);
          }
          return (
            mt.Encoding &&
              (mt.Encoding = et.CFF.readEncoding(
                it,
                mt.Encoding,
                mt.CharStrings.length
              )),
            mt.charset &&
              (mt.charset = et.CFF.readCharset(
                it,
                mt.charset,
                mt.CharStrings.length
              )),
            et.CFF._readFDict(it, mt, yt),
            mt
          );
        }),
        (et.CFF._readFDict = function (it, st, ot) {
          var at;
          for (var lt in (st.Private &&
            ((at = st.Private[1]),
            (st.Private = et.CFF.readDict(it, at, at + st.Private[0])),
            st.Private.Subrs &&
              et.CFF.readSubrs(it, at + st.Private.Subrs, st.Private)),
          st))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(lt) != -1 && (st[lt] = ot[st[lt] - 426 + 35]);
        }),
        (et.CFF.readSubrs = function (it, st, ot) {
          var at = et._bin,
            lt = [];
          st = et.CFF.readIndex(it, st, lt);
          var ct,
            ut = lt.length;
          (ct = ut < 1240 ? 107 : ut < 33900 ? 1131 : 32768),
            (ot.Bias = ct),
            (ot.Subrs = []);
          for (var ft = 0; ft < lt.length - 1; ft++)
            ot.Subrs.push(at.readBytes(it, st + lt[ft], lt[ft + 1] - lt[ft]));
        }),
        (et.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (et.CFF.glyphByUnicode = function (it, st) {
          for (var ot = 0; ot < it.charset.length; ot++)
            if (it.charset[ot] == st) return ot;
          return -1;
        }),
        (et.CFF.glyphBySE = function (it, st) {
          return st < 0 || st > 255
            ? -1
            : et.CFF.glyphByUnicode(it, et.CFF.tableSE[st]);
        }),
        (et.CFF.readEncoding = function (it, st, ot) {
          et._bin;
          var at = [".notdef"],
            lt = it[st];
          if ((st++, lt != 0)) throw "error: unknown encoding format: " + lt;
          var ct = it[st];
          st++;
          for (var ut = 0; ut < ct; ut++) at.push(it[st + ut]);
          return at;
        }),
        (et.CFF.readCharset = function (it, st, ot) {
          var at = et._bin,
            lt = [".notdef"],
            ct = it[st];
          if ((st++, ct == 0))
            for (var ut = 0; ut < ot; ut++) {
              var ft = at.readUshort(it, st);
              (st += 2), lt.push(ft);
            }
          else {
            if (ct != 1 && ct != 2) throw "error: format: " + ct;
            for (; lt.length < ot; ) {
              (ft = at.readUshort(it, st)), (st += 2);
              var ht = 0;
              for (
                ct == 1
                  ? ((ht = it[st]), st++)
                  : ((ht = at.readUshort(it, st)), (st += 2)),
                  ut = 0;
                ut <= ht;
                ut++
              )
                lt.push(ft), ft++;
            }
          }
          return lt;
        }),
        (et.CFF.readIndex = function (it, st, ot) {
          var at = et._bin,
            lt = at.readUshort(it, st) + 1,
            ct = it[(st += 2)];
          if ((st++, ct == 1))
            for (var ut = 0; ut < lt; ut++) ot.push(it[st + ut]);
          else if (ct == 2)
            for (ut = 0; ut < lt; ut++) ot.push(at.readUshort(it, st + 2 * ut));
          else if (ct == 3)
            for (ut = 0; ut < lt; ut++)
              ot.push(16777215 & at.readUint(it, st + 3 * ut - 1));
          else if (lt != 1)
            throw "unsupported offset size: " + ct + ", count: " + lt;
          return (st += lt * ct) - 1;
        }),
        (et.CFF.getCharString = function (it, st, ot) {
          var at = et._bin,
            lt = it[st],
            ct = it[st + 1];
          it[st + 2], it[st + 3], it[st + 4];
          var ut = 1,
            ft = null,
            ht = null;
          lt <= 20 && ((ft = lt), (ut = 1)),
            lt == 12 && ((ft = 100 * lt + ct), (ut = 2)),
            21 <= lt && lt <= 27 && ((ft = lt), (ut = 1)),
            lt == 28 && ((ht = at.readShort(it, st + 1)), (ut = 3)),
            29 <= lt && lt <= 31 && ((ft = lt), (ut = 1)),
            32 <= lt && lt <= 246 && ((ht = lt - 139), (ut = 1)),
            247 <= lt &&
              lt <= 250 &&
              ((ht = 256 * (lt - 247) + ct + 108), (ut = 2)),
            251 <= lt &&
              lt <= 254 &&
              ((ht = 256 * -(lt - 251) - ct - 108), (ut = 2)),
            lt == 255 && ((ht = at.readInt(it, st + 1) / 65535), (ut = 5)),
            (ot.val = ht ?? "o" + ft),
            (ot.size = ut);
        }),
        (et.CFF.readCharString = function (it, st, ot) {
          for (var at = st + ot, lt = et._bin, ct = []; st < at; ) {
            var ut = it[st],
              ft = it[st + 1];
            it[st + 2], it[st + 3], it[st + 4];
            var ht = 1,
              mt = null,
              vt = null;
            ut <= 20 && ((mt = ut), (ht = 1)),
              ut == 12 && ((mt = 100 * ut + ft), (ht = 2)),
              (ut != 19 && ut != 20) || ((mt = ut), (ht = 2)),
              21 <= ut && ut <= 27 && ((mt = ut), (ht = 1)),
              ut == 28 && ((vt = lt.readShort(it, st + 1)), (ht = 3)),
              29 <= ut && ut <= 31 && ((mt = ut), (ht = 1)),
              32 <= ut && ut <= 246 && ((vt = ut - 139), (ht = 1)),
              247 <= ut &&
                ut <= 250 &&
                ((vt = 256 * (ut - 247) + ft + 108), (ht = 2)),
              251 <= ut &&
                ut <= 254 &&
                ((vt = 256 * -(ut - 251) - ft - 108), (ht = 2)),
              ut == 255 && ((vt = lt.readInt(it, st + 1) / 65535), (ht = 5)),
              ct.push(vt ?? "o" + mt),
              (st += ht);
          }
          return ct;
        }),
        (et.CFF.readDict = function (it, st, ot) {
          for (var at = et._bin, lt = {}, ct = []; st < ot; ) {
            var ut = it[st],
              ft = it[st + 1];
            it[st + 2], it[st + 3], it[st + 4];
            var ht = 1,
              mt = null,
              vt = null;
            if (
              (ut == 28 && ((vt = at.readShort(it, st + 1)), (ht = 3)),
              ut == 29 && ((vt = at.readInt(it, st + 1)), (ht = 5)),
              32 <= ut && ut <= 246 && ((vt = ut - 139), (ht = 1)),
              247 <= ut &&
                ut <= 250 &&
                ((vt = 256 * (ut - 247) + ft + 108), (ht = 2)),
              251 <= ut &&
                ut <= 254 &&
                ((vt = 256 * -(ut - 251) - ft - 108), (ht = 2)),
              ut == 255)
            )
              throw (
                ((vt = at.readInt(it, st + 1) / 65535),
                (ht = 5),
                "unknown number")
              );
            if (ut == 30) {
              var yt = [];
              for (ht = 1; ; ) {
                var Et = it[st + ht];
                ht++;
                var pt = Et >> 4,
                  xt = 15 & Et;
                if (
                  (pt != 15 && yt.push(pt), xt != 15 && yt.push(xt), xt == 15)
                )
                  break;
              }
              for (
                var St = "",
                  At = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  Ct = 0;
                Ct < yt.length;
                Ct++
              )
                St += At[yt[Ct]];
              vt = parseFloat(St);
            }
            ut <= 21 &&
              ((mt = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][ut]),
              (ht = 1),
              ut == 12 &&
                ((mt = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][ft]),
                (ht = 2))),
              mt != null
                ? ((lt[mt] = ct.length == 1 ? ct[0] : ct), (ct = []))
                : ct.push(vt),
              (st += ht);
          }
          return lt;
        }),
        (et.cmap = {}),
        (et.cmap.parse = function (it, st, ot) {
          (it = new Uint8Array(it.buffer, st, ot)), (st = 0);
          var at = et._bin,
            lt = {};
          at.readUshort(it, st), (st += 2);
          var ct = at.readUshort(it, st);
          st += 2;
          var ut = [];
          lt.tables = [];
          for (var ft = 0; ft < ct; ft++) {
            var ht = at.readUshort(it, st);
            st += 2;
            var mt = at.readUshort(it, st);
            st += 2;
            var vt = at.readUint(it, st);
            st += 4;
            var yt = "p" + ht + "e" + mt,
              Et = ut.indexOf(vt);
            if (Et == -1) {
              var pt;
              (Et = lt.tables.length), ut.push(vt);
              var xt = at.readUshort(it, vt);
              xt == 0
                ? (pt = et.cmap.parse0(it, vt))
                : xt == 4
                ? (pt = et.cmap.parse4(it, vt))
                : xt == 6
                ? (pt = et.cmap.parse6(it, vt))
                : xt == 12
                ? (pt = et.cmap.parse12(it, vt))
                : console.debug("unknown format: " + xt, ht, mt, vt),
                lt.tables.push(pt);
            }
            if (lt[yt] != null)
              throw "multiple tables for one platform+encoding";
            lt[yt] = Et;
          }
          return lt;
        }),
        (et.cmap.parse0 = function (it, st) {
          var ot = et._bin,
            at = {};
          (at.format = ot.readUshort(it, st)), (st += 2);
          var lt = ot.readUshort(it, st);
          (st += 2), ot.readUshort(it, st), (st += 2), (at.map = []);
          for (var ct = 0; ct < lt - 6; ct++) at.map.push(it[st + ct]);
          return at;
        }),
        (et.cmap.parse4 = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = {};
          (lt.format = ot.readUshort(it, st)), (st += 2);
          var ct = ot.readUshort(it, st);
          (st += 2), ot.readUshort(it, st), (st += 2);
          var ut = ot.readUshort(it, st);
          st += 2;
          var ft = ut / 2;
          (lt.searchRange = ot.readUshort(it, st)),
            (st += 2),
            (lt.entrySelector = ot.readUshort(it, st)),
            (st += 2),
            (lt.rangeShift = ot.readUshort(it, st)),
            (st += 2),
            (lt.endCount = ot.readUshorts(it, st, ft)),
            (st += 2 * ft),
            (st += 2),
            (lt.startCount = ot.readUshorts(it, st, ft)),
            (st += 2 * ft),
            (lt.idDelta = []);
          for (var ht = 0; ht < ft; ht++)
            lt.idDelta.push(ot.readShort(it, st)), (st += 2);
          for (
            lt.idRangeOffset = ot.readUshorts(it, st, ft),
              st += 2 * ft,
              lt.glyphIdArray = [];
            st < at + ct;

          )
            lt.glyphIdArray.push(ot.readUshort(it, st)), (st += 2);
          return lt;
        }),
        (et.cmap.parse6 = function (it, st) {
          var ot = et._bin,
            at = {};
          (at.format = ot.readUshort(it, st)),
            (st += 2),
            ot.readUshort(it, st),
            (st += 2),
            ot.readUshort(it, st),
            (st += 2),
            (at.firstCode = ot.readUshort(it, st)),
            (st += 2);
          var lt = ot.readUshort(it, st);
          (st += 2), (at.glyphIdArray = []);
          for (var ct = 0; ct < lt; ct++)
            at.glyphIdArray.push(ot.readUshort(it, st)), (st += 2);
          return at;
        }),
        (et.cmap.parse12 = function (it, st) {
          var ot = et._bin,
            at = {};
          (at.format = ot.readUshort(it, st)),
            (st += 2),
            (st += 2),
            ot.readUint(it, st),
            (st += 4),
            ot.readUint(it, st),
            (st += 4);
          var lt = ot.readUint(it, st);
          (st += 4), (at.groups = []);
          for (var ct = 0; ct < lt; ct++) {
            var ut = st + 12 * ct,
              ft = ot.readUint(it, ut + 0),
              ht = ot.readUint(it, ut + 4),
              mt = ot.readUint(it, ut + 8);
            at.groups.push([ft, ht, mt]);
          }
          return at;
        }),
        (et.glyf = {}),
        (et.glyf.parse = function (it, st, ot, at) {
          for (var lt = [], ct = 0; ct < at.maxp.numGlyphs; ct++) lt.push(null);
          return lt;
        }),
        (et.glyf._parseGlyf = function (it, st) {
          var ot = et._bin,
            at = it._data,
            lt = et._tabOffset(at, "glyf", it._offset) + it.loca[st];
          if (it.loca[st] == it.loca[st + 1]) return null;
          var ct = {};
          if (
            ((ct.noc = ot.readShort(at, lt)),
            (lt += 2),
            (ct.xMin = ot.readShort(at, lt)),
            (lt += 2),
            (ct.yMin = ot.readShort(at, lt)),
            (lt += 2),
            (ct.xMax = ot.readShort(at, lt)),
            (lt += 2),
            (ct.yMax = ot.readShort(at, lt)),
            (lt += 2),
            ct.xMin >= ct.xMax || ct.yMin >= ct.yMax)
          )
            return null;
          if (ct.noc > 0) {
            ct.endPts = [];
            for (var ut = 0; ut < ct.noc; ut++)
              ct.endPts.push(ot.readUshort(at, lt)), (lt += 2);
            var ft = ot.readUshort(at, lt);
            if (((lt += 2), at.length - lt < ft)) return null;
            (ct.instructions = ot.readBytes(at, lt, ft)), (lt += ft);
            var ht = ct.endPts[ct.noc - 1] + 1;
            for (ct.flags = [], ut = 0; ut < ht; ut++) {
              var mt = at[lt];
              if ((lt++, ct.flags.push(mt), (8 & mt) != 0)) {
                var vt = at[lt];
                lt++;
                for (var yt = 0; yt < vt; yt++) ct.flags.push(mt), ut++;
              }
            }
            for (ct.xs = [], ut = 0; ut < ht; ut++) {
              var Et = (2 & ct.flags[ut]) != 0,
                pt = (16 & ct.flags[ut]) != 0;
              Et
                ? (ct.xs.push(pt ? at[lt] : -at[lt]), lt++)
                : pt
                ? ct.xs.push(0)
                : (ct.xs.push(ot.readShort(at, lt)), (lt += 2));
            }
            for (ct.ys = [], ut = 0; ut < ht; ut++)
              (Et = (4 & ct.flags[ut]) != 0),
                (pt = (32 & ct.flags[ut]) != 0),
                Et
                  ? (ct.ys.push(pt ? at[lt] : -at[lt]), lt++)
                  : pt
                  ? ct.ys.push(0)
                  : (ct.ys.push(ot.readShort(at, lt)), (lt += 2));
            var xt = 0,
              St = 0;
            for (ut = 0; ut < ht; ut++)
              (xt += ct.xs[ut]),
                (St += ct.ys[ut]),
                (ct.xs[ut] = xt),
                (ct.ys[ut] = St);
          } else {
            var At;
            ct.parts = [];
            do {
              (At = ot.readUshort(at, lt)), (lt += 2);
              var Ct = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (ct.parts.push(Ct),
                (Ct.glyphIndex = ot.readUshort(at, lt)),
                (lt += 2),
                1 & At)
              ) {
                var Mt = ot.readShort(at, lt);
                lt += 2;
                var wt = ot.readShort(at, lt);
                lt += 2;
              } else
                (Mt = ot.readInt8(at, lt)),
                  lt++,
                  (wt = ot.readInt8(at, lt)),
                  lt++;
              2 & At
                ? ((Ct.m.tx = Mt), (Ct.m.ty = wt))
                : ((Ct.p1 = Mt), (Ct.p2 = wt)),
                8 & At
                  ? ((Ct.m.a = Ct.m.d = ot.readF2dot14(at, lt)), (lt += 2))
                  : 64 & At
                  ? ((Ct.m.a = ot.readF2dot14(at, lt)),
                    (lt += 2),
                    (Ct.m.d = ot.readF2dot14(at, lt)),
                    (lt += 2))
                  : 128 & At &&
                    ((Ct.m.a = ot.readF2dot14(at, lt)),
                    (lt += 2),
                    (Ct.m.b = ot.readF2dot14(at, lt)),
                    (lt += 2),
                    (Ct.m.c = ot.readF2dot14(at, lt)),
                    (lt += 2),
                    (Ct.m.d = ot.readF2dot14(at, lt)),
                    (lt += 2));
            } while (32 & At);
            if (256 & At) {
              var Bt = ot.readUshort(at, lt);
              for (lt += 2, ct.instr = [], ut = 0; ut < Bt; ut++)
                ct.instr.push(at[lt]), lt++;
            }
          }
          return ct;
        }),
        (et.GPOS = {}),
        (et.GPOS.parse = function (it, st, ot, at) {
          return et._lctf.parse(it, st, ot, at, et.GPOS.subt);
        }),
        (et.GPOS.subt = function (it, st, ot, at) {
          var lt = et._bin,
            ct = ot,
            ut = {};
          if (
            ((ut.fmt = lt.readUshort(it, ot)),
            (ot += 2),
            st == 1 ||
              st == 2 ||
              st == 3 ||
              st == 7 ||
              (st == 8 && ut.fmt <= 2))
          ) {
            var ft = lt.readUshort(it, ot);
            (ot += 2), (ut.coverage = et._lctf.readCoverage(it, ft + ct));
          }
          if (st == 1 && ut.fmt == 1) {
            var ht = lt.readUshort(it, ot);
            ot += 2;
            var mt = et._lctf.numOfOnes(ht);
            ht != 0 && (ut.pos = et.GPOS.readValueRecord(it, ot, ht));
          } else if (st == 2 && ut.fmt >= 1 && ut.fmt <= 2) {
            (ht = lt.readUshort(it, ot)), (ot += 2);
            var vt = lt.readUshort(it, ot);
            (ot += 2), (mt = et._lctf.numOfOnes(ht));
            var yt = et._lctf.numOfOnes(vt);
            if (ut.fmt == 1) {
              ut.pairsets = [];
              var Et = lt.readUshort(it, ot);
              ot += 2;
              for (var pt = 0; pt < Et; pt++) {
                var xt = ct + lt.readUshort(it, ot);
                ot += 2;
                var St = lt.readUshort(it, xt);
                xt += 2;
                for (var At = [], Ct = 0; Ct < St; Ct++) {
                  var Mt = lt.readUshort(it, xt);
                  (xt += 2),
                    ht != 0 &&
                      (($t = et.GPOS.readValueRecord(it, xt, ht)),
                      (xt += 2 * mt)),
                    vt != 0 &&
                      ((Kt = et.GPOS.readValueRecord(it, xt, vt)),
                      (xt += 2 * yt)),
                    At.push({ gid2: Mt, val1: $t, val2: Kt });
                }
                ut.pairsets.push(At);
              }
            }
            if (ut.fmt == 2) {
              var wt = lt.readUshort(it, ot);
              ot += 2;
              var Bt = lt.readUshort(it, ot);
              ot += 2;
              var It = lt.readUshort(it, ot);
              ot += 2;
              var Ft = lt.readUshort(it, ot);
              for (
                ot += 2,
                  ut.classDef1 = et._lctf.readClassDef(it, ct + wt),
                  ut.classDef2 = et._lctf.readClassDef(it, ct + Bt),
                  ut.matrix = [],
                  pt = 0;
                pt < It;
                pt++
              ) {
                var Vt = [];
                for (Ct = 0; Ct < Ft; Ct++) {
                  var $t = null,
                    Kt = null;
                  ht != 0 &&
                    (($t = et.GPOS.readValueRecord(it, ot, ht)),
                    (ot += 2 * mt)),
                    vt != 0 &&
                      ((Kt = et.GPOS.readValueRecord(it, ot, vt)),
                      (ot += 2 * yt)),
                    Vt.push({ val1: $t, val2: Kt });
                }
                ut.matrix.push(Vt);
              }
            }
          } else {
            if (st == 9 && ut.fmt == 1) {
              var Ht = lt.readUshort(it, ot);
              ot += 2;
              var Wt = lt.readUint(it, ot);
              if (((ot += 4), at.ltype == 9)) at.ltype = Ht;
              else if (at.ltype != Ht) throw "invalid extension substitution";
              return et.GPOS.subt(it, at.ltype, ct + Wt);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              st,
              "format",
              ut.fmt
            );
          }
          return ut;
        }),
        (et.GPOS.readValueRecord = function (it, st, ot) {
          var at = et._bin,
            lt = [];
          return (
            lt.push(1 & ot ? at.readShort(it, st) : 0),
            (st += 1 & ot ? 2 : 0),
            lt.push(2 & ot ? at.readShort(it, st) : 0),
            (st += 2 & ot ? 2 : 0),
            lt.push(4 & ot ? at.readShort(it, st) : 0),
            (st += 4 & ot ? 2 : 0),
            lt.push(8 & ot ? at.readShort(it, st) : 0),
            (st += 8 & ot ? 2 : 0),
            lt
          );
        }),
        (et.GSUB = {}),
        (et.GSUB.parse = function (it, st, ot, at) {
          return et._lctf.parse(it, st, ot, at, et.GSUB.subt);
        }),
        (et.GSUB.subt = function (it, st, ot, at) {
          var lt = et._bin,
            ct = ot,
            ut = {};
          if (
            ((ut.fmt = lt.readUshort(it, ot)),
            (ot += 2),
            st != 1 && st != 4 && st != 5 && st != 6)
          )
            return null;
          if (
            st == 1 ||
            st == 4 ||
            (st == 5 && ut.fmt <= 2) ||
            (st == 6 && ut.fmt <= 2)
          ) {
            var ft = lt.readUshort(it, ot);
            (ot += 2), (ut.coverage = et._lctf.readCoverage(it, ct + ft));
          }
          if (st == 1 && ut.fmt >= 1 && ut.fmt <= 2) {
            if (ut.fmt == 1) (ut.delta = lt.readShort(it, ot)), (ot += 2);
            else if (ut.fmt == 2) {
              var ht = lt.readUshort(it, ot);
              (ot += 2),
                (ut.newg = lt.readUshorts(it, ot, ht)),
                (ot += 2 * ut.newg.length);
            }
          } else if (st == 4) {
            (ut.vals = []), (ht = lt.readUshort(it, ot)), (ot += 2);
            for (var mt = 0; mt < ht; mt++) {
              var vt = lt.readUshort(it, ot);
              (ot += 2), ut.vals.push(et.GSUB.readLigatureSet(it, ct + vt));
            }
          } else if (st == 5 && ut.fmt == 2) {
            if (ut.fmt == 2) {
              var yt = lt.readUshort(it, ot);
              (ot += 2),
                (ut.cDef = et._lctf.readClassDef(it, ct + yt)),
                (ut.scset = []);
              var Et = lt.readUshort(it, ot);
              for (ot += 2, mt = 0; mt < Et; mt++) {
                var pt = lt.readUshort(it, ot);
                (ot += 2),
                  ut.scset.push(
                    pt == 0 ? null : et.GSUB.readSubClassSet(it, ct + pt)
                  );
              }
            }
          } else if (st == 6 && ut.fmt == 3) {
            if (ut.fmt == 3) {
              for (mt = 0; mt < 3; mt++) {
                (ht = lt.readUshort(it, ot)), (ot += 2);
                for (var xt = [], St = 0; St < ht; St++)
                  xt.push(
                    et._lctf.readCoverage(
                      it,
                      ct + lt.readUshort(it, ot + 2 * St)
                    )
                  );
                (ot += 2 * ht),
                  mt == 0 && (ut.backCvg = xt),
                  mt == 1 && (ut.inptCvg = xt),
                  mt == 2 && (ut.ahedCvg = xt);
              }
              (ht = lt.readUshort(it, ot)),
                (ot += 2),
                (ut.lookupRec = et.GSUB.readSubstLookupRecords(it, ot, ht));
            }
          } else {
            if (st == 7 && ut.fmt == 1) {
              var At = lt.readUshort(it, ot);
              ot += 2;
              var Ct = lt.readUint(it, ot);
              if (((ot += 4), at.ltype == 9)) at.ltype = At;
              else if (at.ltype != At) throw "invalid extension substitution";
              return et.GSUB.subt(it, at.ltype, ct + Ct);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              st,
              "format",
              ut.fmt
            );
          }
          return ut;
        }),
        (et.GSUB.readSubClassSet = function (it, st) {
          var ot = et._bin.readUshort,
            at = st,
            lt = [],
            ct = ot(it, st);
          st += 2;
          for (var ut = 0; ut < ct; ut++) {
            var ft = ot(it, st);
            (st += 2), lt.push(et.GSUB.readSubClassRule(it, at + ft));
          }
          return lt;
        }),
        (et.GSUB.readSubClassRule = function (it, st) {
          var ot = et._bin.readUshort,
            at = {},
            lt = ot(it, st),
            ct = ot(it, (st += 2));
          (st += 2), (at.input = []);
          for (var ut = 0; ut < lt - 1; ut++)
            at.input.push(ot(it, st)), (st += 2);
          return (
            (at.substLookupRecords = et.GSUB.readSubstLookupRecords(
              it,
              st,
              ct
            )),
            at
          );
        }),
        (et.GSUB.readSubstLookupRecords = function (it, st, ot) {
          for (var at = et._bin.readUshort, lt = [], ct = 0; ct < ot; ct++)
            lt.push(at(it, st), at(it, st + 2)), (st += 4);
          return lt;
        }),
        (et.GSUB.readChainSubClassSet = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = [],
            ct = ot.readUshort(it, st);
          st += 2;
          for (var ut = 0; ut < ct; ut++) {
            var ft = ot.readUshort(it, st);
            (st += 2), lt.push(et.GSUB.readChainSubClassRule(it, at + ft));
          }
          return lt;
        }),
        (et.GSUB.readChainSubClassRule = function (it, st) {
          for (
            var ot = et._bin,
              at = {},
              lt = ["backtrack", "input", "lookahead"],
              ct = 0;
            ct < lt.length;
            ct++
          ) {
            var ut = ot.readUshort(it, st);
            (st += 2),
              ct == 1 && ut--,
              (at[lt[ct]] = ot.readUshorts(it, st, ut)),
              (st += 2 * at[lt[ct]].length);
          }
          return (
            (ut = ot.readUshort(it, st)),
            (st += 2),
            (at.subst = ot.readUshorts(it, st, 2 * ut)),
            (st += 2 * at.subst.length),
            at
          );
        }),
        (et.GSUB.readLigatureSet = function (it, st) {
          var ot = et._bin,
            at = st,
            lt = [],
            ct = ot.readUshort(it, st);
          st += 2;
          for (var ut = 0; ut < ct; ut++) {
            var ft = ot.readUshort(it, st);
            (st += 2), lt.push(et.GSUB.readLigature(it, at + ft));
          }
          return lt;
        }),
        (et.GSUB.readLigature = function (it, st) {
          var ot = et._bin,
            at = { chain: [] };
          (at.nglyph = ot.readUshort(it, st)), (st += 2);
          var lt = ot.readUshort(it, st);
          st += 2;
          for (var ct = 0; ct < lt - 1; ct++)
            at.chain.push(ot.readUshort(it, st)), (st += 2);
          return at;
        }),
        (et.head = {}),
        (et.head.parse = function (it, st, ot) {
          var at = et._bin,
            lt = {};
          return (
            at.readFixed(it, st),
            (st += 4),
            (lt.fontRevision = at.readFixed(it, st)),
            (st += 4),
            at.readUint(it, st),
            (st += 4),
            at.readUint(it, st),
            (st += 4),
            (lt.flags = at.readUshort(it, st)),
            (st += 2),
            (lt.unitsPerEm = at.readUshort(it, st)),
            (st += 2),
            (lt.created = at.readUint64(it, st)),
            (st += 8),
            (lt.modified = at.readUint64(it, st)),
            (st += 8),
            (lt.xMin = at.readShort(it, st)),
            (st += 2),
            (lt.yMin = at.readShort(it, st)),
            (st += 2),
            (lt.xMax = at.readShort(it, st)),
            (st += 2),
            (lt.yMax = at.readShort(it, st)),
            (st += 2),
            (lt.macStyle = at.readUshort(it, st)),
            (st += 2),
            (lt.lowestRecPPEM = at.readUshort(it, st)),
            (st += 2),
            (lt.fontDirectionHint = at.readShort(it, st)),
            (st += 2),
            (lt.indexToLocFormat = at.readShort(it, st)),
            (st += 2),
            (lt.glyphDataFormat = at.readShort(it, st)),
            (st += 2),
            lt
          );
        }),
        (et.hhea = {}),
        (et.hhea.parse = function (it, st, ot) {
          var at = et._bin,
            lt = {};
          return (
            at.readFixed(it, st),
            (st += 4),
            (lt.ascender = at.readShort(it, st)),
            (st += 2),
            (lt.descender = at.readShort(it, st)),
            (st += 2),
            (lt.lineGap = at.readShort(it, st)),
            (st += 2),
            (lt.advanceWidthMax = at.readUshort(it, st)),
            (st += 2),
            (lt.minLeftSideBearing = at.readShort(it, st)),
            (st += 2),
            (lt.minRightSideBearing = at.readShort(it, st)),
            (st += 2),
            (lt.xMaxExtent = at.readShort(it, st)),
            (st += 2),
            (lt.caretSlopeRise = at.readShort(it, st)),
            (st += 2),
            (lt.caretSlopeRun = at.readShort(it, st)),
            (st += 2),
            (lt.caretOffset = at.readShort(it, st)),
            (st += 2),
            (st += 8),
            (lt.metricDataFormat = at.readShort(it, st)),
            (st += 2),
            (lt.numberOfHMetrics = at.readUshort(it, st)),
            (st += 2),
            lt
          );
        }),
        (et.hmtx = {}),
        (et.hmtx.parse = function (it, st, ot, at) {
          for (
            var lt = et._bin,
              ct = { aWidth: [], lsBearing: [] },
              ut = 0,
              ft = 0,
              ht = 0;
            ht < at.maxp.numGlyphs;
            ht++
          )
            ht < at.hhea.numberOfHMetrics &&
              ((ut = lt.readUshort(it, st)),
              (st += 2),
              (ft = lt.readShort(it, st)),
              (st += 2)),
              ct.aWidth.push(ut),
              ct.lsBearing.push(ft);
          return ct;
        }),
        (et.kern = {}),
        (et.kern.parse = function (it, st, ot, at) {
          var lt = et._bin,
            ct = lt.readUshort(it, st);
          if (((st += 2), ct == 1)) return et.kern.parseV1(it, st - 2, ot, at);
          var ut = lt.readUshort(it, st);
          st += 2;
          for (var ft = { glyph1: [], rval: [] }, ht = 0; ht < ut; ht++) {
            (st += 2), (ot = lt.readUshort(it, st)), (st += 2);
            var mt = lt.readUshort(it, st);
            st += 2;
            var vt = mt >>> 8;
            if ((vt &= 15) != 0) throw "unknown kern table format: " + vt;
            st = et.kern.readFormat0(it, st, ft);
          }
          return ft;
        }),
        (et.kern.parseV1 = function (it, st, ot, at) {
          var lt = et._bin;
          lt.readFixed(it, st), (st += 4);
          var ct = lt.readUint(it, st);
          st += 4;
          for (var ut = { glyph1: [], rval: [] }, ft = 0; ft < ct; ft++) {
            lt.readUint(it, st), (st += 4);
            var ht = lt.readUshort(it, st);
            (st += 2), lt.readUshort(it, st), (st += 2);
            var mt = ht >>> 8;
            if ((mt &= 15) != 0) throw "unknown kern table format: " + mt;
            st = et.kern.readFormat0(it, st, ut);
          }
          return ut;
        }),
        (et.kern.readFormat0 = function (it, st, ot) {
          var at = et._bin,
            lt = -1,
            ct = at.readUshort(it, st);
          (st += 2),
            at.readUshort(it, st),
            (st += 2),
            at.readUshort(it, st),
            (st += 2),
            at.readUshort(it, st),
            (st += 2);
          for (var ut = 0; ut < ct; ut++) {
            var ft = at.readUshort(it, st);
            st += 2;
            var ht = at.readUshort(it, st);
            st += 2;
            var mt = at.readShort(it, st);
            (st += 2),
              ft != lt &&
                (ot.glyph1.push(ft), ot.rval.push({ glyph2: [], vals: [] }));
            var vt = ot.rval[ot.rval.length - 1];
            vt.glyph2.push(ht), vt.vals.push(mt), (lt = ft);
          }
          return st;
        }),
        (et.loca = {}),
        (et.loca.parse = function (it, st, ot, at) {
          var lt = et._bin,
            ct = [],
            ut = at.head.indexToLocFormat,
            ft = at.maxp.numGlyphs + 1;
          if (ut == 0)
            for (var ht = 0; ht < ft; ht++)
              ct.push(lt.readUshort(it, st + (ht << 1)) << 1);
          if (ut == 1)
            for (ht = 0; ht < ft; ht++)
              ct.push(lt.readUint(it, st + (ht << 2)));
          return ct;
        }),
        (et.maxp = {}),
        (et.maxp.parse = function (it, st, ot) {
          var at = et._bin,
            lt = {},
            ct = at.readUint(it, st);
          return (
            (st += 4),
            (lt.numGlyphs = at.readUshort(it, st)),
            (st += 2),
            ct == 65536 &&
              ((lt.maxPoints = at.readUshort(it, st)),
              (st += 2),
              (lt.maxContours = at.readUshort(it, st)),
              (st += 2),
              (lt.maxCompositePoints = at.readUshort(it, st)),
              (st += 2),
              (lt.maxCompositeContours = at.readUshort(it, st)),
              (st += 2),
              (lt.maxZones = at.readUshort(it, st)),
              (st += 2),
              (lt.maxTwilightPoints = at.readUshort(it, st)),
              (st += 2),
              (lt.maxStorage = at.readUshort(it, st)),
              (st += 2),
              (lt.maxFunctionDefs = at.readUshort(it, st)),
              (st += 2),
              (lt.maxInstructionDefs = at.readUshort(it, st)),
              (st += 2),
              (lt.maxStackElements = at.readUshort(it, st)),
              (st += 2),
              (lt.maxSizeOfInstructions = at.readUshort(it, st)),
              (st += 2),
              (lt.maxComponentElements = at.readUshort(it, st)),
              (st += 2),
              (lt.maxComponentDepth = at.readUshort(it, st)),
              (st += 2)),
            lt
          );
        }),
        (et.name = {}),
        (et.name.parse = function (it, st, ot) {
          var at = et._bin,
            lt = {};
          at.readUshort(it, st), (st += 2);
          var ct = at.readUshort(it, st);
          (st += 2), at.readUshort(it, st);
          for (
            var ut,
              ft = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              ht = (st += 2),
              mt = 0;
            mt < ct;
            mt++
          ) {
            var vt = at.readUshort(it, st);
            st += 2;
            var yt = at.readUshort(it, st);
            st += 2;
            var Et = at.readUshort(it, st);
            st += 2;
            var pt = at.readUshort(it, st);
            st += 2;
            var xt = at.readUshort(it, st);
            st += 2;
            var St = at.readUshort(it, st);
            st += 2;
            var At,
              Ct = ft[pt],
              Mt = ht + 12 * ct + St;
            if (vt == 0) At = at.readUnicode(it, Mt, xt / 2);
            else if (vt == 3 && yt == 0) At = at.readUnicode(it, Mt, xt / 2);
            else if (yt == 0) At = at.readASCII(it, Mt, xt);
            else if (yt == 1) At = at.readUnicode(it, Mt, xt / 2);
            else if (yt == 3) At = at.readUnicode(it, Mt, xt / 2);
            else {
              if (vt != 1)
                throw "unknown encoding " + yt + ", platformID: " + vt;
              (At = at.readASCII(it, Mt, xt)),
                console.debug(
                  "reading unknown MAC encoding " + yt + " as ASCII"
                );
            }
            var wt = "p" + vt + "," + Et.toString(16);
            lt[wt] == null && (lt[wt] = {}),
              (lt[wt][Ct !== void 0 ? Ct : pt] = At),
              (lt[wt]._lang = Et);
          }
          for (var Bt in lt)
            if (lt[Bt].postScriptName != null && lt[Bt]._lang == 1033)
              return lt[Bt];
          for (var Bt in lt)
            if (lt[Bt].postScriptName != null && lt[Bt]._lang == 0)
              return lt[Bt];
          for (var Bt in lt)
            if (lt[Bt].postScriptName != null && lt[Bt]._lang == 3084)
              return lt[Bt];
          for (var Bt in lt) if (lt[Bt].postScriptName != null) return lt[Bt];
          for (var Bt in lt) {
            ut = Bt;
            break;
          }
          return (
            console.debug(
              "returning name table with languageID " + lt[ut]._lang
            ),
            lt[ut]
          );
        }),
        (et["OS/2"] = {}),
        (et["OS/2"].parse = function (it, st, ot) {
          var at = et._bin.readUshort(it, st);
          st += 2;
          var lt = {};
          if (at == 0) et["OS/2"].version0(it, st, lt);
          else if (at == 1) et["OS/2"].version1(it, st, lt);
          else if (at == 2 || at == 3 || at == 4)
            et["OS/2"].version2(it, st, lt);
          else {
            if (at != 5) throw "unknown OS/2 table version: " + at;
            et["OS/2"].version5(it, st, lt);
          }
          return lt;
        }),
        (et["OS/2"].version0 = function (it, st, ot) {
          var at = et._bin;
          return (
            (ot.xAvgCharWidth = at.readShort(it, st)),
            (st += 2),
            (ot.usWeightClass = at.readUshort(it, st)),
            (st += 2),
            (ot.usWidthClass = at.readUshort(it, st)),
            (st += 2),
            (ot.fsType = at.readUshort(it, st)),
            (st += 2),
            (ot.ySubscriptXSize = at.readShort(it, st)),
            (st += 2),
            (ot.ySubscriptYSize = at.readShort(it, st)),
            (st += 2),
            (ot.ySubscriptXOffset = at.readShort(it, st)),
            (st += 2),
            (ot.ySubscriptYOffset = at.readShort(it, st)),
            (st += 2),
            (ot.ySuperscriptXSize = at.readShort(it, st)),
            (st += 2),
            (ot.ySuperscriptYSize = at.readShort(it, st)),
            (st += 2),
            (ot.ySuperscriptXOffset = at.readShort(it, st)),
            (st += 2),
            (ot.ySuperscriptYOffset = at.readShort(it, st)),
            (st += 2),
            (ot.yStrikeoutSize = at.readShort(it, st)),
            (st += 2),
            (ot.yStrikeoutPosition = at.readShort(it, st)),
            (st += 2),
            (ot.sFamilyClass = at.readShort(it, st)),
            (st += 2),
            (ot.panose = at.readBytes(it, st, 10)),
            (st += 10),
            (ot.ulUnicodeRange1 = at.readUint(it, st)),
            (st += 4),
            (ot.ulUnicodeRange2 = at.readUint(it, st)),
            (st += 4),
            (ot.ulUnicodeRange3 = at.readUint(it, st)),
            (st += 4),
            (ot.ulUnicodeRange4 = at.readUint(it, st)),
            (st += 4),
            (ot.achVendID = [
              at.readInt8(it, st),
              at.readInt8(it, st + 1),
              at.readInt8(it, st + 2),
              at.readInt8(it, st + 3),
            ]),
            (st += 4),
            (ot.fsSelection = at.readUshort(it, st)),
            (st += 2),
            (ot.usFirstCharIndex = at.readUshort(it, st)),
            (st += 2),
            (ot.usLastCharIndex = at.readUshort(it, st)),
            (st += 2),
            (ot.sTypoAscender = at.readShort(it, st)),
            (st += 2),
            (ot.sTypoDescender = at.readShort(it, st)),
            (st += 2),
            (ot.sTypoLineGap = at.readShort(it, st)),
            (st += 2),
            (ot.usWinAscent = at.readUshort(it, st)),
            (st += 2),
            (ot.usWinDescent = at.readUshort(it, st)),
            (st += 2)
          );
        }),
        (et["OS/2"].version1 = function (it, st, ot) {
          var at = et._bin;
          return (
            (st = et["OS/2"].version0(it, st, ot)),
            (ot.ulCodePageRange1 = at.readUint(it, st)),
            (st += 4),
            (ot.ulCodePageRange2 = at.readUint(it, st)),
            (st += 4)
          );
        }),
        (et["OS/2"].version2 = function (it, st, ot) {
          var at = et._bin;
          return (
            (st = et["OS/2"].version1(it, st, ot)),
            (ot.sxHeight = at.readShort(it, st)),
            (st += 2),
            (ot.sCapHeight = at.readShort(it, st)),
            (st += 2),
            (ot.usDefault = at.readUshort(it, st)),
            (st += 2),
            (ot.usBreak = at.readUshort(it, st)),
            (st += 2),
            (ot.usMaxContext = at.readUshort(it, st)),
            (st += 2)
          );
        }),
        (et["OS/2"].version5 = function (it, st, ot) {
          var at = et._bin;
          return (
            (st = et["OS/2"].version2(it, st, ot)),
            (ot.usLowerOpticalPointSize = at.readUshort(it, st)),
            (st += 2),
            (ot.usUpperOpticalPointSize = at.readUshort(it, st)),
            (st += 2)
          );
        }),
        (et.post = {}),
        (et.post.parse = function (it, st, ot) {
          var at = et._bin,
            lt = {};
          return (
            (lt.version = at.readFixed(it, st)),
            (st += 4),
            (lt.italicAngle = at.readFixed(it, st)),
            (st += 4),
            (lt.underlinePosition = at.readShort(it, st)),
            (st += 2),
            (lt.underlineThickness = at.readShort(it, st)),
            (st += 2),
            lt
          );
        }),
        et == null && (et = {}),
        et.U == null && (et.U = {}),
        (et.U.codeToGlyph = function (it, st) {
          var ot = it.cmap,
            at = -1;
          if (
            (ot.p0e4 != null
              ? (at = ot.p0e4)
              : ot.p3e1 != null
              ? (at = ot.p3e1)
              : ot.p1e0 != null
              ? (at = ot.p1e0)
              : ot.p0e3 != null && (at = ot.p0e3),
            at == -1)
          )
            throw "no familiar platform and encoding!";
          var lt = ot.tables[at];
          if (lt.format == 0) return st >= lt.map.length ? 0 : lt.map[st];
          if (lt.format == 4) {
            for (var ct = -1, ut = 0; ut < lt.endCount.length; ut++)
              if (st <= lt.endCount[ut]) {
                ct = ut;
                break;
              }
            return ct == -1 || lt.startCount[ct] > st
              ? 0
              : 65535 &
                  (lt.idRangeOffset[ct] != 0
                    ? lt.glyphIdArray[
                        st -
                          lt.startCount[ct] +
                          (lt.idRangeOffset[ct] >> 1) -
                          (lt.idRangeOffset.length - ct)
                      ]
                    : st + lt.idDelta[ct]);
          }
          if (lt.format == 12) {
            if (st > lt.groups[lt.groups.length - 1][1]) return 0;
            for (ut = 0; ut < lt.groups.length; ut++) {
              var ft = lt.groups[ut];
              if (ft[0] <= st && st <= ft[1]) return ft[2] + (st - ft[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + lt.format;
        }),
        (et.U.glyphToPath = function (it, st) {
          var ot = { cmds: [], crds: [] };
          if (it.SVG && it.SVG.entries[st]) {
            var at = it.SVG.entries[st];
            return at == null
              ? ot
              : (typeof at == "string" &&
                  ((at = et.SVG.toPath(at)), (it.SVG.entries[st] = at)),
                at);
          }
          if (it.CFF) {
            var lt = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: it.CFF.Private ? it.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              ct = it.CFF,
              ut = it.CFF.Private;
            if (ct.ROS) {
              for (var ft = 0; ct.FDSelect[ft + 2] <= st; ) ft += 2;
              ut = ct.FDArray[ct.FDSelect[ft + 1]].Private;
            }
            et.U._drawCFF(it.CFF.CharStrings[st], lt, ct, ut, ot);
          } else it.glyf && et.U._drawGlyf(st, it, ot);
          return ot;
        }),
        (et.U._drawGlyf = function (it, st, ot) {
          var at = st.glyf[it];
          at == null && (at = st.glyf[it] = et.glyf._parseGlyf(st, it)),
            at != null &&
              (at.noc > -1
                ? et.U._simpleGlyph(at, ot)
                : et.U._compoGlyph(at, st, ot));
        }),
        (et.U._simpleGlyph = function (it, st) {
          for (var ot = 0; ot < it.noc; ot++) {
            for (
              var at = ot == 0 ? 0 : it.endPts[ot - 1] + 1,
                lt = it.endPts[ot],
                ct = at;
              ct <= lt;
              ct++
            ) {
              var ut = ct == at ? lt : ct - 1,
                ft = ct == lt ? at : ct + 1,
                ht = 1 & it.flags[ct],
                mt = 1 & it.flags[ut],
                vt = 1 & it.flags[ft],
                yt = it.xs[ct],
                Et = it.ys[ct];
              if (ct == at)
                if (ht) {
                  if (!mt) {
                    et.U.P.moveTo(st, yt, Et);
                    continue;
                  }
                  et.U.P.moveTo(st, it.xs[ut], it.ys[ut]);
                } else
                  mt
                    ? et.U.P.moveTo(st, it.xs[ut], it.ys[ut])
                    : et.U.P.moveTo(
                        st,
                        (it.xs[ut] + yt) / 2,
                        (it.ys[ut] + Et) / 2
                      );
              ht
                ? mt && et.U.P.lineTo(st, yt, Et)
                : vt
                ? et.U.P.qcurveTo(st, yt, Et, it.xs[ft], it.ys[ft])
                : et.U.P.qcurveTo(
                    st,
                    yt,
                    Et,
                    (yt + it.xs[ft]) / 2,
                    (Et + it.ys[ft]) / 2
                  );
            }
            et.U.P.closePath(st);
          }
        }),
        (et.U._compoGlyph = function (it, st, ot) {
          for (var at = 0; at < it.parts.length; at++) {
            var lt = { cmds: [], crds: [] },
              ct = it.parts[at];
            et.U._drawGlyf(ct.glyphIndex, st, lt);
            for (var ut = ct.m, ft = 0; ft < lt.crds.length; ft += 2) {
              var ht = lt.crds[ft],
                mt = lt.crds[ft + 1];
              ot.crds.push(ht * ut.a + mt * ut.b + ut.tx),
                ot.crds.push(ht * ut.c + mt * ut.d + ut.ty);
            }
            for (ft = 0; ft < lt.cmds.length; ft++) ot.cmds.push(lt.cmds[ft]);
          }
        }),
        (et.U._getGlyphClass = function (it, st) {
          var ot = et._lctf.getInterval(st, it);
          return ot == -1 ? 0 : st[ot + 2];
        }),
        (et.U.getPairAdjustment = function (it, st, ot) {
          var at = !1;
          if (it.GPOS)
            for (
              var lt = it.GPOS,
                ct = lt.lookupList,
                ut = lt.featureList,
                ft = [],
                ht = 0;
              ht < ut.length;
              ht++
            ) {
              var mt = ut[ht];
              if (mt.tag == "kern") {
                at = !0;
                for (var vt = 0; vt < mt.tab.length; vt++)
                  if (!ft[mt.tab[vt]]) {
                    ft[mt.tab[vt]] = !0;
                    for (
                      var yt = ct[mt.tab[vt]], Et = 0;
                      Et < yt.tabs.length;
                      Et++
                    )
                      if (yt.tabs[Et] != null) {
                        var pt,
                          xt = yt.tabs[Et];
                        if (
                          (!xt.coverage ||
                            (pt = et._lctf.coverageIndex(xt.coverage, st)) !=
                              -1) &&
                          yt.ltype != 1
                        ) {
                          if (yt.ltype == 2) {
                            var St = null;
                            if (xt.fmt == 1) {
                              var At = xt.pairsets[pt];
                              for (ht = 0; ht < At.length; ht++)
                                At[ht].gid2 == ot && (St = At[ht]);
                            } else if (xt.fmt == 2) {
                              var Ct = et.U._getGlyphClass(st, xt.classDef1),
                                Mt = et.U._getGlyphClass(ot, xt.classDef2);
                              St = xt.matrix[Ct][Mt];
                            }
                            if (St) {
                              var wt = 0;
                              return (
                                St.val1 && St.val1[2] && (wt += St.val1[2]),
                                St.val2 && St.val2[0] && (wt += St.val2[0]),
                                wt
                              );
                            }
                          }
                        }
                      }
                  }
              }
            }
          if (it.kern && !at) {
            var Bt = it.kern.glyph1.indexOf(st);
            if (Bt != -1) {
              var It = it.kern.rval[Bt].glyph2.indexOf(ot);
              if (It != -1) return it.kern.rval[Bt].vals[It];
            }
          }
          return 0;
        }),
        (et.U._applySubs = function (it, st, ot, at) {
          for (var lt = it.length - st - 1, ct = 0; ct < ot.tabs.length; ct++)
            if (ot.tabs[ct] != null) {
              var ut,
                ft = ot.tabs[ct];
              if (
                !ft.coverage ||
                (ut = et._lctf.coverageIndex(ft.coverage, it[st])) != -1
              ) {
                if (ot.ltype == 1)
                  it[st],
                    ft.fmt == 1
                      ? (it[st] = it[st] + ft.delta)
                      : (it[st] = ft.newg[ut]);
                else if (ot.ltype == 4)
                  for (var ht = ft.vals[ut], mt = 0; mt < ht.length; mt++) {
                    var vt = ht[mt],
                      yt = vt.chain.length;
                    if (!(yt > lt)) {
                      for (var Et = !0, pt = 0, xt = 0; xt < yt; xt++) {
                        for (; it[st + pt + (1 + xt)] == -1; ) pt++;
                        vt.chain[xt] != it[st + pt + (1 + xt)] && (Et = !1);
                      }
                      if (Et) {
                        for (it[st] = vt.nglyph, xt = 0; xt < yt + pt; xt++)
                          it[st + xt + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (ot.ltype == 5 && ft.fmt == 2)
                  for (
                    var St = et._lctf.getInterval(ft.cDef, it[st]),
                      At = ft.cDef[St + 2],
                      Ct = ft.scset[At],
                      Mt = 0;
                    Mt < Ct.length;
                    Mt++
                  ) {
                    var wt = Ct[Mt],
                      Bt = wt.input;
                    if (!(Bt.length > lt)) {
                      for (Et = !0, xt = 0; xt < Bt.length; xt++) {
                        var It = et._lctf.getInterval(ft.cDef, it[st + 1 + xt]);
                        if (St == -1 && ft.cDef[It + 2] != Bt[xt]) {
                          Et = !1;
                          break;
                        }
                      }
                      if (Et) {
                        var Ft = wt.substLookupRecords;
                        for (mt = 0; mt < Ft.length; mt += 2)
                          Ft[mt], Ft[mt + 1];
                      }
                    }
                  }
                else if (ot.ltype == 6 && ft.fmt == 3) {
                  if (
                    !et.U._glsCovered(it, ft.backCvg, st - ft.backCvg.length) ||
                    !et.U._glsCovered(it, ft.inptCvg, st) ||
                    !et.U._glsCovered(it, ft.ahedCvg, st + ft.inptCvg.length)
                  )
                    continue;
                  var Vt = ft.lookupRec;
                  for (Mt = 0; Mt < Vt.length; Mt += 2) {
                    St = Vt[Mt];
                    var $t = at[Vt[Mt + 1]];
                    et.U._applySubs(it, st + St, $t, at);
                  }
                }
              }
            }
        }),
        (et.U._glsCovered = function (it, st, ot) {
          for (var at = 0; at < st.length; at++)
            if (et._lctf.coverageIndex(st[at], it[ot + at]) == -1) return !1;
          return !0;
        }),
        (et.U.glyphsToPath = function (it, st, ot) {
          for (
            var at = { cmds: [], crds: [] }, lt = 0, ct = 0;
            ct < st.length;
            ct++
          ) {
            var ut = st[ct];
            if (ut != -1) {
              for (
                var ft =
                    ct < st.length - 1 && st[ct + 1] != -1 ? st[ct + 1] : 0,
                  ht = et.U.glyphToPath(it, ut),
                  mt = 0;
                mt < ht.crds.length;
                mt += 2
              )
                at.crds.push(ht.crds[mt] + lt), at.crds.push(ht.crds[mt + 1]);
              for (ot && at.cmds.push(ot), mt = 0; mt < ht.cmds.length; mt++)
                at.cmds.push(ht.cmds[mt]);
              ot && at.cmds.push("X"),
                (lt += it.hmtx.aWidth[ut]),
                ct < st.length - 1 &&
                  (lt += et.U.getPairAdjustment(it, ut, ft));
            }
          }
          return at;
        }),
        (et.U.P = {}),
        (et.U.P.moveTo = function (it, st, ot) {
          it.cmds.push("M"), it.crds.push(st, ot);
        }),
        (et.U.P.lineTo = function (it, st, ot) {
          it.cmds.push("L"), it.crds.push(st, ot);
        }),
        (et.U.P.curveTo = function (it, st, ot, at, lt, ct, ut) {
          it.cmds.push("C"), it.crds.push(st, ot, at, lt, ct, ut);
        }),
        (et.U.P.qcurveTo = function (it, st, ot, at, lt) {
          it.cmds.push("Q"), it.crds.push(st, ot, at, lt);
        }),
        (et.U.P.closePath = function (it) {
          it.cmds.push("Z");
        }),
        (et.U._drawCFF = function (it, st, ot, at, lt) {
          for (
            var ct = st.stack,
              ut = st.nStems,
              ft = st.haveWidth,
              ht = st.width,
              mt = st.open,
              vt = 0,
              yt = st.x,
              Et = st.y,
              pt = 0,
              xt = 0,
              St = 0,
              At = 0,
              Ct = 0,
              Mt = 0,
              wt = 0,
              Bt = 0,
              It = 0,
              Ft = 0,
              Vt = { val: 0, size: 0 };
            vt < it.length;

          ) {
            et.CFF.getCharString(it, vt, Vt);
            var $t = Vt.val;
            if (((vt += Vt.size), $t == "o1" || $t == "o18"))
              ct.length % 2 != 0 && !ft && (ht = ct.shift() + at.nominalWidthX),
                (ut += ct.length >> 1),
                (ct.length = 0),
                (ft = !0);
            else if ($t == "o3" || $t == "o23")
              ct.length % 2 != 0 && !ft && (ht = ct.shift() + at.nominalWidthX),
                (ut += ct.length >> 1),
                (ct.length = 0),
                (ft = !0);
            else if ($t == "o4")
              ct.length > 1 &&
                !ft &&
                ((ht = ct.shift() + at.nominalWidthX), (ft = !0)),
                mt && et.U.P.closePath(lt),
                (Et += ct.pop()),
                et.U.P.moveTo(lt, yt, Et),
                (mt = !0);
            else if ($t == "o5")
              for (; ct.length > 0; )
                (yt += ct.shift()),
                  (Et += ct.shift()),
                  et.U.P.lineTo(lt, yt, Et);
            else if ($t == "o6" || $t == "o7")
              for (var Kt = ct.length, Ht = $t == "o6", Wt = 0; Wt < Kt; Wt++) {
                var kt = ct.shift();
                Ht ? (yt += kt) : (Et += kt),
                  (Ht = !Ht),
                  et.U.P.lineTo(lt, yt, Et);
              }
            else if ($t == "o8" || $t == "o24") {
              Kt = ct.length;
              for (var Gt = 0; Gt + 6 <= Kt; )
                (pt = yt + ct.shift()),
                  (xt = Et + ct.shift()),
                  (St = pt + ct.shift()),
                  (At = xt + ct.shift()),
                  (yt = St + ct.shift()),
                  (Et = At + ct.shift()),
                  et.U.P.curveTo(lt, pt, xt, St, At, yt, Et),
                  (Gt += 6);
              $t == "o24" &&
                ((yt += ct.shift()),
                (Et += ct.shift()),
                et.U.P.lineTo(lt, yt, Et));
            } else {
              if ($t == "o11") break;
              if (
                $t == "o1234" ||
                $t == "o1235" ||
                $t == "o1236" ||
                $t == "o1237"
              )
                $t == "o1234" &&
                  ((xt = Et),
                  (St = (pt = yt + ct.shift()) + ct.shift()),
                  (Ft = At = xt + ct.shift()),
                  (Mt = At),
                  (Bt = Et),
                  (yt =
                    (wt =
                      (Ct = (It = St + ct.shift()) + ct.shift()) + ct.shift()) +
                    ct.shift()),
                  et.U.P.curveTo(lt, pt, xt, St, At, It, Ft),
                  et.U.P.curveTo(lt, Ct, Mt, wt, Bt, yt, Et)),
                  $t == "o1235" &&
                    ((pt = yt + ct.shift()),
                    (xt = Et + ct.shift()),
                    (St = pt + ct.shift()),
                    (At = xt + ct.shift()),
                    (It = St + ct.shift()),
                    (Ft = At + ct.shift()),
                    (Ct = It + ct.shift()),
                    (Mt = Ft + ct.shift()),
                    (wt = Ct + ct.shift()),
                    (Bt = Mt + ct.shift()),
                    (yt = wt + ct.shift()),
                    (Et = Bt + ct.shift()),
                    ct.shift(),
                    et.U.P.curveTo(lt, pt, xt, St, At, It, Ft),
                    et.U.P.curveTo(lt, Ct, Mt, wt, Bt, yt, Et)),
                  $t == "o1236" &&
                    ((pt = yt + ct.shift()),
                    (xt = Et + ct.shift()),
                    (St = pt + ct.shift()),
                    (Ft = At = xt + ct.shift()),
                    (Mt = At),
                    (wt =
                      (Ct = (It = St + ct.shift()) + ct.shift()) + ct.shift()),
                    (Bt = Mt + ct.shift()),
                    (yt = wt + ct.shift()),
                    et.U.P.curveTo(lt, pt, xt, St, At, It, Ft),
                    et.U.P.curveTo(lt, Ct, Mt, wt, Bt, yt, Et)),
                  $t == "o1237" &&
                    ((pt = yt + ct.shift()),
                    (xt = Et + ct.shift()),
                    (St = pt + ct.shift()),
                    (At = xt + ct.shift()),
                    (It = St + ct.shift()),
                    (Ft = At + ct.shift()),
                    (Ct = It + ct.shift()),
                    (Mt = Ft + ct.shift()),
                    (wt = Ct + ct.shift()),
                    (Bt = Mt + ct.shift()),
                    Math.abs(wt - yt) > Math.abs(Bt - Et)
                      ? (yt = wt + ct.shift())
                      : (Et = Bt + ct.shift()),
                    et.U.P.curveTo(lt, pt, xt, St, At, It, Ft),
                    et.U.P.curveTo(lt, Ct, Mt, wt, Bt, yt, Et));
              else if ($t == "o14") {
                if (
                  (ct.length > 0 &&
                    !ft &&
                    ((ht = ct.shift() + ot.nominalWidthX), (ft = !0)),
                  ct.length == 4)
                ) {
                  var Pt = ct.shift(),
                    Rt = ct.shift(),
                    Nt = ct.shift(),
                    Dt = ct.shift(),
                    zt = et.CFF.glyphBySE(ot, Nt),
                    Yt = et.CFF.glyphBySE(ot, Dt);
                  et.U._drawCFF(ot.CharStrings[zt], st, ot, at, lt),
                    (st.x = Pt),
                    (st.y = Rt),
                    et.U._drawCFF(ot.CharStrings[Yt], st, ot, at, lt);
                }
                mt && (et.U.P.closePath(lt), (mt = !1));
              } else if ($t == "o19" || $t == "o20")
                ct.length % 2 != 0 &&
                  !ft &&
                  (ht = ct.shift() + at.nominalWidthX),
                  (ut += ct.length >> 1),
                  (ct.length = 0),
                  (ft = !0),
                  (vt += (ut + 7) >> 3);
              else if ($t == "o21")
                ct.length > 2 &&
                  !ft &&
                  ((ht = ct.shift() + at.nominalWidthX), (ft = !0)),
                  (Et += ct.pop()),
                  (yt += ct.pop()),
                  mt && et.U.P.closePath(lt),
                  et.U.P.moveTo(lt, yt, Et),
                  (mt = !0);
              else if ($t == "o22")
                ct.length > 1 &&
                  !ft &&
                  ((ht = ct.shift() + at.nominalWidthX), (ft = !0)),
                  (yt += ct.pop()),
                  mt && et.U.P.closePath(lt),
                  et.U.P.moveTo(lt, yt, Et),
                  (mt = !0);
              else if ($t == "o25") {
                for (; ct.length > 6; )
                  (yt += ct.shift()),
                    (Et += ct.shift()),
                    et.U.P.lineTo(lt, yt, Et);
                (pt = yt + ct.shift()),
                  (xt = Et + ct.shift()),
                  (St = pt + ct.shift()),
                  (At = xt + ct.shift()),
                  (yt = St + ct.shift()),
                  (Et = At + ct.shift()),
                  et.U.P.curveTo(lt, pt, xt, St, At, yt, Et);
              } else if ($t == "o26")
                for (ct.length % 2 && (yt += ct.shift()); ct.length > 0; )
                  (pt = yt),
                    (xt = Et + ct.shift()),
                    (yt = St = pt + ct.shift()),
                    (Et = (At = xt + ct.shift()) + ct.shift()),
                    et.U.P.curveTo(lt, pt, xt, St, At, yt, Et);
              else if ($t == "o27")
                for (ct.length % 2 && (Et += ct.shift()); ct.length > 0; )
                  (xt = Et),
                    (St = (pt = yt + ct.shift()) + ct.shift()),
                    (At = xt + ct.shift()),
                    (yt = St + ct.shift()),
                    (Et = At),
                    et.U.P.curveTo(lt, pt, xt, St, At, yt, Et);
              else if ($t == "o10" || $t == "o29") {
                var qt = $t == "o10" ? at : ot;
                if (ct.length == 0) console.debug("error: empty stack");
                else {
                  var Zt = ct.pop(),
                    Jt = qt.Subrs[Zt + qt.Bias];
                  (st.x = yt),
                    (st.y = Et),
                    (st.nStems = ut),
                    (st.haveWidth = ft),
                    (st.width = ht),
                    (st.open = mt),
                    et.U._drawCFF(Jt, st, ot, at, lt),
                    (yt = st.x),
                    (Et = st.y),
                    (ut = st.nStems),
                    (ft = st.haveWidth),
                    (ht = st.width),
                    (mt = st.open);
                }
              } else if ($t == "o30" || $t == "o31") {
                var mn = ct.length,
                  ln = ((Gt = 0), $t == "o31");
                for (Gt += mn - (Kt = -3 & mn); Gt < Kt; )
                  ln
                    ? ((xt = Et),
                      (St = (pt = yt + ct.shift()) + ct.shift()),
                      (Et = (At = xt + ct.shift()) + ct.shift()),
                      Kt - Gt == 5 ? ((yt = St + ct.shift()), Gt++) : (yt = St),
                      (ln = !1))
                    : ((pt = yt),
                      (xt = Et + ct.shift()),
                      (St = pt + ct.shift()),
                      (At = xt + ct.shift()),
                      (yt = St + ct.shift()),
                      Kt - Gt == 5 ? ((Et = At + ct.shift()), Gt++) : (Et = At),
                      (ln = !0)),
                    et.U.P.curveTo(lt, pt, xt, St, At, yt, Et),
                    (Gt += 4);
              } else {
                if (($t + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + $t, it), $t);
                ct.push($t);
              }
            }
          }
          (st.x = yt),
            (st.y = Et),
            (st.nStems = ut),
            (st.haveWidth = ft),
            (st.width = ht),
            (st.open = mt);
        });
      var nt = et,
        rt = { Typr: nt };
      return (
        (tt.Typr = nt),
        (tt.default = rt),
        Object.defineProperty(tt, "__esModule", { value: !0 }),
        tt
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function woff2otfFactory() {
  return (function (tt) {
    var et = Uint8Array,
      nt = Uint16Array,
      rt = Uint32Array,
      it = new et([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      st = new et([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      ot = new et([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      at = function ($t, Kt) {
        for (var Ht = new nt(31), Wt = 0; Wt < 31; ++Wt)
          Ht[Wt] = Kt += 1 << $t[Wt - 1];
        var kt = new rt(Ht[30]);
        for (Wt = 1; Wt < 30; ++Wt)
          for (var Gt = Ht[Wt]; Gt < Ht[Wt + 1]; ++Gt)
            kt[Gt] = ((Gt - Ht[Wt]) << 5) | Wt;
        return [Ht, kt];
      },
      lt = at(it, 2),
      ct = lt[0],
      ut = lt[1];
    (ct[28] = 258), (ut[258] = 28);
    for (var ft = at(st, 0)[0], ht = new nt(32768), mt = 0; mt < 32768; ++mt) {
      var vt = ((43690 & mt) >>> 1) | ((21845 & mt) << 1);
      (vt =
        ((61680 & (vt = ((52428 & vt) >>> 2) | ((13107 & vt) << 2))) >>> 4) |
        ((3855 & vt) << 4)),
        (ht[mt] = (((65280 & vt) >>> 8) | ((255 & vt) << 8)) >>> 1);
    }
    var yt = function ($t, Kt, Ht) {
        for (var Wt = $t.length, kt = 0, Gt = new nt(Kt); kt < Wt; ++kt)
          ++Gt[$t[kt] - 1];
        var Pt,
          Rt = new nt(Kt);
        for (kt = 0; kt < Kt; ++kt) Rt[kt] = (Rt[kt - 1] + Gt[kt - 1]) << 1;
        if (Ht) {
          Pt = new nt(1 << Kt);
          var Nt = 15 - Kt;
          for (kt = 0; kt < Wt; ++kt)
            if ($t[kt])
              for (
                var Dt = (kt << 4) | $t[kt],
                  zt = Kt - $t[kt],
                  Yt = Rt[$t[kt] - 1]++ << zt,
                  qt = Yt | ((1 << zt) - 1);
                Yt <= qt;
                ++Yt
              )
                Pt[ht[Yt] >>> Nt] = Dt;
        } else
          for (Pt = new nt(Wt), kt = 0; kt < Wt; ++kt)
            $t[kt] && (Pt[kt] = ht[Rt[$t[kt] - 1]++] >>> (15 - $t[kt]));
        return Pt;
      },
      Et = new et(288);
    for (mt = 0; mt < 144; ++mt) Et[mt] = 8;
    for (mt = 144; mt < 256; ++mt) Et[mt] = 9;
    for (mt = 256; mt < 280; ++mt) Et[mt] = 7;
    for (mt = 280; mt < 288; ++mt) Et[mt] = 8;
    var pt = new et(32);
    for (mt = 0; mt < 32; ++mt) pt[mt] = 5;
    var xt = yt(Et, 9, 1),
      St = yt(pt, 5, 1),
      At = function ($t) {
        for (var Kt = $t[0], Ht = 1; Ht < $t.length; ++Ht)
          $t[Ht] > Kt && (Kt = $t[Ht]);
        return Kt;
      },
      Ct = function ($t, Kt, Ht) {
        var Wt = (Kt / 8) | 0;
        return (($t[Wt] | ($t[Wt + 1] << 8)) >> (7 & Kt)) & Ht;
      },
      Mt = function ($t, Kt) {
        var Ht = (Kt / 8) | 0;
        return ($t[Ht] | ($t[Ht + 1] << 8) | ($t[Ht + 2] << 16)) >> (7 & Kt);
      },
      wt = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      Bt = function ($t, Kt, Ht) {
        var Wt = new Error(Kt || wt[$t]);
        if (
          ((Wt.code = $t),
          Error.captureStackTrace && Error.captureStackTrace(Wt, Bt),
          !Ht)
        )
          throw Wt;
        return Wt;
      },
      It = function ($t, Kt, Ht) {
        var Wt = $t.length;
        if (!Wt || (Ht && !Ht.l && Wt < 5)) return Kt || new et(0);
        var kt = !Kt || Ht,
          Gt = !Ht || Ht.i;
        Ht || (Ht = {}), Kt || (Kt = new et(3 * Wt));
        var Pt,
          Rt = function (qn) {
            var dn = Kt.length;
            if (qn > dn) {
              var Pn = new et(Math.max(2 * dn, qn));
              Pn.set(Kt), (Kt = Pn);
            }
          },
          Nt = Ht.f || 0,
          Dt = Ht.p || 0,
          zt = Ht.b || 0,
          Yt = Ht.l,
          qt = Ht.d,
          Zt = Ht.m,
          Jt = Ht.n,
          mn = 8 * Wt;
        do {
          if (!Yt) {
            Ht.f = Nt = Ct($t, Dt, 1);
            var ln = Ct($t, Dt + 1, 3);
            if (((Dt += 3), !ln)) {
              var bn =
                  $t[(Tn = (((Pt = Dt) / 8) | 0) + (7 & Pt && 1) + 4) - 4] |
                  ($t[Tn - 3] << 8),
                Bn = Tn + bn;
              if (Bn > Wt) {
                Gt && Bt(0);
                break;
              }
              kt && Rt(zt + bn),
                Kt.set($t.subarray(Tn, Bn), zt),
                (Ht.b = zt += bn),
                (Ht.p = Dt = 8 * Bn);
              continue;
            }
            if (ln == 1) (Yt = xt), (qt = St), (Zt = 9), (Jt = 5);
            else if (ln == 2) {
              var gn = Ct($t, Dt, 31) + 257,
                jt = Ct($t, Dt + 10, 15) + 4,
                yn = gn + Ct($t, Dt + 5, 31) + 1;
              Dt += 14;
              for (var pn = new et(yn), vn = new et(19), xn = 0; xn < jt; ++xn)
                vn[ot[xn]] = Ct($t, Dt + 3 * xn, 7);
              Dt += 3 * jt;
              var Fn = At(vn),
                _n = (1 << Fn) - 1,
                Dn = yt(vn, Fn, 1);
              for (xn = 0; xn < yn; ) {
                var Tn,
                  An = Dn[Ct($t, Dt, _n)];
                if (((Dt += 15 & An), (Tn = An >>> 4) < 16)) pn[xn++] = Tn;
                else {
                  var Wn = 0,
                    Xt = 0;
                  for (
                    Tn == 16
                      ? ((Xt = 3 + Ct($t, Dt, 3)), (Dt += 2), (Wn = pn[xn - 1]))
                      : Tn == 17
                      ? ((Xt = 3 + Ct($t, Dt, 7)), (Dt += 3))
                      : Tn == 18 && ((Xt = 11 + Ct($t, Dt, 127)), (Dt += 7));
                    Xt--;

                  )
                    pn[xn++] = Wn;
                }
              }
              var Ut = pn.subarray(0, gn),
                hn = pn.subarray(gn);
              (Zt = At(Ut)),
                (Jt = At(hn)),
                (Yt = yt(Ut, Zt, 1)),
                (qt = yt(hn, Jt, 1));
            } else Bt(1);
            if (Dt > mn) {
              Gt && Bt(0);
              break;
            }
          }
          kt && Rt(zt + 131072);
          for (var Ln = (1 << Zt) - 1, Cn = (1 << Jt) - 1, Mn = Dt; ; Mn = Dt) {
            var kn = (Wn = Yt[Mt($t, Dt) & Ln]) >>> 4;
            if ((Dt += 15 & Wn) > mn) {
              Gt && Bt(0);
              break;
            }
            if ((Wn || Bt(2), kn < 256)) Kt[zt++] = kn;
            else {
              if (kn == 256) {
                (Mn = Dt), (Yt = null);
                break;
              }
              var Vn = kn - 254;
              if (kn > 264) {
                var Kn = it[(xn = kn - 257)];
                (Vn = Ct($t, Dt, (1 << Kn) - 1) + ct[xn]), (Dt += Kn);
              }
              var Yn = qt[Mt($t, Dt) & Cn],
                ir = Yn >>> 4;
              if (
                (Yn || Bt(3),
                (Dt += 15 & Yn),
                (hn = ft[ir]),
                ir > 3 &&
                  ((Kn = st[ir]),
                  (hn += Mt($t, Dt) & ((1 << Kn) - 1)),
                  (Dt += Kn)),
                Dt > mn)
              ) {
                Gt && Bt(0);
                break;
              }
              kt && Rt(zt + 131072);
              for (var On = zt + Vn; zt < On; zt += 4)
                (Kt[zt] = Kt[zt - hn]),
                  (Kt[zt + 1] = Kt[zt + 1 - hn]),
                  (Kt[zt + 2] = Kt[zt + 2 - hn]),
                  (Kt[zt + 3] = Kt[zt + 3 - hn]);
              zt = On;
            }
          }
          (Ht.l = Yt),
            (Ht.p = Mn),
            (Ht.b = zt),
            Yt && ((Nt = 1), (Ht.m = Zt), (Ht.d = qt), (Ht.n = Jt));
        } while (!Nt);
        return zt == Kt.length
          ? Kt
          : (function (qn, dn, Pn) {
              (dn == null || dn < 0) && (dn = 0),
                (Pn == null || Pn > qn.length) && (Pn = qn.length);
              var Hn = new (qn instanceof nt ? nt : qn instanceof rt ? rt : et)(
                Pn - dn
              );
              return Hn.set(qn.subarray(dn, Pn)), Hn;
            })(Kt, 0, zt);
      },
      Ft = new et(0),
      Vt = typeof TextDecoder < "u" && new TextDecoder();
    try {
      Vt.decode(Ft, { stream: !0 });
    } catch {}
    return (
      (tt.convert_streams = function ($t) {
        var Kt = new DataView($t),
          Ht = 0;
        function Wt() {
          var gn = Kt.getUint16(Ht);
          return (Ht += 2), gn;
        }
        function kt() {
          var gn = Kt.getUint32(Ht);
          return (Ht += 4), gn;
        }
        function Gt(gn) {
          bn.setUint16(Bn, gn), (Bn += 2);
        }
        function Pt(gn) {
          bn.setUint32(Bn, gn), (Bn += 4);
        }
        for (
          var Rt = {
              signature: kt(),
              flavor: kt(),
              length: kt(),
              numTables: Wt(),
              reserved: Wt(),
              totalSfntSize: kt(),
              majorVersion: Wt(),
              minorVersion: Wt(),
              metaOffset: kt(),
              metaLength: kt(),
              metaOrigLength: kt(),
              privOffset: kt(),
              privLength: kt(),
            },
            Nt = 0;
          Math.pow(2, Nt) <= Rt.numTables;

        )
          Nt++;
        Nt--;
        for (
          var Dt = 16 * Math.pow(2, Nt),
            zt = 16 * Rt.numTables - Dt,
            Yt = 12,
            qt = [],
            Zt = 0;
          Zt < Rt.numTables;
          Zt++
        )
          qt.push({
            tag: kt(),
            offset: kt(),
            compLength: kt(),
            origLength: kt(),
            origChecksum: kt(),
          }),
            (Yt += 16);
        var Jt,
          mn = new Uint8Array(
            12 +
              16 * qt.length +
              qt.reduce(function (gn, jt) {
                return gn + jt.origLength + 4;
              }, 0)
          ),
          ln = mn.buffer,
          bn = new DataView(ln),
          Bn = 0;
        return (
          Pt(Rt.flavor),
          Gt(Rt.numTables),
          Gt(Dt),
          Gt(Nt),
          Gt(zt),
          qt.forEach(function (gn) {
            Pt(gn.tag),
              Pt(gn.origChecksum),
              Pt(Yt),
              Pt(gn.origLength),
              (gn.outOffset = Yt),
              (Yt += gn.origLength) % 4 != 0 && (Yt += 4 - (Yt % 4));
          }),
          qt.forEach(function (gn) {
            var jt,
              yn = $t.slice(gn.offset, gn.offset + gn.compLength);
            if (gn.compLength != gn.origLength) {
              var pn = new Uint8Array(gn.origLength);
              (jt = new Uint8Array(yn, 2)), It(jt, pn);
            } else pn = new Uint8Array(yn);
            mn.set(pn, gn.outOffset);
            var vn = 0;
            (Yt = gn.outOffset + gn.origLength) % 4 != 0 && (vn = 4 - (Yt % 4)),
              mn.set(new Uint8Array(vn).buffer, gn.outOffset + gn.origLength),
              (Jt = Yt + vn);
          }),
          ln.slice(0, Jt)
        );
      }),
      Object.defineProperty(tt, "__esModule", { value: !0 }),
      tt
    );
  })({}).convert_streams;
}
function parserFactory(tt, et) {
  const nt = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    rt = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    it = 1,
    st = 2,
    ot = 4,
    at = 8,
    lt = 16,
    ct = 32;
  let ut;
  function ft(Ct) {
    if (!ut) {
      const Mt = { R: st, L: it, D: ot, C: lt, U: ct, T: at };
      ut = new Map();
      for (let wt in rt) {
        let Bt = 0;
        rt[wt].split(",").forEach((It) => {
          let [Ft, Vt] = It.split("+");
          (Ft = parseInt(Ft, 36)),
            (Vt = Vt ? parseInt(Vt, 36) : 0),
            ut.set((Bt += Ft), Mt[wt]);
          for (let $t = Vt; $t--; ) ut.set(++Bt, Mt[wt]);
        });
      }
    }
    return ut.get(Ct) || ct;
  }
  const ht = 1,
    mt = 2,
    vt = 3,
    yt = 4,
    Et = [null, "isol", "init", "fina", "medi"];
  function pt(Ct) {
    const Mt = new Uint8Array(Ct.length);
    let wt = ct,
      Bt = ht,
      It = -1;
    for (let Ft = 0; Ft < Ct.length; Ft++) {
      const Vt = Ct.codePointAt(Ft);
      let $t = ft(Vt) | 0,
        Kt = ht;
      $t & at ||
        (wt & (it | ot | lt)
          ? $t & (st | ot | lt)
            ? ((Kt = vt), (Bt === ht || Bt === vt) && Mt[It]++)
            : $t & (it | ct) && (Bt === mt || Bt === yt) && Mt[It]--
          : wt & (st | ct) && (Bt === mt || Bt === yt) && Mt[It]--,
        (Bt = Mt[Ft] = Kt),
        (wt = $t),
        (It = Ft),
        Vt > 65535 && Ft++);
    }
    return Mt;
  }
  function xt(Ct, Mt) {
    const wt = [];
    for (let It = 0; It < Mt.length; It++) {
      const Ft = Mt.codePointAt(It);
      Ft > 65535 && It++, wt.push(tt.U.codeToGlyph(Ct, Ft));
    }
    const Bt = Ct.GSUB;
    if (Bt) {
      const { lookupList: It, featureList: Ft } = Bt;
      let Vt;
      const $t = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/,
        Kt = [];
      Ft.forEach((Ht) => {
        if ($t.test(Ht.tag))
          for (let Wt = 0; Wt < Ht.tab.length; Wt++) {
            if (Kt[Ht.tab[Wt]]) continue;
            Kt[Ht.tab[Wt]] = !0;
            const kt = It[Ht.tab[Wt]],
              Gt = /^(isol|init|fina|medi)$/.test(Ht.tag);
            Gt && !Vt && (Vt = pt(Mt));
            for (let Pt = 0; Pt < wt.length; Pt++)
              (!Vt || !Gt || Et[Vt[Pt]] === Ht.tag) &&
                tt.U._applySubs(wt, Pt, kt, It);
          }
      });
    }
    return wt;
  }
  function St(...Ct) {
    for (let Mt = 0; Mt < Ct.length; Mt++)
      if (typeof Ct[Mt] == "number") return Ct[Mt];
  }
  function At(Ct) {
    const Mt = Object.create(null),
      wt = Ct["OS/2"],
      Bt = Ct.hhea,
      It = Ct.head.unitsPerEm,
      Ft = St(wt && wt.sTypoAscender, Bt && Bt.ascender, It),
      Vt = {
        unitsPerEm: It,
        ascender: Ft,
        descender: St(wt && wt.sTypoDescender, Bt && Bt.descender, 0),
        capHeight: St(wt && wt.sCapHeight, Ft),
        xHeight: St(wt && wt.sxHeight, Ft),
        lineGap: St(wt && wt.sTypoLineGap, Bt && Bt.lineGap),
        forEachGlyph($t, Kt, Ht, Wt) {
          let kt = 0;
          const Gt = (1 / Vt.unitsPerEm) * Kt,
            Pt = xt(Ct, $t);
          let Rt = 0,
            Nt = -1;
          return (
            Pt.forEach((Dt, zt) => {
              if (Dt !== -1) {
                let Yt = Mt[Dt];
                if (!Yt) {
                  const { cmds: qt, crds: Zt } = tt.U.glyphToPath(Ct, Dt);
                  let Jt = "",
                    mn = 0;
                  for (let jt = 0, yn = qt.length; jt < yn; jt++) {
                    const pn = nt[qt[jt]];
                    Jt += qt[jt];
                    for (let vn = 1; vn <= pn; vn++)
                      Jt += (vn > 1 ? "," : "") + Zt[mn++];
                  }
                  let ln, bn, Bn, gn;
                  if (Zt.length) {
                    (ln = bn = 1 / 0), (Bn = gn = -1 / 0);
                    for (let jt = 0, yn = Zt.length; jt < yn; jt += 2) {
                      let pn = Zt[jt],
                        vn = Zt[jt + 1];
                      pn < ln && (ln = pn),
                        vn < bn && (bn = vn),
                        pn > Bn && (Bn = pn),
                        vn > gn && (gn = vn);
                    }
                  } else ln = Bn = bn = gn = 0;
                  Yt = Mt[Dt] = {
                    index: Dt,
                    advanceWidth: Ct.hmtx.aWidth[Dt],
                    xMin: ln,
                    yMin: bn,
                    xMax: Bn,
                    yMax: gn,
                    path: Jt,
                    pathCommandCount: qt.length,
                  };
                }
                Nt !== -1 && (kt += tt.U.getPairAdjustment(Ct, Nt, Dt) * Gt),
                  Wt.call(null, Yt, kt, Rt),
                  Yt.advanceWidth && (kt += Yt.advanceWidth * Gt),
                  Ht && (kt += Ht * Kt),
                  (Nt = Dt);
              }
              Rt += $t.codePointAt(Rt) > 65535 ? 2 : 1;
            }),
            kt
          );
        },
      };
    return Vt;
  }
  return function (Mt) {
    const wt = new Uint8Array(Mt, 0, 4),
      Bt = tt._bin.readASCII(wt, 0, 4);
    if (Bt === "wOFF") Mt = et(Mt);
    else if (Bt === "wOF2") throw new Error("woff2 fonts not supported");
    return At(tt.parse(Mt)[0]);
  };
}
const workerModule = defineWorkerModule({
    name: "Typr Font Parser",
    dependencies: [typrFactory, woff2otfFactory, parserFactory],
    init(tt, et, nt) {
      const rt = tt(),
        it = et();
      return nt(rt, it);
    },
  }),
  CONFIG = {
    defaultFontURL:
      "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  tempColor = new Color();
function now$1() {
  return (self.performance || Date).now();
}
const atlases = Object.create(null);
function getTextRenderInfo(tt, et) {
  tt = assign$1({}, tt);
  const nt = now$1();
  if (
    ((tt.font = toAbsoluteURL(tt.font || CONFIG.defaultFontURL)),
    (tt.text = "" + tt.text),
    (tt.sdfGlyphSize = tt.sdfGlyphSize || CONFIG.sdfGlyphSize),
    tt.colorRanges != null)
  ) {
    let ft = {};
    for (let ht in tt.colorRanges)
      if (tt.colorRanges.hasOwnProperty(ht)) {
        let mt = tt.colorRanges[ht];
        typeof mt != "number" && (mt = tempColor.set(mt).getHex()),
          (ft[ht] = mt);
      }
    tt.colorRanges = ft;
  }
  Object.freeze(tt);
  const { textureWidth: rt, sdfExponent: it } = CONFIG,
    { sdfGlyphSize: st } = tt,
    ot = (rt / st) * 4;
  let at = atlases[st];
  if (!at) {
    const ft = document.createElement("canvas");
    (ft.width = rt),
      (ft.height = (st * 256) / ot),
      (at = atlases[st] =
        {
          glyphCount: 0,
          sdfGlyphSize: st,
          sdfCanvas: ft,
          sdfTexture: new Texture(
            ft,
            void 0,
            void 0,
            void 0,
            LinearFilter,
            LinearFilter
          ),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (at.sdfTexture.generateMipmaps = !1),
      initContextLossHandling(at);
  }
  const { sdfTexture: lt, sdfCanvas: ct } = at;
  let ut = at.glyphsByFont.get(tt.font);
  ut || at.glyphsByFont.set(tt.font, (ut = new Map())),
    typesetInWorker(tt).then((ft) => {
      const {
          glyphIds: ht,
          glyphPositions: mt,
          fontSize: vt,
          unitsPerEm: yt,
          timings: Et,
        } = ft,
        pt = [],
        xt = new Float32Array(ht.length * 4),
        St = vt / yt;
      let At = 0,
        Ct = 0;
      const Mt = now$1();
      ht.forEach((Vt, $t) => {
        let Kt = ut.get(Vt);
        if (!Kt) {
          const { path: Gt, pathBounds: Pt } = ft.glyphData[Vt],
            Rt =
              (Math.max(Pt[2] - Pt[0], Pt[3] - Pt[1]) / st) *
              (CONFIG.sdfMargin * st + 0.5),
            Nt = at.glyphCount++,
            Dt = [Pt[0] - Rt, Pt[1] - Rt, Pt[2] + Rt, Pt[3] + Rt];
          ut.set(Vt, (Kt = { path: Gt, atlasIndex: Nt, sdfViewBox: Dt })),
            pt.push(Kt);
        }
        const { sdfViewBox: Ht } = Kt,
          Wt = mt[Ct++],
          kt = mt[Ct++];
        (xt[At++] = Wt + Ht[0] * St),
          (xt[At++] = kt + Ht[1] * St),
          (xt[At++] = Wt + Ht[2] * St),
          (xt[At++] = kt + Ht[3] * St),
          (ht[$t] = Kt.atlasIndex);
      }),
        (Et.quads = (Et.quads || 0) + (now$1() - Mt));
      const wt = now$1();
      Et.sdf = {};
      const Bt = ct.height,
        It = Math.ceil(at.glyphCount / ot),
        Ft = Math.pow(2, Math.ceil(Math.log2(It * st)));
      Ft > Bt &&
        (console.info(`Increasing SDF texture size ${Bt}->${Ft}`),
        resizeWebGLCanvasWithoutClearing(ct, rt, Ft),
        lt.dispose()),
        Promise.all(
          pt.map((Vt) =>
            generateGlyphSDF(Vt, at, tt.gpuAccelerateSDF).then(
              ({ timing: $t }) => {
                Et.sdf[Vt.atlasIndex] = $t;
              }
            )
          )
        ).then(() => {
          pt.length &&
            !at.contextLost &&
            (safariPre15Workaround(at), (lt.needsUpdate = !0)),
            (Et.sdfTotal = now$1() - wt),
            (Et.total = now$1() - nt),
            et(
              Object.freeze({
                parameters: tt,
                sdfTexture: lt,
                sdfGlyphSize: st,
                sdfExponent: it,
                glyphBounds: xt,
                glyphAtlasIndices: ht,
                glyphColors: ft.glyphColors,
                caretPositions: ft.caretPositions,
                caretHeight: ft.caretHeight,
                chunkedBounds: ft.chunkedBounds,
                ascender: ft.ascender,
                descender: ft.descender,
                lineHeight: ft.lineHeight,
                capHeight: ft.capHeight,
                xHeight: ft.xHeight,
                topBaseline: ft.topBaseline,
                blockBounds: ft.blockBounds,
                visibleBounds: ft.visibleBounds,
                timings: ft.timings,
              })
            );
        });
    }),
    Promise.resolve().then(() => {
      at.contextLost || warmUpSDFCanvas(ct);
    });
}
function generateGlyphSDF(
  { path: tt, atlasIndex: et, sdfViewBox: nt },
  { sdfGlyphSize: rt, sdfCanvas: it, contextLost: st },
  ot
) {
  if (st) return Promise.resolve({ timing: -1 });
  const { textureWidth: at, sdfExponent: lt } = CONFIG,
    ct = Math.max(nt[2] - nt[0], nt[3] - nt[1]),
    ut = Math.floor(et / 4),
    ft = (ut % (at / rt)) * rt,
    ht = Math.floor(ut / (at / rt)) * rt,
    mt = et % 4;
  return generateSDF(rt, rt, tt, nt, ct, lt, it, ft, ht, mt, ot);
}
function initContextLossHandling(tt) {
  const et = tt.sdfCanvas;
  et.addEventListener("webglcontextlost", (nt) => {
    console.log("Context Lost", nt), nt.preventDefault(), (tt.contextLost = !0);
  }),
    et.addEventListener("webglcontextrestored", (nt) => {
      console.log("Context Restored", nt), (tt.contextLost = !1);
      const rt = [];
      tt.glyphsByFont.forEach((it) => {
        it.forEach((st) => {
          rt.push(generateGlyphSDF(st, tt, !0));
        });
      }),
        Promise.all(rt).then(() => {
          safariPre15Workaround(tt), (tt.sdfTexture.needsUpdate = !0);
        });
    });
}
function preloadFont({ font: tt, characters: et, sdfGlyphSize: nt }, rt) {
  let it = Array.isArray(et)
    ? et.join(`
`)
    : "" + et;
  getTextRenderInfo({ font: tt, sdfGlyphSize: nt, text: it }, rt);
}
function assign$1(tt, et) {
  for (let nt in et) et.hasOwnProperty(nt) && (tt[nt] = et[nt]);
  return tt;
}
let linkEl;
function toAbsoluteURL(tt) {
  return (
    linkEl ||
      (linkEl = typeof document > "u" ? {} : document.createElement("a")),
    (linkEl.href = tt),
    linkEl.href
  );
}
function safariPre15Workaround(tt) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: et, sdfTexture: nt } = tt,
      { width: rt, height: it } = et,
      st = tt.sdfCanvas.getContext("webgl");
    let ot = nt.image.data;
    (!ot || ot.length !== rt * it * 4) &&
      ((ot = new Uint8Array(rt * it * 4)),
      (nt.image = { width: rt, height: it, data: ot }),
      (nt.flipY = !1),
      (nt.isDataTexture = !0)),
      st.readPixels(0, 0, rt, it, st.RGBA, st.UNSIGNED_BYTE, ot);
  }
}
const typesetterWorkerModule = defineWorkerModule({
    name: "Typesetter",
    dependencies: [CONFIG, workerModule, createTypesetter, bidiFactory],
    init(tt, et, nt, rt) {
      const { defaultFontURL: it } = tt;
      return nt(et, rt(), { defaultFontURL: it });
    },
  }),
  typesetInWorker = defineWorkerModule({
    name: "Typesetter",
    dependencies: [typesetterWorkerModule],
    init(tt) {
      return function (et) {
        return new Promise((nt) => {
          tt.typeset(et, nt);
        });
      };
    },
    getTransferables(tt) {
      const et = [tt.glyphPositions.buffer, tt.glyphIds.buffer];
      return (
        tt.caretPositions && et.push(tt.caretPositions.buffer),
        tt.glyphColors && et.push(tt.glyphColors.buffer),
        et
      );
    },
  }),
  templateGeometries = {};
function getTemplateGeometry(tt) {
  let et = templateGeometries[tt];
  if (!et) {
    const nt = new PlaneGeometry(1, 1, tt, tt),
      rt = nt.clone(),
      it = nt.attributes,
      st = rt.attributes,
      ot = new BufferGeometry(),
      at = it.uv.count;
    for (let lt = 0; lt < at; lt++)
      (st.position.array[lt * 3] *= -1), (st.normal.array[lt * 3 + 2] *= -1);
    ["position", "normal", "uv"].forEach((lt) => {
      ot.setAttribute(
        lt,
        new Float32BufferAttribute(
          [...it[lt].array, ...st[lt].array],
          it[lt].itemSize
        )
      );
    }),
      ot.setIndex([...nt.index.array, ...rt.index.array.map((lt) => lt + at)]),
      ot.translate(0.5, 0.5, 0),
      (et = templateGeometries[tt] = ot);
  }
  return et;
}
const glyphBoundsAttrName = "aTroikaGlyphBounds",
  glyphIndexAttrName = "aTroikaGlyphIndex",
  glyphColorAttrName = "aTroikaGlyphColor";
class GlyphsGeometry extends InstancedBufferGeometry {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Sphere()),
      (this.boundingBox = new Box3());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  setSide(et) {
    const nt = this.getIndex().count;
    this.setDrawRange(
      et === BackSide ? nt / 2 : 0,
      et === DoubleSide ? nt : nt / 2
    );
  }
  set detail(et) {
    if (et !== this._detail) {
      (this._detail = et), (typeof et != "number" || et < 1) && (et = 1);
      let nt = getTemplateGeometry(et);
      ["position", "normal", "uv"].forEach((rt) => {
        this.attributes[rt] = nt.attributes[rt].clone();
      }),
        this.setIndex(nt.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(et) {
    et !== this._curveRadius &&
      ((this._curveRadius = et), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(et, nt, rt, it, st) {
    updateBufferAttr(this, glyphBoundsAttrName, et, 4),
      updateBufferAttr(this, glyphIndexAttrName, nt, 1),
      updateBufferAttr(this, glyphColorAttrName, st, 3),
      (this._blockBounds = rt),
      (this._chunkedBounds = it),
      (this.instanceCount = nt.length),
      this._updateBounds();
  }
  _updateBounds() {
    const et = this._blockBounds;
    if (et) {
      const { curveRadius: nt, boundingBox: rt } = this;
      if (nt) {
        const { PI: it, floor: st, min: ot, max: at, sin: lt, cos: ct } = Math,
          ut = it / 2,
          ft = it * 2,
          ht = Math.abs(nt),
          mt = et[0] / ht,
          vt = et[2] / ht,
          yt =
            st((mt + ut) / ft) !== st((vt + ut) / ft)
              ? -ht
              : ot(lt(mt) * ht, lt(vt) * ht),
          Et =
            st((mt - ut) / ft) !== st((vt - ut) / ft)
              ? ht
              : at(lt(mt) * ht, lt(vt) * ht),
          pt =
            st((mt + it) / ft) !== st((vt + it) / ft)
              ? ht * 2
              : at(ht - ct(mt) * ht, ht - ct(vt) * ht);
        rt.min.set(yt, et[1], nt < 0 ? -pt : 0),
          rt.max.set(Et, et[3], nt < 0 ? 0 : pt);
      } else rt.min.set(et[0], et[1], 0), rt.max.set(et[2], et[3], 0);
      rt.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(et) {
    let nt = this.getAttribute(glyphIndexAttrName).count,
      rt = this._chunkedBounds;
    if (rt)
      for (let it = rt.length; it--; ) {
        nt = rt[it].end;
        let st = rt[it].rect;
        if (st[1] < et.w && st[3] > et.y && st[0] < et.z && st[2] > et.x) break;
      }
    this.instanceCount = nt;
  }
}
function updateBufferAttr(tt, et, nt, rt) {
  const it = tt.getAttribute(et);
  nt
    ? it && it.array.length === nt.length
      ? (it.array.set(nt), (it.needsUpdate = !0))
      : (tt.setAttribute(et, new InstancedBufferAttribute(nt, rt)),
        delete tt._maxInstanceCount,
        tt.dispose())
    : it && tt.deleteAttribute(et);
}
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(tt) {
  const et = createDerivedMaterial(tt, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: nt, fragmentShader: rt }) {
      let it = /\buniform\s+vec3\s+diffuse\b/;
      return (
        it.test(rt) &&
          ((rt = rt
            .replace(it, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          it.test(nt) ||
            (nt = nt.replace(
              voidMainRegExp,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: nt, fragmentShader: rt }
      );
    },
  });
  return (
    (et.transparent = !0),
    Object.defineProperties(et, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    et
  );
}
const defaultMaterial = new MeshBasicMaterial({
    color: 16777215,
    side: DoubleSide,
    transparent: !0,
  }),
  defaultStrokeColor = 8421504,
  tempMat4 = new Matrix4(),
  tempVec3a = new Vector3(),
  tempVec3b = new Vector3(),
  tempArray = [],
  origin = new Vector3(),
  defaultOrient = "+x+y";
function first(tt) {
  return Array.isArray(tt) ? tt[0] : tt;
}
let getFlatRaycastMesh = () => {
    const tt = new Mesh(new PlaneGeometry(1, 1), defaultMaterial);
    return (getFlatRaycastMesh = () => tt), tt;
  },
  getCurvedRaycastMesh = () => {
    const tt = new Mesh(new PlaneGeometry(1, 1, 32, 1), defaultMaterial);
    return (getCurvedRaycastMesh = () => tt), tt;
  };
const syncStartEvent = { type: "syncstart" },
  syncCompleteEvent = { type: "synccomplete" },
  SYNCABLE_PROPS = [
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  COPYABLE_PROPS = SYNCABLE_PROPS.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let Text$1 = class extends Mesh {
  constructor() {
    const et = new GlyphsGeometry();
    super(et, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.fontSize = 0.1),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = defaultStrokeColor),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = defaultOrient),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(et) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(et)
        : ((this._isSyncing = !0),
          this.dispatchEvent(syncStartEvent),
          getTextRenderInfo(
            {
              text: this.text,
              font: this.font,
              fontSize: this.fontSize || 0.1,
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
            },
            (nt) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = nt),
                this.geometry.updateGlyphs(
                  nt.glyphBounds,
                  nt.glyphAtlasIndices,
                  nt.blockBounds,
                  nt.chunkedBounds,
                  nt.glyphColors
                );
              const rt = this._queuedSyncs;
              rt &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  rt.forEach((it) => it && it());
                })),
                this.dispatchEvent(syncCompleteEvent),
                et && et();
            }
          )));
  }
  onBeforeRender(et, nt, rt, it, st, ot) {
    this.sync(),
      st.isTroikaTextMaterial && this._prepareForRender(st),
      (st._hadOwnSide = st.hasOwnProperty("side")),
      this.geometry.setSide((st._actualSide = st.side)),
      (st.side = FrontSide);
  }
  onAfterRender(et, nt, rt, it, st, ot) {
    st._hadOwnSide ? (st.side = st._actualSide) : delete st.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let et = this._derivedMaterial;
    const nt =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = defaultMaterial.clone());
    if (
      ((!et || et.baseMaterial !== nt) &&
        ((et = this._derivedMaterial = createTextDerivedMaterial(nt)),
        nt.addEventListener("dispose", function rt() {
          nt.removeEventListener("dispose", rt), et.dispose();
        })),
      this.outlineWidth ||
        this.outlineBlur ||
        this.outlineOffsetX ||
        this.outlineOffsetY)
    ) {
      let rt = et._outlineMtl;
      return (
        rt ||
          ((rt = et._outlineMtl =
            Object.create(et, { id: { value: et.id + 0.1 } })),
          (rt.isTextOutlineMaterial = !0),
          (rt.depthWrite = !1),
          (rt.map = null),
          et.addEventListener("dispose", function it() {
            et.removeEventListener("dispose", it), rt.dispose();
          })),
        [rt, et]
      );
    } else return et;
  }
  set material(et) {
    et && et.isTroikaTextMaterial
      ? ((this._derivedMaterial = et), (this._baseMaterial = et.baseMaterial))
      : (this._baseMaterial = et);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(et) {
    this.geometry.detail = et;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(et) {
    this.geometry.curveRadius = et;
  }
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(et) {
    const nt = et.isTextOutlineMaterial,
      rt = et.uniforms,
      it = this.textRenderInfo;
    if (it) {
      const { sdfTexture: at, blockBounds: lt } = it;
      (rt.uTroikaSDFTexture.value = at),
        rt.uTroikaSDFTextureSize.value.set(at.image.width, at.image.height),
        (rt.uTroikaSDFGlyphSize.value = it.sdfGlyphSize),
        (rt.uTroikaSDFExponent.value = it.sdfExponent),
        rt.uTroikaTotalBounds.value.fromArray(lt),
        (rt.uTroikaUseGlyphColors.value = !nt && !!it.glyphColors);
      let ct = 0,
        ut = 0,
        ft = 0,
        ht,
        mt,
        vt,
        yt = 0,
        Et = 0;
      if (nt) {
        let {
          outlineWidth: xt,
          outlineOffsetX: St,
          outlineOffsetY: At,
          outlineBlur: Ct,
          outlineOpacity: Mt,
        } = this;
        (ct = this._parsePercent(xt) || 0),
          (ut = Math.max(0, this._parsePercent(Ct) || 0)),
          (ht = Mt),
          (yt = this._parsePercent(St) || 0),
          (Et = this._parsePercent(At) || 0);
      } else
        (ft = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          ft &&
            ((vt = this.strokeColor),
            rt.uTroikaStrokeColor.value.set(vt ?? defaultStrokeColor),
            (mt = this.strokeOpacity),
            mt == null && (mt = 1)),
          (ht = this.fillOpacity);
      (rt.uTroikaDistanceOffset.value = ct),
        rt.uTroikaPositionOffset.value.set(yt, Et),
        (rt.uTroikaBlurRadius.value = ut),
        (rt.uTroikaStrokeWidth.value = ft),
        (rt.uTroikaStrokeOpacity.value = mt),
        (rt.uTroikaFillOpacity.value = ht ?? 1),
        (rt.uTroikaCurveRadius.value = this.curveRadius || 0);
      let pt = this.clipRect;
      if (pt && Array.isArray(pt) && pt.length === 4)
        rt.uTroikaClipRect.value.fromArray(pt);
      else {
        const xt = (this.fontSize || 0.1) * 100;
        rt.uTroikaClipRect.value.set(
          lt[0] - xt,
          lt[1] - xt,
          lt[2] + xt,
          lt[3] + xt
        );
      }
      this.geometry.applyClipRect(rt.uTroikaClipRect.value);
    }
    (rt.uTroikaSDFDebug.value = !!this.debugSDF),
      (et.polygonOffset = !!this.depthOffset),
      (et.polygonOffsetFactor = et.polygonOffsetUnits = this.depthOffset || 0);
    const st = nt ? this.outlineColor || 0 : this.color;
    if (st == null) delete et.color;
    else {
      const at = et.hasOwnProperty("color")
        ? et.color
        : (et.color = new Color());
      (st !== at._input || typeof st == "object") && at.set((at._input = st));
    }
    let ot = this.orientation || defaultOrient;
    if (ot !== et._orientation) {
      let at = rt.uTroikaOrient.value;
      ot = ot.replace(/[^-+xyz]/g, "");
      let lt = ot !== defaultOrient && ot.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (lt) {
        let [, ct, ut, ft, ht] = lt;
        (tempVec3a.set(0, 0, 0)[ut] = ct === "-" ? 1 : -1),
          (tempVec3b.set(0, 0, 0)[ht] = ft === "-" ? -1 : 1),
          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b),
          at.setFromMatrix4(tempMat4);
      } else at.identity();
      et._orientation = ot;
    }
  }
  _parsePercent(et) {
    if (typeof et == "string") {
      let nt = et.match(/^(-?[\d.]+)%$/),
        rt = nt ? parseFloat(nt[1]) : NaN;
      et = (isNaN(rt) ? 0 : rt / 100) * this.fontSize;
    }
    return et;
  }
  localPositionToTextCoords(et, nt = new Vector2()) {
    nt.copy(et);
    const rt = this.curveRadius;
    return (
      rt &&
        (nt.x = Math.atan2(et.x, Math.abs(rt) - Math.abs(et.z)) * Math.abs(rt)),
      nt
    );
  }
  worldPositionToTextCoords(et, nt = new Vector2()) {
    return (
      tempVec3a.copy(et),
      this.localPositionToTextCoords(this.worldToLocal(tempVec3a), nt)
    );
  }
  raycast(et, nt) {
    const { textRenderInfo: rt, curveRadius: it } = this;
    if (rt) {
      const st = rt.blockBounds,
        ot = it ? getCurvedRaycastMesh() : getFlatRaycastMesh(),
        at = ot.geometry,
        { position: lt, uv: ct } = at.attributes;
      for (let ut = 0; ut < ct.count; ut++) {
        let ft = st[0] + ct.getX(ut) * (st[2] - st[0]);
        const ht = st[1] + ct.getY(ut) * (st[3] - st[1]);
        let mt = 0;
        it &&
          ((mt = it - Math.cos(ft / it) * it), (ft = Math.sin(ft / it) * it)),
          lt.setXYZ(ut, ft, ht, mt);
      }
      (at.boundingSphere = this.geometry.boundingSphere),
        (at.boundingBox = this.geometry.boundingBox),
        (ot.matrixWorld = this.matrixWorld),
        (ot.material.side = this.material.side),
        (tempArray.length = 0),
        ot.raycast(et, tempArray);
      for (let ut = 0; ut < tempArray.length; ut++)
        (tempArray[ut].object = this), nt.push(tempArray[ut]);
    }
  }
  copy(et) {
    const nt = this.geometry;
    return (
      super.copy(et),
      (this.geometry = nt),
      COPYABLE_PROPS.forEach((rt) => {
        this[rt] = et[rt];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((tt) => {
  const et = "_private_" + tt;
  Object.defineProperty(Text$1.prototype, tt, {
    get() {
      return this[et];
    },
    set(nt) {
      nt !== this[et] && ((this[et] = nt), (this._needsSync = !0));
    },
  });
});
const Text = reactExports.forwardRef(
    (
      {
        sdfGlyphSize: tt = 64,
        anchorX: et = "center",
        anchorY: nt = "middle",
        font: rt,
        fontSize: it = 1,
        children: st,
        characters: ot,
        onSync: at,
        ...lt
      },
      ct
    ) => {
      const ut = useThree(({ invalidate: vt }) => vt),
        [ft] = reactExports.useState(() => new Text$1()),
        [ht, mt] = reactExports.useMemo(() => {
          const vt = [];
          let yt = "";
          return (
            reactExports.Children.forEach(st, (Et) => {
              typeof Et == "string" || typeof Et == "number"
                ? (yt += Et)
                : vt.push(Et);
            }),
            [vt, yt]
          );
        }, [st]);
      return (
        suspend(
          () =>
            new Promise((vt) => preloadFont({ font: rt, characters: ot }, vt)),
          ["troika-text", rt, ot]
        ),
        reactExports.useLayoutEffect(
          () =>
            void ft.sync(() => {
              ut(), at && at(ft);
            })
        ),
        reactExports.useEffect(() => () => ft.dispose(), [ft]),
        reactExports.createElement(
          "primitive",
          _extends(
            {
              object: ft,
              ref: ct,
              font: rt,
              text: mt,
              anchorX: et,
              anchorY: nt,
              fontSize: it,
              sdfGlyphSize: tt,
            },
            lt
          ),
          ht
        )
      );
    }
  ),
  Effects = reactExports.forwardRef(
    (
      {
        children: tt,
        multisamping: et = 8,
        renderIndex: nt = 1,
        disableRender: rt,
        disableGamma: it,
        disableRenderPass: st,
        depthBuffer: ot = !0,
        stencilBuffer: at = !1,
        anisotropy: lt = 1,
        encoding: ct,
        type: ut,
        ...ft
      },
      ht
    ) => {
      reactExports.useMemo(
        () => extend({ EffectComposer, RenderPass, ShaderPass }),
        []
      );
      const mt = reactExports.useRef(),
        { scene: vt, camera: yt, gl: Et, size: pt, viewport: xt } = useThree(),
        [St] = reactExports.useState(() => {
          const Ct = new WebGLRenderTarget(pt.width, pt.height, {
            type: ut || HalfFloatType,
            format: RGBAFormat,
            depthBuffer: ot,
            stencilBuffer: at,
            anisotropy: lt,
          });
          return (
            ut === UnsignedByteType &&
              ct != null &&
              ("colorSpace" in Ct
                ? (Ct.texture.colorSpace = ct)
                : (Ct.texture.encoding = ct)),
            (Ct.samples = et),
            Ct
          );
        });
      reactExports.useEffect(() => {
        var Ct, Mt;
        (Ct = mt.current) == null || Ct.setSize(pt.width, pt.height),
          (Mt = mt.current) == null || Mt.setPixelRatio(xt.dpr);
      }, [Et, pt, xt.dpr]),
        useFrame(() => {
          var Ct;
          rt || (Ct = mt.current) == null || Ct.render();
        }, nt);
      const At = [];
      return (
        st ||
          At.push(
            reactExports.createElement("renderPass", {
              key: "renderpass",
              attach: `passes-${At.length}`,
              args: [vt, yt],
            })
          ),
        it ||
          At.push(
            reactExports.createElement("shaderPass", {
              attach: `passes-${At.length}`,
              key: "gammapass",
              args: [GammaCorrectionShader],
            })
          ),
        reactExports.Children.forEach(tt, (Ct) => {
          Ct &&
            At.push(
              reactExports.cloneElement(Ct, {
                key: At.length,
                attach: `passes-${At.length}`,
              })
            );
        }),
        reactExports.createElement(
          "effectComposer",
          _extends({ ref: mergeRefs([ht, mt]), args: [Et, St] }, ft),
          At
        )
      );
    }
  );
function shaderMaterial(tt, et, nt, rt) {
  const it = class extends ShaderMaterial {
    constructor(ot = {}) {
      const at = Object.entries(tt);
      super({
        uniforms: at.reduce((lt, [ct, ut]) => {
          const ft = UniformsUtils.clone({ [ct]: { value: ut } });
          return { ...lt, ...ft };
        }, {}),
        vertexShader: et,
        fragmentShader: nt,
      }),
        (this.key = ""),
        at.forEach(([lt]) =>
          Object.defineProperty(this, lt, {
            get: () => this.uniforms[lt].value,
            set: (ct) => (this.uniforms[lt].value = ct),
          })
        ),
        Object.assign(this, ot),
        rt && rt(this);
    }
  };
  return (it.key = MathUtils.generateUUID()), it;
}
const getVersion = () => parseInt(REVISION.replace(/\D+/g, "")),
  version = getVersion();
let dracoLoader = null,
  decoderPath = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function extensions(tt, et, nt) {
  return (rt) => {
    nt && nt(rt),
      tt &&
        (dracoLoader || (dracoLoader = new DRACOLoader()),
        dracoLoader.setDecoderPath(typeof tt == "string" ? tt : decoderPath),
        rt.setDRACOLoader(dracoLoader)),
      et &&
        rt.setMeshoptDecoder(
          typeof MeshoptDecoder == "function"
            ? MeshoptDecoder()
            : MeshoptDecoder
        );
  };
}
function useGLTF(tt, et = !0, nt = !0, rt) {
  return useLoader(GLTFLoader, tt, extensions(et, nt, rt));
}
useGLTF.preload = (tt, et = !0, nt = !0, rt) =>
  useLoader.preload(GLTFLoader, tt, extensions(et, nt, rt));
useGLTF.clear = (tt) => useLoader.clear(GLTFLoader, tt);
useGLTF.setDecoderPath = (tt) => {
  decoderPath = tt;
};
const OrbitControls = reactExports.forwardRef(
  (
    {
      makeDefault: tt,
      camera: et,
      regress: nt,
      domElement: rt,
      enableDamping: it = !0,
      keyEvents: st = !1,
      onChange: ot,
      onStart: at,
      onEnd: lt,
      ...ct
    },
    ut
  ) => {
    const ft = useThree((Mt) => Mt.invalidate),
      ht = useThree((Mt) => Mt.camera),
      mt = useThree((Mt) => Mt.gl),
      vt = useThree((Mt) => Mt.events),
      yt = useThree((Mt) => Mt.setEvents),
      Et = useThree((Mt) => Mt.set),
      pt = useThree((Mt) => Mt.get),
      xt = useThree((Mt) => Mt.performance),
      St = et || ht,
      At = rt || vt.connected || mt.domElement,
      Ct = reactExports.useMemo(() => new OrbitControls$1(St), [St]);
    return (
      useFrame(() => {
        Ct.enabled && Ct.update();
      }, -1),
      reactExports.useEffect(
        () => (
          st && Ct.connect(st === !0 ? At : st),
          Ct.connect(At),
          () => void Ct.dispose()
        ),
        [st, At, nt, Ct, ft]
      ),
      reactExports.useEffect(() => {
        const Mt = (It) => {
            ft(), nt && xt.regress(), ot && ot(It);
          },
          wt = (It) => {
            at && at(It);
          },
          Bt = (It) => {
            lt && lt(It);
          };
        return (
          Ct.addEventListener("change", Mt),
          Ct.addEventListener("start", wt),
          Ct.addEventListener("end", Bt),
          () => {
            Ct.removeEventListener("start", wt),
              Ct.removeEventListener("end", Bt),
              Ct.removeEventListener("change", Mt);
          }
        );
      }, [ot, at, lt, Ct, ft, yt]),
      reactExports.useEffect(() => {
        if (tt) {
          const Mt = pt().controls;
          return Et({ controls: Ct }), () => Et({ controls: Mt });
        }
      }, [tt, Ct]),
      reactExports.createElement(
        "primitive",
        _extends({ ref: ut, object: Ct, enableDamping: it }, ct)
      )
    );
  }
);
function useAnimations(tt, et) {
  const nt = reactExports.useRef(),
    [rt] = reactExports.useState(() =>
      et ? (et instanceof Object3D ? { current: et } : et) : nt
    ),
    [it] = reactExports.useState(() => new AnimationMixer(void 0));
  reactExports.useLayoutEffect(() => {
    et && (rt.current = et instanceof Object3D ? et : et.current),
      (it._root = rt.current);
  });
  const st = reactExports.useRef({}),
    ot = reactExports.useMemo(() => {
      const at = {};
      return (
        tt.forEach((lt) =>
          Object.defineProperty(at, lt.name, {
            enumerable: !0,
            get() {
              if (rt.current)
                return (
                  st.current[lt.name] ||
                  (st.current[lt.name] = it.clipAction(lt, rt.current))
                );
            },
            configurable: !0,
          })
        ),
        {
          ref: rt,
          clips: tt,
          actions: at,
          names: tt.map((lt) => lt.name),
          mixer: it,
        }
      );
    }, [tt]);
  return (
    useFrame((at, lt) => it.update(lt)),
    reactExports.useEffect(() => {
      const at = rt.current;
      return () => {
        (st.current = {}),
          it.stopAllAction(),
          Object.values(ot.actions).forEach((lt) => {
            at && it.uncacheAction(lt, at);
          });
      };
    }, [tt]),
    ot
  );
}
const SparklesImplMaterial = shaderMaterial(
    { time: 0, pixelRatio: 1 },
    ` uniform float pixelRatio;
    uniform float time;
    attribute float size;  
    attribute float speed;  
    attribute float opacity;
    attribute vec3 noise;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vOpacity;
    void main() {
      vec4 modelPosition = modelMatrix * vec4(position, 1.0);
      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;
      gl_PointSize = size * 25. * pixelRatio;
      gl_PointSize *= (1.0 / - viewPosition.z);
      vColor = color;
      vOpacity = opacity;
    }`,
    ` varying vec3 vColor;
    varying float vOpacity;
    void main() {
      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
      float strength = 0.05 / distanceToCenter - 0.1;
      gl_FragColor = vec4(vColor, strength * vOpacity);
      #include <tonemapping_fragment>
      #include <${
        version >= 154 ? "colorspace_fragment" : "encodings_fragment"
      }>
    }`
  ),
  isFloat32Array = (tt) => tt && tt.constructor === Float32Array,
  expandColor = (tt) => [tt.r, tt.g, tt.b],
  isVector = (tt) =>
    tt instanceof Vector2 || tt instanceof Vector3 || tt instanceof Vector4,
  normalizeVector = (tt) =>
    Array.isArray(tt) ? tt : isVector(tt) ? tt.toArray() : [tt, tt, tt];
function usePropAsIsOrAsAttribute(tt, et, nt) {
  return reactExports.useMemo(() => {
    if (et !== void 0) {
      if (isFloat32Array(et)) return et;
      if (et instanceof Color) {
        const rt = Array.from({ length: tt * 3 }, () => expandColor(et)).flat();
        return Float32Array.from(rt);
      } else if (isVector(et) || Array.isArray(et)) {
        const rt = Array.from({ length: tt * 3 }, () =>
          normalizeVector(et)
        ).flat();
        return Float32Array.from(rt);
      }
      return Float32Array.from({ length: tt }, () => et);
    }
    return Float32Array.from({ length: tt }, nt);
  }, [et]);
}
const Sparkles = reactExports.forwardRef(
    (
      {
        noise: tt = 1,
        count: et = 100,
        speed: nt = 1,
        opacity: rt = 1,
        scale: it = 1,
        size: st,
        color: ot,
        children: at,
        ...lt
      },
      ct
    ) => {
      reactExports.useMemo(() => extend({ SparklesImplMaterial }), []);
      const ut = reactExports.useRef(null),
        ft = useThree((St) => St.viewport.dpr),
        ht = normalizeVector(it),
        mt = reactExports.useMemo(
          () =>
            Float32Array.from(
              Array.from({ length: et }, () =>
                ht.map(MathUtils.randFloatSpread)
              ).flat()
            ),
          [et, ...ht]
        ),
        vt = usePropAsIsOrAsAttribute(et, st, Math.random),
        yt = usePropAsIsOrAsAttribute(et, rt),
        Et = usePropAsIsOrAsAttribute(et, nt),
        pt = usePropAsIsOrAsAttribute(et * 3, tt),
        xt = usePropAsIsOrAsAttribute(
          ot === void 0 ? et * 3 : et,
          isFloat32Array(ot) ? ot : new Color(ot),
          () => 1
        );
      return (
        useFrame((St) => {
          ut.current &&
            ut.current.material &&
            (ut.current.material.time = St.clock.elapsedTime);
        }),
        reactExports.useImperativeHandle(ct, () => ut.current, []),
        reactExports.createElement(
          "points",
          _extends({ key: `particle-${et}-${JSON.stringify(it)}` }, lt, {
            ref: ut,
          }),
          reactExports.createElement(
            "bufferGeometry",
            null,
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-position",
              args: [mt, 3],
            }),
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-size",
              args: [vt, 1],
            }),
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-opacity",
              args: [yt, 1],
            }),
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-speed",
              args: [Et, 1],
            }),
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-color",
              args: [xt, 3],
            }),
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-noise",
              args: [pt, 3],
            })
          ),
          at ||
            reactExports.createElement("sparklesImplMaterial", {
              transparent: !0,
              pixelRatio: ft,
              depthWrite: !1,
            })
        )
      );
    }
  ),
  img = "images/cubeText1-ec843cde.jpg";
var shim = { exports: {} },
  useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var e$2 = reactExports;
function h$4(tt, et) {
  return (
    (tt === et && (tt !== 0 || 1 / tt === 1 / et)) || (tt !== tt && et !== et)
  );
}
var k$5 = typeof Object.is == "function" ? Object.is : h$4,
  l$4 = e$2.useState,
  m$5 = e$2.useEffect,
  n$5 = e$2.useLayoutEffect,
  p$5 = e$2.useDebugValue;
function q$6(tt, et) {
  var nt = et(),
    rt = l$4({ inst: { value: nt, getSnapshot: et } }),
    it = rt[0].inst,
    st = rt[1];
  return (
    n$5(
      function () {
        (it.value = nt), (it.getSnapshot = et), r$4(it) && st({ inst: it });
      },
      [tt, nt, et]
    ),
    m$5(
      function () {
        return (
          r$4(it) && st({ inst: it }),
          tt(function () {
            r$4(it) && st({ inst: it });
          })
        );
      },
      [tt]
    ),
    p$5(nt),
    nt
  );
}
function r$4(tt) {
  var et = tt.getSnapshot;
  tt = tt.value;
  try {
    var nt = et();
    return !k$5(tt, nt);
  } catch {
    return !0;
  }
}
function t$4(tt, et) {
  return et();
}
var u$3 =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? t$4
    : q$6;
useSyncExternalStoreShim_production_min.useSyncExternalStore =
  e$2.useSyncExternalStore !== void 0 ? e$2.useSyncExternalStore : u$3;
shim.exports = useSyncExternalStoreShim_production_min;
var shimExports = shim.exports,
  withSelector = { exports: {} },
  withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var h$3 = reactExports,
  n$4 = shimExports;
function p$4(tt, et) {
  return (
    (tt === et && (tt !== 0 || 1 / tt === 1 / et)) || (tt !== tt && et !== et)
  );
}
var q$5 = typeof Object.is == "function" ? Object.is : p$4,
  r$3 = n$4.useSyncExternalStore,
  t$3 = h$3.useRef,
  u$2 = h$3.useEffect,
  v$4 = h$3.useMemo,
  w$3 = h$3.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function (
  tt,
  et,
  nt,
  rt,
  it
) {
  var st = t$3(null);
  if (st.current === null) {
    var ot = { hasValue: !1, value: null };
    st.current = ot;
  } else ot = st.current;
  st = v$4(
    function () {
      function lt(mt) {
        if (!ct) {
          if (
            ((ct = !0), (ut = mt), (mt = rt(mt)), it !== void 0 && ot.hasValue)
          ) {
            var vt = ot.value;
            if (it(vt, mt)) return (ft = vt);
          }
          return (ft = mt);
        }
        if (((vt = ft), q$5(ut, mt))) return vt;
        var yt = rt(mt);
        return it !== void 0 && it(vt, yt) ? vt : ((ut = mt), (ft = yt));
      }
      var ct = !1,
        ut,
        ft,
        ht = nt === void 0 ? null : nt;
      return [
        function () {
          return lt(et());
        },
        ht === null
          ? void 0
          : function () {
              return lt(ht());
            },
      ];
    },
    [et, nt, rt, it]
  );
  var at = r$3(tt, st[0], st[1]);
  return (
    u$2(
      function () {
        (ot.hasValue = !0), (ot.value = at);
      },
      [at]
    ),
    w$3(at),
    at
  );
};
withSelector.exports = withSelector_production_min;
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(tt) {
  tt();
}
let batch = defaultNoopBatch;
const setBatch = (tt) => (batch = tt),
  getBatch = () => batch,
  ContextKey = Symbol.for("react-redux-context"),
  gT = typeof globalThis < "u" ? globalThis : {};
function getContext() {
  var tt;
  if (!reactExports.createContext) return {};
  const et = (tt = gT[ContextKey]) != null ? tt : (gT[ContextKey] = new Map());
  let nt = et.get(reactExports.createContext);
  return (
    nt ||
      ((nt = reactExports.createContext(null)),
      et.set(reactExports.createContext, nt)),
    nt
  );
}
const ReactReduxContext = getContext();
function createReduxContextHook(tt = ReactReduxContext) {
  return function () {
    return reactExports.useContext(tt);
  };
}
const useReduxContext = createReduxContextHook(),
  notInitialized = () => {
    throw new Error("uSES not initialized!");
  };
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (tt) => {
    useSyncExternalStoreWithSelector = tt;
  },
  refEquality = (tt, et) => tt === et;
function createSelectorHook(tt = ReactReduxContext) {
  const et =
    tt === ReactReduxContext ? useReduxContext : createReduxContextHook(tt);
  return function (rt, it = {}) {
    const {
        equalityFn: st = refEquality,
        stabilityCheck: ot = void 0,
        noopCheck: at = void 0,
      } = typeof it == "function" ? { equalityFn: it } : it,
      {
        store: lt,
        subscription: ct,
        getServerState: ut,
        stabilityCheck: ft,
        noopCheck: ht,
      } = et();
    reactExports.useRef(!0);
    const mt = reactExports.useCallback(
        {
          [rt.name](yt) {
            return rt(yt);
          },
        }[rt.name],
        [rt, ft, ot]
      ),
      vt = useSyncExternalStoreWithSelector(
        ct.addNestedSub,
        lt.getState,
        ut || lt.getState,
        mt,
        st
      );
    return reactExports.useDebugValue(vt), vt;
  };
}
const useSelector = createSelectorHook();
function _objectWithoutPropertiesLoose(tt, et) {
  if (tt == null) return {};
  var nt = {},
    rt = Object.keys(tt),
    it,
    st;
  for (st = 0; st < rt.length; st++)
    (it = rt[st]), !(et.indexOf(it) >= 0) && (nt[it] = tt[it]);
  return nt;
}
var reactIs$2 = { exports: {} },
  reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$3 = typeof Symbol == "function" && Symbol.for,
  c$2 = b$3 ? Symbol.for("react.element") : 60103,
  d$2 = b$3 ? Symbol.for("react.portal") : 60106,
  e$1 = b$3 ? Symbol.for("react.fragment") : 60107,
  f$3 = b$3 ? Symbol.for("react.strict_mode") : 60108,
  g$3 = b$3 ? Symbol.for("react.profiler") : 60114,
  h$2 = b$3 ? Symbol.for("react.provider") : 60109,
  k$4 = b$3 ? Symbol.for("react.context") : 60110,
  l$3 = b$3 ? Symbol.for("react.async_mode") : 60111,
  m$4 = b$3 ? Symbol.for("react.concurrent_mode") : 60111,
  n$3 = b$3 ? Symbol.for("react.forward_ref") : 60112,
  p$3 = b$3 ? Symbol.for("react.suspense") : 60113,
  q$4 = b$3 ? Symbol.for("react.suspense_list") : 60120,
  r$2 = b$3 ? Symbol.for("react.memo") : 60115,
  t$2 = b$3 ? Symbol.for("react.lazy") : 60116,
  v$3 = b$3 ? Symbol.for("react.block") : 60121,
  w$2 = b$3 ? Symbol.for("react.fundamental") : 60117,
  x$2 = b$3 ? Symbol.for("react.responder") : 60118,
  y$2 = b$3 ? Symbol.for("react.scope") : 60119;
function z$2(tt) {
  if (typeof tt == "object" && tt !== null) {
    var et = tt.$$typeof;
    switch (et) {
      case c$2:
        switch (((tt = tt.type), tt)) {
          case l$3:
          case m$4:
          case e$1:
          case g$3:
          case f$3:
          case p$3:
            return tt;
          default:
            switch (((tt = tt && tt.$$typeof), tt)) {
              case k$4:
              case n$3:
              case t$2:
              case r$2:
              case h$2:
                return tt;
              default:
                return et;
            }
        }
      case d$2:
        return et;
    }
  }
}
function A$1(tt) {
  return z$2(tt) === m$4;
}
reactIs_production_min$1.AsyncMode = l$3;
reactIs_production_min$1.ConcurrentMode = m$4;
reactIs_production_min$1.ContextConsumer = k$4;
reactIs_production_min$1.ContextProvider = h$2;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$3;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$2;
reactIs_production_min$1.Memo = r$2;
reactIs_production_min$1.Portal = d$2;
reactIs_production_min$1.Profiler = g$3;
reactIs_production_min$1.StrictMode = f$3;
reactIs_production_min$1.Suspense = p$3;
reactIs_production_min$1.isAsyncMode = function (tt) {
  return A$1(tt) || z$2(tt) === l$3;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function (tt) {
  return z$2(tt) === k$4;
};
reactIs_production_min$1.isContextProvider = function (tt) {
  return z$2(tt) === h$2;
};
reactIs_production_min$1.isElement = function (tt) {
  return typeof tt == "object" && tt !== null && tt.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function (tt) {
  return z$2(tt) === n$3;
};
reactIs_production_min$1.isFragment = function (tt) {
  return z$2(tt) === e$1;
};
reactIs_production_min$1.isLazy = function (tt) {
  return z$2(tt) === t$2;
};
reactIs_production_min$1.isMemo = function (tt) {
  return z$2(tt) === r$2;
};
reactIs_production_min$1.isPortal = function (tt) {
  return z$2(tt) === d$2;
};
reactIs_production_min$1.isProfiler = function (tt) {
  return z$2(tt) === g$3;
};
reactIs_production_min$1.isStrictMode = function (tt) {
  return z$2(tt) === f$3;
};
reactIs_production_min$1.isSuspense = function (tt) {
  return z$2(tt) === p$3;
};
reactIs_production_min$1.isValidElementType = function (tt) {
  return (
    typeof tt == "string" ||
    typeof tt == "function" ||
    tt === e$1 ||
    tt === m$4 ||
    tt === g$3 ||
    tt === f$3 ||
    tt === p$3 ||
    tt === q$4 ||
    (typeof tt == "object" &&
      tt !== null &&
      (tt.$$typeof === t$2 ||
        tt.$$typeof === r$2 ||
        tt.$$typeof === h$2 ||
        tt.$$typeof === k$4 ||
        tt.$$typeof === n$3 ||
        tt.$$typeof === w$2 ||
        tt.$$typeof === x$2 ||
        tt.$$typeof === y$2 ||
        tt.$$typeof === v$3))
  );
};
reactIs_production_min$1.typeOf = z$2;
reactIs$2.exports = reactIs_production_min$1;
var reactIsExports$1 = reactIs$2.exports,
  reactIs$1 = reactIsExports$1,
  REACT_STATICS = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0,
  },
  KNOWN_STATICS = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0,
  },
  FORWARD_REF_STATICS = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  MEMO_STATICS = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
function getStatics(tt) {
  return reactIs$1.isMemo(tt)
    ? MEMO_STATICS
    : TYPE_STATICS[tt.$$typeof] || REACT_STATICS;
}
var defineProperty = Object.defineProperty,
  getOwnPropertyNames = Object.getOwnPropertyNames,
  getOwnPropertySymbols = Object.getOwnPropertySymbols,
  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
  getPrototypeOf = Object.getPrototypeOf,
  objectPrototype = Object.prototype;
function hoistNonReactStatics(tt, et, nt) {
  if (typeof et != "string") {
    if (objectPrototype) {
      var rt = getPrototypeOf(et);
      rt && rt !== objectPrototype && hoistNonReactStatics(tt, rt, nt);
    }
    var it = getOwnPropertyNames(et);
    getOwnPropertySymbols && (it = it.concat(getOwnPropertySymbols(et)));
    for (
      var st = getStatics(tt), ot = getStatics(et), at = 0;
      at < it.length;
      ++at
    ) {
      var lt = it[at];
      if (
        !KNOWN_STATICS[lt] &&
        !(nt && nt[lt]) &&
        !(ot && ot[lt]) &&
        !(st && st[lt])
      ) {
        var ct = getOwnPropertyDescriptor(et, lt);
        try {
          defineProperty(tt, lt, ct);
        } catch {}
      }
    }
  }
  return tt;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const m$3 = getDefaultExportFromCjs(hoistNonReactStatics_cjs);
var reactIs = { exports: {} },
  reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$2 = Symbol.for("react.element"),
  c$1 = Symbol.for("react.portal"),
  d$1 = Symbol.for("react.fragment"),
  e = Symbol.for("react.strict_mode"),
  f$2 = Symbol.for("react.profiler"),
  g$2 = Symbol.for("react.provider"),
  h$1 = Symbol.for("react.context"),
  k$3 = Symbol.for("react.server_context"),
  l$2 = Symbol.for("react.forward_ref"),
  m$2 = Symbol.for("react.suspense"),
  n$2 = Symbol.for("react.suspense_list"),
  p$2 = Symbol.for("react.memo"),
  q$3 = Symbol.for("react.lazy"),
  t$1 = Symbol.for("react.offscreen"),
  u$1;
u$1 = Symbol.for("react.module.reference");
function v$2(tt) {
  if (typeof tt == "object" && tt !== null) {
    var et = tt.$$typeof;
    switch (et) {
      case b$2:
        switch (((tt = tt.type), tt)) {
          case d$1:
          case f$2:
          case e:
          case m$2:
          case n$2:
            return tt;
          default:
            switch (((tt = tt && tt.$$typeof), tt)) {
              case k$3:
              case h$1:
              case l$2:
              case q$3:
              case p$2:
              case g$2:
                return tt;
              default:
                return et;
            }
        }
      case c$1:
        return et;
    }
  }
}
reactIs_production_min.ContextConsumer = h$1;
reactIs_production_min.ContextProvider = g$2;
reactIs_production_min.Element = b$2;
reactIs_production_min.ForwardRef = l$2;
reactIs_production_min.Fragment = d$1;
reactIs_production_min.Lazy = q$3;
reactIs_production_min.Memo = p$2;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f$2;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m$2;
reactIs_production_min.SuspenseList = n$2;
reactIs_production_min.isAsyncMode = function () {
  return !1;
};
reactIs_production_min.isConcurrentMode = function () {
  return !1;
};
reactIs_production_min.isContextConsumer = function (tt) {
  return v$2(tt) === h$1;
};
reactIs_production_min.isContextProvider = function (tt) {
  return v$2(tt) === g$2;
};
reactIs_production_min.isElement = function (tt) {
  return typeof tt == "object" && tt !== null && tt.$$typeof === b$2;
};
reactIs_production_min.isForwardRef = function (tt) {
  return v$2(tt) === l$2;
};
reactIs_production_min.isFragment = function (tt) {
  return v$2(tt) === d$1;
};
reactIs_production_min.isLazy = function (tt) {
  return v$2(tt) === q$3;
};
reactIs_production_min.isMemo = function (tt) {
  return v$2(tt) === p$2;
};
reactIs_production_min.isPortal = function (tt) {
  return v$2(tt) === c$1;
};
reactIs_production_min.isProfiler = function (tt) {
  return v$2(tt) === f$2;
};
reactIs_production_min.isStrictMode = function (tt) {
  return v$2(tt) === e;
};
reactIs_production_min.isSuspense = function (tt) {
  return v$2(tt) === m$2;
};
reactIs_production_min.isSuspenseList = function (tt) {
  return v$2(tt) === n$2;
};
reactIs_production_min.isValidElementType = function (tt) {
  return (
    typeof tt == "string" ||
    typeof tt == "function" ||
    tt === d$1 ||
    tt === f$2 ||
    tt === e ||
    tt === m$2 ||
    tt === n$2 ||
    tt === t$1 ||
    (typeof tt == "object" &&
      tt !== null &&
      (tt.$$typeof === q$3 ||
        tt.$$typeof === p$2 ||
        tt.$$typeof === g$2 ||
        tt.$$typeof === h$1 ||
        tt.$$typeof === l$2 ||
        tt.$$typeof === u$1 ||
        tt.getModuleId !== void 0))
  );
};
reactIs_production_min.typeOf = v$2;
reactIs.exports = reactIs_production_min;
var reactIsExports = reactIs.exports;
function createListenerCollection() {
  const tt = getBatch();
  let et = null,
    nt = null;
  return {
    clear() {
      (et = null), (nt = null);
    },
    notify() {
      tt(() => {
        let rt = et;
        for (; rt; ) rt.callback(), (rt = rt.next);
      });
    },
    get() {
      let rt = [],
        it = et;
      for (; it; ) rt.push(it), (it = it.next);
      return rt;
    },
    subscribe(rt) {
      let it = !0,
        st = (nt = { callback: rt, next: null, prev: nt });
      return (
        st.prev ? (st.prev.next = st) : (et = st),
        function () {
          !it ||
            et === null ||
            ((it = !1),
            st.next ? (st.next.prev = st.prev) : (nt = st.prev),
            st.prev ? (st.prev.next = st.next) : (et = st.next));
        }
      );
    },
  };
}
const nullListeners = { notify() {}, get: () => [] };
function createSubscription(tt, et) {
  let nt,
    rt = nullListeners,
    it = 0,
    st = !1;
  function ot(yt) {
    ut();
    const Et = rt.subscribe(yt);
    let pt = !1;
    return () => {
      pt || ((pt = !0), Et(), ft());
    };
  }
  function at() {
    rt.notify();
  }
  function lt() {
    vt.onStateChange && vt.onStateChange();
  }
  function ct() {
    return st;
  }
  function ut() {
    it++,
      nt ||
        ((nt = et ? et.addNestedSub(lt) : tt.subscribe(lt)),
        (rt = createListenerCollection()));
  }
  function ft() {
    it--,
      nt && it === 0 && (nt(), (nt = void 0), rt.clear(), (rt = nullListeners));
  }
  function ht() {
    st || ((st = !0), ut());
  }
  function mt() {
    st && ((st = !1), ft());
  }
  const vt = {
    addNestedSub: ot,
    notifyNestedSubs: at,
    handleChangeWrapper: lt,
    isSubscribed: ct,
    trySubscribe: ht,
    tryUnsubscribe: mt,
    getListeners: () => rt,
  };
  return vt;
}
const canUseDOM =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  useIsomorphicLayoutEffect = canUseDOM
    ? reactExports.useLayoutEffect
    : reactExports.useEffect;
function Provider({
  store: tt,
  context: et,
  children: nt,
  serverState: rt,
  stabilityCheck: it = "once",
  noopCheck: st = "once",
}) {
  const ot = reactExports.useMemo(() => {
      const ct = createSubscription(tt);
      return {
        store: tt,
        subscription: ct,
        getServerState: rt ? () => rt : void 0,
        stabilityCheck: it,
        noopCheck: st,
      };
    }, [tt, rt, it, st]),
    at = reactExports.useMemo(() => tt.getState(), [tt]);
  useIsomorphicLayoutEffect(() => {
    const { subscription: ct } = ot;
    return (
      (ct.onStateChange = ct.notifyNestedSubs),
      ct.trySubscribe(),
      at !== tt.getState() && ct.notifyNestedSubs(),
      () => {
        ct.tryUnsubscribe(), (ct.onStateChange = void 0);
      }
    );
  }, [ot, at]);
  const lt = et || ReactReduxContext;
  return reactExports.createElement(lt.Provider, { value: ot }, nt);
}
function createStoreHook(tt = ReactReduxContext) {
  const et =
    tt === ReactReduxContext ? useReduxContext : createReduxContextHook(tt);
  return function () {
    const { store: rt } = et();
    return rt;
  };
}
const useStore = createStoreHook();
function createDispatchHook(tt = ReactReduxContext) {
  const et = tt === ReactReduxContext ? useStore : createStoreHook(tt);
  return function () {
    return et().dispatch;
  };
}
const useDispatch = createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
setBatch(reactDomExports.unstable_batchedUpdates);
function isPlainObject$2(tt) {
  return tt !== null && typeof tt == "object" && tt.constructor === Object;
}
function deepClone(tt) {
  if (!isPlainObject$2(tt)) return tt;
  const et = {};
  return (
    Object.keys(tt).forEach((nt) => {
      et[nt] = deepClone(tt[nt]);
    }),
    et
  );
}
function deepmerge(tt, et, nt = { clone: !0 }) {
  const rt = nt.clone ? _extends({}, tt) : tt;
  return (
    isPlainObject$2(tt) &&
      isPlainObject$2(et) &&
      Object.keys(et).forEach((it) => {
        it !== "__proto__" &&
          (isPlainObject$2(et[it]) && it in tt && isPlainObject$2(tt[it])
            ? (rt[it] = deepmerge(tt[it], et[it], nt))
            : nt.clone
            ? (rt[it] = isPlainObject$2(et[it]) ? deepClone(et[it]) : et[it])
            : (rt[it] = et[it]));
      }),
    rt
  );
}
function formatMuiErrorMessage(tt) {
  let et = "https://mui.com/production-error/?code=" + tt;
  for (let nt = 1; nt < arguments.length; nt += 1)
    et += "&args[]=" + encodeURIComponent(arguments[nt]);
  return (
    "Minified MUI error #" + tt + "; visit " + et + " for the full message."
  );
}
function capitalize(tt) {
  if (typeof tt != "string") throw new Error(formatMuiErrorMessage(7));
  return tt.charAt(0).toUpperCase() + tt.slice(1);
}
function createChainedFunction(...tt) {
  return tt.reduce(
    (et, nt) =>
      nt == null
        ? et
        : function (...it) {
            et.apply(this, it), nt.apply(this, it);
          },
    () => {}
  );
}
function ownerDocument(tt) {
  return (tt && tt.ownerDocument) || document;
}
function setRef(tt, et) {
  typeof tt == "function" ? tt(et) : tt && (tt.current = et);
}
const useEnhancedEffect =
    typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect,
  useEnhancedEffect$1 = useEnhancedEffect;
let globalId = 0;
function useGlobalId(tt) {
  const [et, nt] = reactExports.useState(tt),
    rt = tt || et;
  return (
    reactExports.useEffect(() => {
      et == null && ((globalId += 1), nt(`mui-${globalId}`));
    }, [et]),
    rt
  );
}
const maybeReactUseId = React$1["useId".toString()];
function useId(tt) {
  if (maybeReactUseId !== void 0) {
    const et = maybeReactUseId();
    return tt ?? et;
  }
  return useGlobalId(tt);
}
function useControlled({
  controlled: tt,
  default: et,
  name: nt,
  state: rt = "value",
}) {
  const { current: it } = reactExports.useRef(tt !== void 0),
    [st, ot] = reactExports.useState(et),
    at = it ? tt : st,
    lt = reactExports.useCallback((ct) => {
      it || ot(ct);
    }, []);
  return [at, lt];
}
function useEventCallback(tt) {
  const et = reactExports.useRef(tt);
  return (
    useEnhancedEffect$1(() => {
      et.current = tt;
    }),
    reactExports.useRef((...nt) => (0, et.current)(...nt)).current
  );
}
function useForkRef(...tt) {
  return reactExports.useMemo(
    () =>
      tt.every((et) => et == null)
        ? null
        : (et) => {
            tt.forEach((nt) => {
              setRef(nt, et);
            });
          },
    tt
  );
}
let hadKeyboardEvent = !0,
  hadFocusVisibleRecently = !1,
  hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: !0,
  search: !0,
  url: !0,
  tel: !0,
  email: !0,
  password: !0,
  number: !0,
  date: !0,
  month: !0,
  week: !0,
  time: !0,
  datetime: !0,
  "datetime-local": !0,
};
function focusTriggersKeyboardModality(tt) {
  const { type: et, tagName: nt } = tt;
  return !!(
    (nt === "INPUT" && inputTypesWhitelist[et] && !tt.readOnly) ||
    (nt === "TEXTAREA" && !tt.readOnly) ||
    tt.isContentEditable
  );
}
function handleKeyDown(tt) {
  tt.metaKey || tt.altKey || tt.ctrlKey || (hadKeyboardEvent = !0);
}
function handlePointerDown() {
  hadKeyboardEvent = !1;
}
function handleVisibilityChange() {
  this.visibilityState === "hidden" &&
    hadFocusVisibleRecently &&
    (hadKeyboardEvent = !0);
}
function prepare(tt) {
  tt.addEventListener("keydown", handleKeyDown, !0),
    tt.addEventListener("mousedown", handlePointerDown, !0),
    tt.addEventListener("pointerdown", handlePointerDown, !0),
    tt.addEventListener("touchstart", handlePointerDown, !0),
    tt.addEventListener("visibilitychange", handleVisibilityChange, !0);
}
function isFocusVisible(tt) {
  const { target: et } = tt;
  try {
    return et.matches(":focus-visible");
  } catch {}
  return hadKeyboardEvent || focusTriggersKeyboardModality(et);
}
function useIsFocusVisible() {
  const tt = reactExports.useCallback((it) => {
      it != null && prepare(it.ownerDocument);
    }, []),
    et = reactExports.useRef(!1);
  function nt() {
    return et.current
      ? ((hadFocusVisibleRecently = !0),
        window.clearTimeout(hadFocusVisibleRecentlyTimeout),
        (hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
          hadFocusVisibleRecently = !1;
        }, 100)),
        (et.current = !1),
        !0)
      : !1;
  }
  function rt(it) {
    return isFocusVisible(it) ? ((et.current = !0), !0) : !1;
  }
  return { isFocusVisibleRef: et, onFocus: rt, onBlur: nt, ref: tt };
}
function resolveProps(tt, et) {
  const nt = _extends({}, et);
  return (
    Object.keys(tt).forEach((rt) => {
      if (rt.toString().match(/^(components|slots)$/))
        nt[rt] = _extends({}, tt[rt], nt[rt]);
      else if (rt.toString().match(/^(componentsProps|slotProps)$/)) {
        const it = tt[rt] || {},
          st = et[rt];
        (nt[rt] = {}),
          !st || !Object.keys(st)
            ? (nt[rt] = it)
            : !it || !Object.keys(it)
            ? (nt[rt] = st)
            : ((nt[rt] = _extends({}, st)),
              Object.keys(it).forEach((ot) => {
                nt[rt][ot] = resolveProps(it[ot], st[ot]);
              }));
      } else nt[rt] === void 0 && (nt[rt] = tt[rt]);
    }),
    nt
  );
}
function composeClasses(tt, et, nt = void 0) {
  const rt = {};
  return (
    Object.keys(tt).forEach((it) => {
      rt[it] = tt[it]
        .reduce((st, ot) => {
          if (ot) {
            const at = et(ot);
            at !== "" && st.push(at), nt && nt[ot] && st.push(nt[ot]);
          }
          return st;
        }, [])
        .join(" ");
    }),
    rt
  );
}
const defaultGenerator = (tt) => tt,
  createClassNameGenerator = () => {
    let tt = defaultGenerator;
    return {
      configure(et) {
        tt = et;
      },
      generate(et) {
        return tt(et);
      },
      reset() {
        tt = defaultGenerator;
      },
    };
  },
  ClassNameGenerator = createClassNameGenerator(),
  ClassNameGenerator$1 = ClassNameGenerator,
  globalStateClassesMapping = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected",
  };
function generateUtilityClass(tt, et, nt = "Mui") {
  const rt = globalStateClassesMapping[et];
  return rt ? `${nt}-${rt}` : `${ClassNameGenerator$1.generate(tt)}-${et}`;
}
function generateUtilityClasses(tt, et, nt = "Mui") {
  const rt = {};
  return (
    et.forEach((it) => {
      rt[it] = generateUtilityClass(tt, it, nt);
    }),
    rt
  );
}
function r$1(tt) {
  var et,
    nt,
    rt = "";
  if (typeof tt == "string" || typeof tt == "number") rt += tt;
  else if (typeof tt == "object")
    if (Array.isArray(tt))
      for (et = 0; et < tt.length; et++)
        tt[et] && (nt = r$1(tt[et])) && (rt && (rt += " "), (rt += nt));
    else for (et in tt) tt[et] && (rt && (rt += " "), (rt += et));
  return rt;
}
function clsx() {
  for (var tt, et, nt = 0, rt = ""; nt < arguments.length; )
    (tt = arguments[nt++]) && (et = r$1(tt)) && (rt && (rt += " "), (rt += et));
  return rt;
}
function memoize$1(tt) {
  var et = Object.create(null);
  return function (nt) {
    return et[nt] === void 0 && (et[nt] = tt(nt)), et[nt];
  };
}
var reactPropsRegex =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  isPropValid = memoize$1(function (tt) {
    return (
      reactPropsRegex.test(tt) ||
      (tt.charCodeAt(0) === 111 &&
        tt.charCodeAt(1) === 110 &&
        tt.charCodeAt(2) < 91)
    );
  });
function sheetForTag(tt) {
  if (tt.sheet) return tt.sheet;
  for (var et = 0; et < document.styleSheets.length; et++)
    if (document.styleSheets[et].ownerNode === tt)
      return document.styleSheets[et];
}
function createStyleElement(tt) {
  var et = document.createElement("style");
  return (
    et.setAttribute("data-emotion", tt.key),
    tt.nonce !== void 0 && et.setAttribute("nonce", tt.nonce),
    et.appendChild(document.createTextNode("")),
    et.setAttribute("data-s", ""),
    et
  );
}
var StyleSheet = (function () {
    function tt(nt) {
      var rt = this;
      (this._insertTag = function (it) {
        var st;
        rt.tags.length === 0
          ? rt.insertionPoint
            ? (st = rt.insertionPoint.nextSibling)
            : rt.prepend
            ? (st = rt.container.firstChild)
            : (st = rt.before)
          : (st = rt.tags[rt.tags.length - 1].nextSibling),
          rt.container.insertBefore(it, st),
          rt.tags.push(it);
      }),
        (this.isSpeedy = nt.speedy === void 0 ? !0 : nt.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = nt.nonce),
        (this.key = nt.key),
        (this.container = nt.container),
        (this.prepend = nt.prepend),
        (this.insertionPoint = nt.insertionPoint),
        (this.before = null);
    }
    var et = tt.prototype;
    return (
      (et.hydrate = function (rt) {
        rt.forEach(this._insertTag);
      }),
      (et.insert = function (rt) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(createStyleElement(this));
        var it = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var st = sheetForTag(it);
          try {
            st.insertRule(rt, st.cssRules.length);
          } catch {}
        } else it.appendChild(document.createTextNode(rt));
        this.ctr++;
      }),
      (et.flush = function () {
        this.tags.forEach(function (rt) {
          return rt.parentNode && rt.parentNode.removeChild(rt);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      tt
    );
  })(),
  MS = "-ms-",
  MOZ = "-moz-",
  WEBKIT = "-webkit-",
  COMMENT = "comm",
  RULESET = "rule",
  DECLARATION = "decl",
  IMPORT = "@import",
  KEYFRAMES = "@keyframes",
  LAYER = "@layer",
  abs = Math.abs,
  from = String.fromCharCode,
  assign = Object.assign;
function hash$2(tt, et) {
  return charat(tt, 0) ^ 45
    ? (((((((et << 2) ^ charat(tt, 0)) << 2) ^ charat(tt, 1)) << 2) ^
        charat(tt, 2)) <<
        2) ^
        charat(tt, 3)
    : 0;
}
function trim(tt) {
  return tt.trim();
}
function match(tt, et) {
  return (tt = et.exec(tt)) ? tt[0] : tt;
}
function replace(tt, et, nt) {
  return tt.replace(et, nt);
}
function indexof(tt, et) {
  return tt.indexOf(et);
}
function charat(tt, et) {
  return tt.charCodeAt(et) | 0;
}
function substr(tt, et, nt) {
  return tt.slice(et, nt);
}
function strlen(tt) {
  return tt.length;
}
function sizeof(tt) {
  return tt.length;
}
function append(tt, et) {
  return et.push(tt), tt;
}
function combine(tt, et) {
  return tt.map(et).join("");
}
var line = 1,
  column = 1,
  length = 0,
  position = 0,
  character = 0,
  characters = "";
function node(tt, et, nt, rt, it, st, ot) {
  return {
    value: tt,
    root: et,
    parent: nt,
    type: rt,
    props: it,
    children: st,
    line,
    column,
    length: ot,
    return: "",
  };
}
function copy(tt, et) {
  return assign(
    node("", null, null, "", null, null, 0),
    tt,
    { length: -tt.length },
    et
  );
}
function char() {
  return character;
}
function prev() {
  return (
    (character = position > 0 ? charat(characters, --position) : 0),
    column--,
    character === 10 && ((column = 1), line--),
    character
  );
}
function next() {
  return (
    (character = position < length ? charat(characters, position++) : 0),
    column++,
    character === 10 && ((column = 1), line++),
    character
  );
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(tt, et) {
  return substr(characters, tt, et);
}
function token(tt) {
  switch (tt) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(tt) {
  return (
    (line = column = 1),
    (length = strlen((characters = tt))),
    (position = 0),
    []
  );
}
function dealloc(tt) {
  return (characters = ""), tt;
}
function delimit(tt) {
  return trim(
    slice(position - 1, delimiter(tt === 91 ? tt + 2 : tt === 40 ? tt + 1 : tt))
  );
}
function whitespace(tt) {
  for (; (character = peek()) && character < 33; ) next();
  return token(tt) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(tt, et) {
  for (
    ;
    --et &&
    next() &&
    !(
      character < 48 ||
      character > 102 ||
      (character > 57 && character < 65) ||
      (character > 70 && character < 97)
    );

  );
  return slice(tt, caret() + (et < 6 && peek() == 32 && next() == 32));
}
function delimiter(tt) {
  for (; next(); )
    switch (character) {
      case tt:
        return position;
      case 34:
      case 39:
        tt !== 34 && tt !== 39 && delimiter(character);
        break;
      case 40:
        tt === 41 && delimiter(tt);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(tt, et) {
  for (; next() && tt + character !== 47 + 10; )
    if (tt + character === 42 + 42 && peek() === 47) break;
  return "/*" + slice(et, position - 1) + "*" + from(tt === 47 ? tt : next());
}
function identifier(tt) {
  for (; !token(peek()); ) next();
  return slice(tt, position);
}
function compile(tt) {
  return dealloc(
    parse("", null, null, null, [""], (tt = alloc(tt)), 0, [0], tt)
  );
}
function parse(tt, et, nt, rt, it, st, ot, at, lt) {
  for (
    var ct = 0,
      ut = 0,
      ft = ot,
      ht = 0,
      mt = 0,
      vt = 0,
      yt = 1,
      Et = 1,
      pt = 1,
      xt = 0,
      St = "",
      At = it,
      Ct = st,
      Mt = rt,
      wt = St;
    Et;

  )
    switch (((vt = xt), (xt = next()))) {
      case 40:
        if (vt != 108 && charat(wt, ft - 1) == 58) {
          indexof((wt += replace(delimit(xt), "&", "&\f")), "&\f") != -1 &&
            (pt = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        wt += delimit(xt);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        wt += whitespace(vt);
        break;
      case 92:
        wt += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), et, nt), lt);
            break;
          default:
            wt += "/";
        }
        break;
      case 123 * yt:
        at[ct++] = strlen(wt) * pt;
      case 125 * yt:
      case 59:
      case 0:
        switch (xt) {
          case 0:
          case 125:
            Et = 0;
          case 59 + ut:
            pt == -1 && (wt = replace(wt, /\f/g, "")),
              mt > 0 &&
                strlen(wt) - ft &&
                append(
                  mt > 32
                    ? declaration(wt + ";", rt, nt, ft - 1)
                    : declaration(replace(wt, " ", "") + ";", rt, nt, ft - 2),
                  lt
                );
            break;
          case 59:
            wt += ";";
          default:
            if (
              (append(
                (Mt = ruleset(
                  wt,
                  et,
                  nt,
                  ct,
                  ut,
                  it,
                  at,
                  St,
                  (At = []),
                  (Ct = []),
                  ft
                )),
                st
              ),
              xt === 123)
            )
              if (ut === 0) parse(wt, et, Mt, Mt, At, st, ft, at, Ct);
              else
                switch (ht === 99 && charat(wt, 3) === 110 ? 100 : ht) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(
                      tt,
                      Mt,
                      Mt,
                      rt &&
                        append(
                          ruleset(
                            tt,
                            Mt,
                            Mt,
                            0,
                            0,
                            it,
                            at,
                            St,
                            it,
                            (At = []),
                            ft
                          ),
                          Ct
                        ),
                      it,
                      Ct,
                      ft,
                      at,
                      rt ? At : Ct
                    );
                    break;
                  default:
                    parse(wt, Mt, Mt, Mt, [""], Ct, 0, at, Ct);
                }
        }
        (ct = ut = mt = 0), (yt = pt = 1), (St = wt = ""), (ft = ot);
        break;
      case 58:
        (ft = 1 + strlen(wt)), (mt = vt);
      default:
        if (yt < 1) {
          if (xt == 123) --yt;
          else if (xt == 125 && yt++ == 0 && prev() == 125) continue;
        }
        switch (((wt += from(xt)), xt * yt)) {
          case 38:
            pt = ut > 0 ? 1 : ((wt += "\f"), -1);
            break;
          case 44:
            (at[ct++] = (strlen(wt) - 1) * pt), (pt = 1);
            break;
          case 64:
            peek() === 45 && (wt += delimit(next())),
              (ht = peek()),
              (ut = ft = strlen((St = wt += identifier(caret())))),
              xt++;
            break;
          case 45:
            vt === 45 && strlen(wt) == 2 && (yt = 0);
        }
    }
  return st;
}
function ruleset(tt, et, nt, rt, it, st, ot, at, lt, ct, ut) {
  for (
    var ft = it - 1,
      ht = it === 0 ? st : [""],
      mt = sizeof(ht),
      vt = 0,
      yt = 0,
      Et = 0;
    vt < rt;
    ++vt
  )
    for (
      var pt = 0, xt = substr(tt, ft + 1, (ft = abs((yt = ot[vt])))), St = tt;
      pt < mt;
      ++pt
    )
      (St = trim(yt > 0 ? ht[pt] + " " + xt : replace(xt, /&\f/g, ht[pt]))) &&
        (lt[Et++] = St);
  return node(tt, et, nt, it === 0 ? RULESET : at, lt, ct, ut);
}
function comment(tt, et, nt) {
  return node(tt, et, nt, COMMENT, from(char()), substr(tt, 2, -2), 0);
}
function declaration(tt, et, nt, rt) {
  return node(
    tt,
    et,
    nt,
    DECLARATION,
    substr(tt, 0, rt),
    substr(tt, rt + 1, -1),
    rt
  );
}
function serialize(tt, et) {
  for (var nt = "", rt = sizeof(tt), it = 0; it < rt; it++)
    nt += et(tt[it], it, tt, et) || "";
  return nt;
}
function stringify(tt, et, nt, rt) {
  switch (tt.type) {
    case LAYER:
      if (tt.children.length) break;
    case IMPORT:
    case DECLARATION:
      return (tt.return = tt.return || tt.value);
    case COMMENT:
      return "";
    case KEYFRAMES:
      return (tt.return = tt.value + "{" + serialize(tt.children, rt) + "}");
    case RULESET:
      tt.value = tt.props.join(",");
  }
  return strlen((nt = serialize(tt.children, rt)))
    ? (tt.return = tt.value + "{" + nt + "}")
    : "";
}
function middleware(tt) {
  var et = sizeof(tt);
  return function (nt, rt, it, st) {
    for (var ot = "", at = 0; at < et; at++) ot += tt[at](nt, rt, it, st) || "";
    return ot;
  };
}
function rulesheet(tt) {
  return function (et) {
    et.root || ((et = et.return) && tt(et));
  };
}
var identifierWithPointTracking = function (et, nt, rt) {
    for (
      var it = 0, st = 0;
      (it = st),
        (st = peek()),
        it === 38 && st === 12 && (nt[rt] = 1),
        !token(st);

    )
      next();
    return slice(et, position);
  },
  toRules = function (et, nt) {
    var rt = -1,
      it = 44;
    do
      switch (token(it)) {
        case 0:
          it === 38 && peek() === 12 && (nt[rt] = 1),
            (et[rt] += identifierWithPointTracking(position - 1, nt, rt));
          break;
        case 2:
          et[rt] += delimit(it);
          break;
        case 4:
          if (it === 44) {
            (et[++rt] = peek() === 58 ? "&\f" : ""), (nt[rt] = et[rt].length);
            break;
          }
        default:
          et[rt] += from(it);
      }
    while ((it = next()));
    return et;
  },
  getRules = function (et, nt) {
    return dealloc(toRules(alloc(et), nt));
  },
  fixedElements = new WeakMap(),
  compat = function (et) {
    if (!(et.type !== "rule" || !et.parent || et.length < 1)) {
      for (
        var nt = et.value,
          rt = et.parent,
          it = et.column === rt.column && et.line === rt.line;
        rt.type !== "rule";

      )
        if (((rt = rt.parent), !rt)) return;
      if (
        !(
          et.props.length === 1 &&
          nt.charCodeAt(0) !== 58 &&
          !fixedElements.get(rt)
        ) &&
        !it
      ) {
        fixedElements.set(et, !0);
        for (
          var st = [], ot = getRules(nt, st), at = rt.props, lt = 0, ct = 0;
          lt < ot.length;
          lt++
        )
          for (var ut = 0; ut < at.length; ut++, ct++)
            et.props[ct] = st[lt]
              ? ot[lt].replace(/&\f/g, at[ut])
              : at[ut] + " " + ot[lt];
      }
    }
  },
  removeLabel = function (et) {
    if (et.type === "decl") {
      var nt = et.value;
      nt.charCodeAt(0) === 108 &&
        nt.charCodeAt(2) === 98 &&
        ((et.return = ""), (et.value = ""));
    }
  };
function prefix(tt, et) {
  switch (hash$2(tt, et)) {
    case 5103:
      return WEBKIT + "print-" + tt + tt;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + tt + tt;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + tt + MOZ + tt + MS + tt + tt;
    case 6828:
    case 4268:
      return WEBKIT + tt + MS + tt + tt;
    case 6165:
      return WEBKIT + tt + MS + "flex-" + tt + tt;
    case 5187:
      return (
        WEBKIT +
        tt +
        replace(tt, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") +
        tt
      );
    case 5443:
      return (
        WEBKIT + tt + MS + "flex-item-" + replace(tt, /flex-|-self/, "") + tt
      );
    case 4675:
      return (
        WEBKIT +
        tt +
        MS +
        "flex-line-pack" +
        replace(tt, /align-content|flex-|-self/, "") +
        tt
      );
    case 5548:
      return WEBKIT + tt + MS + replace(tt, "shrink", "negative") + tt;
    case 5292:
      return WEBKIT + tt + MS + replace(tt, "basis", "preferred-size") + tt;
    case 6060:
      return (
        WEBKIT +
        "box-" +
        replace(tt, "-grow", "") +
        WEBKIT +
        tt +
        MS +
        replace(tt, "grow", "positive") +
        tt
      );
    case 4554:
      return (
        WEBKIT + replace(tt, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + tt
      );
    case 6187:
      return (
        replace(
          replace(
            replace(tt, /(zoom-|grab)/, WEBKIT + "$1"),
            /(image-set)/,
            WEBKIT + "$1"
          ),
          tt,
          ""
        ) + tt
      );
    case 5495:
    case 3959:
      return replace(tt, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return (
        replace(
          replace(
            tt,
            /(.+:)(flex-)?(.*)/,
            WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"
          ),
          /s.+-b[^;]+/,
          "justify"
        ) +
        WEBKIT +
        tt +
        tt
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(tt, /(.+)-inline(.+)/, WEBKIT + "$1$2") + tt;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(tt) - 1 - et > 6)
        switch (charat(tt, et + 1)) {
          case 109:
            if (charat(tt, et + 4) !== 45) break;
          case 102:
            return (
              replace(
                tt,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  WEBKIT +
                  "$2-$3$1" +
                  MOZ +
                  (charat(tt, et + 3) == 108 ? "$3" : "$2-$3")
              ) + tt
            );
          case 115:
            return ~indexof(tt, "stretch")
              ? prefix(replace(tt, "stretch", "fill-available"), et) + tt
              : tt;
        }
      break;
    case 4949:
      if (charat(tt, et + 1) !== 115) break;
    case 6444:
      switch (charat(tt, strlen(tt) - 3 - (~indexof(tt, "!important") && 10))) {
        case 107:
          return replace(tt, ":", ":" + WEBKIT) + tt;
        case 101:
          return (
            replace(
              tt,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                WEBKIT +
                (charat(tt, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                WEBKIT +
                "$2$3$1" +
                MS +
                "$2box$3"
            ) + tt
          );
      }
      break;
    case 5936:
      switch (charat(tt, et + 11)) {
        case 114:
          return (
            WEBKIT + tt + MS + replace(tt, /[svh]\w+-[tblr]{2}/, "tb") + tt
          );
        case 108:
          return (
            WEBKIT + tt + MS + replace(tt, /[svh]\w+-[tblr]{2}/, "tb-rl") + tt
          );
        case 45:
          return (
            WEBKIT + tt + MS + replace(tt, /[svh]\w+-[tblr]{2}/, "lr") + tt
          );
      }
      return WEBKIT + tt + MS + tt + tt;
  }
  return tt;
}
var prefixer = function (et, nt, rt, it) {
    if (et.length > -1 && !et.return)
      switch (et.type) {
        case DECLARATION:
          et.return = prefix(et.value, et.length);
          break;
        case KEYFRAMES:
          return serialize(
            [copy(et, { value: replace(et.value, "@", "@" + WEBKIT) })],
            it
          );
        case RULESET:
          if (et.length)
            return combine(et.props, function (st) {
              switch (match(st, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize(
                    [
                      copy(et, {
                        props: [replace(st, /:(read-\w+)/, ":" + MOZ + "$1")],
                      }),
                    ],
                    it
                  );
                case "::placeholder":
                  return serialize(
                    [
                      copy(et, {
                        props: [
                          replace(st, /:(plac\w+)/, ":" + WEBKIT + "input-$1"),
                        ],
                      }),
                      copy(et, {
                        props: [replace(st, /:(plac\w+)/, ":" + MOZ + "$1")],
                      }),
                      copy(et, {
                        props: [replace(st, /:(plac\w+)/, MS + "input-$1")],
                      }),
                    ],
                    it
                  );
              }
              return "";
            });
      }
  },
  defaultStylisPlugins = [prefixer],
  createCache = function (et) {
    var nt = et.key;
    if (nt === "css") {
      var rt = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(rt, function (yt) {
        var Et = yt.getAttribute("data-emotion");
        Et.indexOf(" ") !== -1 &&
          (document.head.appendChild(yt), yt.setAttribute("data-s", ""));
      });
    }
    var it = et.stylisPlugins || defaultStylisPlugins,
      st = {},
      ot,
      at = [];
    (ot = et.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + nt + ' "]'),
        function (yt) {
          for (
            var Et = yt.getAttribute("data-emotion").split(" "), pt = 1;
            pt < Et.length;
            pt++
          )
            st[Et[pt]] = !0;
          at.push(yt);
        }
      );
    var lt,
      ct = [compat, removeLabel];
    {
      var ut,
        ft = [
          stringify,
          rulesheet(function (yt) {
            ut.insert(yt);
          }),
        ],
        ht = middleware(ct.concat(it, ft)),
        mt = function (Et) {
          return serialize(compile(Et), ht);
        };
      lt = function (Et, pt, xt, St) {
        (ut = xt),
          mt(Et ? Et + "{" + pt.styles + "}" : pt.styles),
          St && (vt.inserted[pt.name] = !0);
      };
    }
    var vt = {
      key: nt,
      sheet: new StyleSheet({
        key: nt,
        container: ot,
        nonce: et.nonce,
        speedy: et.speedy,
        prepend: et.prepend,
        insertionPoint: et.insertionPoint,
      }),
      nonce: et.nonce,
      inserted: st,
      registered: {},
      insert: lt,
    };
    return vt.sheet.hydrate(at), vt;
  },
  isBrowser = !0;
function getRegisteredStyles(tt, et, nt) {
  var rt = "";
  return (
    nt.split(" ").forEach(function (it) {
      tt[it] !== void 0 ? et.push(tt[it] + ";") : (rt += it + " ");
    }),
    rt
  );
}
var registerStyles = function (et, nt, rt) {
    var it = et.key + "-" + nt.name;
    (rt === !1 || isBrowser === !1) &&
      et.registered[it] === void 0 &&
      (et.registered[it] = nt.styles);
  },
  insertStyles = function (et, nt, rt) {
    registerStyles(et, nt, rt);
    var it = et.key + "-" + nt.name;
    if (et.inserted[nt.name] === void 0) {
      var st = nt;
      do et.insert(nt === st ? "." + it : "", st, et.sheet, !0), (st = st.next);
      while (st !== void 0);
    }
  };
function murmur2(tt) {
  for (var et = 0, nt, rt = 0, it = tt.length; it >= 4; ++rt, it -= 4)
    (nt =
      (tt.charCodeAt(rt) & 255) |
      ((tt.charCodeAt(++rt) & 255) << 8) |
      ((tt.charCodeAt(++rt) & 255) << 16) |
      ((tt.charCodeAt(++rt) & 255) << 24)),
      (nt = (nt & 65535) * 1540483477 + (((nt >>> 16) * 59797) << 16)),
      (nt ^= nt >>> 24),
      (et =
        ((nt & 65535) * 1540483477 + (((nt >>> 16) * 59797) << 16)) ^
        ((et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16)));
  switch (it) {
    case 3:
      et ^= (tt.charCodeAt(rt + 2) & 255) << 16;
    case 2:
      et ^= (tt.charCodeAt(rt + 1) & 255) << 8;
    case 1:
      (et ^= tt.charCodeAt(rt) & 255),
        (et = (et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16));
  }
  return (
    (et ^= et >>> 13),
    (et = (et & 65535) * 1540483477 + (((et >>> 16) * 59797) << 16)),
    ((et ^ (et >>> 15)) >>> 0).toString(36)
  );
}
var unitlessKeys$1 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  hyphenateRegex = /[A-Z]|^ms/g,
  animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  isCustomProperty = function (et) {
    return et.charCodeAt(1) === 45;
  },
  isProcessableValue = function (et) {
    return et != null && typeof et != "boolean";
  },
  processStyleName = memoize$1(function (tt) {
    return isCustomProperty(tt)
      ? tt
      : tt.replace(hyphenateRegex, "-$&").toLowerCase();
  }),
  processStyleValue = function (et, nt) {
    switch (et) {
      case "animation":
      case "animationName":
        if (typeof nt == "string")
          return nt.replace(animationRegex, function (rt, it, st) {
            return (cursor = { name: it, styles: st, next: cursor }), it;
          });
    }
    return unitlessKeys$1[et] !== 1 &&
      !isCustomProperty(et) &&
      typeof nt == "number" &&
      nt !== 0
      ? nt + "px"
      : nt;
  },
  noComponentSelectorMessage =
    "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(tt, et, nt) {
  if (nt == null) return "";
  if (nt.__emotion_styles !== void 0) return nt;
  switch (typeof nt) {
    case "boolean":
      return "";
    case "object": {
      if (nt.anim === 1)
        return (
          (cursor = { name: nt.name, styles: nt.styles, next: cursor }), nt.name
        );
      if (nt.styles !== void 0) {
        var rt = nt.next;
        if (rt !== void 0)
          for (; rt !== void 0; )
            (cursor = { name: rt.name, styles: rt.styles, next: cursor }),
              (rt = rt.next);
        var it = nt.styles + ";";
        return it;
      }
      return createStringFromObject(tt, et, nt);
    }
    case "function": {
      if (tt !== void 0) {
        var st = cursor,
          ot = nt(tt);
        return (cursor = st), handleInterpolation(tt, et, ot);
      }
      break;
    }
  }
  if (et == null) return nt;
  var at = et[nt];
  return at !== void 0 ? at : nt;
}
function createStringFromObject(tt, et, nt) {
  var rt = "";
  if (Array.isArray(nt))
    for (var it = 0; it < nt.length; it++)
      rt += handleInterpolation(tt, et, nt[it]) + ";";
  else
    for (var st in nt) {
      var ot = nt[st];
      if (typeof ot != "object")
        et != null && et[ot] !== void 0
          ? (rt += st + "{" + et[ot] + "}")
          : isProcessableValue(ot) &&
            (rt +=
              processStyleName(st) + ":" + processStyleValue(st, ot) + ";");
      else if (
        Array.isArray(ot) &&
        typeof ot[0] == "string" &&
        (et == null || et[ot[0]] === void 0)
      )
        for (var at = 0; at < ot.length; at++)
          isProcessableValue(ot[at]) &&
            (rt +=
              processStyleName(st) + ":" + processStyleValue(st, ot[at]) + ";");
      else {
        var lt = handleInterpolation(tt, et, ot);
        switch (st) {
          case "animation":
          case "animationName": {
            rt += processStyleName(st) + ":" + lt + ";";
            break;
          }
          default:
            rt += st + "{" + lt + "}";
        }
      }
    }
  return rt;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
  cursor,
  serializeStyles = function (et, nt, rt) {
    if (
      et.length === 1 &&
      typeof et[0] == "object" &&
      et[0] !== null &&
      et[0].styles !== void 0
    )
      return et[0];
    var it = !0,
      st = "";
    cursor = void 0;
    var ot = et[0];
    ot == null || ot.raw === void 0
      ? ((it = !1), (st += handleInterpolation(rt, nt, ot)))
      : (st += ot[0]);
    for (var at = 1; at < et.length; at++)
      (st += handleInterpolation(rt, nt, et[at])), it && (st += ot[at]);
    labelPattern.lastIndex = 0;
    for (var lt = "", ct; (ct = labelPattern.exec(st)) !== null; )
      lt += "-" + ct[1];
    var ut = murmur2(st) + lt;
    return { name: ut, styles: st, next: cursor };
  },
  syncFallback = function (et) {
    return et();
  },
  useInsertionEffect = React$1["useInsertionEffect"]
    ? React$1["useInsertionEffect"]
    : !1,
  useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback,
  EmotionCacheContext = reactExports.createContext(
    typeof HTMLElement < "u" ? createCache({ key: "css" }) : null
  );
EmotionCacheContext.Provider;
var withEmotionCache = function (et) {
    return reactExports.forwardRef(function (nt, rt) {
      var it = reactExports.useContext(EmotionCacheContext);
      return et(nt, it, rt);
    });
  },
  ThemeContext = reactExports.createContext({});
function css() {
  for (var tt = arguments.length, et = new Array(tt), nt = 0; nt < tt; nt++)
    et[nt] = arguments[nt];
  return serializeStyles(et);
}
var keyframes = function () {
    var et = css.apply(void 0, arguments),
      nt = "animation-" + et.name;
    return {
      name: nt,
      styles: "@keyframes " + nt + "{" + et.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  testOmitPropsOnStringTag = isPropValid,
  testOmitPropsOnComponent = function (et) {
    return et !== "theme";
  },
  getDefaultShouldForwardProp = function (et) {
    return typeof et == "string" && et.charCodeAt(0) > 96
      ? testOmitPropsOnStringTag
      : testOmitPropsOnComponent;
  },
  composeShouldForwardProps = function (et, nt, rt) {
    var it;
    if (nt) {
      var st = nt.shouldForwardProp;
      it =
        et.__emotion_forwardProp && st
          ? function (ot) {
              return et.__emotion_forwardProp(ot) && st(ot);
            }
          : st;
    }
    return typeof it != "function" && rt && (it = et.__emotion_forwardProp), it;
  },
  Insertion = function (et) {
    var nt = et.cache,
      rt = et.serialized,
      it = et.isStringTag;
    return (
      registerStyles(nt, rt, it),
      useInsertionEffectAlwaysWithSyncFallback(function () {
        return insertStyles(nt, rt, it);
      }),
      null
    );
  },
  createStyled$1 = function tt(et, nt) {
    var rt = et.__emotion_real === et,
      it = (rt && et.__emotion_base) || et,
      st,
      ot;
    nt !== void 0 && ((st = nt.label), (ot = nt.target));
    var at = composeShouldForwardProps(et, nt, rt),
      lt = at || getDefaultShouldForwardProp(it),
      ct = !lt("as");
    return function () {
      var ut = arguments,
        ft =
          rt && et.__emotion_styles !== void 0
            ? et.__emotion_styles.slice(0)
            : [];
      if (
        (st !== void 0 && ft.push("label:" + st + ";"),
        ut[0] == null || ut[0].raw === void 0)
      )
        ft.push.apply(ft, ut);
      else {
        ft.push(ut[0][0]);
        for (var ht = ut.length, mt = 1; mt < ht; mt++)
          ft.push(ut[mt], ut[0][mt]);
      }
      var vt = withEmotionCache(function (yt, Et, pt) {
        var xt = (ct && yt.as) || it,
          St = "",
          At = [],
          Ct = yt;
        if (yt.theme == null) {
          Ct = {};
          for (var Mt in yt) Ct[Mt] = yt[Mt];
          Ct.theme = reactExports.useContext(ThemeContext);
        }
        typeof yt.className == "string"
          ? (St = getRegisteredStyles(Et.registered, At, yt.className))
          : yt.className != null && (St = yt.className + " ");
        var wt = serializeStyles(ft.concat(At), Et.registered, Ct);
        (St += Et.key + "-" + wt.name), ot !== void 0 && (St += " " + ot);
        var Bt = ct && at === void 0 ? getDefaultShouldForwardProp(xt) : lt,
          It = {};
        for (var Ft in yt) (ct && Ft === "as") || (Bt(Ft) && (It[Ft] = yt[Ft]));
        return (
          (It.className = St),
          (It.ref = pt),
          reactExports.createElement(
            reactExports.Fragment,
            null,
            reactExports.createElement(Insertion, {
              cache: Et,
              serialized: wt,
              isStringTag: typeof xt == "string",
            }),
            reactExports.createElement(xt, It)
          )
        );
      });
      return (
        (vt.displayName =
          st !== void 0
            ? st
            : "Styled(" +
              (typeof it == "string"
                ? it
                : it.displayName || it.name || "Component") +
              ")"),
        (vt.defaultProps = et.defaultProps),
        (vt.__emotion_real = vt),
        (vt.__emotion_base = it),
        (vt.__emotion_styles = ft),
        (vt.__emotion_forwardProp = at),
        Object.defineProperty(vt, "toString", {
          value: function () {
            return "." + ot;
          },
        }),
        (vt.withComponent = function (yt, Et) {
          return tt(
            yt,
            _extends({}, nt, Et, {
              shouldForwardProp: composeShouldForwardProps(vt, Et, !0),
            })
          ).apply(void 0, ft);
        }),
        vt
      );
    };
  },
  tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  newStyled = createStyled$1.bind();
tags.forEach(function (tt) {
  newStyled[tt] = newStyled(tt);
});
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f$1 = reactExports,
  k$2 = Symbol.for("react.element"),
  l$1 = Symbol.for("react.fragment"),
  m$1 = Object.prototype.hasOwnProperty,
  n$1 =
    f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p$1 = { key: !0, ref: !0, __self: !0, __source: !0 };
function q$2(tt, et, nt) {
  var rt,
    it = {},
    st = null,
    ot = null;
  nt !== void 0 && (st = "" + nt),
    et.key !== void 0 && (st = "" + et.key),
    et.ref !== void 0 && (ot = et.ref);
  for (rt in et)
    m$1.call(et, rt) && !p$1.hasOwnProperty(rt) && (it[rt] = et[rt]);
  if (tt && tt.defaultProps)
    for (rt in ((et = tt.defaultProps), et))
      it[rt] === void 0 && (it[rt] = et[rt]);
  return {
    $$typeof: k$2,
    type: tt,
    key: st,
    ref: ot,
    props: it,
    _owner: n$1.current,
  };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports;
/**
 * @mui/styled-engine v5.14.16
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function styled$3(tt, et) {
  return newStyled(tt, et);
}
const internal_processStyles = (tt, et) => {
    Array.isArray(tt.__emotion_styles) &&
      (tt.__emotion_styles = et(tt.__emotion_styles));
  },
  _excluded$s = ["values", "unit", "step"],
  sortBreakpointsValues = (tt) => {
    const et = Object.keys(tt).map((nt) => ({ key: nt, val: tt[nt] })) || [];
    return (
      et.sort((nt, rt) => nt.val - rt.val),
      et.reduce((nt, rt) => _extends({}, nt, { [rt.key]: rt.val }), {})
    );
  };
function createBreakpoints(tt) {
  const {
      values: et = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: nt = "px",
      step: rt = 5,
    } = tt,
    it = _objectWithoutPropertiesLoose(tt, _excluded$s),
    st = sortBreakpointsValues(et),
    ot = Object.keys(st);
  function at(ht) {
    return `@media (min-width:${typeof et[ht] == "number" ? et[ht] : ht}${nt})`;
  }
  function lt(ht) {
    return `@media (max-width:${
      (typeof et[ht] == "number" ? et[ht] : ht) - rt / 100
    }${nt})`;
  }
  function ct(ht, mt) {
    const vt = ot.indexOf(mt);
    return `@media (min-width:${
      typeof et[ht] == "number" ? et[ht] : ht
    }${nt}) and (max-width:${
      (vt !== -1 && typeof et[ot[vt]] == "number" ? et[ot[vt]] : mt) - rt / 100
    }${nt})`;
  }
  function ut(ht) {
    return ot.indexOf(ht) + 1 < ot.length
      ? ct(ht, ot[ot.indexOf(ht) + 1])
      : at(ht);
  }
  function ft(ht) {
    const mt = ot.indexOf(ht);
    return mt === 0
      ? at(ot[1])
      : mt === ot.length - 1
      ? lt(ot[mt])
      : ct(ht, ot[ot.indexOf(ht) + 1]).replace("@media", "@media not all and");
  }
  return _extends(
    {
      keys: ot,
      values: st,
      up: at,
      down: lt,
      between: ct,
      only: ut,
      not: ft,
      unit: nt,
    },
    it
  );
}
const shape = { borderRadius: 4 },
  shape$1 = shape;
function merge(tt, et) {
  return et ? deepmerge(tt, et, { clone: !1 }) : tt;
}
const values$1 = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  defaultBreakpoints = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (tt) => `@media (min-width:${values$1[tt]}px)`,
  };
function handleBreakpoints(tt, et, nt) {
  const rt = tt.theme || {};
  if (Array.isArray(et)) {
    const st = rt.breakpoints || defaultBreakpoints;
    return et.reduce(
      (ot, at, lt) => ((ot[st.up(st.keys[lt])] = nt(et[lt])), ot),
      {}
    );
  }
  if (typeof et == "object") {
    const st = rt.breakpoints || defaultBreakpoints;
    return Object.keys(et).reduce((ot, at) => {
      if (Object.keys(st.values || values$1).indexOf(at) !== -1) {
        const lt = st.up(at);
        ot[lt] = nt(et[at], at);
      } else {
        const lt = at;
        ot[lt] = et[lt];
      }
      return ot;
    }, {});
  }
  return nt(et);
}
function createEmptyBreakpointObject(tt = {}) {
  var et;
  return (
    ((et = tt.keys) == null
      ? void 0
      : et.reduce((rt, it) => {
          const st = tt.up(it);
          return (rt[st] = {}), rt;
        }, {})) || {}
  );
}
function removeUnusedBreakpoints(tt, et) {
  return tt.reduce((nt, rt) => {
    const it = nt[rt];
    return (!it || Object.keys(it).length === 0) && delete nt[rt], nt;
  }, et);
}
function getPath$1(tt, et, nt = !0) {
  if (!et || typeof et != "string") return null;
  if (tt && tt.vars && nt) {
    const rt = `vars.${et}`
      .split(".")
      .reduce((it, st) => (it && it[st] ? it[st] : null), tt);
    if (rt != null) return rt;
  }
  return et
    .split(".")
    .reduce((rt, it) => (rt && rt[it] != null ? rt[it] : null), tt);
}
function getStyleValue(tt, et, nt, rt = nt) {
  let it;
  return (
    typeof tt == "function"
      ? (it = tt(nt))
      : Array.isArray(tt)
      ? (it = tt[nt] || rt)
      : (it = getPath$1(tt, nt) || rt),
    et && (it = et(it, rt, tt)),
    it
  );
}
function style$1(tt) {
  const {
      prop: et,
      cssProperty: nt = tt.prop,
      themeKey: rt,
      transform: it,
    } = tt,
    st = (ot) => {
      if (ot[et] == null) return null;
      const at = ot[et],
        lt = ot.theme,
        ct = getPath$1(lt, rt) || {};
      return handleBreakpoints(ot, at, (ft) => {
        let ht = getStyleValue(ct, it, ft);
        return (
          ft === ht &&
            typeof ft == "string" &&
            (ht = getStyleValue(
              ct,
              it,
              `${et}${ft === "default" ? "" : capitalize(ft)}`,
              ft
            )),
          nt === !1 ? ht : { [nt]: ht }
        );
      });
    };
  return (st.propTypes = {}), (st.filterProps = [et]), st;
}
function memoize(tt) {
  const et = {};
  return (nt) => (et[nt] === void 0 && (et[nt] = tt(nt)), et[nt]);
}
const properties = { m: "margin", p: "padding" },
  directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  aliases = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  getCssProperties = memoize((tt) => {
    if (tt.length > 2)
      if (aliases[tt]) tt = aliases[tt];
      else return [tt];
    const [et, nt] = tt.split(""),
      rt = properties[et],
      it = directions[nt] || "";
    return Array.isArray(it) ? it.map((st) => rt + st) : [rt + it];
  }),
  marginKeys = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  paddingKeys = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(tt, et, nt, rt) {
  var it;
  const st = (it = getPath$1(tt, et, !1)) != null ? it : nt;
  return typeof st == "number"
    ? (ot) => (typeof ot == "string" ? ot : st * ot)
    : Array.isArray(st)
    ? (ot) => (typeof ot == "string" ? ot : st[ot])
    : typeof st == "function"
    ? st
    : () => {};
}
function createUnarySpacing(tt) {
  return createUnaryUnit(tt, "spacing", 8);
}
function getValue(tt, et) {
  if (typeof et == "string" || et == null) return et;
  const nt = Math.abs(et),
    rt = tt(nt);
  return et >= 0 ? rt : typeof rt == "number" ? -rt : `-${rt}`;
}
function getStyleFromPropValue(tt, et) {
  return (nt) => tt.reduce((rt, it) => ((rt[it] = getValue(et, nt)), rt), {});
}
function resolveCssProperty(tt, et, nt, rt) {
  if (et.indexOf(nt) === -1) return null;
  const it = getCssProperties(nt),
    st = getStyleFromPropValue(it, rt),
    ot = tt[nt];
  return handleBreakpoints(tt, ot, st);
}
function style(tt, et) {
  const nt = createUnarySpacing(tt.theme);
  return Object.keys(tt)
    .map((rt) => resolveCssProperty(tt, et, rt, nt))
    .reduce(merge, {});
}
function margin(tt) {
  return style(tt, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(tt) {
  return style(tt, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(tt = 8) {
  if (tt.mui) return tt;
  const et = createUnarySpacing({ spacing: tt }),
    nt = (...rt) =>
      (rt.length === 0 ? [1] : rt)
        .map((st) => {
          const ot = et(st);
          return typeof ot == "number" ? `${ot}px` : ot;
        })
        .join(" ");
  return (nt.mui = !0), nt;
}
function compose$1(...tt) {
  const et = tt.reduce(
      (rt, it) => (
        it.filterProps.forEach((st) => {
          rt[st] = it;
        }),
        rt
      ),
      {}
    ),
    nt = (rt) =>
      Object.keys(rt).reduce(
        (it, st) => (et[st] ? merge(it, et[st](rt)) : it),
        {}
      );
  return (
    (nt.propTypes = {}),
    (nt.filterProps = tt.reduce((rt, it) => rt.concat(it.filterProps), [])),
    nt
  );
}
function borderTransform(tt) {
  return typeof tt != "number" ? tt : `${tt}px solid`;
}
const border = style$1({
    prop: "border",
    themeKey: "borders",
    transform: borderTransform,
  }),
  borderTop = style$1({
    prop: "borderTop",
    themeKey: "borders",
    transform: borderTransform,
  }),
  borderRight = style$1({
    prop: "borderRight",
    themeKey: "borders",
    transform: borderTransform,
  }),
  borderBottom = style$1({
    prop: "borderBottom",
    themeKey: "borders",
    transform: borderTransform,
  }),
  borderLeft = style$1({
    prop: "borderLeft",
    themeKey: "borders",
    transform: borderTransform,
  }),
  borderColor = style$1({ prop: "borderColor", themeKey: "palette" }),
  borderTopColor = style$1({ prop: "borderTopColor", themeKey: "palette" }),
  borderRightColor = style$1({ prop: "borderRightColor", themeKey: "palette" }),
  borderBottomColor = style$1({
    prop: "borderBottomColor",
    themeKey: "palette",
  }),
  borderLeftColor = style$1({ prop: "borderLeftColor", themeKey: "palette" }),
  borderRadius = (tt) => {
    if (tt.borderRadius !== void 0 && tt.borderRadius !== null) {
      const et = createUnaryUnit(tt.theme, "shape.borderRadius", 4),
        nt = (rt) => ({ borderRadius: getValue(et, rt) });
      return handleBreakpoints(tt, tt.borderRadius, nt);
    }
    return null;
  };
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose$1(
  border,
  borderTop,
  borderRight,
  borderBottom,
  borderLeft,
  borderColor,
  borderTopColor,
  borderRightColor,
  borderBottomColor,
  borderLeftColor,
  borderRadius
);
const gap = (tt) => {
  if (tt.gap !== void 0 && tt.gap !== null) {
    const et = createUnaryUnit(tt.theme, "spacing", 8),
      nt = (rt) => ({ gap: getValue(et, rt) });
    return handleBreakpoints(tt, tt.gap, nt);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (tt) => {
  if (tt.columnGap !== void 0 && tt.columnGap !== null) {
    const et = createUnaryUnit(tt.theme, "spacing", 8),
      nt = (rt) => ({ columnGap: getValue(et, rt) });
    return handleBreakpoints(tt, tt.columnGap, nt);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (tt) => {
  if (tt.rowGap !== void 0 && tt.rowGap !== null) {
    const et = createUnaryUnit(tt.theme, "spacing", 8),
      nt = (rt) => ({ rowGap: getValue(et, rt) });
    return handleBreakpoints(tt, tt.rowGap, nt);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({ prop: "gridColumn" }),
  gridRow = style$1({ prop: "gridRow" }),
  gridAutoFlow = style$1({ prop: "gridAutoFlow" }),
  gridAutoColumns = style$1({ prop: "gridAutoColumns" }),
  gridAutoRows = style$1({ prop: "gridAutoRows" }),
  gridTemplateColumns = style$1({ prop: "gridTemplateColumns" }),
  gridTemplateRows = style$1({ prop: "gridTemplateRows" }),
  gridTemplateAreas = style$1({ prop: "gridTemplateAreas" }),
  gridArea = style$1({ prop: "gridArea" });
compose$1(
  gap,
  columnGap,
  rowGap,
  gridColumn,
  gridRow,
  gridAutoFlow,
  gridAutoColumns,
  gridAutoRows,
  gridTemplateColumns,
  gridTemplateRows,
  gridTemplateAreas,
  gridArea
);
function paletteTransform(tt, et) {
  return et === "grey" ? et : tt;
}
const color = style$1({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform,
  }),
  bgcolor = style$1({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform,
  }),
  backgroundColor = style$1({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform,
  });
compose$1(color, bgcolor, backgroundColor);
function sizingTransform(tt) {
  return tt <= 1 && tt !== 0 ? `${tt * 100}%` : tt;
}
const width = style$1({ prop: "width", transform: sizingTransform }),
  maxWidth = (tt) => {
    if (tt.maxWidth !== void 0 && tt.maxWidth !== null) {
      const et = (nt) => {
        var rt, it;
        const st =
          ((rt = tt.theme) == null ||
          (rt = rt.breakpoints) == null ||
          (rt = rt.values) == null
            ? void 0
            : rt[nt]) || values$1[nt];
        return st
          ? ((it = tt.theme) == null || (it = it.breakpoints) == null
              ? void 0
              : it.unit) !== "px"
            ? { maxWidth: `${st}${tt.theme.breakpoints.unit}` }
            : { maxWidth: st }
          : { maxWidth: sizingTransform(nt) };
      };
      return handleBreakpoints(tt, tt.maxWidth, et);
    }
    return null;
  };
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({ prop: "minWidth", transform: sizingTransform }),
  height = style$1({ prop: "height", transform: sizingTransform }),
  maxHeight = style$1({ prop: "maxHeight", transform: sizingTransform }),
  minHeight = style$1({ prop: "minHeight", transform: sizingTransform });
style$1({ prop: "size", cssProperty: "width", transform: sizingTransform });
style$1({ prop: "size", cssProperty: "height", transform: sizingTransform });
const boxSizing = style$1({ prop: "boxSizing" });
compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    border: { themeKey: "borders", transform: borderTransform },
    borderTop: { themeKey: "borders", transform: borderTransform },
    borderRight: { themeKey: "borders", transform: borderTransform },
    borderBottom: { themeKey: "borders", transform: borderTransform },
    borderLeft: { themeKey: "borders", transform: borderTransform },
    borderColor: { themeKey: "palette" },
    borderTopColor: { themeKey: "palette" },
    borderRightColor: { themeKey: "palette" },
    borderBottomColor: { themeKey: "palette" },
    borderLeftColor: { themeKey: "palette" },
    borderRadius: { themeKey: "shape.borderRadius", style: borderRadius },
    color: { themeKey: "palette", transform: paletteTransform },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: paletteTransform,
    },
    backgroundColor: { themeKey: "palette", transform: paletteTransform },
    p: { style: padding },
    pt: { style: padding },
    pr: { style: padding },
    pb: { style: padding },
    pl: { style: padding },
    px: { style: padding },
    py: { style: padding },
    padding: { style: padding },
    paddingTop: { style: padding },
    paddingRight: { style: padding },
    paddingBottom: { style: padding },
    paddingLeft: { style: padding },
    paddingX: { style: padding },
    paddingY: { style: padding },
    paddingInline: { style: padding },
    paddingInlineStart: { style: padding },
    paddingInlineEnd: { style: padding },
    paddingBlock: { style: padding },
    paddingBlockStart: { style: padding },
    paddingBlockEnd: { style: padding },
    m: { style: margin },
    mt: { style: margin },
    mr: { style: margin },
    mb: { style: margin },
    ml: { style: margin },
    mx: { style: margin },
    my: { style: margin },
    margin: { style: margin },
    marginTop: { style: margin },
    marginRight: { style: margin },
    marginBottom: { style: margin },
    marginLeft: { style: margin },
    marginX: { style: margin },
    marginY: { style: margin },
    marginInline: { style: margin },
    marginInlineStart: { style: margin },
    marginInlineEnd: { style: margin },
    marginBlock: { style: margin },
    marginBlockStart: { style: margin },
    marginBlockEnd: { style: margin },
    displayPrint: {
      cssProperty: !1,
      transform: (tt) => ({ "@media print": { display: tt } }),
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: { style: gap },
    rowGap: { style: rowGap },
    columnGap: { style: columnGap },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: { themeKey: "zIndex" },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: { themeKey: "shadows" },
    width: { transform: sizingTransform },
    maxWidth: { style: maxWidth },
    minWidth: { transform: sizingTransform },
    height: { transform: sizingTransform },
    maxHeight: { transform: sizingTransform },
    minHeight: { transform: sizingTransform },
    boxSizing: {},
    fontFamily: { themeKey: "typography" },
    fontSize: { themeKey: "typography" },
    fontStyle: { themeKey: "typography" },
    fontWeight: { themeKey: "typography" },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: { cssProperty: !1, themeKey: "typography" },
  },
  defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...tt) {
  const et = tt.reduce((rt, it) => rt.concat(Object.keys(it)), []),
    nt = new Set(et);
  return tt.every((rt) => nt.size === Object.keys(rt).length);
}
function callIfFn(tt, et) {
  return typeof tt == "function" ? tt(et) : tt;
}
function unstable_createStyleFunctionSx() {
  function tt(nt, rt, it, st) {
    const ot = { [nt]: rt, theme: it },
      at = st[nt];
    if (!at) return { [nt]: rt };
    const { cssProperty: lt = nt, themeKey: ct, transform: ut, style: ft } = at;
    if (rt == null) return null;
    if (ct === "typography" && rt === "inherit") return { [nt]: rt };
    const ht = getPath$1(it, ct) || {};
    return ft
      ? ft(ot)
      : handleBreakpoints(ot, rt, (vt) => {
          let yt = getStyleValue(ht, ut, vt);
          return (
            vt === yt &&
              typeof vt == "string" &&
              (yt = getStyleValue(
                ht,
                ut,
                `${nt}${vt === "default" ? "" : capitalize(vt)}`,
                vt
              )),
            lt === !1 ? yt : { [lt]: yt }
          );
        });
  }
  function et(nt) {
    var rt;
    const { sx: it, theme: st = {} } = nt || {};
    if (!it) return null;
    const ot = (rt = st.unstable_sxConfig) != null ? rt : defaultSxConfig$1;
    function at(lt) {
      let ct = lt;
      if (typeof lt == "function") ct = lt(st);
      else if (typeof lt != "object") return lt;
      if (!ct) return null;
      const ut = createEmptyBreakpointObject(st.breakpoints),
        ft = Object.keys(ut);
      let ht = ut;
      return (
        Object.keys(ct).forEach((mt) => {
          const vt = callIfFn(ct[mt], st);
          if (vt != null)
            if (typeof vt == "object")
              if (ot[mt]) ht = merge(ht, tt(mt, vt, st, ot));
              else {
                const yt = handleBreakpoints({ theme: st }, vt, (Et) => ({
                  [mt]: Et,
                }));
                objectsHaveSameKeys(yt, vt)
                  ? (ht[mt] = et({ sx: vt, theme: st }))
                  : (ht = merge(ht, yt));
              }
            else ht = merge(ht, tt(mt, vt, st, ot));
        }),
        removeUnusedBreakpoints(ft, ht)
      );
    }
    return Array.isArray(it) ? it.map(at) : at(it);
  }
  return et;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const styleFunctionSx$1 = styleFunctionSx,
  _excluded$r = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(tt = {}, ...et) {
  const {
      breakpoints: nt = {},
      palette: rt = {},
      spacing: it,
      shape: st = {},
    } = tt,
    ot = _objectWithoutPropertiesLoose(tt, _excluded$r),
    at = createBreakpoints(nt),
    lt = createSpacing(it);
  let ct = deepmerge(
    {
      breakpoints: at,
      direction: "ltr",
      components: {},
      palette: _extends({ mode: "light" }, rt),
      spacing: lt,
      shape: _extends({}, shape$1, st),
    },
    ot
  );
  return (
    (ct = et.reduce((ut, ft) => deepmerge(ut, ft), ct)),
    (ct.unstable_sxConfig = _extends(
      {},
      defaultSxConfig$1,
      ot == null ? void 0 : ot.unstable_sxConfig
    )),
    (ct.unstable_sx = function (ft) {
      return styleFunctionSx$1({ sx: ft, theme: this });
    }),
    ct
  );
}
function isObjectEmpty(tt) {
  return Object.keys(tt).length === 0;
}
function useTheme$2(tt = null) {
  const et = reactExports.useContext(ThemeContext);
  return !et || isObjectEmpty(et) ? tt : et;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(tt = systemDefaultTheme$1) {
  return useTheme$2(tt);
}
const _excluded$q = ["sx"],
  splitProps = (tt) => {
    var et, nt;
    const rt = { systemProps: {}, otherProps: {} },
      it =
        (et =
          tt == null || (nt = tt.theme) == null
            ? void 0
            : nt.unstable_sxConfig) != null
          ? et
          : defaultSxConfig$1;
    return (
      Object.keys(tt).forEach((st) => {
        it[st] ? (rt.systemProps[st] = tt[st]) : (rt.otherProps[st] = tt[st]);
      }),
      rt
    );
  };
function extendSxProp(tt) {
  const { sx: et } = tt,
    nt = _objectWithoutPropertiesLoose(tt, _excluded$q),
    { systemProps: rt, otherProps: it } = splitProps(nt);
  let st;
  return (
    Array.isArray(et)
      ? (st = [rt, ...et])
      : typeof et == "function"
      ? (st = (...ot) => {
          const at = et(...ot);
          return isPlainObject$2(at) ? _extends({}, rt, at) : rt;
        })
      : (st = _extends({}, rt, et)),
    _extends({}, it, { sx: st })
  );
}
const _excluded$p = ["variant"];
function isEmpty$1(tt) {
  return tt.length === 0;
}
function propsToClassKey(tt) {
  const { variant: et } = tt,
    nt = _objectWithoutPropertiesLoose(tt, _excluded$p);
  let rt = et || "";
  return (
    Object.keys(nt)
      .sort()
      .forEach((it) => {
        it === "color"
          ? (rt += isEmpty$1(rt) ? tt[it] : capitalize(tt[it]))
          : (rt += `${isEmpty$1(rt) ? it : capitalize(it)}${capitalize(
              tt[it].toString()
            )}`);
      }),
    rt
  );
}
const _excluded$o = [
  "name",
  "slot",
  "skipVariantsResolver",
  "skipSx",
  "overridesResolver",
];
function isEmpty(tt) {
  return Object.keys(tt).length === 0;
}
function isStringTag(tt) {
  return typeof tt == "string" && tt.charCodeAt(0) > 96;
}
const getStyleOverrides = (tt, et) =>
    et.components && et.components[tt] && et.components[tt].styleOverrides
      ? et.components[tt].styleOverrides
      : null,
  transformVariants = (tt) => {
    const et = {};
    return (
      tt &&
        tt.forEach((nt) => {
          const rt = propsToClassKey(nt.props);
          et[rt] = nt.style;
        }),
      et
    );
  },
  getVariantStyles = (tt, et) => {
    let nt = [];
    return (
      et &&
        et.components &&
        et.components[tt] &&
        et.components[tt].variants &&
        (nt = et.components[tt].variants),
      transformVariants(nt)
    );
  },
  variantsResolver = (tt, et, nt) => {
    const { ownerState: rt = {} } = tt,
      it = [];
    return (
      nt &&
        nt.forEach((st) => {
          let ot = !0;
          Object.keys(st.props).forEach((at) => {
            rt[at] !== st.props[at] && tt[at] !== st.props[at] && (ot = !1);
          }),
            ot && it.push(et[propsToClassKey(st.props)]);
        }),
      it
    );
  },
  themeVariantsResolver = (tt, et, nt, rt) => {
    var it;
    const st =
      nt == null || (it = nt.components) == null || (it = it[rt]) == null
        ? void 0
        : it.variants;
    return variantsResolver(tt, et, st);
  };
function shouldForwardProp(tt) {
  return tt !== "ownerState" && tt !== "theme" && tt !== "sx" && tt !== "as";
}
const systemDefaultTheme = createTheme$1(),
  lowercaseFirstLetter = (tt) => tt && tt.charAt(0).toLowerCase() + tt.slice(1);
function resolveTheme({ defaultTheme: tt, theme: et, themeId: nt }) {
  return isEmpty(et) ? tt : et[nt] || et;
}
function defaultOverridesResolver(tt) {
  return tt ? (et, nt) => nt[tt] : null;
}
const muiStyledFunctionResolver = ({
  styledArg: tt,
  props: et,
  defaultTheme: nt,
  themeId: rt,
}) => {
  const it = tt(
    _extends({}, et, {
      theme: resolveTheme(_extends({}, et, { defaultTheme: nt, themeId: rt })),
    })
  );
  let st;
  if ((it && it.variants && ((st = it.variants), delete it.variants), st)) {
    const ot = variantsResolver(et, transformVariants(st), st);
    return [it, ...ot];
  }
  return it;
};
function createStyled(tt = {}) {
  const {
      themeId: et,
      defaultTheme: nt = systemDefaultTheme,
      rootShouldForwardProp: rt = shouldForwardProp,
      slotShouldForwardProp: it = shouldForwardProp,
    } = tt,
    st = (ot) =>
      styleFunctionSx$1(
        _extends({}, ot, {
          theme: resolveTheme(
            _extends({}, ot, { defaultTheme: nt, themeId: et })
          ),
        })
      );
  return (
    (st.__mui_systemSx = !0),
    (ot, at = {}) => {
      internal_processStyles(ot, (At) =>
        At.filter((Ct) => !(Ct != null && Ct.__mui_systemSx))
      );
      const {
          name: lt,
          slot: ct,
          skipVariantsResolver: ut,
          skipSx: ft,
          overridesResolver: ht = defaultOverridesResolver(
            lowercaseFirstLetter(ct)
          ),
        } = at,
        mt = _objectWithoutPropertiesLoose(at, _excluded$o),
        vt = ut !== void 0 ? ut : (ct && ct !== "Root" && ct !== "root") || !1,
        yt = ft || !1;
      let Et,
        pt = shouldForwardProp;
      ct === "Root" || ct === "root"
        ? (pt = rt)
        : ct
        ? (pt = it)
        : isStringTag(ot) && (pt = void 0);
      const xt = styled$3(
          ot,
          _extends({ shouldForwardProp: pt, label: Et }, mt)
        ),
        St = (At, ...Ct) => {
          const Mt = Ct
            ? Ct.map((Ft) => {
                if (typeof Ft == "function" && Ft.__emotion_real !== Ft)
                  return (Vt) =>
                    muiStyledFunctionResolver({
                      styledArg: Ft,
                      props: Vt,
                      defaultTheme: nt,
                      themeId: et,
                    });
                if (isPlainObject$2(Ft)) {
                  let Vt = Ft,
                    $t;
                  return (
                    Ft &&
                      Ft.variants &&
                      (($t = Ft.variants),
                      delete Vt.variants,
                      (Vt = (Kt) => {
                        let Ht = Ft;
                        return (
                          variantsResolver(
                            Kt,
                            transformVariants($t),
                            $t
                          ).forEach((kt) => {
                            Ht = deepmerge(Ht, kt);
                          }),
                          Ht
                        );
                      })),
                    Vt
                  );
                }
                return Ft;
              })
            : [];
          let wt = At;
          if (isPlainObject$2(At)) {
            let Ft;
            At &&
              At.variants &&
              ((Ft = At.variants),
              delete wt.variants,
              (wt = (Vt) => {
                let $t = At;
                return (
                  variantsResolver(Vt, transformVariants(Ft), Ft).forEach(
                    (Ht) => {
                      $t = deepmerge($t, Ht);
                    }
                  ),
                  $t
                );
              }));
          } else
            typeof At == "function" &&
              At.__emotion_real !== At &&
              (wt = (Ft) =>
                muiStyledFunctionResolver({
                  styledArg: At,
                  props: Ft,
                  defaultTheme: nt,
                  themeId: et,
                }));
          lt &&
            ht &&
            Mt.push((Ft) => {
              const Vt = resolveTheme(
                  _extends({}, Ft, { defaultTheme: nt, themeId: et })
                ),
                $t = getStyleOverrides(lt, Vt);
              if ($t) {
                const Kt = {};
                return (
                  Object.entries($t).forEach(([Ht, Wt]) => {
                    Kt[Ht] =
                      typeof Wt == "function"
                        ? Wt(_extends({}, Ft, { theme: Vt }))
                        : Wt;
                  }),
                  ht(Ft, Kt)
                );
              }
              return null;
            }),
            lt &&
              !vt &&
              Mt.push((Ft) => {
                const Vt = resolveTheme(
                  _extends({}, Ft, { defaultTheme: nt, themeId: et })
                );
                return themeVariantsResolver(
                  Ft,
                  getVariantStyles(lt, Vt),
                  Vt,
                  lt
                );
              }),
            yt || Mt.push(st);
          const Bt = Mt.length - Ct.length;
          if (Array.isArray(At) && Bt > 0) {
            const Ft = new Array(Bt).fill("");
            (wt = [...At, ...Ft]), (wt.raw = [...At.raw, ...Ft]);
          }
          const It = xt(wt, ...Mt);
          return ot.muiName && (It.muiName = ot.muiName), It;
        };
      return xt.withConfig && (St.withConfig = xt.withConfig), St;
    }
  );
}
function getThemeProps(tt) {
  const { theme: et, name: nt, props: rt } = tt;
  return !et ||
    !et.components ||
    !et.components[nt] ||
    !et.components[nt].defaultProps
    ? rt
    : resolveProps(et.components[nt].defaultProps, rt);
}
function useThemeProps$1({
  props: tt,
  name: et,
  defaultTheme: nt,
  themeId: rt,
}) {
  let it = useTheme$1(nt);
  return (
    rt && (it = it[rt] || it), getThemeProps({ theme: it, name: et, props: tt })
  );
}
function clamp(tt, et = 0, nt = 1) {
  return Math.min(Math.max(et, tt), nt);
}
function hexToRgb(tt) {
  tt = tt.slice(1);
  const et = new RegExp(`.{1,${tt.length >= 6 ? 2 : 1}}`, "g");
  let nt = tt.match(et);
  return (
    nt && nt[0].length === 1 && (nt = nt.map((rt) => rt + rt)),
    nt
      ? `rgb${nt.length === 4 ? "a" : ""}(${nt
          .map((rt, it) =>
            it < 3
              ? parseInt(rt, 16)
              : Math.round((parseInt(rt, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function decomposeColor(tt) {
  if (tt.type) return tt;
  if (tt.charAt(0) === "#") return decomposeColor(hexToRgb(tt));
  const et = tt.indexOf("("),
    nt = tt.substring(0, et);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(nt) === -1)
    throw new Error(formatMuiErrorMessage(9, tt));
  let rt = tt.substring(et + 1, tt.length - 1),
    it;
  if (nt === "color") {
    if (
      ((rt = rt.split(" ")),
      (it = rt.shift()),
      rt.length === 4 && rt[3].charAt(0) === "/" && (rt[3] = rt[3].slice(1)),
      ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(
        it
      ) === -1)
    )
      throw new Error(formatMuiErrorMessage(10, it));
  } else rt = rt.split(",");
  return (
    (rt = rt.map((st) => parseFloat(st))),
    { type: nt, values: rt, colorSpace: it }
  );
}
function recomposeColor(tt) {
  const { type: et, colorSpace: nt } = tt;
  let { values: rt } = tt;
  return (
    et.indexOf("rgb") !== -1
      ? (rt = rt.map((it, st) => (st < 3 ? parseInt(it, 10) : it)))
      : et.indexOf("hsl") !== -1 &&
        ((rt[1] = `${rt[1]}%`), (rt[2] = `${rt[2]}%`)),
    et.indexOf("color") !== -1
      ? (rt = `${nt} ${rt.join(" ")}`)
      : (rt = `${rt.join(", ")}`),
    `${et}(${rt})`
  );
}
function hslToRgb(tt) {
  tt = decomposeColor(tt);
  const { values: et } = tt,
    nt = et[0],
    rt = et[1] / 100,
    it = et[2] / 100,
    st = rt * Math.min(it, 1 - it),
    ot = (ct, ut = (ct + nt / 30) % 12) =>
      it - st * Math.max(Math.min(ut - 3, 9 - ut, 1), -1);
  let at = "rgb";
  const lt = [
    Math.round(ot(0) * 255),
    Math.round(ot(8) * 255),
    Math.round(ot(4) * 255),
  ];
  return (
    tt.type === "hsla" && ((at += "a"), lt.push(et[3])),
    recomposeColor({ type: at, values: lt })
  );
}
function getLuminance(tt) {
  tt = decomposeColor(tt);
  let et =
    tt.type === "hsl" || tt.type === "hsla"
      ? decomposeColor(hslToRgb(tt)).values
      : tt.values;
  return (
    (et = et.map(
      (nt) => (
        tt.type !== "color" && (nt /= 255),
        nt <= 0.03928 ? nt / 12.92 : ((nt + 0.055) / 1.055) ** 2.4
      )
    )),
    Number((0.2126 * et[0] + 0.7152 * et[1] + 0.0722 * et[2]).toFixed(3))
  );
}
function getContrastRatio(tt, et) {
  const nt = getLuminance(tt),
    rt = getLuminance(et);
  return (Math.max(nt, rt) + 0.05) / (Math.min(nt, rt) + 0.05);
}
function alpha(tt, et) {
  return (
    (tt = decomposeColor(tt)),
    (et = clamp(et)),
    (tt.type === "rgb" || tt.type === "hsl") && (tt.type += "a"),
    tt.type === "color" ? (tt.values[3] = `/${et}`) : (tt.values[3] = et),
    recomposeColor(tt)
  );
}
function darken(tt, et) {
  if (
    ((tt = decomposeColor(tt)), (et = clamp(et)), tt.type.indexOf("hsl") !== -1)
  )
    tt.values[2] *= 1 - et;
  else if (tt.type.indexOf("rgb") !== -1 || tt.type.indexOf("color") !== -1)
    for (let nt = 0; nt < 3; nt += 1) tt.values[nt] *= 1 - et;
  return recomposeColor(tt);
}
function lighten(tt, et) {
  if (
    ((tt = decomposeColor(tt)), (et = clamp(et)), tt.type.indexOf("hsl") !== -1)
  )
    tt.values[2] += (100 - tt.values[2]) * et;
  else if (tt.type.indexOf("rgb") !== -1)
    for (let nt = 0; nt < 3; nt += 1)
      tt.values[nt] += (255 - tt.values[nt]) * et;
  else if (tt.type.indexOf("color") !== -1)
    for (let nt = 0; nt < 3; nt += 1) tt.values[nt] += (1 - tt.values[nt]) * et;
  return recomposeColor(tt);
}
function emphasize(tt, et = 0.15) {
  return getLuminance(tt) > 0.5 ? darken(tt, et) : lighten(tt, et);
}
function createMixins(tt, et) {
  return _extends(
    {
      toolbar: {
        minHeight: 56,
        [tt.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
        [tt.up("sm")]: { minHeight: 64 },
      },
    },
    et
  );
}
const common = { black: "#000", white: "#fff" },
  common$1 = common,
  grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  },
  grey$1 = grey,
  purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff",
  },
  purple$1 = purple,
  red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000",
  },
  red$1 = red,
  orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00",
  },
  orange$1 = orange,
  blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff",
  },
  blue$1 = blue,
  lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea",
  },
  lightBlue$1 = lightBlue,
  green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853",
  },
  green$1 = green,
  _excluded$n = ["mode", "contrastThreshold", "tonalOffset"],
  light = {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: common$1.white, default: common$1.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  dark = {
    text: {
      primary: common$1.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: common$1.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
function addLightOrDark(tt, et, nt, rt) {
  const it = rt.light || rt,
    st = rt.dark || rt * 1.5;
  tt[et] ||
    (tt.hasOwnProperty(nt)
      ? (tt[et] = tt[nt])
      : et === "light"
      ? (tt.light = lighten(tt.main, it))
      : et === "dark" && (tt.dark = darken(tt.main, st)));
}
function getDefaultPrimary(tt = "light") {
  return tt === "dark"
    ? { main: blue$1[200], light: blue$1[50], dark: blue$1[400] }
    : { main: blue$1[700], light: blue$1[400], dark: blue$1[800] };
}
function getDefaultSecondary(tt = "light") {
  return tt === "dark"
    ? { main: purple$1[200], light: purple$1[50], dark: purple$1[400] }
    : { main: purple$1[500], light: purple$1[300], dark: purple$1[700] };
}
function getDefaultError(tt = "light") {
  return tt === "dark"
    ? { main: red$1[500], light: red$1[300], dark: red$1[700] }
    : { main: red$1[700], light: red$1[400], dark: red$1[800] };
}
function getDefaultInfo(tt = "light") {
  return tt === "dark"
    ? {
        main: lightBlue$1[400],
        light: lightBlue$1[300],
        dark: lightBlue$1[700],
      }
    : {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900],
      };
}
function getDefaultSuccess(tt = "light") {
  return tt === "dark"
    ? { main: green$1[400], light: green$1[300], dark: green$1[700] }
    : { main: green$1[800], light: green$1[500], dark: green$1[900] };
}
function getDefaultWarning(tt = "light") {
  return tt === "dark"
    ? { main: orange$1[400], light: orange$1[300], dark: orange$1[700] }
    : { main: "#ed6c02", light: orange$1[500], dark: orange$1[900] };
}
function createPalette(tt) {
  const {
      mode: et = "light",
      contrastThreshold: nt = 3,
      tonalOffset: rt = 0.2,
    } = tt,
    it = _objectWithoutPropertiesLoose(tt, _excluded$n),
    st = tt.primary || getDefaultPrimary(et),
    ot = tt.secondary || getDefaultSecondary(et),
    at = tt.error || getDefaultError(et),
    lt = tt.info || getDefaultInfo(et),
    ct = tt.success || getDefaultSuccess(et),
    ut = tt.warning || getDefaultWarning(et);
  function ft(yt) {
    return getContrastRatio(yt, dark.text.primary) >= nt
      ? dark.text.primary
      : light.text.primary;
  }
  const ht = ({
      color: yt,
      name: Et,
      mainShade: pt = 500,
      lightShade: xt = 300,
      darkShade: St = 700,
    }) => {
      if (
        ((yt = _extends({}, yt)),
        !yt.main && yt[pt] && (yt.main = yt[pt]),
        !yt.hasOwnProperty("main"))
      )
        throw new Error(formatMuiErrorMessage(11, Et ? ` (${Et})` : "", pt));
      if (typeof yt.main != "string")
        throw new Error(
          formatMuiErrorMessage(
            12,
            Et ? ` (${Et})` : "",
            JSON.stringify(yt.main)
          )
        );
      return (
        addLightOrDark(yt, "light", xt, rt),
        addLightOrDark(yt, "dark", St, rt),
        yt.contrastText || (yt.contrastText = ft(yt.main)),
        yt
      );
    },
    mt = { dark, light };
  return deepmerge(
    _extends(
      {
        common: _extends({}, common$1),
        mode: et,
        primary: ht({ color: st, name: "primary" }),
        secondary: ht({
          color: ot,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: ht({ color: at, name: "error" }),
        warning: ht({ color: ut, name: "warning" }),
        info: ht({ color: lt, name: "info" }),
        success: ht({ color: ct, name: "success" }),
        grey: grey$1,
        contrastThreshold: nt,
        getContrastText: ft,
        augmentColor: ht,
        tonalOffset: rt,
      },
      mt[et]
    ),
    it
  );
}
const _excluded$m = [
  "fontFamily",
  "fontSize",
  "fontWeightLight",
  "fontWeightRegular",
  "fontWeightMedium",
  "fontWeightBold",
  "htmlFontSize",
  "allVariants",
  "pxToRem",
];
function round$2(tt) {
  return Math.round(tt * 1e5) / 1e5;
}
const caseAllCaps = { textTransform: "uppercase" },
  defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(tt, et) {
  const nt = typeof et == "function" ? et(tt) : et,
    {
      fontFamily: rt = defaultFontFamily,
      fontSize: it = 14,
      fontWeightLight: st = 300,
      fontWeightRegular: ot = 400,
      fontWeightMedium: at = 500,
      fontWeightBold: lt = 700,
      htmlFontSize: ct = 16,
      allVariants: ut,
      pxToRem: ft,
    } = nt,
    ht = _objectWithoutPropertiesLoose(nt, _excluded$m),
    mt = it / 14,
    vt = ft || ((pt) => `${(pt / ct) * mt}rem`),
    yt = (pt, xt, St, At, Ct) =>
      _extends(
        { fontFamily: rt, fontWeight: pt, fontSize: vt(xt), lineHeight: St },
        rt === defaultFontFamily
          ? { letterSpacing: `${round$2(At / xt)}em` }
          : {},
        Ct,
        ut
      ),
    Et = {
      h1: yt(st, 96, 1.167, -1.5),
      h2: yt(st, 60, 1.2, -0.5),
      h3: yt(ot, 48, 1.167, 0),
      h4: yt(ot, 34, 1.235, 0.25),
      h5: yt(ot, 24, 1.334, 0),
      h6: yt(at, 20, 1.6, 0.15),
      subtitle1: yt(ot, 16, 1.75, 0.15),
      subtitle2: yt(at, 14, 1.57, 0.1),
      body1: yt(ot, 16, 1.5, 0.15),
      body2: yt(ot, 14, 1.43, 0.15),
      button: yt(at, 14, 1.75, 0.4, caseAllCaps),
      caption: yt(ot, 12, 1.66, 0.4),
      overline: yt(ot, 12, 2.66, 1, caseAllCaps),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return deepmerge(
    _extends(
      {
        htmlFontSize: ct,
        pxToRem: vt,
        fontFamily: rt,
        fontSize: it,
        fontWeightLight: st,
        fontWeightRegular: ot,
        fontWeightMedium: at,
        fontWeightBold: lt,
      },
      Et
    ),
    ht,
    { clone: !1 }
  );
}
const shadowKeyUmbraOpacity = 0.2,
  shadowKeyPenumbraOpacity = 0.14,
  shadowAmbientShadowOpacity = 0.12;
function createShadow(...tt) {
  return [
    `${tt[0]}px ${tt[1]}px ${tt[2]}px ${tt[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
    `${tt[4]}px ${tt[5]}px ${tt[6]}px ${tt[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
    `${tt[8]}px ${tt[9]}px ${tt[10]}px ${tt[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`,
  ].join(",");
}
const shadows = [
    "none",
    createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  shadows$1 = shadows,
  _excluded$l = ["duration", "easing", "delay"],
  easing = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function formatMs(tt) {
  return `${Math.round(tt)}ms`;
}
function getAutoHeightDuration(tt) {
  if (!tt) return 0;
  const et = tt / 36;
  return Math.round((4 + 15 * et ** 0.25 + et / 5) * 10);
}
function createTransitions(tt) {
  const et = _extends({}, easing, tt.easing),
    nt = _extends({}, duration, tt.duration);
  return _extends(
    {
      getAutoHeightDuration,
      create: (it = ["all"], st = {}) => {
        const {
          duration: ot = nt.standard,
          easing: at = et.easeInOut,
          delay: lt = 0,
        } = st;
        return (
          _objectWithoutPropertiesLoose(st, _excluded$l),
          (Array.isArray(it) ? it : [it])
            .map(
              (ct) =>
                `${ct} ${typeof ot == "string" ? ot : formatMs(ot)} ${at} ${
                  typeof lt == "string" ? lt : formatMs(lt)
                }`
            )
            .join(",")
        );
      },
    },
    tt,
    { easing: et, duration: nt }
  );
}
const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  zIndex$1 = zIndex,
  _excluded$k = [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
  ];
function createTheme(tt = {}, ...et) {
  const {
      mixins: nt = {},
      palette: rt = {},
      transitions: it = {},
      typography: st = {},
    } = tt,
    ot = _objectWithoutPropertiesLoose(tt, _excluded$k);
  if (tt.vars) throw new Error(formatMuiErrorMessage(18));
  const at = createPalette(rt),
    lt = createTheme$1(tt);
  let ct = deepmerge(lt, {
    mixins: createMixins(lt.breakpoints, nt),
    palette: at,
    shadows: shadows$1.slice(),
    typography: createTypography(at, st),
    transitions: createTransitions(it),
    zIndex: _extends({}, zIndex$1),
  });
  return (
    (ct = deepmerge(ct, ot)),
    (ct = et.reduce((ut, ft) => deepmerge(ut, ft), ct)),
    (ct.unstable_sxConfig = _extends(
      {},
      defaultSxConfig$1,
      ot == null ? void 0 : ot.unstable_sxConfig
    )),
    (ct.unstable_sx = function (ft) {
      return styleFunctionSx$1({ sx: ft, theme: this });
    }),
    ct
  );
}
const defaultTheme = createTheme(),
  defaultTheme$1 = defaultTheme,
  THEME_ID = "$$material";
function useThemeProps({ props: tt, name: et }) {
  return useThemeProps$1({
    props: tt,
    name: et,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID,
  });
}
const rootShouldForwardProp = (tt) => shouldForwardProp(tt) && tt !== "classes",
  styled$1 = createStyled({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$1,
    rootShouldForwardProp,
  }),
  styled$2 = styled$1;
function getSvgIconUtilityClass(tt) {
  return generateUtilityClass("MuiSvgIcon", tt);
}
generateUtilityClasses("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const _excluded$j = [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox",
  ],
  useUtilityClasses$f = (tt) => {
    const { color: et, fontSize: nt, classes: rt } = tt,
      it = {
        root: [
          "root",
          et !== "inherit" && `color${capitalize(et)}`,
          `fontSize${capitalize(nt)}`,
        ],
      };
    return composeClasses(it, getSvgIconUtilityClass, rt);
  },
  SvgIconRoot = styled$2("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        nt.color !== "inherit" && et[`color${capitalize(nt.color)}`],
        et[`fontSize${capitalize(nt.fontSize)}`],
      ];
    },
  })(({ theme: tt, ownerState: et }) => {
    var nt, rt, it, st, ot, at, lt, ct, ut, ft, ht, mt, vt;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: et.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition:
        (nt = tt.transitions) == null || (rt = nt.create) == null
          ? void 0
          : rt.call(nt, "fill", {
              duration:
                (it = tt.transitions) == null || (it = it.duration) == null
                  ? void 0
                  : it.shorter,
            }),
      fontSize: {
        inherit: "inherit",
        small:
          ((st = tt.typography) == null || (ot = st.pxToRem) == null
            ? void 0
            : ot.call(st, 20)) || "1.25rem",
        medium:
          ((at = tt.typography) == null || (lt = at.pxToRem) == null
            ? void 0
            : lt.call(at, 24)) || "1.5rem",
        large:
          ((ct = tt.typography) == null || (ut = ct.pxToRem) == null
            ? void 0
            : ut.call(ct, 35)) || "2.1875rem",
      }[et.fontSize],
      color:
        (ft =
          (ht = (tt.vars || tt).palette) == null || (ht = ht[et.color]) == null
            ? void 0
            : ht.main) != null
          ? ft
          : {
              action:
                (mt = (tt.vars || tt).palette) == null ||
                (mt = mt.action) == null
                  ? void 0
                  : mt.active,
              disabled:
                (vt = (tt.vars || tt).palette) == null ||
                (vt = vt.action) == null
                  ? void 0
                  : vt.disabled,
              inherit: void 0,
            }[et.color],
    };
  }),
  SvgIcon = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiSvgIcon" }),
      {
        children: it,
        className: st,
        color: ot = "inherit",
        component: at = "svg",
        fontSize: lt = "medium",
        htmlColor: ct,
        inheritViewBox: ut = !1,
        titleAccess: ft,
        viewBox: ht = "0 0 24 24",
      } = rt,
      mt = _objectWithoutPropertiesLoose(rt, _excluded$j),
      vt = reactExports.isValidElement(it) && it.type === "svg",
      yt = _extends({}, rt, {
        color: ot,
        component: at,
        fontSize: lt,
        instanceFontSize: et.fontSize,
        inheritViewBox: ut,
        viewBox: ht,
        hasSvgAsChild: vt,
      }),
      Et = {};
    ut || (Et.viewBox = ht);
    const pt = useUtilityClasses$f(yt);
    return jsxRuntimeExports.jsxs(
      SvgIconRoot,
      _extends(
        {
          as: at,
          className: clsx(pt.root, st),
          focusable: "false",
          color: ct,
          "aria-hidden": ft ? void 0 : !0,
          role: ft ? "img" : void 0,
          ref: nt,
        },
        Et,
        mt,
        vt && it.props,
        {
          ownerState: yt,
          children: [
            vt ? it.props.children : it,
            ft ? jsxRuntimeExports.jsx("title", { children: ft }) : null,
          ],
        }
      )
    );
  });
SvgIcon.muiName = "SvgIcon";
const SvgIcon$1 = SvgIcon;
function createSvgIcon(tt, et) {
  function nt(rt, it) {
    return jsxRuntimeExports.jsx(
      SvgIcon$1,
      _extends({ "data-testid": `${et}Icon`, ref: it }, rt, { children: tt })
    );
  }
  return (
    (nt.muiName = SvgIcon$1.muiName),
    reactExports.memo(reactExports.forwardRef(nt))
  );
}
const PlayArrowRounded = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M8 6.82v10.36c0 .79.87 1.27 1.54.84l8.14-5.18c.62-.39.62-1.29 0-1.69L9.54 5.98C8.87 5.55 8 6.03 8 6.82z",
    }),
    "PlayArrowRounded"
  ),
  RestartAlt = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91z",
    }),
    "RestartAlt"
  ),
  ledger = "images/ledger-c7d63032.jpg";
function n(tt) {
  for (
    var et = arguments.length, nt = Array(et > 1 ? et - 1 : 0), rt = 1;
    rt < et;
    rt++
  )
    nt[rt - 1] = arguments[rt];
  throw Error(
    "[Immer] minified error nr: " +
      tt +
      (nt.length
        ? " " +
          nt
            .map(function (it) {
              return "'" + it + "'";
            })
            .join(",")
        : "") +
      ". Find the full error at: https://bit.ly/3cXEKWf"
  );
}
function r(tt) {
  return !!tt && !!tt[Q$1];
}
function t(tt) {
  var et;
  return (
    !!tt &&
    ((function (nt) {
      if (!nt || typeof nt != "object") return !1;
      var rt = Object.getPrototypeOf(nt);
      if (rt === null) return !0;
      var it = Object.hasOwnProperty.call(rt, "constructor") && rt.constructor;
      return (
        it === Object ||
        (typeof it == "function" && Function.toString.call(it) === Z$1)
      );
    })(tt) ||
      Array.isArray(tt) ||
      !!tt[L$1] ||
      !!(!((et = tt.constructor) === null || et === void 0) && et[L$1]) ||
      s(tt) ||
      v$1(tt))
  );
}
function i(tt, et, nt) {
  nt === void 0 && (nt = !1),
    o(tt) === 0
      ? (nt ? Object.keys : nn)(tt).forEach(function (rt) {
          (nt && typeof rt == "symbol") || et(rt, tt[rt], tt);
        })
      : tt.forEach(function (rt, it) {
          return et(it, rt, tt);
        });
}
function o(tt) {
  var et = tt[Q$1];
  return et
    ? et.i > 3
      ? et.i - 4
      : et.i
    : Array.isArray(tt)
    ? 1
    : s(tt)
    ? 2
    : v$1(tt)
    ? 3
    : 0;
}
function u(tt, et) {
  return o(tt) === 2
    ? tt.has(et)
    : Object.prototype.hasOwnProperty.call(tt, et);
}
function a(tt, et) {
  return o(tt) === 2 ? tt.get(et) : tt[et];
}
function f(tt, et, nt) {
  var rt = o(tt);
  rt === 2 ? tt.set(et, nt) : rt === 3 ? tt.add(nt) : (tt[et] = nt);
}
function c(tt, et) {
  return tt === et ? tt !== 0 || 1 / tt == 1 / et : tt != tt && et != et;
}
function s(tt) {
  return X$1 && tt instanceof Map;
}
function v$1(tt) {
  return q$1 && tt instanceof Set;
}
function p(tt) {
  return tt.o || tt.t;
}
function l(tt) {
  if (Array.isArray(tt)) return Array.prototype.slice.call(tt);
  var et = rn(tt);
  delete et[Q$1];
  for (var nt = nn(et), rt = 0; rt < nt.length; rt++) {
    var it = nt[rt],
      st = et[it];
    st.writable === !1 && ((st.writable = !0), (st.configurable = !0)),
      (st.get || st.set) &&
        (et[it] = {
          configurable: !0,
          writable: !0,
          enumerable: st.enumerable,
          value: tt[it],
        });
  }
  return Object.create(Object.getPrototypeOf(tt), et);
}
function d(tt, et) {
  return (
    et === void 0 && (et = !1),
    y$1(tt) ||
      r(tt) ||
      !t(tt) ||
      (o(tt) > 1 && (tt.set = tt.add = tt.clear = tt.delete = h),
      Object.freeze(tt),
      et &&
        i(
          tt,
          function (nt, rt) {
            return d(rt, !0);
          },
          !0
        )),
    tt
  );
}
function h() {
  n(2);
}
function y$1(tt) {
  return tt == null || typeof tt != "object" || Object.isFrozen(tt);
}
function b$1(tt) {
  var et = tn[tt];
  return et || n(18, tt), et;
}
function m(tt, et) {
  tn[tt] || (tn[tt] = et);
}
function _$2() {
  return U$1;
}
function j$1(tt, et) {
  et && (b$1("Patches"), (tt.u = []), (tt.s = []), (tt.v = et));
}
function g$1(tt) {
  O(tt), tt.p.forEach(S$1), (tt.p = null);
}
function O(tt) {
  tt === U$1 && (U$1 = tt.l);
}
function w$1(tt) {
  return (U$1 = { p: [], l: U$1, h: tt, m: !0, _: 0 });
}
function S$1(tt) {
  var et = tt[Q$1];
  et.i === 0 || et.i === 1 ? et.j() : (et.g = !0);
}
function P(tt, et) {
  et._ = et.p.length;
  var nt = et.p[0],
    rt = tt !== void 0 && tt !== nt;
  return (
    et.h.O || b$1("ES5").S(et, tt, rt),
    rt
      ? (nt[Q$1].P && (g$1(et), n(4)),
        t(tt) && ((tt = M$1(et, tt)), et.l || x$1(et, tt)),
        et.u && b$1("Patches").M(nt[Q$1].t, tt, et.u, et.s))
      : (tt = M$1(et, nt, [])),
    g$1(et),
    et.u && et.v(et.u, et.s),
    tt !== H$1 ? tt : void 0
  );
}
function M$1(tt, et, nt) {
  if (y$1(et)) return et;
  var rt = et[Q$1];
  if (!rt)
    return (
      i(
        et,
        function (at, lt) {
          return A(tt, rt, et, at, lt, nt);
        },
        !0
      ),
      et
    );
  if (rt.A !== tt) return et;
  if (!rt.P) return x$1(tt, rt.t, !0), rt.t;
  if (!rt.I) {
    (rt.I = !0), rt.A._--;
    var it = rt.i === 4 || rt.i === 5 ? (rt.o = l(rt.k)) : rt.o,
      st = it,
      ot = !1;
    rt.i === 3 && ((st = new Set(it)), it.clear(), (ot = !0)),
      i(st, function (at, lt) {
        return A(tt, rt, it, at, lt, nt, ot);
      }),
      x$1(tt, it, !1),
      nt && tt.u && b$1("Patches").N(rt, nt, tt.u, tt.s);
  }
  return rt.o;
}
function A(tt, et, nt, rt, it, st, ot) {
  if (r(it)) {
    var at = M$1(
      tt,
      it,
      st && et && et.i !== 3 && !u(et.R, rt) ? st.concat(rt) : void 0
    );
    if ((f(nt, rt, at), !r(at))) return;
    tt.m = !1;
  } else ot && nt.add(it);
  if (t(it) && !y$1(it)) {
    if (!tt.h.D && tt._ < 1) return;
    M$1(tt, it), (et && et.A.l) || x$1(tt, it);
  }
}
function x$1(tt, et, nt) {
  nt === void 0 && (nt = !1), !tt.l && tt.h.D && tt.m && d(et, nt);
}
function z$1(tt, et) {
  var nt = tt[Q$1];
  return (nt ? p(nt) : tt)[et];
}
function I$1(tt, et) {
  if (et in tt)
    for (var nt = Object.getPrototypeOf(tt); nt; ) {
      var rt = Object.getOwnPropertyDescriptor(nt, et);
      if (rt) return rt;
      nt = Object.getPrototypeOf(nt);
    }
}
function k$1(tt) {
  tt.P || ((tt.P = !0), tt.l && k$1(tt.l));
}
function E$1(tt) {
  tt.o || (tt.o = l(tt.t));
}
function N$1(tt, et, nt) {
  var rt = s(et)
    ? b$1("MapSet").F(et, nt)
    : v$1(et)
    ? b$1("MapSet").T(et, nt)
    : tt.O
    ? (function (it, st) {
        var ot = Array.isArray(it),
          at = {
            i: ot ? 1 : 0,
            A: st ? st.A : _$2(),
            P: !1,
            I: !1,
            R: {},
            l: st,
            t: it,
            k: null,
            o: null,
            j: null,
            C: !1,
          },
          lt = at,
          ct = en;
        ot && ((lt = [at]), (ct = on));
        var ut = Proxy.revocable(lt, ct),
          ft = ut.revoke,
          ht = ut.proxy;
        return (at.k = ht), (at.j = ft), ht;
      })(et, nt)
    : b$1("ES5").J(et, nt);
  return (nt ? nt.A : _$2()).p.push(rt), rt;
}
function R(tt) {
  return (
    r(tt) || n(22, tt),
    (function et(nt) {
      if (!t(nt)) return nt;
      var rt,
        it = nt[Q$1],
        st = o(nt);
      if (it) {
        if (!it.P && (it.i < 4 || !b$1("ES5").K(it))) return it.t;
        (it.I = !0), (rt = D$1(nt, st)), (it.I = !1);
      } else rt = D$1(nt, st);
      return (
        i(rt, function (ot, at) {
          (it && a(it.t, ot) === at) || f(rt, ot, et(at));
        }),
        st === 3 ? new Set(rt) : rt
      );
    })(tt)
  );
}
function D$1(tt, et) {
  switch (et) {
    case 2:
      return new Map(tt);
    case 3:
      return Array.from(tt);
  }
  return l(tt);
}
function F$1() {
  function tt(st, ot) {
    var at = it[st];
    return (
      at
        ? (at.enumerable = ot)
        : (it[st] = at =
            {
              configurable: !0,
              enumerable: ot,
              get: function () {
                var lt = this[Q$1];
                return en.get(lt, st);
              },
              set: function (lt) {
                var ct = this[Q$1];
                en.set(ct, st, lt);
              },
            }),
      at
    );
  }
  function et(st) {
    for (var ot = st.length - 1; ot >= 0; ot--) {
      var at = st[ot][Q$1];
      if (!at.P)
        switch (at.i) {
          case 5:
            rt(at) && k$1(at);
            break;
          case 4:
            nt(at) && k$1(at);
        }
    }
  }
  function nt(st) {
    for (
      var ot = st.t, at = st.k, lt = nn(at), ct = lt.length - 1;
      ct >= 0;
      ct--
    ) {
      var ut = lt[ct];
      if (ut !== Q$1) {
        var ft = ot[ut];
        if (ft === void 0 && !u(ot, ut)) return !0;
        var ht = at[ut],
          mt = ht && ht[Q$1];
        if (mt ? mt.t !== ft : !c(ht, ft)) return !0;
      }
    }
    var vt = !!ot[Q$1];
    return lt.length !== nn(ot).length + (vt ? 0 : 1);
  }
  function rt(st) {
    var ot = st.k;
    if (ot.length !== st.t.length) return !0;
    var at = Object.getOwnPropertyDescriptor(ot, ot.length - 1);
    if (at && !at.get) return !0;
    for (var lt = 0; lt < ot.length; lt++)
      if (!ot.hasOwnProperty(lt)) return !0;
    return !1;
  }
  var it = {};
  m("ES5", {
    J: function (st, ot) {
      var at = Array.isArray(st),
        lt = (function (ut, ft) {
          if (ut) {
            for (var ht = Array(ft.length), mt = 0; mt < ft.length; mt++)
              Object.defineProperty(ht, "" + mt, tt(mt, !0));
            return ht;
          }
          var vt = rn(ft);
          delete vt[Q$1];
          for (var yt = nn(vt), Et = 0; Et < yt.length; Et++) {
            var pt = yt[Et];
            vt[pt] = tt(pt, ut || !!vt[pt].enumerable);
          }
          return Object.create(Object.getPrototypeOf(ft), vt);
        })(at, st),
        ct = {
          i: at ? 5 : 4,
          A: ot ? ot.A : _$2(),
          P: !1,
          I: !1,
          R: {},
          l: ot,
          t: st,
          k: lt,
          o: null,
          g: !1,
          C: !1,
        };
      return Object.defineProperty(lt, Q$1, { value: ct, writable: !0 }), lt;
    },
    S: function (st, ot, at) {
      at
        ? r(ot) && ot[Q$1].A === st && et(st.p)
        : (st.u &&
            (function lt(ct) {
              if (ct && typeof ct == "object") {
                var ut = ct[Q$1];
                if (ut) {
                  var ft = ut.t,
                    ht = ut.k,
                    mt = ut.R,
                    vt = ut.i;
                  if (vt === 4)
                    i(ht, function (St) {
                      St !== Q$1 &&
                        (ft[St] !== void 0 || u(ft, St)
                          ? mt[St] || lt(ht[St])
                          : ((mt[St] = !0), k$1(ut)));
                    }),
                      i(ft, function (St) {
                        ht[St] !== void 0 ||
                          u(ht, St) ||
                          ((mt[St] = !1), k$1(ut));
                      });
                  else if (vt === 5) {
                    if (
                      (rt(ut) && (k$1(ut), (mt.length = !0)),
                      ht.length < ft.length)
                    )
                      for (var yt = ht.length; yt < ft.length; yt++)
                        mt[yt] = !1;
                    else
                      for (var Et = ft.length; Et < ht.length; Et++)
                        mt[Et] = !0;
                    for (
                      var pt = Math.min(ht.length, ft.length), xt = 0;
                      xt < pt;
                      xt++
                    )
                      ht.hasOwnProperty(xt) || (mt[xt] = !0),
                        mt[xt] === void 0 && lt(ht[xt]);
                  }
                }
              }
            })(st.p[0]),
          et(st.p));
    },
    K: function (st) {
      return st.i === 4 ? nt(st) : rt(st);
    },
  });
}
var G$1,
  U$1,
  W$1 = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
  X$1 = typeof Map < "u",
  q$1 = typeof Set < "u",
  B$1 =
    typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
  H$1 = W$1
    ? Symbol.for("immer-nothing")
    : (((G$1 = {})["immer-nothing"] = !0), G$1),
  L$1 = W$1 ? Symbol.for("immer-draftable") : "__$immer_draftable",
  Q$1 = W$1 ? Symbol.for("immer-state") : "__$immer_state",
  Z$1 = "" + Object.prototype.constructor,
  nn =
    typeof Reflect < "u" && Reflect.ownKeys
      ? Reflect.ownKeys
      : Object.getOwnPropertySymbols !== void 0
      ? function (tt) {
          return Object.getOwnPropertyNames(tt).concat(
            Object.getOwnPropertySymbols(tt)
          );
        }
      : Object.getOwnPropertyNames,
  rn =
    Object.getOwnPropertyDescriptors ||
    function (tt) {
      var et = {};
      return (
        nn(tt).forEach(function (nt) {
          et[nt] = Object.getOwnPropertyDescriptor(tt, nt);
        }),
        et
      );
    },
  tn = {},
  en = {
    get: function (tt, et) {
      if (et === Q$1) return tt;
      var nt = p(tt);
      if (!u(nt, et))
        return (function (it, st, ot) {
          var at,
            lt = I$1(st, ot);
          return lt
            ? "value" in lt
              ? lt.value
              : (at = lt.get) === null || at === void 0
              ? void 0
              : at.call(it.k)
            : void 0;
        })(tt, nt, et);
      var rt = nt[et];
      return tt.I || !t(rt)
        ? rt
        : rt === z$1(tt.t, et)
        ? (E$1(tt), (tt.o[et] = N$1(tt.A.h, rt, tt)))
        : rt;
    },
    has: function (tt, et) {
      return et in p(tt);
    },
    ownKeys: function (tt) {
      return Reflect.ownKeys(p(tt));
    },
    set: function (tt, et, nt) {
      var rt = I$1(p(tt), et);
      if (rt != null && rt.set) return rt.set.call(tt.k, nt), !0;
      if (!tt.P) {
        var it = z$1(p(tt), et),
          st = it == null ? void 0 : it[Q$1];
        if (st && st.t === nt) return (tt.o[et] = nt), (tt.R[et] = !1), !0;
        if (c(nt, it) && (nt !== void 0 || u(tt.t, et))) return !0;
        E$1(tt), k$1(tt);
      }
      return (
        (tt.o[et] === nt && (nt !== void 0 || et in tt.o)) ||
          (Number.isNaN(nt) && Number.isNaN(tt.o[et])) ||
          ((tt.o[et] = nt), (tt.R[et] = !0)),
        !0
      );
    },
    deleteProperty: function (tt, et) {
      return (
        z$1(tt.t, et) !== void 0 || et in tt.t
          ? ((tt.R[et] = !1), E$1(tt), k$1(tt))
          : delete tt.R[et],
        tt.o && delete tt.o[et],
        !0
      );
    },
    getOwnPropertyDescriptor: function (tt, et) {
      var nt = p(tt),
        rt = Reflect.getOwnPropertyDescriptor(nt, et);
      return (
        rt && {
          writable: !0,
          configurable: tt.i !== 1 || et !== "length",
          enumerable: rt.enumerable,
          value: nt[et],
        }
      );
    },
    defineProperty: function () {
      n(11);
    },
    getPrototypeOf: function (tt) {
      return Object.getPrototypeOf(tt.t);
    },
    setPrototypeOf: function () {
      n(12);
    },
  },
  on = {};
i(en, function (tt, et) {
  on[tt] = function () {
    return (arguments[0] = arguments[0][0]), et.apply(this, arguments);
  };
}),
  (on.deleteProperty = function (tt, et) {
    return on.set.call(this, tt, et, void 0);
  }),
  (on.set = function (tt, et, nt) {
    return en.set.call(this, tt[0], et, nt, tt[0]);
  });
var un = (function () {
    function tt(nt) {
      var rt = this;
      (this.O = B$1),
        (this.D = !0),
        (this.produce = function (it, st, ot) {
          if (typeof it == "function" && typeof st != "function") {
            var at = st;
            st = it;
            var lt = rt;
            return function (yt) {
              var Et = this;
              yt === void 0 && (yt = at);
              for (
                var pt = arguments.length,
                  xt = Array(pt > 1 ? pt - 1 : 0),
                  St = 1;
                St < pt;
                St++
              )
                xt[St - 1] = arguments[St];
              return lt.produce(yt, function (At) {
                var Ct;
                return (Ct = st).call.apply(Ct, [Et, At].concat(xt));
              });
            };
          }
          var ct;
          if (
            (typeof st != "function" && n(6),
            ot !== void 0 && typeof ot != "function" && n(7),
            t(it))
          ) {
            var ut = w$1(rt),
              ft = N$1(rt, it, void 0),
              ht = !0;
            try {
              (ct = st(ft)), (ht = !1);
            } finally {
              ht ? g$1(ut) : O(ut);
            }
            return typeof Promise < "u" && ct instanceof Promise
              ? ct.then(
                  function (yt) {
                    return j$1(ut, ot), P(yt, ut);
                  },
                  function (yt) {
                    throw (g$1(ut), yt);
                  }
                )
              : (j$1(ut, ot), P(ct, ut));
          }
          if (!it || typeof it != "object") {
            if (
              ((ct = st(it)) === void 0 && (ct = it),
              ct === H$1 && (ct = void 0),
              rt.D && d(ct, !0),
              ot)
            ) {
              var mt = [],
                vt = [];
              b$1("Patches").M(it, ct, mt, vt), ot(mt, vt);
            }
            return ct;
          }
          n(21, it);
        }),
        (this.produceWithPatches = function (it, st) {
          if (typeof it == "function")
            return function (ct) {
              for (
                var ut = arguments.length,
                  ft = Array(ut > 1 ? ut - 1 : 0),
                  ht = 1;
                ht < ut;
                ht++
              )
                ft[ht - 1] = arguments[ht];
              return rt.produceWithPatches(ct, function (mt) {
                return it.apply(void 0, [mt].concat(ft));
              });
            };
          var ot,
            at,
            lt = rt.produce(it, st, function (ct, ut) {
              (ot = ct), (at = ut);
            });
          return typeof Promise < "u" && lt instanceof Promise
            ? lt.then(function (ct) {
                return [ct, ot, at];
              })
            : [lt, ot, at];
        }),
        typeof (nt == null ? void 0 : nt.useProxies) == "boolean" &&
          this.setUseProxies(nt.useProxies),
        typeof (nt == null ? void 0 : nt.autoFreeze) == "boolean" &&
          this.setAutoFreeze(nt.autoFreeze);
    }
    var et = tt.prototype;
    return (
      (et.createDraft = function (nt) {
        t(nt) || n(8), r(nt) && (nt = R(nt));
        var rt = w$1(this),
          it = N$1(this, nt, void 0);
        return (it[Q$1].C = !0), O(rt), it;
      }),
      (et.finishDraft = function (nt, rt) {
        var it = nt && nt[Q$1],
          st = it.A;
        return j$1(st, rt), P(void 0, st);
      }),
      (et.setAutoFreeze = function (nt) {
        this.D = nt;
      }),
      (et.setUseProxies = function (nt) {
        nt && !B$1 && n(20), (this.O = nt);
      }),
      (et.applyPatches = function (nt, rt) {
        var it;
        for (it = rt.length - 1; it >= 0; it--) {
          var st = rt[it];
          if (st.path.length === 0 && st.op === "replace") {
            nt = st.value;
            break;
          }
        }
        it > -1 && (rt = rt.slice(it + 1));
        var ot = b$1("Patches").$;
        return r(nt)
          ? ot(nt, rt)
          : this.produce(nt, function (at) {
              return ot(at, rt);
            });
      }),
      tt
    );
  })(),
  an = new un(),
  fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
function _typeof(tt) {
  "@babel/helpers - typeof";
  return (
    (_typeof =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (et) {
            return typeof et;
          }
        : function (et) {
            return et &&
              typeof Symbol == "function" &&
              et.constructor === Symbol &&
              et !== Symbol.prototype
              ? "symbol"
              : typeof et;
          }),
    _typeof(tt)
  );
}
function _toPrimitive(tt, et) {
  if (_typeof(tt) !== "object" || tt === null) return tt;
  var nt = tt[Symbol.toPrimitive];
  if (nt !== void 0) {
    var rt = nt.call(tt, et || "default");
    if (_typeof(rt) !== "object") return rt;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (et === "string" ? String : Number)(tt);
}
function _toPropertyKey(tt) {
  var et = _toPrimitive(tt, "string");
  return _typeof(et) === "symbol" ? et : String(et);
}
function _defineProperty(tt, et, nt) {
  return (
    (et = _toPropertyKey(et)),
    et in tt
      ? Object.defineProperty(tt, et, {
          value: nt,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (tt[et] = nt),
    tt
  );
}
function ownKeys(tt, et) {
  var nt = Object.keys(tt);
  if (Object.getOwnPropertySymbols) {
    var rt = Object.getOwnPropertySymbols(tt);
    et &&
      (rt = rt.filter(function (it) {
        return Object.getOwnPropertyDescriptor(tt, it).enumerable;
      })),
      nt.push.apply(nt, rt);
  }
  return nt;
}
function _objectSpread2(tt) {
  for (var et = 1; et < arguments.length; et++) {
    var nt = arguments[et] != null ? arguments[et] : {};
    et % 2
      ? ownKeys(Object(nt), !0).forEach(function (rt) {
          _defineProperty(tt, rt, nt[rt]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(tt, Object.getOwnPropertyDescriptors(nt))
      : ownKeys(Object(nt)).forEach(function (rt) {
          Object.defineProperty(
            tt,
            rt,
            Object.getOwnPropertyDescriptor(nt, rt)
          );
        });
  }
  return tt;
}
function formatProdErrorMessage(tt) {
  return (
    "Minified Redux error #" +
    tt +
    "; visit https://redux.js.org/Errors?code=" +
    tt +
    " for the full message or use the non-minified dev environment for full errors. "
  );
}
var $$observable = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })(),
  randomString = function () {
    return Math.random().toString(36).substring(7).split("").join(".");
  },
  ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    },
  };
function isPlainObject$1(tt) {
  if (typeof tt != "object" || tt === null) return !1;
  for (var et = tt; Object.getPrototypeOf(et) !== null; )
    et = Object.getPrototypeOf(et);
  return Object.getPrototypeOf(tt) === et;
}
function createStore(tt, et, nt) {
  var rt;
  if (
    (typeof et == "function" && typeof nt == "function") ||
    (typeof nt == "function" && typeof arguments[3] == "function")
  )
    throw new Error(formatProdErrorMessage(0));
  if (
    (typeof et == "function" && typeof nt > "u" && ((nt = et), (et = void 0)),
    typeof nt < "u")
  ) {
    if (typeof nt != "function") throw new Error(formatProdErrorMessage(1));
    return nt(createStore)(tt, et);
  }
  if (typeof tt != "function") throw new Error(formatProdErrorMessage(2));
  var it = tt,
    st = et,
    ot = [],
    at = ot,
    lt = !1;
  function ct() {
    at === ot && (at = ot.slice());
  }
  function ut() {
    if (lt) throw new Error(formatProdErrorMessage(3));
    return st;
  }
  function ft(yt) {
    if (typeof yt != "function") throw new Error(formatProdErrorMessage(4));
    if (lt) throw new Error(formatProdErrorMessage(5));
    var Et = !0;
    return (
      ct(),
      at.push(yt),
      function () {
        if (Et) {
          if (lt) throw new Error(formatProdErrorMessage(6));
          (Et = !1), ct();
          var xt = at.indexOf(yt);
          at.splice(xt, 1), (ot = null);
        }
      }
    );
  }
  function ht(yt) {
    if (!isPlainObject$1(yt)) throw new Error(formatProdErrorMessage(7));
    if (typeof yt.type > "u") throw new Error(formatProdErrorMessage(8));
    if (lt) throw new Error(formatProdErrorMessage(9));
    try {
      (lt = !0), (st = it(st, yt));
    } finally {
      lt = !1;
    }
    for (var Et = (ot = at), pt = 0; pt < Et.length; pt++) {
      var xt = Et[pt];
      xt();
    }
    return yt;
  }
  function mt(yt) {
    if (typeof yt != "function") throw new Error(formatProdErrorMessage(10));
    (it = yt), ht({ type: ActionTypes.REPLACE });
  }
  function vt() {
    var yt,
      Et = ft;
    return (
      (yt = {
        subscribe: function (xt) {
          if (typeof xt != "object" || xt === null)
            throw new Error(formatProdErrorMessage(11));
          function St() {
            xt.next && xt.next(ut());
          }
          St();
          var At = Et(St);
          return { unsubscribe: At };
        },
      }),
      (yt[$$observable] = function () {
        return this;
      }),
      yt
    );
  }
  return (
    ht({ type: ActionTypes.INIT }),
    (rt = { dispatch: ht, subscribe: ft, getState: ut, replaceReducer: mt }),
    (rt[$$observable] = vt),
    rt
  );
}
function assertReducerShape(tt) {
  Object.keys(tt).forEach(function (et) {
    var nt = tt[et],
      rt = nt(void 0, { type: ActionTypes.INIT });
    if (typeof rt > "u") throw new Error(formatProdErrorMessage(12));
    if (typeof nt(void 0, { type: ActionTypes.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(formatProdErrorMessage(13));
  });
}
function combineReducers(tt) {
  for (var et = Object.keys(tt), nt = {}, rt = 0; rt < et.length; rt++) {
    var it = et[rt];
    typeof tt[it] == "function" && (nt[it] = tt[it]);
  }
  var st = Object.keys(nt),
    ot;
  try {
    assertReducerShape(nt);
  } catch (at) {
    ot = at;
  }
  return function (lt, ct) {
    if ((lt === void 0 && (lt = {}), ot)) throw ot;
    for (var ut = !1, ft = {}, ht = 0; ht < st.length; ht++) {
      var mt = st[ht],
        vt = nt[mt],
        yt = lt[mt],
        Et = vt(yt, ct);
      if (typeof Et > "u")
        throw (ct && ct.type, new Error(formatProdErrorMessage(14)));
      (ft[mt] = Et), (ut = ut || Et !== yt);
    }
    return (ut = ut || st.length !== Object.keys(lt).length), ut ? ft : lt;
  };
}
function compose() {
  for (var tt = arguments.length, et = new Array(tt), nt = 0; nt < tt; nt++)
    et[nt] = arguments[nt];
  return et.length === 0
    ? function (rt) {
        return rt;
      }
    : et.length === 1
    ? et[0]
    : et.reduce(function (rt, it) {
        return function () {
          return rt(it.apply(void 0, arguments));
        };
      });
}
function applyMiddleware() {
  for (var tt = arguments.length, et = new Array(tt), nt = 0; nt < tt; nt++)
    et[nt] = arguments[nt];
  return function (rt) {
    return function () {
      var it = rt.apply(void 0, arguments),
        st = function () {
          throw new Error(formatProdErrorMessage(15));
        },
        ot = {
          getState: it.getState,
          dispatch: function () {
            return st.apply(void 0, arguments);
          },
        },
        at = et.map(function (lt) {
          return lt(ot);
        });
      return (
        (st = compose.apply(void 0, at)(it.dispatch)),
        _objectSpread2(_objectSpread2({}, it), {}, { dispatch: st })
      );
    };
  };
}
function createThunkMiddleware(tt) {
  var et = function (rt) {
    var it = rt.dispatch,
      st = rt.getState;
    return function (ot) {
      return function (at) {
        return typeof at == "function" ? at(it, st, tt) : ot(at);
      };
    };
  };
  return et;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
const thunkMiddleware = thunk;
var __extends =
    (globalThis && globalThis.__extends) ||
    (function () {
      var tt = function (et, nt) {
        return (
          (tt =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (rt, it) {
                rt.__proto__ = it;
              }) ||
            function (rt, it) {
              for (var st in it)
                Object.prototype.hasOwnProperty.call(it, st) &&
                  (rt[st] = it[st]);
            }),
          tt(et, nt)
        );
      };
      return function (et, nt) {
        if (typeof nt != "function" && nt !== null)
          throw new TypeError(
            "Class extends value " +
              String(nt) +
              " is not a constructor or null"
          );
        tt(et, nt);
        function rt() {
          this.constructor = et;
        }
        et.prototype =
          nt === null
            ? Object.create(nt)
            : ((rt.prototype = nt.prototype), new rt());
      };
    })(),
  __generator =
    (globalThis && globalThis.__generator) ||
    function (tt, et) {
      var nt = {
          label: 0,
          sent: function () {
            if (st[0] & 1) throw st[1];
            return st[1];
          },
          trys: [],
          ops: [],
        },
        rt,
        it,
        st,
        ot;
      return (
        (ot = { next: at(0), throw: at(1), return: at(2) }),
        typeof Symbol == "function" &&
          (ot[Symbol.iterator] = function () {
            return this;
          }),
        ot
      );
      function at(ct) {
        return function (ut) {
          return lt([ct, ut]);
        };
      }
      function lt(ct) {
        if (rt) throw new TypeError("Generator is already executing.");
        for (; nt; )
          try {
            if (
              ((rt = 1),
              it &&
                (st =
                  ct[0] & 2
                    ? it.return
                    : ct[0]
                    ? it.throw || ((st = it.return) && st.call(it), 0)
                    : it.next) &&
                !(st = st.call(it, ct[1])).done)
            )
              return st;
            switch (((it = 0), st && (ct = [ct[0] & 2, st.value]), ct[0])) {
              case 0:
              case 1:
                st = ct;
                break;
              case 4:
                return nt.label++, { value: ct[1], done: !1 };
              case 5:
                nt.label++, (it = ct[1]), (ct = [0]);
                continue;
              case 7:
                (ct = nt.ops.pop()), nt.trys.pop();
                continue;
              default:
                if (
                  ((st = nt.trys),
                  !(st = st.length > 0 && st[st.length - 1]) &&
                    (ct[0] === 6 || ct[0] === 2))
                ) {
                  nt = 0;
                  continue;
                }
                if (ct[0] === 3 && (!st || (ct[1] > st[0] && ct[1] < st[3]))) {
                  nt.label = ct[1];
                  break;
                }
                if (ct[0] === 6 && nt.label < st[1]) {
                  (nt.label = st[1]), (st = ct);
                  break;
                }
                if (st && nt.label < st[2]) {
                  (nt.label = st[2]), nt.ops.push(ct);
                  break;
                }
                st[2] && nt.ops.pop(), nt.trys.pop();
                continue;
            }
            ct = et.call(tt, nt);
          } catch (ut) {
            (ct = [6, ut]), (it = 0);
          } finally {
            rt = st = 0;
          }
        if (ct[0] & 5) throw ct[1];
        return { value: ct[0] ? ct[1] : void 0, done: !0 };
      }
    },
  __spreadArray =
    (globalThis && globalThis.__spreadArray) ||
    function (tt, et) {
      for (var nt = 0, rt = et.length, it = tt.length; nt < rt; nt++, it++)
        tt[it] = et[nt];
      return tt;
    },
  __defProp = Object.defineProperty,
  __defProps = Object.defineProperties,
  __getOwnPropDescs = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp = function (tt, et, nt) {
    return et in tt
      ? __defProp(tt, et, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: nt,
        })
      : (tt[et] = nt);
  },
  __spreadValues = function (tt, et) {
    for (var nt in et || (et = {}))
      __hasOwnProp.call(et, nt) && __defNormalProp(tt, nt, et[nt]);
    if (__getOwnPropSymbols)
      for (var rt = 0, it = __getOwnPropSymbols(et); rt < it.length; rt++) {
        var nt = it[rt];
        __propIsEnum.call(et, nt) && __defNormalProp(tt, nt, et[nt]);
      }
    return tt;
  },
  __spreadProps = function (tt, et) {
    return __defProps(tt, __getOwnPropDescs(et));
  },
  __async = function (tt, et, nt) {
    return new Promise(function (rt, it) {
      var st = function (lt) {
          try {
            at(nt.next(lt));
          } catch (ct) {
            it(ct);
          }
        },
        ot = function (lt) {
          try {
            at(nt.throw(lt));
          } catch (ct) {
            it(ct);
          }
        },
        at = function (lt) {
          return lt.done
            ? rt(lt.value)
            : Promise.resolve(lt.value).then(st, ot);
        };
      at((nt = nt.apply(tt, et)).next());
    });
  },
  composeWithDevTools =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? compose
              : compose.apply(null, arguments);
        };
function isPlainObject(tt) {
  if (typeof tt != "object" || tt === null) return !1;
  var et = Object.getPrototypeOf(tt);
  if (et === null) return !0;
  for (var nt = et; Object.getPrototypeOf(nt) !== null; )
    nt = Object.getPrototypeOf(nt);
  return et === nt;
}
function createAction(tt, et) {
  function nt() {
    for (var rt = [], it = 0; it < arguments.length; it++)
      rt[it] = arguments[it];
    if (et) {
      var st = et.apply(void 0, rt);
      if (!st) throw new Error("prepareAction did not return an object");
      return __spreadValues(
        __spreadValues(
          { type: tt, payload: st.payload },
          "meta" in st && { meta: st.meta }
        ),
        "error" in st && { error: st.error }
      );
    }
    return { type: tt, payload: rt[0] };
  }
  return (
    (nt.toString = function () {
      return "" + tt;
    }),
    (nt.type = tt),
    (nt.match = function (rt) {
      return rt.type === tt;
    }),
    nt
  );
}
var MiddlewareArray = (function (tt) {
    __extends(et, tt);
    function et() {
      for (var nt = [], rt = 0; rt < arguments.length; rt++)
        nt[rt] = arguments[rt];
      var it = tt.apply(this, nt) || this;
      return Object.setPrototypeOf(it, et.prototype), it;
    }
    return (
      Object.defineProperty(et, Symbol.species, {
        get: function () {
          return et;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (et.prototype.concat = function () {
        for (var nt = [], rt = 0; rt < arguments.length; rt++)
          nt[rt] = arguments[rt];
        return tt.prototype.concat.apply(this, nt);
      }),
      (et.prototype.prepend = function () {
        for (var nt = [], rt = 0; rt < arguments.length; rt++)
          nt[rt] = arguments[rt];
        return nt.length === 1 && Array.isArray(nt[0])
          ? new (et.bind.apply(
              et,
              __spreadArray([void 0], nt[0].concat(this))
            ))()
          : new (et.bind.apply(et, __spreadArray([void 0], nt.concat(this))))();
      }),
      et
    );
  })(Array),
  EnhancerArray = (function (tt) {
    __extends(et, tt);
    function et() {
      for (var nt = [], rt = 0; rt < arguments.length; rt++)
        nt[rt] = arguments[rt];
      var it = tt.apply(this, nt) || this;
      return Object.setPrototypeOf(it, et.prototype), it;
    }
    return (
      Object.defineProperty(et, Symbol.species, {
        get: function () {
          return et;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (et.prototype.concat = function () {
        for (var nt = [], rt = 0; rt < arguments.length; rt++)
          nt[rt] = arguments[rt];
        return tt.prototype.concat.apply(this, nt);
      }),
      (et.prototype.prepend = function () {
        for (var nt = [], rt = 0; rt < arguments.length; rt++)
          nt[rt] = arguments[rt];
        return nt.length === 1 && Array.isArray(nt[0])
          ? new (et.bind.apply(
              et,
              __spreadArray([void 0], nt[0].concat(this))
            ))()
          : new (et.bind.apply(et, __spreadArray([void 0], nt.concat(this))))();
      }),
      et
    );
  })(Array);
function freezeDraftable(tt) {
  return t(tt) ? fn(tt, function () {}) : tt;
}
function isBoolean(tt) {
  return typeof tt == "boolean";
}
function curryGetDefaultMiddleware() {
  return function (et) {
    return getDefaultMiddleware(et);
  };
}
function getDefaultMiddleware(tt) {
  tt === void 0 && (tt = {});
  var et = tt.thunk,
    nt = et === void 0 ? !0 : et;
  tt.immutableCheck, tt.serializableCheck, tt.actionCreatorCheck;
  var rt = new MiddlewareArray();
  return (
    nt &&
      (isBoolean(nt)
        ? rt.push(thunkMiddleware)
        : rt.push(thunkMiddleware.withExtraArgument(nt.extraArgument))),
    rt
  );
}
var IS_PRODUCTION = !0;
function configureStore(tt) {
  var et = curryGetDefaultMiddleware(),
    nt = tt || {},
    rt = nt.reducer,
    it = rt === void 0 ? void 0 : rt,
    st = nt.middleware,
    ot = st === void 0 ? et() : st,
    at = nt.devTools,
    lt = at === void 0 ? !0 : at,
    ct = nt.preloadedState,
    ut = ct === void 0 ? void 0 : ct,
    ft = nt.enhancers,
    ht = ft === void 0 ? void 0 : ft,
    mt;
  if (typeof it == "function") mt = it;
  else if (isPlainObject(it)) mt = combineReducers(it);
  else
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  var vt = ot;
  typeof vt == "function" && (vt = vt(et));
  var yt = applyMiddleware.apply(void 0, vt),
    Et = compose;
  lt &&
    (Et = composeWithDevTools(
      __spreadValues({ trace: !IS_PRODUCTION }, typeof lt == "object" && lt)
    ));
  var pt = new EnhancerArray(yt),
    xt = pt;
  Array.isArray(ht)
    ? (xt = __spreadArray([yt], ht))
    : typeof ht == "function" && (xt = ht(pt));
  var St = Et.apply(void 0, xt);
  return createStore(mt, ut, St);
}
function executeReducerBuilderCallback(tt) {
  var et = {},
    nt = [],
    rt,
    it = {
      addCase: function (st, ot) {
        var at = typeof st == "string" ? st : st.type;
        if (!at)
          throw new Error(
            "`builder.addCase` cannot be called with an empty action type"
          );
        if (at in et)
          throw new Error(
            "`builder.addCase` cannot be called with two reducers for the same action type"
          );
        return (et[at] = ot), it;
      },
      addMatcher: function (st, ot) {
        return nt.push({ matcher: st, reducer: ot }), it;
      },
      addDefaultCase: function (st) {
        return (rt = st), it;
      },
    };
  return tt(it), [et, nt, rt];
}
function isStateFunction(tt) {
  return typeof tt == "function";
}
function createReducer(tt, et, nt, rt) {
  nt === void 0 && (nt = []);
  var it =
      typeof et == "function"
        ? executeReducerBuilderCallback(et)
        : [et, nt, rt],
    st = it[0],
    ot = it[1],
    at = it[2],
    lt;
  if (isStateFunction(tt))
    lt = function () {
      return freezeDraftable(tt());
    };
  else {
    var ct = freezeDraftable(tt);
    lt = function () {
      return ct;
    };
  }
  function ut(ft, ht) {
    ft === void 0 && (ft = lt());
    var mt = __spreadArray(
      [st[ht.type]],
      ot
        .filter(function (vt) {
          var yt = vt.matcher;
          return yt(ht);
        })
        .map(function (vt) {
          var yt = vt.reducer;
          return yt;
        })
    );
    return (
      mt.filter(function (vt) {
        return !!vt;
      }).length === 0 && (mt = [at]),
      mt.reduce(function (vt, yt) {
        if (yt)
          if (r(vt)) {
            var Et = vt,
              pt = yt(Et, ht);
            return pt === void 0 ? vt : pt;
          } else {
            if (t(vt))
              return fn(vt, function (xt) {
                return yt(xt, ht);
              });
            var pt = yt(vt, ht);
            if (pt === void 0) {
              if (vt === null) return vt;
              throw Error(
                "A case reducer on a non-draftable value must not return undefined"
              );
            }
            return pt;
          }
        return vt;
      }, ft)
    );
  }
  return (ut.getInitialState = lt), ut;
}
function getType2(tt, et) {
  return tt + "/" + et;
}
function createSlice(tt) {
  var et = tt.name;
  if (!et) throw new Error("`name` is a required option for createSlice");
  typeof process < "u";
  var nt =
      typeof tt.initialState == "function"
        ? tt.initialState
        : freezeDraftable(tt.initialState),
    rt = tt.reducers || {},
    it = Object.keys(rt),
    st = {},
    ot = {},
    at = {};
  it.forEach(function (ut) {
    var ft = rt[ut],
      ht = getType2(et, ut),
      mt,
      vt;
    "reducer" in ft ? ((mt = ft.reducer), (vt = ft.prepare)) : (mt = ft),
      (st[ut] = mt),
      (ot[ht] = mt),
      (at[ut] = vt ? createAction(ht, vt) : createAction(ht));
  });
  function lt() {
    var ut =
        typeof tt.extraReducers == "function"
          ? executeReducerBuilderCallback(tt.extraReducers)
          : [tt.extraReducers],
      ft = ut[0],
      ht = ft === void 0 ? {} : ft,
      mt = ut[1],
      vt = mt === void 0 ? [] : mt,
      yt = ut[2],
      Et = yt === void 0 ? void 0 : yt,
      pt = __spreadValues(__spreadValues({}, ht), ot);
    return createReducer(nt, function (xt) {
      for (var St in pt) xt.addCase(St, pt[St]);
      for (var At = 0, Ct = vt; At < Ct.length; At++) {
        var Mt = Ct[At];
        xt.addMatcher(Mt.matcher, Mt.reducer);
      }
      Et && xt.addDefaultCase(Et);
    });
  }
  var ct;
  return {
    name: et,
    reducer: function (ut, ft) {
      return ct || (ct = lt()), ct(ut, ft);
    },
    actions: at,
    caseReducers: st,
    getInitialState: function () {
      return ct || (ct = lt()), ct.getInitialState();
    },
  };
}
var urlAlphabet =
    "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  nanoid = function (tt) {
    tt === void 0 && (tt = 21);
    for (var et = "", nt = tt; nt--; )
      et += urlAlphabet[(Math.random() * 64) | 0];
    return et;
  },
  commonProperties = ["name", "message", "stack", "code"],
  RejectWithValue = (function () {
    function tt(et, nt) {
      (this.payload = et), (this.meta = nt);
    }
    return tt;
  })(),
  FulfillWithMeta = (function () {
    function tt(et, nt) {
      (this.payload = et), (this.meta = nt);
    }
    return tt;
  })(),
  miniSerializeError = function (tt) {
    if (typeof tt == "object" && tt !== null) {
      for (var et = {}, nt = 0, rt = commonProperties; nt < rt.length; nt++) {
        var it = rt[nt];
        typeof tt[it] == "string" && (et[it] = tt[it]);
      }
      return et;
    }
    return { message: String(tt) };
  };
(function () {
  function tt(et, nt, rt) {
    var it = createAction(et + "/fulfilled", function (ct, ut, ft, ht) {
        return {
          payload: ct,
          meta: __spreadProps(__spreadValues({}, ht || {}), {
            arg: ft,
            requestId: ut,
            requestStatus: "fulfilled",
          }),
        };
      }),
      st = createAction(et + "/pending", function (ct, ut, ft) {
        return {
          payload: void 0,
          meta: __spreadProps(__spreadValues({}, ft || {}), {
            arg: ut,
            requestId: ct,
            requestStatus: "pending",
          }),
        };
      }),
      ot = createAction(et + "/rejected", function (ct, ut, ft, ht, mt) {
        return {
          payload: ht,
          error: ((rt && rt.serializeError) || miniSerializeError)(
            ct || "Rejected"
          ),
          meta: __spreadProps(__spreadValues({}, mt || {}), {
            arg: ft,
            requestId: ut,
            rejectedWithValue: !!ht,
            requestStatus: "rejected",
            aborted: (ct == null ? void 0 : ct.name) === "AbortError",
            condition: (ct == null ? void 0 : ct.name) === "ConditionError",
          }),
        };
      }),
      at =
        typeof AbortController < "u"
          ? AbortController
          : (function () {
              function ct() {
                this.signal = {
                  aborted: !1,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return !1;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {},
                };
              }
              return (ct.prototype.abort = function () {}), ct;
            })();
    function lt(ct) {
      return function (ut, ft, ht) {
        var mt = rt != null && rt.idGenerator ? rt.idGenerator(ct) : nanoid(),
          vt = new at(),
          yt;
        function Et(xt) {
          (yt = xt), vt.abort();
        }
        var pt = (function () {
          return __async(this, null, function () {
            var xt, St, At, Ct, Mt, wt, Bt;
            return __generator(this, function (It) {
              switch (It.label) {
                case 0:
                  return (
                    It.trys.push([0, 4, , 5]),
                    (Ct =
                      (xt = rt == null ? void 0 : rt.condition) == null
                        ? void 0
                        : xt.call(rt, ct, { getState: ft, extra: ht })),
                    isThenable(Ct) ? [4, Ct] : [3, 2]
                  );
                case 1:
                  (Ct = It.sent()), (It.label = 2);
                case 2:
                  if (Ct === !1 || vt.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message:
                        "Aborted due to condition callback returning false.",
                    };
                  return (
                    (Mt = new Promise(function (Ft, Vt) {
                      return vt.signal.addEventListener("abort", function () {
                        return Vt({
                          name: "AbortError",
                          message: yt || "Aborted",
                        });
                      });
                    })),
                    ut(
                      st(
                        mt,
                        ct,
                        (St = rt == null ? void 0 : rt.getPendingMeta) == null
                          ? void 0
                          : St.call(
                              rt,
                              { requestId: mt, arg: ct },
                              { getState: ft, extra: ht }
                            )
                      )
                    ),
                    [
                      4,
                      Promise.race([
                        Mt,
                        Promise.resolve(
                          nt(ct, {
                            dispatch: ut,
                            getState: ft,
                            extra: ht,
                            requestId: mt,
                            signal: vt.signal,
                            abort: Et,
                            rejectWithValue: function (Ft, Vt) {
                              return new RejectWithValue(Ft, Vt);
                            },
                            fulfillWithValue: function (Ft, Vt) {
                              return new FulfillWithMeta(Ft, Vt);
                            },
                          })
                        ).then(function (Ft) {
                          if (Ft instanceof RejectWithValue) throw Ft;
                          return Ft instanceof FulfillWithMeta
                            ? it(Ft.payload, mt, ct, Ft.meta)
                            : it(Ft, mt, ct);
                        }),
                      ]),
                    ]
                  );
                case 3:
                  return (At = It.sent()), [3, 5];
                case 4:
                  return (
                    (wt = It.sent()),
                    (At =
                      wt instanceof RejectWithValue
                        ? ot(null, mt, ct, wt.payload, wt.meta)
                        : ot(wt, mt, ct)),
                    [3, 5]
                  );
                case 5:
                  return (
                    (Bt =
                      rt &&
                      !rt.dispatchConditionRejection &&
                      ot.match(At) &&
                      At.meta.condition),
                    Bt || ut(At),
                    [2, At]
                  );
              }
            });
          });
        })();
        return Object.assign(pt, {
          abort: Et,
          requestId: mt,
          arg: ct,
          unwrap: function () {
            return pt.then(unwrapResult);
          },
        });
      };
    }
    return Object.assign(lt, {
      pending: st,
      rejected: ot,
      fulfilled: it,
      typePrefix: et,
    });
  }
  return (
    (tt.withTypes = function () {
      return tt;
    }),
    tt
  );
})();
function unwrapResult(tt) {
  if (tt.meta && tt.meta.rejectedWithValue) throw tt.payload;
  if (tt.error) throw tt.error;
  return tt.payload;
}
function isThenable(tt) {
  return tt !== null && typeof tt == "object" && typeof tt.then == "function";
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
var promise;
typeof queueMicrotask == "function" &&
  queueMicrotask.bind(
    typeof window < "u" ? window : typeof global < "u" ? global : globalThis
  );
F$1();
const initialState = {
    radioClicked: "conventional",
    userDetails: [],
    userBalance: 0,
    receiverAmt: 0,
    sendAnmiation: !1,
    playBlockChain: "conventional",
    showCard: !1,
    resetTheAnimation: !1,
    isTransactionProgressing: !1,
    receiverName: "",
    showLedger: !1,
    transactionError: !1,
    showSideOption: !1,
    isLoadingReceipt: !1,
    enableAlerts: !1,
    moneySendToReciver: !1,
    isCancelation: !1,
    isReturnAmt: !1,
    instructionMessage: [],
    isAnimating: !1,
    animationProgress: 0,
    showGlowCube: !0,
    waiting: !1,
    task: !0,
    request: "normal",
    selectedColor: {
      sender: "#008000",
      receiver: "#ddddff",
      verifier: "#FFFF00",
    },
    verifierName: "",
    showLedgerAnimation: !1,
    clickedTime: 0,
    isRestart: !1,
    userBalanceBlockChain: 100,
    showCancelAlert: !1,
  },
  DoubleSpendingReducer = createSlice({
    name: "BlockChainDetails",
    initialState,
    reducers: {
      updateRadionChange: (tt, et) => {
        (tt.radioClicked = et.payload),
          (tt.showCard = !1),
          (tt.showLedger = !1),
          (tt.instructionMessage = []),
          (tt.userBalance = 0),
          (tt.isTransactionProgressing = !1),
          (tt.userDetails = []),
          (tt.waiting = !1),
          (tt.selectedColor = {
            sender: "#008000",
            receiver: "#ddddff",
            verifier: "#FFFF00",
          }),
          (tt.receiverName = ""),
          (tt.verifierName = ""),
          (tt.showLedgerAnimation = !1),
          (tt.clickedTime = 0),
          (tt.isRestart = !1),
          (tt.userBalanceBlockChain = 100);
      },
      updateRetart: (tt, et) => {
        (tt.radioClicked = "conventional"),
          (tt.showCard = !1),
          (tt.showLedger = !1),
          (tt.instructionMessage = []),
          (tt.userBalance = 0),
          (tt.isTransactionProgressing = !1),
          (tt.waiting = !1),
          (tt.userDetails = []),
          (tt.isRestart = !0),
          (tt.isAnimating = !1),
          (tt.animationProgress = 0),
          (tt.showGlowCube = !0),
          (tt.waiting = !1),
          (tt.task = !0),
          (tt.request = "normal"),
          (tt.selectedColor = {
            sender: "#008000",
            receiver: "#ddddff",
            verifier: "#FFFF00",
          }),
          (tt.receiverName = ""),
          (tt.verifierName = ""),
          (tt.showLedgerAnimation = !1),
          (tt.clickedTime = 0),
          (tt.isRestart = !1),
          (tt.userBalanceBlockChain = 100);
      },
      sendMoneyToReceiver: (tt, et) => {
        (tt.userDetails = [...tt.userDetails, et.payload]),
          (tt.receiverAmt = et.payload.amount),
          (tt.sendAnmiation = !0),
          (tt.verifierName = "");
      },
      sendReceiverName: (tt, et) => {
        tt.receiverName = et.payload;
      },
      onHandlePlayBlokChain: (tt, et) => {
        (tt.playBlockChain = et.payload.setType),
          (tt.showCard = et.payload.showCard);
      },
      transactionProgresing: (tt, et) => {
        tt.isTransactionProgressing = !0;
      },
      onEnableAlerts: (tt, et) => {
        tt.enableAlerts = !0;
      },
      UpdateMoneySendToReciver: (tt, et) => {
        tt.moneySendToReciver = et.payload;
      },
      transactionProgresingStop: (tt, et) => {
        tt.isTransactionProgressing = !1;
      },
      updateBalance: (tt, et) => {
        tt.userBalance = et.payload;
      },
      updateBalanceBlockChain: (tt, et) => {
        tt.userBalanceBlockChain = et.payload;
      },
      resetAnimation: (tt, et) => {
        tt.resetTheAnimation = et.payload;
      },
      updateStopAnimation: (tt, et) => {
        tt.sendAnmiation = et.payload;
      },
      updateLedger: (tt, et) => {
        tt.showLedger = et.payload;
      },
      updateTranscationError: (tt, et) => {
        tt.transactionError = et.payload;
      },
      updateShowSideOption: (tt, et) => {
        tt.showSideOption = et.payload;
      },
      updateInstruction: (tt, et) => {
        tt.instructionMessage = et.payload;
      },
      startAnimation: (tt) => {
        (tt.isAnimating = !0),
          (tt.showGlowCube = !0),
          (tt.animationProgress = 0);
      },
      stopAnimation: (tt) => {
        (tt.isAnimating = !1),
          (tt.animationProgress = 0),
          (tt.showGlowCube = !1);
      },
      updateAnimationProgress: (tt, et) => {
        tt.animationProgress = et.payload;
      },
      waitingStart: (tt, et) => {
        tt.waiting = et.payload;
      },
      updateClickTime: (tt, et) => {
        tt.clickedTime = et.payload;
      },
      updateTask: (tt, et) => {
        tt.task = et.payload;
      },
      updateRquest: (tt, et) => {
        tt.request = et.payload;
      },
      updateSelectedColor: (tt, et) => {
        tt.selectedColor = et.payload;
      },
      onHandleChangeVerifer: (tt, et) => {
        tt.verifierName = et.payload;
      },
      updateLedgerAnimation: (tt, et) => {
        tt.showLedgerAnimation = et.payload;
      },
      updateShowAlert: (tt, et) => {
        tt.showCancelAlert = et.payload;
      },
    },
  }),
  {
    updateShowAlert,
    returnAmount,
    updateRadionChange,
    sendMoneyToReceiver,
    onHandlePlayBlokChain,
    updateShowSideOption,
    updateBalance,
    updateBalanceBlockChain,
    transactionProgresing,
    resetAnimation,
    updateTranscationError,
    updateLedger,
    transactionProgresingStop,
    sendReceiverName,
    updateStopAnimation,
    onEnableAlerts,
    UpdateMoneySendToReciver,
    updateIsCancel,
    updateInstruction,
    startAnimation,
    stopAnimation,
    updateAnimationProgress,
    waitingStart,
    updateRetart,
    updateTask,
    updateRquest,
    updateSelectedColor,
    onHandleChangeVerifer,
    updateLedgerAnimation,
    updateClickTime,
  } = DoubleSpendingReducer.actions,
  DoubleSpendingReducer$1 = DoubleSpendingReducer.reducer,
  CubeAnimationB = () => {
    const tt = useLoader(TextureLoader, ledger),
      et = useDispatch(),
      { instructionMessage: nt, verifierName: rt } = useSelector(
        (ut) => ut.DoubleSpendingReducer
      ),
      [it, st] = reactExports.useState({
        c: !0,
        d: !0,
        a: !0,
        e: !0,
        aHide: !1,
        dHide: !1,
        cHide: !1,
        eHide: !1,
      }),
      ot = reactExports.useRef(),
      at = reactExports.useRef(),
      lt = reactExports.useRef(),
      ct = reactExports.useRef();
    return (
      useFrame(() => {
        it.a &&
          ((lt.current.position.x -= 0.05),
          (lt.current.position.z += 0.02),
          (lt.current.position.y -= 0.05)),
          it.c &&
            ((ot.current.position.x += 0.05),
            (ot.current.position.z += 0.02),
            (ot.current.position.y -= 0.05)),
          it.e && (ct.current.position.y -= 0.05),
          it.d && (at.current.position.y -= 0.05);
      }),
      reactExports.useEffect(() => {
        let ut;
        return (
          (ut = setTimeout(() => {
            st((ft) => ({ ...ft, a: !1, aHide: !0, cHide: !0, c: !1 })),
              setTimeout(() => {
                st((ft) => ({ ...ft, eHide: !0, e: !1, d: !1, dHide: !0 }));
              }, 1200),
              et(
                updateInstruction([
                  ...nt,
                  `User-${rt} can now pass the transaction ledger to other users for additional verification`,
                  ,
                ])
              );
          }, 1e3)),
          () => {
            clearTimeout(ut);
          }
        );
      }, []),
      React.createElement(
        "group",
        null,
        React.createElement(
          "mesh",
          { scale: it.aHide ? 0 : 1, position: [0.4, 3, 0], ref: lt },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { scale: it.cHide ? 0 : 1, position: [0.3, 3, 0], ref: ot },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, 3, 0], scale: it.eHide ? 0 : 1, ref: ct },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, 3, 0], scale: it.dHide ? 0 : 1, ref: at },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        )
      )
    );
  },
  CubeAnimationD = () => {
    const tt = useLoader(TextureLoader, ledger),
      et = useDispatch(),
      { instructionMessage: nt, verifierName: rt } = useSelector(
        (ut) => ut.DoubleSpendingReducer
      ),
      [it, st] = reactExports.useState({
        c: !0,
        b: !0,
        a: !0,
        e: !0,
        aHide: !1,
        eHide: !1,
        cHide: !1,
        bHide: !1,
      }),
      ot = reactExports.useRef(),
      at = reactExports.useRef(),
      lt = reactExports.useRef(),
      ct = reactExports.useRef();
    return (
      useFrame(() => {
        it.a &&
          ((lt.current.position.y += 0.03), (lt.current.position.x -= 0.03)),
          it.c &&
            ((ot.current.position.y += 0.03), (ot.current.position.x += 0.03)),
          it.e && (at.current.position.y += 0.03),
          it.d && (cubeD.current.position.y += 0.03);
      }),
      reactExports.useEffect(() => {
        let ut;
        return (
          (ut = setTimeout(() => {
            st((ft) => ({ ...ft, a: !1, aHide: !0, cHide: !0, c: !1 })),
              setTimeout(() => {
                st((ft) => ({ ...ft, bHide: !0, b: !1, e: !1, eHide: !0 }));
              }, 1700),
              et(
                updateInstruction([
                  ...nt,
                  `User-${rt} can now pass the transaction ledger to other users for additional verification`,
                ])
              );
          }, 1800)),
          () => {
            clearTimeout(ut);
          }
        );
      }, []),
      React.createElement(
        "group",
        null,
        React.createElement(
          "mesh",
          { scale: it.aHide ? 0 : 1, position: [0.1, -3, 0], ref: lt },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { scale: it.cHide ? 0 : 1, position: [0.3, -3, 0], ref: ot },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, -3, 0], scale: it.bHide ? 0 : 1, ref: ct },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, -3, 0], scale: it.eHide ? 0 : 1, ref: at },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        )
      )
    );
  },
  CubeAnimationC = () => {
    const tt = useLoader(TextureLoader, ledger);
    useDispatch(), useSelector((at) => at.DoubleSpendingReducer);
    const [et, nt] = reactExports.useState({
        d: !0,
        e: !0,
        b: !0,
        a: !0,
        aHide: !1,
        eHide: !1,
        dHide: !1,
        bHide: !1,
      }),
      rt = reactExports.useRef(),
      it = reactExports.useRef(),
      st = reactExports.useRef(),
      ot = reactExports.useRef();
    return (
      useFrame(() => {
        et.b &&
          ((ot.current.position.y += 0.03), (ot.current.position.x -= 0.03)),
          et.d &&
            ((rt.current.position.y -= 0.03), (rt.current.position.x -= 0.03)),
          et.e && (it.current.position.x -= 0.03),
          et.a && (st.current.position.x -= 0.03);
      }),
      reactExports.useEffect(() => {
        let at;
        return (
          (at = setTimeout(() => {
            nt((ft) => ({ ...ft, d: !1, dHide: !0, bHide: !0, b: !1 })),
              setTimeout(() => {
                nt((ft) => ({ ...ft, aHide: !0, a: !1, e: !1, eHide: !0 }));
              }, 1800),
              lt(
                updateInstruction([
                  ...ct,
                  `User-${ut} can now pass the transaction ledger to other users for additional verification`,
                ])
              );
            const lt = useDispatch(),
              { instructionMessage: ct, verifierName: ut } = useSelector(
                (ft) => ft.DoubleSpendingReducer
              );
          }, 1800)),
          () => {
            clearTimeout(at);
          }
        );
      }, []),
      React.createElement(
        "group",
        null,
        React.createElement(
          "mesh",
          { scale: et.bHide ? 0 : 1, position: [4, 0, 0], ref: ot },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { scale: et.dHide ? 0 : 1, position: [3.7, 0, 0], ref: rt },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [3.7, 0, 0], scale: et.aHide ? 0 : 1, ref: st },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        ),
        React.createElement(
          "mesh",
          { position: [3.7, 0, 0], scale: et.eHide ? 0 : 1, ref: it },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: tt })
        )
      )
    );
  },
  CubeAnimationE = () => {
    const tt = useDispatch(),
      { instructionMessage: et, verifierName: nt } = useSelector(
        (ut) => ut.DoubleSpendingReducer
      ),
      [rt, it] = reactExports.useState({
        d: !0,
        c: !0,
        b: !0,
        a: !0,
        aHide: !1,
        cHide: !1,
        dHide: !1,
        bHide: !1,
      }),
      st = reactExports.useRef(),
      ot = reactExports.useRef(),
      at = reactExports.useRef(),
      lt = reactExports.useRef(),
      ct = useLoader(TextureLoader, ledger);
    return (
      useFrame(() => {
        rt.b && (lt.current.position.y += 0.03),
          rt.d && (st.current.position.y -= 0.03),
          rt.c && (ot.current.position.x -= 0.03),
          rt.a && (at.current.position.x += 0.03);
      }),
      reactExports.useEffect(() => {
        let ut;
        return (
          (ut = setTimeout(() => {
            it((ft) => ({ ...ft, d: !1, dHide: !0, bHide: !0, b: !1 })),
              setTimeout(() => {
                it((ft) => ({ ...ft, aHide: !0, a: !1, c: !1, cHide: !0 }));
              }, 100),
              tt(
                updateInstruction([
                  ...et,
                  `User-${nt} can now pass the transaction ledger to other users for additional verification`,
                ])
              );
          }, 1800)),
          () => {
            clearTimeout(ut);
          }
        );
      }, []),
      React.createElement(
        "group",
        null,
        React.createElement(
          "mesh",
          { scale: rt.bHide ? 0 : 1, position: [0.5, 0, 0], ref: lt },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: ct })
        ),
        React.createElement(
          "mesh",
          { scale: rt.dHide ? 0 : 1, position: [0.5, 0, 0], ref: st },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: ct })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, 0, 0], scale: rt.aHide ? 0 : 1, ref: at },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: ct })
        ),
        React.createElement(
          "mesh",
          { position: [0.5, 0, 0], scale: rt.cHide ? 0 : 1, ref: ot },
          React.createElement("boxGeometry", { args: [0.5, 0.2, 0.5] }),
          React.createElement("meshBasicMaterial", { map: ct })
        )
      )
    );
  },
  BlockChain = () => {
    const tt = reactExports.useRef(),
      et = reactExports.useRef(),
      nt = reactExports.useRef(),
      rt = reactExports.useRef(),
      it = reactExports.useRef(),
      st = useLoader(TextureLoader, img),
      {
        receiverName: ot,
        receiverAmt: at,
        selectedColor: lt,
        verifierName: ct,
        showLedgerAnimation: ut,
      } = useSelector((vt) => vt.DoubleSpendingReducer),
      { sender: ft, receiver: ht, verifier: mt } = lt;
    return (
      useFrame(() => {
        (tt.current.rotation.y += 0.03),
          (et.current.rotation.y += 0.03),
          (nt.current.rotation.y += 0.03),
          (rt.current.rotation.y += 0.03),
          (it.current.rotation.y += 0.03);
      }),
      React.createElement(
        "group",
        null,
        React.createElement(
          "group",
          null,
          React.createElement(
            "group",
            { position: [-1, 0, 0] },
            React.createElement(
              "mesh",
              { position: [-2, 0, 0] },
              React.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }),
              React.createElement("meshBasicMaterial", {
                color: ft,
                transparent: !0,
                opacity: 0.3,
              })
            ),
            React.createElement(
              "mesh",
              { ref: tt, position: [-2, 0, 0] },
              React.createElement("boxGeometry", { args: [0.8, 0.8, 0.8] }),
              React.createElement("meshBasicMaterial", { map: st })
            ),
            React.createElement(
              Text,
              { scale: 0.3, position: [-3.2, 0, 0] },
              "A"
            )
          ),
          React.createElement(
            "group",
            { position: [0, 1, 0] },
            React.createElement(
              "mesh",
              { position: [0.5, 2, 0] },
              React.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }),
              React.createElement("meshBasicMaterial", {
                color: ct === "B" ? mt : ot === "B" ? ht : "#ddddff",
                transparent: !0,
                opacity: 0.2,
              })
            ),
            React.createElement(
              "mesh",
              { ref: et, position: [0.5, 2, 0] },
              React.createElement("boxGeometry", { args: [0.8, 0.8, 0.8] }),
              React.createElement("meshBasicMaterial", { map: st })
            ),
            React.createElement(
              Text,
              { scale: 0.3, position: [0.5, 3, 0] },
              "B"
            )
          ),
          React.createElement(
            "group",
            { position: [1, 0, 0] },
            React.createElement(
              "mesh",
              { position: [3, 0, 0] },
              React.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }),
              React.createElement("meshBasicMaterial", {
                color: ct === "C" ? mt : ot === "C" ? ht : "#ddddff",
                transparent: !0,
                opacity: 0.3,
              })
            ),
            React.createElement(
              "mesh",
              { ref: nt, position: [3, 0, 0] },
              React.createElement("boxGeometry", { args: [0.8, 0.8, 0.8] }),
              React.createElement("meshBasicMaterial", { map: st })
            ),
            React.createElement(
              Text,
              { scale: 0.3, position: [4.2, 0, 0] },
              "C"
            )
          ),
          React.createElement(
            "group",
            { position: [0, -1, 0] },
            React.createElement(
              "mesh",
              { position: [0.5, -2, 0] },
              React.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }),
              React.createElement("meshBasicMaterial", {
                color: ct === "D" ? mt : ot === "D" ? ht : "#ddddff",
                transparent: !0,
                opacity: 0.3,
              })
            ),
            React.createElement(
              "mesh",
              { ref: rt, position: [0.5, -2, 0] },
              React.createElement("boxGeometry", { args: [0.8, 0.8, 0.8] }),
              React.createElement("meshBasicMaterial", { map: st })
            ),
            React.createElement(
              Text,
              { scale: 0.3, position: [0.5, -3.3, 0] },
              "D"
            )
          ),
          React.createElement(
            "group",
            null,
            React.createElement(
              "mesh",
              { position: [0.5, 0, 0] },
              React.createElement("boxGeometry", { args: [1.5, 1.5, 1.5] }),
              React.createElement("meshBasicMaterial", {
                color: ct === "E" ? mt : ot === "E" ? ht : "#ddddff",
                transparent: !0,
                opacity: 0.3,
              })
            ),
            React.createElement(
              "mesh",
              { ref: it, position: [0.5, 0, 0] },
              React.createElement("boxGeometry", { args: [0.8, 0.8, 0.8] }),
              React.createElement("meshBasicMaterial", { map: st })
            ),
            React.createElement(
              Text,
              { scale: 0.3, position: [0.7, 1, 0] },
              "E"
            )
          )
        ),
        React.createElement(
          "group",
          null,
          React.createElement(Line, {
            points: [
              [0.5, 2.2, 0],
              [0.5, 0.8, 0],
            ],
            lineWidth: 5,
            color: "#034179",
          }),
          React.createElement(Line, {
            points: [
              [0.5, -2.2, 0],
              [0.5, 0.8, 0],
            ],
            lineWidth: 5,
            color: "#034179",
          }),
          React.createElement(Line, {
            points: [
              [1.3, 3, 0],
              [3.9, 0.8, 0],
            ],
            lineWidth: 5,
            color: "#034179",
          }),
          React.createElement(
            "group",
            null,
            React.createElement(Line, {
              points: [
                [-0.3, 3, 0],
                [-3, 0.8, 0],
              ],
              lineWidth: 5,
              color: ot === "B" ? ft : "#034179",
              opacity: 0.5,
            }),
            ot === "B" &&
              React.createElement(
                Text,
                {
                  color: "yellow",
                  position: [-2, 2, 0],
                  rotation: [0, 0, 6.95],
                  scale: 0.23,
                },
                "sending ",
                at,
                "Rs"
              )
          ),
          React.createElement(
            "group",
            null,
            React.createElement(Line, {
              points: [
                [-3, -0.8, 0],
                [-0.3, -3, 0],
              ],
              lineWidth: 5,
              color: ot === "D" ? ft : "#034179",
            }),
            ot === "D" &&
              React.createElement(
                Text,
                {
                  color: "yellow",
                  position: [-2, -2, 0],
                  rotation: [0, 0, -6.95],
                  scale: 0.23,
                },
                "sending ",
                at,
                "Rs"
              )
          ),
          React.createElement(Line, {
            points: [
              [4, -0.8, 0],
              [1.3, -3, 0],
            ],
            lineWidth: 5,
            color: "#034179",
          }),
          React.createElement(
            "group",
            null,
            ot === "E" &&
              React.createElement(
                Text,
                {
                  color: "yellow",
                  position: [-1.2, 0.5, 0],
                  rotation: [0, 0, 0],
                  scale: 0.23,
                },
                "sending ",
                at,
                "Rs"
              ),
            React.createElement(Line, {
              points: [
                [-2.23, 0, 0],
                [-0.3, -0, 0],
              ],
              lineWidth: 5,
              color: ot === "C" || ot === "E" ? ft : "#034179",
            })
          ),
          React.createElement(
            "group",
            null,
            React.createElement(Line, {
              points: [
                [1.3, 0, 0],
                [3.25, -0, 0],
              ],
              lineWidth: 5,
              color: ot === "C" ? ft : "#034179",
            }),
            ot === "C" &&
              React.createElement(
                Text,
                {
                  color: "yellow",
                  position: [2.2, 0.5, 0],
                  rotation: [0, 0, 0],
                  scale: 0.23,
                },
                "sending ",
                at,
                "Rs"
              )
          ),
          React.createElement(
            "group",
            null,
            ut && ct === "B" && React.createElement(CubeAnimationB, null),
            ut && ct === "D" && React.createElement(CubeAnimationD, null),
            ut && ct === "C" && React.createElement(CubeAnimationC, null),
            ut && ct === "E" && React.createElement(CubeAnimationE, null)
          )
        )
      )
    );
  };
function Server(tt) {
  const { nodes: et, materials: nt } = useGLTF("images/server.glb");
  return React.createElement(
    "group",
    { scale: 0.7, ...tt, dispose: null },
    React.createElement(
      "group",
      { position: [2.089, 0, -5], rotation: [-Math.PI / 2, 0, 0] },
      React.createElement(
        "group",
        { rotation: [Math.PI / 2, 0, 0], scale: 0.01 },
        React.createElement(
          "group",
          {
            position: [-233.279, 69.331, 371.805],
            rotation: [-Math.PI / 2, 0, -3.124],
            scale: 100,
          },
          React.createElement("mesh", {
            geometry: et.Server_2_shell_alu_power_bank_0.geometry,
            material: nt.alu_power_bank,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_alu_0.geometry,
            material: nt.material,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_blinky_0.geometry,
            material: nt.blinky,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Blue_blinky_light_0.geometry,
            material: nt.Blue_blinky_light,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_hdd_base_0.geometry,
            material: nt.hdd_base,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Hdd_case_sliver_0.geometry,
            material: nt.Hdd_case_sliver,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Hdd_Dock_0.geometry,
            material: nt.Hdd_Dock,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material010_0.geometry,
            material: nt["Material.010"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material012_0.geometry,
            material: nt["Material.012"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material013_0.geometry,
            material: nt["Material.013"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material015_0.geometry,
            material: nt["Material.015"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material016_0.geometry,
            material: nt["Material.016"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material017_0.geometry,
            material: nt["Material.017"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material018_0.geometry,
            material: nt["Material.018"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material020_0.geometry,
            material: nt["Material.020"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_Material026_0.geometry,
            material: nt["Material.026"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_green001_0.geometry,
            material: nt["progress_bar_green.001"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_green002_0.geometry,
            material: nt["progress_bar_green.002"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_green004_0.geometry,
            material: nt["progress_bar_green.004"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_green_0.geometry,
            material: nt.progress_bar_green,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_red_blinky_0.geometry,
            material: nt.progress_bar_red_blinky,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_red_0.geometry,
            material: nt.progress_bar_red,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_yellow001_0.geometry,
            material: nt["progress_bar_yellow.001"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_progress_bar_yellow_0.geometry,
            material: nt.progress_bar_yellow,
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_server_computer001_0.geometry,
            material: nt["server_computer.001"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_server_computer002_0.geometry,
            material: nt["server_computer.002"],
          }),
          React.createElement("mesh", {
            geometry: et.Server_2_shell_server_computer_0.geometry,
            material: nt.server_computer,
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images__7_0"].geometry,
            material: nt["server-images__7"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images__8_0"].geometry,
            material: nt["server-images__8"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images__9_0"].geometry,
            material: nt["server-images__9"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images_2_0"].geometry,
            material: nt["server-images_2"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images_3_0"].geometry,
            material: nt["server-images_3"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images_4_0"].geometry,
            material: nt["server-images_4"],
          }),
          React.createElement("mesh", {
            geometry: et["Server_2_shell_server-images_5_0"].geometry,
            material: nt["server-images_5"],
          })
        )
      )
    )
  );
}
useGLTF.preload("images/server.glb");
const Glowcube = ({ position: tt }) =>
  React.createElement(
    "mesh",
    { position: tt },
    React.createElement("boxGeometry", { args: [0.2, 0.2, 0.2] }),
    React.createElement("meshStandardMaterial", { emissive: "yellow" })
  );
function Bank() {
  const {
      receiverName: tt,
      receiverAmt: et,
      instructionMessage: nt,
      isAnimating: rt,
      showGlowCube: it,
      animationProgress: st,
      waiting: ot,
      task: at,
      userBalance: lt,
      request: ct,
      isRestart: ut,
    } = useSelector((vt) => vt.DoubleSpendingReducer),
    ft = useDispatch(),
    ht = reactExports.useRef();
  function mt(vt, yt, Et) {
    console.log(vt);
    const pt = vt + yt / Et;
    return pt >= 1 ? (ft(stopAnimation()), ft(waitingStart(!0)), 1) : pt;
  }
  return (
    useFrame((vt, yt) => {
      if ((console.log(ct), rt)) {
        const pt = mt(st, yt, 2.7);
        ft(updateAnimationProgress(pt)),
          ct === "return"
            ? (ht.current.position.x -= yt * 2)
            : (ht.current.position.x += yt * 2);
      }
    }),
    reactExports.useEffect(() => {
      let vt;
      return (
        ot &&
          (ft(
            updateInstruction([
              ...nt,
              "Once Ram sends the money, it is received by the bank, which then initiates the  of the transaction.",
            ])
          ),
          ft(updateTask(1)),
          (vt = setTimeout(() => {
            ft(startAnimation()), ft(updateTask(2));
          }, 2e3))),
        () => {
          clearTimeout(vt);
        }
      );
    }, [ot]),
    reactExports.useEffect(() => {
      at === 2 &&
        ft(
          updateInstruction([
            ...nt,
            `
          In this process, the bank will disburse the funds to ${tt} before the transaction is considered finalized.`,
            "By pressing the cancel button, you can detect instances of double spending occurring in a centralized database.",
          ])
        );
    }, [at]),
    reactExports.useEffect(() => {
      let vt;
      return (
        ct === "cancel" &&
          ((ht.current.position.x = -1),
          (ht.current.position.y = 1.9),
          (ht.current.position.z = -1.5),
          ft(
            updateInstruction([
              ...nt,
              `Ram has contacted the bank with a request to revoke or void the Demand Draft (DD) transaction that was originally intended for ${tt}.`,
            ])
          ),
          (vt = setTimeout(() => {
            ft(updateRquest("return")), ft(startAnimation());
          }, 4e3))),
        ct === "return" &&
          ft(
            updateInstruction([
              ...nt,
              `Despite the bank returning ${lt} rupees to Ram, it failed to deduct the same amount from ${tt}'s account.`,
              `
    In this scenario, both Ram and ${tt} now possess ${lt} rupees each, while the bank's ledger appears to be missing ${lt} rupees, creating a discrepancy in the bank's records..`,
            ])
          ),
        () => {
          clearTimeout(vt);
        }
      );
    }, [ct]),
    React.createElement(
      "group",
      { position: [0, -0.5, 0] },
      React.createElement(
        "group",
        {
          scale: it ? 1 : 0,
          ref: ht,
          rotation: [0, 6.2, 0],
          position: [-1, 1.9, -1.5],
        },
        React.createElement(
          Text,
          {
            strokeColor: "white",
            position: [-4.7, 0.5, 0],
            fontSize: 0.2,
            scale: it ? 1 : 0,
            strokeWidth: 10,
          },
          ct === "cancel" ? "Cancel Request" : `${et} Rs`
        ),
        React.createElement(Glowcube, { position: [-5, 0, 0] }),
        React.createElement(Glowcube, { position: [-4.7, 0, 0] }),
        React.createElement(Glowcube, { position: [-4.4, 0, 0] })
      ),
      React.createElement(
        "group",
        { position: [0, 0, -0.5] },
        React.createElement(
          "group",
          { position: [-1, -0.1, 0] },
          React.createElement(Server, { position: [2, 0, 0] }),
          React.createElement(Server, { position: [1, 0, 0] }),
          React.createElement(Server, { position: [0, 0, 0] })
        ),
        React.createElement(
          Text,
          {
            strokeColor: "white",
            position: [-0.1, 4, -2.5],
            fontSize: 0.2,
            scale: 1.5,
            strokeWidth: 10,
          },
          "Conventional Transaction"
        ),
        React.createElement(
          "mesh",
          null,
          React.createElement("spotLight", {
            intensity: 500,
            angle: 0.7,
            position: [0, -3, 0],
            color: ot ? "red" : "white",
          })
        )
      )
    )
  );
}
function UserOne(tt) {
  const et = reactExports.useRef(),
    {
      nodes: nt,
      materials: rt,
      animations: it,
    } = useGLTF("images/user1.glb"),
    { actions: st, names: ot } = useAnimations(it, et);
  return (
    reactExports.useEffect(() => {
      st[ot[0]].reset().fadeIn(0.5).play();
    }, []),
    React.createElement(
      "group",
      { scale: 1.3, ref: et, ...tt, dispose: null },
      React.createElement(
        "group",
        { position: [0.35, 0.1, 0.55], rotation: [0, 3, 0], name: "Scene" },
        React.createElement(
          "group",
          { name: "Sketchfab_model", rotation: [-Math.PI / 2, 0, 0] },
          React.createElement(
            "group",
            {
              name: "fe4cac43b7ae44b39c27b8d450c38bb6fbx",
              rotation: [Math.PI / 2.5, 0, 0],
            },
            React.createElement(
              "group",
              { name: "RootNode" },
              React.createElement("group", { name: "Bank_Asset" })
            )
          )
        ),
        React.createElement(
          "group",
          { name: "Armature001", rotation: [Math.PI / 2, 0, 0], scale: 0.01 },
          React.createElement("primitive", { object: nt.mixamorig7Hips }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Belt001",
            geometry: nt.Ch33_Belt001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Belt001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Body001",
            geometry: nt.Ch33_Body001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Body001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Eyelashes001",
            geometry: nt.Ch33_Eyelashes001.geometry,
            material: rt["Ch33_hair.001"],
            skeleton: nt.Ch33_Eyelashes001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Hair001",
            geometry: nt.Ch33_Hair001.geometry,
            material: rt["Ch33_hair.001"],
            skeleton: nt.Ch33_Hair001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Pants001",
            geometry: nt.Ch33_Pants001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Pants001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Shirt001",
            geometry: nt.Ch33_Shirt001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Shirt001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Shoes001",
            geometry: nt.Ch33_Shoes001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Shoes001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Suit001",
            geometry: nt.Ch33_Suit001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Suit001.skeleton,
          }),
          React.createElement("skinnedMesh", {
            name: "Ch33_Tie001",
            geometry: nt.Ch33_Tie001.geometry,
            material: rt["Ch33_body.001"],
            skeleton: nt.Ch33_Tie001.skeleton,
          })
        )
      )
    )
  );
}
useGLTF.preload("images/user1.glb");
function Office(tt) {
  const { nodes: et, materials: nt } = useGLTF("images/Office.glb");
  return React.createElement(
    "group",
    { ...tt, dispose: null },
    React.createElement(
      "group",
      {
        position: [0.27, 0.942, 0],
        rotation: [-Math.PI / 2, 0, 0],
        scale: 0.006,
      },
      React.createElement(
        "group",
        { rotation: [Math.PI / 2, 0, 0] },
        React.createElement(
          "group",
          {
            position: [47.82, -0.996, 69.998],
            rotation: [-Math.PI / 2, 0, 1.658],
            scale: 0.21,
          },
          React.createElement("mesh", {
            geometry: et["Box001_01_-_Default_0"].geometry,
            material: nt["01_-_Default"],
            position: [274.495, -24.015, 0],
          }),
          React.createElement("mesh", {
            geometry: et["Box001_02_-_Default_0"].geometry,
            material: nt["02_-_Default_1"],
          }),
          React.createElement("mesh", {
            geometry: et["Box001_03_-_Default_0"].geometry,
            material: nt["03_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Box001_07_-_Default_0"].geometry,
            material: nt["07_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Box001_07_-_Default_0001"].geometry,
            material: nt["07_-_Default_1"],
          }),
          React.createElement("mesh", {
            geometry: et["Box001_13_-_Default_0"].geometry,
            material: nt["13_-_Default_0"],
          })
        ),
        React.createElement(
          "group",
          { position: [0.184, 0, 65.626], rotation: [-Math.PI / 2, 0, 0] },
          React.createElement("mesh", {
            geometry: et["Box005_14_-_Default_0"].geometry,
            material: nt["14_-_Default"],
            position: [0, 57.727, 0],
          }),
          React.createElement("mesh", {
            geometry: et["Box005_15_-_Default_0"].geometry,
            material: nt["15_-_Default"],
          })
        ),
        React.createElement(
          "group",
          {
            position: [5.839, -7.659, 7.98],
            rotation: [-Math.PI / 2, 0, 0],
            scale: [1, 0.627, 0.36],
          },
          React.createElement("mesh", {
            geometry: et["Box006_07_-_Default_0"].geometry,
            material: nt["07_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Box006_Material_#195_0"].geometry,
            material: nt.Material_195,
          })
        ),
        React.createElement(
          "group",
          { position: [-9.657, 4.698, 65.836], rotation: [-Math.PI / 2, 0, 0] },
          React.createElement(
            "group",
            { position: [0.019, 1.129, -124.145] },
            React.createElement("mesh", {
              geometry: et["Box008_07_-_Default_0"].geometry,
              material: nt["07_-_Default_0"],
              position: [0, 56.475, 0],
            }),
            React.createElement("mesh", {
              geometry: et["Box008_15_-_Default_0"].geometry,
              material: nt["15_-_Default"],
              position: [0, 57.727, 0],
            })
          )
        ),
        React.createElement(
          "group",
          {
            position: tt.cpuPos,
            rotation: [-Math.PI / 2, 0, 0],
            scale: [0.699, 0.929, 0.674],
          },
          React.createElement("mesh", {
            geometry: et["Box011_07_-_Default_0"].geometry,
            material: nt["07_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Box011_20_-_Default_0"].geometry,
            material: nt["20_-_Default"],
          }),
          React.createElement("mesh", {
            geometry: et["Box011_22_-_Default_0"].geometry,
            material: nt["22_-_Default"],
          })
        ),
        React.createElement(
          "group",
          { position: [-138.019, 0, 999.622], rotation: [-Math.PI / 2, 0, 0] },
          React.createElement("mesh", {
            geometry: et["Box015_21_-_Default_0"].geometry,
            material: nt["21_-_Default"],
          }),
          React.createElement("mesh", {
            geometry: et["Box015_24_-_Default_0"].geometry,
            material: nt["24_-_Default"],
          }),
          React.createElement("mesh", {
            geometry: et["Box015_Material_#299_0"].geometry,
            material: nt.Material_299,
          }),
          React.createElement("mesh", {
            geometry: et["Box015_Material_#301_0"].geometry,
            material: nt.Material_301,
          }),
          React.createElement("mesh", {
            geometry: et["Box015_Material_#304_0"].geometry,
            material: nt.Material_304,
          })
        ),
        React.createElement(
          "group",
          { position: [139.8, 0, 27.333], rotation: [-Math.PI / 2, 0, 1.134] },
          React.createElement("mesh", {
            geometry: et["Cylinder010_02_-_Default_0"].geometry,
            material: nt["02_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Cylinder010_07_-_Default_0"].geometry,
            material: nt["07_-_Default"],
          })
        ),
        React.createElement(
          "group",
          {
            position: [146.046, 33.129, 14.355],
            rotation: [0, -0.436, Math.PI / 2],
            scale: [0.674, 0.674, 0.896],
          },
          React.createElement("mesh", {
            geometry: et["Cylinder012_02_-_Default_0"].geometry,
            material: nt["02_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Cylinder012_Material_#26_0"].geometry,
            material: nt.Material_26,
          })
        ),
        React.createElement(
          "group",
          {
            position: [-135.652, 0, 28.517],
            rotation: [-Math.PI / 2, 0, 2.007],
          },
          React.createElement("mesh", {
            geometry: et["Cylinder016_02_-_Default_0"].geometry,
            material: nt["02_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Cylinder016_07_-_Default_0"].geometry,
            material: nt["07_-_Default"],
          })
        ),
        React.createElement(
          "group",
          {
            position: [-141.578, 33.129, 15.39],
            rotation: [0, 0.436, Math.PI / 2],
            scale: [0.674, 0.674, 0.896],
          },
          React.createElement("mesh", {
            geometry: et["Cylinder018_02_-_Default_0"].geometry,
            material: nt["02_-_Default_0"],
          }),
          React.createElement("mesh", {
            geometry: et["Cylinder018_Material_#26_0"].geometry,
            material: nt.Material_26,
          })
        ),
        React.createElement(
          "group",
          {
            position: [-213.999, -148.217, -26.102],
            rotation: [-Math.PI / 2, 0, 0],
            scale: [0.365, 0.365, 0.621],
          },
          React.createElement("mesh", {
            geometry: et["Cylinder020_10_-_Default_0"].geometry,
            material: nt["10_-_Default"],
          }),
          React.createElement("mesh", {
            geometry: et["Cylinder020_11_-_Default_0"].geometry,
            material: nt["11_-_Default"],
          })
        ),
        React.createElement("mesh", {
          geometry: et["Box009_Material_#195_0"].geometry,
          material: nt.Material_195,
          position: [197.282, -151.061, -4.408],
          rotation: [-Math.PI / 2, 0, 0],
          scale: [1, 1.191, 1],
        }),
        React.createElement("mesh", {
          geometry: et["Box010_Material_#195_0"].geometry,
          material: nt.Material_195,
          position: [-185.543, -151.061, -4.408],
          rotation: [-Math.PI / 2, 0, 0],
          scale: [1, 1.191, 1],
        }),
        React.createElement("mesh", {
          geometry: et["Box012_05_-_Default_0"].geometry,
          material: nt["05_-_Default"],
          position: [-218.607, -47.433, 11.084],
          rotation: [-Math.PI / 2, Math.PI / 2, 0],
          scale: [0.517, 1, 1],
        }),
        React.createElement("mesh", {
          geometry: et["Box013_04_-_Default_0"].geometry,
          material: nt["04_-_Default"],
          position: [-194.114, -47.433, 18.7],
          rotation: [-Math.PI / 2, Math.PI / 2, 0],
          scale: [0.517, 1, 1],
        }),
        React.createElement("mesh", {
          geometry: et["Box014_05_-_Default_0"].geometry,
          material: nt["05_-_Default"],
          position: [-162.355, -49.417, 9.475],
          rotation: [Math.PI / 2, 1.396, -Math.PI],
          scale: [0.44, 1, 0.596],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder011_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [146.179, 0, 3.45],
          rotation: [-Math.PI / 2, 0, 1.134],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder014_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [141.583, 1.43, 35.627],
          rotation: [-Math.PI / 2, 0, 1.134],
          scale: [0.57, 0.57, 1.222],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder015_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [132.381, 1.43, 31.335],
          rotation: [-Math.PI / 2, 0, 1.134],
          scale: [0.57, 0.57, 1.222],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder017_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [-149.847, 0, 8.278],
          rotation: [-Math.PI / 2, 0, 2.007],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder019_Material_#263_0"].geometry,
          material: nt.Material_263,
          position: [-213.633, -145.673, -25.923],
          rotation: [-Math.PI / 2, 0, 0],
        }),
        React.createElement("mesh", {
          geometry: et["Cylinder021_24_-_Default_0"].geometry,
          material: nt["24_-_Default"],
          position: [-108.158, -150.898, -32.593],
          rotation: [-Math.PI / 2, 0, 0],
        }),
        React.createElement("mesh", {
          geometry: et["GeoSphere004_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [131.503, 33.12, 45.508],
          rotation: [-Math.PI / 2, 0, 1.134],
          scale: 0.92,
        }),
        React.createElement("mesh", {
          geometry: et["GeoSphere005_02_-_Default_0"].geometry,
          material: nt["02_-_Default_0"],
          position: [-127.062, 33.12, 46.555],
          rotation: [-Math.PI / 2, 0, 2.007],
          scale: 0.92,
        }),
        React.createElement("mesh", {
          geometry: et["Plane001_Material_#413_0"].geometry,
          material: nt.Material_413,
          position: [6.27, -151.247, 154.387],
          rotation: [-Math.PI / 2, 0, 0],
          scale: [0.721, 0.807, 0.721],
        })
      )
    ),
    React.createElement(
      "group",
      {
        position: [0, 1.024, 0],
        rotation: [-Math.PI / 2, 0, 3.101],
        scale: 0.005,
      },
      React.createElement(
        "group",
        { rotation: [Math.PI / 2, 0, 0] },
        React.createElement(
          "group",
          {
            position: [2.684, -0.125, 67.889],
            rotation: [-Math.PI / 2, 0, -Math.PI],
            scale: 100,
          },
          React.createElement("mesh", {
            geometry: et.Base_Base_0.geometry,
            material: nt.Base,
            position: [0.58, -0.19, -0.148],
            rotation: [0, 0, 0.006],
          })
        ),
        React.createElement(
          "group",
          {
            position: [2.684, 83.159, 64.775],
            rotation: [-1.484, 0, -Math.PI],
            scale: 100,
          },
          React.createElement("mesh", {
            geometry: et.Display_iMac_0.geometry,
            material: nt.iMac,
            position: [0.58, -0.176, -0.164],
            rotation: [0, -0.001, 0.006],
          })
        ),
        React.createElement(
          "group",
          {
            position: [22.163, 1.566, -0.477],
            rotation: [-1.58, 0, 3.139],
            scale: 100,
          },
          React.createElement("mesh", {
            geometry: et.Keyboard_Keyboard_0.geometry,
            material: nt.Keyboard,
            position: [0.737, -0.053, -0.098],
          })
        )
      )
    )
  );
}
useGLTF.preload("images/Office.glb");
const UserOneScene = ({ cpuPos: tt }) =>
  React.createElement(
    "group",
    null,
    React.createElement(Office, { cpuPos: tt })
  );
useGLTF.preload("images/user2.glb");
function useTheme() {
  const tt = useTheme$1(defaultTheme$1);
  return tt[THEME_ID] || tt;
}
const getOverlayAlpha = (tt) => {
    let et;
    return (
      tt < 1 ? (et = 5.11916 * tt ** 2) : (et = 4.5 * Math.log(tt + 1) + 2),
      (et / 100).toFixed(2)
    );
  },
  getOverlayAlpha$1 = getOverlayAlpha;
function _setPrototypeOf(tt, et) {
  return (
    (_setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (rt, it) {
          return (rt.__proto__ = it), rt;
        }),
    _setPrototypeOf(tt, et)
  );
}
function _inheritsLoose(tt, et) {
  (tt.prototype = Object.create(et.prototype)),
    (tt.prototype.constructor = tt),
    _setPrototypeOf(tt, et);
}
const config = { disabled: !1 },
  TransitionGroupContext = React.createContext(null);
var forceReflow = function (et) {
    return et.scrollTop;
  },
  UNMOUNTED = "unmounted",
  EXITED = "exited",
  ENTERING = "entering",
  ENTERED = "entered",
  EXITING = "exiting",
  Transition = (function (tt) {
    _inheritsLoose(et, tt);
    function et(rt, it) {
      var st;
      st = tt.call(this, rt, it) || this;
      var ot = it,
        at = ot && !ot.isMounting ? rt.enter : rt.appear,
        lt;
      return (
        (st.appearStatus = null),
        rt.in
          ? at
            ? ((lt = EXITED), (st.appearStatus = ENTERING))
            : (lt = ENTERED)
          : rt.unmountOnExit || rt.mountOnEnter
          ? (lt = UNMOUNTED)
          : (lt = EXITED),
        (st.state = { status: lt }),
        (st.nextCallback = null),
        st
      );
    }
    et.getDerivedStateFromProps = function (it, st) {
      var ot = it.in;
      return ot && st.status === UNMOUNTED ? { status: EXITED } : null;
    };
    var nt = et.prototype;
    return (
      (nt.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (nt.componentDidUpdate = function (it) {
        var st = null;
        if (it !== this.props) {
          var ot = this.state.status;
          this.props.in
            ? ot !== ENTERING && ot !== ENTERED && (st = ENTERING)
            : (ot === ENTERING || ot === ENTERED) && (st = EXITING);
        }
        this.updateStatus(!1, st);
      }),
      (nt.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (nt.getTimeouts = function () {
        var it = this.props.timeout,
          st,
          ot,
          at;
        return (
          (st = ot = at = it),
          it != null &&
            typeof it != "number" &&
            ((st = it.exit),
            (ot = it.enter),
            (at = it.appear !== void 0 ? it.appear : ot)),
          { exit: st, enter: ot, appear: at }
        );
      }),
      (nt.updateStatus = function (it, st) {
        if ((it === void 0 && (it = !1), st !== null))
          if ((this.cancelNextCallback(), st === ENTERING)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var ot = this.props.nodeRef
                ? this.props.nodeRef.current
                : ReactDOM.findDOMNode(this);
              ot && forceReflow(ot);
            }
            this.performEnter(it);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === EXITED &&
            this.setState({ status: UNMOUNTED });
      }),
      (nt.performEnter = function (it) {
        var st = this,
          ot = this.props.enter,
          at = this.context ? this.context.isMounting : it,
          lt = this.props.nodeRef ? [at] : [ReactDOM.findDOMNode(this), at],
          ct = lt[0],
          ut = lt[1],
          ft = this.getTimeouts(),
          ht = at ? ft.appear : ft.enter;
        if ((!it && !ot) || config.disabled) {
          this.safeSetState({ status: ENTERED }, function () {
            st.props.onEntered(ct);
          });
          return;
        }
        this.props.onEnter(ct, ut),
          this.safeSetState({ status: ENTERING }, function () {
            st.props.onEntering(ct, ut),
              st.onTransitionEnd(ht, function () {
                st.safeSetState({ status: ENTERED }, function () {
                  st.props.onEntered(ct, ut);
                });
              });
          });
      }),
      (nt.performExit = function () {
        var it = this,
          st = this.props.exit,
          ot = this.getTimeouts(),
          at = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!st || config.disabled) {
          this.safeSetState({ status: EXITED }, function () {
            it.props.onExited(at);
          });
          return;
        }
        this.props.onExit(at),
          this.safeSetState({ status: EXITING }, function () {
            it.props.onExiting(at),
              it.onTransitionEnd(ot.exit, function () {
                it.safeSetState({ status: EXITED }, function () {
                  it.props.onExited(at);
                });
              });
          });
      }),
      (nt.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (nt.safeSetState = function (it, st) {
        (st = this.setNextCallback(st)), this.setState(it, st);
      }),
      (nt.setNextCallback = function (it) {
        var st = this,
          ot = !0;
        return (
          (this.nextCallback = function (at) {
            ot && ((ot = !1), (st.nextCallback = null), it(at));
          }),
          (this.nextCallback.cancel = function () {
            ot = !1;
          }),
          this.nextCallback
        );
      }),
      (nt.onTransitionEnd = function (it, st) {
        this.setNextCallback(st);
        var ot = this.props.nodeRef
            ? this.props.nodeRef.current
            : ReactDOM.findDOMNode(this),
          at = it == null && !this.props.addEndListener;
        if (!ot || at) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var lt = this.props.nodeRef
              ? [this.nextCallback]
              : [ot, this.nextCallback],
            ct = lt[0],
            ut = lt[1];
          this.props.addEndListener(ct, ut);
        }
        it != null && setTimeout(this.nextCallback, it);
      }),
      (nt.render = function () {
        var it = this.state.status;
        if (it === UNMOUNTED) return null;
        var st = this.props,
          ot = st.children;
        st.in,
          st.mountOnEnter,
          st.unmountOnExit,
          st.appear,
          st.enter,
          st.exit,
          st.timeout,
          st.addEndListener,
          st.onEnter,
          st.onEntering,
          st.onEntered,
          st.onExit,
          st.onExiting,
          st.onExited,
          st.nodeRef;
        var at = _objectWithoutPropertiesLoose(st, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return React.createElement(
          TransitionGroupContext.Provider,
          { value: null },
          typeof ot == "function"
            ? ot(it, at)
            : React.cloneElement(React.Children.only(ot), at)
        );
      }),
      et
    );
  })(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop,
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized(tt) {
  if (tt === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return tt;
}
function getChildMapping(tt, et) {
  var nt = function (st) {
      return et && reactExports.isValidElement(st) ? et(st) : st;
    },
    rt = Object.create(null);
  return (
    tt &&
      reactExports.Children.map(tt, function (it) {
        return it;
      }).forEach(function (it) {
        rt[it.key] = nt(it);
      }),
    rt
  );
}
function mergeChildMappings(tt, et) {
  (tt = tt || {}), (et = et || {});
  function nt(ut) {
    return ut in et ? et[ut] : tt[ut];
  }
  var rt = Object.create(null),
    it = [];
  for (var st in tt)
    st in et ? it.length && ((rt[st] = it), (it = [])) : it.push(st);
  var ot,
    at = {};
  for (var lt in et) {
    if (rt[lt])
      for (ot = 0; ot < rt[lt].length; ot++) {
        var ct = rt[lt][ot];
        at[rt[lt][ot]] = nt(ct);
      }
    at[lt] = nt(lt);
  }
  for (ot = 0; ot < it.length; ot++) at[it[ot]] = nt(it[ot]);
  return at;
}
function getProp(tt, et, nt) {
  return nt[et] != null ? nt[et] : tt.props[et];
}
function getInitialChildMapping(tt, et) {
  return getChildMapping(tt.children, function (nt) {
    return reactExports.cloneElement(nt, {
      onExited: et.bind(null, nt),
      in: !0,
      appear: getProp(nt, "appear", tt),
      enter: getProp(nt, "enter", tt),
      exit: getProp(nt, "exit", tt),
    });
  });
}
function getNextChildMapping(tt, et, nt) {
  var rt = getChildMapping(tt.children),
    it = mergeChildMappings(et, rt);
  return (
    Object.keys(it).forEach(function (st) {
      var ot = it[st];
      if (reactExports.isValidElement(ot)) {
        var at = st in et,
          lt = st in rt,
          ct = et[st],
          ut = reactExports.isValidElement(ct) && !ct.props.in;
        lt && (!at || ut)
          ? (it[st] = reactExports.cloneElement(ot, {
              onExited: nt.bind(null, ot),
              in: !0,
              exit: getProp(ot, "exit", tt),
              enter: getProp(ot, "enter", tt),
            }))
          : !lt && at && !ut
          ? (it[st] = reactExports.cloneElement(ot, { in: !1 }))
          : lt &&
            at &&
            reactExports.isValidElement(ct) &&
            (it[st] = reactExports.cloneElement(ot, {
              onExited: nt.bind(null, ot),
              in: ct.props.in,
              exit: getProp(ot, "exit", tt),
              enter: getProp(ot, "enter", tt),
            }));
      }
    }),
    it
  );
}
var values =
    Object.values ||
    function (tt) {
      return Object.keys(tt).map(function (et) {
        return tt[et];
      });
    },
  defaultProps = {
    component: "div",
    childFactory: function (et) {
      return et;
    },
  },
  TransitionGroup = (function (tt) {
    _inheritsLoose(et, tt);
    function et(rt, it) {
      var st;
      st = tt.call(this, rt, it) || this;
      var ot = st.handleExited.bind(_assertThisInitialized(st));
      return (
        (st.state = {
          contextValue: { isMounting: !0 },
          handleExited: ot,
          firstRender: !0,
        }),
        st
      );
    }
    var nt = et.prototype;
    return (
      (nt.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (nt.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (et.getDerivedStateFromProps = function (it, st) {
        var ot = st.children,
          at = st.handleExited,
          lt = st.firstRender;
        return {
          children: lt
            ? getInitialChildMapping(it, at)
            : getNextChildMapping(it, ot, at),
          firstRender: !1,
        };
      }),
      (nt.handleExited = function (it, st) {
        var ot = getChildMapping(this.props.children);
        it.key in ot ||
          (it.props.onExited && it.props.onExited(st),
          this.mounted &&
            this.setState(function (at) {
              var lt = _extends({}, at.children);
              return delete lt[it.key], { children: lt };
            }));
      }),
      (nt.render = function () {
        var it = this.props,
          st = it.component,
          ot = it.childFactory,
          at = _objectWithoutPropertiesLoose(it, ["component", "childFactory"]),
          lt = this.state.contextValue,
          ct = values(this.state.children).map(ot);
        return (
          delete at.appear,
          delete at.enter,
          delete at.exit,
          st === null
            ? React.createElement(
                TransitionGroupContext.Provider,
                { value: lt },
                ct
              )
            : React.createElement(
                TransitionGroupContext.Provider,
                { value: lt },
                React.createElement(st, at, ct)
              )
        );
      }),
      et
    );
  })(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup,
  reflow = (tt) => tt.scrollTop;
function getTransitionProps(tt, et) {
  var nt, rt;
  const { timeout: it, easing: st, style: ot = {} } = tt;
  return {
    duration:
      (nt = ot.transitionDuration) != null
        ? nt
        : typeof it == "number"
        ? it
        : it[et.mode] || 0,
    easing:
      (rt = ot.transitionTimingFunction) != null
        ? rt
        : typeof st == "object"
        ? st[et.mode]
        : st,
    delay: ot.transitionDelay,
  };
}
function getPaperUtilityClass(tt) {
  return generateUtilityClass("MuiPaper", tt);
}
generateUtilityClasses("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const _excluded$i = [
    "className",
    "component",
    "elevation",
    "square",
    "variant",
  ],
  useUtilityClasses$e = (tt) => {
    const { square: et, elevation: nt, variant: rt, classes: it } = tt,
      st = {
        root: [
          "root",
          rt,
          !et && "rounded",
          rt === "elevation" && `elevation${nt}`,
        ],
      };
    return composeClasses(st, getPaperUtilityClass, it);
  },
  PaperRoot = styled$2("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        et[nt.variant],
        !nt.square && et.rounded,
        nt.variant === "elevation" && et[`elevation${nt.elevation}`],
      ];
    },
  })(({ theme: tt, ownerState: et }) => {
    var nt;
    return _extends(
      {
        backgroundColor: (tt.vars || tt).palette.background.paper,
        color: (tt.vars || tt).palette.text.primary,
        transition: tt.transitions.create("box-shadow"),
      },
      !et.square && { borderRadius: tt.shape.borderRadius },
      et.variant === "outlined" && {
        border: `1px solid ${(tt.vars || tt).palette.divider}`,
      },
      et.variant === "elevation" &&
        _extends(
          { boxShadow: (tt.vars || tt).shadows[et.elevation] },
          !tt.vars &&
            tt.palette.mode === "dark" && {
              backgroundImage: `linear-gradient(${alpha(
                "#fff",
                getOverlayAlpha$1(et.elevation)
              )}, ${alpha("#fff", getOverlayAlpha$1(et.elevation))})`,
            },
          tt.vars && {
            backgroundImage:
              (nt = tt.vars.overlays) == null ? void 0 : nt[et.elevation],
          }
        )
    );
  }),
  Paper = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiPaper" }),
      {
        className: it,
        component: st = "div",
        elevation: ot = 1,
        square: at = !1,
        variant: lt = "elevation",
      } = rt,
      ct = _objectWithoutPropertiesLoose(rt, _excluded$i),
      ut = _extends({}, rt, {
        component: st,
        elevation: ot,
        square: at,
        variant: lt,
      }),
      ft = useUtilityClasses$e(ut);
    return jsxRuntimeExports.jsx(
      PaperRoot,
      _extends(
        { as: st, ownerState: ut, className: clsx(ft.root, it), ref: nt },
        ct
      )
    );
  }),
  Paper$1 = Paper;
function Ripple(tt) {
  const {
      className: et,
      classes: nt,
      pulsate: rt = !1,
      rippleX: it,
      rippleY: st,
      rippleSize: ot,
      in: at,
      onExited: lt,
      timeout: ct,
    } = tt,
    [ut, ft] = reactExports.useState(!1),
    ht = clsx(et, nt.ripple, nt.rippleVisible, rt && nt.ripplePulsate),
    mt = { width: ot, height: ot, top: -(ot / 2) + st, left: -(ot / 2) + it },
    vt = clsx(nt.child, ut && nt.childLeaving, rt && nt.childPulsate);
  return (
    !at && !ut && ft(!0),
    reactExports.useEffect(() => {
      if (!at && lt != null) {
        const yt = setTimeout(lt, ct);
        return () => {
          clearTimeout(yt);
        };
      }
    }, [lt, at, ct]),
    jsxRuntimeExports.jsx("span", {
      className: ht,
      style: mt,
      children: jsxRuntimeExports.jsx("span", { className: vt }),
    })
  );
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", [
    "root",
    "ripple",
    "rippleVisible",
    "ripplePulsate",
    "child",
    "childLeaving",
    "childPulsate",
  ]),
  touchRippleClasses$1 = touchRippleClasses,
  _excluded$h = ["center", "classes", "className"];
let _$1 = (tt) => tt,
  _t,
  _t2,
  _t3,
  _t4;
const DURATION = 550,
  DELAY_RIPPLE = 80,
  enterKeyframe = keyframes(
    _t ||
      (_t = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  exitKeyframe = keyframes(
    _t2 ||
      (_t2 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  pulsateKeyframe = keyframes(
    _t3 ||
      (_t3 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  TouchRippleRoot = styled$2("span", { name: "MuiTouchRipple", slot: "Root" })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
  }),
  TouchRippleRipple = styled$2(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple",
  })(
    _t4 ||
      (_t4 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    touchRippleClasses$1.rippleVisible,
    enterKeyframe,
    DURATION,
    ({ theme: tt }) => tt.transitions.easing.easeInOut,
    touchRippleClasses$1.ripplePulsate,
    ({ theme: tt }) => tt.transitions.duration.shorter,
    touchRippleClasses$1.child,
    touchRippleClasses$1.childLeaving,
    exitKeyframe,
    DURATION,
    ({ theme: tt }) => tt.transitions.easing.easeInOut,
    touchRippleClasses$1.childPulsate,
    pulsateKeyframe,
    ({ theme: tt }) => tt.transitions.easing.easeInOut
  ),
  TouchRipple = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiTouchRipple" }),
      { center: it = !1, classes: st = {}, className: ot } = rt,
      at = _objectWithoutPropertiesLoose(rt, _excluded$h),
      [lt, ct] = reactExports.useState([]),
      ut = reactExports.useRef(0),
      ft = reactExports.useRef(null);
    reactExports.useEffect(() => {
      ft.current && (ft.current(), (ft.current = null));
    }, [lt]);
    const ht = reactExports.useRef(!1),
      mt = reactExports.useRef(0),
      vt = reactExports.useRef(null),
      yt = reactExports.useRef(null);
    reactExports.useEffect(
      () => () => {
        mt.current && clearTimeout(mt.current);
      },
      []
    );
    const Et = reactExports.useCallback(
        (At) => {
          const {
            pulsate: Ct,
            rippleX: Mt,
            rippleY: wt,
            rippleSize: Bt,
            cb: It,
          } = At;
          ct((Ft) => [
            ...Ft,
            jsxRuntimeExports.jsx(
              TouchRippleRipple,
              {
                classes: {
                  ripple: clsx(st.ripple, touchRippleClasses$1.ripple),
                  rippleVisible: clsx(
                    st.rippleVisible,
                    touchRippleClasses$1.rippleVisible
                  ),
                  ripplePulsate: clsx(
                    st.ripplePulsate,
                    touchRippleClasses$1.ripplePulsate
                  ),
                  child: clsx(st.child, touchRippleClasses$1.child),
                  childLeaving: clsx(
                    st.childLeaving,
                    touchRippleClasses$1.childLeaving
                  ),
                  childPulsate: clsx(
                    st.childPulsate,
                    touchRippleClasses$1.childPulsate
                  ),
                },
                timeout: DURATION,
                pulsate: Ct,
                rippleX: Mt,
                rippleY: wt,
                rippleSize: Bt,
              },
              ut.current
            ),
          ]),
            (ut.current += 1),
            (ft.current = It);
        },
        [st]
      ),
      pt = reactExports.useCallback(
        (At = {}, Ct = {}, Mt = () => {}) => {
          const {
            pulsate: wt = !1,
            center: Bt = it || Ct.pulsate,
            fakeElement: It = !1,
          } = Ct;
          if ((At == null ? void 0 : At.type) === "mousedown" && ht.current) {
            ht.current = !1;
            return;
          }
          (At == null ? void 0 : At.type) === "touchstart" && (ht.current = !0);
          const Ft = It ? null : yt.current,
            Vt = Ft
              ? Ft.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 };
          let $t, Kt, Ht;
          if (
            Bt ||
            At === void 0 ||
            (At.clientX === 0 && At.clientY === 0) ||
            (!At.clientX && !At.touches)
          )
            ($t = Math.round(Vt.width / 2)), (Kt = Math.round(Vt.height / 2));
          else {
            const { clientX: Wt, clientY: kt } =
              At.touches && At.touches.length > 0 ? At.touches[0] : At;
            ($t = Math.round(Wt - Vt.left)), (Kt = Math.round(kt - Vt.top));
          }
          if (Bt)
            (Ht = Math.sqrt((2 * Vt.width ** 2 + Vt.height ** 2) / 3)),
              Ht % 2 === 0 && (Ht += 1);
          else {
            const Wt =
                Math.max(Math.abs((Ft ? Ft.clientWidth : 0) - $t), $t) * 2 + 2,
              kt =
                Math.max(Math.abs((Ft ? Ft.clientHeight : 0) - Kt), Kt) * 2 + 2;
            Ht = Math.sqrt(Wt ** 2 + kt ** 2);
          }
          At != null && At.touches
            ? vt.current === null &&
              ((vt.current = () => {
                Et({
                  pulsate: wt,
                  rippleX: $t,
                  rippleY: Kt,
                  rippleSize: Ht,
                  cb: Mt,
                });
              }),
              (mt.current = setTimeout(() => {
                vt.current && (vt.current(), (vt.current = null));
              }, DELAY_RIPPLE)))
            : Et({
                pulsate: wt,
                rippleX: $t,
                rippleY: Kt,
                rippleSize: Ht,
                cb: Mt,
              });
        },
        [it, Et]
      ),
      xt = reactExports.useCallback(() => {
        pt({}, { pulsate: !0 });
      }, [pt]),
      St = reactExports.useCallback((At, Ct) => {
        if (
          (clearTimeout(mt.current),
          (At == null ? void 0 : At.type) === "touchend" && vt.current)
        ) {
          vt.current(),
            (vt.current = null),
            (mt.current = setTimeout(() => {
              St(At, Ct);
            }));
          return;
        }
        (vt.current = null),
          ct((Mt) => (Mt.length > 0 ? Mt.slice(1) : Mt)),
          (ft.current = Ct);
      }, []);
    return (
      reactExports.useImperativeHandle(
        nt,
        () => ({ pulsate: xt, start: pt, stop: St }),
        [xt, pt, St]
      ),
      jsxRuntimeExports.jsx(
        TouchRippleRoot,
        _extends(
          { className: clsx(touchRippleClasses$1.root, st.root, ot), ref: yt },
          at,
          {
            children: jsxRuntimeExports.jsx(TransitionGroup$1, {
              component: null,
              exit: !0,
              children: lt,
            }),
          }
        )
      )
    );
  }),
  TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(tt) {
  return generateUtilityClass("MuiButtonBase", tt);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", [
    "root",
    "disabled",
    "focusVisible",
  ]),
  buttonBaseClasses$1 = buttonBaseClasses,
  _excluded$g = [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type",
  ],
  useUtilityClasses$d = (tt) => {
    const {
        disabled: et,
        focusVisible: nt,
        focusVisibleClassName: rt,
        classes: it,
      } = tt,
      ot = composeClasses(
        { root: ["root", et && "disabled", nt && "focusVisible"] },
        getButtonBaseUtilityClass,
        it
      );
    return nt && rt && (ot.root += ` ${rt}`), ot;
  },
  ButtonBaseRoot = styled$2("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (tt, et) => et.root,
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": { borderStyle: "none" },
    [`&.${buttonBaseClasses$1.disabled}`]: {
      pointerEvents: "none",
      cursor: "default",
    },
    "@media print": { colorAdjust: "exact" },
  }),
  ButtonBase = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiButtonBase" }),
      {
        action: it,
        centerRipple: st = !1,
        children: ot,
        className: at,
        component: lt = "button",
        disabled: ct = !1,
        disableRipple: ut = !1,
        disableTouchRipple: ft = !1,
        focusRipple: ht = !1,
        LinkComponent: mt = "a",
        onBlur: vt,
        onClick: yt,
        onContextMenu: Et,
        onDragLeave: pt,
        onFocus: xt,
        onFocusVisible: St,
        onKeyDown: At,
        onKeyUp: Ct,
        onMouseDown: Mt,
        onMouseLeave: wt,
        onMouseUp: Bt,
        onTouchEnd: It,
        onTouchMove: Ft,
        onTouchStart: Vt,
        tabIndex: $t = 0,
        TouchRippleProps: Kt,
        touchRippleRef: Ht,
        type: Wt,
      } = rt,
      kt = _objectWithoutPropertiesLoose(rt, _excluded$g),
      Gt = reactExports.useRef(null),
      Pt = reactExports.useRef(null),
      Rt = useForkRef(Pt, Ht),
      {
        isFocusVisibleRef: Nt,
        onFocus: Dt,
        onBlur: zt,
        ref: Yt,
      } = useIsFocusVisible(),
      [qt, Zt] = reactExports.useState(!1);
    ct && qt && Zt(!1),
      reactExports.useImperativeHandle(
        it,
        () => ({
          focusVisible: () => {
            Zt(!0), Gt.current.focus();
          },
        }),
        []
      );
    const [Jt, mn] = reactExports.useState(!1);
    reactExports.useEffect(() => {
      mn(!0);
    }, []);
    const ln = Jt && !ut && !ct;
    reactExports.useEffect(() => {
      qt && ht && !ut && Jt && Pt.current.pulsate();
    }, [ut, ht, qt, Jt]);
    function bn(kn, Vn, Kn = ft) {
      return useEventCallback(
        (Yn) => (Vn && Vn(Yn), !Kn && Pt.current && Pt.current[kn](Yn), !0)
      );
    }
    const Bn = bn("start", Mt),
      gn = bn("stop", Et),
      jt = bn("stop", pt),
      yn = bn("stop", Bt),
      pn = bn("stop", (kn) => {
        qt && kn.preventDefault(), wt && wt(kn);
      }),
      vn = bn("start", Vt),
      xn = bn("stop", It),
      Fn = bn("stop", Ft),
      _n = bn(
        "stop",
        (kn) => {
          zt(kn), Nt.current === !1 && Zt(!1), vt && vt(kn);
        },
        !1
      ),
      Dn = useEventCallback((kn) => {
        Gt.current || (Gt.current = kn.currentTarget),
          Dt(kn),
          Nt.current === !0 && (Zt(!0), St && St(kn)),
          xt && xt(kn);
      }),
      Tn = () => {
        const kn = Gt.current;
        return lt && lt !== "button" && !(kn.tagName === "A" && kn.href);
      },
      An = reactExports.useRef(!1),
      Wn = useEventCallback((kn) => {
        ht &&
          !An.current &&
          qt &&
          Pt.current &&
          kn.key === " " &&
          ((An.current = !0),
          Pt.current.stop(kn, () => {
            Pt.current.start(kn);
          })),
          kn.target === kn.currentTarget &&
            Tn() &&
            kn.key === " " &&
            kn.preventDefault(),
          At && At(kn),
          kn.target === kn.currentTarget &&
            Tn() &&
            kn.key === "Enter" &&
            !ct &&
            (kn.preventDefault(), yt && yt(kn));
      }),
      Xt = useEventCallback((kn) => {
        ht &&
          kn.key === " " &&
          Pt.current &&
          qt &&
          !kn.defaultPrevented &&
          ((An.current = !1),
          Pt.current.stop(kn, () => {
            Pt.current.pulsate(kn);
          })),
          Ct && Ct(kn),
          yt &&
            kn.target === kn.currentTarget &&
            Tn() &&
            kn.key === " " &&
            !kn.defaultPrevented &&
            yt(kn);
      });
    let Ut = lt;
    Ut === "button" && (kt.href || kt.to) && (Ut = mt);
    const hn = {};
    Ut === "button"
      ? ((hn.type = Wt === void 0 ? "button" : Wt), (hn.disabled = ct))
      : (!kt.href && !kt.to && (hn.role = "button"),
        ct && (hn["aria-disabled"] = ct));
    const Ln = useForkRef(nt, Yt, Gt),
      Cn = _extends({}, rt, {
        centerRipple: st,
        component: lt,
        disabled: ct,
        disableRipple: ut,
        disableTouchRipple: ft,
        focusRipple: ht,
        tabIndex: $t,
        focusVisible: qt,
      }),
      Mn = useUtilityClasses$d(Cn);
    return jsxRuntimeExports.jsxs(
      ButtonBaseRoot,
      _extends(
        {
          as: Ut,
          className: clsx(Mn.root, at),
          ownerState: Cn,
          onBlur: _n,
          onClick: yt,
          onContextMenu: gn,
          onFocus: Dn,
          onKeyDown: Wn,
          onKeyUp: Xt,
          onMouseDown: Bn,
          onMouseLeave: pn,
          onMouseUp: yn,
          onDragLeave: jt,
          onTouchEnd: xn,
          onTouchMove: Fn,
          onTouchStart: vn,
          ref: Ln,
          tabIndex: ct ? -1 : $t,
          type: Wt,
        },
        hn,
        kt,
        {
          children: [
            ot,
            ln
              ? jsxRuntimeExports.jsx(
                  TouchRipple$1,
                  _extends({ ref: Rt, center: st }, Kt)
                )
              : null,
          ],
        }
      )
    );
  }),
  ButtonBase$1 = ButtonBase;
function getAlertUtilityClass(tt) {
  return generateUtilityClass("MuiAlert", tt);
}
const alertClasses = generateUtilityClasses("MuiAlert", [
    "root",
    "action",
    "icon",
    "message",
    "filled",
    "filledSuccess",
    "filledInfo",
    "filledWarning",
    "filledError",
    "outlined",
    "outlinedSuccess",
    "outlinedInfo",
    "outlinedWarning",
    "outlinedError",
    "standard",
    "standardSuccess",
    "standardInfo",
    "standardWarning",
    "standardError",
  ]),
  alertClasses$1 = alertClasses;
function getIconButtonUtilityClass(tt) {
  return generateUtilityClass("MuiIconButton", tt);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", [
    "root",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorError",
    "colorInfo",
    "colorSuccess",
    "colorWarning",
    "edgeStart",
    "edgeEnd",
    "sizeSmall",
    "sizeMedium",
    "sizeLarge",
  ]),
  iconButtonClasses$1 = iconButtonClasses,
  _excluded$f = [
    "edge",
    "children",
    "className",
    "color",
    "disabled",
    "disableFocusRipple",
    "size",
  ],
  useUtilityClasses$c = (tt) => {
    const { classes: et, disabled: nt, color: rt, edge: it, size: st } = tt,
      ot = {
        root: [
          "root",
          nt && "disabled",
          rt !== "default" && `color${capitalize(rt)}`,
          it && `edge${capitalize(it)}`,
          `size${capitalize(st)}`,
        ],
      };
    return composeClasses(ot, getIconButtonUtilityClass, et);
  },
  IconButtonRoot = styled$2(ButtonBase$1, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        nt.color !== "default" && et[`color${capitalize(nt.color)}`],
        nt.edge && et[`edge${capitalize(nt.edge)}`],
        et[`size${capitalize(nt.size)}`],
      ];
    },
  })(
    ({ theme: tt, ownerState: et }) =>
      _extends(
        {
          textAlign: "center",
          flex: "0 0 auto",
          fontSize: tt.typography.pxToRem(24),
          padding: 8,
          borderRadius: "50%",
          overflow: "visible",
          color: (tt.vars || tt).palette.action.active,
          transition: tt.transitions.create("background-color", {
            duration: tt.transitions.duration.shortest,
          }),
        },
        !et.disableRipple && {
          "&:hover": {
            backgroundColor: tt.vars
              ? `rgba(${tt.vars.palette.action.activeChannel} / ${tt.vars.palette.action.hoverOpacity})`
              : alpha(tt.palette.action.active, tt.palette.action.hoverOpacity),
            "@media (hover: none)": { backgroundColor: "transparent" },
          },
        },
        et.edge === "start" && { marginLeft: et.size === "small" ? -3 : -12 },
        et.edge === "end" && { marginRight: et.size === "small" ? -3 : -12 }
      ),
    ({ theme: tt, ownerState: et }) => {
      var nt;
      const rt = (nt = (tt.vars || tt).palette) == null ? void 0 : nt[et.color];
      return _extends(
        {},
        et.color === "inherit" && { color: "inherit" },
        et.color !== "inherit" &&
          et.color !== "default" &&
          _extends(
            { color: rt == null ? void 0 : rt.main },
            !et.disableRipple && {
              "&:hover": _extends(
                {},
                rt && {
                  backgroundColor: tt.vars
                    ? `rgba(${rt.mainChannel} / ${tt.vars.palette.action.hoverOpacity})`
                    : alpha(rt.main, tt.palette.action.hoverOpacity),
                },
                { "@media (hover: none)": { backgroundColor: "transparent" } }
              ),
            }
          ),
        et.size === "small" && {
          padding: 5,
          fontSize: tt.typography.pxToRem(18),
        },
        et.size === "large" && {
          padding: 12,
          fontSize: tt.typography.pxToRem(28),
        },
        {
          [`&.${iconButtonClasses$1.disabled}`]: {
            backgroundColor: "transparent",
            color: (tt.vars || tt).palette.action.disabled,
          },
        }
      );
    }
  ),
  IconButton = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiIconButton" }),
      {
        edge: it = !1,
        children: st,
        className: ot,
        color: at = "default",
        disabled: lt = !1,
        disableFocusRipple: ct = !1,
        size: ut = "medium",
      } = rt,
      ft = _objectWithoutPropertiesLoose(rt, _excluded$f),
      ht = _extends({}, rt, {
        edge: it,
        color: at,
        disabled: lt,
        disableFocusRipple: ct,
        size: ut,
      }),
      mt = useUtilityClasses$c(ht);
    return jsxRuntimeExports.jsx(
      IconButtonRoot,
      _extends(
        {
          className: clsx(mt.root, ot),
          centerRipple: !0,
          focusRipple: !ct,
          disabled: lt,
          ref: nt,
          ownerState: ht,
        },
        ft,
        { children: st }
      )
    );
  }),
  IconButton$1 = IconButton,
  SuccessOutlinedIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z",
    }),
    "SuccessOutlined"
  ),
  ReportProblemOutlinedIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z",
    }),
    "ReportProblemOutlined"
  ),
  ErrorOutlineIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",
    }),
    "ErrorOutline"
  ),
  InfoOutlinedIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z",
    }),
    "InfoOutlined"
  ),
  ClearIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
    }),
    "Close"
  ),
  _excluded$e = [
    "action",
    "children",
    "className",
    "closeText",
    "color",
    "components",
    "componentsProps",
    "icon",
    "iconMapping",
    "onClose",
    "role",
    "severity",
    "slotProps",
    "slots",
    "variant",
  ],
  useUtilityClasses$b = (tt) => {
    const { variant: et, color: nt, severity: rt, classes: it } = tt,
      st = {
        root: ["root", `${et}${capitalize(nt || rt)}`, `${et}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"],
      };
    return composeClasses(st, getAlertUtilityClass, it);
  },
  AlertRoot = styled$2(Paper$1, {
    name: "MuiAlert",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        et[nt.variant],
        et[`${nt.variant}${capitalize(nt.color || nt.severity)}`],
      ];
    },
  })(({ theme: tt, ownerState: et }) => {
    const nt = tt.palette.mode === "light" ? darken : lighten,
      rt = tt.palette.mode === "light" ? lighten : darken,
      it = et.color || et.severity;
    return _extends(
      {},
      tt.typography.body2,
      { backgroundColor: "transparent", display: "flex", padding: "6px 16px" },
      it &&
        et.variant === "standard" && {
          color: tt.vars
            ? tt.vars.palette.Alert[`${it}Color`]
            : nt(tt.palette[it].light, 0.6),
          backgroundColor: tt.vars
            ? tt.vars.palette.Alert[`${it}StandardBg`]
            : rt(tt.palette[it].light, 0.9),
          [`& .${alertClasses$1.icon}`]: tt.vars
            ? { color: tt.vars.palette.Alert[`${it}IconColor`] }
            : { color: tt.palette[it].main },
        },
      it &&
        et.variant === "outlined" && {
          color: tt.vars
            ? tt.vars.palette.Alert[`${it}Color`]
            : nt(tt.palette[it].light, 0.6),
          border: `1px solid ${(tt.vars || tt).palette[it].light}`,
          [`& .${alertClasses$1.icon}`]: tt.vars
            ? { color: tt.vars.palette.Alert[`${it}IconColor`] }
            : { color: tt.palette[it].main },
        },
      it &&
        et.variant === "filled" &&
        _extends(
          { fontWeight: tt.typography.fontWeightMedium },
          tt.vars
            ? {
                color: tt.vars.palette.Alert[`${it}FilledColor`],
                backgroundColor: tt.vars.palette.Alert[`${it}FilledBg`],
              }
            : {
                backgroundColor:
                  tt.palette.mode === "dark"
                    ? tt.palette[it].dark
                    : tt.palette[it].main,
                color: tt.palette.getContrastText(tt.palette[it].main),
              }
        )
    );
  }),
  AlertIcon = styled$2("div", {
    name: "MuiAlert",
    slot: "Icon",
    overridesResolver: (tt, et) => et.icon,
  })({
    marginRight: 12,
    padding: "7px 0",
    display: "flex",
    fontSize: 22,
    opacity: 0.9,
  }),
  AlertMessage = styled$2("div", {
    name: "MuiAlert",
    slot: "Message",
    overridesResolver: (tt, et) => et.message,
  })({ padding: "8px 0", minWidth: 0, overflow: "auto" }),
  AlertAction = styled$2("div", {
    name: "MuiAlert",
    slot: "Action",
    overridesResolver: (tt, et) => et.action,
  })({
    display: "flex",
    alignItems: "flex-start",
    padding: "4px 0 0 16px",
    marginLeft: "auto",
    marginRight: -8,
  }),
  defaultIconMapping = {
    success: jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
      fontSize: "inherit",
    }),
    warning: jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
      fontSize: "inherit",
    }),
    error: jsxRuntimeExports.jsx(ErrorOutlineIcon, { fontSize: "inherit" }),
    info: jsxRuntimeExports.jsx(InfoOutlinedIcon, { fontSize: "inherit" }),
  },
  Alert = reactExports.forwardRef(function (et, nt) {
    var rt, it, st, ot, at, lt;
    const ct = useThemeProps({ props: et, name: "MuiAlert" }),
      {
        action: ut,
        children: ft,
        className: ht,
        closeText: mt = "Close",
        color: vt,
        components: yt = {},
        componentsProps: Et = {},
        icon: pt,
        iconMapping: xt = defaultIconMapping,
        onClose: St,
        role: At = "alert",
        severity: Ct = "success",
        slotProps: Mt = {},
        slots: wt = {},
        variant: Bt = "standard",
      } = ct,
      It = _objectWithoutPropertiesLoose(ct, _excluded$e),
      Ft = _extends({}, ct, { color: vt, severity: Ct, variant: Bt }),
      Vt = useUtilityClasses$b(Ft),
      $t =
        (rt = (it = wt.closeButton) != null ? it : yt.CloseButton) != null
          ? rt
          : IconButton$1,
      Kt =
        (st = (ot = wt.closeIcon) != null ? ot : yt.CloseIcon) != null
          ? st
          : ClearIcon,
      Ht = (at = Mt.closeButton) != null ? at : Et.closeButton,
      Wt = (lt = Mt.closeIcon) != null ? lt : Et.closeIcon;
    return jsxRuntimeExports.jsxs(
      AlertRoot,
      _extends(
        {
          role: At,
          elevation: 0,
          ownerState: Ft,
          className: clsx(Vt.root, ht),
          ref: nt,
        },
        It,
        {
          children: [
            pt !== !1
              ? jsxRuntimeExports.jsx(AlertIcon, {
                  ownerState: Ft,
                  className: Vt.icon,
                  children: pt || xt[Ct] || defaultIconMapping[Ct],
                })
              : null,
            jsxRuntimeExports.jsx(AlertMessage, {
              ownerState: Ft,
              className: Vt.message,
              children: ft,
            }),
            ut != null
              ? jsxRuntimeExports.jsx(AlertAction, {
                  ownerState: Ft,
                  className: Vt.action,
                  children: ut,
                })
              : null,
            ut == null && St
              ? jsxRuntimeExports.jsx(AlertAction, {
                  ownerState: Ft,
                  className: Vt.action,
                  children: jsxRuntimeExports.jsx(
                    $t,
                    _extends(
                      {
                        size: "small",
                        "aria-label": mt,
                        title: mt,
                        color: "inherit",
                        onClick: St,
                      },
                      Ht,
                      {
                        children: jsxRuntimeExports.jsx(
                          Kt,
                          _extends({ fontSize: "small" }, Wt)
                        ),
                      }
                    )
                  ),
                })
              : null,
          ],
        }
      )
    );
  }),
  Alert$1 = Alert;
function getTypographyUtilityClass(tt) {
  return generateUtilityClass("MuiTypography", tt);
}
generateUtilityClasses("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const _excluded$d = [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping",
  ],
  useUtilityClasses$a = (tt) => {
    const {
        align: et,
        gutterBottom: nt,
        noWrap: rt,
        paragraph: it,
        variant: st,
        classes: ot,
      } = tt,
      at = {
        root: [
          "root",
          st,
          tt.align !== "inherit" && `align${capitalize(et)}`,
          nt && "gutterBottom",
          rt && "noWrap",
          it && "paragraph",
        ],
      };
    return composeClasses(at, getTypographyUtilityClass, ot);
  },
  TypographyRoot = styled$2("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        nt.variant && et[nt.variant],
        nt.align !== "inherit" && et[`align${capitalize(nt.align)}`],
        nt.noWrap && et.noWrap,
        nt.gutterBottom && et.gutterBottom,
        nt.paragraph && et.paragraph,
      ];
    },
  })(({ theme: tt, ownerState: et }) =>
    _extends(
      { margin: 0 },
      et.variant === "inherit" && { font: "inherit" },
      et.variant !== "inherit" && tt.typography[et.variant],
      et.align !== "inherit" && { textAlign: et.align },
      et.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
      },
      et.gutterBottom && { marginBottom: "0.35em" },
      et.paragraph && { marginBottom: 16 }
    )
  ),
  defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  colorTransformations = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main",
  },
  transformDeprecatedColors = (tt) => colorTransformations[tt] || tt,
  Typography = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiTypography" }),
      it = transformDeprecatedColors(rt.color),
      st = extendSxProp(_extends({}, rt, { color: it })),
      {
        align: ot = "inherit",
        className: at,
        component: lt,
        gutterBottom: ct = !1,
        noWrap: ut = !1,
        paragraph: ft = !1,
        variant: ht = "body1",
        variantMapping: mt = defaultVariantMapping,
      } = st,
      vt = _objectWithoutPropertiesLoose(st, _excluded$d),
      yt = _extends({}, st, {
        align: ot,
        color: it,
        className: at,
        component: lt,
        gutterBottom: ct,
        noWrap: ut,
        paragraph: ft,
        variant: ht,
        variantMapping: mt,
      }),
      Et = lt || (ft ? "p" : mt[ht] || defaultVariantMapping[ht]) || "span",
      pt = useUtilityClasses$a(yt);
    return jsxRuntimeExports.jsx(
      TypographyRoot,
      _extends(
        { as: Et, ref: nt, ownerState: yt, className: clsx(pt.root, at) },
        vt
      )
    );
  }),
  Typography$1 = Typography;
function isHostComponent(tt) {
  return typeof tt == "string";
}
function appendOwnerState(tt, et, nt) {
  return tt === void 0 || isHostComponent(tt)
    ? et
    : _extends({}, et, { ownerState: _extends({}, et.ownerState, nt) });
}
const defaultContextValue = { disableDefaultClasses: !1 },
  ClassNameConfiguratorContext =
    reactExports.createContext(defaultContextValue);
function useClassNamesOverride(tt) {
  const { disableDefaultClasses: et } = reactExports.useContext(
    ClassNameConfiguratorContext
  );
  return (nt) => (et ? "" : tt(nt));
}
function extractEventHandlers(tt, et = []) {
  if (tt === void 0) return {};
  const nt = {};
  return (
    Object.keys(tt)
      .filter(
        (rt) =>
          rt.match(/^on[A-Z]/) &&
          typeof tt[rt] == "function" &&
          !et.includes(rt)
      )
      .forEach((rt) => {
        nt[rt] = tt[rt];
      }),
    nt
  );
}
function resolveComponentProps(tt, et, nt) {
  return typeof tt == "function" ? tt(et, nt) : tt;
}
function omitEventHandlers(tt) {
  if (tt === void 0) return {};
  const et = {};
  return (
    Object.keys(tt)
      .filter((nt) => !(nt.match(/^on[A-Z]/) && typeof tt[nt] == "function"))
      .forEach((nt) => {
        et[nt] = tt[nt];
      }),
    et
  );
}
function mergeSlotProps(tt) {
  const {
    getSlotProps: et,
    additionalProps: nt,
    externalSlotProps: rt,
    externalForwardedProps: it,
    className: st,
  } = tt;
  if (!et) {
    const mt = clsx(
        nt == null ? void 0 : nt.className,
        st,
        it == null ? void 0 : it.className,
        rt == null ? void 0 : rt.className
      ),
      vt = _extends(
        {},
        nt == null ? void 0 : nt.style,
        it == null ? void 0 : it.style,
        rt == null ? void 0 : rt.style
      ),
      yt = _extends({}, nt, it, rt);
    return (
      mt.length > 0 && (yt.className = mt),
      Object.keys(vt).length > 0 && (yt.style = vt),
      { props: yt, internalRef: void 0 }
    );
  }
  const ot = extractEventHandlers(_extends({}, it, rt)),
    at = omitEventHandlers(rt),
    lt = omitEventHandlers(it),
    ct = et(ot),
    ut = clsx(
      ct == null ? void 0 : ct.className,
      nt == null ? void 0 : nt.className,
      st,
      it == null ? void 0 : it.className,
      rt == null ? void 0 : rt.className
    ),
    ft = _extends(
      {},
      ct == null ? void 0 : ct.style,
      nt == null ? void 0 : nt.style,
      it == null ? void 0 : it.style,
      rt == null ? void 0 : rt.style
    ),
    ht = _extends({}, ct, nt, lt, at);
  return (
    ut.length > 0 && (ht.className = ut),
    Object.keys(ft).length > 0 && (ht.style = ft),
    { props: ht, internalRef: ct.ref }
  );
}
const _excluded$c = [
  "elementType",
  "externalSlotProps",
  "ownerState",
  "skipResolvingSlotProps",
];
function useSlotProps(tt) {
  var et;
  const {
      elementType: nt,
      externalSlotProps: rt,
      ownerState: it,
      skipResolvingSlotProps: st = !1,
    } = tt,
    ot = _objectWithoutPropertiesLoose(tt, _excluded$c),
    at = st ? {} : resolveComponentProps(rt, it),
    { props: lt, internalRef: ct } = mergeSlotProps(
      _extends({}, ot, { externalSlotProps: at })
    ),
    ut = useForkRef(
      ct,
      at == null ? void 0 : at.ref,
      (et = tt.additionalProps) == null ? void 0 : et.ref
    );
  return appendOwnerState(nt, _extends({}, lt, { ref: ut }), it);
}
function mapEventPropToEvent(tt) {
  return tt.substring(2).toLowerCase();
}
function clickedRootScrollbar(tt, et) {
  return (
    et.documentElement.clientWidth < tt.clientX ||
    et.documentElement.clientHeight < tt.clientY
  );
}
function ClickAwayListener(tt) {
  const {
      children: et,
      disableReactTree: nt = !1,
      mouseEvent: rt = "onClick",
      onClickAway: it,
      touchEvent: st = "onTouchEnd",
    } = tt,
    ot = reactExports.useRef(!1),
    at = reactExports.useRef(null),
    lt = reactExports.useRef(!1),
    ct = reactExports.useRef(!1);
  reactExports.useEffect(
    () => (
      setTimeout(() => {
        lt.current = !0;
      }, 0),
      () => {
        lt.current = !1;
      }
    ),
    []
  );
  const ut = useForkRef(et.ref, at),
    ft = useEventCallback((vt) => {
      const yt = ct.current;
      ct.current = !1;
      const Et = ownerDocument(at.current);
      if (
        !lt.current ||
        !at.current ||
        ("clientX" in vt && clickedRootScrollbar(vt, Et))
      )
        return;
      if (ot.current) {
        ot.current = !1;
        return;
      }
      let pt;
      vt.composedPath
        ? (pt = vt.composedPath().indexOf(at.current) > -1)
        : (pt =
            !Et.documentElement.contains(vt.target) ||
            at.current.contains(vt.target)),
        !pt && (nt || !yt) && it(vt);
    }),
    ht = (vt) => (yt) => {
      ct.current = !0;
      const Et = et.props[vt];
      Et && Et(yt);
    },
    mt = { ref: ut };
  return (
    st !== !1 && (mt[st] = ht(st)),
    reactExports.useEffect(() => {
      if (st !== !1) {
        const vt = mapEventPropToEvent(st),
          yt = ownerDocument(at.current),
          Et = () => {
            ot.current = !0;
          };
        return (
          yt.addEventListener(vt, ft),
          yt.addEventListener("touchmove", Et),
          () => {
            yt.removeEventListener(vt, ft),
              yt.removeEventListener("touchmove", Et);
          }
        );
      }
    }, [ft, st]),
    rt !== !1 && (mt[rt] = ht(rt)),
    reactExports.useEffect(() => {
      if (rt !== !1) {
        const vt = mapEventPropToEvent(rt),
          yt = ownerDocument(at.current);
        return (
          yt.addEventListener(vt, ft),
          () => {
            yt.removeEventListener(vt, ft);
          }
        );
      }
    }, [ft, rt]),
    jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: reactExports.cloneElement(et, mt),
    })
  );
}
var top = "top",
  bottom = "bottom",
  right = "right",
  left = "left",
  auto = "auto",
  basePlacements = [top, bottom, right, left],
  start = "start",
  end = "end",
  clippingParents = "clippingParents",
  viewport = "viewport",
  popper = "popper",
  reference = "reference",
  variationPlacements = basePlacements.reduce(function (tt, et) {
    return tt.concat([et + "-" + start, et + "-" + end]);
  }, []),
  placements = [].concat(basePlacements, [auto]).reduce(function (tt, et) {
    return tt.concat([et, et + "-" + start, et + "-" + end]);
  }, []),
  beforeRead = "beforeRead",
  read = "read",
  afterRead = "afterRead",
  beforeMain = "beforeMain",
  main = "main",
  afterMain = "afterMain",
  beforeWrite = "beforeWrite",
  write = "write",
  afterWrite = "afterWrite",
  modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite,
  ];
function getNodeName(tt) {
  return tt ? (tt.nodeName || "").toLowerCase() : null;
}
function getWindow(tt) {
  if (tt == null) return window;
  if (tt.toString() !== "[object Window]") {
    var et = tt.ownerDocument;
    return (et && et.defaultView) || window;
  }
  return tt;
}
function isElement(tt) {
  var et = getWindow(tt).Element;
  return tt instanceof et || tt instanceof Element;
}
function isHTMLElement$1(tt) {
  var et = getWindow(tt).HTMLElement;
  return tt instanceof et || tt instanceof HTMLElement;
}
function isShadowRoot(tt) {
  if (typeof ShadowRoot > "u") return !1;
  var et = getWindow(tt).ShadowRoot;
  return tt instanceof et || tt instanceof ShadowRoot;
}
function applyStyles(tt) {
  var et = tt.state;
  Object.keys(et.elements).forEach(function (nt) {
    var rt = et.styles[nt] || {},
      it = et.attributes[nt] || {},
      st = et.elements[nt];
    !isHTMLElement$1(st) ||
      !getNodeName(st) ||
      (Object.assign(st.style, rt),
      Object.keys(it).forEach(function (ot) {
        var at = it[ot];
        at === !1
          ? st.removeAttribute(ot)
          : st.setAttribute(ot, at === !0 ? "" : at);
      }));
  });
}
function effect$2(tt) {
  var et = tt.state,
    nt = {
      popper: {
        position: et.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: { position: "absolute" },
      reference: {},
    };
  return (
    Object.assign(et.elements.popper.style, nt.popper),
    (et.styles = nt),
    et.elements.arrow && Object.assign(et.elements.arrow.style, nt.arrow),
    function () {
      Object.keys(et.elements).forEach(function (rt) {
        var it = et.elements[rt],
          st = et.attributes[rt] || {},
          ot = Object.keys(
            et.styles.hasOwnProperty(rt) ? et.styles[rt] : nt[rt]
          ),
          at = ot.reduce(function (lt, ct) {
            return (lt[ct] = ""), lt;
          }, {});
        !isHTMLElement$1(it) ||
          !getNodeName(it) ||
          (Object.assign(it.style, at),
          Object.keys(st).forEach(function (lt) {
            it.removeAttribute(lt);
          }));
      });
    }
  );
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"],
};
function getBasePlacement(tt) {
  return tt.split("-")[0];
}
var max = Math.max,
  min = Math.min,
  round$1 = Math.round;
function getUAString() {
  var tt = navigator.userAgentData;
  return tt != null && tt.brands && Array.isArray(tt.brands)
    ? tt.brands
        .map(function (et) {
          return et.brand + "/" + et.version;
        })
        .join(" ")
    : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(tt, et, nt) {
  et === void 0 && (et = !1), nt === void 0 && (nt = !1);
  var rt = tt.getBoundingClientRect(),
    it = 1,
    st = 1;
  et &&
    isHTMLElement$1(tt) &&
    ((it = (tt.offsetWidth > 0 && round$1(rt.width) / tt.offsetWidth) || 1),
    (st = (tt.offsetHeight > 0 && round$1(rt.height) / tt.offsetHeight) || 1));
  var ot = isElement(tt) ? getWindow(tt) : window,
    at = ot.visualViewport,
    lt = !isLayoutViewport() && nt,
    ct = (rt.left + (lt && at ? at.offsetLeft : 0)) / it,
    ut = (rt.top + (lt && at ? at.offsetTop : 0)) / st,
    ft = rt.width / it,
    ht = rt.height / st;
  return {
    width: ft,
    height: ht,
    top: ut,
    right: ct + ft,
    bottom: ut + ht,
    left: ct,
    x: ct,
    y: ut,
  };
}
function getLayoutRect(tt) {
  var et = getBoundingClientRect(tt),
    nt = tt.offsetWidth,
    rt = tt.offsetHeight;
  return (
    Math.abs(et.width - nt) <= 1 && (nt = et.width),
    Math.abs(et.height - rt) <= 1 && (rt = et.height),
    { x: tt.offsetLeft, y: tt.offsetTop, width: nt, height: rt }
  );
}
function contains(tt, et) {
  var nt = et.getRootNode && et.getRootNode();
  if (tt.contains(et)) return !0;
  if (nt && isShadowRoot(nt)) {
    var rt = et;
    do {
      if (rt && tt.isSameNode(rt)) return !0;
      rt = rt.parentNode || rt.host;
    } while (rt);
  }
  return !1;
}
function getComputedStyle(tt) {
  return getWindow(tt).getComputedStyle(tt);
}
function isTableElement(tt) {
  return ["table", "td", "th"].indexOf(getNodeName(tt)) >= 0;
}
function getDocumentElement(tt) {
  return ((isElement(tt) ? tt.ownerDocument : tt.document) || window.document)
    .documentElement;
}
function getParentNode(tt) {
  return getNodeName(tt) === "html"
    ? tt
    : tt.assignedSlot ||
        tt.parentNode ||
        (isShadowRoot(tt) ? tt.host : null) ||
        getDocumentElement(tt);
}
function getTrueOffsetParent(tt) {
  return !isHTMLElement$1(tt) || getComputedStyle(tt).position === "fixed"
    ? null
    : tt.offsetParent;
}
function getContainingBlock(tt) {
  var et = /firefox/i.test(getUAString()),
    nt = /Trident/i.test(getUAString());
  if (nt && isHTMLElement$1(tt)) {
    var rt = getComputedStyle(tt);
    if (rt.position === "fixed") return null;
  }
  var it = getParentNode(tt);
  for (
    isShadowRoot(it) && (it = it.host);
    isHTMLElement$1(it) && ["html", "body"].indexOf(getNodeName(it)) < 0;

  ) {
    var st = getComputedStyle(it);
    if (
      st.transform !== "none" ||
      st.perspective !== "none" ||
      st.contain === "paint" ||
      ["transform", "perspective"].indexOf(st.willChange) !== -1 ||
      (et && st.willChange === "filter") ||
      (et && st.filter && st.filter !== "none")
    )
      return it;
    it = it.parentNode;
  }
  return null;
}
function getOffsetParent(tt) {
  for (
    var et = getWindow(tt), nt = getTrueOffsetParent(tt);
    nt && isTableElement(nt) && getComputedStyle(nt).position === "static";

  )
    nt = getTrueOffsetParent(nt);
  return nt &&
    (getNodeName(nt) === "html" ||
      (getNodeName(nt) === "body" &&
        getComputedStyle(nt).position === "static"))
    ? et
    : nt || getContainingBlock(tt) || et;
}
function getMainAxisFromPlacement(tt) {
  return ["top", "bottom"].indexOf(tt) >= 0 ? "x" : "y";
}
function within(tt, et, nt) {
  return max(tt, min(et, nt));
}
function withinMaxClamp(tt, et, nt) {
  var rt = within(tt, et, nt);
  return rt > nt ? nt : rt;
}
function getFreshSideObject() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function mergePaddingObject(tt) {
  return Object.assign({}, getFreshSideObject(), tt);
}
function expandToHashMap(tt, et) {
  return et.reduce(function (nt, rt) {
    return (nt[rt] = tt), nt;
  }, {});
}
var toPaddingObject = function (et, nt) {
  return (
    (et =
      typeof et == "function"
        ? et(Object.assign({}, nt.rects, { placement: nt.placement }))
        : et),
    mergePaddingObject(
      typeof et != "number" ? et : expandToHashMap(et, basePlacements)
    )
  );
};
function arrow(tt) {
  var et,
    nt = tt.state,
    rt = tt.name,
    it = tt.options,
    st = nt.elements.arrow,
    ot = nt.modifiersData.popperOffsets,
    at = getBasePlacement(nt.placement),
    lt = getMainAxisFromPlacement(at),
    ct = [left, right].indexOf(at) >= 0,
    ut = ct ? "height" : "width";
  if (!(!st || !ot)) {
    var ft = toPaddingObject(it.padding, nt),
      ht = getLayoutRect(st),
      mt = lt === "y" ? top : left,
      vt = lt === "y" ? bottom : right,
      yt =
        nt.rects.reference[ut] +
        nt.rects.reference[lt] -
        ot[lt] -
        nt.rects.popper[ut],
      Et = ot[lt] - nt.rects.reference[lt],
      pt = getOffsetParent(st),
      xt = pt ? (lt === "y" ? pt.clientHeight || 0 : pt.clientWidth || 0) : 0,
      St = yt / 2 - Et / 2,
      At = ft[mt],
      Ct = xt - ht[ut] - ft[vt],
      Mt = xt / 2 - ht[ut] / 2 + St,
      wt = within(At, Mt, Ct),
      Bt = lt;
    nt.modifiersData[rt] =
      ((et = {}), (et[Bt] = wt), (et.centerOffset = wt - Mt), et);
  }
}
function effect$1(tt) {
  var et = tt.state,
    nt = tt.options,
    rt = nt.element,
    it = rt === void 0 ? "[data-popper-arrow]" : rt;
  it != null &&
    ((typeof it == "string" &&
      ((it = et.elements.popper.querySelector(it)), !it)) ||
      (contains(et.elements.popper, it) && (et.elements.arrow = it)));
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function getVariation(tt) {
  return tt.split("-")[1];
}
var unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function roundOffsetsByDPR(tt, et) {
  var nt = tt.x,
    rt = tt.y,
    it = et.devicePixelRatio || 1;
  return { x: round$1(nt * it) / it || 0, y: round$1(rt * it) / it || 0 };
}
function mapToStyles(tt) {
  var et,
    nt = tt.popper,
    rt = tt.popperRect,
    it = tt.placement,
    st = tt.variation,
    ot = tt.offsets,
    at = tt.position,
    lt = tt.gpuAcceleration,
    ct = tt.adaptive,
    ut = tt.roundOffsets,
    ft = tt.isFixed,
    ht = ot.x,
    mt = ht === void 0 ? 0 : ht,
    vt = ot.y,
    yt = vt === void 0 ? 0 : vt,
    Et = typeof ut == "function" ? ut({ x: mt, y: yt }) : { x: mt, y: yt };
  (mt = Et.x), (yt = Et.y);
  var pt = ot.hasOwnProperty("x"),
    xt = ot.hasOwnProperty("y"),
    St = left,
    At = top,
    Ct = window;
  if (ct) {
    var Mt = getOffsetParent(nt),
      wt = "clientHeight",
      Bt = "clientWidth";
    if (
      (Mt === getWindow(nt) &&
        ((Mt = getDocumentElement(nt)),
        getComputedStyle(Mt).position !== "static" &&
          at === "absolute" &&
          ((wt = "scrollHeight"), (Bt = "scrollWidth"))),
      (Mt = Mt),
      it === top || ((it === left || it === right) && st === end))
    ) {
      At = bottom;
      var It =
        ft && Mt === Ct && Ct.visualViewport
          ? Ct.visualViewport.height
          : Mt[wt];
      (yt -= It - rt.height), (yt *= lt ? 1 : -1);
    }
    if (it === left || ((it === top || it === bottom) && st === end)) {
      St = right;
      var Ft =
        ft && Mt === Ct && Ct.visualViewport ? Ct.visualViewport.width : Mt[Bt];
      (mt -= Ft - rt.width), (mt *= lt ? 1 : -1);
    }
  }
  var Vt = Object.assign({ position: at }, ct && unsetSides),
    $t =
      ut === !0
        ? roundOffsetsByDPR({ x: mt, y: yt }, getWindow(nt))
        : { x: mt, y: yt };
  if (((mt = $t.x), (yt = $t.y), lt)) {
    var Kt;
    return Object.assign(
      {},
      Vt,
      ((Kt = {}),
      (Kt[At] = xt ? "0" : ""),
      (Kt[St] = pt ? "0" : ""),
      (Kt.transform =
        (Ct.devicePixelRatio || 1) <= 1
          ? "translate(" + mt + "px, " + yt + "px)"
          : "translate3d(" + mt + "px, " + yt + "px, 0)"),
      Kt)
    );
  }
  return Object.assign(
    {},
    Vt,
    ((et = {}),
    (et[At] = xt ? yt + "px" : ""),
    (et[St] = pt ? mt + "px" : ""),
    (et.transform = ""),
    et)
  );
}
function computeStyles(tt) {
  var et = tt.state,
    nt = tt.options,
    rt = nt.gpuAcceleration,
    it = rt === void 0 ? !0 : rt,
    st = nt.adaptive,
    ot = st === void 0 ? !0 : st,
    at = nt.roundOffsets,
    lt = at === void 0 ? !0 : at,
    ct = {
      placement: getBasePlacement(et.placement),
      variation: getVariation(et.placement),
      popper: et.elements.popper,
      popperRect: et.rects.popper,
      gpuAcceleration: it,
      isFixed: et.options.strategy === "fixed",
    };
  et.modifiersData.popperOffsets != null &&
    (et.styles.popper = Object.assign(
      {},
      et.styles.popper,
      mapToStyles(
        Object.assign({}, ct, {
          offsets: et.modifiersData.popperOffsets,
          position: et.options.strategy,
          adaptive: ot,
          roundOffsets: lt,
        })
      )
    )),
    et.modifiersData.arrow != null &&
      (et.styles.arrow = Object.assign(
        {},
        et.styles.arrow,
        mapToStyles(
          Object.assign({}, ct, {
            offsets: et.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: lt,
          })
        )
      )),
    (et.attributes.popper = Object.assign({}, et.attributes.popper, {
      "data-popper-placement": et.placement,
    }));
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {},
};
var passive = { passive: !0 };
function effect(tt) {
  var et = tt.state,
    nt = tt.instance,
    rt = tt.options,
    it = rt.scroll,
    st = it === void 0 ? !0 : it,
    ot = rt.resize,
    at = ot === void 0 ? !0 : ot,
    lt = getWindow(et.elements.popper),
    ct = [].concat(et.scrollParents.reference, et.scrollParents.popper);
  return (
    st &&
      ct.forEach(function (ut) {
        ut.addEventListener("scroll", nt.update, passive);
      }),
    at && lt.addEventListener("resize", nt.update, passive),
    function () {
      st &&
        ct.forEach(function (ut) {
          ut.removeEventListener("scroll", nt.update, passive);
        }),
        at && lt.removeEventListener("resize", nt.update, passive);
    }
  );
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect,
  data: {},
};
var hash$1 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(tt) {
  return tt.replace(/left|right|bottom|top/g, function (et) {
    return hash$1[et];
  });
}
var hash = { start: "end", end: "start" };
function getOppositeVariationPlacement(tt) {
  return tt.replace(/start|end/g, function (et) {
    return hash[et];
  });
}
function getWindowScroll(tt) {
  var et = getWindow(tt),
    nt = et.pageXOffset,
    rt = et.pageYOffset;
  return { scrollLeft: nt, scrollTop: rt };
}
function getWindowScrollBarX(tt) {
  return (
    getBoundingClientRect(getDocumentElement(tt)).left +
    getWindowScroll(tt).scrollLeft
  );
}
function getViewportRect(tt, et) {
  var nt = getWindow(tt),
    rt = getDocumentElement(tt),
    it = nt.visualViewport,
    st = rt.clientWidth,
    ot = rt.clientHeight,
    at = 0,
    lt = 0;
  if (it) {
    (st = it.width), (ot = it.height);
    var ct = isLayoutViewport();
    (ct || (!ct && et === "fixed")) &&
      ((at = it.offsetLeft), (lt = it.offsetTop));
  }
  return { width: st, height: ot, x: at + getWindowScrollBarX(tt), y: lt };
}
function getDocumentRect(tt) {
  var et,
    nt = getDocumentElement(tt),
    rt = getWindowScroll(tt),
    it = (et = tt.ownerDocument) == null ? void 0 : et.body,
    st = max(
      nt.scrollWidth,
      nt.clientWidth,
      it ? it.scrollWidth : 0,
      it ? it.clientWidth : 0
    ),
    ot = max(
      nt.scrollHeight,
      nt.clientHeight,
      it ? it.scrollHeight : 0,
      it ? it.clientHeight : 0
    ),
    at = -rt.scrollLeft + getWindowScrollBarX(tt),
    lt = -rt.scrollTop;
  return (
    getComputedStyle(it || nt).direction === "rtl" &&
      (at += max(nt.clientWidth, it ? it.clientWidth : 0) - st),
    { width: st, height: ot, x: at, y: lt }
  );
}
function isScrollParent(tt) {
  var et = getComputedStyle(tt),
    nt = et.overflow,
    rt = et.overflowX,
    it = et.overflowY;
  return /auto|scroll|overlay|hidden/.test(nt + it + rt);
}
function getScrollParent(tt) {
  return ["html", "body", "#document"].indexOf(getNodeName(tt)) >= 0
    ? tt.ownerDocument.body
    : isHTMLElement$1(tt) && isScrollParent(tt)
    ? tt
    : getScrollParent(getParentNode(tt));
}
function listScrollParents(tt, et) {
  var nt;
  et === void 0 && (et = []);
  var rt = getScrollParent(tt),
    it = rt === ((nt = tt.ownerDocument) == null ? void 0 : nt.body),
    st = getWindow(rt),
    ot = it
      ? [st].concat(st.visualViewport || [], isScrollParent(rt) ? rt : [])
      : rt,
    at = et.concat(ot);
  return it ? at : at.concat(listScrollParents(getParentNode(ot)));
}
function rectToClientRect(tt) {
  return Object.assign({}, tt, {
    left: tt.x,
    top: tt.y,
    right: tt.x + tt.width,
    bottom: tt.y + tt.height,
  });
}
function getInnerBoundingClientRect(tt, et) {
  var nt = getBoundingClientRect(tt, !1, et === "fixed");
  return (
    (nt.top = nt.top + tt.clientTop),
    (nt.left = nt.left + tt.clientLeft),
    (nt.bottom = nt.top + tt.clientHeight),
    (nt.right = nt.left + tt.clientWidth),
    (nt.width = tt.clientWidth),
    (nt.height = tt.clientHeight),
    (nt.x = nt.left),
    (nt.y = nt.top),
    nt
  );
}
function getClientRectFromMixedType(tt, et, nt) {
  return et === viewport
    ? rectToClientRect(getViewportRect(tt, nt))
    : isElement(et)
    ? getInnerBoundingClientRect(et, nt)
    : rectToClientRect(getDocumentRect(getDocumentElement(tt)));
}
function getClippingParents(tt) {
  var et = listScrollParents(getParentNode(tt)),
    nt = ["absolute", "fixed"].indexOf(getComputedStyle(tt).position) >= 0,
    rt = nt && isHTMLElement$1(tt) ? getOffsetParent(tt) : tt;
  return isElement(rt)
    ? et.filter(function (it) {
        return isElement(it) && contains(it, rt) && getNodeName(it) !== "body";
      })
    : [];
}
function getClippingRect(tt, et, nt, rt) {
  var it = et === "clippingParents" ? getClippingParents(tt) : [].concat(et),
    st = [].concat(it, [nt]),
    ot = st[0],
    at = st.reduce(function (lt, ct) {
      var ut = getClientRectFromMixedType(tt, ct, rt);
      return (
        (lt.top = max(ut.top, lt.top)),
        (lt.right = min(ut.right, lt.right)),
        (lt.bottom = min(ut.bottom, lt.bottom)),
        (lt.left = max(ut.left, lt.left)),
        lt
      );
    }, getClientRectFromMixedType(tt, ot, rt));
  return (
    (at.width = at.right - at.left),
    (at.height = at.bottom - at.top),
    (at.x = at.left),
    (at.y = at.top),
    at
  );
}
function computeOffsets(tt) {
  var et = tt.reference,
    nt = tt.element,
    rt = tt.placement,
    it = rt ? getBasePlacement(rt) : null,
    st = rt ? getVariation(rt) : null,
    ot = et.x + et.width / 2 - nt.width / 2,
    at = et.y + et.height / 2 - nt.height / 2,
    lt;
  switch (it) {
    case top:
      lt = { x: ot, y: et.y - nt.height };
      break;
    case bottom:
      lt = { x: ot, y: et.y + et.height };
      break;
    case right:
      lt = { x: et.x + et.width, y: at };
      break;
    case left:
      lt = { x: et.x - nt.width, y: at };
      break;
    default:
      lt = { x: et.x, y: et.y };
  }
  var ct = it ? getMainAxisFromPlacement(it) : null;
  if (ct != null) {
    var ut = ct === "y" ? "height" : "width";
    switch (st) {
      case start:
        lt[ct] = lt[ct] - (et[ut] / 2 - nt[ut] / 2);
        break;
      case end:
        lt[ct] = lt[ct] + (et[ut] / 2 - nt[ut] / 2);
        break;
    }
  }
  return lt;
}
function detectOverflow(tt, et) {
  et === void 0 && (et = {});
  var nt = et,
    rt = nt.placement,
    it = rt === void 0 ? tt.placement : rt,
    st = nt.strategy,
    ot = st === void 0 ? tt.strategy : st,
    at = nt.boundary,
    lt = at === void 0 ? clippingParents : at,
    ct = nt.rootBoundary,
    ut = ct === void 0 ? viewport : ct,
    ft = nt.elementContext,
    ht = ft === void 0 ? popper : ft,
    mt = nt.altBoundary,
    vt = mt === void 0 ? !1 : mt,
    yt = nt.padding,
    Et = yt === void 0 ? 0 : yt,
    pt = mergePaddingObject(
      typeof Et != "number" ? Et : expandToHashMap(Et, basePlacements)
    ),
    xt = ht === popper ? reference : popper,
    St = tt.rects.popper,
    At = tt.elements[vt ? xt : ht],
    Ct = getClippingRect(
      isElement(At)
        ? At
        : At.contextElement || getDocumentElement(tt.elements.popper),
      lt,
      ut,
      ot
    ),
    Mt = getBoundingClientRect(tt.elements.reference),
    wt = computeOffsets({
      reference: Mt,
      element: St,
      strategy: "absolute",
      placement: it,
    }),
    Bt = rectToClientRect(Object.assign({}, St, wt)),
    It = ht === popper ? Bt : Mt,
    Ft = {
      top: Ct.top - It.top + pt.top,
      bottom: It.bottom - Ct.bottom + pt.bottom,
      left: Ct.left - It.left + pt.left,
      right: It.right - Ct.right + pt.right,
    },
    Vt = tt.modifiersData.offset;
  if (ht === popper && Vt) {
    var $t = Vt[it];
    Object.keys(Ft).forEach(function (Kt) {
      var Ht = [right, bottom].indexOf(Kt) >= 0 ? 1 : -1,
        Wt = [top, bottom].indexOf(Kt) >= 0 ? "y" : "x";
      Ft[Kt] += $t[Wt] * Ht;
    });
  }
  return Ft;
}
function computeAutoPlacement(tt, et) {
  et === void 0 && (et = {});
  var nt = et,
    rt = nt.placement,
    it = nt.boundary,
    st = nt.rootBoundary,
    ot = nt.padding,
    at = nt.flipVariations,
    lt = nt.allowedAutoPlacements,
    ct = lt === void 0 ? placements : lt,
    ut = getVariation(rt),
    ft = ut
      ? at
        ? variationPlacements
        : variationPlacements.filter(function (vt) {
            return getVariation(vt) === ut;
          })
      : basePlacements,
    ht = ft.filter(function (vt) {
      return ct.indexOf(vt) >= 0;
    });
  ht.length === 0 && (ht = ft);
  var mt = ht.reduce(function (vt, yt) {
    return (
      (vt[yt] = detectOverflow(tt, {
        placement: yt,
        boundary: it,
        rootBoundary: st,
        padding: ot,
      })[getBasePlacement(yt)]),
      vt
    );
  }, {});
  return Object.keys(mt).sort(function (vt, yt) {
    return mt[vt] - mt[yt];
  });
}
function getExpandedFallbackPlacements(tt) {
  if (getBasePlacement(tt) === auto) return [];
  var et = getOppositePlacement(tt);
  return [
    getOppositeVariationPlacement(tt),
    et,
    getOppositeVariationPlacement(et),
  ];
}
function flip(tt) {
  var et = tt.state,
    nt = tt.options,
    rt = tt.name;
  if (!et.modifiersData[rt]._skip) {
    for (
      var it = nt.mainAxis,
        st = it === void 0 ? !0 : it,
        ot = nt.altAxis,
        at = ot === void 0 ? !0 : ot,
        lt = nt.fallbackPlacements,
        ct = nt.padding,
        ut = nt.boundary,
        ft = nt.rootBoundary,
        ht = nt.altBoundary,
        mt = nt.flipVariations,
        vt = mt === void 0 ? !0 : mt,
        yt = nt.allowedAutoPlacements,
        Et = et.options.placement,
        pt = getBasePlacement(Et),
        xt = pt === Et,
        St =
          lt ||
          (xt || !vt
            ? [getOppositePlacement(Et)]
            : getExpandedFallbackPlacements(Et)),
        At = [Et].concat(St).reduce(function (qt, Zt) {
          return qt.concat(
            getBasePlacement(Zt) === auto
              ? computeAutoPlacement(et, {
                  placement: Zt,
                  boundary: ut,
                  rootBoundary: ft,
                  padding: ct,
                  flipVariations: vt,
                  allowedAutoPlacements: yt,
                })
              : Zt
          );
        }, []),
        Ct = et.rects.reference,
        Mt = et.rects.popper,
        wt = new Map(),
        Bt = !0,
        It = At[0],
        Ft = 0;
      Ft < At.length;
      Ft++
    ) {
      var Vt = At[Ft],
        $t = getBasePlacement(Vt),
        Kt = getVariation(Vt) === start,
        Ht = [top, bottom].indexOf($t) >= 0,
        Wt = Ht ? "width" : "height",
        kt = detectOverflow(et, {
          placement: Vt,
          boundary: ut,
          rootBoundary: ft,
          altBoundary: ht,
          padding: ct,
        }),
        Gt = Ht ? (Kt ? right : left) : Kt ? bottom : top;
      Ct[Wt] > Mt[Wt] && (Gt = getOppositePlacement(Gt));
      var Pt = getOppositePlacement(Gt),
        Rt = [];
      if (
        (st && Rt.push(kt[$t] <= 0),
        at && Rt.push(kt[Gt] <= 0, kt[Pt] <= 0),
        Rt.every(function (qt) {
          return qt;
        }))
      ) {
        (It = Vt), (Bt = !1);
        break;
      }
      wt.set(Vt, Rt);
    }
    if (Bt)
      for (
        var Nt = vt ? 3 : 1,
          Dt = function (Zt) {
            var Jt = At.find(function (mn) {
              var ln = wt.get(mn);
              if (ln)
                return ln.slice(0, Zt).every(function (bn) {
                  return bn;
                });
            });
            if (Jt) return (It = Jt), "break";
          },
          zt = Nt;
        zt > 0;
        zt--
      ) {
        var Yt = Dt(zt);
        if (Yt === "break") break;
      }
    et.placement !== It &&
      ((et.modifiersData[rt]._skip = !0), (et.placement = It), (et.reset = !0));
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: { _skip: !1 },
};
function getSideOffsets(tt, et, nt) {
  return (
    nt === void 0 && (nt = { x: 0, y: 0 }),
    {
      top: tt.top - et.height - nt.y,
      right: tt.right - et.width + nt.x,
      bottom: tt.bottom - et.height + nt.y,
      left: tt.left - et.width - nt.x,
    }
  );
}
function isAnySideFullyClipped(tt) {
  return [top, right, bottom, left].some(function (et) {
    return tt[et] >= 0;
  });
}
function hide(tt) {
  var et = tt.state,
    nt = tt.name,
    rt = et.rects.reference,
    it = et.rects.popper,
    st = et.modifiersData.preventOverflow,
    ot = detectOverflow(et, { elementContext: "reference" }),
    at = detectOverflow(et, { altBoundary: !0 }),
    lt = getSideOffsets(ot, rt),
    ct = getSideOffsets(at, it, st),
    ut = isAnySideFullyClipped(lt),
    ft = isAnySideFullyClipped(ct);
  (et.modifiersData[nt] = {
    referenceClippingOffsets: lt,
    popperEscapeOffsets: ct,
    isReferenceHidden: ut,
    hasPopperEscaped: ft,
  }),
    (et.attributes.popper = Object.assign({}, et.attributes.popper, {
      "data-popper-reference-hidden": ut,
      "data-popper-escaped": ft,
    }));
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide,
};
function distanceAndSkiddingToXY(tt, et, nt) {
  var rt = getBasePlacement(tt),
    it = [left, top].indexOf(rt) >= 0 ? -1 : 1,
    st =
      typeof nt == "function"
        ? nt(Object.assign({}, et, { placement: tt }))
        : nt,
    ot = st[0],
    at = st[1];
  return (
    (ot = ot || 0),
    (at = (at || 0) * it),
    [left, right].indexOf(rt) >= 0 ? { x: at, y: ot } : { x: ot, y: at }
  );
}
function offset(tt) {
  var et = tt.state,
    nt = tt.options,
    rt = tt.name,
    it = nt.offset,
    st = it === void 0 ? [0, 0] : it,
    ot = placements.reduce(function (ut, ft) {
      return (ut[ft] = distanceAndSkiddingToXY(ft, et.rects, st)), ut;
    }, {}),
    at = ot[et.placement],
    lt = at.x,
    ct = at.y;
  et.modifiersData.popperOffsets != null &&
    ((et.modifiersData.popperOffsets.x += lt),
    (et.modifiersData.popperOffsets.y += ct)),
    (et.modifiersData[rt] = ot);
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset,
};
function popperOffsets(tt) {
  var et = tt.state,
    nt = tt.name;
  et.modifiersData[nt] = computeOffsets({
    reference: et.rects.reference,
    element: et.rects.popper,
    strategy: "absolute",
    placement: et.placement,
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {},
};
function getAltAxis(tt) {
  return tt === "x" ? "y" : "x";
}
function preventOverflow(tt) {
  var et = tt.state,
    nt = tt.options,
    rt = tt.name,
    it = nt.mainAxis,
    st = it === void 0 ? !0 : it,
    ot = nt.altAxis,
    at = ot === void 0 ? !1 : ot,
    lt = nt.boundary,
    ct = nt.rootBoundary,
    ut = nt.altBoundary,
    ft = nt.padding,
    ht = nt.tether,
    mt = ht === void 0 ? !0 : ht,
    vt = nt.tetherOffset,
    yt = vt === void 0 ? 0 : vt,
    Et = detectOverflow(et, {
      boundary: lt,
      rootBoundary: ct,
      padding: ft,
      altBoundary: ut,
    }),
    pt = getBasePlacement(et.placement),
    xt = getVariation(et.placement),
    St = !xt,
    At = getMainAxisFromPlacement(pt),
    Ct = getAltAxis(At),
    Mt = et.modifiersData.popperOffsets,
    wt = et.rects.reference,
    Bt = et.rects.popper,
    It =
      typeof yt == "function"
        ? yt(Object.assign({}, et.rects, { placement: et.placement }))
        : yt,
    Ft =
      typeof It == "number"
        ? { mainAxis: It, altAxis: It }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, It),
    Vt = et.modifiersData.offset ? et.modifiersData.offset[et.placement] : null,
    $t = { x: 0, y: 0 };
  if (Mt) {
    if (st) {
      var Kt,
        Ht = At === "y" ? top : left,
        Wt = At === "y" ? bottom : right,
        kt = At === "y" ? "height" : "width",
        Gt = Mt[At],
        Pt = Gt + Et[Ht],
        Rt = Gt - Et[Wt],
        Nt = mt ? -Bt[kt] / 2 : 0,
        Dt = xt === start ? wt[kt] : Bt[kt],
        zt = xt === start ? -Bt[kt] : -wt[kt],
        Yt = et.elements.arrow,
        qt = mt && Yt ? getLayoutRect(Yt) : { width: 0, height: 0 },
        Zt = et.modifiersData["arrow#persistent"]
          ? et.modifiersData["arrow#persistent"].padding
          : getFreshSideObject(),
        Jt = Zt[Ht],
        mn = Zt[Wt],
        ln = within(0, wt[kt], qt[kt]),
        bn = St
          ? wt[kt] / 2 - Nt - ln - Jt - Ft.mainAxis
          : Dt - ln - Jt - Ft.mainAxis,
        Bn = St
          ? -wt[kt] / 2 + Nt + ln + mn + Ft.mainAxis
          : zt + ln + mn + Ft.mainAxis,
        gn = et.elements.arrow && getOffsetParent(et.elements.arrow),
        jt = gn ? (At === "y" ? gn.clientTop || 0 : gn.clientLeft || 0) : 0,
        yn = (Kt = Vt == null ? void 0 : Vt[At]) != null ? Kt : 0,
        pn = Gt + bn - yn - jt,
        vn = Gt + Bn - yn,
        xn = within(mt ? min(Pt, pn) : Pt, Gt, mt ? max(Rt, vn) : Rt);
      (Mt[At] = xn), ($t[At] = xn - Gt);
    }
    if (at) {
      var Fn,
        _n = At === "x" ? top : left,
        Dn = At === "x" ? bottom : right,
        Tn = Mt[Ct],
        An = Ct === "y" ? "height" : "width",
        Wn = Tn + Et[_n],
        Xt = Tn - Et[Dn],
        Ut = [top, left].indexOf(pt) !== -1,
        hn = (Fn = Vt == null ? void 0 : Vt[Ct]) != null ? Fn : 0,
        Ln = Ut ? Wn : Tn - wt[An] - Bt[An] - hn + Ft.altAxis,
        Cn = Ut ? Tn + wt[An] + Bt[An] - hn - Ft.altAxis : Xt,
        Mn =
          mt && Ut
            ? withinMaxClamp(Ln, Tn, Cn)
            : within(mt ? Ln : Wn, Tn, mt ? Cn : Xt);
      (Mt[Ct] = Mn), ($t[Ct] = Mn - Tn);
    }
    et.modifiersData[rt] = $t;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"],
};
function getHTMLElementScroll(tt) {
  return { scrollLeft: tt.scrollLeft, scrollTop: tt.scrollTop };
}
function getNodeScroll(tt) {
  return tt === getWindow(tt) || !isHTMLElement$1(tt)
    ? getWindowScroll(tt)
    : getHTMLElementScroll(tt);
}
function isElementScaled(tt) {
  var et = tt.getBoundingClientRect(),
    nt = round$1(et.width) / tt.offsetWidth || 1,
    rt = round$1(et.height) / tt.offsetHeight || 1;
  return nt !== 1 || rt !== 1;
}
function getCompositeRect(tt, et, nt) {
  nt === void 0 && (nt = !1);
  var rt = isHTMLElement$1(et),
    it = isHTMLElement$1(et) && isElementScaled(et),
    st = getDocumentElement(et),
    ot = getBoundingClientRect(tt, it, nt),
    at = { scrollLeft: 0, scrollTop: 0 },
    lt = { x: 0, y: 0 };
  return (
    (rt || (!rt && !nt)) &&
      ((getNodeName(et) !== "body" || isScrollParent(st)) &&
        (at = getNodeScroll(et)),
      isHTMLElement$1(et)
        ? ((lt = getBoundingClientRect(et, !0)),
          (lt.x += et.clientLeft),
          (lt.y += et.clientTop))
        : st && (lt.x = getWindowScrollBarX(st))),
    {
      x: ot.left + at.scrollLeft - lt.x,
      y: ot.top + at.scrollTop - lt.y,
      width: ot.width,
      height: ot.height,
    }
  );
}
function order(tt) {
  var et = new Map(),
    nt = new Set(),
    rt = [];
  tt.forEach(function (st) {
    et.set(st.name, st);
  });
  function it(st) {
    nt.add(st.name);
    var ot = [].concat(st.requires || [], st.requiresIfExists || []);
    ot.forEach(function (at) {
      if (!nt.has(at)) {
        var lt = et.get(at);
        lt && it(lt);
      }
    }),
      rt.push(st);
  }
  return (
    tt.forEach(function (st) {
      nt.has(st.name) || it(st);
    }),
    rt
  );
}
function orderModifiers(tt) {
  var et = order(tt);
  return modifierPhases.reduce(function (nt, rt) {
    return nt.concat(
      et.filter(function (it) {
        return it.phase === rt;
      })
    );
  }, []);
}
function debounce(tt) {
  var et;
  return function () {
    return (
      et ||
        (et = new Promise(function (nt) {
          Promise.resolve().then(function () {
            (et = void 0), nt(tt());
          });
        })),
      et
    );
  };
}
function mergeByName(tt) {
  var et = tt.reduce(function (nt, rt) {
    var it = nt[rt.name];
    return (
      (nt[rt.name] = it
        ? Object.assign({}, it, rt, {
            options: Object.assign({}, it.options, rt.options),
            data: Object.assign({}, it.data, rt.data),
          })
        : rt),
      nt
    );
  }, {});
  return Object.keys(et).map(function (nt) {
    return et[nt];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute",
};
function areValidElements() {
  for (var tt = arguments.length, et = new Array(tt), nt = 0; nt < tt; nt++)
    et[nt] = arguments[nt];
  return !et.some(function (rt) {
    return !(rt && typeof rt.getBoundingClientRect == "function");
  });
}
function popperGenerator(tt) {
  tt === void 0 && (tt = {});
  var et = tt,
    nt = et.defaultModifiers,
    rt = nt === void 0 ? [] : nt,
    it = et.defaultOptions,
    st = it === void 0 ? DEFAULT_OPTIONS : it;
  return function (at, lt, ct) {
    ct === void 0 && (ct = st);
    var ut = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, st),
        modifiersData: {},
        elements: { reference: at, popper: lt },
        attributes: {},
        styles: {},
      },
      ft = [],
      ht = !1,
      mt = {
        state: ut,
        setOptions: function (pt) {
          var xt = typeof pt == "function" ? pt(ut.options) : pt;
          yt(),
            (ut.options = Object.assign({}, st, ut.options, xt)),
            (ut.scrollParents = {
              reference: isElement(at)
                ? listScrollParents(at)
                : at.contextElement
                ? listScrollParents(at.contextElement)
                : [],
              popper: listScrollParents(lt),
            });
          var St = orderModifiers(
            mergeByName([].concat(rt, ut.options.modifiers))
          );
          return (
            (ut.orderedModifiers = St.filter(function (At) {
              return At.enabled;
            })),
            vt(),
            mt.update()
          );
        },
        forceUpdate: function () {
          if (!ht) {
            var pt = ut.elements,
              xt = pt.reference,
              St = pt.popper;
            if (areValidElements(xt, St)) {
              (ut.rects = {
                reference: getCompositeRect(
                  xt,
                  getOffsetParent(St),
                  ut.options.strategy === "fixed"
                ),
                popper: getLayoutRect(St),
              }),
                (ut.reset = !1),
                (ut.placement = ut.options.placement),
                ut.orderedModifiers.forEach(function (Ft) {
                  return (ut.modifiersData[Ft.name] = Object.assign(
                    {},
                    Ft.data
                  ));
                });
              for (var At = 0; At < ut.orderedModifiers.length; At++) {
                if (ut.reset === !0) {
                  (ut.reset = !1), (At = -1);
                  continue;
                }
                var Ct = ut.orderedModifiers[At],
                  Mt = Ct.fn,
                  wt = Ct.options,
                  Bt = wt === void 0 ? {} : wt,
                  It = Ct.name;
                typeof Mt == "function" &&
                  (ut =
                    Mt({ state: ut, options: Bt, name: It, instance: mt }) ||
                    ut);
              }
            }
          }
        },
        update: debounce(function () {
          return new Promise(function (Et) {
            mt.forceUpdate(), Et(ut);
          });
        }),
        destroy: function () {
          yt(), (ht = !0);
        },
      };
    if (!areValidElements(at, lt)) return mt;
    mt.setOptions(ct).then(function (Et) {
      !ht && ct.onFirstUpdate && ct.onFirstUpdate(Et);
    });
    function vt() {
      ut.orderedModifiers.forEach(function (Et) {
        var pt = Et.name,
          xt = Et.options,
          St = xt === void 0 ? {} : xt,
          At = Et.effect;
        if (typeof At == "function") {
          var Ct = At({ state: ut, name: pt, instance: mt, options: St }),
            Mt = function () {};
          ft.push(Ct || Mt);
        }
      });
    }
    function yt() {
      ft.forEach(function (Et) {
        return Et();
      }),
        (ft = []);
    }
    return mt;
  };
}
var defaultModifiers = [
    eventListeners,
    popperOffsets$1,
    computeStyles$1,
    applyStyles$1,
    offset$1,
    flip$1,
    preventOverflow$1,
    arrow$1,
    hide$1,
  ],
  createPopper = popperGenerator({ defaultModifiers });
function getContainer(tt) {
  return typeof tt == "function" ? tt() : tt;
}
const Portal = reactExports.forwardRef(function (et, nt) {
  const { children: rt, container: it, disablePortal: st = !1 } = et,
    [ot, at] = reactExports.useState(null),
    lt = useForkRef(reactExports.isValidElement(rt) ? rt.ref : null, nt);
  if (
    (useEnhancedEffect$1(() => {
      st || at(getContainer(it) || document.body);
    }, [it, st]),
    useEnhancedEffect$1(() => {
      if (ot && !st)
        return (
          setRef(nt, ot),
          () => {
            setRef(nt, null);
          }
        );
    }, [nt, ot, st]),
    st)
  ) {
    if (reactExports.isValidElement(rt)) {
      const ct = { ref: lt };
      return reactExports.cloneElement(rt, ct);
    }
    return jsxRuntimeExports.jsx(reactExports.Fragment, { children: rt });
  }
  return jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: ot && reactDomExports.createPortal(rt, ot),
  });
});
function getPopperUtilityClass(tt) {
  return generateUtilityClass("MuiPopper", tt);
}
generateUtilityClasses("MuiPopper", ["root"]);
const _excluded$b = [
    "anchorEl",
    "children",
    "direction",
    "disablePortal",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "slotProps",
    "slots",
    "TransitionProps",
    "ownerState",
  ],
  _excluded2$1 = [
    "anchorEl",
    "children",
    "container",
    "direction",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "style",
    "transition",
    "slotProps",
    "slots",
  ];
function flipPlacement(tt, et) {
  if (et === "ltr") return tt;
  switch (tt) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return tt;
  }
}
function resolveAnchorEl(tt) {
  return typeof tt == "function" ? tt() : tt;
}
function isHTMLElement(tt) {
  return tt.nodeType !== void 0;
}
const useUtilityClasses$9 = () =>
    composeClasses(
      { root: ["root"] },
      useClassNamesOverride(getPopperUtilityClass)
    ),
  defaultPopperOptions = {},
  PopperTooltip = reactExports.forwardRef(function (et, nt) {
    var rt;
    const {
        anchorEl: it,
        children: st,
        direction: ot,
        disablePortal: at,
        modifiers: lt,
        open: ct,
        placement: ut,
        popperOptions: ft,
        popperRef: ht,
        slotProps: mt = {},
        slots: vt = {},
        TransitionProps: yt,
      } = et,
      Et = _objectWithoutPropertiesLoose(et, _excluded$b),
      pt = reactExports.useRef(null),
      xt = useForkRef(pt, nt),
      St = reactExports.useRef(null),
      At = useForkRef(St, ht),
      Ct = reactExports.useRef(At);
    useEnhancedEffect$1(() => {
      Ct.current = At;
    }, [At]),
      reactExports.useImperativeHandle(ht, () => St.current, []);
    const Mt = flipPlacement(ut, ot),
      [wt, Bt] = reactExports.useState(Mt),
      [It, Ft] = reactExports.useState(resolveAnchorEl(it));
    reactExports.useEffect(() => {
      St.current && St.current.forceUpdate();
    }),
      reactExports.useEffect(() => {
        it && Ft(resolveAnchorEl(it));
      }, [it]),
      useEnhancedEffect$1(() => {
        if (!It || !ct) return;
        const Wt = (Pt) => {
          Bt(Pt.placement);
        };
        let kt = [
          { name: "preventOverflow", options: { altBoundary: at } },
          { name: "flip", options: { altBoundary: at } },
          {
            name: "onUpdate",
            enabled: !0,
            phase: "afterWrite",
            fn: ({ state: Pt }) => {
              Wt(Pt);
            },
          },
        ];
        lt != null && (kt = kt.concat(lt)),
          ft && ft.modifiers != null && (kt = kt.concat(ft.modifiers));
        const Gt = createPopper(
          It,
          pt.current,
          _extends({ placement: Mt }, ft, { modifiers: kt })
        );
        return (
          Ct.current(Gt),
          () => {
            Gt.destroy(), Ct.current(null);
          }
        );
      }, [It, at, lt, ct, ft, Mt]);
    const Vt = { placement: wt };
    yt !== null && (Vt.TransitionProps = yt);
    const $t = useUtilityClasses$9(),
      Kt = (rt = vt.root) != null ? rt : "div",
      Ht = useSlotProps({
        elementType: Kt,
        externalSlotProps: mt.root,
        externalForwardedProps: Et,
        additionalProps: { role: "tooltip", ref: xt },
        ownerState: et,
        className: $t.root,
      });
    return jsxRuntimeExports.jsx(
      Kt,
      _extends({}, Ht, { children: typeof st == "function" ? st(Vt) : st })
    );
  }),
  Popper$2 = reactExports.forwardRef(function (et, nt) {
    const {
        anchorEl: rt,
        children: it,
        container: st,
        direction: ot = "ltr",
        disablePortal: at = !1,
        keepMounted: lt = !1,
        modifiers: ct,
        open: ut,
        placement: ft = "bottom",
        popperOptions: ht = defaultPopperOptions,
        popperRef: mt,
        style: vt,
        transition: yt = !1,
        slotProps: Et = {},
        slots: pt = {},
      } = et,
      xt = _objectWithoutPropertiesLoose(et, _excluded2$1),
      [St, At] = reactExports.useState(!0),
      Ct = () => {
        At(!1);
      },
      Mt = () => {
        At(!0);
      };
    if (!lt && !ut && (!yt || St)) return null;
    let wt;
    if (st) wt = st;
    else if (rt) {
      const Ft = resolveAnchorEl(rt);
      wt =
        Ft && isHTMLElement(Ft)
          ? ownerDocument(Ft).body
          : ownerDocument(null).body;
    }
    const Bt = !ut && lt && (!yt || St) ? "none" : void 0,
      It = yt ? { in: ut, onEnter: Ct, onExited: Mt } : void 0;
    return jsxRuntimeExports.jsx(Portal, {
      disablePortal: at,
      container: wt,
      children: jsxRuntimeExports.jsx(
        PopperTooltip,
        _extends(
          {
            anchorEl: rt,
            direction: ot,
            disablePortal: at,
            modifiers: ct,
            ref: nt,
            open: yt ? !St : ut,
            placement: ft,
            popperOptions: ht,
            popperRef: mt,
            slotProps: Et,
            slots: pt,
          },
          xt,
          {
            style: _extends(
              { position: "fixed", top: 0, left: 0, display: Bt },
              vt
            ),
            TransitionProps: It,
            children: it,
          }
        )
      ),
    });
  });
function useSnackbar(tt = {}) {
  const {
      autoHideDuration: et = null,
      disableWindowBlurListener: nt = !1,
      onClose: rt,
      open: it,
      resumeHideDuration: st,
    } = tt,
    ot = reactExports.useRef();
  reactExports.useEffect(() => {
    if (!it) return;
    function pt(xt) {
      xt.defaultPrevented ||
        ((xt.key === "Escape" || xt.key === "Esc") &&
          (rt == null || rt(xt, "escapeKeyDown")));
    }
    return (
      document.addEventListener("keydown", pt),
      () => {
        document.removeEventListener("keydown", pt);
      }
    );
  }, [it, rt]);
  const at = useEventCallback((pt, xt) => {
      rt == null || rt(pt, xt);
    }),
    lt = useEventCallback((pt) => {
      !rt ||
        pt == null ||
        (clearTimeout(ot.current),
        (ot.current = setTimeout(() => {
          at(null, "timeout");
        }, pt)));
    });
  reactExports.useEffect(
    () => (
      it && lt(et),
      () => {
        clearTimeout(ot.current);
      }
    ),
    [it, et, lt]
  );
  const ct = (pt) => {
      rt == null || rt(pt, "clickaway");
    },
    ut = () => {
      clearTimeout(ot.current);
    },
    ft = reactExports.useCallback(() => {
      et != null && lt(st ?? et * 0.5);
    }, [et, st, lt]),
    ht = (pt) => (xt) => {
      const St = pt.onBlur;
      St == null || St(xt), ft();
    },
    mt = (pt) => (xt) => {
      const St = pt.onFocus;
      St == null || St(xt), ut();
    },
    vt = (pt) => (xt) => {
      const St = pt.onMouseEnter;
      St == null || St(xt), ut();
    },
    yt = (pt) => (xt) => {
      const St = pt.onMouseLeave;
      St == null || St(xt), ft();
    };
  return (
    reactExports.useEffect(() => {
      if (!nt && it)
        return (
          window.addEventListener("focus", ft),
          window.addEventListener("blur", ut),
          () => {
            window.removeEventListener("focus", ft),
              window.removeEventListener("blur", ut);
          }
        );
    }, [nt, ft, it]),
    {
      getRootProps: (pt = {}) => {
        const xt = _extends(
          {},
          extractEventHandlers(tt),
          extractEventHandlers(pt)
        );
        return _extends({ role: "presentation" }, pt, xt, {
          onBlur: ht(xt),
          onFocus: mt(xt),
          onMouseEnter: vt(xt),
          onMouseLeave: yt(xt),
        });
      },
      onClickAway: ct,
    }
  );
}
const _excluded$a = [
    "anchorEl",
    "component",
    "components",
    "componentsProps",
    "container",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "transition",
    "slots",
    "slotProps",
  ],
  PopperRoot = styled$2(Popper$2, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (tt, et) => et.root,
  })({}),
  Popper = reactExports.forwardRef(function (et, nt) {
    var rt;
    const it = useTheme$2(),
      st = useThemeProps({ props: et, name: "MuiPopper" }),
      {
        anchorEl: ot,
        component: at,
        components: lt,
        componentsProps: ct,
        container: ut,
        disablePortal: ft,
        keepMounted: ht,
        modifiers: mt,
        open: vt,
        placement: yt,
        popperOptions: Et,
        popperRef: pt,
        transition: xt,
        slots: St,
        slotProps: At,
      } = st,
      Ct = _objectWithoutPropertiesLoose(st, _excluded$a),
      Mt =
        (rt = St == null ? void 0 : St.root) != null
          ? rt
          : lt == null
          ? void 0
          : lt.Root,
      wt = _extends(
        {
          anchorEl: ot,
          container: ut,
          disablePortal: ft,
          keepMounted: ht,
          modifiers: mt,
          open: vt,
          placement: yt,
          popperOptions: Et,
          popperRef: pt,
          transition: xt,
        },
        Ct
      );
    return jsxRuntimeExports.jsx(
      PopperRoot,
      _extends(
        {
          as: at,
          direction: it == null ? void 0 : it.direction,
          slots: { root: Mt },
          slotProps: At ?? ct,
        },
        wt,
        { ref: nt }
      )
    );
  }),
  Popper$1 = Popper,
  FormControlContext = reactExports.createContext(void 0),
  FormControlContext$1 = FormControlContext;
function useFormControl() {
  return reactExports.useContext(FormControlContext$1);
}
function getButtonUtilityClass(tt) {
  return generateUtilityClass("MuiButton", tt);
}
const buttonClasses = generateUtilityClasses("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
  ]),
  buttonClasses$1 = buttonClasses,
  ButtonGroupContext = reactExports.createContext({}),
  ButtonGroupContext$1 = ButtonGroupContext,
  ButtonGroupButtonContext = reactExports.createContext(void 0),
  ButtonGroupButtonContext$1 = ButtonGroupButtonContext,
  _excluded$9 = [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "size",
    "startIcon",
    "type",
    "variant",
  ],
  useUtilityClasses$8 = (tt) => {
    const {
        color: et,
        disableElevation: nt,
        fullWidth: rt,
        size: it,
        variant: st,
        classes: ot,
      } = tt,
      at = {
        root: [
          "root",
          st,
          `${st}${capitalize(et)}`,
          `size${capitalize(it)}`,
          `${st}Size${capitalize(it)}`,
          et === "inherit" && "colorInherit",
          nt && "disableElevation",
          rt && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize(it)}`],
        endIcon: ["endIcon", `iconSize${capitalize(it)}`],
      },
      lt = composeClasses(at, getButtonUtilityClass, ot);
    return _extends({}, ot, lt);
  },
  commonIconStyles = (tt) =>
    _extends(
      {},
      tt.size === "small" && { "& > *:nth-of-type(1)": { fontSize: 18 } },
      tt.size === "medium" && { "& > *:nth-of-type(1)": { fontSize: 20 } },
      tt.size === "large" && { "& > *:nth-of-type(1)": { fontSize: 22 } }
    ),
  ButtonRoot = styled$2(ButtonBase$1, {
    shouldForwardProp: (tt) => rootShouldForwardProp(tt) || tt === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        et[nt.variant],
        et[`${nt.variant}${capitalize(nt.color)}`],
        et[`size${capitalize(nt.size)}`],
        et[`${nt.variant}Size${capitalize(nt.size)}`],
        nt.color === "inherit" && et.colorInherit,
        nt.disableElevation && et.disableElevation,
        nt.fullWidth && et.fullWidth,
      ];
    },
  })(
    ({ theme: tt, ownerState: et }) => {
      var nt, rt;
      const it =
          tt.palette.mode === "light"
            ? tt.palette.grey[300]
            : tt.palette.grey[800],
        st =
          tt.palette.mode === "light"
            ? tt.palette.grey.A100
            : tt.palette.grey[700];
      return _extends(
        {},
        tt.typography.button,
        {
          minWidth: 64,
          padding: "6px 16px",
          borderRadius: (tt.vars || tt).shape.borderRadius,
          transition: tt.transitions.create(
            ["background-color", "box-shadow", "border-color", "color"],
            { duration: tt.transitions.duration.short }
          ),
          "&:hover": _extends(
            {
              textDecoration: "none",
              backgroundColor: tt.vars
                ? `rgba(${tt.vars.palette.text.primaryChannel} / ${tt.vars.palette.action.hoverOpacity})`
                : alpha(
                    tt.palette.text.primary,
                    tt.palette.action.hoverOpacity
                  ),
              "@media (hover: none)": { backgroundColor: "transparent" },
            },
            et.variant === "text" &&
              et.color !== "inherit" && {
                backgroundColor: tt.vars
                  ? `rgba(${tt.vars.palette[et.color].mainChannel} / ${
                      tt.vars.palette.action.hoverOpacity
                    })`
                  : alpha(
                      tt.palette[et.color].main,
                      tt.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            et.variant === "outlined" &&
              et.color !== "inherit" && {
                border: `1px solid ${(tt.vars || tt).palette[et.color].main}`,
                backgroundColor: tt.vars
                  ? `rgba(${tt.vars.palette[et.color].mainChannel} / ${
                      tt.vars.palette.action.hoverOpacity
                    })`
                  : alpha(
                      tt.palette[et.color].main,
                      tt.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": { backgroundColor: "transparent" },
              },
            et.variant === "contained" && {
              backgroundColor: tt.vars
                ? tt.vars.palette.Button.inheritContainedHoverBg
                : st,
              boxShadow: (tt.vars || tt).shadows[4],
              "@media (hover: none)": {
                boxShadow: (tt.vars || tt).shadows[2],
                backgroundColor: (tt.vars || tt).palette.grey[300],
              },
            },
            et.variant === "contained" &&
              et.color !== "inherit" && {
                backgroundColor: (tt.vars || tt).palette[et.color].dark,
                "@media (hover: none)": {
                  backgroundColor: (tt.vars || tt).palette[et.color].main,
                },
              }
          ),
          "&:active": _extends(
            {},
            et.variant === "contained" && {
              boxShadow: (tt.vars || tt).shadows[8],
            }
          ),
          [`&.${buttonClasses$1.focusVisible}`]: _extends(
            {},
            et.variant === "contained" && {
              boxShadow: (tt.vars || tt).shadows[6],
            }
          ),
          [`&.${buttonClasses$1.disabled}`]: _extends(
            { color: (tt.vars || tt).palette.action.disabled },
            et.variant === "outlined" && {
              border: `1px solid ${
                (tt.vars || tt).palette.action.disabledBackground
              }`,
            },
            et.variant === "contained" && {
              color: (tt.vars || tt).palette.action.disabled,
              boxShadow: (tt.vars || tt).shadows[0],
              backgroundColor: (tt.vars || tt).palette.action
                .disabledBackground,
            }
          ),
        },
        et.variant === "text" && { padding: "6px 8px" },
        et.variant === "text" &&
          et.color !== "inherit" && {
            color: (tt.vars || tt).palette[et.color].main,
          },
        et.variant === "outlined" && {
          padding: "5px 15px",
          border: "1px solid currentColor",
        },
        et.variant === "outlined" &&
          et.color !== "inherit" && {
            color: (tt.vars || tt).palette[et.color].main,
            border: tt.vars
              ? `1px solid rgba(${tt.vars.palette[et.color].mainChannel} / 0.5)`
              : `1px solid ${alpha(tt.palette[et.color].main, 0.5)}`,
          },
        et.variant === "contained" && {
          color: tt.vars
            ? tt.vars.palette.text.primary
            : (nt = (rt = tt.palette).getContrastText) == null
            ? void 0
            : nt.call(rt, tt.palette.grey[300]),
          backgroundColor: tt.vars
            ? tt.vars.palette.Button.inheritContainedBg
            : it,
          boxShadow: (tt.vars || tt).shadows[2],
        },
        et.variant === "contained" &&
          et.color !== "inherit" && {
            color: (tt.vars || tt).palette[et.color].contrastText,
            backgroundColor: (tt.vars || tt).palette[et.color].main,
          },
        et.color === "inherit" && {
          color: "inherit",
          borderColor: "currentColor",
        },
        et.size === "small" &&
          et.variant === "text" && {
            padding: "4px 5px",
            fontSize: tt.typography.pxToRem(13),
          },
        et.size === "large" &&
          et.variant === "text" && {
            padding: "8px 11px",
            fontSize: tt.typography.pxToRem(15),
          },
        et.size === "small" &&
          et.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: tt.typography.pxToRem(13),
          },
        et.size === "large" &&
          et.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: tt.typography.pxToRem(15),
          },
        et.size === "small" &&
          et.variant === "contained" && {
            padding: "4px 10px",
            fontSize: tt.typography.pxToRem(13),
          },
        et.size === "large" &&
          et.variant === "contained" && {
            padding: "8px 22px",
            fontSize: tt.typography.pxToRem(15),
          },
        et.fullWidth && { width: "100%" }
      );
    },
    ({ ownerState: tt }) =>
      tt.disableElevation && {
        boxShadow: "none",
        "&:hover": { boxShadow: "none" },
        [`&.${buttonClasses$1.focusVisible}`]: { boxShadow: "none" },
        "&:active": { boxShadow: "none" },
        [`&.${buttonClasses$1.disabled}`]: { boxShadow: "none" },
      }
  ),
  ButtonStartIcon = styled$2("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [et.startIcon, et[`iconSize${capitalize(nt.size)}`]];
    },
  })(({ ownerState: tt }) =>
    _extends(
      { display: "inherit", marginRight: 8, marginLeft: -4 },
      tt.size === "small" && { marginLeft: -2 },
      commonIconStyles(tt)
    )
  ),
  ButtonEndIcon = styled$2("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [et.endIcon, et[`iconSize${capitalize(nt.size)}`]];
    },
  })(({ ownerState: tt }) =>
    _extends(
      { display: "inherit", marginRight: -4, marginLeft: 8 },
      tt.size === "small" && { marginRight: -2 },
      commonIconStyles(tt)
    )
  ),
  Button = reactExports.forwardRef(function (et, nt) {
    const rt = reactExports.useContext(ButtonGroupContext$1),
      it = reactExports.useContext(ButtonGroupButtonContext$1),
      st = resolveProps(rt, et),
      ot = useThemeProps({ props: st, name: "MuiButton" }),
      {
        children: at,
        color: lt = "primary",
        component: ct = "button",
        className: ut,
        disabled: ft = !1,
        disableElevation: ht = !1,
        disableFocusRipple: mt = !1,
        endIcon: vt,
        focusVisibleClassName: yt,
        fullWidth: Et = !1,
        size: pt = "medium",
        startIcon: xt,
        type: St,
        variant: At = "text",
      } = ot,
      Ct = _objectWithoutPropertiesLoose(ot, _excluded$9),
      Mt = _extends({}, ot, {
        color: lt,
        component: ct,
        disabled: ft,
        disableElevation: ht,
        disableFocusRipple: mt,
        fullWidth: Et,
        size: pt,
        type: St,
        variant: At,
      }),
      wt = useUtilityClasses$8(Mt),
      Bt =
        xt &&
        jsxRuntimeExports.jsx(ButtonStartIcon, {
          className: wt.startIcon,
          ownerState: Mt,
          children: xt,
        }),
      It =
        vt &&
        jsxRuntimeExports.jsx(ButtonEndIcon, {
          className: wt.endIcon,
          ownerState: Mt,
          children: vt,
        }),
      Ft = it || "";
    return jsxRuntimeExports.jsxs(
      ButtonRoot,
      _extends(
        {
          ownerState: Mt,
          className: clsx(rt.className, wt.root, ut, Ft),
          component: ct,
          disabled: ft,
          focusRipple: !mt,
          focusVisibleClassName: clsx(wt.focusVisible, yt),
          ref: nt,
          type: St,
        },
        Ct,
        { classes: wt, children: [Bt, at, It] }
      )
    );
  }),
  Button$1 = Button;
function getCardUtilityClass(tt) {
  return generateUtilityClass("MuiCard", tt);
}
generateUtilityClasses("MuiCard", ["root"]);
const _excluded$8 = ["className", "raised"],
  useUtilityClasses$7 = (tt) => {
    const { classes: et } = tt;
    return composeClasses({ root: ["root"] }, getCardUtilityClass, et);
  },
  CardRoot = styled$2(Paper$1, {
    name: "MuiCard",
    slot: "Root",
    overridesResolver: (tt, et) => et.root,
  })(() => ({ overflow: "hidden" })),
  Card = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiCard" }),
      { className: it, raised: st = !1 } = rt,
      ot = _objectWithoutPropertiesLoose(rt, _excluded$8),
      at = _extends({}, rt, { raised: st }),
      lt = useUtilityClasses$7(at);
    return jsxRuntimeExports.jsx(
      CardRoot,
      _extends(
        {
          className: clsx(lt.root, it),
          elevation: st ? 8 : void 0,
          ref: nt,
          ownerState: at,
        },
        ot
      )
    );
  }),
  Card$1 = Card;
function getCardActionsUtilityClass(tt) {
  return generateUtilityClass("MuiCardActions", tt);
}
generateUtilityClasses("MuiCardActions", ["root", "spacing"]);
const _excluded$7 = ["disableSpacing", "className"],
  useUtilityClasses$6 = (tt) => {
    const { classes: et, disableSpacing: nt } = tt;
    return composeClasses(
      { root: ["root", !nt && "spacing"] },
      getCardActionsUtilityClass,
      et
    );
  },
  CardActionsRoot = styled$2("div", {
    name: "MuiCardActions",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [et.root, !nt.disableSpacing && et.spacing];
    },
  })(({ ownerState: tt }) =>
    _extends(
      { display: "flex", alignItems: "center", padding: 8 },
      !tt.disableSpacing && { "& > :not(:first-of-type)": { marginLeft: 8 } }
    )
  ),
  CardActions = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiCardActions" }),
      { disableSpacing: it = !1, className: st } = rt,
      ot = _objectWithoutPropertiesLoose(rt, _excluded$7),
      at = _extends({}, rt, { disableSpacing: it }),
      lt = useUtilityClasses$6(at);
    return jsxRuntimeExports.jsx(
      CardActionsRoot,
      _extends({ className: clsx(lt.root, st), ownerState: at, ref: nt }, ot)
    );
  }),
  CardActions$1 = CardActions;
function getCardContentUtilityClass(tt) {
  return generateUtilityClass("MuiCardContent", tt);
}
generateUtilityClasses("MuiCardContent", ["root"]);
const _excluded$6 = ["className", "component"],
  useUtilityClasses$5 = (tt) => {
    const { classes: et } = tt;
    return composeClasses({ root: ["root"] }, getCardContentUtilityClass, et);
  },
  CardContentRoot = styled$2("div", {
    name: "MuiCardContent",
    slot: "Root",
    overridesResolver: (tt, et) => et.root,
  })(() => ({ padding: 16, "&:last-child": { paddingBottom: 24 } })),
  CardContent = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiCardContent" }),
      { className: it, component: st = "div" } = rt,
      ot = _objectWithoutPropertiesLoose(rt, _excluded$6),
      at = _extends({}, rt, { component: st }),
      lt = useUtilityClasses$5(at);
    return jsxRuntimeExports.jsx(
      CardContentRoot,
      _extends(
        { as: st, className: clsx(lt.root, it), ownerState: at, ref: nt },
        ot
      )
    );
  }),
  CardContent$1 = CardContent;
function getSwitchBaseUtilityClass(tt) {
  return generateUtilityClass("PrivateSwitchBase", tt);
}
generateUtilityClasses("PrivateSwitchBase", [
  "root",
  "checked",
  "disabled",
  "input",
  "edgeStart",
  "edgeEnd",
]);
const _excluded$5 = [
    "autoFocus",
    "checked",
    "checkedIcon",
    "className",
    "defaultChecked",
    "disabled",
    "disableFocusRipple",
    "edge",
    "icon",
    "id",
    "inputProps",
    "inputRef",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "readOnly",
    "required",
    "tabIndex",
    "type",
    "value",
  ],
  useUtilityClasses$4 = (tt) => {
    const { classes: et, checked: nt, disabled: rt, edge: it } = tt,
      st = {
        root: [
          "root",
          nt && "checked",
          rt && "disabled",
          it && `edge${capitalize(it)}`,
        ],
        input: ["input"],
      };
    return composeClasses(st, getSwitchBaseUtilityClass, et);
  },
  SwitchBaseRoot = styled$2(ButtonBase$1)(({ ownerState: tt }) =>
    _extends(
      { padding: 9, borderRadius: "50%" },
      tt.edge === "start" && { marginLeft: tt.size === "small" ? -3 : -12 },
      tt.edge === "end" && { marginRight: tt.size === "small" ? -3 : -12 }
    )
  ),
  SwitchBaseInput = styled$2("input", {
    shouldForwardProp: rootShouldForwardProp,
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1,
  }),
  SwitchBase = reactExports.forwardRef(function (et, nt) {
    const {
        autoFocus: rt,
        checked: it,
        checkedIcon: st,
        className: ot,
        defaultChecked: at,
        disabled: lt,
        disableFocusRipple: ct = !1,
        edge: ut = !1,
        icon: ft,
        id: ht,
        inputProps: mt,
        inputRef: vt,
        name: yt,
        onBlur: Et,
        onChange: pt,
        onFocus: xt,
        readOnly: St,
        required: At = !1,
        tabIndex: Ct,
        type: Mt,
        value: wt,
      } = et,
      Bt = _objectWithoutPropertiesLoose(et, _excluded$5),
      [It, Ft] = useControlled({
        controlled: it,
        default: !!at,
        name: "SwitchBase",
        state: "checked",
      }),
      Vt = useFormControl(),
      $t = (Rt) => {
        xt && xt(Rt), Vt && Vt.onFocus && Vt.onFocus(Rt);
      },
      Kt = (Rt) => {
        Et && Et(Rt), Vt && Vt.onBlur && Vt.onBlur(Rt);
      },
      Ht = (Rt) => {
        if (Rt.nativeEvent.defaultPrevented) return;
        const Nt = Rt.target.checked;
        Ft(Nt), pt && pt(Rt, Nt);
      };
    let Wt = lt;
    Vt && typeof Wt > "u" && (Wt = Vt.disabled);
    const kt = Mt === "checkbox" || Mt === "radio",
      Gt = _extends({}, et, {
        checked: It,
        disabled: Wt,
        disableFocusRipple: ct,
        edge: ut,
      }),
      Pt = useUtilityClasses$4(Gt);
    return jsxRuntimeExports.jsxs(
      SwitchBaseRoot,
      _extends(
        {
          component: "span",
          className: clsx(Pt.root, ot),
          centerRipple: !0,
          focusRipple: !ct,
          disabled: Wt,
          tabIndex: null,
          role: void 0,
          onFocus: $t,
          onBlur: Kt,
          ownerState: Gt,
          ref: nt,
        },
        Bt,
        {
          children: [
            jsxRuntimeExports.jsx(
              SwitchBaseInput,
              _extends(
                {
                  autoFocus: rt,
                  checked: it,
                  defaultChecked: at,
                  className: Pt.input,
                  disabled: Wt,
                  id: kt ? ht : void 0,
                  name: yt,
                  onChange: Ht,
                  readOnly: St,
                  ref: vt,
                  required: At,
                  ownerState: Gt,
                  tabIndex: Ct,
                  type: Mt,
                },
                Mt === "checkbox" && wt === void 0 ? {} : { value: wt },
                mt
              )
            ),
            It ? st : ft,
          ],
        }
      )
    );
  }),
  SwitchBase$1 = SwitchBase,
  _excluded$4 = [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    "TransitionComponent",
  ];
function getScale(tt) {
  return `scale(${tt}, ${tt ** 2})`;
}
const styles = {
    entering: { opacity: 1, transform: getScale(1) },
    entered: { opacity: 1, transform: "none" },
  },
  isWebKit154 =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  Grow = reactExports.forwardRef(function (et, nt) {
    const {
        addEndListener: rt,
        appear: it = !0,
        children: st,
        easing: ot,
        in: at,
        onEnter: lt,
        onEntered: ct,
        onEntering: ut,
        onExit: ft,
        onExited: ht,
        onExiting: mt,
        style: vt,
        timeout: yt = "auto",
        TransitionComponent: Et = Transition$1,
      } = et,
      pt = _objectWithoutPropertiesLoose(et, _excluded$4),
      xt = reactExports.useRef(),
      St = reactExports.useRef(),
      At = useTheme(),
      Ct = reactExports.useRef(null),
      Mt = useForkRef(Ct, st.ref, nt),
      wt = (Wt) => (kt) => {
        if (Wt) {
          const Gt = Ct.current;
          kt === void 0 ? Wt(Gt) : Wt(Gt, kt);
        }
      },
      Bt = wt(ut),
      It = wt((Wt, kt) => {
        reflow(Wt);
        const {
          duration: Gt,
          delay: Pt,
          easing: Rt,
        } = getTransitionProps(
          { style: vt, timeout: yt, easing: ot },
          { mode: "enter" }
        );
        let Nt;
        yt === "auto"
          ? ((Nt = At.transitions.getAutoHeightDuration(Wt.clientHeight)),
            (St.current = Nt))
          : (Nt = Gt),
          (Wt.style.transition = [
            At.transitions.create("opacity", { duration: Nt, delay: Pt }),
            At.transitions.create("transform", {
              duration: isWebKit154 ? Nt : Nt * 0.666,
              delay: Pt,
              easing: Rt,
            }),
          ].join(",")),
          lt && lt(Wt, kt);
      }),
      Ft = wt(ct),
      Vt = wt(mt),
      $t = wt((Wt) => {
        const {
          duration: kt,
          delay: Gt,
          easing: Pt,
        } = getTransitionProps(
          { style: vt, timeout: yt, easing: ot },
          { mode: "exit" }
        );
        let Rt;
        yt === "auto"
          ? ((Rt = At.transitions.getAutoHeightDuration(Wt.clientHeight)),
            (St.current = Rt))
          : (Rt = kt),
          (Wt.style.transition = [
            At.transitions.create("opacity", { duration: Rt, delay: Gt }),
            At.transitions.create("transform", {
              duration: isWebKit154 ? Rt : Rt * 0.666,
              delay: isWebKit154 ? Gt : Gt || Rt * 0.333,
              easing: Pt,
            }),
          ].join(",")),
          (Wt.style.opacity = 0),
          (Wt.style.transform = getScale(0.75)),
          ft && ft(Wt);
      }),
      Kt = wt(ht),
      Ht = (Wt) => {
        yt === "auto" && (xt.current = setTimeout(Wt, St.current || 0)),
          rt && rt(Ct.current, Wt);
      };
    return (
      reactExports.useEffect(
        () => () => {
          clearTimeout(xt.current);
        },
        []
      ),
      jsxRuntimeExports.jsx(
        Et,
        _extends(
          {
            appear: it,
            in: at,
            nodeRef: Ct,
            onEnter: It,
            onEntered: Ft,
            onEntering: Bt,
            onExit: $t,
            onExited: Kt,
            onExiting: Vt,
            addEndListener: Ht,
            timeout: yt === "auto" ? null : yt,
          },
          pt,
          {
            children: (Wt, kt) =>
              reactExports.cloneElement(
                st,
                _extends(
                  {
                    style: _extends(
                      {
                        opacity: 0,
                        transform: getScale(0.75),
                        visibility: Wt === "exited" && !at ? "hidden" : void 0,
                      },
                      styles[Wt],
                      vt,
                      st.props.style
                    ),
                    ref: Mt,
                  },
                  kt
                )
              ),
          }
        )
      )
    );
  });
Grow.muiSupportAuto = !0;
const Grow$1 = Grow,
  RadioButtonUncheckedIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",
    }),
    "RadioButtonUnchecked"
  ),
  RadioButtonCheckedIcon = createSvgIcon(
    jsxRuntimeExports.jsx("path", {
      d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z",
    }),
    "RadioButtonChecked"
  ),
  RadioButtonIconRoot = styled$2("span", {
    shouldForwardProp: rootShouldForwardProp,
  })({ position: "relative", display: "flex" }),
  RadioButtonIconBackground = styled$2(RadioButtonUncheckedIcon)({
    transform: "scale(1)",
  }),
  RadioButtonIconDot = styled$2(RadioButtonCheckedIcon)(
    ({ theme: tt, ownerState: et }) =>
      _extends(
        {
          left: 0,
          position: "absolute",
          transform: "scale(0)",
          transition: tt.transitions.create("transform", {
            easing: tt.transitions.easing.easeIn,
            duration: tt.transitions.duration.shortest,
          }),
        },
        et.checked && {
          transform: "scale(1)",
          transition: tt.transitions.create("transform", {
            easing: tt.transitions.easing.easeOut,
            duration: tt.transitions.duration.shortest,
          }),
        }
      )
  );
function RadioButtonIcon(tt) {
  const { checked: et = !1, classes: nt = {}, fontSize: rt } = tt,
    it = _extends({}, tt, { checked: et });
  return jsxRuntimeExports.jsxs(RadioButtonIconRoot, {
    className: nt.root,
    ownerState: it,
    children: [
      jsxRuntimeExports.jsx(RadioButtonIconBackground, {
        fontSize: rt,
        className: nt.background,
        ownerState: it,
      }),
      jsxRuntimeExports.jsx(RadioButtonIconDot, {
        fontSize: rt,
        className: nt.dot,
        ownerState: it,
      }),
    ],
  });
}
const RadioGroupContext = reactExports.createContext(void 0),
  RadioGroupContext$1 = RadioGroupContext;
function useRadioGroup() {
  return reactExports.useContext(RadioGroupContext$1);
}
function getRadioUtilityClass(tt) {
  return generateUtilityClass("MuiRadio", tt);
}
const radioClasses = generateUtilityClasses("MuiRadio", [
    "root",
    "checked",
    "disabled",
    "colorPrimary",
    "colorSecondary",
    "sizeSmall",
  ]),
  radioClasses$1 = radioClasses,
  _excluded$3 = [
    "checked",
    "checkedIcon",
    "color",
    "icon",
    "name",
    "onChange",
    "size",
    "className",
  ],
  useUtilityClasses$3 = (tt) => {
    const { classes: et, color: nt, size: rt } = tt,
      it = {
        root: [
          "root",
          `color${capitalize(nt)}`,
          rt !== "medium" && `size${capitalize(rt)}`,
        ],
      };
    return _extends({}, et, composeClasses(it, getRadioUtilityClass, et));
  },
  RadioRoot = styled$2(SwitchBase$1, {
    shouldForwardProp: (tt) => rootShouldForwardProp(tt) || tt === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        nt.size !== "medium" && et[`size${capitalize(nt.size)}`],
        et[`color${capitalize(nt.color)}`],
      ];
    },
  })(({ theme: tt, ownerState: et }) =>
    _extends(
      { color: (tt.vars || tt).palette.text.secondary },
      !et.disableRipple && {
        "&:hover": {
          backgroundColor: tt.vars
            ? `rgba(${
                et.color === "default"
                  ? tt.vars.palette.action.activeChannel
                  : tt.vars.palette[et.color].mainChannel
              } / ${tt.vars.palette.action.hoverOpacity})`
            : alpha(
                et.color === "default"
                  ? tt.palette.action.active
                  : tt.palette[et.color].main,
                tt.palette.action.hoverOpacity
              ),
          "@media (hover: none)": { backgroundColor: "transparent" },
        },
      },
      et.color !== "default" && {
        [`&.${radioClasses$1.checked}`]: {
          color: (tt.vars || tt).palette[et.color].main,
        },
      },
      {
        [`&.${radioClasses$1.disabled}`]: {
          color: (tt.vars || tt).palette.action.disabled,
        },
      }
    )
  );
function areEqualValues(tt, et) {
  return typeof et == "object" && et !== null
    ? tt === et
    : String(tt) === String(et);
}
const defaultCheckedIcon = jsxRuntimeExports.jsx(RadioButtonIcon, {
    checked: !0,
  }),
  defaultIcon = jsxRuntimeExports.jsx(RadioButtonIcon, {}),
  Radio = reactExports.forwardRef(function (et, nt) {
    var rt, it;
    const st = useThemeProps({ props: et, name: "MuiRadio" }),
      {
        checked: ot,
        checkedIcon: at = defaultCheckedIcon,
        color: lt = "primary",
        icon: ct = defaultIcon,
        name: ut,
        onChange: ft,
        size: ht = "medium",
        className: mt,
      } = st,
      vt = _objectWithoutPropertiesLoose(st, _excluded$3),
      yt = _extends({}, st, { color: lt, size: ht }),
      Et = useUtilityClasses$3(yt),
      pt = useRadioGroup();
    let xt = ot;
    const St = createChainedFunction(ft, pt && pt.onChange);
    let At = ut;
    return (
      pt &&
        (typeof xt > "u" && (xt = areEqualValues(pt.value, st.value)),
        typeof At > "u" && (At = pt.name)),
      jsxRuntimeExports.jsx(
        RadioRoot,
        _extends(
          {
            type: "radio",
            icon: reactExports.cloneElement(ct, {
              fontSize: (rt = defaultIcon.props.fontSize) != null ? rt : ht,
            }),
            checkedIcon: reactExports.cloneElement(at, {
              fontSize:
                (it = defaultCheckedIcon.props.fontSize) != null ? it : ht,
            }),
            ownerState: yt,
            classes: Et,
            name: At,
            checked: xt,
            onChange: St,
            ref: nt,
            className: clsx(Et.root, mt),
          },
          vt
        )
      )
    );
  }),
  Radio$1 = Radio;
function getSnackbarContentUtilityClass(tt) {
  return generateUtilityClass("MuiSnackbarContent", tt);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const _excluded$2 = ["action", "className", "message", "role"],
  useUtilityClasses$2 = (tt) => {
    const { classes: et } = tt;
    return composeClasses(
      { root: ["root"], action: ["action"], message: ["message"] },
      getSnackbarContentUtilityClass,
      et
    );
  },
  SnackbarContentRoot = styled$2(Paper$1, {
    name: "MuiSnackbarContent",
    slot: "Root",
    overridesResolver: (tt, et) => et.root,
  })(({ theme: tt }) => {
    const et = tt.palette.mode === "light" ? 0.8 : 0.98,
      nt = emphasize(tt.palette.background.default, et);
    return _extends({}, tt.typography.body2, {
      color: tt.vars
        ? tt.vars.palette.SnackbarContent.color
        : tt.palette.getContrastText(nt),
      backgroundColor: tt.vars ? tt.vars.palette.SnackbarContent.bg : nt,
      display: "flex",
      alignItems: "center",
      flexWrap: "wrap",
      padding: "6px 16px",
      borderRadius: (tt.vars || tt).shape.borderRadius,
      flexGrow: 1,
      [tt.breakpoints.up("sm")]: { flexGrow: "initial", minWidth: 288 },
    });
  }),
  SnackbarContentMessage = styled$2("div", {
    name: "MuiSnackbarContent",
    slot: "Message",
    overridesResolver: (tt, et) => et.message,
  })({ padding: "8px 0" }),
  SnackbarContentAction = styled$2("div", {
    name: "MuiSnackbarContent",
    slot: "Action",
    overridesResolver: (tt, et) => et.action,
  })({
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: 16,
    marginRight: -8,
  }),
  SnackbarContent = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiSnackbarContent" }),
      { action: it, className: st, message: ot, role: at = "alert" } = rt,
      lt = _objectWithoutPropertiesLoose(rt, _excluded$2),
      ct = rt,
      ut = useUtilityClasses$2(ct);
    return jsxRuntimeExports.jsxs(
      SnackbarContentRoot,
      _extends(
        {
          role: at,
          square: !0,
          elevation: 6,
          className: clsx(ut.root, st),
          ownerState: ct,
          ref: nt,
        },
        lt,
        {
          children: [
            jsxRuntimeExports.jsx(SnackbarContentMessage, {
              className: ut.message,
              ownerState: ct,
              children: ot,
            }),
            it
              ? jsxRuntimeExports.jsx(SnackbarContentAction, {
                  className: ut.action,
                  ownerState: ct,
                  children: it,
                })
              : null,
          ],
        }
      )
    );
  }),
  SnackbarContent$1 = SnackbarContent;
function getSnackbarUtilityClass(tt) {
  return generateUtilityClass("MuiSnackbar", tt);
}
generateUtilityClasses("MuiSnackbar", [
  "root",
  "anchorOriginTopCenter",
  "anchorOriginBottomCenter",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
]);
const _excluded$1 = ["onEnter", "onExited"],
  _excluded2 = [
    "action",
    "anchorOrigin",
    "autoHideDuration",
    "children",
    "className",
    "ClickAwayListenerProps",
    "ContentProps",
    "disableWindowBlurListener",
    "message",
    "onBlur",
    "onClose",
    "onFocus",
    "onMouseEnter",
    "onMouseLeave",
    "open",
    "resumeHideDuration",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps",
  ],
  useUtilityClasses$1 = (tt) => {
    const { classes: et, anchorOrigin: nt } = tt,
      rt = {
        root: [
          "root",
          `anchorOrigin${capitalize(nt.vertical)}${capitalize(nt.horizontal)}`,
        ],
      };
    return composeClasses(rt, getSnackbarUtilityClass, et);
  },
  SnackbarRoot = styled$2("div", {
    name: "MuiSnackbar",
    slot: "Root",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.root,
        et[
          `anchorOrigin${capitalize(nt.anchorOrigin.vertical)}${capitalize(
            nt.anchorOrigin.horizontal
          )}`
        ],
      ];
    },
  })(({ theme: tt, ownerState: et }) => {
    const nt = { left: "50%", right: "auto", transform: "translateX(-50%)" };
    return _extends(
      {
        zIndex: (tt.vars || tt).zIndex.snackbar,
        position: "fixed",
        display: "flex",
        left: 8,
        right: 8,
        justifyContent: "center",
        alignItems: "center",
      },
      et.anchorOrigin.vertical === "top" ? { top: 8 } : { bottom: 8 },
      et.anchorOrigin.horizontal === "left" && { justifyContent: "flex-start" },
      et.anchorOrigin.horizontal === "right" && { justifyContent: "flex-end" },
      {
        [tt.breakpoints.up("sm")]: _extends(
          {},
          et.anchorOrigin.vertical === "top" ? { top: 24 } : { bottom: 24 },
          et.anchorOrigin.horizontal === "center" && nt,
          et.anchorOrigin.horizontal === "left" && { left: 24, right: "auto" },
          et.anchorOrigin.horizontal === "right" && { right: 24, left: "auto" }
        ),
      }
    );
  }),
  Snackbar = reactExports.forwardRef(function (et, nt) {
    const rt = useThemeProps({ props: et, name: "MuiSnackbar" }),
      it = useTheme(),
      st = {
        enter: it.transitions.duration.enteringScreen,
        exit: it.transitions.duration.leavingScreen,
      },
      {
        action: ot,
        anchorOrigin: { vertical: at, horizontal: lt } = {
          vertical: "bottom",
          horizontal: "left",
        },
        autoHideDuration: ct = null,
        children: ut,
        className: ft,
        ClickAwayListenerProps: ht,
        ContentProps: mt,
        disableWindowBlurListener: vt = !1,
        message: yt,
        open: Et,
        TransitionComponent: pt = Grow$1,
        transitionDuration: xt = st,
        TransitionProps: { onEnter: St, onExited: At } = {},
      } = rt,
      Ct = _objectWithoutPropertiesLoose(rt.TransitionProps, _excluded$1),
      Mt = _objectWithoutPropertiesLoose(rt, _excluded2),
      wt = _extends({}, rt, {
        anchorOrigin: { vertical: at, horizontal: lt },
        autoHideDuration: ct,
        disableWindowBlurListener: vt,
        TransitionComponent: pt,
        transitionDuration: xt,
      }),
      Bt = useUtilityClasses$1(wt),
      { getRootProps: It, onClickAway: Ft } = useSnackbar(_extends({}, wt)),
      [Vt, $t] = reactExports.useState(!0),
      Kt = useSlotProps({
        elementType: SnackbarRoot,
        getSlotProps: It,
        externalForwardedProps: Mt,
        ownerState: wt,
        additionalProps: { ref: nt },
        className: [Bt.root, ft],
      }),
      Ht = (kt) => {
        $t(!0), At && At(kt);
      },
      Wt = (kt, Gt) => {
        $t(!1), St && St(kt, Gt);
      };
    return !Et && Vt
      ? null
      : jsxRuntimeExports.jsx(
          ClickAwayListener,
          _extends({ onClickAway: Ft }, ht, {
            children: jsxRuntimeExports.jsx(
              SnackbarRoot,
              _extends({}, Kt, {
                children: jsxRuntimeExports.jsx(
                  pt,
                  _extends(
                    {
                      appear: !0,
                      in: Et,
                      timeout: xt,
                      direction: at === "top" ? "down" : "up",
                      onEnter: Wt,
                      onExited: Ht,
                    },
                    Ct,
                    {
                      children:
                        ut ||
                        jsxRuntimeExports.jsx(
                          SnackbarContent$1,
                          _extends({ message: yt, action: ot }, mt)
                        ),
                    }
                  )
                ),
              })
            ),
          })
        );
  }),
  Snackbar$1 = Snackbar;
function getTooltipUtilityClass(tt) {
  return generateUtilityClass("MuiTooltip", tt);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", [
    "popper",
    "popperInteractive",
    "popperArrow",
    "popperClose",
    "tooltip",
    "tooltipArrow",
    "touch",
    "tooltipPlacementLeft",
    "tooltipPlacementRight",
    "tooltipPlacementTop",
    "tooltipPlacementBottom",
    "arrow",
  ]),
  tooltipClasses$1 = tooltipClasses,
  _excluded = [
    "arrow",
    "children",
    "classes",
    "components",
    "componentsProps",
    "describeChild",
    "disableFocusListener",
    "disableHoverListener",
    "disableInteractive",
    "disableTouchListener",
    "enterDelay",
    "enterNextDelay",
    "enterTouchDelay",
    "followCursor",
    "id",
    "leaveDelay",
    "leaveTouchDelay",
    "onClose",
    "onOpen",
    "open",
    "placement",
    "PopperComponent",
    "PopperProps",
    "slotProps",
    "slots",
    "title",
    "TransitionComponent",
    "TransitionProps",
  ];
function round(tt) {
  return Math.round(tt * 1e5) / 1e5;
}
const useUtilityClasses = (tt) => {
    const {
        classes: et,
        disableInteractive: nt,
        arrow: rt,
        touch: it,
        placement: st,
      } = tt,
      ot = {
        popper: ["popper", !nt && "popperInteractive", rt && "popperArrow"],
        tooltip: [
          "tooltip",
          rt && "tooltipArrow",
          it && "touch",
          `tooltipPlacement${capitalize(st.split("-")[0])}`,
        ],
        arrow: ["arrow"],
      };
    return composeClasses(ot, getTooltipUtilityClass, et);
  },
  TooltipPopper = styled$2(Popper$1, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.popper,
        !nt.disableInteractive && et.popperInteractive,
        nt.arrow && et.popperArrow,
        !nt.open && et.popperClose,
      ];
    },
  })(({ theme: tt, ownerState: et, open: nt }) =>
    _extends(
      { zIndex: (tt.vars || tt).zIndex.tooltip, pointerEvents: "none" },
      !et.disableInteractive && { pointerEvents: "auto" },
      !nt && { pointerEvents: "none" },
      et.arrow && {
        [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
          top: 0,
          marginTop: "-0.71em",
          "&::before": { transformOrigin: "0 100%" },
        },
        [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
          bottom: 0,
          marginBottom: "-0.71em",
          "&::before": { transformOrigin: "100% 0" },
        },
        [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]:
          _extends(
            {},
            et.isRtl
              ? { right: 0, marginRight: "-0.71em" }
              : { left: 0, marginLeft: "-0.71em" },
            {
              height: "1em",
              width: "0.71em",
              "&::before": { transformOrigin: "100% 100%" },
            }
          ),
        [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]:
          _extends(
            {},
            et.isRtl
              ? { left: 0, marginLeft: "-0.71em" }
              : { right: 0, marginRight: "-0.71em" },
            {
              height: "1em",
              width: "0.71em",
              "&::before": { transformOrigin: "0 0" },
            }
          ),
      }
    )
  ),
  TooltipTooltip = styled$2("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (tt, et) => {
      const { ownerState: nt } = tt;
      return [
        et.tooltip,
        nt.touch && et.touch,
        nt.arrow && et.tooltipArrow,
        et[`tooltipPlacement${capitalize(nt.placement.split("-")[0])}`],
      ];
    },
  })(({ theme: tt, ownerState: et }) =>
    _extends(
      {
        backgroundColor: tt.vars
          ? tt.vars.palette.Tooltip.bg
          : alpha(tt.palette.grey[700], 0.92),
        borderRadius: (tt.vars || tt).shape.borderRadius,
        color: (tt.vars || tt).palette.common.white,
        fontFamily: tt.typography.fontFamily,
        padding: "4px 8px",
        fontSize: tt.typography.pxToRem(11),
        maxWidth: 300,
        margin: 2,
        wordWrap: "break-word",
        fontWeight: tt.typography.fontWeightMedium,
      },
      et.arrow && { position: "relative", margin: 0 },
      et.touch && {
        padding: "8px 16px",
        fontSize: tt.typography.pxToRem(14),
        lineHeight: `${round(16 / 14)}em`,
        fontWeight: tt.typography.fontWeightRegular,
      },
      {
        [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]:
          _extends(
            { transformOrigin: "right center" },
            et.isRtl
              ? _extends(
                  { marginLeft: "14px" },
                  et.touch && { marginLeft: "24px" }
                )
              : _extends(
                  { marginRight: "14px" },
                  et.touch && { marginRight: "24px" }
                )
          ),
        [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]:
          _extends(
            { transformOrigin: "left center" },
            et.isRtl
              ? _extends(
                  { marginRight: "14px" },
                  et.touch && { marginRight: "24px" }
                )
              : _extends(
                  { marginLeft: "14px" },
                  et.touch && { marginLeft: "24px" }
                )
          ),
        [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]:
          _extends(
            { transformOrigin: "center bottom", marginBottom: "14px" },
            et.touch && { marginBottom: "24px" }
          ),
        [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]:
          _extends(
            { transformOrigin: "center top", marginTop: "14px" },
            et.touch && { marginTop: "24px" }
          ),
      }
    )
  ),
  TooltipArrow = styled$2("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (tt, et) => et.arrow,
  })(({ theme: tt }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: tt.vars
      ? tt.vars.palette.Tooltip.bg
      : alpha(tt.palette.grey[700], 0.9),
    "&::before": {
      content: '""',
      margin: "auto",
      display: "block",
      width: "100%",
      height: "100%",
      backgroundColor: "currentColor",
      transform: "rotate(45deg)",
    },
  }));
let hystersisOpen = !1,
  hystersisTimer = null,
  cursorPosition = { x: 0, y: 0 };
function composeEventHandler(tt, et) {
  return (nt) => {
    et && et(nt), tt(nt);
  };
}
const Tooltip = reactExports.forwardRef(function (et, nt) {
    var rt,
      it,
      st,
      ot,
      at,
      lt,
      ct,
      ut,
      ft,
      ht,
      mt,
      vt,
      yt,
      Et,
      pt,
      xt,
      St,
      At,
      Ct;
    const Mt = useThemeProps({ props: et, name: "MuiTooltip" }),
      {
        arrow: wt = !1,
        children: Bt,
        components: It = {},
        componentsProps: Ft = {},
        describeChild: Vt = !1,
        disableFocusListener: $t = !1,
        disableHoverListener: Kt = !1,
        disableInteractive: Ht = !1,
        disableTouchListener: Wt = !1,
        enterDelay: kt = 100,
        enterNextDelay: Gt = 0,
        enterTouchDelay: Pt = 700,
        followCursor: Rt = !1,
        id: Nt,
        leaveDelay: Dt = 0,
        leaveTouchDelay: zt = 1500,
        onClose: Yt,
        onOpen: qt,
        open: Zt,
        placement: Jt = "bottom",
        PopperComponent: mn,
        PopperProps: ln = {},
        slotProps: bn = {},
        slots: Bn = {},
        title: gn,
        TransitionComponent: jt = Grow$1,
        TransitionProps: yn,
      } = Mt,
      pn = _objectWithoutPropertiesLoose(Mt, _excluded),
      vn = reactExports.isValidElement(Bt)
        ? Bt
        : jsxRuntimeExports.jsx("span", { children: Bt }),
      xn = useTheme(),
      Fn = xn.direction === "rtl",
      [_n, Dn] = reactExports.useState(),
      [Tn, An] = reactExports.useState(null),
      Wn = reactExports.useRef(!1),
      Xt = Ht || Rt,
      Ut = reactExports.useRef(),
      hn = reactExports.useRef(),
      Ln = reactExports.useRef(),
      Cn = reactExports.useRef(),
      [Mn, kn] = useControlled({
        controlled: Zt,
        default: !1,
        name: "Tooltip",
        state: "open",
      });
    let Vn = Mn;
    const Kn = useId(Nt),
      Yn = reactExports.useRef(),
      ir = reactExports.useCallback(() => {
        Yn.current !== void 0 &&
          ((document.body.style.WebkitUserSelect = Yn.current),
          (Yn.current = void 0)),
          clearTimeout(Cn.current);
      }, []);
    reactExports.useEffect(
      () => () => {
        clearTimeout(Ut.current),
          clearTimeout(hn.current),
          clearTimeout(Ln.current),
          ir();
      },
      [ir]
    );
    const On = (Zn) => {
        clearTimeout(hystersisTimer),
          (hystersisOpen = !0),
          kn(!0),
          qt && !Vn && qt(Zn);
      },
      qn = useEventCallback((Zn) => {
        clearTimeout(hystersisTimer),
          (hystersisTimer = setTimeout(() => {
            hystersisOpen = !1;
          }, 800 + Dt)),
          kn(!1),
          Yt && Vn && Yt(Zn),
          clearTimeout(Ut.current),
          (Ut.current = setTimeout(() => {
            Wn.current = !1;
          }, xn.transitions.duration.shortest));
      }),
      dn = (Zn) => {
        (Wn.current && Zn.type !== "touchstart") ||
          (_n && _n.removeAttribute("title"),
          clearTimeout(hn.current),
          clearTimeout(Ln.current),
          kt || (hystersisOpen && Gt)
            ? (hn.current = setTimeout(
                () => {
                  On(Zn);
                },
                hystersisOpen ? Gt : kt
              ))
            : On(Zn));
      },
      Pn = (Zn) => {
        clearTimeout(hn.current),
          clearTimeout(Ln.current),
          (Ln.current = setTimeout(() => {
            qn(Zn);
          }, Dt));
      },
      {
        isFocusVisibleRef: Hn,
        onBlur: Qt,
        onFocus: zn,
        ref: Xn,
      } = useIsFocusVisible(),
      [, Qn] = reactExports.useState(!1),
      tr = (Zn) => {
        Qt(Zn), Hn.current === !1 && (Qn(!1), Pn(Zn));
      },
      jn = (Zn) => {
        _n || Dn(Zn.currentTarget),
          zn(Zn),
          Hn.current === !0 && (Qn(!0), dn(Zn));
      },
      nr = (Zn) => {
        Wn.current = !0;
        const lr = vn.props;
        lr.onTouchStart && lr.onTouchStart(Zn);
      },
      or = dn,
      vr = Pn,
      Ar = (Zn) => {
        nr(Zn),
          clearTimeout(Ln.current),
          clearTimeout(Ut.current),
          ir(),
          (Yn.current = document.body.style.WebkitUserSelect),
          (document.body.style.WebkitUserSelect = "none"),
          (Cn.current = setTimeout(() => {
            (document.body.style.WebkitUserSelect = Yn.current), dn(Zn);
          }, Pt));
      },
      _r = (Zn) => {
        vn.props.onTouchEnd && vn.props.onTouchEnd(Zn),
          ir(),
          clearTimeout(Ln.current),
          (Ln.current = setTimeout(() => {
            qn(Zn);
          }, zt));
      };
    reactExports.useEffect(() => {
      if (!Vn) return;
      function Zn(lr) {
        (lr.key === "Escape" || lr.key === "Esc") && qn(lr);
      }
      return (
        document.addEventListener("keydown", Zn),
        () => {
          document.removeEventListener("keydown", Zn);
        }
      );
    }, [qn, Vn]);
    const yr = useForkRef(vn.ref, Xn, Dn, nt);
    !gn && gn !== 0 && (Vn = !1);
    const Qr = reactExports.useRef(),
      Zr = (Zn) => {
        const lr = vn.props;
        lr.onMouseMove && lr.onMouseMove(Zn),
          (cursorPosition = { x: Zn.clientX, y: Zn.clientY }),
          Qr.current && Qr.current.update();
      },
      Mr = {},
      Fr = typeof gn == "string";
    Vt
      ? ((Mr.title = !Vn && Fr && !Kt ? gn : null),
        (Mr["aria-describedby"] = Vn ? Kn : null))
      : ((Mr["aria-label"] = Fr ? gn : null),
        (Mr["aria-labelledby"] = Vn && !Fr ? Kn : null));
    const Dr = _extends(
        {},
        Mr,
        pn,
        vn.props,
        {
          className: clsx(pn.className, vn.props.className),
          onTouchStart: nr,
          ref: yr,
        },
        Rt ? { onMouseMove: Zr } : {}
      ),
      Pr = {};
    Wt || ((Dr.onTouchStart = Ar), (Dr.onTouchEnd = _r)),
      Kt ||
        ((Dr.onMouseOver = composeEventHandler(or, Dr.onMouseOver)),
        (Dr.onMouseLeave = composeEventHandler(vr, Dr.onMouseLeave)),
        Xt || ((Pr.onMouseOver = or), (Pr.onMouseLeave = vr))),
      $t ||
        ((Dr.onFocus = composeEventHandler(jn, Dr.onFocus)),
        (Dr.onBlur = composeEventHandler(tr, Dr.onBlur)),
        Xt || ((Pr.onFocus = jn), (Pr.onBlur = tr)));
    const Gr = reactExports.useMemo(() => {
        var Zn;
        let lr = [
          {
            name: "arrow",
            enabled: !!Tn,
            options: { element: Tn, padding: 4 },
          },
        ];
        return (
          (Zn = ln.popperOptions) != null &&
            Zn.modifiers &&
            (lr = lr.concat(ln.popperOptions.modifiers)),
          _extends({}, ln.popperOptions, { modifiers: lr })
        );
      }, [Tn, ln]),
      $r = _extends({}, Mt, {
        isRtl: Fn,
        arrow: wt,
        disableInteractive: Xt,
        placement: Jt,
        PopperComponentProp: mn,
        touch: Wn.current,
      }),
      fs = useUtilityClasses($r),
      ss =
        (rt = (it = Bn.popper) != null ? it : It.Popper) != null
          ? rt
          : TooltipPopper,
      sn =
        (st =
          (ot = (at = Bn.transition) != null ? at : It.Transition) != null
            ? ot
            : jt) != null
          ? st
          : Grow$1,
      wn =
        (lt = (ct = Bn.tooltip) != null ? ct : It.Tooltip) != null
          ? lt
          : TooltipTooltip,
      Un =
        (ut = (ft = Bn.arrow) != null ? ft : It.Arrow) != null
          ? ut
          : TooltipArrow,
      Rn = appendOwnerState(
        ss,
        _extends({}, ln, (ht = bn.popper) != null ? ht : Ft.popper, {
          className: clsx(
            fs.popper,
            ln == null ? void 0 : ln.className,
            (mt = (vt = bn.popper) != null ? vt : Ft.popper) == null
              ? void 0
              : mt.className
          ),
        }),
        $r
      ),
      Gn = appendOwnerState(
        sn,
        _extends({}, yn, (yt = bn.transition) != null ? yt : Ft.transition),
        $r
      ),
      ar = appendOwnerState(
        wn,
        _extends({}, (Et = bn.tooltip) != null ? Et : Ft.tooltip, {
          className: clsx(
            fs.tooltip,
            (pt = (xt = bn.tooltip) != null ? xt : Ft.tooltip) == null
              ? void 0
              : pt.className
          ),
        }),
        $r
      ),
      fr = appendOwnerState(
        Un,
        _extends({}, (St = bn.arrow) != null ? St : Ft.arrow, {
          className: clsx(
            fs.arrow,
            (At = (Ct = bn.arrow) != null ? Ct : Ft.arrow) == null
              ? void 0
              : At.className
          ),
        }),
        $r
      );
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [
        reactExports.cloneElement(vn, Dr),
        jsxRuntimeExports.jsx(
          ss,
          _extends(
            {
              as: mn ?? Popper$1,
              placement: Jt,
              anchorEl: Rt
                ? {
                    getBoundingClientRect: () => ({
                      top: cursorPosition.y,
                      left: cursorPosition.x,
                      right: cursorPosition.x,
                      bottom: cursorPosition.y,
                      width: 0,
                      height: 0,
                    }),
                  }
                : _n,
              popperRef: Qr,
              open: _n ? Vn : !1,
              id: Kn,
              transition: !0,
            },
            Pr,
            Rn,
            {
              popperOptions: Gr,
              children: ({ TransitionProps: Zn }) =>
                jsxRuntimeExports.jsx(
                  sn,
                  _extends(
                    { timeout: xn.transitions.duration.shorter },
                    Zn,
                    Gn,
                    {
                      children: jsxRuntimeExports.jsxs(
                        wn,
                        _extends({}, ar, {
                          children: [
                            gn,
                            wt
                              ? jsxRuntimeExports.jsx(
                                  Un,
                                  _extends({}, fr, { ref: An })
                                )
                              : null,
                          ],
                        })
                      ),
                    }
                  )
                ),
            }
          )
        ),
      ],
    });
  }),
  Tooltip$1 = Tooltip,
  Ledger = () => {
    const tt = useDispatch(),
      { instructionMessage: et } = useSelector(
        (rt) => rt.DoubleSpendingReducer
      ),
      nt = () => {
        tt(updateShowAlert(!0));
      };
    return React.createElement(
      "div",
      {
        style: {
          position: "absolute",
          bottom: 0,
          right: 0,
          background: "#ffffff10",
          paddingInline: 10,
        },
      },
      React.createElement(
        "h4",
        {
          style: {
            textAlign: "center",
            color: "white",
            fontFamily: "sans-serif",
          },
        },
        " ",
        "Process"
      ),
      et.map((rt, it) =>
        React.createElement(
          "div",
          {
            key: it,
            style: {
              width: "400px",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              padding: 5,
              marginLeft: 3 * it,
            },
          },
          React.createElement(
            "div",
            { style: { display: "flex", margin: 0, flexDirection: "row" } },
            React.createElement(
              "p",
              {
                style: {
                  marginInline: 2,
                  marginBlock: 0,
                  color: "white",
                  display: "flex",
                },
              },
              it + 1,
              " ",
              "   ",
              React.createElement("span", null, ".")
            ),
            React.createElement(
              "p",
              { style: { marginInline: 4, marginBlock: 0, color: "yellow" } },
              rt
            )
          ),
          it === 3 &&
            React.createElement(
              "button",
              { onClick: nt, style: { width: 150, padding: 3, marginTop: 15 } },
              "Cancel Request"
            )
        )
      )
    );
  },
  alert = "images/alert-01dc5b70.jpg",
  paper = "images/paper-eaaa0371.jpg",
  DDObj = ({ position: tt, firstTxt: et, rotation: nt, secondTxt: rt }) => {
    const {
        receiverName: it,
        receiverAmt: st,
        userBalance: ot,
      } = useSelector((lt) => lt.DoubleSpendingReducer),
      at = useLoader(TextureLoader, paper);
    return (
      console.log(ot, st),
      React.createElement(
        "group",
        { rotation: nt, position: tt },
        React.createElement(
          "mesh",
          { rotation: [0, 50, 0] },
          React.createElement(
            Text,
            { color: "yellow", position: [0, 1.9, 0], fontSize: 0.16 },
            et
          ),
          (ot > 0 || st > 0) &&
            React.createElement(
              Text,
              { color: "white", position: [0, 1.5, 0], fontSize: 0.16 },
              rt
            ),
          React.createElement("boxGeometry", { args: [4, 2, 0.8] }),
          React.createElement("meshBasicMaterial", { map: at })
        ),
        React.createElement(
          "mesh",
          { position: [-0.2, 0.8, 0.4], rotation: [0, 50, 0] },
          React.createElement("boxGeometry", { args: [3, 0.3, 0.1] }),
          React.createElement("meshBasicMaterial", { color: "white" }),
          React.createElement(
            Text,
            { color: "black", position: [0, 0, 0.1], fontSize: 0.2 },
            "DEMAND DRAFT"
          ),
          React.createElement(
            Text,
            { color: "black", position: [0, 0, 0.1], fontSize: 0.2 },
            "DEMAND DRAFT"
          )
        ),
        React.createElement(
          "mesh",
          { position: [-0.2, 0.2, 0.4], rotation: [0, 50, 0] },
          React.createElement("boxGeometry", { args: [3.5, 0.3, 0.1] }),
          React.createElement("meshBasicMaterial", { color: "white" }),
          React.createElement(
            Text,
            { color: "black", position: [-1, 0, 0.1], fontSize: 0.2 },
            "Name :"
          ),
          React.createElement(
            Text,
            { color: "blue", position: [1, 0, 0.1], fontSize: 0.2 },
            it
          )
        ),
        React.createElement(
          "mesh",
          { position: [-0.2, -0.2, 0.4], rotation: [0, 50, 0] },
          React.createElement("boxGeometry", { args: [3.5, 0.3, 0.1] }),
          React.createElement("meshBasicMaterial", { color: "white" }),
          React.createElement(
            Text,
            { color: "black", position: [-1, 0, 0.1], fontSize: 0.2 },
            "amount :"
          ),
          React.createElement(
            Text,
            { color: "blue", position: [1, 0, 0.1], fontSize: 0.2 },
            st
          )
        ),
        React.createElement(
          "mesh",
          { position: [1, -0.6, 0.7], rotation: [0, 50, 0] },
          React.createElement(
            Text,
            { color: "blue", position: [0, -0.12, 0.1], fontSize: 0.15 },
            "Ram"
          ),
          React.createElement(
            Text,
            { color: "black", position: [0, -0.26, 0.1], fontSize: 0.15 },
            "Signature"
          )
        )
      )
    );
  },
  Conventional = () => {
    const {
        receiverName: tt,
        moneySendToReciver: et,
        receiverAmt: nt,
        isCancelation: rt,
        userBalance: it,
        isReturnAmt: st,
        enableAlerts: ot,
        waiting: at,
        request: lt,
      } = useSelector((ft) => ft.DoubleSpendingReducer),
      ct = useLoader(TextureLoader, alert),
      ut = useDispatch();
    return (
      console.log(it, st, et),
      reactExports.useEffect(() => {
        console.log("hello"), ut(updateShowSideOption(!0));
      }, []),
      React.createElement(
        "group",
        null,
        React.createElement(
          "group",
          { position: [0, 0, -3] },
          React.createElement(DDObj, {
            firstTxt: "Ram",
            secondTxt: `Balance : ${lt === "return" ? nt : at ? 0 : it} `,
            position: [-5, 1, -0.5],
          }),
          React.createElement(
            "group",
            { rotation: [0, 90, 0], position: [6, 0, 3] },
            tt !== "" &&
              React.createElement(
                React.Fragment,
                null,
                React.createElement(
                  Text,
                  {
                    color: "yellow",
                    rotation: [0, 60, 0],
                    position: [0, 3, 0],
                    fontSize: 0.16,
                  },
                  tt
                ),
                React.createElement(
                  Text,
                  {
                    rotation: [0, 60, 0],
                    color: "white",
                    position: [0, 2.5, 0],
                    fontSize: 0.16,
                  },
                  `Balance : ${at ? nt : 0} `
                )
              ),
            React.createElement(UserOne, null),
            React.createElement(UserOneScene, null)
          )
        ),
        React.createElement(
          "group",
          { rotation: [0, 50, 0] },
          React.createElement(Bank, null),
          at &&
            React.createElement(
              "mesh",
              { position: [0, 1, -1.3] },
              React.createElement("boxGeometry", { args: [3, 1, 0.1] }),
              React.createElement("meshBasicMaterial", { map: ct }),
              React.createElement(
                Text,
                {
                  rotation: [0, 0, 0],
                  color: "white",
                  position: [0, 0, 0.1],
                  fontSize: 0.3,
                },
                "Processing..."
              )
            )
        )
      )
    );
  },
  Loading = () =>
    React.createElement(
      Html,
      { position: [-2, 0, 0] },
      React.createElement(
        "div",
        {
          style: {
            width: "100%",
            height: "100%",
            display: "flex",
            alignItems: "center",
          },
        },
        React.createElement(
          "div",
          { style: { color: "white", width: "500px" } },
          React.createElement(
            "span",
            null,
            "Initializing Simulation Sequence... Please wait"
          )
        )
      )
    );
extend({ UnrealBloomPass });
const Scene = () => {
  const {
    playBlockChain: tt,
    showCard: et,
    radioClicked: nt,
  } = useSelector((rt) => rt.DoubleSpendingReducer);
  return React.createElement(
    Canvas,
    {
      camera: {
        fov: 20,
        position: nt === "conventional" ? [-10, 5, 30] : [-1, 5, 30],
      },
      style: { height: "100vh", position: "absolute" },
    },
    React.createElement(
      reactExports.Suspense,
      { fallback: React.createElement(Loading, null) },
      React.createElement(
        Effects,
        { disableGamma: !0 },
        React.createElement("unrealBloomPass", {
          threshold: 1,
          strength: 1,
          radius: 1,
        })
      ),
      React.createElement("ambientLight", null),
      React.createElement("pointLight", { position: [10, 10, 10] }),
      nt === "conventional" && React.createElement(Conventional, null),
      nt === "blockChain" && React.createElement(BlockChain, null),
      React.createElement(Sparkles, {
        count: 200,
        scale: [60, 20, 10],
        size: 1.5,
        speed: 2,
      }),
      React.createElement("mesh", {
        castShadow: !0,
        receiveShadow: !0,
        "material-color": "#778",
        position: [-0.1, 0.03, 0.07],
      }),
      React.createElement("color", { attach: "background", args: ["#2e3747"] }),
      React.createElement(OrbitControls, { enableZoom: nt !== "conventional" })
    )
  );
};
var lottie = { exports: {} };
(function (module, exports) {
  typeof navigator < "u" &&
    (function (tt, et) {
      module.exports = et();
    })(commonjsGlobal, function () {
      var svgNS = "http://www.w3.org/2000/svg",
        locationHref = "",
        _useWebWorker = !1,
        initialDefaultFrame = -999999,
        setWebWorker = function (et) {
          _useWebWorker = !!et;
        },
        getWebWorker = function () {
          return _useWebWorker;
        },
        setLocationHref = function (et) {
          locationHref = et;
        },
        getLocationHref = function () {
          return locationHref;
        };
      function createTag(tt) {
        return document.createElement(tt);
      }
      function extendPrototype(tt, et) {
        var nt,
          rt = tt.length,
          it;
        for (nt = 0; nt < rt; nt += 1) {
          it = tt[nt].prototype;
          for (var st in it)
            Object.prototype.hasOwnProperty.call(it, st) &&
              (et.prototype[st] = it[st]);
        }
      }
      function getDescriptor(tt, et) {
        return Object.getOwnPropertyDescriptor(tt, et);
      }
      function createProxyFunction(tt) {
        function et() {}
        return (et.prototype = tt), et;
      }
      var audioControllerFactory = (function () {
          function tt(et) {
            (this.audios = []),
              (this.audioFactory = et),
              (this._volume = 1),
              (this._isMuted = !1);
          }
          return (
            (tt.prototype = {
              addAudio: function (nt) {
                this.audios.push(nt);
              },
              pause: function () {
                var nt,
                  rt = this.audios.length;
                for (nt = 0; nt < rt; nt += 1) this.audios[nt].pause();
              },
              resume: function () {
                var nt,
                  rt = this.audios.length;
                for (nt = 0; nt < rt; nt += 1) this.audios[nt].resume();
              },
              setRate: function (nt) {
                var rt,
                  it = this.audios.length;
                for (rt = 0; rt < it; rt += 1) this.audios[rt].setRate(nt);
              },
              createAudio: function (nt) {
                return this.audioFactory
                  ? this.audioFactory(nt)
                  : window.Howl
                  ? new window.Howl({ src: [nt] })
                  : {
                      isPlaying: !1,
                      play: function () {
                        this.isPlaying = !0;
                      },
                      seek: function () {
                        this.isPlaying = !1;
                      },
                      playing: function () {},
                      rate: function () {},
                      setVolume: function () {},
                    };
              },
              setAudioFactory: function (nt) {
                this.audioFactory = nt;
              },
              setVolume: function (nt) {
                (this._volume = nt), this._updateVolume();
              },
              mute: function () {
                (this._isMuted = !0), this._updateVolume();
              },
              unmute: function () {
                (this._isMuted = !1), this._updateVolume();
              },
              getVolume: function () {
                return this._volume;
              },
              _updateVolume: function () {
                var nt,
                  rt = this.audios.length;
                for (nt = 0; nt < rt; nt += 1)
                  this.audios[nt].volume(
                    this._volume * (this._isMuted ? 0 : 1)
                  );
              },
            }),
            function () {
              return new tt();
            }
          );
        })(),
        createTypedArray = (function () {
          function tt(nt, rt) {
            var it = 0,
              st = [],
              ot;
            switch (nt) {
              case "int16":
              case "uint8c":
                ot = 1;
                break;
              default:
                ot = 1.1;
                break;
            }
            for (it = 0; it < rt; it += 1) st.push(ot);
            return st;
          }
          function et(nt, rt) {
            return nt === "float32"
              ? new Float32Array(rt)
              : nt === "int16"
              ? new Int16Array(rt)
              : nt === "uint8c"
              ? new Uint8ClampedArray(rt)
              : tt(nt, rt);
          }
          return typeof Uint8ClampedArray == "function" &&
            typeof Float32Array == "function"
            ? et
            : tt;
        })();
      function createSizedArray(tt) {
        return Array.apply(null, { length: tt });
      }
      function _typeof$6(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$6 = function (nt) {
                return typeof nt;
              })
            : (_typeof$6 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$6(tt)
        );
      }
      var subframeEnabled = !0,
        expressionsPlugin = null,
        expressionsInterfaces = null,
        idPrefix$1 = "",
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        bmPow = Math.pow,
        bmSqrt = Math.sqrt,
        bmFloor = Math.floor,
        bmMax = Math.max,
        bmMin = Math.min,
        BMMath = {};
      (function () {
        var tt = [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "atan2",
            "ceil",
            "cbrt",
            "expm1",
            "clz32",
            "cos",
            "cosh",
            "exp",
            "floor",
            "fround",
            "hypot",
            "imul",
            "log",
            "log1p",
            "log2",
            "log10",
            "max",
            "min",
            "pow",
            "random",
            "round",
            "sign",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "E",
            "LN10",
            "LN2",
            "LOG10E",
            "LOG2E",
            "PI",
            "SQRT1_2",
            "SQRT2",
          ],
          et,
          nt = tt.length;
        for (et = 0; et < nt; et += 1) BMMath[tt[et]] = Math[tt[et]];
      })(),
        (BMMath.random = Math.random),
        (BMMath.abs = function (tt) {
          var et = _typeof$6(tt);
          if (et === "object" && tt.length) {
            var nt = createSizedArray(tt.length),
              rt,
              it = tt.length;
            for (rt = 0; rt < it; rt += 1) nt[rt] = Math.abs(tt[rt]);
            return nt;
          }
          return Math.abs(tt);
        });
      var defaultCurveSegments = 150,
        degToRads = Math.PI / 180,
        roundCorner = 0.5519;
      function styleDiv(tt) {
        (tt.style.position = "absolute"),
          (tt.style.top = 0),
          (tt.style.left = 0),
          (tt.style.display = "block"),
          (tt.style.transformOrigin = "0 0"),
          (tt.style.webkitTransformOrigin = "0 0"),
          (tt.style.backfaceVisibility = "visible"),
          (tt.style.webkitBackfaceVisibility = "visible"),
          (tt.style.transformStyle = "preserve-3d"),
          (tt.style.webkitTransformStyle = "preserve-3d"),
          (tt.style.mozTransformStyle = "preserve-3d");
      }
      function BMEnterFrameEvent(tt, et, nt, rt) {
        (this.type = tt),
          (this.currentTime = et),
          (this.totalTime = nt),
          (this.direction = rt < 0 ? -1 : 1);
      }
      function BMCompleteEvent(tt, et) {
        (this.type = tt), (this.direction = et < 0 ? -1 : 1);
      }
      function BMCompleteLoopEvent(tt, et, nt, rt) {
        (this.type = tt),
          (this.currentLoop = nt),
          (this.totalLoops = et),
          (this.direction = rt < 0 ? -1 : 1);
      }
      function BMSegmentStartEvent(tt, et, nt) {
        (this.type = tt), (this.firstFrame = et), (this.totalFrames = nt);
      }
      function BMDestroyEvent(tt, et) {
        (this.type = tt), (this.target = et);
      }
      function BMRenderFrameErrorEvent(tt, et) {
        (this.type = "renderFrameError"),
          (this.nativeError = tt),
          (this.currentTime = et);
      }
      function BMConfigErrorEvent(tt) {
        (this.type = "configError"), (this.nativeError = tt);
      }
      var createElementID = (function () {
        var tt = 0;
        return function () {
          return (tt += 1), idPrefix$1 + "__lottie_element_" + tt;
        };
      })();
      function HSVtoRGB(tt, et, nt) {
        var rt, it, st, ot, at, lt, ct, ut;
        switch (
          ((ot = Math.floor(tt * 6)),
          (at = tt * 6 - ot),
          (lt = nt * (1 - et)),
          (ct = nt * (1 - at * et)),
          (ut = nt * (1 - (1 - at) * et)),
          ot % 6)
        ) {
          case 0:
            (rt = nt), (it = ut), (st = lt);
            break;
          case 1:
            (rt = ct), (it = nt), (st = lt);
            break;
          case 2:
            (rt = lt), (it = nt), (st = ut);
            break;
          case 3:
            (rt = lt), (it = ct), (st = nt);
            break;
          case 4:
            (rt = ut), (it = lt), (st = nt);
            break;
          case 5:
            (rt = nt), (it = lt), (st = ct);
            break;
        }
        return [rt, it, st];
      }
      function RGBtoHSV(tt, et, nt) {
        var rt = Math.max(tt, et, nt),
          it = Math.min(tt, et, nt),
          st = rt - it,
          ot,
          at = rt === 0 ? 0 : st / rt,
          lt = rt / 255;
        switch (rt) {
          case it:
            ot = 0;
            break;
          case tt:
            (ot = et - nt + st * (et < nt ? 6 : 0)), (ot /= 6 * st);
            break;
          case et:
            (ot = nt - tt + st * 2), (ot /= 6 * st);
            break;
          case nt:
            (ot = tt - et + st * 4), (ot /= 6 * st);
            break;
        }
        return [ot, at, lt];
      }
      function addSaturationToRGB(tt, et) {
        var nt = RGBtoHSV(tt[0] * 255, tt[1] * 255, tt[2] * 255);
        return (
          (nt[1] += et),
          nt[1] > 1 ? (nt[1] = 1) : nt[1] <= 0 && (nt[1] = 0),
          HSVtoRGB(nt[0], nt[1], nt[2])
        );
      }
      function addBrightnessToRGB(tt, et) {
        var nt = RGBtoHSV(tt[0] * 255, tt[1] * 255, tt[2] * 255);
        return (
          (nt[2] += et),
          nt[2] > 1 ? (nt[2] = 1) : nt[2] < 0 && (nt[2] = 0),
          HSVtoRGB(nt[0], nt[1], nt[2])
        );
      }
      function addHueToRGB(tt, et) {
        var nt = RGBtoHSV(tt[0] * 255, tt[1] * 255, tt[2] * 255);
        return (
          (nt[0] += et / 360),
          nt[0] > 1 ? (nt[0] -= 1) : nt[0] < 0 && (nt[0] += 1),
          HSVtoRGB(nt[0], nt[1], nt[2])
        );
      }
      var rgbToHex = (function () {
          var tt = [],
            et,
            nt;
          for (et = 0; et < 256; et += 1)
            (nt = et.toString(16)), (tt[et] = nt.length === 1 ? "0" + nt : nt);
          return function (rt, it, st) {
            return (
              rt < 0 && (rt = 0),
              it < 0 && (it = 0),
              st < 0 && (st = 0),
              "#" + tt[rt] + tt[it] + tt[st]
            );
          };
        })(),
        setSubframeEnabled = function (et) {
          subframeEnabled = !!et;
        },
        getSubframeEnabled = function () {
          return subframeEnabled;
        },
        setExpressionsPlugin = function (et) {
          expressionsPlugin = et;
        },
        getExpressionsPlugin = function () {
          return expressionsPlugin;
        },
        setExpressionInterfaces = function (et) {
          expressionsInterfaces = et;
        },
        getExpressionInterfaces = function () {
          return expressionsInterfaces;
        },
        setDefaultCurveSegments = function (et) {
          defaultCurveSegments = et;
        },
        getDefaultCurveSegments = function () {
          return defaultCurveSegments;
        },
        setIdPrefix = function (et) {
          idPrefix$1 = et;
        };
      function createNS(tt) {
        return document.createElementNS(svgNS, tt);
      }
      function _typeof$5(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$5 = function (nt) {
                return typeof nt;
              })
            : (_typeof$5 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$5(tt)
        );
      }
      var dataManager = (function () {
          var tt = 1,
            et = [],
            nt,
            rt,
            it = {
              onmessage: function () {},
              postMessage: function (mt) {
                nt({ data: mt });
              },
            },
            st = {
              postMessage: function (mt) {
                it.onmessage({ data: mt });
              },
            };
          function ot(ht) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var mt = new Blob(
                  ["var _workerSelf = self; self.onmessage = ", ht.toString()],
                  { type: "text/javascript" }
                ),
                vt = URL.createObjectURL(mt);
              return new Worker(vt);
            }
            return (nt = ht), it;
          }
          function at() {
            rt ||
              ((rt = ot(function (mt) {
                function vt() {
                  function Et(Wt, kt) {
                    var Gt,
                      Pt,
                      Rt = Wt.length,
                      Nt,
                      Dt,
                      zt,
                      Yt;
                    for (Pt = 0; Pt < Rt; Pt += 1)
                      if (((Gt = Wt[Pt]), "ks" in Gt && !Gt.completed)) {
                        if (((Gt.completed = !0), Gt.hasMask)) {
                          var qt = Gt.masksProperties;
                          for (Dt = qt.length, Nt = 0; Nt < Dt; Nt += 1)
                            if (qt[Nt].pt.k.i) Ct(qt[Nt].pt.k);
                            else
                              for (
                                Yt = qt[Nt].pt.k.length, zt = 0;
                                zt < Yt;
                                zt += 1
                              )
                                qt[Nt].pt.k[zt].s && Ct(qt[Nt].pt.k[zt].s[0]),
                                  qt[Nt].pt.k[zt].e && Ct(qt[Nt].pt.k[zt].e[0]);
                        }
                        Gt.ty === 0
                          ? ((Gt.layers = St(Gt.refId, kt)), Et(Gt.layers, kt))
                          : Gt.ty === 4
                          ? At(Gt.shapes)
                          : Gt.ty === 5 && Kt(Gt);
                      }
                  }
                  function pt(Wt, kt) {
                    if (Wt) {
                      var Gt = 0,
                        Pt = Wt.length;
                      for (Gt = 0; Gt < Pt; Gt += 1)
                        Wt[Gt].t === 1 &&
                          ((Wt[Gt].data.layers = St(Wt[Gt].data.refId, kt)),
                          Et(Wt[Gt].data.layers, kt));
                    }
                  }
                  function xt(Wt, kt) {
                    for (var Gt = 0, Pt = kt.length; Gt < Pt; ) {
                      if (kt[Gt].id === Wt) return kt[Gt];
                      Gt += 1;
                    }
                    return null;
                  }
                  function St(Wt, kt) {
                    var Gt = xt(Wt, kt);
                    return Gt
                      ? Gt.layers.__used
                        ? JSON.parse(JSON.stringify(Gt.layers))
                        : ((Gt.layers.__used = !0), Gt.layers)
                      : null;
                  }
                  function At(Wt) {
                    var kt,
                      Gt = Wt.length,
                      Pt,
                      Rt;
                    for (kt = Gt - 1; kt >= 0; kt -= 1)
                      if (Wt[kt].ty === "sh")
                        if (Wt[kt].ks.k.i) Ct(Wt[kt].ks.k);
                        else
                          for (
                            Rt = Wt[kt].ks.k.length, Pt = 0;
                            Pt < Rt;
                            Pt += 1
                          )
                            Wt[kt].ks.k[Pt].s && Ct(Wt[kt].ks.k[Pt].s[0]),
                              Wt[kt].ks.k[Pt].e && Ct(Wt[kt].ks.k[Pt].e[0]);
                      else Wt[kt].ty === "gr" && At(Wt[kt].it);
                  }
                  function Ct(Wt) {
                    var kt,
                      Gt = Wt.i.length;
                    for (kt = 0; kt < Gt; kt += 1)
                      (Wt.i[kt][0] += Wt.v[kt][0]),
                        (Wt.i[kt][1] += Wt.v[kt][1]),
                        (Wt.o[kt][0] += Wt.v[kt][0]),
                        (Wt.o[kt][1] += Wt.v[kt][1]);
                  }
                  function Mt(Wt, kt) {
                    var Gt = kt ? kt.split(".") : [100, 100, 100];
                    return Wt[0] > Gt[0]
                      ? !0
                      : Gt[0] > Wt[0]
                      ? !1
                      : Wt[1] > Gt[1]
                      ? !0
                      : Gt[1] > Wt[1]
                      ? !1
                      : Wt[2] > Gt[2]
                      ? !0
                      : Gt[2] > Wt[2]
                      ? !1
                      : null;
                  }
                  var wt = (function () {
                      var Wt = [4, 4, 14];
                      function kt(Pt) {
                        var Rt = Pt.t.d;
                        Pt.t.d = { k: [{ s: Rt, t: 0 }] };
                      }
                      function Gt(Pt) {
                        var Rt,
                          Nt = Pt.length;
                        for (Rt = 0; Rt < Nt; Rt += 1)
                          Pt[Rt].ty === 5 && kt(Pt[Rt]);
                      }
                      return function (Pt) {
                        if (Mt(Wt, Pt.v) && (Gt(Pt.layers), Pt.assets)) {
                          var Rt,
                            Nt = Pt.assets.length;
                          for (Rt = 0; Rt < Nt; Rt += 1)
                            Pt.assets[Rt].layers && Gt(Pt.assets[Rt].layers);
                        }
                      };
                    })(),
                    Bt = (function () {
                      var Wt = [4, 7, 99];
                      return function (kt) {
                        if (kt.chars && !Mt(Wt, kt.v)) {
                          var Gt,
                            Pt = kt.chars.length;
                          for (Gt = 0; Gt < Pt; Gt += 1) {
                            var Rt = kt.chars[Gt];
                            Rt.data &&
                              Rt.data.shapes &&
                              (At(Rt.data.shapes),
                              (Rt.data.ip = 0),
                              (Rt.data.op = 99999),
                              (Rt.data.st = 0),
                              (Rt.data.sr = 1),
                              (Rt.data.ks = {
                                p: { k: [0, 0], a: 0 },
                                s: { k: [100, 100], a: 0 },
                                a: { k: [0, 0], a: 0 },
                                r: { k: 0, a: 0 },
                                o: { k: 100, a: 0 },
                              }),
                              kt.chars[Gt].t ||
                                (Rt.data.shapes.push({ ty: "no" }),
                                Rt.data.shapes[0].it.push({
                                  p: { k: [0, 0], a: 0 },
                                  s: { k: [100, 100], a: 0 },
                                  a: { k: [0, 0], a: 0 },
                                  r: { k: 0, a: 0 },
                                  o: { k: 100, a: 0 },
                                  sk: { k: 0, a: 0 },
                                  sa: { k: 0, a: 0 },
                                  ty: "tr",
                                })));
                          }
                        }
                      };
                    })(),
                    It = (function () {
                      var Wt = [5, 7, 15];
                      function kt(Pt) {
                        var Rt = Pt.t.p;
                        typeof Rt.a == "number" && (Rt.a = { a: 0, k: Rt.a }),
                          typeof Rt.p == "number" && (Rt.p = { a: 0, k: Rt.p }),
                          typeof Rt.r == "number" && (Rt.r = { a: 0, k: Rt.r });
                      }
                      function Gt(Pt) {
                        var Rt,
                          Nt = Pt.length;
                        for (Rt = 0; Rt < Nt; Rt += 1)
                          Pt[Rt].ty === 5 && kt(Pt[Rt]);
                      }
                      return function (Pt) {
                        if (Mt(Wt, Pt.v) && (Gt(Pt.layers), Pt.assets)) {
                          var Rt,
                            Nt = Pt.assets.length;
                          for (Rt = 0; Rt < Nt; Rt += 1)
                            Pt.assets[Rt].layers && Gt(Pt.assets[Rt].layers);
                        }
                      };
                    })(),
                    Ft = (function () {
                      var Wt = [4, 1, 9];
                      function kt(Pt) {
                        var Rt,
                          Nt = Pt.length,
                          Dt,
                          zt;
                        for (Rt = 0; Rt < Nt; Rt += 1)
                          if (Pt[Rt].ty === "gr") kt(Pt[Rt].it);
                          else if (Pt[Rt].ty === "fl" || Pt[Rt].ty === "st")
                            if (Pt[Rt].c.k && Pt[Rt].c.k[0].i)
                              for (
                                zt = Pt[Rt].c.k.length, Dt = 0;
                                Dt < zt;
                                Dt += 1
                              )
                                Pt[Rt].c.k[Dt].s &&
                                  ((Pt[Rt].c.k[Dt].s[0] /= 255),
                                  (Pt[Rt].c.k[Dt].s[1] /= 255),
                                  (Pt[Rt].c.k[Dt].s[2] /= 255),
                                  (Pt[Rt].c.k[Dt].s[3] /= 255)),
                                  Pt[Rt].c.k[Dt].e &&
                                    ((Pt[Rt].c.k[Dt].e[0] /= 255),
                                    (Pt[Rt].c.k[Dt].e[1] /= 255),
                                    (Pt[Rt].c.k[Dt].e[2] /= 255),
                                    (Pt[Rt].c.k[Dt].e[3] /= 255));
                            else
                              (Pt[Rt].c.k[0] /= 255),
                                (Pt[Rt].c.k[1] /= 255),
                                (Pt[Rt].c.k[2] /= 255),
                                (Pt[Rt].c.k[3] /= 255);
                      }
                      function Gt(Pt) {
                        var Rt,
                          Nt = Pt.length;
                        for (Rt = 0; Rt < Nt; Rt += 1)
                          Pt[Rt].ty === 4 && kt(Pt[Rt].shapes);
                      }
                      return function (Pt) {
                        if (Mt(Wt, Pt.v) && (Gt(Pt.layers), Pt.assets)) {
                          var Rt,
                            Nt = Pt.assets.length;
                          for (Rt = 0; Rt < Nt; Rt += 1)
                            Pt.assets[Rt].layers && Gt(Pt.assets[Rt].layers);
                        }
                      };
                    })(),
                    Vt = (function () {
                      var Wt = [4, 4, 18];
                      function kt(Pt) {
                        var Rt,
                          Nt = Pt.length,
                          Dt,
                          zt;
                        for (Rt = Nt - 1; Rt >= 0; Rt -= 1)
                          if (Pt[Rt].ty === "sh")
                            if (Pt[Rt].ks.k.i) Pt[Rt].ks.k.c = Pt[Rt].closed;
                            else
                              for (
                                zt = Pt[Rt].ks.k.length, Dt = 0;
                                Dt < zt;
                                Dt += 1
                              )
                                Pt[Rt].ks.k[Dt].s &&
                                  (Pt[Rt].ks.k[Dt].s[0].c = Pt[Rt].closed),
                                  Pt[Rt].ks.k[Dt].e &&
                                    (Pt[Rt].ks.k[Dt].e[0].c = Pt[Rt].closed);
                          else Pt[Rt].ty === "gr" && kt(Pt[Rt].it);
                      }
                      function Gt(Pt) {
                        var Rt,
                          Nt,
                          Dt = Pt.length,
                          zt,
                          Yt,
                          qt,
                          Zt;
                        for (Nt = 0; Nt < Dt; Nt += 1) {
                          if (((Rt = Pt[Nt]), Rt.hasMask)) {
                            var Jt = Rt.masksProperties;
                            for (Yt = Jt.length, zt = 0; zt < Yt; zt += 1)
                              if (Jt[zt].pt.k.i) Jt[zt].pt.k.c = Jt[zt].cl;
                              else
                                for (
                                  Zt = Jt[zt].pt.k.length, qt = 0;
                                  qt < Zt;
                                  qt += 1
                                )
                                  Jt[zt].pt.k[qt].s &&
                                    (Jt[zt].pt.k[qt].s[0].c = Jt[zt].cl),
                                    Jt[zt].pt.k[qt].e &&
                                      (Jt[zt].pt.k[qt].e[0].c = Jt[zt].cl);
                          }
                          Rt.ty === 4 && kt(Rt.shapes);
                        }
                      }
                      return function (Pt) {
                        if (Mt(Wt, Pt.v) && (Gt(Pt.layers), Pt.assets)) {
                          var Rt,
                            Nt = Pt.assets.length;
                          for (Rt = 0; Rt < Nt; Rt += 1)
                            Pt.assets[Rt].layers && Gt(Pt.assets[Rt].layers);
                        }
                      };
                    })();
                  function $t(Wt) {
                    Wt.__complete ||
                      (Ft(Wt),
                      wt(Wt),
                      Bt(Wt),
                      It(Wt),
                      Vt(Wt),
                      Et(Wt.layers, Wt.assets),
                      pt(Wt.chars, Wt.assets),
                      (Wt.__complete = !0));
                  }
                  function Kt(Wt) {
                    Wt.t.a.length === 0 && "m" in Wt.t.p;
                  }
                  var Ht = {};
                  return (
                    (Ht.completeData = $t),
                    (Ht.checkColors = Ft),
                    (Ht.checkChars = Bt),
                    (Ht.checkPathProperties = It),
                    (Ht.checkShapes = Vt),
                    (Ht.completeLayers = Et),
                    Ht
                  );
                }
                if (
                  (st.dataManager || (st.dataManager = vt()),
                  st.assetLoader ||
                    (st.assetLoader = (function () {
                      function Et(xt) {
                        var St = xt.getResponseHeader("content-type");
                        return (St &&
                          xt.responseType === "json" &&
                          St.indexOf("json") !== -1) ||
                          (xt.response && _typeof$5(xt.response) === "object")
                          ? xt.response
                          : xt.response && typeof xt.response == "string"
                          ? JSON.parse(xt.response)
                          : xt.responseText
                          ? JSON.parse(xt.responseText)
                          : null;
                      }
                      function pt(xt, St, At, Ct) {
                        var Mt,
                          wt = new XMLHttpRequest();
                        try {
                          wt.responseType = "json";
                        } catch {}
                        wt.onreadystatechange = function () {
                          if (wt.readyState === 4)
                            if (wt.status === 200) (Mt = Et(wt)), At(Mt);
                            else
                              try {
                                (Mt = Et(wt)), At(Mt);
                              } catch (Bt) {
                                Ct && Ct(Bt);
                              }
                        };
                        try {
                          wt.open(["G", "E", "T"].join(""), xt, !0);
                        } catch {
                          wt.open(["G", "E", "T"].join(""), St + "/" + xt, !0);
                        }
                        wt.send();
                      }
                      return { load: pt };
                    })()),
                  mt.data.type === "loadAnimation")
                )
                  st.assetLoader.load(
                    mt.data.path,
                    mt.data.fullPath,
                    function (Et) {
                      st.dataManager.completeData(Et),
                        st.postMessage({
                          id: mt.data.id,
                          payload: Et,
                          status: "success",
                        });
                    },
                    function () {
                      st.postMessage({ id: mt.data.id, status: "error" });
                    }
                  );
                else if (mt.data.type === "complete") {
                  var yt = mt.data.animation;
                  st.dataManager.completeData(yt),
                    st.postMessage({
                      id: mt.data.id,
                      payload: yt,
                      status: "success",
                    });
                } else
                  mt.data.type === "loadData" &&
                    st.assetLoader.load(
                      mt.data.path,
                      mt.data.fullPath,
                      function (Et) {
                        st.postMessage({
                          id: mt.data.id,
                          payload: Et,
                          status: "success",
                        });
                      },
                      function () {
                        st.postMessage({ id: mt.data.id, status: "error" });
                      }
                    );
              })),
              (rt.onmessage = function (ht) {
                var mt = ht.data,
                  vt = mt.id,
                  yt = et[vt];
                (et[vt] = null),
                  mt.status === "success"
                    ? yt.onComplete(mt.payload)
                    : yt.onError && yt.onError();
              }));
          }
          function lt(ht, mt) {
            tt += 1;
            var vt = "processId_" + tt;
            return (et[vt] = { onComplete: ht, onError: mt }), vt;
          }
          function ct(ht, mt, vt) {
            at();
            var yt = lt(mt, vt);
            rt.postMessage({
              type: "loadAnimation",
              path: ht,
              fullPath: window.location.origin + window.location.pathname,
              id: yt,
            });
          }
          function ut(ht, mt, vt) {
            at();
            var yt = lt(mt, vt);
            rt.postMessage({
              type: "loadData",
              path: ht,
              fullPath: window.location.origin + window.location.pathname,
              id: yt,
            });
          }
          function ft(ht, mt, vt) {
            at();
            var yt = lt(mt, vt);
            rt.postMessage({ type: "complete", animation: ht, id: yt });
          }
          return { loadAnimation: ct, loadData: ut, completeAnimation: ft };
        })(),
        ImagePreloader = (function () {
          var tt = (function () {
            var pt = createTag("canvas");
            (pt.width = 1), (pt.height = 1);
            var xt = pt.getContext("2d");
            return (
              (xt.fillStyle = "rgba(0,0,0,0)"), xt.fillRect(0, 0, 1, 1), pt
            );
          })();
          function et() {
            (this.loadedAssets += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function nt() {
            (this.loadedFootagesCount += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function rt(pt, xt, St) {
            var At = "";
            if (pt.e) At = pt.p;
            else if (xt) {
              var Ct = pt.p;
              Ct.indexOf("images/") !== -1 && (Ct = Ct.split("/")[1]),
                (At = xt + Ct);
            } else (At = St), (At += pt.u ? pt.u : ""), (At += pt.p);
            return At;
          }
          function it(pt) {
            var xt = 0,
              St = setInterval(
                function () {
                  var At = pt.getBBox();
                  (At.width || xt > 500) &&
                    (this._imageLoaded(), clearInterval(St)),
                    (xt += 1);
                }.bind(this),
                50
              );
          }
          function st(pt) {
            var xt = rt(pt, this.assetsPath, this.path),
              St = createNS("image");
            isSafari
              ? this.testImageLoaded(St)
              : St.addEventListener("load", this._imageLoaded, !1),
              St.addEventListener(
                "error",
                function () {
                  (At.img = tt), this._imageLoaded();
                }.bind(this),
                !1
              ),
              St.setAttributeNS("http://www.w3.org/1999/xlink", "href", xt),
              this._elementHelper.append
                ? this._elementHelper.append(St)
                : this._elementHelper.appendChild(St);
            var At = { img: St, assetData: pt };
            return At;
          }
          function ot(pt) {
            var xt = rt(pt, this.assetsPath, this.path),
              St = createTag("img");
            (St.crossOrigin = "anonymous"),
              St.addEventListener("load", this._imageLoaded, !1),
              St.addEventListener(
                "error",
                function () {
                  (At.img = tt), this._imageLoaded();
                }.bind(this),
                !1
              ),
              (St.src = xt);
            var At = { img: St, assetData: pt };
            return At;
          }
          function at(pt) {
            var xt = { assetData: pt },
              St = rt(pt, this.assetsPath, this.path);
            return (
              dataManager.loadData(
                St,
                function (At) {
                  (xt.img = At), this._footageLoaded();
                }.bind(this),
                function () {
                  (xt.img = {}), this._footageLoaded();
                }.bind(this)
              ),
              xt
            );
          }
          function lt(pt, xt) {
            this.imagesLoadedCb = xt;
            var St,
              At = pt.length;
            for (St = 0; St < At; St += 1)
              pt[St].layers ||
                (!pt[St].t || pt[St].t === "seq"
                  ? ((this.totalImages += 1),
                    this.images.push(this._createImageData(pt[St])))
                  : pt[St].t === 3 &&
                    ((this.totalFootages += 1),
                    this.images.push(this.createFootageData(pt[St]))));
          }
          function ct(pt) {
            this.path = pt || "";
          }
          function ut(pt) {
            this.assetsPath = pt || "";
          }
          function ft(pt) {
            for (var xt = 0, St = this.images.length; xt < St; ) {
              if (this.images[xt].assetData === pt) return this.images[xt].img;
              xt += 1;
            }
            return null;
          }
          function ht() {
            (this.imagesLoadedCb = null), (this.images.length = 0);
          }
          function mt() {
            return this.totalImages === this.loadedAssets;
          }
          function vt() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function yt(pt, xt) {
            pt === "svg"
              ? ((this._elementHelper = xt),
                (this._createImageData = this.createImageData.bind(this)))
              : (this._createImageData = this.createImgData.bind(this));
          }
          function Et() {
            (this._imageLoaded = et.bind(this)),
              (this._footageLoaded = nt.bind(this)),
              (this.testImageLoaded = it.bind(this)),
              (this.createFootageData = at.bind(this)),
              (this.assetsPath = ""),
              (this.path = ""),
              (this.totalImages = 0),
              (this.totalFootages = 0),
              (this.loadedAssets = 0),
              (this.loadedFootagesCount = 0),
              (this.imagesLoadedCb = null),
              (this.images = []);
          }
          return (
            (Et.prototype = {
              loadAssets: lt,
              setAssetsPath: ut,
              setPath: ct,
              loadedImages: mt,
              loadedFootages: vt,
              destroy: ht,
              getAsset: ft,
              createImgData: ot,
              createImageData: st,
              imageLoaded: et,
              footageLoaded: nt,
              setCacheType: yt,
            }),
            Et
          );
        })();
      function BaseEvent() {}
      BaseEvent.prototype = {
        triggerEvent: function (et, nt) {
          if (this._cbs[et])
            for (var rt = this._cbs[et], it = 0; it < rt.length; it += 1)
              rt[it](nt);
        },
        addEventListener: function (et, nt) {
          return (
            this._cbs[et] || (this._cbs[et] = []),
            this._cbs[et].push(nt),
            function () {
              this.removeEventListener(et, nt);
            }.bind(this)
          );
        },
        removeEventListener: function (et, nt) {
          if (!nt) this._cbs[et] = null;
          else if (this._cbs[et]) {
            for (var rt = 0, it = this._cbs[et].length; rt < it; )
              this._cbs[et][rt] === nt &&
                (this._cbs[et].splice(rt, 1), (rt -= 1), (it -= 1)),
                (rt += 1);
            this._cbs[et].length || (this._cbs[et] = null);
          }
        },
      };
      var markerParser = (function () {
          function tt(et) {
            for (
              var nt = et.split(`\r
`),
                rt = {},
                it,
                st = 0,
                ot = 0;
              ot < nt.length;
              ot += 1
            )
              (it = nt[ot].split(":")),
                it.length === 2 && ((rt[it[0]] = it[1].trim()), (st += 1));
            if (st === 0) throw new Error();
            return rt;
          }
          return function (et) {
            for (var nt = [], rt = 0; rt < et.length; rt += 1) {
              var it = et[rt],
                st = { time: it.tm, duration: it.dr };
              try {
                st.payload = JSON.parse(et[rt].cm);
              } catch {
                try {
                  st.payload = tt(et[rt].cm);
                } catch {
                  st.payload = { name: et[rt].cm };
                }
              }
              nt.push(st);
            }
            return nt;
          };
        })(),
        ProjectInterface = (function () {
          function tt(et) {
            this.compositions.push(et);
          }
          return function () {
            function et(nt) {
              for (var rt = 0, it = this.compositions.length; rt < it; ) {
                if (
                  this.compositions[rt].data &&
                  this.compositions[rt].data.nm === nt
                )
                  return (
                    this.compositions[rt].prepareFrame &&
                      this.compositions[rt].data.xt &&
                      this.compositions[rt].prepareFrame(this.currentFrame),
                    this.compositions[rt].compInterface
                  );
                rt += 1;
              }
              return null;
            }
            return (
              (et.compositions = []),
              (et.currentFrame = 0),
              (et.registerComposition = tt),
              et
            );
          };
        })(),
        renderers = {},
        registerRenderer = function (et, nt) {
          renderers[et] = nt;
        };
      function getRenderer(tt) {
        return renderers[tt];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) return "canvas";
        for (var tt in renderers) if (renderers[tt]) return tt;
        return "";
      }
      function _typeof$4(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$4 = function (nt) {
                return typeof nt;
              })
            : (_typeof$4 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$4(tt)
        );
      }
      var AnimationItem = function () {
        (this._cbs = []),
          (this.name = ""),
          (this.path = ""),
          (this.isLoaded = !1),
          (this.currentFrame = 0),
          (this.currentRawFrame = 0),
          (this.firstFrame = 0),
          (this.totalFrames = 0),
          (this.frameRate = 0),
          (this.frameMult = 0),
          (this.playSpeed = 1),
          (this.playDirection = 1),
          (this.playCount = 0),
          (this.animationData = {}),
          (this.assets = []),
          (this.isPaused = !0),
          (this.autoplay = !1),
          (this.loop = !0),
          (this.renderer = null),
          (this.animationID = createElementID()),
          (this.assetsPath = ""),
          (this.timeCompleted = 0),
          (this.segmentPos = 0),
          (this.isSubframeEnabled = getSubframeEnabled()),
          (this.segments = []),
          (this._idle = !0),
          (this._completedLoop = !1),
          (this.projectInterface = ProjectInterface()),
          (this.imagePreloader = new ImagePreloader()),
          (this.audioController = audioControllerFactory()),
          (this.markers = []),
          (this.configAnimation = this.configAnimation.bind(this)),
          (this.onSetupError = this.onSetupError.bind(this)),
          (this.onSegmentComplete = this.onSegmentComplete.bind(this)),
          (this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0)),
          (this.expressionsPlugin = getExpressionsPlugin());
      };
      extendPrototype([BaseEvent], AnimationItem),
        (AnimationItem.prototype.setParams = function (tt) {
          (tt.wrapper || tt.container) &&
            (this.wrapper = tt.wrapper || tt.container);
          var et = "svg";
          tt.animType ? (et = tt.animType) : tt.renderer && (et = tt.renderer);
          var nt = getRenderer(et);
          (this.renderer = new nt(this, tt.rendererSettings)),
            this.imagePreloader.setCacheType(et, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            (this.animType = et),
            tt.loop === "" ||
            tt.loop === null ||
            tt.loop === void 0 ||
            tt.loop === !0
              ? (this.loop = !0)
              : tt.loop === !1
              ? (this.loop = !1)
              : (this.loop = parseInt(tt.loop, 10)),
            (this.autoplay = "autoplay" in tt ? tt.autoplay : !0),
            (this.name = tt.name ? tt.name : ""),
            (this.autoloadSegments = Object.prototype.hasOwnProperty.call(
              tt,
              "autoloadSegments"
            )
              ? tt.autoloadSegments
              : !0),
            (this.assetsPath = tt.assetsPath),
            (this.initialSegment = tt.initialSegment),
            tt.audioFactory &&
              this.audioController.setAudioFactory(tt.audioFactory),
            tt.animationData
              ? this.setupAnimation(tt.animationData)
              : tt.path &&
                (tt.path.lastIndexOf("\\") !== -1
                  ? (this.path = tt.path.substr(
                      0,
                      tt.path.lastIndexOf("\\") + 1
                    ))
                  : (this.path = tt.path.substr(
                      0,
                      tt.path.lastIndexOf("/") + 1
                    )),
                (this.fileName = tt.path.substr(tt.path.lastIndexOf("/") + 1)),
                (this.fileName = this.fileName.substr(
                  0,
                  this.fileName.lastIndexOf(".json")
                )),
                dataManager.loadAnimation(
                  tt.path,
                  this.configAnimation,
                  this.onSetupError
                ));
        }),
        (AnimationItem.prototype.onSetupError = function () {
          this.trigger("data_failed");
        }),
        (AnimationItem.prototype.setupAnimation = function (tt) {
          dataManager.completeAnimation(tt, this.configAnimation);
        }),
        (AnimationItem.prototype.setData = function (tt, et) {
          et && _typeof$4(et) !== "object" && (et = JSON.parse(et));
          var nt = { wrapper: tt, animationData: et },
            rt = tt.attributes;
          (nt.path = rt.getNamedItem("data-animation-path")
            ? rt.getNamedItem("data-animation-path").value
            : rt.getNamedItem("data-bm-path")
            ? rt.getNamedItem("data-bm-path").value
            : rt.getNamedItem("bm-path")
            ? rt.getNamedItem("bm-path").value
            : ""),
            (nt.animType = rt.getNamedItem("data-anim-type")
              ? rt.getNamedItem("data-anim-type").value
              : rt.getNamedItem("data-bm-type")
              ? rt.getNamedItem("data-bm-type").value
              : rt.getNamedItem("bm-type")
              ? rt.getNamedItem("bm-type").value
              : rt.getNamedItem("data-bm-renderer")
              ? rt.getNamedItem("data-bm-renderer").value
              : rt.getNamedItem("bm-renderer")
              ? rt.getNamedItem("bm-renderer").value
              : getRegisteredRenderer() || "canvas");
          var it = rt.getNamedItem("data-anim-loop")
            ? rt.getNamedItem("data-anim-loop").value
            : rt.getNamedItem("data-bm-loop")
            ? rt.getNamedItem("data-bm-loop").value
            : rt.getNamedItem("bm-loop")
            ? rt.getNamedItem("bm-loop").value
            : "";
          it === "false"
            ? (nt.loop = !1)
            : it === "true"
            ? (nt.loop = !0)
            : it !== "" && (nt.loop = parseInt(it, 10));
          var st = rt.getNamedItem("data-anim-autoplay")
            ? rt.getNamedItem("data-anim-autoplay").value
            : rt.getNamedItem("data-bm-autoplay")
            ? rt.getNamedItem("data-bm-autoplay").value
            : rt.getNamedItem("bm-autoplay")
            ? rt.getNamedItem("bm-autoplay").value
            : !0;
          (nt.autoplay = st !== "false"),
            (nt.name = rt.getNamedItem("data-name")
              ? rt.getNamedItem("data-name").value
              : rt.getNamedItem("data-bm-name")
              ? rt.getNamedItem("data-bm-name").value
              : rt.getNamedItem("bm-name")
              ? rt.getNamedItem("bm-name").value
              : "");
          var ot = rt.getNamedItem("data-anim-prerender")
            ? rt.getNamedItem("data-anim-prerender").value
            : rt.getNamedItem("data-bm-prerender")
            ? rt.getNamedItem("data-bm-prerender").value
            : rt.getNamedItem("bm-prerender")
            ? rt.getNamedItem("bm-prerender").value
            : "";
          ot === "false" && (nt.prerender = !1),
            nt.path ? this.setParams(nt) : this.trigger("destroy");
        }),
        (AnimationItem.prototype.includeLayers = function (tt) {
          tt.op > this.animationData.op &&
            ((this.animationData.op = tt.op),
            (this.totalFrames = Math.floor(tt.op - this.animationData.ip)));
          var et = this.animationData.layers,
            nt,
            rt = et.length,
            it = tt.layers,
            st,
            ot = it.length;
          for (st = 0; st < ot; st += 1)
            for (nt = 0; nt < rt; ) {
              if (et[nt].id === it[st].id) {
                et[nt] = it[st];
                break;
              }
              nt += 1;
            }
          if (
            ((tt.chars || tt.fonts) &&
              (this.renderer.globalData.fontManager.addChars(tt.chars),
              this.renderer.globalData.fontManager.addFonts(
                tt.fonts,
                this.renderer.globalData.defs
              )),
            tt.assets)
          )
            for (rt = tt.assets.length, nt = 0; nt < rt; nt += 1)
              this.animationData.assets.push(tt.assets[nt]);
          (this.animationData.__complete = !1),
            dataManager.completeAnimation(
              this.animationData,
              this.onSegmentComplete
            );
        }),
        (AnimationItem.prototype.onSegmentComplete = function (tt) {
          this.animationData = tt;
          var et = getExpressionsPlugin();
          et && et.initExpressions(this), this.loadNextSegment();
        }),
        (AnimationItem.prototype.loadNextSegment = function () {
          var tt = this.animationData.segments;
          if (!tt || tt.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready"), (this.timeCompleted = this.totalFrames);
            return;
          }
          var et = tt.shift();
          this.timeCompleted = et.time * this.frameRate;
          var nt = this.path + this.fileName + "_" + this.segmentPos + ".json";
          (this.segmentPos += 1),
            dataManager.loadData(
              nt,
              this.includeLayers.bind(this),
              function () {
                this.trigger("data_failed");
              }.bind(this)
            );
        }),
        (AnimationItem.prototype.loadSegments = function () {
          var tt = this.animationData.segments;
          tt || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
        }),
        (AnimationItem.prototype.imagesLoaded = function () {
          this.trigger("loaded_images"), this.checkLoaded();
        }),
        (AnimationItem.prototype.preloadImages = function () {
          this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(
              this.animationData.assets,
              this.imagesLoaded.bind(this)
            );
        }),
        (AnimationItem.prototype.configAnimation = function (tt) {
          if (this.renderer)
            try {
              (this.animationData = tt),
                this.initialSegment
                  ? ((this.totalFrames = Math.floor(
                      this.initialSegment[1] - this.initialSegment[0]
                    )),
                    (this.firstFrame = Math.round(this.initialSegment[0])))
                  : ((this.totalFrames = Math.floor(
                      this.animationData.op - this.animationData.ip
                    )),
                    (this.firstFrame = Math.round(this.animationData.ip))),
                this.renderer.configAnimation(tt),
                tt.assets || (tt.assets = []),
                (this.assets = this.animationData.assets),
                (this.frameRate = this.animationData.fr),
                (this.frameMult = this.animationData.fr / 1e3),
                this.renderer.searchExtraCompositions(tt.assets),
                (this.markers = markerParser(tt.markers || [])),
                this.trigger("config_ready"),
                this.preloadImages(),
                this.loadSegments(),
                this.updaFrameModifier(),
                this.waitForFontsLoaded(),
                this.isPaused && this.audioController.pause();
            } catch (et) {
              this.triggerConfigError(et);
            }
        }),
        (AnimationItem.prototype.waitForFontsLoaded = function () {
          this.renderer &&
            (this.renderer.globalData.fontManager.isLoaded
              ? this.checkLoaded()
              : setTimeout(this.waitForFontsLoaded.bind(this), 20));
        }),
        (AnimationItem.prototype.checkLoaded = function () {
          if (
            !this.isLoaded &&
            this.renderer.globalData.fontManager.isLoaded &&
            (this.imagePreloader.loadedImages() ||
              this.renderer.rendererType !== "canvas") &&
            this.imagePreloader.loadedFootages()
          ) {
            this.isLoaded = !0;
            var tt = getExpressionsPlugin();
            tt && tt.initExpressions(this),
              this.renderer.initItems(),
              setTimeout(
                function () {
                  this.trigger("DOMLoaded");
                }.bind(this),
                0
              ),
              this.gotoFrame(),
              this.autoplay && this.play();
          }
        }),
        (AnimationItem.prototype.resize = function (tt, et) {
          var nt = typeof tt == "number" ? tt : void 0,
            rt = typeof et == "number" ? et : void 0;
          this.renderer.updateContainerSize(nt, rt);
        }),
        (AnimationItem.prototype.setSubframe = function (tt) {
          this.isSubframeEnabled = !!tt;
        }),
        (AnimationItem.prototype.gotoFrame = function () {
          (this.currentFrame = this.isSubframeEnabled
            ? this.currentRawFrame
            : ~~this.currentRawFrame),
            this.timeCompleted !== this.totalFrames &&
              this.currentFrame > this.timeCompleted &&
              (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame");
        }),
        (AnimationItem.prototype.renderFrame = function () {
          if (!(this.isLoaded === !1 || !this.renderer))
            try {
              this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                this.renderer.renderFrame(this.currentFrame + this.firstFrame);
            } catch (tt) {
              this.triggerRenderFrameError(tt);
            }
        }),
        (AnimationItem.prototype.play = function (tt) {
          (tt && this.name !== tt) ||
            (this.isPaused === !0 &&
              ((this.isPaused = !1),
              this.trigger("_play"),
              this.audioController.resume(),
              this._idle && ((this._idle = !1), this.trigger("_active"))));
        }),
        (AnimationItem.prototype.pause = function (tt) {
          (tt && this.name !== tt) ||
            (this.isPaused === !1 &&
              ((this.isPaused = !0),
              this.trigger("_pause"),
              (this._idle = !0),
              this.trigger("_idle"),
              this.audioController.pause()));
        }),
        (AnimationItem.prototype.togglePause = function (tt) {
          (tt && this.name !== tt) ||
            (this.isPaused === !0 ? this.play() : this.pause());
        }),
        (AnimationItem.prototype.stop = function (tt) {
          (tt && this.name !== tt) ||
            (this.pause(),
            (this.playCount = 0),
            (this._completedLoop = !1),
            this.setCurrentRawFrameValue(0));
        }),
        (AnimationItem.prototype.getMarkerData = function (tt) {
          for (var et, nt = 0; nt < this.markers.length; nt += 1)
            if (((et = this.markers[nt]), et.payload && et.payload.name === tt))
              return et;
          return null;
        }),
        (AnimationItem.prototype.goToAndStop = function (tt, et, nt) {
          if (!(nt && this.name !== nt)) {
            var rt = Number(tt);
            if (isNaN(rt)) {
              var it = this.getMarkerData(tt);
              it && this.goToAndStop(it.time, !0);
            } else
              et
                ? this.setCurrentRawFrameValue(tt)
                : this.setCurrentRawFrameValue(tt * this.frameModifier);
            this.pause();
          }
        }),
        (AnimationItem.prototype.goToAndPlay = function (tt, et, nt) {
          if (!(nt && this.name !== nt)) {
            var rt = Number(tt);
            if (isNaN(rt)) {
              var it = this.getMarkerData(tt);
              it &&
                (it.duration
                  ? this.playSegments([it.time, it.time + it.duration], !0)
                  : this.goToAndStop(it.time, !0));
            } else this.goToAndStop(rt, et, nt);
            this.play();
          }
        }),
        (AnimationItem.prototype.advanceTime = function (tt) {
          if (!(this.isPaused === !0 || this.isLoaded === !1)) {
            var et = this.currentRawFrame + tt * this.frameModifier,
              nt = !1;
            et >= this.totalFrames - 1 && this.frameModifier > 0
              ? !this.loop || this.playCount === this.loop
                ? this.checkSegments(
                    et > this.totalFrames ? et % this.totalFrames : 0
                  ) || ((nt = !0), (et = this.totalFrames - 1))
                : et >= this.totalFrames
                ? ((this.playCount += 1),
                  this.checkSegments(et % this.totalFrames) ||
                    (this.setCurrentRawFrameValue(et % this.totalFrames),
                    (this._completedLoop = !0),
                    this.trigger("loopComplete")))
                : this.setCurrentRawFrameValue(et)
              : et < 0
              ? this.checkSegments(et % this.totalFrames) ||
                (this.loop && !(this.playCount-- <= 0 && this.loop !== !0)
                  ? (this.setCurrentRawFrameValue(
                      this.totalFrames + (et % this.totalFrames)
                    ),
                    this._completedLoop
                      ? this.trigger("loopComplete")
                      : (this._completedLoop = !0))
                  : ((nt = !0), (et = 0)))
              : this.setCurrentRawFrameValue(et),
              nt &&
                (this.setCurrentRawFrameValue(et),
                this.pause(),
                this.trigger("complete"));
          }
        }),
        (AnimationItem.prototype.adjustSegment = function (tt, et) {
          (this.playCount = 0),
            tt[1] < tt[0]
              ? (this.frameModifier > 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(-1)),
                (this.totalFrames = tt[0] - tt[1]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = tt[1]),
                this.setCurrentRawFrameValue(this.totalFrames - 0.001 - et))
              : tt[1] > tt[0] &&
                (this.frameModifier < 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(1)),
                (this.totalFrames = tt[1] - tt[0]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = tt[0]),
                this.setCurrentRawFrameValue(0.001 + et)),
            this.trigger("segmentStart");
        }),
        (AnimationItem.prototype.setSegment = function (tt, et) {
          var nt = -1;
          this.isPaused &&
            (this.currentRawFrame + this.firstFrame < tt
              ? (nt = tt)
              : this.currentRawFrame + this.firstFrame > et && (nt = et - tt)),
            (this.firstFrame = tt),
            (this.totalFrames = et - tt),
            (this.timeCompleted = this.totalFrames),
            nt !== -1 && this.goToAndStop(nt, !0);
        }),
        (AnimationItem.prototype.playSegments = function (tt, et) {
          if (
            (et && (this.segments.length = 0), _typeof$4(tt[0]) === "object")
          ) {
            var nt,
              rt = tt.length;
            for (nt = 0; nt < rt; nt += 1) this.segments.push(tt[nt]);
          } else this.segments.push(tt);
          this.segments.length &&
            et &&
            this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play();
        }),
        (AnimationItem.prototype.resetSegments = function (tt) {
          (this.segments.length = 0),
            this.segments.push([this.animationData.ip, this.animationData.op]),
            tt && this.checkSegments(0);
        }),
        (AnimationItem.prototype.checkSegments = function (tt) {
          return this.segments.length
            ? (this.adjustSegment(this.segments.shift(), tt), !0)
            : !1;
        }),
        (AnimationItem.prototype.destroy = function (tt) {
          (tt && this.name !== tt) ||
            !this.renderer ||
            (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            (this._cbs = null),
            (this.onEnterFrame = null),
            (this.onLoopComplete = null),
            (this.onComplete = null),
            (this.onSegmentStart = null),
            (this.onDestroy = null),
            (this.renderer = null),
            (this.expressionsPlugin = null),
            (this.imagePreloader = null),
            (this.projectInterface = null));
        }),
        (AnimationItem.prototype.setCurrentRawFrameValue = function (tt) {
          (this.currentRawFrame = tt), this.gotoFrame();
        }),
        (AnimationItem.prototype.setSpeed = function (tt) {
          (this.playSpeed = tt), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setDirection = function (tt) {
          (this.playDirection = tt < 0 ? -1 : 1), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setLoop = function (tt) {
          this.loop = tt;
        }),
        (AnimationItem.prototype.setVolume = function (tt, et) {
          (et && this.name !== et) || this.audioController.setVolume(tt);
        }),
        (AnimationItem.prototype.getVolume = function () {
          return this.audioController.getVolume();
        }),
        (AnimationItem.prototype.mute = function (tt) {
          (tt && this.name !== tt) || this.audioController.mute();
        }),
        (AnimationItem.prototype.unmute = function (tt) {
          (tt && this.name !== tt) || this.audioController.unmute();
        }),
        (AnimationItem.prototype.updaFrameModifier = function () {
          (this.frameModifier =
            this.frameMult * this.playSpeed * this.playDirection),
            this.audioController.setRate(this.playSpeed * this.playDirection);
        }),
        (AnimationItem.prototype.getPath = function () {
          return this.path;
        }),
        (AnimationItem.prototype.getAssetsPath = function (tt) {
          var et = "";
          if (tt.e) et = tt.p;
          else if (this.assetsPath) {
            var nt = tt.p;
            nt.indexOf("images/") !== -1 && (nt = nt.split("/")[1]),
              (et = this.assetsPath + nt);
          } else (et = this.path), (et += tt.u ? tt.u : ""), (et += tt.p);
          return et;
        }),
        (AnimationItem.prototype.getAssetData = function (tt) {
          for (var et = 0, nt = this.assets.length; et < nt; ) {
            if (tt === this.assets[et].id) return this.assets[et];
            et += 1;
          }
          return null;
        }),
        (AnimationItem.prototype.hide = function () {
          this.renderer.hide();
        }),
        (AnimationItem.prototype.show = function () {
          this.renderer.show();
        }),
        (AnimationItem.prototype.getDuration = function (tt) {
          return tt ? this.totalFrames : this.totalFrames / this.frameRate;
        }),
        (AnimationItem.prototype.updateDocumentData = function (tt, et, nt) {
          try {
            var rt = this.renderer.getElementByPath(tt);
            rt.updateDocumentData(et, nt);
          } catch {}
        }),
        (AnimationItem.prototype.trigger = function (tt) {
          if (this._cbs && this._cbs[tt])
            switch (tt) {
              case "enterFrame":
                this.triggerEvent(
                  tt,
                  new BMEnterFrameEvent(
                    tt,
                    this.currentFrame,
                    this.totalFrames,
                    this.frameModifier
                  )
                );
                break;
              case "drawnFrame":
                (this.drawnFrameEvent.currentTime = this.currentFrame),
                  (this.drawnFrameEvent.totalTime = this.totalFrames),
                  (this.drawnFrameEvent.direction = this.frameModifier),
                  this.triggerEvent(tt, this.drawnFrameEvent);
                break;
              case "loopComplete":
                this.triggerEvent(
                  tt,
                  new BMCompleteLoopEvent(
                    tt,
                    this.loop,
                    this.playCount,
                    this.frameMult
                  )
                );
                break;
              case "complete":
                this.triggerEvent(tt, new BMCompleteEvent(tt, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(
                  tt,
                  new BMSegmentStartEvent(tt, this.firstFrame, this.totalFrames)
                );
                break;
              case "destroy":
                this.triggerEvent(tt, new BMDestroyEvent(tt, this));
                break;
              default:
                this.triggerEvent(tt);
            }
          tt === "enterFrame" &&
            this.onEnterFrame &&
            this.onEnterFrame.call(
              this,
              new BMEnterFrameEvent(
                tt,
                this.currentFrame,
                this.totalFrames,
                this.frameMult
              )
            ),
            tt === "loopComplete" &&
              this.onLoopComplete &&
              this.onLoopComplete.call(
                this,
                new BMCompleteLoopEvent(
                  tt,
                  this.loop,
                  this.playCount,
                  this.frameMult
                )
              ),
            tt === "complete" &&
              this.onComplete &&
              this.onComplete.call(
                this,
                new BMCompleteEvent(tt, this.frameMult)
              ),
            tt === "segmentStart" &&
              this.onSegmentStart &&
              this.onSegmentStart.call(
                this,
                new BMSegmentStartEvent(tt, this.firstFrame, this.totalFrames)
              ),
            tt === "destroy" &&
              this.onDestroy &&
              this.onDestroy.call(this, new BMDestroyEvent(tt, this));
        }),
        (AnimationItem.prototype.triggerRenderFrameError = function (tt) {
          var et = new BMRenderFrameErrorEvent(tt, this.currentFrame);
          this.triggerEvent("error", et),
            this.onError && this.onError.call(this, et);
        }),
        (AnimationItem.prototype.triggerConfigError = function (tt) {
          var et = new BMConfigErrorEvent(tt, this.currentFrame);
          this.triggerEvent("error", et),
            this.onError && this.onError.call(this, et);
        });
      var animationManager = (function () {
          var tt = {},
            et = [],
            nt = 0,
            rt = 0,
            it = 0,
            st = !0,
            ot = !1;
          function at(kt) {
            for (var Gt = 0, Pt = kt.target; Gt < rt; )
              et[Gt].animation === Pt &&
                (et.splice(Gt, 1), (Gt -= 1), (rt -= 1), Pt.isPaused || ft()),
                (Gt += 1);
          }
          function lt(kt, Gt) {
            if (!kt) return null;
            for (var Pt = 0; Pt < rt; ) {
              if (et[Pt].elem === kt && et[Pt].elem !== null)
                return et[Pt].animation;
              Pt += 1;
            }
            var Rt = new AnimationItem();
            return ht(Rt, kt), Rt.setData(kt, Gt), Rt;
          }
          function ct() {
            var kt,
              Gt = et.length,
              Pt = [];
            for (kt = 0; kt < Gt; kt += 1) Pt.push(et[kt].animation);
            return Pt;
          }
          function ut() {
            (it += 1), Ft();
          }
          function ft() {
            it -= 1;
          }
          function ht(kt, Gt) {
            kt.addEventListener("destroy", at),
              kt.addEventListener("_active", ut),
              kt.addEventListener("_idle", ft),
              et.push({ elem: Gt, animation: kt }),
              (rt += 1);
          }
          function mt(kt) {
            var Gt = new AnimationItem();
            return ht(Gt, null), Gt.setParams(kt), Gt;
          }
          function vt(kt, Gt) {
            var Pt;
            for (Pt = 0; Pt < rt; Pt += 1) et[Pt].animation.setSpeed(kt, Gt);
          }
          function yt(kt, Gt) {
            var Pt;
            for (Pt = 0; Pt < rt; Pt += 1)
              et[Pt].animation.setDirection(kt, Gt);
          }
          function Et(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.play(kt);
          }
          function pt(kt) {
            var Gt = kt - nt,
              Pt;
            for (Pt = 0; Pt < rt; Pt += 1) et[Pt].animation.advanceTime(Gt);
            (nt = kt), it && !ot ? window.requestAnimationFrame(pt) : (st = !0);
          }
          function xt(kt) {
            (nt = kt), window.requestAnimationFrame(pt);
          }
          function St(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.pause(kt);
          }
          function At(kt, Gt, Pt) {
            var Rt;
            for (Rt = 0; Rt < rt; Rt += 1)
              et[Rt].animation.goToAndStop(kt, Gt, Pt);
          }
          function Ct(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.stop(kt);
          }
          function Mt(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.togglePause(kt);
          }
          function wt(kt) {
            var Gt;
            for (Gt = rt - 1; Gt >= 0; Gt -= 1) et[Gt].animation.destroy(kt);
          }
          function Bt(kt, Gt, Pt) {
            var Rt = [].concat(
                [].slice.call(document.getElementsByClassName("lottie")),
                [].slice.call(document.getElementsByClassName("bodymovin"))
              ),
              Nt,
              Dt = Rt.length;
            for (Nt = 0; Nt < Dt; Nt += 1)
              Pt && Rt[Nt].setAttribute("data-bm-type", Pt), lt(Rt[Nt], kt);
            if (Gt && Dt === 0) {
              Pt || (Pt = "svg");
              var zt = document.getElementsByTagName("body")[0];
              zt.innerText = "";
              var Yt = createTag("div");
              (Yt.style.width = "100%"),
                (Yt.style.height = "100%"),
                Yt.setAttribute("data-bm-type", Pt),
                zt.appendChild(Yt),
                lt(Yt, kt);
            }
          }
          function It() {
            var kt;
            for (kt = 0; kt < rt; kt += 1) et[kt].animation.resize();
          }
          function Ft() {
            !ot && it && st && (window.requestAnimationFrame(xt), (st = !1));
          }
          function Vt() {
            ot = !0;
          }
          function $t() {
            (ot = !1), Ft();
          }
          function Kt(kt, Gt) {
            var Pt;
            for (Pt = 0; Pt < rt; Pt += 1) et[Pt].animation.setVolume(kt, Gt);
          }
          function Ht(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.mute(kt);
          }
          function Wt(kt) {
            var Gt;
            for (Gt = 0; Gt < rt; Gt += 1) et[Gt].animation.unmute(kt);
          }
          return (
            (tt.registerAnimation = lt),
            (tt.loadAnimation = mt),
            (tt.setSpeed = vt),
            (tt.setDirection = yt),
            (tt.play = Et),
            (tt.pause = St),
            (tt.stop = Ct),
            (tt.togglePause = Mt),
            (tt.searchAnimations = Bt),
            (tt.resize = It),
            (tt.goToAndStop = At),
            (tt.destroy = wt),
            (tt.freeze = Vt),
            (tt.unfreeze = $t),
            (tt.setVolume = Kt),
            (tt.mute = Ht),
            (tt.unmute = Wt),
            (tt.getRegisteredAnimations = ct),
            tt
          );
        })(),
        BezierFactory = (function () {
          var tt = {};
          tt.getBezierEasing = nt;
          var et = {};
          function nt(xt, St, At, Ct, Mt) {
            var wt =
              Mt ||
              ("bez_" + xt + "_" + St + "_" + At + "_" + Ct).replace(
                /\./g,
                "p"
              );
            if (et[wt]) return et[wt];
            var Bt = new pt([xt, St, At, Ct]);
            return (et[wt] = Bt), Bt;
          }
          var rt = 4,
            it = 0.001,
            st = 1e-7,
            ot = 10,
            at = 11,
            lt = 1 / (at - 1),
            ct = typeof Float32Array == "function";
          function ut(xt, St) {
            return 1 - 3 * St + 3 * xt;
          }
          function ft(xt, St) {
            return 3 * St - 6 * xt;
          }
          function ht(xt) {
            return 3 * xt;
          }
          function mt(xt, St, At) {
            return ((ut(St, At) * xt + ft(St, At)) * xt + ht(St)) * xt;
          }
          function vt(xt, St, At) {
            return 3 * ut(St, At) * xt * xt + 2 * ft(St, At) * xt + ht(St);
          }
          function yt(xt, St, At, Ct, Mt) {
            var wt,
              Bt,
              It = 0;
            do
              (Bt = St + (At - St) / 2),
                (wt = mt(Bt, Ct, Mt) - xt),
                wt > 0 ? (At = Bt) : (St = Bt);
            while (Math.abs(wt) > st && ++It < ot);
            return Bt;
          }
          function Et(xt, St, At, Ct) {
            for (var Mt = 0; Mt < rt; ++Mt) {
              var wt = vt(St, At, Ct);
              if (wt === 0) return St;
              var Bt = mt(St, At, Ct) - xt;
              St -= Bt / wt;
            }
            return St;
          }
          function pt(xt) {
            (this._p = xt),
              (this._mSampleValues = ct ? new Float32Array(at) : new Array(at)),
              (this._precomputed = !1),
              (this.get = this.get.bind(this));
          }
          return (
            (pt.prototype = {
              get: function (St) {
                var At = this._p[0],
                  Ct = this._p[1],
                  Mt = this._p[2],
                  wt = this._p[3];
                return (
                  this._precomputed || this._precompute(),
                  At === Ct && Mt === wt
                    ? St
                    : St === 0
                    ? 0
                    : St === 1
                    ? 1
                    : mt(this._getTForX(St), Ct, wt)
                );
              },
              _precompute: function () {
                var St = this._p[0],
                  At = this._p[1],
                  Ct = this._p[2],
                  Mt = this._p[3];
                (this._precomputed = !0),
                  (St !== At || Ct !== Mt) && this._calcSampleValues();
              },
              _calcSampleValues: function () {
                for (
                  var St = this._p[0], At = this._p[2], Ct = 0;
                  Ct < at;
                  ++Ct
                )
                  this._mSampleValues[Ct] = mt(Ct * lt, St, At);
              },
              _getTForX: function (St) {
                for (
                  var At = this._p[0],
                    Ct = this._p[2],
                    Mt = this._mSampleValues,
                    wt = 0,
                    Bt = 1,
                    It = at - 1;
                  Bt !== It && Mt[Bt] <= St;
                  ++Bt
                )
                  wt += lt;
                --Bt;
                var Ft = (St - Mt[Bt]) / (Mt[Bt + 1] - Mt[Bt]),
                  Vt = wt + Ft * lt,
                  $t = vt(Vt, At, Ct);
                return $t >= it
                  ? Et(St, Vt, At, Ct)
                  : $t === 0
                  ? Vt
                  : yt(St, wt, wt + lt, At, Ct);
              },
            }),
            tt
          );
        })(),
        pooling = (function () {
          function tt(et) {
            return et.concat(createSizedArray(et.length));
          }
          return { double: tt };
        })(),
        poolFactory = (function () {
          return function (tt, et, nt) {
            var rt = 0,
              it = tt,
              st = createSizedArray(it),
              ot = { newElement: at, release: lt };
            function at() {
              var ct;
              return rt ? ((rt -= 1), (ct = st[rt])) : (ct = et()), ct;
            }
            function lt(ct) {
              rt === it && ((st = pooling.double(st)), (it *= 2)),
                nt && nt(ct),
                (st[rt] = ct),
                (rt += 1);
            }
            return ot;
          };
        })(),
        bezierLengthPool = (function () {
          function tt() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments()),
            };
          }
          return poolFactory(8, tt);
        })(),
        segmentsLengthPool = (function () {
          function tt() {
            return { lengths: [], totalLength: 0 };
          }
          function et(nt) {
            var rt,
              it = nt.lengths.length;
            for (rt = 0; rt < it; rt += 1)
              bezierLengthPool.release(nt.lengths[rt]);
            nt.lengths.length = 0;
          }
          return poolFactory(8, tt, et);
        })();
      function bezFunction() {
        var tt = Math;
        function et(ht, mt, vt, yt, Et, pt) {
          var xt = ht * yt + mt * Et + vt * pt - Et * yt - pt * ht - vt * mt;
          return xt > -0.001 && xt < 0.001;
        }
        function nt(ht, mt, vt, yt, Et, pt, xt, St, At) {
          if (vt === 0 && pt === 0 && At === 0)
            return et(ht, mt, yt, Et, xt, St);
          var Ct = tt.sqrt(
              tt.pow(yt - ht, 2) + tt.pow(Et - mt, 2) + tt.pow(pt - vt, 2)
            ),
            Mt = tt.sqrt(
              tt.pow(xt - ht, 2) + tt.pow(St - mt, 2) + tt.pow(At - vt, 2)
            ),
            wt = tt.sqrt(
              tt.pow(xt - yt, 2) + tt.pow(St - Et, 2) + tt.pow(At - pt, 2)
            ),
            Bt;
          return (
            Ct > Mt
              ? Ct > wt
                ? (Bt = Ct - Mt - wt)
                : (Bt = wt - Mt - Ct)
              : wt > Mt
              ? (Bt = wt - Mt - Ct)
              : (Bt = Mt - Ct - wt),
            Bt > -1e-4 && Bt < 1e-4
          );
        }
        var rt = (function () {
          return function (ht, mt, vt, yt) {
            var Et = getDefaultCurveSegments(),
              pt,
              xt,
              St,
              At,
              Ct,
              Mt = 0,
              wt,
              Bt = [],
              It = [],
              Ft = bezierLengthPool.newElement();
            for (St = vt.length, pt = 0; pt < Et; pt += 1) {
              for (Ct = pt / (Et - 1), wt = 0, xt = 0; xt < St; xt += 1)
                (At =
                  bmPow(1 - Ct, 3) * ht[xt] +
                  3 * bmPow(1 - Ct, 2) * Ct * vt[xt] +
                  3 * (1 - Ct) * bmPow(Ct, 2) * yt[xt] +
                  bmPow(Ct, 3) * mt[xt]),
                  (Bt[xt] = At),
                  It[xt] !== null && (wt += bmPow(Bt[xt] - It[xt], 2)),
                  (It[xt] = Bt[xt]);
              wt && ((wt = bmSqrt(wt)), (Mt += wt)),
                (Ft.percents[pt] = Ct),
                (Ft.lengths[pt] = Mt);
            }
            return (Ft.addedLength = Mt), Ft;
          };
        })();
        function it(ht) {
          var mt = segmentsLengthPool.newElement(),
            vt = ht.c,
            yt = ht.v,
            Et = ht.o,
            pt = ht.i,
            xt,
            St = ht._length,
            At = mt.lengths,
            Ct = 0;
          for (xt = 0; xt < St - 1; xt += 1)
            (At[xt] = rt(yt[xt], yt[xt + 1], Et[xt], pt[xt + 1])),
              (Ct += At[xt].addedLength);
          return (
            vt &&
              St &&
              ((At[xt] = rt(yt[xt], yt[0], Et[xt], pt[0])),
              (Ct += At[xt].addedLength)),
            (mt.totalLength = Ct),
            mt
          );
        }
        function st(ht) {
          (this.segmentLength = 0), (this.points = new Array(ht));
        }
        function ot(ht, mt) {
          (this.partialLength = ht), (this.point = mt);
        }
        var at = (function () {
          var ht = {};
          return function (mt, vt, yt, Et) {
            var pt = (
              mt[0] +
              "_" +
              mt[1] +
              "_" +
              vt[0] +
              "_" +
              vt[1] +
              "_" +
              yt[0] +
              "_" +
              yt[1] +
              "_" +
              Et[0] +
              "_" +
              Et[1]
            ).replace(/\./g, "p");
            if (!ht[pt]) {
              var xt = getDefaultCurveSegments(),
                St,
                At,
                Ct,
                Mt,
                wt,
                Bt = 0,
                It,
                Ft,
                Vt = null;
              mt.length === 2 &&
                (mt[0] !== vt[0] || mt[1] !== vt[1]) &&
                et(mt[0], mt[1], vt[0], vt[1], mt[0] + yt[0], mt[1] + yt[1]) &&
                et(mt[0], mt[1], vt[0], vt[1], vt[0] + Et[0], vt[1] + Et[1]) &&
                (xt = 2);
              var $t = new st(xt);
              for (Ct = yt.length, St = 0; St < xt; St += 1) {
                for (
                  Ft = createSizedArray(Ct), wt = St / (xt - 1), It = 0, At = 0;
                  At < Ct;
                  At += 1
                )
                  (Mt =
                    bmPow(1 - wt, 3) * mt[At] +
                    3 * bmPow(1 - wt, 2) * wt * (mt[At] + yt[At]) +
                    3 * (1 - wt) * bmPow(wt, 2) * (vt[At] + Et[At]) +
                    bmPow(wt, 3) * vt[At]),
                    (Ft[At] = Mt),
                    Vt !== null && (It += bmPow(Ft[At] - Vt[At], 2));
                (It = bmSqrt(It)),
                  (Bt += It),
                  ($t.points[St] = new ot(It, Ft)),
                  (Vt = Ft);
              }
              ($t.segmentLength = Bt), (ht[pt] = $t);
            }
            return ht[pt];
          };
        })();
        function lt(ht, mt) {
          var vt = mt.percents,
            yt = mt.lengths,
            Et = vt.length,
            pt = bmFloor((Et - 1) * ht),
            xt = ht * mt.addedLength,
            St = 0;
          if (pt === Et - 1 || pt === 0 || xt === yt[pt]) return vt[pt];
          for (var At = yt[pt] > xt ? -1 : 1, Ct = !0; Ct; )
            if (
              (yt[pt] <= xt && yt[pt + 1] > xt
                ? ((St = (xt - yt[pt]) / (yt[pt + 1] - yt[pt])), (Ct = !1))
                : (pt += At),
              pt < 0 || pt >= Et - 1)
            ) {
              if (pt === Et - 1) return vt[pt];
              Ct = !1;
            }
          return vt[pt] + (vt[pt + 1] - vt[pt]) * St;
        }
        function ct(ht, mt, vt, yt, Et, pt) {
          var xt = lt(Et, pt),
            St = 1 - xt,
            At =
              tt.round(
                (St * St * St * ht[0] +
                  (xt * St * St + St * xt * St + St * St * xt) * vt[0] +
                  (xt * xt * St + St * xt * xt + xt * St * xt) * yt[0] +
                  xt * xt * xt * mt[0]) *
                  1e3
              ) / 1e3,
            Ct =
              tt.round(
                (St * St * St * ht[1] +
                  (xt * St * St + St * xt * St + St * St * xt) * vt[1] +
                  (xt * xt * St + St * xt * xt + xt * St * xt) * yt[1] +
                  xt * xt * xt * mt[1]) *
                  1e3
              ) / 1e3;
          return [At, Ct];
        }
        var ut = createTypedArray("float32", 8);
        function ft(ht, mt, vt, yt, Et, pt, xt) {
          Et < 0 ? (Et = 0) : Et > 1 && (Et = 1);
          var St = lt(Et, xt);
          pt = pt > 1 ? 1 : pt;
          var At = lt(pt, xt),
            Ct,
            Mt = ht.length,
            wt = 1 - St,
            Bt = 1 - At,
            It = wt * wt * wt,
            Ft = St * wt * wt * 3,
            Vt = St * St * wt * 3,
            $t = St * St * St,
            Kt = wt * wt * Bt,
            Ht = St * wt * Bt + wt * St * Bt + wt * wt * At,
            Wt = St * St * Bt + wt * St * At + St * wt * At,
            kt = St * St * At,
            Gt = wt * Bt * Bt,
            Pt = St * Bt * Bt + wt * At * Bt + wt * Bt * At,
            Rt = St * At * Bt + wt * At * At + St * Bt * At,
            Nt = St * At * At,
            Dt = Bt * Bt * Bt,
            zt = At * Bt * Bt + Bt * At * Bt + Bt * Bt * At,
            Yt = At * At * Bt + Bt * At * At + At * Bt * At,
            qt = At * At * At;
          for (Ct = 0; Ct < Mt; Ct += 1)
            (ut[Ct * 4] =
              tt.round(
                (It * ht[Ct] + Ft * vt[Ct] + Vt * yt[Ct] + $t * mt[Ct]) * 1e3
              ) / 1e3),
              (ut[Ct * 4 + 1] =
                tt.round(
                  (Kt * ht[Ct] + Ht * vt[Ct] + Wt * yt[Ct] + kt * mt[Ct]) * 1e3
                ) / 1e3),
              (ut[Ct * 4 + 2] =
                tt.round(
                  (Gt * ht[Ct] + Pt * vt[Ct] + Rt * yt[Ct] + Nt * mt[Ct]) * 1e3
                ) / 1e3),
              (ut[Ct * 4 + 3] =
                tt.round(
                  (Dt * ht[Ct] + zt * vt[Ct] + Yt * yt[Ct] + qt * mt[Ct]) * 1e3
                ) / 1e3);
          return ut;
        }
        return {
          getSegmentsLength: it,
          getNewSegment: ft,
          getPointInSegment: ct,
          buildBezierData: at,
          pointOnLine2D: et,
          pointOnLine3D: nt,
        };
      }
      var bez = bezFunction(),
        initFrame = initialDefaultFrame,
        mathAbs = Math.abs;
      function interpolateValue(tt, et) {
        var nt = this.offsetTime,
          rt;
        this.propType === "multidimensional" &&
          (rt = createTypedArray("float32", this.pv.length));
        for (
          var it = et.lastIndex,
            st = it,
            ot = this.keyframes.length - 1,
            at = !0,
            lt,
            ct,
            ut;
          at;

        ) {
          if (
            ((lt = this.keyframes[st]),
            (ct = this.keyframes[st + 1]),
            st === ot - 1 && tt >= ct.t - nt)
          ) {
            lt.h && (lt = ct), (it = 0);
            break;
          }
          if (ct.t - nt > tt) {
            it = st;
            break;
          }
          st < ot - 1 ? (st += 1) : ((it = 0), (at = !1));
        }
        ut = this.keyframesMetadata[st] || {};
        var ft,
          ht,
          mt,
          vt,
          yt,
          Et,
          pt = ct.t - nt,
          xt = lt.t - nt,
          St;
        if (lt.to) {
          ut.bezierData ||
            (ut.bezierData = bez.buildBezierData(
              lt.s,
              ct.s || lt.e,
              lt.to,
              lt.ti
            ));
          var At = ut.bezierData;
          if (tt >= pt || tt < xt) {
            var Ct = tt >= pt ? At.points.length - 1 : 0;
            for (ht = At.points[Ct].point.length, ft = 0; ft < ht; ft += 1)
              rt[ft] = At.points[Ct].point[ft];
          } else {
            ut.__fnct
              ? (Et = ut.__fnct)
              : ((Et = BezierFactory.getBezierEasing(
                  lt.o.x,
                  lt.o.y,
                  lt.i.x,
                  lt.i.y,
                  lt.n
                ).get),
                (ut.__fnct = Et)),
              (mt = Et((tt - xt) / (pt - xt)));
            var Mt = At.segmentLength * mt,
              wt,
              Bt =
                et.lastFrame < tt && et._lastKeyframeIndex === st
                  ? et._lastAddedLength
                  : 0;
            for (
              yt =
                et.lastFrame < tt && et._lastKeyframeIndex === st
                  ? et._lastPoint
                  : 0,
                at = !0,
                vt = At.points.length;
              at;

            ) {
              if (
                ((Bt += At.points[yt].partialLength),
                Mt === 0 || mt === 0 || yt === At.points.length - 1)
              ) {
                for (ht = At.points[yt].point.length, ft = 0; ft < ht; ft += 1)
                  rt[ft] = At.points[yt].point[ft];
                break;
              } else if (
                Mt >= Bt &&
                Mt < Bt + At.points[yt + 1].partialLength
              ) {
                for (
                  wt = (Mt - Bt) / At.points[yt + 1].partialLength,
                    ht = At.points[yt].point.length,
                    ft = 0;
                  ft < ht;
                  ft += 1
                )
                  rt[ft] =
                    At.points[yt].point[ft] +
                    (At.points[yt + 1].point[ft] - At.points[yt].point[ft]) *
                      wt;
                break;
              }
              yt < vt - 1 ? (yt += 1) : (at = !1);
            }
            (et._lastPoint = yt),
              (et._lastAddedLength = Bt - At.points[yt].partialLength),
              (et._lastKeyframeIndex = st);
          }
        } else {
          var It, Ft, Vt, $t, Kt;
          if (((ot = lt.s.length), (St = ct.s || lt.e), this.sh && lt.h !== 1))
            if (tt >= pt) (rt[0] = St[0]), (rt[1] = St[1]), (rt[2] = St[2]);
            else if (tt <= xt)
              (rt[0] = lt.s[0]), (rt[1] = lt.s[1]), (rt[2] = lt.s[2]);
            else {
              var Ht = createQuaternion(lt.s),
                Wt = createQuaternion(St),
                kt = (tt - xt) / (pt - xt);
              quaternionToEuler(rt, slerp(Ht, Wt, kt));
            }
          else
            for (st = 0; st < ot; st += 1)
              lt.h !== 1 &&
                (tt >= pt
                  ? (mt = 1)
                  : tt < xt
                  ? (mt = 0)
                  : (lt.o.x.constructor === Array
                      ? (ut.__fnct || (ut.__fnct = []),
                        ut.__fnct[st]
                          ? (Et = ut.__fnct[st])
                          : ((It =
                              lt.o.x[st] === void 0 ? lt.o.x[0] : lt.o.x[st]),
                            (Ft =
                              lt.o.y[st] === void 0 ? lt.o.y[0] : lt.o.y[st]),
                            (Vt =
                              lt.i.x[st] === void 0 ? lt.i.x[0] : lt.i.x[st]),
                            ($t =
                              lt.i.y[st] === void 0 ? lt.i.y[0] : lt.i.y[st]),
                            (Et = BezierFactory.getBezierEasing(
                              It,
                              Ft,
                              Vt,
                              $t
                            ).get),
                            (ut.__fnct[st] = Et)))
                      : ut.__fnct
                      ? (Et = ut.__fnct)
                      : ((It = lt.o.x),
                        (Ft = lt.o.y),
                        (Vt = lt.i.x),
                        ($t = lt.i.y),
                        (Et = BezierFactory.getBezierEasing(
                          It,
                          Ft,
                          Vt,
                          $t
                        ).get),
                        (lt.keyframeMetadata = Et)),
                    (mt = Et((tt - xt) / (pt - xt))))),
                (St = ct.s || lt.e),
                (Kt =
                  lt.h === 1 ? lt.s[st] : lt.s[st] + (St[st] - lt.s[st]) * mt),
                this.propType === "multidimensional"
                  ? (rt[st] = Kt)
                  : (rt = Kt);
        }
        return (et.lastIndex = it), rt;
      }
      function slerp(tt, et, nt) {
        var rt = [],
          it = tt[0],
          st = tt[1],
          ot = tt[2],
          at = tt[3],
          lt = et[0],
          ct = et[1],
          ut = et[2],
          ft = et[3],
          ht,
          mt,
          vt,
          yt,
          Et;
        return (
          (mt = it * lt + st * ct + ot * ut + at * ft),
          mt < 0 &&
            ((mt = -mt), (lt = -lt), (ct = -ct), (ut = -ut), (ft = -ft)),
          1 - mt > 1e-6
            ? ((ht = Math.acos(mt)),
              (vt = Math.sin(ht)),
              (yt = Math.sin((1 - nt) * ht) / vt),
              (Et = Math.sin(nt * ht) / vt))
            : ((yt = 1 - nt), (Et = nt)),
          (rt[0] = yt * it + Et * lt),
          (rt[1] = yt * st + Et * ct),
          (rt[2] = yt * ot + Et * ut),
          (rt[3] = yt * at + Et * ft),
          rt
        );
      }
      function quaternionToEuler(tt, et) {
        var nt = et[0],
          rt = et[1],
          it = et[2],
          st = et[3],
          ot = Math.atan2(
            2 * rt * st - 2 * nt * it,
            1 - 2 * rt * rt - 2 * it * it
          ),
          at = Math.asin(2 * nt * rt + 2 * it * st),
          lt = Math.atan2(
            2 * nt * st - 2 * rt * it,
            1 - 2 * nt * nt - 2 * it * it
          );
        (tt[0] = ot / degToRads),
          (tt[1] = at / degToRads),
          (tt[2] = lt / degToRads);
      }
      function createQuaternion(tt) {
        var et = tt[0] * degToRads,
          nt = tt[1] * degToRads,
          rt = tt[2] * degToRads,
          it = Math.cos(et / 2),
          st = Math.cos(nt / 2),
          ot = Math.cos(rt / 2),
          at = Math.sin(et / 2),
          lt = Math.sin(nt / 2),
          ct = Math.sin(rt / 2),
          ut = it * st * ot - at * lt * ct,
          ft = at * lt * ot + it * st * ct,
          ht = at * st * ot + it * lt * ct,
          mt = it * lt * ot - at * st * ct;
        return [ft, ht, mt, ut];
      }
      function getValueAtCurrentTime() {
        var tt = this.comp.renderedFrame - this.offsetTime,
          et = this.keyframes[0].t - this.offsetTime,
          nt = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (
          !(
            tt === this._caching.lastFrame ||
            (this._caching.lastFrame !== initFrame &&
              ((this._caching.lastFrame >= nt && tt >= nt) ||
                (this._caching.lastFrame < et && tt < et)))
          )
        ) {
          this._caching.lastFrame >= tt &&
            ((this._caching._lastKeyframeIndex = -1),
            (this._caching.lastIndex = 0));
          var rt = this.interpolateValue(tt, this._caching);
          this.pv = rt;
        }
        return (this._caching.lastFrame = tt), this.pv;
      }
      function setVValue(tt) {
        var et;
        if (this.propType === "unidimensional")
          (et = tt * this.mult),
            mathAbs(this.v - et) > 1e-5 && ((this.v = et), (this._mdf = !0));
        else
          for (var nt = 0, rt = this.v.length; nt < rt; )
            (et = tt[nt] * this.mult),
              mathAbs(this.v[nt] - et) > 1e-5 &&
                ((this.v[nt] = et), (this._mdf = !0)),
              (nt += 1);
      }
      function processEffectsSequence() {
        if (
          !(
            this.elem.globalData.frameId === this.frameId ||
            !this.effectsSequence.length
          )
        ) {
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          (this.lock = !0), (this._mdf = this._isFirstFrame);
          var tt,
            et = this.effectsSequence.length,
            nt = this.kf ? this.pv : this.data.k;
          for (tt = 0; tt < et; tt += 1) nt = this.effectsSequence[tt](nt);
          this.setVValue(nt),
            (this._isFirstFrame = !1),
            (this.lock = !1),
            (this.frameId = this.elem.globalData.frameId);
        }
      }
      function addEffect(tt) {
        this.effectsSequence.push(tt), this.container.addDynamicProperty(this);
      }
      function ValueProperty(tt, et, nt, rt) {
        (this.propType = "unidimensional"),
          (this.mult = nt || 1),
          (this.data = et),
          (this.v = nt ? et.k * nt : et.k),
          (this.pv = et.k),
          (this._mdf = !1),
          (this.elem = tt),
          (this.container = rt),
          (this.comp = tt.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.vel = 0),
          (this.effectsSequence = []),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function MultiDimensionalProperty(tt, et, nt, rt) {
        (this.propType = "multidimensional"),
          (this.mult = nt || 1),
          (this.data = et),
          (this._mdf = !1),
          (this.elem = tt),
          (this.container = rt),
          (this.comp = tt.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.frameId = -1);
        var it,
          st = et.k.length;
        for (
          this.v = createTypedArray("float32", st),
            this.pv = createTypedArray("float32", st),
            this.vel = createTypedArray("float32", st),
            it = 0;
          it < st;
          it += 1
        )
          (this.v[it] = et.k[it] * this.mult), (this.pv[it] = et.k[it]);
        (this._isFirstFrame = !0),
          (this.effectsSequence = []),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function KeyframedValueProperty(tt, et, nt, rt) {
        (this.propType = "unidimensional"),
          (this.keyframes = et.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = tt.data.st),
          (this.frameId = -1),
          (this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1,
          }),
          (this.k = !0),
          (this.kf = !0),
          (this.data = et),
          (this.mult = nt || 1),
          (this.elem = tt),
          (this.container = rt),
          (this.comp = tt.comp),
          (this.v = initFrame),
          (this.pv = initFrame),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.addEffect = addEffect);
      }
      function KeyframedMultidimensionalProperty(tt, et, nt, rt) {
        this.propType = "multidimensional";
        var it,
          st = et.k.length,
          ot,
          at,
          lt,
          ct;
        for (it = 0; it < st - 1; it += 1)
          et.k[it].to &&
            et.k[it].s &&
            et.k[it + 1] &&
            et.k[it + 1].s &&
            ((ot = et.k[it].s),
            (at = et.k[it + 1].s),
            (lt = et.k[it].to),
            (ct = et.k[it].ti),
            ((ot.length === 2 &&
              !(ot[0] === at[0] && ot[1] === at[1]) &&
              bez.pointOnLine2D(
                ot[0],
                ot[1],
                at[0],
                at[1],
                ot[0] + lt[0],
                ot[1] + lt[1]
              ) &&
              bez.pointOnLine2D(
                ot[0],
                ot[1],
                at[0],
                at[1],
                at[0] + ct[0],
                at[1] + ct[1]
              )) ||
              (ot.length === 3 &&
                !(ot[0] === at[0] && ot[1] === at[1] && ot[2] === at[2]) &&
                bez.pointOnLine3D(
                  ot[0],
                  ot[1],
                  ot[2],
                  at[0],
                  at[1],
                  at[2],
                  ot[0] + lt[0],
                  ot[1] + lt[1],
                  ot[2] + lt[2]
                ) &&
                bez.pointOnLine3D(
                  ot[0],
                  ot[1],
                  ot[2],
                  at[0],
                  at[1],
                  at[2],
                  at[0] + ct[0],
                  at[1] + ct[1],
                  at[2] + ct[2]
                ))) &&
              ((et.k[it].to = null), (et.k[it].ti = null)),
            ot[0] === at[0] &&
              ot[1] === at[1] &&
              lt[0] === 0 &&
              lt[1] === 0 &&
              ct[0] === 0 &&
              ct[1] === 0 &&
              (ot.length === 2 ||
                (ot[2] === at[2] && lt[2] === 0 && ct[2] === 0)) &&
              ((et.k[it].to = null), (et.k[it].ti = null)));
        (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.data = et),
          (this.keyframes = et.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = tt.data.st),
          (this.k = !0),
          (this.kf = !0),
          (this._isFirstFrame = !0),
          (this.mult = nt || 1),
          (this.elem = tt),
          (this.container = rt),
          (this.comp = tt.comp),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.frameId = -1);
        var ut = et.k[0].s.length;
        for (
          this.v = createTypedArray("float32", ut),
            this.pv = createTypedArray("float32", ut),
            it = 0;
          it < ut;
          it += 1
        )
          (this.v[it] = initFrame), (this.pv[it] = initFrame);
        (this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", ut),
        }),
          (this.addEffect = addEffect);
      }
      var PropertyFactory = (function () {
        function tt(nt, rt, it, st, ot) {
          rt.sid && (rt = nt.globalData.slotManager.getProp(rt));
          var at;
          if (!rt.k.length) at = new ValueProperty(nt, rt, st, ot);
          else if (typeof rt.k[0] == "number")
            at = new MultiDimensionalProperty(nt, rt, st, ot);
          else
            switch (it) {
              case 0:
                at = new KeyframedValueProperty(nt, rt, st, ot);
                break;
              case 1:
                at = new KeyframedMultidimensionalProperty(nt, rt, st, ot);
                break;
            }
          return at.effectsSequence.length && ot.addDynamicProperty(at), at;
        }
        var et = { getProp: tt };
        return et;
      })();
      function DynamicPropertyContainer() {}
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function (et) {
          this.dynamicProperties.indexOf(et) === -1 &&
            (this.dynamicProperties.push(et),
            this.container.addDynamicProperty(this),
            (this._isAnimated = !0));
        },
        iterateDynamicProperties: function () {
          this._mdf = !1;
          var et,
            nt = this.dynamicProperties.length;
          for (et = 0; et < nt; et += 1)
            this.dynamicProperties[et].getValue(),
              this.dynamicProperties[et]._mdf && (this._mdf = !0);
        },
        initDynamicPropertyContainer: function (et) {
          (this.container = et),
            (this.dynamicProperties = []),
            (this._mdf = !1),
            (this._isAnimated = !1);
        },
      };
      var pointPool = (function () {
        function tt() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, tt);
      })();
      function ShapePath() {
        (this.c = !1),
          (this._length = 0),
          (this._maxLength = 8),
          (this.v = createSizedArray(this._maxLength)),
          (this.o = createSizedArray(this._maxLength)),
          (this.i = createSizedArray(this._maxLength));
      }
      (ShapePath.prototype.setPathData = function (tt, et) {
        (this.c = tt), this.setLength(et);
        for (var nt = 0; nt < et; )
          (this.v[nt] = pointPool.newElement()),
            (this.o[nt] = pointPool.newElement()),
            (this.i[nt] = pointPool.newElement()),
            (nt += 1);
      }),
        (ShapePath.prototype.setLength = function (tt) {
          for (; this._maxLength < tt; ) this.doubleArrayLength();
          this._length = tt;
        }),
        (ShapePath.prototype.doubleArrayLength = function () {
          (this.v = this.v.concat(createSizedArray(this._maxLength))),
            (this.i = this.i.concat(createSizedArray(this._maxLength))),
            (this.o = this.o.concat(createSizedArray(this._maxLength))),
            (this._maxLength *= 2);
        }),
        (ShapePath.prototype.setXYAt = function (tt, et, nt, rt, it) {
          var st;
          switch (
            ((this._length = Math.max(this._length, rt + 1)),
            this._length >= this._maxLength && this.doubleArrayLength(),
            nt)
          ) {
            case "v":
              st = this.v;
              break;
            case "i":
              st = this.i;
              break;
            case "o":
              st = this.o;
              break;
            default:
              st = [];
              break;
          }
          (!st[rt] || (st[rt] && !it)) && (st[rt] = pointPool.newElement()),
            (st[rt][0] = tt),
            (st[rt][1] = et);
        }),
        (ShapePath.prototype.setTripleAt = function (
          tt,
          et,
          nt,
          rt,
          it,
          st,
          ot,
          at
        ) {
          this.setXYAt(tt, et, "v", ot, at),
            this.setXYAt(nt, rt, "o", ot, at),
            this.setXYAt(it, st, "i", ot, at);
        }),
        (ShapePath.prototype.reverse = function () {
          var tt = new ShapePath();
          tt.setPathData(this.c, this._length);
          var et = this.v,
            nt = this.o,
            rt = this.i,
            it = 0;
          this.c &&
            (tt.setTripleAt(
              et[0][0],
              et[0][1],
              rt[0][0],
              rt[0][1],
              nt[0][0],
              nt[0][1],
              0,
              !1
            ),
            (it = 1));
          var st = this._length - 1,
            ot = this._length,
            at;
          for (at = it; at < ot; at += 1)
            tt.setTripleAt(
              et[st][0],
              et[st][1],
              rt[st][0],
              rt[st][1],
              nt[st][0],
              nt[st][1],
              at,
              !1
            ),
              (st -= 1);
          return tt;
        }),
        (ShapePath.prototype.length = function () {
          return this._length;
        });
      var shapePool = (function () {
        function tt() {
          return new ShapePath();
        }
        function et(it) {
          var st = it._length,
            ot;
          for (ot = 0; ot < st; ot += 1)
            pointPool.release(it.v[ot]),
              pointPool.release(it.i[ot]),
              pointPool.release(it.o[ot]),
              (it.v[ot] = null),
              (it.i[ot] = null),
              (it.o[ot] = null);
          (it._length = 0), (it.c = !1);
        }
        function nt(it) {
          var st = rt.newElement(),
            ot,
            at = it._length === void 0 ? it.v.length : it._length;
          for (st.setLength(at), st.c = it.c, ot = 0; ot < at; ot += 1)
            st.setTripleAt(
              it.v[ot][0],
              it.v[ot][1],
              it.o[ot][0],
              it.o[ot][1],
              it.i[ot][0],
              it.i[ot][1],
              ot
            );
          return st;
        }
        var rt = poolFactory(4, tt, et);
        return (rt.clone = nt), rt;
      })();
      function ShapeCollection() {
        (this._length = 0),
          (this._maxLength = 4),
          (this.shapes = createSizedArray(this._maxLength));
      }
      (ShapeCollection.prototype.addShape = function (tt) {
        this._length === this._maxLength &&
          ((this.shapes = this.shapes.concat(
            createSizedArray(this._maxLength)
          )),
          (this._maxLength *= 2)),
          (this.shapes[this._length] = tt),
          (this._length += 1);
      }),
        (ShapeCollection.prototype.releaseShapes = function () {
          var tt;
          for (tt = 0; tt < this._length; tt += 1)
            shapePool.release(this.shapes[tt]);
          this._length = 0;
        });
      var shapeCollectionPool = (function () {
          var tt = { newShapeCollection: it, release: st },
            et = 0,
            nt = 4,
            rt = createSizedArray(nt);
          function it() {
            var ot;
            return (
              et ? ((et -= 1), (ot = rt[et])) : (ot = new ShapeCollection()), ot
            );
          }
          function st(ot) {
            var at,
              lt = ot._length;
            for (at = 0; at < lt; at += 1) shapePool.release(ot.shapes[at]);
            (ot._length = 0),
              et === nt && ((rt = pooling.double(rt)), (nt *= 2)),
              (rt[et] = ot),
              (et += 1);
          }
          return tt;
        })(),
        ShapePropertyFactory = (function () {
          var tt = -999999;
          function et(pt, xt, St) {
            var At = St.lastIndex,
              Ct,
              Mt,
              wt,
              Bt,
              It,
              Ft,
              Vt,
              $t,
              Kt,
              Ht = this.keyframes;
            if (pt < Ht[0].t - this.offsetTime)
              (Ct = Ht[0].s[0]), (wt = !0), (At = 0);
            else if (pt >= Ht[Ht.length - 1].t - this.offsetTime)
              (Ct = Ht[Ht.length - 1].s
                ? Ht[Ht.length - 1].s[0]
                : Ht[Ht.length - 2].e[0]),
                (wt = !0);
            else {
              for (
                var Wt = At, kt = Ht.length - 1, Gt = !0, Pt, Rt, Nt;
                Gt &&
                ((Pt = Ht[Wt]),
                (Rt = Ht[Wt + 1]),
                !(Rt.t - this.offsetTime > pt));

              )
                Wt < kt - 1 ? (Wt += 1) : (Gt = !1);
              if (
                ((Nt = this.keyframesMetadata[Wt] || {}),
                (wt = Pt.h === 1),
                (At = Wt),
                !wt)
              ) {
                if (pt >= Rt.t - this.offsetTime) $t = 1;
                else if (pt < Pt.t - this.offsetTime) $t = 0;
                else {
                  var Dt;
                  Nt.__fnct
                    ? (Dt = Nt.__fnct)
                    : ((Dt = BezierFactory.getBezierEasing(
                        Pt.o.x,
                        Pt.o.y,
                        Pt.i.x,
                        Pt.i.y
                      ).get),
                      (Nt.__fnct = Dt)),
                    ($t = Dt(
                      (pt - (Pt.t - this.offsetTime)) /
                        (Rt.t - this.offsetTime - (Pt.t - this.offsetTime))
                    ));
                }
                Mt = Rt.s ? Rt.s[0] : Pt.e[0];
              }
              Ct = Pt.s[0];
            }
            for (
              Ft = xt._length, Vt = Ct.i[0].length, St.lastIndex = At, Bt = 0;
              Bt < Ft;
              Bt += 1
            )
              for (It = 0; It < Vt; It += 1)
                (Kt = wt
                  ? Ct.i[Bt][It]
                  : Ct.i[Bt][It] + (Mt.i[Bt][It] - Ct.i[Bt][It]) * $t),
                  (xt.i[Bt][It] = Kt),
                  (Kt = wt
                    ? Ct.o[Bt][It]
                    : Ct.o[Bt][It] + (Mt.o[Bt][It] - Ct.o[Bt][It]) * $t),
                  (xt.o[Bt][It] = Kt),
                  (Kt = wt
                    ? Ct.v[Bt][It]
                    : Ct.v[Bt][It] + (Mt.v[Bt][It] - Ct.v[Bt][It]) * $t),
                  (xt.v[Bt][It] = Kt);
          }
          function nt() {
            var pt = this.comp.renderedFrame - this.offsetTime,
              xt = this.keyframes[0].t - this.offsetTime,
              St =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
              At = this._caching.lastFrame;
            return (
              (At !== tt && ((At < xt && pt < xt) || (At > St && pt > St))) ||
                ((this._caching.lastIndex =
                  At < pt ? this._caching.lastIndex : 0),
                this.interpolateShape(pt, this.pv, this._caching)),
              (this._caching.lastFrame = pt),
              this.pv
            );
          }
          function rt() {
            this.paths = this.localShapeCollection;
          }
          function it(pt, xt) {
            if (pt._length !== xt._length || pt.c !== xt.c) return !1;
            var St,
              At = pt._length;
            for (St = 0; St < At; St += 1)
              if (
                pt.v[St][0] !== xt.v[St][0] ||
                pt.v[St][1] !== xt.v[St][1] ||
                pt.o[St][0] !== xt.o[St][0] ||
                pt.o[St][1] !== xt.o[St][1] ||
                pt.i[St][0] !== xt.i[St][0] ||
                pt.i[St][1] !== xt.i[St][1]
              )
                return !1;
            return !0;
          }
          function st(pt) {
            it(this.v, pt) ||
              ((this.v = shapePool.clone(pt)),
              this.localShapeCollection.releaseShapes(),
              this.localShapeCollection.addShape(this.v),
              (this._mdf = !0),
              (this.paths = this.localShapeCollection));
          }
          function ot() {
            if (this.elem.globalData.frameId !== this.frameId) {
              if (!this.effectsSequence.length) {
                this._mdf = !1;
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              (this.lock = !0), (this._mdf = !1);
              var pt;
              this.kf
                ? (pt = this.pv)
                : this.data.ks
                ? (pt = this.data.ks.k)
                : (pt = this.data.pt.k);
              var xt,
                St = this.effectsSequence.length;
              for (xt = 0; xt < St; xt += 1) pt = this.effectsSequence[xt](pt);
              this.setVValue(pt),
                (this.lock = !1),
                (this.frameId = this.elem.globalData.frameId);
            }
          }
          function at(pt, xt, St) {
            (this.propType = "shape"),
              (this.comp = pt.comp),
              (this.container = pt),
              (this.elem = pt),
              (this.data = xt),
              (this.k = !1),
              (this.kf = !1),
              (this._mdf = !1);
            var At = St === 3 ? xt.pt.k : xt.ks.k;
            (this.v = shapePool.clone(At)),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.reset = rt),
              (this.effectsSequence = []);
          }
          function lt(pt) {
            this.effectsSequence.push(pt),
              this.container.addDynamicProperty(this);
          }
          (at.prototype.interpolateShape = et),
            (at.prototype.getValue = ot),
            (at.prototype.setVValue = st),
            (at.prototype.addEffect = lt);
          function ct(pt, xt, St) {
            (this.propType = "shape"),
              (this.comp = pt.comp),
              (this.elem = pt),
              (this.container = pt),
              (this.offsetTime = pt.data.st),
              (this.keyframes = St === 3 ? xt.pt.k : xt.ks.k),
              (this.keyframesMetadata = []),
              (this.k = !0),
              (this.kf = !0);
            var At = this.keyframes[0].s[0].i.length;
            (this.v = shapePool.newElement()),
              this.v.setPathData(this.keyframes[0].s[0].c, At),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.lastFrame = tt),
              (this.reset = rt),
              (this._caching = { lastFrame: tt, lastIndex: 0 }),
              (this.effectsSequence = [nt.bind(this)]);
          }
          (ct.prototype.getValue = ot),
            (ct.prototype.interpolateShape = et),
            (ct.prototype.setVValue = st),
            (ct.prototype.addEffect = lt);
          var ut = (function () {
              var pt = roundCorner;
              function xt(St, At) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 4),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  (this.paths = this.localShapeCollection),
                  this.localShapeCollection.addShape(this.v),
                  (this.d = At.d),
                  (this.elem = St),
                  (this.comp = St.comp),
                  (this.frameId = -1),
                  this.initDynamicPropertyContainer(St),
                  (this.p = PropertyFactory.getProp(St, At.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(St, At.s, 1, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertEllToPath());
              }
              return (
                (xt.prototype = {
                  reset: rt,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertEllToPath());
                  },
                  convertEllToPath: function () {
                    var At = this.p.v[0],
                      Ct = this.p.v[1],
                      Mt = this.s.v[0] / 2,
                      wt = this.s.v[1] / 2,
                      Bt = this.d !== 3,
                      It = this.v;
                    (It.v[0][0] = At),
                      (It.v[0][1] = Ct - wt),
                      (It.v[1][0] = Bt ? At + Mt : At - Mt),
                      (It.v[1][1] = Ct),
                      (It.v[2][0] = At),
                      (It.v[2][1] = Ct + wt),
                      (It.v[3][0] = Bt ? At - Mt : At + Mt),
                      (It.v[3][1] = Ct),
                      (It.i[0][0] = Bt ? At - Mt * pt : At + Mt * pt),
                      (It.i[0][1] = Ct - wt),
                      (It.i[1][0] = Bt ? At + Mt : At - Mt),
                      (It.i[1][1] = Ct - wt * pt),
                      (It.i[2][0] = Bt ? At + Mt * pt : At - Mt * pt),
                      (It.i[2][1] = Ct + wt),
                      (It.i[3][0] = Bt ? At - Mt : At + Mt),
                      (It.i[3][1] = Ct + wt * pt),
                      (It.o[0][0] = Bt ? At + Mt * pt : At - Mt * pt),
                      (It.o[0][1] = Ct - wt),
                      (It.o[1][0] = Bt ? At + Mt : At - Mt),
                      (It.o[1][1] = Ct + wt * pt),
                      (It.o[2][0] = Bt ? At - Mt * pt : At + Mt * pt),
                      (It.o[2][1] = Ct + wt),
                      (It.o[3][0] = Bt ? At - Mt : At + Mt),
                      (It.o[3][1] = Ct - wt * pt);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], xt),
                xt
              );
            })(),
            ft = (function () {
              function pt(xt, St) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 0),
                  (this.elem = xt),
                  (this.comp = xt.comp),
                  (this.data = St),
                  (this.frameId = -1),
                  (this.d = St.d),
                  this.initDynamicPropertyContainer(xt),
                  St.sy === 1
                    ? ((this.ir = PropertyFactory.getProp(
                        xt,
                        St.ir,
                        0,
                        0,
                        this
                      )),
                      (this.is = PropertyFactory.getProp(
                        xt,
                        St.is,
                        0,
                        0.01,
                        this
                      )),
                      (this.convertToPath = this.convertStarToPath))
                    : (this.convertToPath = this.convertPolygonToPath),
                  (this.pt = PropertyFactory.getProp(xt, St.pt, 0, 0, this)),
                  (this.p = PropertyFactory.getProp(xt, St.p, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(
                    xt,
                    St.r,
                    0,
                    degToRads,
                    this
                  )),
                  (this.or = PropertyFactory.getProp(xt, St.or, 0, 0, this)),
                  (this.os = PropertyFactory.getProp(xt, St.os, 0, 0.01, this)),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertToPath());
              }
              return (
                (pt.prototype = {
                  reset: rt,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertToPath());
                  },
                  convertStarToPath: function () {
                    var St = Math.floor(this.pt.v) * 2,
                      At = (Math.PI * 2) / St,
                      Ct = !0,
                      Mt = this.or.v,
                      wt = this.ir.v,
                      Bt = this.os.v,
                      It = this.is.v,
                      Ft = (2 * Math.PI * Mt) / (St * 2),
                      Vt = (2 * Math.PI * wt) / (St * 2),
                      $t,
                      Kt,
                      Ht,
                      Wt,
                      kt = -Math.PI / 2;
                    kt += this.r.v;
                    var Gt = this.data.d === 3 ? -1 : 1;
                    for (this.v._length = 0, $t = 0; $t < St; $t += 1) {
                      (Kt = Ct ? Mt : wt),
                        (Ht = Ct ? Bt : It),
                        (Wt = Ct ? Ft : Vt);
                      var Pt = Kt * Math.cos(kt),
                        Rt = Kt * Math.sin(kt),
                        Nt =
                          Pt === 0 && Rt === 0
                            ? 0
                            : Rt / Math.sqrt(Pt * Pt + Rt * Rt),
                        Dt =
                          Pt === 0 && Rt === 0
                            ? 0
                            : -Pt / Math.sqrt(Pt * Pt + Rt * Rt);
                      (Pt += +this.p.v[0]),
                        (Rt += +this.p.v[1]),
                        this.v.setTripleAt(
                          Pt,
                          Rt,
                          Pt - Nt * Wt * Ht * Gt,
                          Rt - Dt * Wt * Ht * Gt,
                          Pt + Nt * Wt * Ht * Gt,
                          Rt + Dt * Wt * Ht * Gt,
                          $t,
                          !0
                        ),
                        (Ct = !Ct),
                        (kt += At * Gt);
                    }
                  },
                  convertPolygonToPath: function () {
                    var St = Math.floor(this.pt.v),
                      At = (Math.PI * 2) / St,
                      Ct = this.or.v,
                      Mt = this.os.v,
                      wt = (2 * Math.PI * Ct) / (St * 4),
                      Bt,
                      It = -Math.PI * 0.5,
                      Ft = this.data.d === 3 ? -1 : 1;
                    for (
                      It += this.r.v, this.v._length = 0, Bt = 0;
                      Bt < St;
                      Bt += 1
                    ) {
                      var Vt = Ct * Math.cos(It),
                        $t = Ct * Math.sin(It),
                        Kt =
                          Vt === 0 && $t === 0
                            ? 0
                            : $t / Math.sqrt(Vt * Vt + $t * $t),
                        Ht =
                          Vt === 0 && $t === 0
                            ? 0
                            : -Vt / Math.sqrt(Vt * Vt + $t * $t);
                      (Vt += +this.p.v[0]),
                        ($t += +this.p.v[1]),
                        this.v.setTripleAt(
                          Vt,
                          $t,
                          Vt - Kt * wt * Mt * Ft,
                          $t - Ht * wt * Mt * Ft,
                          Vt + Kt * wt * Mt * Ft,
                          $t + Ht * wt * Mt * Ft,
                          Bt,
                          !0
                        ),
                        (It += At * Ft);
                    }
                    (this.paths.length = 0), (this.paths[0] = this.v);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], pt),
                pt
              );
            })(),
            ht = (function () {
              function pt(xt, St) {
                (this.v = shapePool.newElement()),
                  (this.v.c = !0),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  (this.elem = xt),
                  (this.comp = xt.comp),
                  (this.frameId = -1),
                  (this.d = St.d),
                  this.initDynamicPropertyContainer(xt),
                  (this.p = PropertyFactory.getProp(xt, St.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(xt, St.s, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(xt, St.r, 0, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertRectToPath());
              }
              return (
                (pt.prototype = {
                  convertRectToPath: function () {
                    var St = this.p.v[0],
                      At = this.p.v[1],
                      Ct = this.s.v[0] / 2,
                      Mt = this.s.v[1] / 2,
                      wt = bmMin(Ct, Mt, this.r.v),
                      Bt = wt * (1 - roundCorner);
                    (this.v._length = 0),
                      this.d === 2 || this.d === 1
                        ? (this.v.setTripleAt(
                            St + Ct,
                            At - Mt + wt,
                            St + Ct,
                            At - Mt + wt,
                            St + Ct,
                            At - Mt + Bt,
                            0,
                            !0
                          ),
                          this.v.setTripleAt(
                            St + Ct,
                            At + Mt - wt,
                            St + Ct,
                            At + Mt - Bt,
                            St + Ct,
                            At + Mt - wt,
                            1,
                            !0
                          ),
                          wt !== 0
                            ? (this.v.setTripleAt(
                                St + Ct - wt,
                                At + Mt,
                                St + Ct - wt,
                                At + Mt,
                                St + Ct - Bt,
                                At + Mt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct + wt,
                                At + Mt,
                                St - Ct + Bt,
                                At + Mt,
                                St - Ct + wt,
                                At + Mt,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At + Mt - wt,
                                St - Ct,
                                At + Mt - wt,
                                St - Ct,
                                At + Mt - Bt,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At - Mt + wt,
                                St - Ct,
                                At - Mt + Bt,
                                St - Ct,
                                At - Mt + wt,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct + wt,
                                At - Mt,
                                St - Ct + wt,
                                At - Mt,
                                St - Ct + Bt,
                                At - Mt,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                St + Ct - wt,
                                At - Mt,
                                St + Ct - Bt,
                                At - Mt,
                                St + Ct - wt,
                                At - Mt,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                St - Ct,
                                At + Mt,
                                St - Ct + Bt,
                                At + Mt,
                                St - Ct,
                                At + Mt,
                                2
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At - Mt,
                                St - Ct,
                                At - Mt + Bt,
                                St - Ct,
                                At - Mt,
                                3
                              )))
                        : (this.v.setTripleAt(
                            St + Ct,
                            At - Mt + wt,
                            St + Ct,
                            At - Mt + Bt,
                            St + Ct,
                            At - Mt + wt,
                            0,
                            !0
                          ),
                          wt !== 0
                            ? (this.v.setTripleAt(
                                St + Ct - wt,
                                At - Mt,
                                St + Ct - wt,
                                At - Mt,
                                St + Ct - Bt,
                                At - Mt,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct + wt,
                                At - Mt,
                                St - Ct + Bt,
                                At - Mt,
                                St - Ct + wt,
                                At - Mt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At - Mt + wt,
                                St - Ct,
                                At - Mt + wt,
                                St - Ct,
                                At - Mt + Bt,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At + Mt - wt,
                                St - Ct,
                                At + Mt - Bt,
                                St - Ct,
                                At + Mt - wt,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct + wt,
                                At + Mt,
                                St - Ct + wt,
                                At + Mt,
                                St - Ct + Bt,
                                At + Mt,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                St + Ct - wt,
                                At + Mt,
                                St + Ct - Bt,
                                At + Mt,
                                St + Ct - wt,
                                At + Mt,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                St + Ct,
                                At + Mt - wt,
                                St + Ct,
                                At + Mt - wt,
                                St + Ct,
                                At + Mt - Bt,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                St - Ct,
                                At - Mt,
                                St - Ct + Bt,
                                At - Mt,
                                St - Ct,
                                At - Mt,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                St - Ct,
                                At + Mt,
                                St - Ct,
                                At + Mt - Bt,
                                St - Ct,
                                At + Mt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                St + Ct,
                                At + Mt,
                                St + Ct - Bt,
                                At + Mt,
                                St + Ct,
                                At + Mt,
                                3,
                                !0
                              )));
                  },
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertRectToPath());
                  },
                  reset: rt,
                }),
                extendPrototype([DynamicPropertyContainer], pt),
                pt
              );
            })();
          function mt(pt, xt, St) {
            var At;
            if (St === 3 || St === 4) {
              var Ct = St === 3 ? xt.pt : xt.ks,
                Mt = Ct.k;
              Mt.length ? (At = new ct(pt, xt, St)) : (At = new at(pt, xt, St));
            } else
              St === 5
                ? (At = new ht(pt, xt))
                : St === 6
                ? (At = new ut(pt, xt))
                : St === 7 && (At = new ft(pt, xt));
            return At.k && pt.addDynamicProperty(At), At;
          }
          function vt() {
            return at;
          }
          function yt() {
            return ct;
          }
          var Et = {};
          return (
            (Et.getShapeProp = mt),
            (Et.getConstructorFunction = vt),
            (Et.getKeyframedConstructorFunction = yt),
            Et
          );
        })();
      /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */ var Matrix = (function () {
        var tt = Math.cos,
          et = Math.sin,
          nt = Math.tan,
          rt = Math.round;
        function it() {
          return (
            (this.props[0] = 1),
            (this.props[1] = 0),
            (this.props[2] = 0),
            (this.props[3] = 0),
            (this.props[4] = 0),
            (this.props[5] = 1),
            (this.props[6] = 0),
            (this.props[7] = 0),
            (this.props[8] = 0),
            (this.props[9] = 0),
            (this.props[10] = 1),
            (this.props[11] = 0),
            (this.props[12] = 0),
            (this.props[13] = 0),
            (this.props[14] = 0),
            (this.props[15] = 1),
            this
          );
        }
        function st(Pt) {
          if (Pt === 0) return this;
          var Rt = tt(Pt),
            Nt = et(Pt);
          return this._t(Rt, -Nt, 0, 0, Nt, Rt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function ot(Pt) {
          if (Pt === 0) return this;
          var Rt = tt(Pt),
            Nt = et(Pt);
          return this._t(1, 0, 0, 0, 0, Rt, -Nt, 0, 0, Nt, Rt, 0, 0, 0, 0, 1);
        }
        function at(Pt) {
          if (Pt === 0) return this;
          var Rt = tt(Pt),
            Nt = et(Pt);
          return this._t(Rt, 0, Nt, 0, 0, 1, 0, 0, -Nt, 0, Rt, 0, 0, 0, 0, 1);
        }
        function lt(Pt) {
          if (Pt === 0) return this;
          var Rt = tt(Pt),
            Nt = et(Pt);
          return this._t(Rt, -Nt, 0, 0, Nt, Rt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function ct(Pt, Rt) {
          return this._t(1, Rt, Pt, 1, 0, 0);
        }
        function ut(Pt, Rt) {
          return this.shear(nt(Pt), nt(Rt));
        }
        function ft(Pt, Rt) {
          var Nt = tt(Rt),
            Dt = et(Rt);
          return this._t(Nt, Dt, 0, 0, -Dt, Nt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(1, 0, 0, 0, nt(Pt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(Nt, -Dt, 0, 0, Dt, Nt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function ht(Pt, Rt, Nt) {
          return (
            !Nt && Nt !== 0 && (Nt = 1),
            Pt === 1 && Rt === 1 && Nt === 1
              ? this
              : this._t(Pt, 0, 0, 0, 0, Rt, 0, 0, 0, 0, Nt, 0, 0, 0, 0, 1)
          );
        }
        function mt(
          Pt,
          Rt,
          Nt,
          Dt,
          zt,
          Yt,
          qt,
          Zt,
          Jt,
          mn,
          ln,
          bn,
          Bn,
          gn,
          jt,
          yn
        ) {
          return (
            (this.props[0] = Pt),
            (this.props[1] = Rt),
            (this.props[2] = Nt),
            (this.props[3] = Dt),
            (this.props[4] = zt),
            (this.props[5] = Yt),
            (this.props[6] = qt),
            (this.props[7] = Zt),
            (this.props[8] = Jt),
            (this.props[9] = mn),
            (this.props[10] = ln),
            (this.props[11] = bn),
            (this.props[12] = Bn),
            (this.props[13] = gn),
            (this.props[14] = jt),
            (this.props[15] = yn),
            this
          );
        }
        function vt(Pt, Rt, Nt) {
          return (
            (Nt = Nt || 0),
            Pt !== 0 || Rt !== 0 || Nt !== 0
              ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, Pt, Rt, Nt, 1)
              : this
          );
        }
        function yt(
          Pt,
          Rt,
          Nt,
          Dt,
          zt,
          Yt,
          qt,
          Zt,
          Jt,
          mn,
          ln,
          bn,
          Bn,
          gn,
          jt,
          yn
        ) {
          var pn = this.props;
          if (
            Pt === 1 &&
            Rt === 0 &&
            Nt === 0 &&
            Dt === 0 &&
            zt === 0 &&
            Yt === 1 &&
            qt === 0 &&
            Zt === 0 &&
            Jt === 0 &&
            mn === 0 &&
            ln === 1 &&
            bn === 0
          )
            return (
              (pn[12] = pn[12] * Pt + pn[15] * Bn),
              (pn[13] = pn[13] * Yt + pn[15] * gn),
              (pn[14] = pn[14] * ln + pn[15] * jt),
              (pn[15] *= yn),
              (this._identityCalculated = !1),
              this
            );
          var vn = pn[0],
            xn = pn[1],
            Fn = pn[2],
            _n = pn[3],
            Dn = pn[4],
            Tn = pn[5],
            An = pn[6],
            Wn = pn[7],
            Xt = pn[8],
            Ut = pn[9],
            hn = pn[10],
            Ln = pn[11],
            Cn = pn[12],
            Mn = pn[13],
            kn = pn[14],
            Vn = pn[15];
          return (
            (pn[0] = vn * Pt + xn * zt + Fn * Jt + _n * Bn),
            (pn[1] = vn * Rt + xn * Yt + Fn * mn + _n * gn),
            (pn[2] = vn * Nt + xn * qt + Fn * ln + _n * jt),
            (pn[3] = vn * Dt + xn * Zt + Fn * bn + _n * yn),
            (pn[4] = Dn * Pt + Tn * zt + An * Jt + Wn * Bn),
            (pn[5] = Dn * Rt + Tn * Yt + An * mn + Wn * gn),
            (pn[6] = Dn * Nt + Tn * qt + An * ln + Wn * jt),
            (pn[7] = Dn * Dt + Tn * Zt + An * bn + Wn * yn),
            (pn[8] = Xt * Pt + Ut * zt + hn * Jt + Ln * Bn),
            (pn[9] = Xt * Rt + Ut * Yt + hn * mn + Ln * gn),
            (pn[10] = Xt * Nt + Ut * qt + hn * ln + Ln * jt),
            (pn[11] = Xt * Dt + Ut * Zt + hn * bn + Ln * yn),
            (pn[12] = Cn * Pt + Mn * zt + kn * Jt + Vn * Bn),
            (pn[13] = Cn * Rt + Mn * Yt + kn * mn + Vn * gn),
            (pn[14] = Cn * Nt + Mn * qt + kn * ln + Vn * jt),
            (pn[15] = Cn * Dt + Mn * Zt + kn * bn + Vn * yn),
            (this._identityCalculated = !1),
            this
          );
        }
        function Et(Pt) {
          var Rt = Pt.props;
          return this.transform(
            Rt[0],
            Rt[1],
            Rt[2],
            Rt[3],
            Rt[4],
            Rt[5],
            Rt[6],
            Rt[7],
            Rt[8],
            Rt[9],
            Rt[10],
            Rt[11],
            Rt[12],
            Rt[13],
            Rt[14],
            Rt[15]
          );
        }
        function pt() {
          return (
            this._identityCalculated ||
              ((this._identity = !(
                this.props[0] !== 1 ||
                this.props[1] !== 0 ||
                this.props[2] !== 0 ||
                this.props[3] !== 0 ||
                this.props[4] !== 0 ||
                this.props[5] !== 1 ||
                this.props[6] !== 0 ||
                this.props[7] !== 0 ||
                this.props[8] !== 0 ||
                this.props[9] !== 0 ||
                this.props[10] !== 1 ||
                this.props[11] !== 0 ||
                this.props[12] !== 0 ||
                this.props[13] !== 0 ||
                this.props[14] !== 0 ||
                this.props[15] !== 1
              )),
              (this._identityCalculated = !0)),
            this._identity
          );
        }
        function xt(Pt) {
          for (var Rt = 0; Rt < 16; ) {
            if (Pt.props[Rt] !== this.props[Rt]) return !1;
            Rt += 1;
          }
          return !0;
        }
        function St(Pt) {
          var Rt;
          for (Rt = 0; Rt < 16; Rt += 1) Pt.props[Rt] = this.props[Rt];
          return Pt;
        }
        function At(Pt) {
          var Rt;
          for (Rt = 0; Rt < 16; Rt += 1) this.props[Rt] = Pt[Rt];
        }
        function Ct(Pt, Rt, Nt) {
          return {
            x:
              Pt * this.props[0] +
              Rt * this.props[4] +
              Nt * this.props[8] +
              this.props[12],
            y:
              Pt * this.props[1] +
              Rt * this.props[5] +
              Nt * this.props[9] +
              this.props[13],
            z:
              Pt * this.props[2] +
              Rt * this.props[6] +
              Nt * this.props[10] +
              this.props[14],
          };
        }
        function Mt(Pt, Rt, Nt) {
          return (
            Pt * this.props[0] +
            Rt * this.props[4] +
            Nt * this.props[8] +
            this.props[12]
          );
        }
        function wt(Pt, Rt, Nt) {
          return (
            Pt * this.props[1] +
            Rt * this.props[5] +
            Nt * this.props[9] +
            this.props[13]
          );
        }
        function Bt(Pt, Rt, Nt) {
          return (
            Pt * this.props[2] +
            Rt * this.props[6] +
            Nt * this.props[10] +
            this.props[14]
          );
        }
        function It() {
          var Pt =
              this.props[0] * this.props[5] - this.props[1] * this.props[4],
            Rt = this.props[5] / Pt,
            Nt = -this.props[1] / Pt,
            Dt = -this.props[4] / Pt,
            zt = this.props[0] / Pt,
            Yt =
              (this.props[4] * this.props[13] -
                this.props[5] * this.props[12]) /
              Pt,
            qt =
              -(
                this.props[0] * this.props[13] -
                this.props[1] * this.props[12]
              ) / Pt,
            Zt = new Matrix();
          return (
            (Zt.props[0] = Rt),
            (Zt.props[1] = Nt),
            (Zt.props[4] = Dt),
            (Zt.props[5] = zt),
            (Zt.props[12] = Yt),
            (Zt.props[13] = qt),
            Zt
          );
        }
        function Ft(Pt) {
          var Rt = this.getInverseMatrix();
          return Rt.applyToPointArray(Pt[0], Pt[1], Pt[2] || 0);
        }
        function Vt(Pt) {
          var Rt,
            Nt = Pt.length,
            Dt = [];
          for (Rt = 0; Rt < Nt; Rt += 1) Dt[Rt] = Ft(Pt[Rt]);
          return Dt;
        }
        function $t(Pt, Rt, Nt) {
          var Dt = createTypedArray("float32", 6);
          if (this.isIdentity())
            (Dt[0] = Pt[0]),
              (Dt[1] = Pt[1]),
              (Dt[2] = Rt[0]),
              (Dt[3] = Rt[1]),
              (Dt[4] = Nt[0]),
              (Dt[5] = Nt[1]);
          else {
            var zt = this.props[0],
              Yt = this.props[1],
              qt = this.props[4],
              Zt = this.props[5],
              Jt = this.props[12],
              mn = this.props[13];
            (Dt[0] = Pt[0] * zt + Pt[1] * qt + Jt),
              (Dt[1] = Pt[0] * Yt + Pt[1] * Zt + mn),
              (Dt[2] = Rt[0] * zt + Rt[1] * qt + Jt),
              (Dt[3] = Rt[0] * Yt + Rt[1] * Zt + mn),
              (Dt[4] = Nt[0] * zt + Nt[1] * qt + Jt),
              (Dt[5] = Nt[0] * Yt + Nt[1] * Zt + mn);
          }
          return Dt;
        }
        function Kt(Pt, Rt, Nt) {
          var Dt;
          return (
            this.isIdentity()
              ? (Dt = [Pt, Rt, Nt])
              : (Dt = [
                  Pt * this.props[0] +
                    Rt * this.props[4] +
                    Nt * this.props[8] +
                    this.props[12],
                  Pt * this.props[1] +
                    Rt * this.props[5] +
                    Nt * this.props[9] +
                    this.props[13],
                  Pt * this.props[2] +
                    Rt * this.props[6] +
                    Nt * this.props[10] +
                    this.props[14],
                ]),
            Dt
          );
        }
        function Ht(Pt, Rt) {
          if (this.isIdentity()) return Pt + "," + Rt;
          var Nt = this.props;
          return (
            Math.round((Pt * Nt[0] + Rt * Nt[4] + Nt[12]) * 100) / 100 +
            "," +
            Math.round((Pt * Nt[1] + Rt * Nt[5] + Nt[13]) * 100) / 100
          );
        }
        function Wt() {
          for (
            var Pt = 0, Rt = this.props, Nt = "matrix3d(", Dt = 1e4;
            Pt < 16;

          )
            (Nt += rt(Rt[Pt] * Dt) / Dt),
              (Nt += Pt === 15 ? ")" : ","),
              (Pt += 1);
          return Nt;
        }
        function kt(Pt) {
          var Rt = 1e4;
          return (Pt < 1e-6 && Pt > 0) || (Pt > -1e-6 && Pt < 0)
            ? rt(Pt * Rt) / Rt
            : Pt;
        }
        function Gt() {
          var Pt = this.props,
            Rt = kt(Pt[0]),
            Nt = kt(Pt[1]),
            Dt = kt(Pt[4]),
            zt = kt(Pt[5]),
            Yt = kt(Pt[12]),
            qt = kt(Pt[13]);
          return (
            "matrix(" +
            Rt +
            "," +
            Nt +
            "," +
            Dt +
            "," +
            zt +
            "," +
            Yt +
            "," +
            qt +
            ")"
          );
        }
        return function () {
          (this.reset = it),
            (this.rotate = st),
            (this.rotateX = ot),
            (this.rotateY = at),
            (this.rotateZ = lt),
            (this.skew = ut),
            (this.skewFromAxis = ft),
            (this.shear = ct),
            (this.scale = ht),
            (this.setTransform = mt),
            (this.translate = vt),
            (this.transform = yt),
            (this.multiply = Et),
            (this.applyToPoint = Ct),
            (this.applyToX = Mt),
            (this.applyToY = wt),
            (this.applyToZ = Bt),
            (this.applyToPointArray = Kt),
            (this.applyToTriplePoints = $t),
            (this.applyToPointStringified = Ht),
            (this.toCSS = Wt),
            (this.to2dCSS = Gt),
            (this.clone = St),
            (this.cloneFromProps = At),
            (this.equals = xt),
            (this.inversePoints = Vt),
            (this.inversePoint = Ft),
            (this.getInverseMatrix = It),
            (this._t = this.transform),
            (this.isIdentity = pt),
            (this._identity = !0),
            (this._identityCalculated = !1),
            (this.props = createTypedArray("float32", 16)),
            this.reset();
        };
      })();
      function _typeof$3(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$3 = function (nt) {
                return typeof nt;
              })
            : (_typeof$3 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$3(tt)
        );
      }
      var lottie = {};
      function setLocation(tt) {
        setLocationHref(tt);
      }
      function searchAnimations() {
        animationManager.searchAnimations();
      }
      function setSubframeRendering(tt) {
        setSubframeEnabled(tt);
      }
      function setPrefix(tt) {
        setIdPrefix(tt);
      }
      function loadAnimation(tt) {
        return animationManager.loadAnimation(tt);
      }
      function setQuality(tt) {
        if (typeof tt == "string")
          switch (tt) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        else !isNaN(tt) && tt > 1 && setDefaultCurveSegments(tt);
      }
      function inBrowser() {
        return typeof navigator < "u";
      }
      function installPlugin(tt, et) {
        tt === "expressions" && setExpressionsPlugin(et);
      }
      function getFactory(tt) {
        switch (tt) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      (lottie.play = animationManager.play),
        (lottie.pause = animationManager.pause),
        (lottie.setLocationHref = setLocation),
        (lottie.togglePause = animationManager.togglePause),
        (lottie.setSpeed = animationManager.setSpeed),
        (lottie.setDirection = animationManager.setDirection),
        (lottie.stop = animationManager.stop),
        (lottie.searchAnimations = searchAnimations),
        (lottie.registerAnimation = animationManager.registerAnimation),
        (lottie.loadAnimation = loadAnimation),
        (lottie.setSubframeRendering = setSubframeRendering),
        (lottie.resize = animationManager.resize),
        (lottie.goToAndStop = animationManager.goToAndStop),
        (lottie.destroy = animationManager.destroy),
        (lottie.setQuality = setQuality),
        (lottie.inBrowser = inBrowser),
        (lottie.installPlugin = installPlugin),
        (lottie.freeze = animationManager.freeze),
        (lottie.unfreeze = animationManager.unfreeze),
        (lottie.setVolume = animationManager.setVolume),
        (lottie.mute = animationManager.mute),
        (lottie.unmute = animationManager.unmute),
        (lottie.getRegisteredAnimations =
          animationManager.getRegisteredAnimations),
        (lottie.useWebWorker = setWebWorker),
        (lottie.setIDPrefix = setPrefix),
        (lottie.__getFactory = getFactory),
        (lottie.version = "5.12.2");
      function checkReady() {
        document.readyState === "complete" &&
          (clearInterval(readyStateCheckInterval), searchAnimations());
      }
      function getQueryVariable(tt) {
        for (var et = queryString.split("&"), nt = 0; nt < et.length; nt += 1) {
          var rt = et[nt].split("=");
          if (decodeURIComponent(rt[0]) == tt) return decodeURIComponent(rt[1]);
        }
        return null;
      }
      var queryString = "";
      {
        var scripts = document.getElementsByTagName("script"),
          index = scripts.length - 1,
          myScript = scripts[index] || { src: "" };
        (queryString = myScript.src
          ? myScript.src.replace(/^[^\?]+\??/, "")
          : ""),
          getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
      } catch (tt) {}
      var ShapeModifiers = (function () {
        var tt = {},
          et = {};
        (tt.registerModifier = nt), (tt.getModifier = rt);
        function nt(it, st) {
          et[it] || (et[it] = st);
        }
        function rt(it, st, ot) {
          return new et[it](st, ot);
        }
        return tt;
      })();
      function ShapeModifier() {}
      (ShapeModifier.prototype.initModifierProperties = function () {}),
        (ShapeModifier.prototype.addShapeToModifier = function () {}),
        (ShapeModifier.prototype.addShape = function (tt) {
          if (!this.closed) {
            tt.sh.container.addDynamicProperty(tt.sh);
            var et = {
              shape: tt.sh,
              data: tt,
              localShapeCollection: shapeCollectionPool.newShapeCollection(),
            };
            this.shapes.push(et),
              this.addShapeToModifier(et),
              this._isAnimated && tt.setAsAnimated();
          }
        }),
        (ShapeModifier.prototype.init = function (tt, et) {
          (this.shapes = []),
            (this.elem = tt),
            this.initDynamicPropertyContainer(tt),
            this.initModifierProperties(tt, et),
            (this.frameId = initialDefaultFrame),
            (this.closed = !1),
            (this.k = !1),
            this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (ShapeModifier.prototype.processKeys = function () {
          this.elem.globalData.frameId !== this.frameId &&
            ((this.frameId = this.elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {}
      extendPrototype([ShapeModifier], TrimModifier),
        (TrimModifier.prototype.initModifierProperties = function (tt, et) {
          (this.s = PropertyFactory.getProp(tt, et.s, 0, 0.01, this)),
            (this.e = PropertyFactory.getProp(tt, et.e, 0, 0.01, this)),
            (this.o = PropertyFactory.getProp(tt, et.o, 0, 0, this)),
            (this.sValue = 0),
            (this.eValue = 0),
            (this.getValue = this.processKeys),
            (this.m = et.m),
            (this._isAnimated =
              !!this.s.effectsSequence.length ||
              !!this.e.effectsSequence.length ||
              !!this.o.effectsSequence.length);
        }),
        (TrimModifier.prototype.addShapeToModifier = function (tt) {
          tt.pathsData = [];
        }),
        (TrimModifier.prototype.calculateShapeEdges = function (
          tt,
          et,
          nt,
          rt,
          it
        ) {
          var st = [];
          et <= 1
            ? st.push({ s: tt, e: et })
            : tt >= 1
            ? st.push({ s: tt - 1, e: et - 1 })
            : (st.push({ s: tt, e: 1 }), st.push({ s: 0, e: et - 1 }));
          var ot = [],
            at,
            lt = st.length,
            ct;
          for (at = 0; at < lt; at += 1)
            if (((ct = st[at]), !(ct.e * it < rt || ct.s * it > rt + nt))) {
              var ut, ft;
              ct.s * it <= rt ? (ut = 0) : (ut = (ct.s * it - rt) / nt),
                ct.e * it >= rt + nt ? (ft = 1) : (ft = (ct.e * it - rt) / nt),
                ot.push([ut, ft]);
            }
          return ot.length || ot.push([0, 0]), ot;
        }),
        (TrimModifier.prototype.releasePathsData = function (tt) {
          var et,
            nt = tt.length;
          for (et = 0; et < nt; et += 1) segmentsLengthPool.release(tt[et]);
          return (tt.length = 0), tt;
        }),
        (TrimModifier.prototype.processShapes = function (tt) {
          var et, nt;
          if (this._mdf || tt) {
            var rt = (this.o.v % 360) / 360;
            if (
              (rt < 0 && (rt += 1),
              this.s.v > 1
                ? (et = 1 + rt)
                : this.s.v < 0
                ? (et = 0 + rt)
                : (et = this.s.v + rt),
              this.e.v > 1
                ? (nt = 1 + rt)
                : this.e.v < 0
                ? (nt = 0 + rt)
                : (nt = this.e.v + rt),
              et > nt)
            ) {
              var it = et;
              (et = nt), (nt = it);
            }
            (et = Math.round(et * 1e4) * 1e-4),
              (nt = Math.round(nt * 1e4) * 1e-4),
              (this.sValue = et),
              (this.eValue = nt);
          } else (et = this.sValue), (nt = this.eValue);
          var st,
            ot,
            at = this.shapes.length,
            lt,
            ct,
            ut,
            ft,
            ht,
            mt = 0;
          if (nt === et)
            for (ot = 0; ot < at; ot += 1)
              this.shapes[ot].localShapeCollection.releaseShapes(),
                (this.shapes[ot].shape._mdf = !0),
                (this.shapes[ot].shape.paths =
                  this.shapes[ot].localShapeCollection),
                this._mdf && (this.shapes[ot].pathsData.length = 0);
          else if ((nt === 1 && et === 0) || (nt === 0 && et === 1)) {
            if (this._mdf)
              for (ot = 0; ot < at; ot += 1)
                (this.shapes[ot].pathsData.length = 0),
                  (this.shapes[ot].shape._mdf = !0);
          } else {
            var vt = [],
              yt,
              Et;
            for (ot = 0; ot < at; ot += 1)
              if (
                ((yt = this.shapes[ot]),
                !yt.shape._mdf && !this._mdf && !tt && this.m !== 2)
              )
                yt.shape.paths = yt.localShapeCollection;
              else {
                if (
                  ((st = yt.shape.paths),
                  (ct = st._length),
                  (ht = 0),
                  !yt.shape._mdf && yt.pathsData.length)
                )
                  ht = yt.totalShapeLength;
                else {
                  for (
                    ut = this.releasePathsData(yt.pathsData), lt = 0;
                    lt < ct;
                    lt += 1
                  )
                    (ft = bez.getSegmentsLength(st.shapes[lt])),
                      ut.push(ft),
                      (ht += ft.totalLength);
                  (yt.totalShapeLength = ht), (yt.pathsData = ut);
                }
                (mt += ht), (yt.shape._mdf = !0);
              }
            var pt = et,
              xt = nt,
              St = 0,
              At;
            for (ot = at - 1; ot >= 0; ot -= 1)
              if (((yt = this.shapes[ot]), yt.shape._mdf)) {
                for (
                  Et = yt.localShapeCollection,
                    Et.releaseShapes(),
                    this.m === 2 && at > 1
                      ? ((At = this.calculateShapeEdges(
                          et,
                          nt,
                          yt.totalShapeLength,
                          St,
                          mt
                        )),
                        (St += yt.totalShapeLength))
                      : (At = [[pt, xt]]),
                    ct = At.length,
                    lt = 0;
                  lt < ct;
                  lt += 1
                ) {
                  (pt = At[lt][0]),
                    (xt = At[lt][1]),
                    (vt.length = 0),
                    xt <= 1
                      ? vt.push({
                          s: yt.totalShapeLength * pt,
                          e: yt.totalShapeLength * xt,
                        })
                      : pt >= 1
                      ? vt.push({
                          s: yt.totalShapeLength * (pt - 1),
                          e: yt.totalShapeLength * (xt - 1),
                        })
                      : (vt.push({
                          s: yt.totalShapeLength * pt,
                          e: yt.totalShapeLength,
                        }),
                        vt.push({ s: 0, e: yt.totalShapeLength * (xt - 1) }));
                  var Ct = this.addShapes(yt, vt[0]);
                  if (vt[0].s !== vt[0].e) {
                    if (vt.length > 1) {
                      var Mt =
                        yt.shape.paths.shapes[yt.shape.paths._length - 1];
                      if (Mt.c) {
                        var wt = Ct.pop();
                        this.addPaths(Ct, Et),
                          (Ct = this.addShapes(yt, vt[1], wt));
                      } else
                        this.addPaths(Ct, Et), (Ct = this.addShapes(yt, vt[1]));
                    }
                    this.addPaths(Ct, Et);
                  }
                }
                yt.shape.paths = Et;
              }
          }
        }),
        (TrimModifier.prototype.addPaths = function (tt, et) {
          var nt,
            rt = tt.length;
          for (nt = 0; nt < rt; nt += 1) et.addShape(tt[nt]);
        }),
        (TrimModifier.prototype.addSegment = function (
          tt,
          et,
          nt,
          rt,
          it,
          st,
          ot
        ) {
          it.setXYAt(et[0], et[1], "o", st),
            it.setXYAt(nt[0], nt[1], "i", st + 1),
            ot && it.setXYAt(tt[0], tt[1], "v", st),
            it.setXYAt(rt[0], rt[1], "v", st + 1);
        }),
        (TrimModifier.prototype.addSegmentFromArray = function (
          tt,
          et,
          nt,
          rt
        ) {
          et.setXYAt(tt[1], tt[5], "o", nt),
            et.setXYAt(tt[2], tt[6], "i", nt + 1),
            rt && et.setXYAt(tt[0], tt[4], "v", nt),
            et.setXYAt(tt[3], tt[7], "v", nt + 1);
        }),
        (TrimModifier.prototype.addShapes = function (tt, et, nt) {
          var rt = tt.pathsData,
            it = tt.shape.paths.shapes,
            st,
            ot = tt.shape.paths._length,
            at,
            lt,
            ct = 0,
            ut,
            ft,
            ht,
            mt,
            vt = [],
            yt,
            Et = !0;
          for (
            nt
              ? ((ft = nt._length), (yt = nt._length))
              : ((nt = shapePool.newElement()), (ft = 0), (yt = 0)),
              vt.push(nt),
              st = 0;
            st < ot;
            st += 1
          ) {
            for (
              ht = rt[st].lengths,
                nt.c = it[st].c,
                lt = it[st].c ? ht.length : ht.length + 1,
                at = 1;
              at < lt;
              at += 1
            )
              if (((ut = ht[at - 1]), ct + ut.addedLength < et.s))
                (ct += ut.addedLength), (nt.c = !1);
              else if (ct > et.e) {
                nt.c = !1;
                break;
              } else
                et.s <= ct && et.e >= ct + ut.addedLength
                  ? (this.addSegment(
                      it[st].v[at - 1],
                      it[st].o[at - 1],
                      it[st].i[at],
                      it[st].v[at],
                      nt,
                      ft,
                      Et
                    ),
                    (Et = !1))
                  : ((mt = bez.getNewSegment(
                      it[st].v[at - 1],
                      it[st].v[at],
                      it[st].o[at - 1],
                      it[st].i[at],
                      (et.s - ct) / ut.addedLength,
                      (et.e - ct) / ut.addedLength,
                      ht[at - 1]
                    )),
                    this.addSegmentFromArray(mt, nt, ft, Et),
                    (Et = !1),
                    (nt.c = !1)),
                  (ct += ut.addedLength),
                  (ft += 1);
            if (it[st].c && ht.length) {
              if (((ut = ht[at - 1]), ct <= et.e)) {
                var pt = ht[at - 1].addedLength;
                et.s <= ct && et.e >= ct + pt
                  ? (this.addSegment(
                      it[st].v[at - 1],
                      it[st].o[at - 1],
                      it[st].i[0],
                      it[st].v[0],
                      nt,
                      ft,
                      Et
                    ),
                    (Et = !1))
                  : ((mt = bez.getNewSegment(
                      it[st].v[at - 1],
                      it[st].v[0],
                      it[st].o[at - 1],
                      it[st].i[0],
                      (et.s - ct) / pt,
                      (et.e - ct) / pt,
                      ht[at - 1]
                    )),
                    this.addSegmentFromArray(mt, nt, ft, Et),
                    (Et = !1),
                    (nt.c = !1));
              } else nt.c = !1;
              (ct += ut.addedLength), (ft += 1);
            }
            if (
              (nt._length &&
                (nt.setXYAt(nt.v[yt][0], nt.v[yt][1], "i", yt),
                nt.setXYAt(
                  nt.v[nt._length - 1][0],
                  nt.v[nt._length - 1][1],
                  "o",
                  nt._length - 1
                )),
              ct > et.e)
            )
              break;
            st < ot - 1 &&
              ((nt = shapePool.newElement()), (Et = !0), vt.push(nt), (ft = 0));
          }
          return vt;
        });
      function PuckerAndBloatModifier() {}
      extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        (PuckerAndBloatModifier.prototype.initModifierProperties = function (
          tt,
          et
        ) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(tt, et.a, 0, null, this)),
            (this._isAnimated = !!this.amount.effectsSequence.length);
        }),
        (PuckerAndBloatModifier.prototype.processPath = function (tt, et) {
          var nt = et / 100,
            rt = [0, 0],
            it = tt._length,
            st = 0;
          for (st = 0; st < it; st += 1)
            (rt[0] += tt.v[st][0]), (rt[1] += tt.v[st][1]);
          (rt[0] /= it), (rt[1] /= it);
          var ot = shapePool.newElement();
          ot.c = tt.c;
          var at, lt, ct, ut, ft, ht;
          for (st = 0; st < it; st += 1)
            (at = tt.v[st][0] + (rt[0] - tt.v[st][0]) * nt),
              (lt = tt.v[st][1] + (rt[1] - tt.v[st][1]) * nt),
              (ct = tt.o[st][0] + (rt[0] - tt.o[st][0]) * -nt),
              (ut = tt.o[st][1] + (rt[1] - tt.o[st][1]) * -nt),
              (ft = tt.i[st][0] + (rt[0] - tt.i[st][0]) * -nt),
              (ht = tt.i[st][1] + (rt[1] - tt.i[st][1]) * -nt),
              ot.setTripleAt(at, lt, ct, ut, ft, ht, st);
          return ot;
        }),
        (PuckerAndBloatModifier.prototype.processShapes = function (tt) {
          var et,
            nt,
            rt = this.shapes.length,
            it,
            st,
            ot = this.amount.v;
          if (ot !== 0) {
            var at, lt;
            for (nt = 0; nt < rt; nt += 1) {
              if (
                ((at = this.shapes[nt]),
                (lt = at.localShapeCollection),
                !(!at.shape._mdf && !this._mdf && !tt))
              )
                for (
                  lt.releaseShapes(),
                    at.shape._mdf = !0,
                    et = at.shape.paths.shapes,
                    st = at.shape.paths._length,
                    it = 0;
                  it < st;
                  it += 1
                )
                  lt.addShape(this.processPath(et[it], ot));
              at.shape.paths = at.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      var TransformPropertyFactory = (function () {
        var tt = [0, 0];
        function et(lt) {
          var ct = this._mdf;
          this.iterateDynamicProperties(),
            (this._mdf = this._mdf || ct),
            this.a && lt.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
            this.s && lt.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
            this.sk && lt.skewFromAxis(-this.sk.v, this.sa.v),
            this.r
              ? lt.rotate(-this.r.v)
              : lt
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]),
            this.data.p.s
              ? this.data.p.z
                ? lt.translate(this.px.v, this.py.v, -this.pz.v)
                : lt.translate(this.px.v, this.py.v, 0)
              : lt.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
        function nt(lt) {
          if (this.elem.globalData.frameId !== this.frameId) {
            if (
              (this._isDirty &&
                (this.precalculateMatrix(), (this._isDirty = !1)),
              this.iterateDynamicProperties(),
              this._mdf || lt)
            ) {
              var ct;
              if (
                (this.v.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1 &&
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.appliedTransformations < 2 &&
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk &&
                  this.appliedTransformations < 3 &&
                  this.v.skewFromAxis(-this.sk.v, this.sa.v),
                this.r && this.appliedTransformations < 4
                  ? this.v.rotate(-this.r.v)
                  : !this.r &&
                    this.appliedTransformations < 4 &&
                    this.v
                      .rotateZ(-this.rz.v)
                      .rotateY(this.ry.v)
                      .rotateX(this.rx.v)
                      .rotateZ(-this.or.v[2])
                      .rotateY(this.or.v[1])
                      .rotateX(this.or.v[0]),
                this.autoOriented)
              ) {
                var ut, ft;
                if (
                  ((ct = this.elem.globalData.frameRate),
                  this.p && this.p.keyframes && this.p.getValueAtTime)
                )
                  this.p._caching.lastFrame + this.p.offsetTime <=
                  this.p.keyframes[0].t
                    ? ((ut = this.p.getValueAtTime(
                        (this.p.keyframes[0].t + 0.01) / ct,
                        0
                      )),
                      (ft = this.p.getValueAtTime(
                        this.p.keyframes[0].t / ct,
                        0
                      )))
                    : this.p._caching.lastFrame + this.p.offsetTime >=
                      this.p.keyframes[this.p.keyframes.length - 1].t
                    ? ((ut = this.p.getValueAtTime(
                        this.p.keyframes[this.p.keyframes.length - 1].t / ct,
                        0
                      )),
                      (ft = this.p.getValueAtTime(
                        (this.p.keyframes[this.p.keyframes.length - 1].t -
                          0.05) /
                          ct,
                        0
                      )))
                    : ((ut = this.p.pv),
                      (ft = this.p.getValueAtTime(
                        (this.p._caching.lastFrame + this.p.offsetTime - 0.01) /
                          ct,
                        this.p.offsetTime
                      )));
                else if (
                  this.px &&
                  this.px.keyframes &&
                  this.py.keyframes &&
                  this.px.getValueAtTime &&
                  this.py.getValueAtTime
                ) {
                  (ut = []), (ft = []);
                  var ht = this.px,
                    mt = this.py;
                  ht._caching.lastFrame + ht.offsetTime <= ht.keyframes[0].t
                    ? ((ut[0] = ht.getValueAtTime(
                        (ht.keyframes[0].t + 0.01) / ct,
                        0
                      )),
                      (ut[1] = mt.getValueAtTime(
                        (mt.keyframes[0].t + 0.01) / ct,
                        0
                      )),
                      (ft[0] = ht.getValueAtTime(ht.keyframes[0].t / ct, 0)),
                      (ft[1] = mt.getValueAtTime(mt.keyframes[0].t / ct, 0)))
                    : ht._caching.lastFrame + ht.offsetTime >=
                      ht.keyframes[ht.keyframes.length - 1].t
                    ? ((ut[0] = ht.getValueAtTime(
                        ht.keyframes[ht.keyframes.length - 1].t / ct,
                        0
                      )),
                      (ut[1] = mt.getValueAtTime(
                        mt.keyframes[mt.keyframes.length - 1].t / ct,
                        0
                      )),
                      (ft[0] = ht.getValueAtTime(
                        (ht.keyframes[ht.keyframes.length - 1].t - 0.01) / ct,
                        0
                      )),
                      (ft[1] = mt.getValueAtTime(
                        (mt.keyframes[mt.keyframes.length - 1].t - 0.01) / ct,
                        0
                      )))
                    : ((ut = [ht.pv, mt.pv]),
                      (ft[0] = ht.getValueAtTime(
                        (ht._caching.lastFrame + ht.offsetTime - 0.01) / ct,
                        ht.offsetTime
                      )),
                      (ft[1] = mt.getValueAtTime(
                        (mt._caching.lastFrame + mt.offsetTime - 0.01) / ct,
                        mt.offsetTime
                      )));
                } else (ft = tt), (ut = ft);
                this.v.rotate(-Math.atan2(ut[1] - ft[1], ut[0] - ft[0]));
              }
              this.data.p && this.data.p.s
                ? this.data.p.z
                  ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                  : this.v.translate(this.px.v, this.py.v, 0)
                : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
            this.frameId = this.elem.globalData.frameId;
          }
        }
        function rt() {
          if (
            ((this.appliedTransformations = 0),
            this.pre.reset(),
            !this.a.effectsSequence.length)
          )
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
              (this.appliedTransformations = 1);
          else return;
          if (!this.s.effectsSequence.length)
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
              (this.appliedTransformations = 2);
          else return;
          if (this.sk)
            if (
              !this.sk.effectsSequence.length &&
              !this.sa.effectsSequence.length
            )
              this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                (this.appliedTransformations = 3);
            else return;
          this.r
            ? this.r.effectsSequence.length ||
              (this.pre.rotate(-this.r.v), (this.appliedTransformations = 4))
            : !this.rz.effectsSequence.length &&
              !this.ry.effectsSequence.length &&
              !this.rx.effectsSequence.length &&
              !this.or.effectsSequence.length &&
              (this.pre
                .rotateZ(-this.rz.v)
                .rotateY(this.ry.v)
                .rotateX(this.rx.v)
                .rotateZ(-this.or.v[2])
                .rotateY(this.or.v[1])
                .rotateX(this.or.v[0]),
              (this.appliedTransformations = 4));
        }
        function it() {}
        function st(lt) {
          this._addDynamicProperty(lt),
            this.elem.addDynamicProperty(lt),
            (this._isDirty = !0);
        }
        function ot(lt, ct, ut) {
          if (
            ((this.elem = lt),
            (this.frameId = -1),
            (this.propType = "transform"),
            (this.data = ct),
            (this.v = new Matrix()),
            (this.pre = new Matrix()),
            (this.appliedTransformations = 0),
            this.initDynamicPropertyContainer(ut || lt),
            ct.p && ct.p.s
              ? ((this.px = PropertyFactory.getProp(lt, ct.p.x, 0, 0, this)),
                (this.py = PropertyFactory.getProp(lt, ct.p.y, 0, 0, this)),
                ct.p.z &&
                  (this.pz = PropertyFactory.getProp(lt, ct.p.z, 0, 0, this)))
              : (this.p = PropertyFactory.getProp(
                  lt,
                  ct.p || { k: [0, 0, 0] },
                  1,
                  0,
                  this
                )),
            ct.rx)
          ) {
            if (
              ((this.rx = PropertyFactory.getProp(
                lt,
                ct.rx,
                0,
                degToRads,
                this
              )),
              (this.ry = PropertyFactory.getProp(
                lt,
                ct.ry,
                0,
                degToRads,
                this
              )),
              (this.rz = PropertyFactory.getProp(
                lt,
                ct.rz,
                0,
                degToRads,
                this
              )),
              ct.or.k[0].ti)
            ) {
              var ft,
                ht = ct.or.k.length;
              for (ft = 0; ft < ht; ft += 1)
                (ct.or.k[ft].to = null), (ct.or.k[ft].ti = null);
            }
            (this.or = PropertyFactory.getProp(lt, ct.or, 1, degToRads, this)),
              (this.or.sh = !0);
          } else
            this.r = PropertyFactory.getProp(
              lt,
              ct.r || { k: 0 },
              0,
              degToRads,
              this
            );
          ct.sk &&
            ((this.sk = PropertyFactory.getProp(lt, ct.sk, 0, degToRads, this)),
            (this.sa = PropertyFactory.getProp(lt, ct.sa, 0, degToRads, this))),
            (this.a = PropertyFactory.getProp(
              lt,
              ct.a || { k: [0, 0, 0] },
              1,
              0,
              this
            )),
            (this.s = PropertyFactory.getProp(
              lt,
              ct.s || { k: [100, 100, 100] },
              1,
              0.01,
              this
            )),
            ct.o
              ? (this.o = PropertyFactory.getProp(lt, ct.o, 0, 0.01, lt))
              : (this.o = { _mdf: !1, v: 1 }),
            (this._isDirty = !0),
            this.dynamicProperties.length || this.getValue(!0);
        }
        (ot.prototype = {
          applyToMatrix: et,
          getValue: nt,
          precalculateMatrix: rt,
          autoOrient: it,
        }),
          extendPrototype([DynamicPropertyContainer], ot),
          (ot.prototype.addDynamicProperty = st),
          (ot.prototype._addDynamicProperty =
            DynamicPropertyContainer.prototype.addDynamicProperty);
        function at(lt, ct, ut) {
          return new ot(lt, ct, ut);
        }
        return { getTransformProperty: at };
      })();
      function RepeaterModifier() {}
      extendPrototype([ShapeModifier], RepeaterModifier),
        (RepeaterModifier.prototype.initModifierProperties = function (tt, et) {
          (this.getValue = this.processKeys),
            (this.c = PropertyFactory.getProp(tt, et.c, 0, null, this)),
            (this.o = PropertyFactory.getProp(tt, et.o, 0, null, this)),
            (this.tr = TransformPropertyFactory.getTransformProperty(
              tt,
              et.tr,
              this
            )),
            (this.so = PropertyFactory.getProp(tt, et.tr.so, 0, 0.01, this)),
            (this.eo = PropertyFactory.getProp(tt, et.tr.eo, 0, 0.01, this)),
            (this.data = et),
            this.dynamicProperties.length || this.getValue(!0),
            (this._isAnimated = !!this.dynamicProperties.length),
            (this.pMatrix = new Matrix()),
            (this.rMatrix = new Matrix()),
            (this.sMatrix = new Matrix()),
            (this.tMatrix = new Matrix()),
            (this.matrix = new Matrix());
        }),
        (RepeaterModifier.prototype.applyTransforms = function (
          tt,
          et,
          nt,
          rt,
          it,
          st
        ) {
          var ot = st ? -1 : 1,
            at = rt.s.v[0] + (1 - rt.s.v[0]) * (1 - it),
            lt = rt.s.v[1] + (1 - rt.s.v[1]) * (1 - it);
          tt.translate(rt.p.v[0] * ot * it, rt.p.v[1] * ot * it, rt.p.v[2]),
            et.translate(-rt.a.v[0], -rt.a.v[1], rt.a.v[2]),
            et.rotate(-rt.r.v * ot * it),
            et.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2]),
            nt.translate(-rt.a.v[0], -rt.a.v[1], rt.a.v[2]),
            nt.scale(st ? 1 / at : at, st ? 1 / lt : lt),
            nt.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2]);
        }),
        (RepeaterModifier.prototype.init = function (tt, et, nt, rt) {
          for (
            this.elem = tt,
              this.arr = et,
              this.pos = nt,
              this.elemsData = rt,
              this._currentCopies = 0,
              this._elements = [],
              this._groups = [],
              this.frameId = -1,
              this.initDynamicPropertyContainer(tt),
              this.initModifierProperties(tt, et[nt]);
            nt > 0;

          )
            (nt -= 1), this._elements.unshift(et[nt]);
          this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (RepeaterModifier.prototype.resetElements = function (tt) {
          var et,
            nt = tt.length;
          for (et = 0; et < nt; et += 1)
            (tt[et]._processed = !1),
              tt[et].ty === "gr" && this.resetElements(tt[et].it);
        }),
        (RepeaterModifier.prototype.cloneElements = function (tt) {
          var et = JSON.parse(JSON.stringify(tt));
          return this.resetElements(et), et;
        }),
        (RepeaterModifier.prototype.changeGroupRender = function (tt, et) {
          var nt,
            rt = tt.length;
          for (nt = 0; nt < rt; nt += 1)
            (tt[nt]._render = et),
              tt[nt].ty === "gr" && this.changeGroupRender(tt[nt].it, et);
        }),
        (RepeaterModifier.prototype.processShapes = function (tt) {
          var et,
            nt,
            rt,
            it,
            st,
            ot = !1;
          if (this._mdf || tt) {
            var at = Math.ceil(this.c.v);
            if (this._groups.length < at) {
              for (; this._groups.length < at; ) {
                var lt = { it: this.cloneElements(this._elements), ty: "gr" };
                lt.it.push({
                  a: { a: 0, ix: 1, k: [0, 0] },
                  nm: "Transform",
                  o: { a: 0, ix: 7, k: 100 },
                  p: { a: 0, ix: 2, k: [0, 0] },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [
                      { s: 0, e: 0, t: 0 },
                      { s: 0, e: 0, t: 1 },
                    ],
                  },
                  s: { a: 0, ix: 3, k: [100, 100] },
                  sa: { a: 0, ix: 5, k: 0 },
                  sk: { a: 0, ix: 4, k: 0 },
                  ty: "tr",
                }),
                  this.arr.splice(0, 0, lt),
                  this._groups.splice(0, 0, lt),
                  (this._currentCopies += 1);
              }
              this.elem.reloadShapes(), (ot = !0);
            }
            st = 0;
            var ct;
            for (rt = 0; rt <= this._groups.length - 1; rt += 1) {
              if (
                ((ct = st < at),
                (this._groups[rt]._render = ct),
                this.changeGroupRender(this._groups[rt].it, ct),
                !ct)
              ) {
                var ut = this.elemsData[rt].it,
                  ft = ut[ut.length - 1];
                ft.transform.op.v !== 0
                  ? ((ft.transform.op._mdf = !0), (ft.transform.op.v = 0))
                  : (ft.transform.op._mdf = !1);
              }
              st += 1;
            }
            this._currentCopies = at;
            var ht = this.o.v,
              mt = ht % 1,
              vt = ht > 0 ? Math.floor(ht) : Math.ceil(ht),
              yt = this.pMatrix.props,
              Et = this.rMatrix.props,
              pt = this.sMatrix.props;
            this.pMatrix.reset(),
              this.rMatrix.reset(),
              this.sMatrix.reset(),
              this.tMatrix.reset(),
              this.matrix.reset();
            var xt = 0;
            if (ht > 0) {
              for (; xt < vt; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !1
                ),
                  (xt += 1);
              mt &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  mt,
                  !1
                ),
                (xt += mt));
            } else if (ht < 0) {
              for (; xt > vt; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !0
                ),
                  (xt -= 1);
              mt &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  -mt,
                  !0
                ),
                (xt -= mt));
            }
            (rt = this.data.m === 1 ? 0 : this._currentCopies - 1),
              (it = this.data.m === 1 ? 1 : -1),
              (st = this._currentCopies);
            for (var St, At; st; ) {
              if (
                ((et = this.elemsData[rt].it),
                (nt = et[et.length - 1].transform.mProps.v.props),
                (At = nt.length),
                (et[et.length - 1].transform.mProps._mdf = !0),
                (et[et.length - 1].transform.op._mdf = !0),
                (et[et.length - 1].transform.op.v =
                  this._currentCopies === 1
                    ? this.so.v
                    : this.so.v +
                      (this.eo.v - this.so.v) *
                        (rt / (this._currentCopies - 1))),
                xt !== 0)
              ) {
                for (
                  ((rt !== 0 && it === 1) ||
                    (rt !== this._currentCopies - 1 && it === -1)) &&
                    this.applyTransforms(
                      this.pMatrix,
                      this.rMatrix,
                      this.sMatrix,
                      this.tr,
                      1,
                      !1
                    ),
                    this.matrix.transform(
                      Et[0],
                      Et[1],
                      Et[2],
                      Et[3],
                      Et[4],
                      Et[5],
                      Et[6],
                      Et[7],
                      Et[8],
                      Et[9],
                      Et[10],
                      Et[11],
                      Et[12],
                      Et[13],
                      Et[14],
                      Et[15]
                    ),
                    this.matrix.transform(
                      pt[0],
                      pt[1],
                      pt[2],
                      pt[3],
                      pt[4],
                      pt[5],
                      pt[6],
                      pt[7],
                      pt[8],
                      pt[9],
                      pt[10],
                      pt[11],
                      pt[12],
                      pt[13],
                      pt[14],
                      pt[15]
                    ),
                    this.matrix.transform(
                      yt[0],
                      yt[1],
                      yt[2],
                      yt[3],
                      yt[4],
                      yt[5],
                      yt[6],
                      yt[7],
                      yt[8],
                      yt[9],
                      yt[10],
                      yt[11],
                      yt[12],
                      yt[13],
                      yt[14],
                      yt[15]
                    ),
                    St = 0;
                  St < At;
                  St += 1
                )
                  nt[St] = this.matrix.props[St];
                this.matrix.reset();
              } else
                for (this.matrix.reset(), St = 0; St < At; St += 1)
                  nt[St] = this.matrix.props[St];
              (xt += 1), (st -= 1), (rt += it);
            }
          } else
            for (st = this._currentCopies, rt = 0, it = 1; st; )
              (et = this.elemsData[rt].it),
                (nt = et[et.length - 1].transform.mProps.v.props),
                (et[et.length - 1].transform.mProps._mdf = !1),
                (et[et.length - 1].transform.op._mdf = !1),
                (st -= 1),
                (rt += it);
          return ot;
        }),
        (RepeaterModifier.prototype.addShape = function () {});
      function RoundCornersModifier() {}
      extendPrototype([ShapeModifier], RoundCornersModifier),
        (RoundCornersModifier.prototype.initModifierProperties = function (
          tt,
          et
        ) {
          (this.getValue = this.processKeys),
            (this.rd = PropertyFactory.getProp(tt, et.r, 0, null, this)),
            (this._isAnimated = !!this.rd.effectsSequence.length);
        }),
        (RoundCornersModifier.prototype.processPath = function (tt, et) {
          var nt = shapePool.newElement();
          nt.c = tt.c;
          var rt,
            it = tt._length,
            st,
            ot,
            at,
            lt,
            ct,
            ut,
            ft = 0,
            ht,
            mt,
            vt,
            yt,
            Et,
            pt;
          for (rt = 0; rt < it; rt += 1)
            (st = tt.v[rt]),
              (at = tt.o[rt]),
              (ot = tt.i[rt]),
              st[0] === at[0] &&
              st[1] === at[1] &&
              st[0] === ot[0] &&
              st[1] === ot[1]
                ? (rt === 0 || rt === it - 1) && !tt.c
                  ? (nt.setTripleAt(
                      st[0],
                      st[1],
                      at[0],
                      at[1],
                      ot[0],
                      ot[1],
                      ft
                    ),
                    (ft += 1))
                  : (rt === 0 ? (lt = tt.v[it - 1]) : (lt = tt.v[rt - 1]),
                    (ct = Math.sqrt(
                      Math.pow(st[0] - lt[0], 2) + Math.pow(st[1] - lt[1], 2)
                    )),
                    (ut = ct ? Math.min(ct / 2, et) / ct : 0),
                    (Et = st[0] + (lt[0] - st[0]) * ut),
                    (ht = Et),
                    (pt = st[1] - (st[1] - lt[1]) * ut),
                    (mt = pt),
                    (vt = ht - (ht - st[0]) * roundCorner),
                    (yt = mt - (mt - st[1]) * roundCorner),
                    nt.setTripleAt(ht, mt, vt, yt, Et, pt, ft),
                    (ft += 1),
                    rt === it - 1 ? (lt = tt.v[0]) : (lt = tt.v[rt + 1]),
                    (ct = Math.sqrt(
                      Math.pow(st[0] - lt[0], 2) + Math.pow(st[1] - lt[1], 2)
                    )),
                    (ut = ct ? Math.min(ct / 2, et) / ct : 0),
                    (vt = st[0] + (lt[0] - st[0]) * ut),
                    (ht = vt),
                    (yt = st[1] + (lt[1] - st[1]) * ut),
                    (mt = yt),
                    (Et = ht - (ht - st[0]) * roundCorner),
                    (pt = mt - (mt - st[1]) * roundCorner),
                    nt.setTripleAt(ht, mt, vt, yt, Et, pt, ft),
                    (ft += 1))
                : (nt.setTripleAt(
                    tt.v[rt][0],
                    tt.v[rt][1],
                    tt.o[rt][0],
                    tt.o[rt][1],
                    tt.i[rt][0],
                    tt.i[rt][1],
                    ft
                  ),
                  (ft += 1));
          return nt;
        }),
        (RoundCornersModifier.prototype.processShapes = function (tt) {
          var et,
            nt,
            rt = this.shapes.length,
            it,
            st,
            ot = this.rd.v;
          if (ot !== 0) {
            var at, lt;
            for (nt = 0; nt < rt; nt += 1) {
              if (
                ((at = this.shapes[nt]),
                (lt = at.localShapeCollection),
                !(!at.shape._mdf && !this._mdf && !tt))
              )
                for (
                  lt.releaseShapes(),
                    at.shape._mdf = !0,
                    et = at.shape.paths.shapes,
                    st = at.shape.paths._length,
                    it = 0;
                  it < st;
                  it += 1
                )
                  lt.addShape(this.processPath(et[it], ot));
              at.shape.paths = at.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function floatEqual(tt, et) {
        return Math.abs(tt - et) * 1e5 <= Math.min(Math.abs(tt), Math.abs(et));
      }
      function floatZero(tt) {
        return Math.abs(tt) <= 1e-5;
      }
      function lerp(tt, et, nt) {
        return tt * (1 - nt) + et * nt;
      }
      function lerpPoint(tt, et, nt) {
        return [lerp(tt[0], et[0], nt), lerp(tt[1], et[1], nt)];
      }
      function quadRoots(tt, et, nt) {
        if (tt === 0) return [];
        var rt = et * et - 4 * tt * nt;
        if (rt < 0) return [];
        var it = -et / (2 * tt);
        if (rt === 0) return [it];
        var st = Math.sqrt(rt) / (2 * tt);
        return [it - st, it + st];
      }
      function polynomialCoefficients(tt, et, nt, rt) {
        return [
          -tt + 3 * et - 3 * nt + rt,
          3 * tt - 6 * et + 3 * nt,
          -3 * tt + 3 * et,
          tt,
        ];
      }
      function singlePoint(tt) {
        return new PolynomialBezier(tt, tt, tt, tt, !1);
      }
      function PolynomialBezier(tt, et, nt, rt, it) {
        it && pointEqual(tt, et) && (et = lerpPoint(tt, rt, 1 / 3)),
          it && pointEqual(nt, rt) && (nt = lerpPoint(tt, rt, 2 / 3));
        var st = polynomialCoefficients(tt[0], et[0], nt[0], rt[0]),
          ot = polynomialCoefficients(tt[1], et[1], nt[1], rt[1]);
        (this.a = [st[0], ot[0]]),
          (this.b = [st[1], ot[1]]),
          (this.c = [st[2], ot[2]]),
          (this.d = [st[3], ot[3]]),
          (this.points = [tt, et, nt, rt]);
      }
      (PolynomialBezier.prototype.point = function (tt) {
        return [
          ((this.a[0] * tt + this.b[0]) * tt + this.c[0]) * tt + this.d[0],
          ((this.a[1] * tt + this.b[1]) * tt + this.c[1]) * tt + this.d[1],
        ];
      }),
        (PolynomialBezier.prototype.derivative = function (tt) {
          return [
            (3 * tt * this.a[0] + 2 * this.b[0]) * tt + this.c[0],
            (3 * tt * this.a[1] + 2 * this.b[1]) * tt + this.c[1],
          ];
        }),
        (PolynomialBezier.prototype.tangentAngle = function (tt) {
          var et = this.derivative(tt);
          return Math.atan2(et[1], et[0]);
        }),
        (PolynomialBezier.prototype.normalAngle = function (tt) {
          var et = this.derivative(tt);
          return Math.atan2(et[0], et[1]);
        }),
        (PolynomialBezier.prototype.inflectionPoints = function () {
          var tt = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(tt)) return [];
          var et =
              (-0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1])) / tt,
            nt =
              et * et -
              ((1 / 3) * (this.b[1] * this.c[0] - this.b[0] * this.c[1])) / tt;
          if (nt < 0) return [];
          var rt = Math.sqrt(nt);
          return floatZero(rt)
            ? rt > 0 && rt < 1
              ? [et]
              : []
            : [et - rt, et + rt].filter(function (it) {
                return it > 0 && it < 1;
              });
        }),
        (PolynomialBezier.prototype.split = function (tt) {
          if (tt <= 0) return [singlePoint(this.points[0]), this];
          if (tt >= 1)
            return [this, singlePoint(this.points[this.points.length - 1])];
          var et = lerpPoint(this.points[0], this.points[1], tt),
            nt = lerpPoint(this.points[1], this.points[2], tt),
            rt = lerpPoint(this.points[2], this.points[3], tt),
            it = lerpPoint(et, nt, tt),
            st = lerpPoint(nt, rt, tt),
            ot = lerpPoint(it, st, tt);
          return [
            new PolynomialBezier(this.points[0], et, it, ot, !0),
            new PolynomialBezier(ot, st, rt, this.points[3], !0),
          ];
        });
      function extrema(tt, et) {
        var nt = tt.points[0][et],
          rt = tt.points[tt.points.length - 1][et];
        if (nt > rt) {
          var it = rt;
          (rt = nt), (nt = it);
        }
        for (
          var st = quadRoots(3 * tt.a[et], 2 * tt.b[et], tt.c[et]), ot = 0;
          ot < st.length;
          ot += 1
        )
          if (st[ot] > 0 && st[ot] < 1) {
            var at = tt.point(st[ot])[et];
            at < nt ? (nt = at) : at > rt && (rt = at);
          }
        return { min: nt, max: rt };
      }
      (PolynomialBezier.prototype.bounds = function () {
        return { x: extrema(this, 0), y: extrema(this, 1) };
      }),
        (PolynomialBezier.prototype.boundingBox = function () {
          var tt = this.bounds();
          return {
            left: tt.x.min,
            right: tt.x.max,
            top: tt.y.min,
            bottom: tt.y.max,
            width: tt.x.max - tt.x.min,
            height: tt.y.max - tt.y.min,
            cx: (tt.x.max + tt.x.min) / 2,
            cy: (tt.y.max + tt.y.min) / 2,
          };
        });
      function intersectData(tt, et, nt) {
        var rt = tt.boundingBox();
        return {
          cx: rt.cx,
          cy: rt.cy,
          width: rt.width,
          height: rt.height,
          bez: tt,
          t: (et + nt) / 2,
          t1: et,
          t2: nt,
        };
      }
      function splitData(tt) {
        var et = tt.bez.split(0.5);
        return [
          intersectData(et[0], tt.t1, tt.t),
          intersectData(et[1], tt.t, tt.t2),
        ];
      }
      function boxIntersect(tt, et) {
        return (
          Math.abs(tt.cx - et.cx) * 2 < tt.width + et.width &&
          Math.abs(tt.cy - et.cy) * 2 < tt.height + et.height
        );
      }
      function intersectsImpl(tt, et, nt, rt, it, st) {
        if (boxIntersect(tt, et)) {
          if (
            nt >= st ||
            (tt.width <= rt &&
              tt.height <= rt &&
              et.width <= rt &&
              et.height <= rt)
          ) {
            it.push([tt.t, et.t]);
            return;
          }
          var ot = splitData(tt),
            at = splitData(et);
          intersectsImpl(ot[0], at[0], nt + 1, rt, it, st),
            intersectsImpl(ot[0], at[1], nt + 1, rt, it, st),
            intersectsImpl(ot[1], at[0], nt + 1, rt, it, st),
            intersectsImpl(ot[1], at[1], nt + 1, rt, it, st);
        }
      }
      (PolynomialBezier.prototype.intersections = function (tt, et, nt) {
        et === void 0 && (et = 2), nt === void 0 && (nt = 7);
        var rt = [];
        return (
          intersectsImpl(
            intersectData(this, 0, 1),
            intersectData(tt, 0, 1),
            0,
            et,
            rt,
            nt
          ),
          rt
        );
      }),
        (PolynomialBezier.shapeSegment = function (tt, et) {
          var nt = (et + 1) % tt.length();
          return new PolynomialBezier(
            tt.v[et],
            tt.o[et],
            tt.i[nt],
            tt.v[nt],
            !0
          );
        }),
        (PolynomialBezier.shapeSegmentInverted = function (tt, et) {
          var nt = (et + 1) % tt.length();
          return new PolynomialBezier(
            tt.v[nt],
            tt.i[nt],
            tt.o[et],
            tt.v[et],
            !0
          );
        });
      function crossProduct(tt, et) {
        return [
          tt[1] * et[2] - tt[2] * et[1],
          tt[2] * et[0] - tt[0] * et[2],
          tt[0] * et[1] - tt[1] * et[0],
        ];
      }
      function lineIntersection(tt, et, nt, rt) {
        var it = [tt[0], tt[1], 1],
          st = [et[0], et[1], 1],
          ot = [nt[0], nt[1], 1],
          at = [rt[0], rt[1], 1],
          lt = crossProduct(crossProduct(it, st), crossProduct(ot, at));
        return floatZero(lt[2]) ? null : [lt[0] / lt[2], lt[1] / lt[2]];
      }
      function polarOffset(tt, et, nt) {
        return [tt[0] + Math.cos(et) * nt, tt[1] - Math.sin(et) * nt];
      }
      function pointDistance(tt, et) {
        return Math.hypot(tt[0] - et[0], tt[1] - et[1]);
      }
      function pointEqual(tt, et) {
        return floatEqual(tt[0], et[0]) && floatEqual(tt[1], et[1]);
      }
      function ZigZagModifier() {}
      extendPrototype([ShapeModifier], ZigZagModifier),
        (ZigZagModifier.prototype.initModifierProperties = function (tt, et) {
          (this.getValue = this.processKeys),
            (this.amplitude = PropertyFactory.getProp(tt, et.s, 0, null, this)),
            (this.frequency = PropertyFactory.getProp(tt, et.r, 0, null, this)),
            (this.pointsType = PropertyFactory.getProp(
              tt,
              et.pt,
              0,
              null,
              this
            )),
            (this._isAnimated =
              this.amplitude.effectsSequence.length !== 0 ||
              this.frequency.effectsSequence.length !== 0 ||
              this.pointsType.effectsSequence.length !== 0);
        });
      function setPoint(tt, et, nt, rt, it, st, ot) {
        var at = nt - Math.PI / 2,
          lt = nt + Math.PI / 2,
          ct = et[0] + Math.cos(nt) * rt * it,
          ut = et[1] - Math.sin(nt) * rt * it;
        tt.setTripleAt(
          ct,
          ut,
          ct + Math.cos(at) * st,
          ut - Math.sin(at) * st,
          ct + Math.cos(lt) * ot,
          ut - Math.sin(lt) * ot,
          tt.length()
        );
      }
      function getPerpendicularVector(tt, et) {
        var nt = [et[0] - tt[0], et[1] - tt[1]],
          rt = -Math.PI * 0.5,
          it = [
            Math.cos(rt) * nt[0] - Math.sin(rt) * nt[1],
            Math.sin(rt) * nt[0] + Math.cos(rt) * nt[1],
          ];
        return it;
      }
      function getProjectingAngle(tt, et) {
        var nt = et === 0 ? tt.length() - 1 : et - 1,
          rt = (et + 1) % tt.length(),
          it = tt.v[nt],
          st = tt.v[rt],
          ot = getPerpendicularVector(it, st);
        return Math.atan2(0, 1) - Math.atan2(ot[1], ot[0]);
      }
      function zigZagCorner(tt, et, nt, rt, it, st, ot) {
        var at = getProjectingAngle(et, nt),
          lt = et.v[nt % et._length],
          ct = et.v[nt === 0 ? et._length - 1 : nt - 1],
          ut = et.v[(nt + 1) % et._length],
          ft =
            st === 2
              ? Math.sqrt(
                  Math.pow(lt[0] - ct[0], 2) + Math.pow(lt[1] - ct[1], 2)
                )
              : 0,
          ht =
            st === 2
              ? Math.sqrt(
                  Math.pow(lt[0] - ut[0], 2) + Math.pow(lt[1] - ut[1], 2)
                )
              : 0;
        setPoint(
          tt,
          et.v[nt % et._length],
          at,
          ot,
          rt,
          ht / ((it + 1) * 2),
          ft / ((it + 1) * 2)
        );
      }
      function zigZagSegment(tt, et, nt, rt, it, st) {
        for (var ot = 0; ot < rt; ot += 1) {
          var at = (ot + 1) / (rt + 1),
            lt =
              it === 2
                ? Math.sqrt(
                    Math.pow(et.points[3][0] - et.points[0][0], 2) +
                      Math.pow(et.points[3][1] - et.points[0][1], 2)
                  )
                : 0,
            ct = et.normalAngle(at),
            ut = et.point(at);
          setPoint(
            tt,
            ut,
            ct,
            st,
            nt,
            lt / ((rt + 1) * 2),
            lt / ((rt + 1) * 2)
          ),
            (st = -st);
        }
        return st;
      }
      (ZigZagModifier.prototype.processPath = function (tt, et, nt, rt) {
        var it = tt._length,
          st = shapePool.newElement();
        if (((st.c = tt.c), tt.c || (it -= 1), it === 0)) return st;
        var ot = -1,
          at = PolynomialBezier.shapeSegment(tt, 0);
        zigZagCorner(st, tt, 0, et, nt, rt, ot);
        for (var lt = 0; lt < it; lt += 1)
          (ot = zigZagSegment(st, at, et, nt, rt, -ot)),
            lt === it - 1 && !tt.c
              ? (at = null)
              : (at = PolynomialBezier.shapeSegment(tt, (lt + 1) % it)),
            zigZagCorner(st, tt, lt + 1, et, nt, rt, ot);
        return st;
      }),
        (ZigZagModifier.prototype.processShapes = function (tt) {
          var et,
            nt,
            rt = this.shapes.length,
            it,
            st,
            ot = this.amplitude.v,
            at = Math.max(0, Math.round(this.frequency.v)),
            lt = this.pointsType.v;
          if (ot !== 0) {
            var ct, ut;
            for (nt = 0; nt < rt; nt += 1) {
              if (
                ((ct = this.shapes[nt]),
                (ut = ct.localShapeCollection),
                !(!ct.shape._mdf && !this._mdf && !tt))
              )
                for (
                  ut.releaseShapes(),
                    ct.shape._mdf = !0,
                    et = ct.shape.paths.shapes,
                    st = ct.shape.paths._length,
                    it = 0;
                  it < st;
                  it += 1
                )
                  ut.addShape(this.processPath(et[it], ot, at, lt));
              ct.shape.paths = ct.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function linearOffset(tt, et, nt) {
        var rt = Math.atan2(et[0] - tt[0], et[1] - tt[1]);
        return [polarOffset(tt, rt, nt), polarOffset(et, rt, nt)];
      }
      function offsetSegment(tt, et) {
        var nt, rt, it, st, ot, at, lt;
        (lt = linearOffset(tt.points[0], tt.points[1], et)),
          (nt = lt[0]),
          (rt = lt[1]),
          (lt = linearOffset(tt.points[1], tt.points[2], et)),
          (it = lt[0]),
          (st = lt[1]),
          (lt = linearOffset(tt.points[2], tt.points[3], et)),
          (ot = lt[0]),
          (at = lt[1]);
        var ct = lineIntersection(nt, rt, it, st);
        ct === null && (ct = rt);
        var ut = lineIntersection(ot, at, it, st);
        return ut === null && (ut = ot), new PolynomialBezier(nt, ct, ut, at);
      }
      function joinLines(tt, et, nt, rt, it) {
        var st = et.points[3],
          ot = nt.points[0];
        if (rt === 3 || pointEqual(st, ot)) return st;
        if (rt === 2) {
          var at = -et.tangentAngle(1),
            lt = -nt.tangentAngle(0) + Math.PI,
            ct = lineIntersection(
              st,
              polarOffset(st, at + Math.PI / 2, 100),
              ot,
              polarOffset(ot, at + Math.PI / 2, 100)
            ),
            ut = ct ? pointDistance(ct, st) : pointDistance(st, ot) / 2,
            ft = polarOffset(st, at, 2 * ut * roundCorner);
          return (
            tt.setXYAt(ft[0], ft[1], "o", tt.length() - 1),
            (ft = polarOffset(ot, lt, 2 * ut * roundCorner)),
            tt.setTripleAt(
              ot[0],
              ot[1],
              ot[0],
              ot[1],
              ft[0],
              ft[1],
              tt.length()
            ),
            ot
          );
        }
        var ht = pointEqual(st, et.points[2]) ? et.points[0] : et.points[2],
          mt = pointEqual(ot, nt.points[1]) ? nt.points[3] : nt.points[1],
          vt = lineIntersection(ht, st, ot, mt);
        return vt && pointDistance(vt, st) < it
          ? (tt.setTripleAt(
              vt[0],
              vt[1],
              vt[0],
              vt[1],
              vt[0],
              vt[1],
              tt.length()
            ),
            vt)
          : st;
      }
      function getIntersection(tt, et) {
        var nt = tt.intersections(et);
        return (
          nt.length && floatEqual(nt[0][0], 1) && nt.shift(),
          nt.length ? nt[0] : null
        );
      }
      function pruneSegmentIntersection(tt, et) {
        var nt = tt.slice(),
          rt = et.slice(),
          it = getIntersection(tt[tt.length - 1], et[0]);
        return (
          it &&
            ((nt[tt.length - 1] = tt[tt.length - 1].split(it[0])[0]),
            (rt[0] = et[0].split(it[1])[1])),
          tt.length > 1 &&
          et.length > 1 &&
          ((it = getIntersection(tt[0], et[et.length - 1])), it)
            ? [[tt[0].split(it[0])[0]], [et[et.length - 1].split(it[1])[1]]]
            : [nt, rt]
        );
      }
      function pruneIntersections(tt) {
        for (var et, nt = 1; nt < tt.length; nt += 1)
          (et = pruneSegmentIntersection(tt[nt - 1], tt[nt])),
            (tt[nt - 1] = et[0]),
            (tt[nt] = et[1]);
        return (
          tt.length > 1 &&
            ((et = pruneSegmentIntersection(tt[tt.length - 1], tt[0])),
            (tt[tt.length - 1] = et[0]),
            (tt[0] = et[1])),
          tt
        );
      }
      function offsetSegmentSplit(tt, et) {
        var nt = tt.inflectionPoints(),
          rt,
          it,
          st,
          ot;
        if (nt.length === 0) return [offsetSegment(tt, et)];
        if (nt.length === 1 || floatEqual(nt[1], 1))
          return (
            (st = tt.split(nt[0])),
            (rt = st[0]),
            (it = st[1]),
            [offsetSegment(rt, et), offsetSegment(it, et)]
          );
        (st = tt.split(nt[0])), (rt = st[0]);
        var at = (nt[1] - nt[0]) / (1 - nt[0]);
        return (
          (st = st[1].split(at)),
          (ot = st[0]),
          (it = st[1]),
          [offsetSegment(rt, et), offsetSegment(ot, et), offsetSegment(it, et)]
        );
      }
      function OffsetPathModifier() {}
      extendPrototype([ShapeModifier], OffsetPathModifier),
        (OffsetPathModifier.prototype.initModifierProperties = function (
          tt,
          et
        ) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(tt, et.a, 0, null, this)),
            (this.miterLimit = PropertyFactory.getProp(
              tt,
              et.ml,
              0,
              null,
              this
            )),
            (this.lineJoin = et.lj),
            (this._isAnimated = this.amount.effectsSequence.length !== 0);
        }),
        (OffsetPathModifier.prototype.processPath = function (tt, et, nt, rt) {
          var it = shapePool.newElement();
          it.c = tt.c;
          var st = tt.length();
          tt.c || (st -= 1);
          var ot,
            at,
            lt,
            ct = [];
          for (ot = 0; ot < st; ot += 1)
            (lt = PolynomialBezier.shapeSegment(tt, ot)),
              ct.push(offsetSegmentSplit(lt, et));
          if (!tt.c)
            for (ot = st - 1; ot >= 0; ot -= 1)
              (lt = PolynomialBezier.shapeSegmentInverted(tt, ot)),
                ct.push(offsetSegmentSplit(lt, et));
          ct = pruneIntersections(ct);
          var ut = null,
            ft = null;
          for (ot = 0; ot < ct.length; ot += 1) {
            var ht = ct[ot];
            for (
              ft && (ut = joinLines(it, ft, ht[0], nt, rt)),
                ft = ht[ht.length - 1],
                at = 0;
              at < ht.length;
              at += 1
            )
              (lt = ht[at]),
                ut && pointEqual(lt.points[0], ut)
                  ? it.setXYAt(
                      lt.points[1][0],
                      lt.points[1][1],
                      "o",
                      it.length() - 1
                    )
                  : it.setTripleAt(
                      lt.points[0][0],
                      lt.points[0][1],
                      lt.points[1][0],
                      lt.points[1][1],
                      lt.points[0][0],
                      lt.points[0][1],
                      it.length()
                    ),
                it.setTripleAt(
                  lt.points[3][0],
                  lt.points[3][1],
                  lt.points[3][0],
                  lt.points[3][1],
                  lt.points[2][0],
                  lt.points[2][1],
                  it.length()
                ),
                (ut = lt.points[3]);
          }
          return ct.length && joinLines(it, ft, ct[0][0], nt, rt), it;
        }),
        (OffsetPathModifier.prototype.processShapes = function (tt) {
          var et,
            nt,
            rt = this.shapes.length,
            it,
            st,
            ot = this.amount.v,
            at = this.miterLimit.v,
            lt = this.lineJoin;
          if (ot !== 0) {
            var ct, ut;
            for (nt = 0; nt < rt; nt += 1) {
              if (
                ((ct = this.shapes[nt]),
                (ut = ct.localShapeCollection),
                !(!ct.shape._mdf && !this._mdf && !tt))
              )
                for (
                  ut.releaseShapes(),
                    ct.shape._mdf = !0,
                    et = ct.shape.paths.shapes,
                    st = ct.shape.paths._length,
                    it = 0;
                  it < st;
                  it += 1
                )
                  ut.addShape(this.processPath(et[it], ot, lt, at));
              ct.shape.paths = ct.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function getFontProperties(tt) {
        for (
          var et = tt.fStyle ? tt.fStyle.split(" ") : [],
            nt = "normal",
            rt = "normal",
            it = et.length,
            st,
            ot = 0;
          ot < it;
          ot += 1
        )
          switch (((st = et[ot].toLowerCase()), st)) {
            case "italic":
              rt = "italic";
              break;
            case "bold":
              nt = "700";
              break;
            case "black":
              nt = "900";
              break;
            case "medium":
              nt = "500";
              break;
            case "regular":
            case "normal":
              nt = "400";
              break;
            case "light":
            case "thin":
              nt = "200";
              break;
          }
        return { style: rt, weight: tt.fWeight || nt };
      }
      var FontManager = (function () {
        var tt = 5e3,
          et = { w: 0, size: 0, shapes: [], data: { shapes: [] } },
          nt = [];
        nt = nt.concat([
          2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368,
          2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
          2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403,
        ]);
        var rt = 127988,
          it = 917631,
          st = 917601,
          ot = 917626,
          at = 65039,
          lt = 8205,
          ct = 127462,
          ut = 127487,
          ft = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function ht(kt) {
          var Gt = kt.split(","),
            Pt,
            Rt = Gt.length,
            Nt = [];
          for (Pt = 0; Pt < Rt; Pt += 1)
            Gt[Pt] !== "sans-serif" &&
              Gt[Pt] !== "monospace" &&
              Nt.push(Gt[Pt]);
          return Nt.join(",");
        }
        function mt(kt, Gt) {
          var Pt = createTag("span");
          Pt.setAttribute("aria-hidden", !0), (Pt.style.fontFamily = Gt);
          var Rt = createTag("span");
          (Rt.innerText = "giItT1WQy@!-/#"),
            (Pt.style.position = "absolute"),
            (Pt.style.left = "-10000px"),
            (Pt.style.top = "-10000px"),
            (Pt.style.fontSize = "300px"),
            (Pt.style.fontVariant = "normal"),
            (Pt.style.fontStyle = "normal"),
            (Pt.style.fontWeight = "normal"),
            (Pt.style.letterSpacing = "0"),
            Pt.appendChild(Rt),
            document.body.appendChild(Pt);
          var Nt = Rt.offsetWidth;
          return (
            (Rt.style.fontFamily = ht(kt) + ", " + Gt),
            { node: Rt, w: Nt, parent: Pt }
          );
        }
        function vt() {
          var kt,
            Gt = this.fonts.length,
            Pt,
            Rt,
            Nt = Gt;
          for (kt = 0; kt < Gt; kt += 1)
            this.fonts[kt].loaded
              ? (Nt -= 1)
              : this.fonts[kt].fOrigin === "n" || this.fonts[kt].origin === 0
              ? (this.fonts[kt].loaded = !0)
              : ((Pt = this.fonts[kt].monoCase.node),
                (Rt = this.fonts[kt].monoCase.w),
                Pt.offsetWidth !== Rt
                  ? ((Nt -= 1), (this.fonts[kt].loaded = !0))
                  : ((Pt = this.fonts[kt].sansCase.node),
                    (Rt = this.fonts[kt].sansCase.w),
                    Pt.offsetWidth !== Rt &&
                      ((Nt -= 1), (this.fonts[kt].loaded = !0))),
                this.fonts[kt].loaded &&
                  (this.fonts[kt].sansCase.parent.parentNode.removeChild(
                    this.fonts[kt].sansCase.parent
                  ),
                  this.fonts[kt].monoCase.parent.parentNode.removeChild(
                    this.fonts[kt].monoCase.parent
                  )));
          Nt !== 0 && Date.now() - this.initTime < tt
            ? setTimeout(this.checkLoadedFontsBinded, 20)
            : setTimeout(this.setIsLoadedBinded, 10);
        }
        function yt(kt, Gt) {
          var Pt = document.body && Gt ? "svg" : "canvas",
            Rt,
            Nt = getFontProperties(kt);
          if (Pt === "svg") {
            var Dt = createNS("text");
            (Dt.style.fontSize = "100px"),
              Dt.setAttribute("font-family", kt.fFamily),
              Dt.setAttribute("font-style", Nt.style),
              Dt.setAttribute("font-weight", Nt.weight),
              (Dt.textContent = "1"),
              kt.fClass
                ? ((Dt.style.fontFamily = "inherit"),
                  Dt.setAttribute("class", kt.fClass))
                : (Dt.style.fontFamily = kt.fFamily),
              Gt.appendChild(Dt),
              (Rt = Dt);
          } else {
            var zt = new OffscreenCanvas(500, 500).getContext("2d");
            (zt.font = Nt.style + " " + Nt.weight + " 100px " + kt.fFamily),
              (Rt = zt);
          }
          function Yt(qt) {
            return Pt === "svg"
              ? ((Rt.textContent = qt), Rt.getComputedTextLength())
              : Rt.measureText(qt).width;
          }
          return { measureText: Yt };
        }
        function Et(kt, Gt) {
          if (!kt) {
            this.isLoaded = !0;
            return;
          }
          if (this.chars) {
            (this.isLoaded = !0), (this.fonts = kt.list);
            return;
          }
          if (!document.body) {
            (this.isLoaded = !0),
              kt.list.forEach(function (ln) {
                (ln.helper = yt(ln)), (ln.cache = {});
              }),
              (this.fonts = kt.list);
            return;
          }
          var Pt = kt.list,
            Rt,
            Nt = Pt.length,
            Dt = Nt;
          for (Rt = 0; Rt < Nt; Rt += 1) {
            var zt = !0,
              Yt,
              qt;
            if (
              ((Pt[Rt].loaded = !1),
              (Pt[Rt].monoCase = mt(Pt[Rt].fFamily, "monospace")),
              (Pt[Rt].sansCase = mt(Pt[Rt].fFamily, "sans-serif")),
              !Pt[Rt].fPath)
            )
              (Pt[Rt].loaded = !0), (Dt -= 1);
            else if (Pt[Rt].fOrigin === "p" || Pt[Rt].origin === 3) {
              if (
                ((Yt = document.querySelectorAll(
                  'style[f-forigin="p"][f-family="' +
                    Pt[Rt].fFamily +
                    '"], style[f-origin="3"][f-family="' +
                    Pt[Rt].fFamily +
                    '"]'
                )),
                Yt.length > 0 && (zt = !1),
                zt)
              ) {
                var Zt = createTag("style");
                Zt.setAttribute("f-forigin", Pt[Rt].fOrigin),
                  Zt.setAttribute("f-origin", Pt[Rt].origin),
                  Zt.setAttribute("f-family", Pt[Rt].fFamily),
                  (Zt.type = "text/css"),
                  (Zt.innerText =
                    "@font-face {font-family: " +
                    Pt[Rt].fFamily +
                    "; font-style: normal; src: url('" +
                    Pt[Rt].fPath +
                    "');}"),
                  Gt.appendChild(Zt);
              }
            } else if (Pt[Rt].fOrigin === "g" || Pt[Rt].origin === 1) {
              for (
                Yt = document.querySelectorAll(
                  'link[f-forigin="g"], link[f-origin="1"]'
                ),
                  qt = 0;
                qt < Yt.length;
                qt += 1
              )
                Yt[qt].href.indexOf(Pt[Rt].fPath) !== -1 && (zt = !1);
              if (zt) {
                var Jt = createTag("link");
                Jt.setAttribute("f-forigin", Pt[Rt].fOrigin),
                  Jt.setAttribute("f-origin", Pt[Rt].origin),
                  (Jt.type = "text/css"),
                  (Jt.rel = "stylesheet"),
                  (Jt.href = Pt[Rt].fPath),
                  document.body.appendChild(Jt);
              }
            } else if (Pt[Rt].fOrigin === "t" || Pt[Rt].origin === 2) {
              for (
                Yt = document.querySelectorAll(
                  'script[f-forigin="t"], script[f-origin="2"]'
                ),
                  qt = 0;
                qt < Yt.length;
                qt += 1
              )
                Pt[Rt].fPath === Yt[qt].src && (zt = !1);
              if (zt) {
                var mn = createTag("link");
                mn.setAttribute("f-forigin", Pt[Rt].fOrigin),
                  mn.setAttribute("f-origin", Pt[Rt].origin),
                  mn.setAttribute("rel", "stylesheet"),
                  mn.setAttribute("href", Pt[Rt].fPath),
                  Gt.appendChild(mn);
              }
            }
            (Pt[Rt].helper = yt(Pt[Rt], Gt)),
              (Pt[Rt].cache = {}),
              this.fonts.push(Pt[Rt]);
          }
          Dt === 0
            ? (this.isLoaded = !0)
            : setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
        function pt(kt) {
          if (kt) {
            this.chars || (this.chars = []);
            var Gt,
              Pt = kt.length,
              Rt,
              Nt = this.chars.length,
              Dt;
            for (Gt = 0; Gt < Pt; Gt += 1) {
              for (Rt = 0, Dt = !1; Rt < Nt; )
                this.chars[Rt].style === kt[Gt].style &&
                  this.chars[Rt].fFamily === kt[Gt].fFamily &&
                  this.chars[Rt].ch === kt[Gt].ch &&
                  (Dt = !0),
                  (Rt += 1);
              Dt || (this.chars.push(kt[Gt]), (Nt += 1));
            }
          }
        }
        function xt(kt, Gt, Pt) {
          for (var Rt = 0, Nt = this.chars.length; Rt < Nt; ) {
            if (
              this.chars[Rt].ch === kt &&
              this.chars[Rt].style === Gt &&
              this.chars[Rt].fFamily === Pt
            )
              return this.chars[Rt];
            Rt += 1;
          }
          return (
            ((typeof kt == "string" && kt.charCodeAt(0) !== 13) || !kt) &&
              console &&
              console.warn &&
              !this._warned &&
              ((this._warned = !0),
              console.warn(
                "Missing character from exported characters list: ",
                kt,
                Gt,
                Pt
              )),
            et
          );
        }
        function St(kt, Gt, Pt) {
          var Rt = this.getFontByName(Gt),
            Nt = kt;
          if (!Rt.cache[Nt]) {
            var Dt = Rt.helper;
            if (kt === " ") {
              var zt = Dt.measureText("|" + kt + "|"),
                Yt = Dt.measureText("||");
              Rt.cache[Nt] = (zt - Yt) / 100;
            } else Rt.cache[Nt] = Dt.measureText(kt) / 100;
          }
          return Rt.cache[Nt] * Pt;
        }
        function At(kt) {
          for (var Gt = 0, Pt = this.fonts.length; Gt < Pt; ) {
            if (this.fonts[Gt].fName === kt) return this.fonts[Gt];
            Gt += 1;
          }
          return this.fonts[0];
        }
        function Ct(kt) {
          var Gt = 0,
            Pt = kt.charCodeAt(0);
          if (Pt >= 55296 && Pt <= 56319) {
            var Rt = kt.charCodeAt(1);
            Rt >= 56320 &&
              Rt <= 57343 &&
              (Gt = (Pt - 55296) * 1024 + Rt - 56320 + 65536);
          }
          return Gt;
        }
        function Mt(kt, Gt) {
          var Pt = kt.toString(16) + Gt.toString(16);
          return ft.indexOf(Pt) !== -1;
        }
        function wt(kt) {
          return kt === lt;
        }
        function Bt(kt) {
          return kt === at;
        }
        function It(kt) {
          var Gt = Ct(kt);
          return Gt >= ct && Gt <= ut;
        }
        function Ft(kt) {
          return It(kt.substr(0, 2)) && It(kt.substr(2, 2));
        }
        function Vt(kt) {
          return nt.indexOf(kt) !== -1;
        }
        function $t(kt, Gt) {
          var Pt = Ct(kt.substr(Gt, 2));
          if (Pt !== rt) return !1;
          var Rt = 0;
          for (Gt += 2; Rt < 5; ) {
            if (((Pt = Ct(kt.substr(Gt, 2))), Pt < st || Pt > ot)) return !1;
            (Rt += 1), (Gt += 2);
          }
          return Ct(kt.substr(Gt, 2)) === it;
        }
        function Kt() {
          this.isLoaded = !0;
        }
        var Ht = function () {
          (this.fonts = []),
            (this.chars = null),
            (this.typekitLoaded = 0),
            (this.isLoaded = !1),
            (this._warned = !1),
            (this.initTime = Date.now()),
            (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
            (this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this));
        };
        (Ht.isModifier = Mt),
          (Ht.isZeroWidthJoiner = wt),
          (Ht.isFlagEmoji = Ft),
          (Ht.isRegionalCode = It),
          (Ht.isCombinedCharacter = Vt),
          (Ht.isRegionalFlag = $t),
          (Ht.isVariationSelector = Bt),
          (Ht.BLACK_FLAG_CODE_POINT = rt);
        var Wt = {
          addChars: pt,
          addFonts: Et,
          getCharData: xt,
          getFontByName: At,
          measureText: St,
          checkLoadedFonts: vt,
          setIsLoaded: Kt,
        };
        return (Ht.prototype = Wt), Ht;
      })();
      function SlotManager(tt) {
        this.animationData = tt;
      }
      SlotManager.prototype.getProp = function (tt) {
        return this.animationData.slots && this.animationData.slots[tt.sid]
          ? Object.assign(tt, this.animationData.slots[tt.sid].p)
          : tt;
      };
      function slotFactory(tt) {
        return new SlotManager(tt);
      }
      function RenderableElement() {}
      RenderableElement.prototype = {
        initRenderable: function () {
          (this.isInRange = !1),
            (this.hidden = !1),
            (this.isTransparent = !1),
            (this.renderableComponents = []);
        },
        addRenderableComponent: function (et) {
          this.renderableComponents.indexOf(et) === -1 &&
            this.renderableComponents.push(et);
        },
        removeRenderableComponent: function (et) {
          this.renderableComponents.indexOf(et) !== -1 &&
            this.renderableComponents.splice(
              this.renderableComponents.indexOf(et),
              1
            );
        },
        prepareRenderableFrame: function (et) {
          this.checkLayerLimits(et);
        },
        checkTransparency: function () {
          this.finalTransform.mProp.o.v <= 0
            ? !this.isTransparent &&
              this.globalData.renderConfig.hideOnTransparent &&
              ((this.isTransparent = !0), this.hide())
            : this.isTransparent && ((this.isTransparent = !1), this.show());
        },
        checkLayerLimits: function (et) {
          this.data.ip - this.data.st <= et && this.data.op - this.data.st > et
            ? this.isInRange !== !0 &&
              ((this.globalData._mdf = !0),
              (this._mdf = !0),
              (this.isInRange = !0),
              this.show())
            : this.isInRange !== !1 &&
              ((this.globalData._mdf = !0), (this.isInRange = !1), this.hide());
        },
        renderRenderable: function () {
          var et,
            nt = this.renderableComponents.length;
          for (et = 0; et < nt; et += 1)
            this.renderableComponents[et].renderFrame(this._isFirstFrame);
        },
        sourceRectAtTime: function () {
          return { top: 0, left: 0, width: 100, height: 100 };
        },
        getLayerSize: function () {
          return this.data.ty === 5
            ? { w: this.data.textData.width, h: this.data.textData.height }
            : { w: this.data.width, h: this.data.height };
        },
      };
      var getBlendMode = (function () {
        var tt = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity",
        };
        return function (et) {
          return tt[et] || "";
        };
      })();
      function SliderEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 0, 0, nt);
      }
      function AngleEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 0, 0, nt);
      }
      function ColorEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 1, 0, nt);
      }
      function PointEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 1, 0, nt);
      }
      function LayerIndexEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 0, 0, nt);
      }
      function MaskIndexEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 0, 0, nt);
      }
      function CheckboxEffect(tt, et, nt) {
        this.p = PropertyFactory.getProp(et, tt.v, 0, 0, nt);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(tt, et) {
        var nt = tt.ef || [];
        this.effectElements = [];
        var rt,
          it = nt.length,
          st;
        for (rt = 0; rt < it; rt += 1)
          (st = new GroupEffect(nt[rt], et)), this.effectElements.push(st);
      }
      function GroupEffect(tt, et) {
        this.init(tt, et);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect),
        (GroupEffect.prototype.getValue =
          GroupEffect.prototype.iterateDynamicProperties),
        (GroupEffect.prototype.init = function (tt, et) {
          (this.data = tt),
            (this.effectElements = []),
            this.initDynamicPropertyContainer(et);
          var nt,
            rt = this.data.ef.length,
            it,
            st = this.data.ef;
          for (nt = 0; nt < rt; nt += 1) {
            switch (((it = null), st[nt].ty)) {
              case 0:
                it = new SliderEffect(st[nt], et, this);
                break;
              case 1:
                it = new AngleEffect(st[nt], et, this);
                break;
              case 2:
                it = new ColorEffect(st[nt], et, this);
                break;
              case 3:
                it = new PointEffect(st[nt], et, this);
                break;
              case 4:
              case 7:
                it = new CheckboxEffect(st[nt], et, this);
                break;
              case 10:
                it = new LayerIndexEffect(st[nt], et, this);
                break;
              case 11:
                it = new MaskIndexEffect(st[nt], et, this);
                break;
              case 5:
                it = new EffectsManager(st[nt], et);
                break;
              default:
                it = new NoValueEffect(st[nt]);
                break;
            }
            it && this.effectElements.push(it);
          }
        });
      function BaseElement() {}
      BaseElement.prototype = {
        checkMasks: function () {
          if (!this.data.hasMask) return !1;
          for (var et = 0, nt = this.data.masksProperties.length; et < nt; ) {
            if (
              this.data.masksProperties[et].mode !== "n" &&
              this.data.masksProperties[et].cl !== !1
            )
              return !0;
            et += 1;
          }
          return !1;
        },
        initExpressions: function () {
          var et = getExpressionInterfaces();
          if (et) {
            var nt = et("layer"),
              rt = et("effects"),
              it = et("shape"),
              st = et("text"),
              ot = et("comp");
            (this.layerInterface = nt(this)),
              this.data.hasMask &&
                this.maskManager &&
                this.layerInterface.registerMaskInterface(this.maskManager);
            var at = rt.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(at),
              this.data.ty === 0 || this.data.xt
                ? (this.compInterface = ot(this))
                : this.data.ty === 4
                ? ((this.layerInterface.shapeInterface = it(
                    this.shapesData,
                    this.itemsData,
                    this.layerInterface
                  )),
                  (this.layerInterface.content =
                    this.layerInterface.shapeInterface))
                : this.data.ty === 5 &&
                  ((this.layerInterface.textInterface = st(this)),
                  (this.layerInterface.text =
                    this.layerInterface.textInterface));
          }
        },
        setBlendMode: function () {
          var et = getBlendMode(this.data.bm),
            nt = this.baseElement || this.layerElement;
          nt.style["mix-blend-mode"] = et;
        },
        initBaseData: function (et, nt, rt) {
          (this.globalData = nt),
            (this.comp = rt),
            (this.data = et),
            (this.layerId = createElementID()),
            this.data.sr || (this.data.sr = 1),
            (this.effectsManager = new EffectsManager(
              this.data,
              this,
              this.dynamicProperties
            ));
        },
        getType: function () {
          return this.type;
        },
        sourceRectAtTime: function () {},
      };
      function FrameElement() {}
      FrameElement.prototype = {
        initFrame: function () {
          (this._isFirstFrame = !1),
            (this.dynamicProperties = []),
            (this._mdf = !1);
        },
        prepareProperties: function (et, nt) {
          var rt,
            it = this.dynamicProperties.length;
          for (rt = 0; rt < it; rt += 1)
            (nt ||
              (this._isParent &&
                this.dynamicProperties[rt].propType === "transform")) &&
              (this.dynamicProperties[rt].getValue(),
              this.dynamicProperties[rt]._mdf &&
                ((this.globalData._mdf = !0), (this._mdf = !0)));
        },
        addDynamicProperty: function (et) {
          this.dynamicProperties.indexOf(et) === -1 &&
            this.dynamicProperties.push(et);
        },
      };
      function FootageElement(tt, et, nt) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = et.getAssetData(tt.refId)),
          (this.footageData = et.imageLoader.getAsset(this.assetData)),
          this.initBaseData(tt, et, nt);
      }
      (FootageElement.prototype.prepareFrame = function () {}),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          FootageElement
        ),
        (FootageElement.prototype.getBaseElement = function () {
          return null;
        }),
        (FootageElement.prototype.renderFrame = function () {}),
        (FootageElement.prototype.destroy = function () {}),
        (FootageElement.prototype.initExpressions = function () {
          var tt = getExpressionInterfaces();
          if (tt) {
            var et = tt("footage");
            this.layerInterface = et(this);
          }
        }),
        (FootageElement.prototype.getFootageData = function () {
          return this.footageData;
        });
      function AudioElement(tt, et, nt) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = et.getAssetData(tt.refId)),
          this.initBaseData(tt, et, nt),
          (this._isPlaying = !1),
          (this._canPlay = !1);
        var rt = this.globalData.getAssetsPath(this.assetData);
        (this.audio = this.globalData.audioController.createAudio(rt)),
          (this._currentTime = 0),
          this.globalData.audioController.addAudio(this),
          (this._volumeMultiplier = 1),
          (this._volume = 1),
          (this._previousVolume = null),
          (this.tm = tt.tm
            ? PropertyFactory.getProp(this, tt.tm, 0, et.frameRate, this)
            : { _placeholder: !0 }),
          (this.lv = PropertyFactory.getProp(
            this,
            tt.au && tt.au.lv ? tt.au.lv : { k: [100] },
            1,
            0.01,
            this
          ));
      }
      (AudioElement.prototype.prepareFrame = function (tt) {
        if (
          (this.prepareRenderableFrame(tt, !0),
          this.prepareProperties(tt, !0),
          this.tm._placeholder)
        )
          this._currentTime = tt / this.data.sr;
        else {
          var et = this.tm.v;
          this._currentTime = et;
        }
        this._volume = this.lv.v[0];
        var nt = this._volume * this._volumeMultiplier;
        this._previousVolume !== nt &&
          ((this._previousVolume = nt), this.audio.volume(nt));
      }),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          AudioElement
        ),
        (AudioElement.prototype.renderFrame = function () {
          this.isInRange &&
            this._canPlay &&
            (this._isPlaying
              ? (!this.audio.playing() ||
                  Math.abs(
                    this._currentTime / this.globalData.frameRate -
                      this.audio.seek()
                  ) > 0.1) &&
                this.audio.seek(this._currentTime / this.globalData.frameRate)
              : (this.audio.play(),
                this.audio.seek(this._currentTime / this.globalData.frameRate),
                (this._isPlaying = !0)));
        }),
        (AudioElement.prototype.show = function () {}),
        (AudioElement.prototype.hide = function () {
          this.audio.pause(), (this._isPlaying = !1);
        }),
        (AudioElement.prototype.pause = function () {
          this.audio.pause(), (this._isPlaying = !1), (this._canPlay = !1);
        }),
        (AudioElement.prototype.resume = function () {
          this._canPlay = !0;
        }),
        (AudioElement.prototype.setRate = function (tt) {
          this.audio.rate(tt);
        }),
        (AudioElement.prototype.volume = function (tt) {
          (this._volumeMultiplier = tt),
            (this._previousVolume = tt * this._volume),
            this.audio.volume(this._previousVolume);
        }),
        (AudioElement.prototype.getBaseElement = function () {
          return null;
        }),
        (AudioElement.prototype.destroy = function () {}),
        (AudioElement.prototype.sourceRectAtTime = function () {}),
        (AudioElement.prototype.initExpressions = function () {});
      function BaseRenderer() {}
      (BaseRenderer.prototype.checkLayers = function (tt) {
        var et,
          nt = this.layers.length,
          rt;
        for (this.completeLayers = !0, et = nt - 1; et >= 0; et -= 1)
          this.elements[et] ||
            ((rt = this.layers[et]),
            rt.ip - rt.st <= tt - this.layers[et].st &&
              rt.op - rt.st > tt - this.layers[et].st &&
              this.buildItem(et)),
            (this.completeLayers = this.elements[et]
              ? this.completeLayers
              : !1);
        this.checkPendingElements();
      }),
        (BaseRenderer.prototype.createItem = function (tt) {
          switch (tt.ty) {
            case 2:
              return this.createImage(tt);
            case 0:
              return this.createComp(tt);
            case 1:
              return this.createSolid(tt);
            case 3:
              return this.createNull(tt);
            case 4:
              return this.createShape(tt);
            case 5:
              return this.createText(tt);
            case 6:
              return this.createAudio(tt);
            case 13:
              return this.createCamera(tt);
            case 15:
              return this.createFootage(tt);
            default:
              return this.createNull(tt);
          }
        }),
        (BaseRenderer.prototype.createCamera = function () {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        }),
        (BaseRenderer.prototype.createAudio = function (tt) {
          return new AudioElement(tt, this.globalData, this);
        }),
        (BaseRenderer.prototype.createFootage = function (tt) {
          return new FootageElement(tt, this.globalData, this);
        }),
        (BaseRenderer.prototype.buildAllItems = function () {
          var tt,
            et = this.layers.length;
          for (tt = 0; tt < et; tt += 1) this.buildItem(tt);
          this.checkPendingElements();
        }),
        (BaseRenderer.prototype.includeLayers = function (tt) {
          this.completeLayers = !1;
          var et,
            nt = tt.length,
            rt,
            it = this.layers.length;
          for (et = 0; et < nt; et += 1)
            for (rt = 0; rt < it; ) {
              if (this.layers[rt].id === tt[et].id) {
                this.layers[rt] = tt[et];
                break;
              }
              rt += 1;
            }
        }),
        (BaseRenderer.prototype.setProjectInterface = function (tt) {
          this.globalData.projectInterface = tt;
        }),
        (BaseRenderer.prototype.initItems = function () {
          this.globalData.progressiveLoad || this.buildAllItems();
        }),
        (BaseRenderer.prototype.buildElementParenting = function (tt, et, nt) {
          for (
            var rt = this.elements, it = this.layers, st = 0, ot = it.length;
            st < ot;

          )
            it[st].ind == et &&
              (!rt[st] || rt[st] === !0
                ? (this.buildItem(st), this.addPendingElement(tt))
                : (nt.push(rt[st]),
                  rt[st].setAsParent(),
                  it[st].parent !== void 0
                    ? this.buildElementParenting(tt, it[st].parent, nt)
                    : tt.setHierarchy(nt))),
              (st += 1);
        }),
        (BaseRenderer.prototype.addPendingElement = function (tt) {
          this.pendingElements.push(tt);
        }),
        (BaseRenderer.prototype.searchExtraCompositions = function (tt) {
          var et,
            nt = tt.length;
          for (et = 0; et < nt; et += 1)
            if (tt[et].xt) {
              var rt = this.createComp(tt[et]);
              rt.initExpressions(),
                this.globalData.projectInterface.registerComposition(rt);
            }
        }),
        (BaseRenderer.prototype.getElementById = function (tt) {
          var et,
            nt = this.elements.length;
          for (et = 0; et < nt; et += 1)
            if (this.elements[et].data.ind === tt) return this.elements[et];
          return null;
        }),
        (BaseRenderer.prototype.getElementByPath = function (tt) {
          var et = tt.shift(),
            nt;
          if (typeof et == "number") nt = this.elements[et];
          else {
            var rt,
              it = this.elements.length;
            for (rt = 0; rt < it; rt += 1)
              if (this.elements[rt].data.nm === et) {
                nt = this.elements[rt];
                break;
              }
          }
          return tt.length === 0 ? nt : nt.getElementByPath(tt);
        }),
        (BaseRenderer.prototype.setupGlobalData = function (tt, et) {
          (this.globalData.fontManager = new FontManager()),
            (this.globalData.slotManager = slotFactory(tt)),
            this.globalData.fontManager.addChars(tt.chars),
            this.globalData.fontManager.addFonts(tt.fonts, et),
            (this.globalData.getAssetData =
              this.animationItem.getAssetData.bind(this.animationItem)),
            (this.globalData.getAssetsPath =
              this.animationItem.getAssetsPath.bind(this.animationItem)),
            (this.globalData.imageLoader = this.animationItem.imagePreloader),
            (this.globalData.audioController =
              this.animationItem.audioController),
            (this.globalData.frameId = 0),
            (this.globalData.frameRate = tt.fr),
            (this.globalData.nm = tt.nm),
            (this.globalData.compSize = { w: tt.w, h: tt.h });
        });
      var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" };
      function TransformElement() {}
      TransformElement.prototype = {
        initTransform: function () {
          var et = new Matrix();
          (this.finalTransform = {
            mProp: this.data.ks
              ? TransformPropertyFactory.getTransformProperty(
                  this,
                  this.data.ks,
                  this
                )
              : { o: 0 },
            _matMdf: !1,
            _localMatMdf: !1,
            _opMdf: !1,
            mat: et,
            localMat: et,
            localOpacity: 1,
          }),
            this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
            this.data.ty;
        },
        renderTransform: function () {
          if (
            ((this.finalTransform._opMdf =
              this.finalTransform.mProp.o._mdf || this._isFirstFrame),
            (this.finalTransform._matMdf =
              this.finalTransform.mProp._mdf || this._isFirstFrame),
            this.hierarchy)
          ) {
            var et,
              nt = this.finalTransform.mat,
              rt = 0,
              it = this.hierarchy.length;
            if (!this.finalTransform._matMdf)
              for (; rt < it; ) {
                if (this.hierarchy[rt].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = !0;
                  break;
                }
                rt += 1;
              }
            if (this.finalTransform._matMdf)
              for (
                et = this.finalTransform.mProp.v.props,
                  nt.cloneFromProps(et),
                  rt = 0;
                rt < it;
                rt += 1
              )
                nt.multiply(this.hierarchy[rt].finalTransform.mProp.v);
          }
          this.finalTransform._matMdf &&
            (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
            this.finalTransform._opMdf &&
              (this.finalTransform.localOpacity =
                this.finalTransform.mProp.o.v);
        },
        renderLocalTransform: function () {
          if (this.localTransforms) {
            var et = 0,
              nt = this.localTransforms.length;
            if (
              ((this.finalTransform._localMatMdf = this.finalTransform._matMdf),
              !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            )
              for (; et < nt; )
                this.localTransforms[et]._mdf &&
                  (this.finalTransform._localMatMdf = !0),
                  this.localTransforms[et]._opMdf &&
                    !this.finalTransform._opMdf &&
                    ((this.finalTransform.localOpacity =
                      this.finalTransform.mProp.o.v),
                    (this.finalTransform._opMdf = !0)),
                  (et += 1);
            if (this.finalTransform._localMatMdf) {
              var rt = this.finalTransform.localMat;
              for (
                this.localTransforms[0].matrix.clone(rt), et = 1;
                et < nt;
                et += 1
              ) {
                var it = this.localTransforms[et].matrix;
                rt.multiply(it);
              }
              rt.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var st = this.finalTransform.localOpacity;
              for (et = 0; et < nt; et += 1)
                st *= this.localTransforms[et].opacity * 0.01;
              this.finalTransform.localOpacity = st;
            }
          }
        },
        searchEffectTransforms: function () {
          if (this.renderableEffectsManager) {
            var et = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            );
            if (et.length) {
              (this.localTransforms = []),
                (this.finalTransform.localMat = new Matrix());
              var nt = 0,
                rt = et.length;
              for (nt = 0; nt < rt; nt += 1) this.localTransforms.push(et[nt]);
            }
          }
        },
        globalToLocal: function (et) {
          var nt = [];
          nt.push(this.finalTransform);
          for (var rt = !0, it = this.comp; rt; )
            it.finalTransform
              ? (it.data.hasMask && nt.splice(0, 0, it.finalTransform),
                (it = it.comp))
              : (rt = !1);
          var st,
            ot = nt.length,
            at;
          for (st = 0; st < ot; st += 1)
            (at = nt[st].mat.applyToPointArray(0, 0, 0)),
              (et = [et[0] - at[0], et[1] - at[1], 0]);
          return et;
        },
        mHelper: new Matrix(),
      };
      function MaskElement(tt, et, nt) {
        (this.data = tt),
          (this.element = et),
          (this.globalData = nt),
          (this.storedData = []),
          (this.masksProperties = this.data.masksProperties || []),
          (this.maskElement = null);
        var rt = this.globalData.defs,
          it,
          st = this.masksProperties ? this.masksProperties.length : 0;
        (this.viewData = createSizedArray(st)), (this.solidPath = "");
        var ot,
          at = this.masksProperties,
          lt = 0,
          ct = [],
          ut,
          ft,
          ht = createElementID(),
          mt,
          vt,
          yt,
          Et,
          pt = "clipPath",
          xt = "clip-path";
        for (it = 0; it < st; it += 1)
          if (
            (((at[it].mode !== "a" && at[it].mode !== "n") ||
              at[it].inv ||
              at[it].o.k !== 100 ||
              at[it].o.x) &&
              ((pt = "mask"), (xt = "mask")),
            (at[it].mode === "s" || at[it].mode === "i") && lt === 0
              ? ((mt = createNS("rect")),
                mt.setAttribute("fill", "#ffffff"),
                mt.setAttribute("width", this.element.comp.data.w || 0),
                mt.setAttribute("height", this.element.comp.data.h || 0),
                ct.push(mt))
              : (mt = null),
            (ot = createNS("path")),
            at[it].mode === "n")
          )
            (this.viewData[it] = {
              op: PropertyFactory.getProp(
                this.element,
                at[it].o,
                0,
                0.01,
                this.element
              ),
              prop: ShapePropertyFactory.getShapeProp(this.element, at[it], 3),
              elem: ot,
              lastPath: "",
            }),
              rt.appendChild(ot);
          else {
            (lt += 1),
              ot.setAttribute(
                "fill",
                at[it].mode === "s" ? "#000000" : "#ffffff"
              ),
              ot.setAttribute("clip-rule", "nonzero");
            var St;
            if (
              (at[it].x.k !== 0
                ? ((pt = "mask"),
                  (xt = "mask"),
                  (Et = PropertyFactory.getProp(
                    this.element,
                    at[it].x,
                    0,
                    null,
                    this.element
                  )),
                  (St = createElementID()),
                  (vt = createNS("filter")),
                  vt.setAttribute("id", St),
                  (yt = createNS("feMorphology")),
                  yt.setAttribute("operator", "erode"),
                  yt.setAttribute("in", "SourceGraphic"),
                  yt.setAttribute("radius", "0"),
                  vt.appendChild(yt),
                  rt.appendChild(vt),
                  ot.setAttribute(
                    "stroke",
                    at[it].mode === "s" ? "#000000" : "#ffffff"
                  ))
                : ((yt = null), (Et = null)),
              (this.storedData[it] = {
                elem: ot,
                x: Et,
                expan: yt,
                lastPath: "",
                lastOperator: "",
                filterId: St,
                lastRadius: 0,
              }),
              at[it].mode === "i")
            ) {
              ft = ct.length;
              var At = createNS("g");
              for (ut = 0; ut < ft; ut += 1) At.appendChild(ct[ut]);
              var Ct = createNS("mask");
              Ct.setAttribute("mask-type", "alpha"),
                Ct.setAttribute("id", ht + "_" + lt),
                Ct.appendChild(ot),
                rt.appendChild(Ct),
                At.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + ht + "_" + lt + ")"
                ),
                (ct.length = 0),
                ct.push(At);
            } else ct.push(ot);
            at[it].inv &&
              !this.solidPath &&
              (this.solidPath = this.createLayerSolidPath()),
              (this.viewData[it] = {
                elem: ot,
                lastPath: "",
                op: PropertyFactory.getProp(
                  this.element,
                  at[it].o,
                  0,
                  0.01,
                  this.element
                ),
                prop: ShapePropertyFactory.getShapeProp(
                  this.element,
                  at[it],
                  3
                ),
                invRect: mt,
              }),
              this.viewData[it].prop.k ||
                this.drawPath(
                  at[it],
                  this.viewData[it].prop.v,
                  this.viewData[it]
                );
          }
        for (
          this.maskElement = createNS(pt), st = ct.length, it = 0;
          it < st;
          it += 1
        )
          this.maskElement.appendChild(ct[it]);
        lt > 0 &&
          (this.maskElement.setAttribute("id", ht),
          this.element.maskedElement.setAttribute(
            xt,
            "url(" + getLocationHref() + "#" + ht + ")"
          ),
          rt.appendChild(this.maskElement)),
          this.viewData.length && this.element.addRenderableComponent(this);
      }
      (MaskElement.prototype.getMaskProperty = function (tt) {
        return this.viewData[tt].prop;
      }),
        (MaskElement.prototype.renderFrame = function (tt) {
          var et = this.element.finalTransform.mat,
            nt,
            rt = this.masksProperties.length;
          for (nt = 0; nt < rt; nt += 1)
            if (
              ((this.viewData[nt].prop._mdf || tt) &&
                this.drawPath(
                  this.masksProperties[nt],
                  this.viewData[nt].prop.v,
                  this.viewData[nt]
                ),
              (this.viewData[nt].op._mdf || tt) &&
                this.viewData[nt].elem.setAttribute(
                  "fill-opacity",
                  this.viewData[nt].op.v
                ),
              this.masksProperties[nt].mode !== "n" &&
                (this.viewData[nt].invRect &&
                  (this.element.finalTransform.mProp._mdf || tt) &&
                  this.viewData[nt].invRect.setAttribute(
                    "transform",
                    et.getInverseMatrix().to2dCSS()
                  ),
                this.storedData[nt].x && (this.storedData[nt].x._mdf || tt)))
            ) {
              var it = this.storedData[nt].expan;
              this.storedData[nt].x.v < 0
                ? (this.storedData[nt].lastOperator !== "erode" &&
                    ((this.storedData[nt].lastOperator = "erode"),
                    this.storedData[nt].elem.setAttribute(
                      "filter",
                      "url(" +
                        getLocationHref() +
                        "#" +
                        this.storedData[nt].filterId +
                        ")"
                    )),
                  it.setAttribute("radius", -this.storedData[nt].x.v))
                : (this.storedData[nt].lastOperator !== "dilate" &&
                    ((this.storedData[nt].lastOperator = "dilate"),
                    this.storedData[nt].elem.setAttribute("filter", null)),
                  this.storedData[nt].elem.setAttribute(
                    "stroke-width",
                    this.storedData[nt].x.v * 2
                  ));
            }
        }),
        (MaskElement.prototype.getMaskelement = function () {
          return this.maskElement;
        }),
        (MaskElement.prototype.createLayerSolidPath = function () {
          var tt = "M0,0 ";
          return (
            (tt += " h" + this.globalData.compSize.w),
            (tt += " v" + this.globalData.compSize.h),
            (tt += " h-" + this.globalData.compSize.w),
            (tt += " v-" + this.globalData.compSize.h + " "),
            tt
          );
        }),
        (MaskElement.prototype.drawPath = function (tt, et, nt) {
          var rt = " M" + et.v[0][0] + "," + et.v[0][1],
            it,
            st;
          for (st = et._length, it = 1; it < st; it += 1)
            rt +=
              " C" +
              et.o[it - 1][0] +
              "," +
              et.o[it - 1][1] +
              " " +
              et.i[it][0] +
              "," +
              et.i[it][1] +
              " " +
              et.v[it][0] +
              "," +
              et.v[it][1];
          if (
            (et.c &&
              st > 1 &&
              (rt +=
                " C" +
                et.o[it - 1][0] +
                "," +
                et.o[it - 1][1] +
                " " +
                et.i[0][0] +
                "," +
                et.i[0][1] +
                " " +
                et.v[0][0] +
                "," +
                et.v[0][1]),
            nt.lastPath !== rt)
          ) {
            var ot = "";
            nt.elem &&
              (et.c && (ot = tt.inv ? this.solidPath + rt : rt),
              nt.elem.setAttribute("d", ot)),
              (nt.lastPath = rt);
          }
        }),
        (MaskElement.prototype.destroy = function () {
          (this.element = null),
            (this.globalData = null),
            (this.maskElement = null),
            (this.data = null),
            (this.masksProperties = null);
        });
      var filtersFactory = (function () {
          var tt = {};
          (tt.createFilter = et), (tt.createAlphaToLuminanceFilter = nt);
          function et(rt, it) {
            var st = createNS("filter");
            return (
              st.setAttribute("id", rt),
              it !== !0 &&
                (st.setAttribute("filterUnits", "objectBoundingBox"),
                st.setAttribute("x", "0%"),
                st.setAttribute("y", "0%"),
                st.setAttribute("width", "100%"),
                st.setAttribute("height", "100%")),
              st
            );
          }
          function nt() {
            var rt = createNS("feColorMatrix");
            return (
              rt.setAttribute("type", "matrix"),
              rt.setAttribute("color-interpolation-filters", "sRGB"),
              rt.setAttribute(
                "values",
                "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
              ),
              rt
            );
          }
          return tt;
        })(),
        featureSupport = (function () {
          var tt = {
            maskType: !0,
            svgLumaHidden: !0,
            offscreenCanvas: typeof OffscreenCanvas < "u",
          };
          return (
            (/MSIE 10/i.test(navigator.userAgent) ||
              /MSIE 9/i.test(navigator.userAgent) ||
              /rv:11.0/i.test(navigator.userAgent) ||
              /Edge\/\d./i.test(navigator.userAgent)) &&
              (tt.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (tt.svgLumaHidden = !1),
            tt
          );
        })(),
        registeredEffects$1 = {},
        idPrefix = "filter_result_";
      function SVGEffects(tt) {
        var et,
          nt = "SourceGraphic",
          rt = tt.data.ef ? tt.data.ef.length : 0,
          it = createElementID(),
          st = filtersFactory.createFilter(it, !0),
          ot = 0;
        this.filters = [];
        var at;
        for (et = 0; et < rt; et += 1) {
          at = null;
          var lt = tt.data.ef[et].ty;
          if (registeredEffects$1[lt]) {
            var ct = registeredEffects$1[lt].effect;
            (at = new ct(
              st,
              tt.effectsManager.effectElements[et],
              tt,
              idPrefix + ot,
              nt
            )),
              (nt = idPrefix + ot),
              registeredEffects$1[lt].countsAsEffect && (ot += 1);
          }
          at && this.filters.push(at);
        }
        ot &&
          (tt.globalData.defs.appendChild(st),
          tt.layerElement.setAttribute(
            "filter",
            "url(" + getLocationHref() + "#" + it + ")"
          )),
          this.filters.length && tt.addRenderableComponent(this);
      }
      (SVGEffects.prototype.renderFrame = function (tt) {
        var et,
          nt = this.filters.length;
        for (et = 0; et < nt; et += 1) this.filters[et].renderFrame(tt);
      }),
        (SVGEffects.prototype.getEffects = function (tt) {
          var et,
            nt = this.filters.length,
            rt = [];
          for (et = 0; et < nt; et += 1)
            this.filters[et].type === tt && rt.push(this.filters[et]);
          return rt;
        });
      function registerEffect$1(tt, et, nt) {
        registeredEffects$1[tt] = { effect: et, countsAsEffect: nt };
      }
      function SVGBaseElement() {}
      SVGBaseElement.prototype = {
        initRendererElement: function () {
          this.layerElement = createNS("g");
        },
        createContainerElements: function () {
          (this.matteElement = createNS("g")),
            (this.transformedElement = this.layerElement),
            (this.maskedElement = this.layerElement),
            (this._sizeChanged = !1);
          var et = null;
          if (this.data.td) {
            this.matteMasks = {};
            var nt = createNS("g");
            nt.setAttribute("id", this.layerId),
              nt.appendChild(this.layerElement),
              (et = nt),
              this.globalData.defs.appendChild(nt);
          } else
            this.data.tt
              ? (this.matteElement.appendChild(this.layerElement),
                (et = this.matteElement),
                (this.baseElement = this.matteElement))
              : (this.baseElement = this.layerElement);
          if (
            (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.ty === 0 && !this.data.hd)
          ) {
            var rt = createNS("clipPath"),
              it = createNS("path");
            it.setAttribute(
              "d",
              "M0,0 L" +
                this.data.w +
                ",0 L" +
                this.data.w +
                "," +
                this.data.h +
                " L0," +
                this.data.h +
                "z"
            );
            var st = createElementID();
            if (
              (rt.setAttribute("id", st),
              rt.appendChild(it),
              this.globalData.defs.appendChild(rt),
              this.checkMasks())
            ) {
              var ot = createNS("g");
              ot.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + st + ")"
              ),
                ot.appendChild(this.layerElement),
                (this.transformedElement = ot),
                et
                  ? et.appendChild(this.transformedElement)
                  : (this.baseElement = this.transformedElement);
            } else
              this.layerElement.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + st + ")"
              );
          }
          this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          this.finalTransform._localMatMdf &&
            this.transformedElement.setAttribute(
              "transform",
              this.finalTransform.localMat.to2dCSS()
            ),
            this.finalTransform._opMdf &&
              this.transformedElement.setAttribute(
                "opacity",
                this.finalTransform.localOpacity
              );
        },
        destroyBaseElement: function () {
          (this.layerElement = null),
            (this.matteElement = null),
            this.maskManager.destroy();
        },
        getBaseElement: function () {
          return this.data.hd ? null : this.baseElement;
        },
        createRenderableComponents: function () {
          (this.maskManager = new MaskElement(
            this.data,
            this,
            this.globalData
          )),
            (this.renderableEffectsManager = new SVGEffects(this)),
            this.searchEffectTransforms();
        },
        getMatte: function (et) {
          if (
            (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[et])
          ) {
            var nt = this.layerId + "_" + et,
              rt,
              it,
              st,
              ot;
            if (et === 1 || et === 3) {
              var at = createNS("mask");
              at.setAttribute("id", nt),
                at.setAttribute("mask-type", et === 3 ? "luminance" : "alpha"),
                (st = createNS("use")),
                st.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                at.appendChild(st),
                this.globalData.defs.appendChild(at),
                !featureSupport.maskType &&
                  et === 1 &&
                  (at.setAttribute("mask-type", "luminance"),
                  (rt = createElementID()),
                  (it = filtersFactory.createFilter(rt)),
                  this.globalData.defs.appendChild(it),
                  it.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (ot = createNS("g")),
                  ot.appendChild(st),
                  at.appendChild(ot),
                  ot.setAttribute(
                    "filter",
                    "url(" + getLocationHref() + "#" + rt + ")"
                  ));
            } else if (et === 2) {
              var lt = createNS("mask");
              lt.setAttribute("id", nt), lt.setAttribute("mask-type", "alpha");
              var ct = createNS("g");
              lt.appendChild(ct),
                (rt = createElementID()),
                (it = filtersFactory.createFilter(rt));
              var ut = createNS("feComponentTransfer");
              ut.setAttribute("in", "SourceGraphic"), it.appendChild(ut);
              var ft = createNS("feFuncA");
              ft.setAttribute("type", "table"),
                ft.setAttribute("tableValues", "1.0 0.0"),
                ut.appendChild(ft),
                this.globalData.defs.appendChild(it);
              var ht = createNS("rect");
              ht.setAttribute("width", this.comp.data.w),
                ht.setAttribute("height", this.comp.data.h),
                ht.setAttribute("x", "0"),
                ht.setAttribute("y", "0"),
                ht.setAttribute("fill", "#ffffff"),
                ht.setAttribute("opacity", "0"),
                ct.setAttribute(
                  "filter",
                  "url(" + getLocationHref() + "#" + rt + ")"
                ),
                ct.appendChild(ht),
                (st = createNS("use")),
                st.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                ct.appendChild(st),
                featureSupport.maskType ||
                  (lt.setAttribute("mask-type", "luminance"),
                  it.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (ot = createNS("g")),
                  ct.appendChild(ht),
                  ot.appendChild(this.layerElement),
                  ct.appendChild(ot)),
                this.globalData.defs.appendChild(lt);
            }
            this.matteMasks[et] = nt;
          }
          return this.matteMasks[et];
        },
        setMatte: function (et) {
          this.matteElement &&
            this.matteElement.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + et + ")"
            );
        },
      };
      function HierarchyElement() {}
      HierarchyElement.prototype = {
        initHierarchy: function () {
          (this.hierarchy = []), (this._isParent = !1), this.checkParenting();
        },
        setHierarchy: function (et) {
          this.hierarchy = et;
        },
        setAsParent: function () {
          this._isParent = !0;
        },
        checkParenting: function () {
          this.data.parent !== void 0 &&
            this.comp.buildElementParenting(this, this.data.parent, []);
        },
      };
      function RenderableDOMElement() {}
      (function () {
        var tt = {
          initElement: function (nt, rt, it) {
            this.initFrame(),
              this.initBaseData(nt, rt, it),
              this.initTransform(nt, rt, it),
              this.initHierarchy(),
              this.initRenderable(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              this.createContent(),
              this.hide();
          },
          hide: function () {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var nt = this.baseElement || this.layerElement;
              (nt.style.display = "none"), (this.hidden = !0);
            }
          },
          show: function () {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var nt = this.baseElement || this.layerElement;
                nt.style.display = "block";
              }
              (this.hidden = !1), (this._isFirstFrame = !0);
            }
          },
          renderFrame: function () {
            this.data.hd ||
              this.hidden ||
              (this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.renderElement(),
              this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1));
          },
          renderInnerContent: function () {},
          prepareFrame: function (nt) {
            (this._mdf = !1),
              this.prepareRenderableFrame(nt),
              this.prepareProperties(nt, this.isInRange),
              this.checkTransparency();
          },
          destroy: function () {
            (this.innerElem = null), this.destroyBaseElement();
          },
        };
        extendPrototype(
          [RenderableElement, createProxyFunction(tt)],
          RenderableDOMElement
        );
      })();
      function IImageElement(tt, et, nt) {
        (this.assetData = et.getAssetData(tt.refId)),
          this.assetData &&
            this.assetData.sid &&
            (this.assetData = et.slotManager.getProp(this.assetData)),
          this.initElement(tt, et, nt),
          (this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h,
          });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        IImageElement
      ),
        (IImageElement.prototype.createContent = function () {
          var tt = this.globalData.getAssetsPath(this.assetData);
          (this.innerElem = createNS("image")),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute(
              "preserveAspectRatio",
              this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            ),
            this.innerElem.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              tt
            ),
            this.layerElement.appendChild(this.innerElem);
        }),
        (IImageElement.prototype.sourceRectAtTime = function () {
          return this.sourceRect;
        });
      function ProcessedElement(tt, et) {
        (this.elem = tt), (this.pos = et);
      }
      function IShapeElement() {}
      IShapeElement.prototype = {
        addShapeToModifiers: function (et) {
          var nt,
            rt = this.shapeModifiers.length;
          for (nt = 0; nt < rt; nt += 1) this.shapeModifiers[nt].addShape(et);
        },
        isShapeInAnimatedModifiers: function (et) {
          for (var nt = 0, rt = this.shapeModifiers.length; nt < rt; )
            if (this.shapeModifiers[nt].isAnimatedWithShape(et)) return !0;
          return !1;
        },
        renderModifiers: function () {
          if (this.shapeModifiers.length) {
            var et,
              nt = this.shapes.length;
            for (et = 0; et < nt; et += 1) this.shapes[et].sh.reset();
            nt = this.shapeModifiers.length;
            var rt;
            for (
              et = nt - 1;
              et >= 0 &&
              ((rt = this.shapeModifiers[et].processShapes(this._isFirstFrame)),
              !rt);
              et -= 1
            );
          }
        },
        searchProcessedElement: function (et) {
          for (
            var nt = this.processedElements, rt = 0, it = nt.length;
            rt < it;

          ) {
            if (nt[rt].elem === et) return nt[rt].pos;
            rt += 1;
          }
          return 0;
        },
        addProcessedElement: function (et, nt) {
          for (var rt = this.processedElements, it = rt.length; it; )
            if (((it -= 1), rt[it].elem === et)) {
              rt[it].pos = nt;
              return;
            }
          rt.push(new ProcessedElement(et, nt));
        },
        prepareFrame: function (et) {
          this.prepareRenderableFrame(et),
            this.prepareProperties(et, this.isInRange);
        },
      };
      var lineCapEnum = { 1: "butt", 2: "round", 3: "square" },
        lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" };
      function SVGShapeData(tt, et, nt) {
        (this.caches = []),
          (this.styles = []),
          (this.transformers = tt),
          (this.lStr = ""),
          (this.sh = nt),
          (this.lvl = et),
          (this._isAnimated = !!nt.k);
        for (var rt = 0, it = tt.length; rt < it; ) {
          if (tt[rt].mProps.dynamicProperties.length) {
            this._isAnimated = !0;
            break;
          }
          rt += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function () {
        this._isAnimated = !0;
      };
      function SVGStyleData(tt, et) {
        (this.data = tt),
          (this.type = tt.ty),
          (this.d = ""),
          (this.lvl = et),
          (this._mdf = !1),
          (this.closed = tt.hd === !0),
          (this.pElem = createNS("path")),
          (this.msElem = null);
      }
      SVGStyleData.prototype.reset = function () {
        (this.d = ""), (this._mdf = !1);
      };
      function DashProperty(tt, et, nt, rt) {
        (this.elem = tt),
          (this.frameId = -1),
          (this.dataProps = createSizedArray(et.length)),
          (this.renderer = nt),
          (this.k = !1),
          (this.dashStr = ""),
          (this.dashArray = createTypedArray(
            "float32",
            et.length ? et.length - 1 : 0
          )),
          (this.dashoffset = createTypedArray("float32", 1)),
          this.initDynamicPropertyContainer(rt);
        var it,
          st = et.length || 0,
          ot;
        for (it = 0; it < st; it += 1)
          (ot = PropertyFactory.getProp(tt, et[it].v, 0, 0, this)),
            (this.k = ot.k || this.k),
            (this.dataProps[it] = { n: et[it].n, p: ot });
        this.k || this.getValue(!0), (this._isAnimated = this.k);
      }
      (DashProperty.prototype.getValue = function (tt) {
        if (
          !(this.elem.globalData.frameId === this.frameId && !tt) &&
          ((this.frameId = this.elem.globalData.frameId),
          this.iterateDynamicProperties(),
          (this._mdf = this._mdf || tt),
          this._mdf)
        ) {
          var et = 0,
            nt = this.dataProps.length;
          for (
            this.renderer === "svg" && (this.dashStr = ""), et = 0;
            et < nt;
            et += 1
          )
            this.dataProps[et].n !== "o"
              ? this.renderer === "svg"
                ? (this.dashStr += " " + this.dataProps[et].p.v)
                : (this.dashArray[et] = this.dataProps[et].p.v)
              : (this.dashoffset[0] = this.dataProps[et].p.v);
        }
      }),
        extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(tt, et, nt) {
        this.initDynamicPropertyContainer(tt),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(tt, et.o, 0, 0.01, this)),
          (this.w = PropertyFactory.getProp(tt, et.w, 0, null, this)),
          (this.d = new DashProperty(tt, et.d || {}, "svg", this)),
          (this.c = PropertyFactory.getProp(tt, et.c, 1, 255, this)),
          (this.style = nt),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(tt, et, nt) {
        this.initDynamicPropertyContainer(tt),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(tt, et.o, 0, 0.01, this)),
          (this.c = PropertyFactory.getProp(tt, et.c, 1, 255, this)),
          (this.style = nt);
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(tt, et, nt) {
        this.initDynamicPropertyContainer(tt),
          (this.getValue = this.iterateDynamicProperties),
          (this.style = nt);
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(tt, et, nt) {
        (this.data = et), (this.c = createTypedArray("uint8c", et.p * 4));
        var rt = et.k.k[0].s
          ? et.k.k[0].s.length - et.p * 4
          : et.k.k.length - et.p * 4;
        (this.o = createTypedArray("float32", rt)),
          (this._cmdf = !1),
          (this._omdf = !1),
          (this._collapsable = this.checkCollapsable()),
          (this._hasOpacity = rt),
          this.initDynamicPropertyContainer(nt),
          (this.prop = PropertyFactory.getProp(tt, et.k, 1, null, this)),
          (this.k = this.prop.k),
          this.getValue(!0);
      }
      (GradientProperty.prototype.comparePoints = function (tt, et) {
        for (var nt = 0, rt = this.o.length / 2, it; nt < rt; ) {
          if (((it = Math.abs(tt[nt * 4] - tt[et * 4 + nt * 2])), it > 0.01))
            return !1;
          nt += 1;
        }
        return !0;
      }),
        (GradientProperty.prototype.checkCollapsable = function () {
          if (this.o.length / 2 !== this.c.length / 4) return !1;
          if (this.data.k.k[0].s)
            for (var tt = 0, et = this.data.k.k.length; tt < et; ) {
              if (!this.comparePoints(this.data.k.k[tt].s, this.data.p))
                return !1;
              tt += 1;
            }
          else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
          return !0;
        }),
        (GradientProperty.prototype.getValue = function (tt) {
          if (
            (this.prop.getValue(),
            (this._mdf = !1),
            (this._cmdf = !1),
            (this._omdf = !1),
            this.prop._mdf || tt)
          ) {
            var et,
              nt = this.data.p * 4,
              rt,
              it;
            for (et = 0; et < nt; et += 1)
              (rt = et % 4 === 0 ? 100 : 255),
                (it = Math.round(this.prop.v[et] * rt)),
                this.c[et] !== it && ((this.c[et] = it), (this._cmdf = !tt));
            if (this.o.length)
              for (
                nt = this.prop.v.length, et = this.data.p * 4;
                et < nt;
                et += 1
              )
                (rt = et % 2 === 0 ? 100 : 1),
                  (it =
                    et % 2 === 0
                      ? Math.round(this.prop.v[et] * 100)
                      : this.prop.v[et]),
                  this.o[et - this.data.p * 4] !== it &&
                    ((this.o[et - this.data.p * 4] = it), (this._omdf = !tt));
            this._mdf = !tt;
          }
        }),
        extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(tt, et, nt) {
        this.initDynamicPropertyContainer(tt),
          (this.getValue = this.iterateDynamicProperties),
          this.initGradientData(tt, et, nt);
      }
      (SVGGradientFillStyleData.prototype.initGradientData = function (
        tt,
        et,
        nt
      ) {
        (this.o = PropertyFactory.getProp(tt, et.o, 0, 0.01, this)),
          (this.s = PropertyFactory.getProp(tt, et.s, 1, null, this)),
          (this.e = PropertyFactory.getProp(tt, et.e, 1, null, this)),
          (this.h = PropertyFactory.getProp(
            tt,
            et.h || { k: 0 },
            0,
            0.01,
            this
          )),
          (this.a = PropertyFactory.getProp(
            tt,
            et.a || { k: 0 },
            0,
            degToRads,
            this
          )),
          (this.g = new GradientProperty(tt, et.g, this)),
          (this.style = nt),
          (this.stops = []),
          this.setGradientData(nt.pElem, et),
          this.setGradientOpacity(et, nt),
          (this._isAnimated = !!this._isAnimated);
      }),
        (SVGGradientFillStyleData.prototype.setGradientData = function (
          tt,
          et
        ) {
          var nt = createElementID(),
            rt = createNS(et.t === 1 ? "linearGradient" : "radialGradient");
          rt.setAttribute("id", nt),
            rt.setAttribute("spreadMethod", "pad"),
            rt.setAttribute("gradientUnits", "userSpaceOnUse");
          var it = [],
            st,
            ot,
            at;
          for (at = et.g.p * 4, ot = 0; ot < at; ot += 4)
            (st = createNS("stop")), rt.appendChild(st), it.push(st);
          tt.setAttribute(
            et.ty === "gf" ? "fill" : "stroke",
            "url(" + getLocationHref() + "#" + nt + ")"
          ),
            (this.gf = rt),
            (this.cst = it);
        }),
        (SVGGradientFillStyleData.prototype.setGradientOpacity = function (
          tt,
          et
        ) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var nt,
              rt,
              it,
              st = createNS("mask"),
              ot = createNS("path");
            st.appendChild(ot);
            var at = createElementID(),
              lt = createElementID();
            st.setAttribute("id", lt);
            var ct = createNS(tt.t === 1 ? "linearGradient" : "radialGradient");
            ct.setAttribute("id", at),
              ct.setAttribute("spreadMethod", "pad"),
              ct.setAttribute("gradientUnits", "userSpaceOnUse"),
              (it = tt.g.k.k[0].s ? tt.g.k.k[0].s.length : tt.g.k.k.length);
            var ut = this.stops;
            for (rt = tt.g.p * 4; rt < it; rt += 2)
              (nt = createNS("stop")),
                nt.setAttribute("stop-color", "rgb(255,255,255)"),
                ct.appendChild(nt),
                ut.push(nt);
            ot.setAttribute(
              tt.ty === "gf" ? "fill" : "stroke",
              "url(" + getLocationHref() + "#" + at + ")"
            ),
              tt.ty === "gs" &&
                (ot.setAttribute("stroke-linecap", lineCapEnum[tt.lc || 2]),
                ot.setAttribute("stroke-linejoin", lineJoinEnum[tt.lj || 2]),
                tt.lj === 1 && ot.setAttribute("stroke-miterlimit", tt.ml)),
              (this.of = ct),
              (this.ms = st),
              (this.ost = ut),
              (this.maskId = lt),
              (et.msElem = ot);
          }
        }),
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(tt, et, nt) {
        this.initDynamicPropertyContainer(tt),
          (this.getValue = this.iterateDynamicProperties),
          (this.w = PropertyFactory.getProp(tt, et.w, 0, null, this)),
          (this.d = new DashProperty(tt, et.d || {}, "svg", this)),
          this.initGradientData(tt, et, nt),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype(
        [SVGGradientFillStyleData, DynamicPropertyContainer],
        SVGGradientStrokeStyleData
      );
      function ShapeGroupData() {
        (this.it = []), (this.prevViewData = []), (this.gr = createNS("g"));
      }
      function SVGTransformData(tt, et, nt) {
        (this.transform = { mProps: tt, op: et, container: nt }),
          (this.elements = []),
          (this._isAnimated =
            this.transform.mProps.dynamicProperties.length ||
            this.transform.op.effectsSequence.length);
      }
      var buildShapeString = function (et, nt, rt, it) {
          if (nt === 0) return "";
          var st = et.o,
            ot = et.i,
            at = et.v,
            lt,
            ct = " M" + it.applyToPointStringified(at[0][0], at[0][1]);
          for (lt = 1; lt < nt; lt += 1)
            ct +=
              " C" +
              it.applyToPointStringified(st[lt - 1][0], st[lt - 1][1]) +
              " " +
              it.applyToPointStringified(ot[lt][0], ot[lt][1]) +
              " " +
              it.applyToPointStringified(at[lt][0], at[lt][1]);
          return (
            rt &&
              nt &&
              ((ct +=
                " C" +
                it.applyToPointStringified(st[lt - 1][0], st[lt - 1][1]) +
                " " +
                it.applyToPointStringified(ot[0][0], ot[0][1]) +
                " " +
                it.applyToPointStringified(at[0][0], at[0][1])),
              (ct += "z")),
            ct
          );
        },
        SVGElementsRenderer = (function () {
          var tt = new Matrix(),
            et = new Matrix(),
            nt = { createRenderFunction: rt };
          function rt(ft) {
            switch (ft.ty) {
              case "fl":
                return at;
              case "gf":
                return ct;
              case "gs":
                return lt;
              case "st":
                return ut;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return ot;
              case "tr":
                return it;
              case "no":
                return st;
              default:
                return null;
            }
          }
          function it(ft, ht, mt) {
            (mt || ht.transform.op._mdf) &&
              ht.transform.container.setAttribute("opacity", ht.transform.op.v),
              (mt || ht.transform.mProps._mdf) &&
                ht.transform.container.setAttribute(
                  "transform",
                  ht.transform.mProps.v.to2dCSS()
                );
          }
          function st() {}
          function ot(ft, ht, mt) {
            var vt,
              yt,
              Et,
              pt,
              xt,
              St,
              At = ht.styles.length,
              Ct = ht.lvl,
              Mt,
              wt,
              Bt,
              It;
            for (St = 0; St < At; St += 1) {
              if (((pt = ht.sh._mdf || mt), ht.styles[St].lvl < Ct)) {
                for (
                  wt = et.reset(),
                    Bt = Ct - ht.styles[St].lvl,
                    It = ht.transformers.length - 1;
                  !pt && Bt > 0;

                )
                  (pt = ht.transformers[It].mProps._mdf || pt),
                    (Bt -= 1),
                    (It -= 1);
                if (pt)
                  for (
                    Bt = Ct - ht.styles[St].lvl,
                      It = ht.transformers.length - 1;
                    Bt > 0;

                  )
                    wt.multiply(ht.transformers[It].mProps.v),
                      (Bt -= 1),
                      (It -= 1);
              } else wt = tt;
              if (((Mt = ht.sh.paths), (yt = Mt._length), pt)) {
                for (Et = "", vt = 0; vt < yt; vt += 1)
                  (xt = Mt.shapes[vt]),
                    xt &&
                      xt._length &&
                      (Et += buildShapeString(xt, xt._length, xt.c, wt));
                ht.caches[St] = Et;
              } else Et = ht.caches[St];
              (ht.styles[St].d += ft.hd === !0 ? "" : Et),
                (ht.styles[St]._mdf = pt || ht.styles[St]._mdf);
            }
          }
          function at(ft, ht, mt) {
            var vt = ht.style;
            (ht.c._mdf || mt) &&
              vt.pElem.setAttribute(
                "fill",
                "rgb(" +
                  bmFloor(ht.c.v[0]) +
                  "," +
                  bmFloor(ht.c.v[1]) +
                  "," +
                  bmFloor(ht.c.v[2]) +
                  ")"
              ),
              (ht.o._mdf || mt) &&
                vt.pElem.setAttribute("fill-opacity", ht.o.v);
          }
          function lt(ft, ht, mt) {
            ct(ft, ht, mt), ut(ft, ht, mt);
          }
          function ct(ft, ht, mt) {
            var vt = ht.gf,
              yt = ht.g._hasOpacity,
              Et = ht.s.v,
              pt = ht.e.v;
            if (ht.o._mdf || mt) {
              var xt = ft.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              ht.style.pElem.setAttribute(xt, ht.o.v);
            }
            if (ht.s._mdf || mt) {
              var St = ft.t === 1 ? "x1" : "cx",
                At = St === "x1" ? "y1" : "cy";
              vt.setAttribute(St, Et[0]),
                vt.setAttribute(At, Et[1]),
                yt &&
                  !ht.g._collapsable &&
                  (ht.of.setAttribute(St, Et[0]),
                  ht.of.setAttribute(At, Et[1]));
            }
            var Ct, Mt, wt, Bt;
            if (ht.g._cmdf || mt) {
              Ct = ht.cst;
              var It = ht.g.c;
              for (wt = Ct.length, Mt = 0; Mt < wt; Mt += 1)
                (Bt = Ct[Mt]),
                  Bt.setAttribute("offset", It[Mt * 4] + "%"),
                  Bt.setAttribute(
                    "stop-color",
                    "rgb(" +
                      It[Mt * 4 + 1] +
                      "," +
                      It[Mt * 4 + 2] +
                      "," +
                      It[Mt * 4 + 3] +
                      ")"
                  );
            }
            if (yt && (ht.g._omdf || mt)) {
              var Ft = ht.g.o;
              for (
                ht.g._collapsable ? (Ct = ht.cst) : (Ct = ht.ost),
                  wt = Ct.length,
                  Mt = 0;
                Mt < wt;
                Mt += 1
              )
                (Bt = Ct[Mt]),
                  ht.g._collapsable ||
                    Bt.setAttribute("offset", Ft[Mt * 2] + "%"),
                  Bt.setAttribute("stop-opacity", Ft[Mt * 2 + 1]);
            }
            if (ft.t === 1)
              (ht.e._mdf || mt) &&
                (vt.setAttribute("x2", pt[0]),
                vt.setAttribute("y2", pt[1]),
                yt &&
                  !ht.g._collapsable &&
                  (ht.of.setAttribute("x2", pt[0]),
                  ht.of.setAttribute("y2", pt[1])));
            else {
              var Vt;
              if (
                ((ht.s._mdf || ht.e._mdf || mt) &&
                  ((Vt = Math.sqrt(
                    Math.pow(Et[0] - pt[0], 2) + Math.pow(Et[1] - pt[1], 2)
                  )),
                  vt.setAttribute("r", Vt),
                  yt && !ht.g._collapsable && ht.of.setAttribute("r", Vt)),
                ht.e._mdf || ht.h._mdf || ht.a._mdf || mt)
              ) {
                Vt ||
                  (Vt = Math.sqrt(
                    Math.pow(Et[0] - pt[0], 2) + Math.pow(Et[1] - pt[1], 2)
                  ));
                var $t = Math.atan2(pt[1] - Et[1], pt[0] - Et[0]),
                  Kt = ht.h.v;
                Kt >= 1 ? (Kt = 0.99) : Kt <= -1 && (Kt = -0.99);
                var Ht = Vt * Kt,
                  Wt = Math.cos($t + ht.a.v) * Ht + Et[0],
                  kt = Math.sin($t + ht.a.v) * Ht + Et[1];
                vt.setAttribute("fx", Wt),
                  vt.setAttribute("fy", kt),
                  yt &&
                    !ht.g._collapsable &&
                    (ht.of.setAttribute("fx", Wt),
                    ht.of.setAttribute("fy", kt));
              }
            }
          }
          function ut(ft, ht, mt) {
            var vt = ht.style,
              yt = ht.d;
            yt &&
              (yt._mdf || mt) &&
              yt.dashStr &&
              (vt.pElem.setAttribute("stroke-dasharray", yt.dashStr),
              vt.pElem.setAttribute("stroke-dashoffset", yt.dashoffset[0])),
              ht.c &&
                (ht.c._mdf || mt) &&
                vt.pElem.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(ht.c.v[0]) +
                    "," +
                    bmFloor(ht.c.v[1]) +
                    "," +
                    bmFloor(ht.c.v[2]) +
                    ")"
                ),
              (ht.o._mdf || mt) &&
                vt.pElem.setAttribute("stroke-opacity", ht.o.v),
              (ht.w._mdf || mt) &&
                (vt.pElem.setAttribute("stroke-width", ht.w.v),
                vt.msElem && vt.msElem.setAttribute("stroke-width", ht.w.v));
          }
          return nt;
        })();
      function SVGShapeElement(tt, et, nt) {
        (this.shapes = []),
          (this.shapesData = tt.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          this.initElement(tt, et, nt),
          (this.prevViewData = []);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        SVGShapeElement
      ),
        (SVGShapeElement.prototype.initSecondaryElement = function () {}),
        (SVGShapeElement.prototype.identityMatrix = new Matrix()),
        (SVGShapeElement.prototype.buildExpressionInterface = function () {}),
        (SVGShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.layerElement,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes();
        }),
        (SVGShapeElement.prototype.filterUniqueShapes = function () {
          var tt,
            et = this.shapes.length,
            nt,
            rt,
            it = this.stylesList.length,
            st,
            ot = [],
            at = !1;
          for (rt = 0; rt < it; rt += 1) {
            for (
              st = this.stylesList[rt], at = !1, ot.length = 0, tt = 0;
              tt < et;
              tt += 1
            )
              (nt = this.shapes[tt]),
                nt.styles.indexOf(st) !== -1 &&
                  (ot.push(nt), (at = nt._isAnimated || at));
            ot.length > 1 && at && this.setShapesAsAnimated(ot);
          }
        }),
        (SVGShapeElement.prototype.setShapesAsAnimated = function (tt) {
          var et,
            nt = tt.length;
          for (et = 0; et < nt; et += 1) tt[et].setAsAnimated();
        }),
        (SVGShapeElement.prototype.createStyleElement = function (tt, et) {
          var nt,
            rt = new SVGStyleData(tt, et),
            it = rt.pElem;
          if (tt.ty === "st") nt = new SVGStrokeStyleData(this, tt, rt);
          else if (tt.ty === "fl") nt = new SVGFillStyleData(this, tt, rt);
          else if (tt.ty === "gf" || tt.ty === "gs") {
            var st =
              tt.ty === "gf"
                ? SVGGradientFillStyleData
                : SVGGradientStrokeStyleData;
            (nt = new st(this, tt, rt)),
              this.globalData.defs.appendChild(nt.gf),
              nt.maskId &&
                (this.globalData.defs.appendChild(nt.ms),
                this.globalData.defs.appendChild(nt.of),
                it.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + nt.maskId + ")"
                ));
          } else tt.ty === "no" && (nt = new SVGNoStyleData(this, tt, rt));
          return (
            (tt.ty === "st" || tt.ty === "gs") &&
              (it.setAttribute("stroke-linecap", lineCapEnum[tt.lc || 2]),
              it.setAttribute("stroke-linejoin", lineJoinEnum[tt.lj || 2]),
              it.setAttribute("fill-opacity", "0"),
              tt.lj === 1 && it.setAttribute("stroke-miterlimit", tt.ml)),
            tt.r === 2 && it.setAttribute("fill-rule", "evenodd"),
            tt.ln && it.setAttribute("id", tt.ln),
            tt.cl && it.setAttribute("class", tt.cl),
            tt.bm && (it.style["mix-blend-mode"] = getBlendMode(tt.bm)),
            this.stylesList.push(rt),
            this.addToAnimatedContents(tt, nt),
            nt
          );
        }),
        (SVGShapeElement.prototype.createGroupElement = function (tt) {
          var et = new ShapeGroupData();
          return (
            tt.ln && et.gr.setAttribute("id", tt.ln),
            tt.cl && et.gr.setAttribute("class", tt.cl),
            tt.bm && (et.gr.style["mix-blend-mode"] = getBlendMode(tt.bm)),
            et
          );
        }),
        (SVGShapeElement.prototype.createTransformElement = function (tt, et) {
          var nt = TransformPropertyFactory.getTransformProperty(
              this,
              tt,
              this
            ),
            rt = new SVGTransformData(nt, nt.o, et);
          return this.addToAnimatedContents(tt, rt), rt;
        }),
        (SVGShapeElement.prototype.createShapeElement = function (tt, et, nt) {
          var rt = 4;
          tt.ty === "rc"
            ? (rt = 5)
            : tt.ty === "el"
            ? (rt = 6)
            : tt.ty === "sr" && (rt = 7);
          var it = ShapePropertyFactory.getShapeProp(this, tt, rt, this),
            st = new SVGShapeData(et, nt, it);
          return (
            this.shapes.push(st),
            this.addShapeToModifiers(st),
            this.addToAnimatedContents(tt, st),
            st
          );
        }),
        (SVGShapeElement.prototype.addToAnimatedContents = function (tt, et) {
          for (var nt = 0, rt = this.animatedContents.length; nt < rt; ) {
            if (this.animatedContents[nt].element === et) return;
            nt += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(tt),
            element: et,
            data: tt,
          });
        }),
        (SVGShapeElement.prototype.setElementStyles = function (tt) {
          var et = tt.styles,
            nt,
            rt = this.stylesList.length;
          for (nt = 0; nt < rt; nt += 1)
            this.stylesList[nt].closed || et.push(this.stylesList[nt]);
        }),
        (SVGShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var tt,
            et = this.itemsData.length;
          for (tt = 0; tt < et; tt += 1)
            this.prevViewData[tt] = this.itemsData[tt];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes(),
              et = this.dynamicProperties.length,
              tt = 0;
            tt < et;
            tt += 1
          )
            this.dynamicProperties[tt].getValue();
          this.renderModifiers();
        }),
        (SVGShapeElement.prototype.searchShapes = function (
          tt,
          et,
          nt,
          rt,
          it,
          st,
          ot
        ) {
          var at = [].concat(st),
            lt,
            ct = tt.length - 1,
            ut,
            ft,
            ht = [],
            mt = [],
            vt,
            yt,
            Et;
          for (lt = ct; lt >= 0; lt -= 1) {
            if (
              ((Et = this.searchProcessedElement(tt[lt])),
              Et ? (et[lt] = nt[Et - 1]) : (tt[lt]._render = ot),
              tt[lt].ty === "fl" ||
                tt[lt].ty === "st" ||
                tt[lt].ty === "gf" ||
                tt[lt].ty === "gs" ||
                tt[lt].ty === "no")
            )
              Et
                ? (et[lt].style.closed = !1)
                : (et[lt] = this.createStyleElement(tt[lt], it)),
                tt[lt]._render &&
                  et[lt].style.pElem.parentNode !== rt &&
                  rt.appendChild(et[lt].style.pElem),
                ht.push(et[lt].style);
            else if (tt[lt].ty === "gr") {
              if (!Et) et[lt] = this.createGroupElement(tt[lt]);
              else
                for (ft = et[lt].it.length, ut = 0; ut < ft; ut += 1)
                  et[lt].prevViewData[ut] = et[lt].it[ut];
              this.searchShapes(
                tt[lt].it,
                et[lt].it,
                et[lt].prevViewData,
                et[lt].gr,
                it + 1,
                at,
                ot
              ),
                tt[lt]._render &&
                  et[lt].gr.parentNode !== rt &&
                  rt.appendChild(et[lt].gr);
            } else
              tt[lt].ty === "tr"
                ? (Et || (et[lt] = this.createTransformElement(tt[lt], rt)),
                  (vt = et[lt].transform),
                  at.push(vt))
                : tt[lt].ty === "sh" ||
                  tt[lt].ty === "rc" ||
                  tt[lt].ty === "el" ||
                  tt[lt].ty === "sr"
                ? (Et || (et[lt] = this.createShapeElement(tt[lt], at, it)),
                  this.setElementStyles(et[lt]))
                : tt[lt].ty === "tm" ||
                  tt[lt].ty === "rd" ||
                  tt[lt].ty === "ms" ||
                  tt[lt].ty === "pb" ||
                  tt[lt].ty === "zz" ||
                  tt[lt].ty === "op"
                ? (Et
                    ? ((yt = et[lt]), (yt.closed = !1))
                    : ((yt = ShapeModifiers.getModifier(tt[lt].ty)),
                      yt.init(this, tt[lt]),
                      (et[lt] = yt),
                      this.shapeModifiers.push(yt)),
                  mt.push(yt))
                : tt[lt].ty === "rp" &&
                  (Et
                    ? ((yt = et[lt]), (yt.closed = !0))
                    : ((yt = ShapeModifiers.getModifier(tt[lt].ty)),
                      (et[lt] = yt),
                      yt.init(this, tt, lt, et),
                      this.shapeModifiers.push(yt),
                      (ot = !1)),
                  mt.push(yt));
            this.addProcessedElement(tt[lt], lt + 1);
          }
          for (ct = ht.length, lt = 0; lt < ct; lt += 1) ht[lt].closed = !0;
          for (ct = mt.length, lt = 0; lt < ct; lt += 1) mt[lt].closed = !0;
        }),
        (SVGShapeElement.prototype.renderInnerContent = function () {
          this.renderModifiers();
          var tt,
            et = this.stylesList.length;
          for (tt = 0; tt < et; tt += 1) this.stylesList[tt].reset();
          for (this.renderShape(), tt = 0; tt < et; tt += 1)
            (this.stylesList[tt]._mdf || this._isFirstFrame) &&
              (this.stylesList[tt].msElem &&
                (this.stylesList[tt].msElem.setAttribute(
                  "d",
                  this.stylesList[tt].d
                ),
                (this.stylesList[tt].d = "M0 0" + this.stylesList[tt].d)),
              this.stylesList[tt].pElem.setAttribute(
                "d",
                this.stylesList[tt].d || "M0 0"
              ));
        }),
        (SVGShapeElement.prototype.renderShape = function () {
          var tt,
            et = this.animatedContents.length,
            nt;
          for (tt = 0; tt < et; tt += 1)
            (nt = this.animatedContents[tt]),
              (this._isFirstFrame || nt.element._isAnimated) &&
                nt.data !== !0 &&
                nt.fn(nt.data, nt.element, this._isFirstFrame);
        }),
        (SVGShapeElement.prototype.destroy = function () {
          this.destroyBaseElement(),
            (this.shapesData = null),
            (this.itemsData = null);
        });
      function LetterProps(tt, et, nt, rt, it, st) {
        (this.o = tt),
          (this.sw = et),
          (this.sc = nt),
          (this.fc = rt),
          (this.m = it),
          (this.p = st),
          (this._mdf = { o: !0, sw: !!et, sc: !!nt, fc: !!rt, m: !0, p: !0 });
      }
      LetterProps.prototype.update = function (tt, et, nt, rt, it, st) {
        (this._mdf.o = !1),
          (this._mdf.sw = !1),
          (this._mdf.sc = !1),
          (this._mdf.fc = !1),
          (this._mdf.m = !1),
          (this._mdf.p = !1);
        var ot = !1;
        return (
          this.o !== tt && ((this.o = tt), (this._mdf.o = !0), (ot = !0)),
          this.sw !== et && ((this.sw = et), (this._mdf.sw = !0), (ot = !0)),
          this.sc !== nt && ((this.sc = nt), (this._mdf.sc = !0), (ot = !0)),
          this.fc !== rt && ((this.fc = rt), (this._mdf.fc = !0), (ot = !0)),
          this.m !== it && ((this.m = it), (this._mdf.m = !0), (ot = !0)),
          st.length &&
            (this.p[0] !== st[0] ||
              this.p[1] !== st[1] ||
              this.p[4] !== st[4] ||
              this.p[5] !== st[5] ||
              this.p[12] !== st[12] ||
              this.p[13] !== st[13]) &&
            ((this.p = st), (this._mdf.p = !0), (ot = !0)),
          ot
        );
      };
      function TextProperty(tt, et) {
        (this._frameId = initialDefaultFrame),
          (this.pv = ""),
          (this.v = ""),
          (this.kf = !1),
          (this._isFirstFrame = !0),
          (this._mdf = !1),
          et.d && et.d.sid && (et.d = tt.globalData.slotManager.getProp(et.d)),
          (this.data = et),
          (this.elem = tt),
          (this.comp = this.elem.comp),
          (this.keysIndex = 0),
          (this.canResize = !1),
          (this.minimumFontSize = 1),
          (this.effectsSequence = []),
          (this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: !1,
            strokeColorAnim: !1,
            strokeWidthAnim: !1,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: !1,
          }),
          this.copyData(this.currentData, this.data.d.k[0].s),
          this.searchProperty() || this.completeTextData(this.currentData);
      }
      (TextProperty.prototype.defaultBoxWidth = [0, 0]),
        (TextProperty.prototype.copyData = function (tt, et) {
          for (var nt in et)
            Object.prototype.hasOwnProperty.call(et, nt) && (tt[nt] = et[nt]);
          return tt;
        }),
        (TextProperty.prototype.setCurrentData = function (tt) {
          tt.__complete || this.completeTextData(tt),
            (this.currentData = tt),
            (this.currentData.boxWidth =
              this.currentData.boxWidth || this.defaultBoxWidth),
            (this._mdf = !0);
        }),
        (TextProperty.prototype.searchProperty = function () {
          return this.searchKeyframes();
        }),
        (TextProperty.prototype.searchKeyframes = function () {
          return (
            (this.kf = this.data.d.k.length > 1),
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
          );
        }),
        (TextProperty.prototype.addEffect = function (tt) {
          this.effectsSequence.push(tt), this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.getValue = function (tt) {
          if (
            !(
              (this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length) &&
              !tt
            )
          ) {
            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
            var et = this.currentData,
              nt = this.keysIndex;
            if (this.lock) {
              this.setCurrentData(this.currentData);
              return;
            }
            (this.lock = !0), (this._mdf = !1);
            var rt,
              it = this.effectsSequence.length,
              st = tt || this.data.d.k[this.keysIndex].s;
            for (rt = 0; rt < it; rt += 1)
              nt !== this.keysIndex
                ? (st = this.effectsSequence[rt](st, st.t))
                : (st = this.effectsSequence[rt](this.currentData, st.t));
            et !== st && this.setCurrentData(st),
              (this.v = this.currentData),
              (this.pv = this.v),
              (this.lock = !1),
              (this.frameId = this.elem.globalData.frameId);
          }
        }),
        (TextProperty.prototype.getKeyframeValue = function () {
          for (
            var tt = this.data.d.k,
              et = this.elem.comp.renderedFrame,
              nt = 0,
              rt = tt.length;
            nt <= rt - 1 && !(nt === rt - 1 || tt[nt + 1].t > et);

          )
            nt += 1;
          return (
            this.keysIndex !== nt && (this.keysIndex = nt),
            this.data.d.k[this.keysIndex].s
          );
        }),
        (TextProperty.prototype.buildFinalText = function (tt) {
          for (
            var et = [],
              nt = 0,
              rt = tt.length,
              it,
              st,
              ot = !1,
              at = !1,
              lt = "";
            nt < rt;

          )
            (ot = at),
              (at = !1),
              (it = tt.charCodeAt(nt)),
              (lt = tt.charAt(nt)),
              FontManager.isCombinedCharacter(it)
                ? (ot = !0)
                : it >= 55296 && it <= 56319
                ? FontManager.isRegionalFlag(tt, nt)
                  ? (lt = tt.substr(nt, 14))
                  : ((st = tt.charCodeAt(nt + 1)),
                    st >= 56320 &&
                      st <= 57343 &&
                      (FontManager.isModifier(it, st)
                        ? ((lt = tt.substr(nt, 2)), (ot = !0))
                        : FontManager.isFlagEmoji(tt.substr(nt, 4))
                        ? (lt = tt.substr(nt, 4))
                        : (lt = tt.substr(nt, 2))))
                : it > 56319
                ? ((st = tt.charCodeAt(nt + 1)),
                  FontManager.isVariationSelector(it) && (ot = !0))
                : FontManager.isZeroWidthJoiner(it) && ((ot = !0), (at = !0)),
              ot ? ((et[et.length - 1] += lt), (ot = !1)) : et.push(lt),
              (nt += lt.length);
          return et;
        }),
        (TextProperty.prototype.completeTextData = function (tt) {
          tt.__complete = !0;
          var et = this.elem.globalData.fontManager,
            nt = this.data,
            rt = [],
            it,
            st,
            ot,
            at = 0,
            lt,
            ct = nt.m.g,
            ut = 0,
            ft = 0,
            ht = 0,
            mt = [],
            vt = 0,
            yt = 0,
            Et,
            pt,
            xt = et.getFontByName(tt.f),
            St,
            At = 0,
            Ct = getFontProperties(xt);
          (tt.fWeight = Ct.weight),
            (tt.fStyle = Ct.style),
            (tt.finalSize = tt.s),
            (tt.finalText = this.buildFinalText(tt.t)),
            (st = tt.finalText.length),
            (tt.finalLineHeight = tt.lh);
          var Mt = (tt.tr / 1e3) * tt.finalSize,
            wt;
          if (tt.sz)
            for (var Bt = !0, It = tt.sz[0], Ft = tt.sz[1], Vt, $t; Bt; ) {
              ($t = this.buildFinalText(tt.t)),
                (Vt = 0),
                (vt = 0),
                (st = $t.length),
                (Mt = (tt.tr / 1e3) * tt.finalSize);
              var Kt = -1;
              for (it = 0; it < st; it += 1)
                (wt = $t[it].charCodeAt(0)),
                  (ot = !1),
                  $t[it] === " "
                    ? (Kt = it)
                    : (wt === 13 || wt === 3) &&
                      ((vt = 0),
                      (ot = !0),
                      (Vt += tt.finalLineHeight || tt.finalSize * 1.2)),
                  et.chars
                    ? ((St = et.getCharData($t[it], xt.fStyle, xt.fFamily)),
                      (At = ot ? 0 : (St.w * tt.finalSize) / 100))
                    : (At = et.measureText($t[it], tt.f, tt.finalSize)),
                  vt + At > It && $t[it] !== " "
                    ? (Kt === -1 ? (st += 1) : (it = Kt),
                      (Vt += tt.finalLineHeight || tt.finalSize * 1.2),
                      $t.splice(it, Kt === it ? 1 : 0, "\r"),
                      (Kt = -1),
                      (vt = 0))
                    : ((vt += At), (vt += Mt));
              (Vt += (xt.ascent * tt.finalSize) / 100),
                this.canResize && tt.finalSize > this.minimumFontSize && Ft < Vt
                  ? ((tt.finalSize -= 1),
                    (tt.finalLineHeight = (tt.finalSize * tt.lh) / tt.s))
                  : ((tt.finalText = $t),
                    (st = tt.finalText.length),
                    (Bt = !1));
            }
          (vt = -Mt), (At = 0);
          var Ht = 0,
            Wt;
          for (it = 0; it < st; it += 1)
            if (
              ((ot = !1),
              (Wt = tt.finalText[it]),
              (wt = Wt.charCodeAt(0)),
              wt === 13 || wt === 3
                ? ((Ht = 0),
                  mt.push(vt),
                  (yt = vt > yt ? vt : yt),
                  (vt = -2 * Mt),
                  (lt = ""),
                  (ot = !0),
                  (ht += 1))
                : (lt = Wt),
              et.chars
                ? ((St = et.getCharData(
                    Wt,
                    xt.fStyle,
                    et.getFontByName(tt.f).fFamily
                  )),
                  (At = ot ? 0 : (St.w * tt.finalSize) / 100))
                : (At = et.measureText(lt, tt.f, tt.finalSize)),
              Wt === " " ? (Ht += At + Mt) : ((vt += At + Mt + Ht), (Ht = 0)),
              rt.push({
                l: At,
                an: At,
                add: ut,
                n: ot,
                anIndexes: [],
                val: lt,
                line: ht,
                animatorJustifyOffset: 0,
              }),
              ct == 2)
            ) {
              if (((ut += At), lt === "" || lt === " " || it === st - 1)) {
                for ((lt === "" || lt === " ") && (ut -= At); ft <= it; )
                  (rt[ft].an = ut),
                    (rt[ft].ind = at),
                    (rt[ft].extra = At),
                    (ft += 1);
                (at += 1), (ut = 0);
              }
            } else if (ct == 3) {
              if (((ut += At), lt === "" || it === st - 1)) {
                for (lt === "" && (ut -= At); ft <= it; )
                  (rt[ft].an = ut),
                    (rt[ft].ind = at),
                    (rt[ft].extra = At),
                    (ft += 1);
                (ut = 0), (at += 1);
              }
            } else (rt[at].ind = at), (rt[at].extra = 0), (at += 1);
          if (((tt.l = rt), (yt = vt > yt ? vt : yt), mt.push(vt), tt.sz))
            (tt.boxWidth = tt.sz[0]), (tt.justifyOffset = 0);
          else
            switch (((tt.boxWidth = yt), tt.j)) {
              case 1:
                tt.justifyOffset = -tt.boxWidth;
                break;
              case 2:
                tt.justifyOffset = -tt.boxWidth / 2;
                break;
              default:
                tt.justifyOffset = 0;
            }
          tt.lineWidths = mt;
          var kt = nt.a,
            Gt,
            Pt;
          pt = kt.length;
          var Rt,
            Nt,
            Dt = [];
          for (Et = 0; Et < pt; Et += 1) {
            for (
              Gt = kt[Et],
                Gt.a.sc && (tt.strokeColorAnim = !0),
                Gt.a.sw && (tt.strokeWidthAnim = !0),
                (Gt.a.fc || Gt.a.fh || Gt.a.fs || Gt.a.fb) &&
                  (tt.fillColorAnim = !0),
                Nt = 0,
                Rt = Gt.s.b,
                it = 0;
              it < st;
              it += 1
            )
              (Pt = rt[it]),
                (Pt.anIndexes[Et] = Nt),
                ((Rt == 1 && Pt.val !== "") ||
                  (Rt == 2 && Pt.val !== "" && Pt.val !== " ") ||
                  (Rt == 3 && (Pt.n || Pt.val == " " || it == st - 1)) ||
                  (Rt == 4 && (Pt.n || it == st - 1))) &&
                  (Gt.s.rn === 1 && Dt.push(Nt), (Nt += 1));
            nt.a[Et].s.totalChars = Nt;
            var zt = -1,
              Yt;
            if (Gt.s.rn === 1)
              for (it = 0; it < st; it += 1)
                (Pt = rt[it]),
                  zt != Pt.anIndexes[Et] &&
                    ((zt = Pt.anIndexes[Et]),
                    (Yt = Dt.splice(
                      Math.floor(Math.random() * Dt.length),
                      1
                    )[0])),
                  (Pt.anIndexes[Et] = Yt);
          }
          (tt.yOffset = tt.finalLineHeight || tt.finalSize * 1.2),
            (tt.ls = tt.ls || 0),
            (tt.ascent = (xt.ascent * tt.finalSize) / 100);
        }),
        (TextProperty.prototype.updateDocumentData = function (tt, et) {
          et = et === void 0 ? this.keysIndex : et;
          var nt = this.copyData({}, this.data.d.k[et].s);
          (nt = this.copyData(nt, tt)),
            (this.data.d.k[et].s = nt),
            this.recalculate(et),
            this.setCurrentData(nt),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.recalculate = function (tt) {
          var et = this.data.d.k[tt].s;
          (et.__complete = !1),
            (this.keysIndex = 0),
            (this._isFirstFrame = !0),
            this.getValue(et);
        }),
        (TextProperty.prototype.canResizeFont = function (tt) {
          (this.canResize = tt),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.setMinimumFontSize = function (tt) {
          (this.minimumFontSize = Math.floor(tt) || 1),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        });
      var TextSelectorProp = (function () {
        var tt = Math.max,
          et = Math.min,
          nt = Math.floor;
        function rt(st, ot) {
          (this._currentTextLength = -1),
            (this.k = !1),
            (this.data = ot),
            (this.elem = st),
            (this.comp = st.comp),
            (this.finalS = 0),
            (this.finalE = 0),
            this.initDynamicPropertyContainer(st),
            (this.s = PropertyFactory.getProp(
              st,
              ot.s || { k: 0 },
              0,
              0,
              this
            )),
            "e" in ot
              ? (this.e = PropertyFactory.getProp(st, ot.e, 0, 0, this))
              : (this.e = { v: 100 }),
            (this.o = PropertyFactory.getProp(
              st,
              ot.o || { k: 0 },
              0,
              0,
              this
            )),
            (this.xe = PropertyFactory.getProp(
              st,
              ot.xe || { k: 0 },
              0,
              0,
              this
            )),
            (this.ne = PropertyFactory.getProp(
              st,
              ot.ne || { k: 0 },
              0,
              0,
              this
            )),
            (this.sm = PropertyFactory.getProp(
              st,
              ot.sm || { k: 100 },
              0,
              0,
              this
            )),
            (this.a = PropertyFactory.getProp(st, ot.a, 0, 0.01, this)),
            this.dynamicProperties.length || this.getValue();
        }
        (rt.prototype = {
          getMult: function (ot) {
            this._currentTextLength !==
              this.elem.textProperty.currentData.l.length && this.getValue();
            var at = 0,
              lt = 0,
              ct = 1,
              ut = 1;
            this.ne.v > 0 ? (at = this.ne.v / 100) : (lt = -this.ne.v / 100),
              this.xe.v > 0
                ? (ct = 1 - this.xe.v / 100)
                : (ut = 1 + this.xe.v / 100);
            var ft = BezierFactory.getBezierEasing(at, lt, ct, ut).get,
              ht = 0,
              mt = this.finalS,
              vt = this.finalE,
              yt = this.data.sh;
            if (yt === 2)
              vt === mt
                ? (ht = ot >= vt ? 1 : 0)
                : (ht = tt(0, et(0.5 / (vt - mt) + (ot - mt) / (vt - mt), 1))),
                (ht = ft(ht));
            else if (yt === 3)
              vt === mt
                ? (ht = ot >= vt ? 0 : 1)
                : (ht =
                    1 - tt(0, et(0.5 / (vt - mt) + (ot - mt) / (vt - mt), 1))),
                (ht = ft(ht));
            else if (yt === 4)
              vt === mt
                ? (ht = 0)
                : ((ht = tt(0, et(0.5 / (vt - mt) + (ot - mt) / (vt - mt), 1))),
                  ht < 0.5 ? (ht *= 2) : (ht = 1 - 2 * (ht - 0.5))),
                (ht = ft(ht));
            else if (yt === 5) {
              if (vt === mt) ht = 0;
              else {
                var Et = vt - mt;
                ot = et(tt(0, ot + 0.5 - mt), vt - mt);
                var pt = -Et / 2 + ot,
                  xt = Et / 2;
                ht = Math.sqrt(1 - (pt * pt) / (xt * xt));
              }
              ht = ft(ht);
            } else
              yt === 6
                ? (vt === mt
                    ? (ht = 0)
                    : ((ot = et(tt(0, ot + 0.5 - mt), vt - mt)),
                      (ht =
                        (1 +
                          Math.cos(Math.PI + (Math.PI * 2 * ot) / (vt - mt))) /
                        2)),
                  (ht = ft(ht)))
                : (ot >= nt(mt) &&
                    (ot - mt < 0
                      ? (ht = tt(0, et(et(vt, 1) - (mt - ot), 1)))
                      : (ht = tt(0, et(vt - ot, 1)))),
                  (ht = ft(ht)));
            if (this.sm.v !== 100) {
              var St = this.sm.v * 0.01;
              St === 0 && (St = 1e-8);
              var At = 0.5 - St * 0.5;
              ht < At ? (ht = 0) : ((ht = (ht - At) / St), ht > 1 && (ht = 1));
            }
            return ht * this.a.v;
          },
          getValue: function (ot) {
            this.iterateDynamicProperties(),
              (this._mdf = ot || this._mdf),
              (this._currentTextLength =
                this.elem.textProperty.currentData.l.length || 0),
              ot && this.data.r === 2 && (this.e.v = this._currentTextLength);
            var at = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
              lt = this.o.v / at,
              ct = this.s.v / at + lt,
              ut = this.e.v / at + lt;
            if (ct > ut) {
              var ft = ct;
              (ct = ut), (ut = ft);
            }
            (this.finalS = ct), (this.finalE = ut);
          },
        }),
          extendPrototype([DynamicPropertyContainer], rt);
        function it(st, ot, at) {
          return new rt(st, ot);
        }
        return { getTextSelectorProp: it };
      })();
      function TextAnimatorDataProperty(tt, et, nt) {
        var rt = { propType: !1 },
          it = PropertyFactory.getProp,
          st = et.a;
        (this.a = {
          r: st.r ? it(tt, st.r, 0, degToRads, nt) : rt,
          rx: st.rx ? it(tt, st.rx, 0, degToRads, nt) : rt,
          ry: st.ry ? it(tt, st.ry, 0, degToRads, nt) : rt,
          sk: st.sk ? it(tt, st.sk, 0, degToRads, nt) : rt,
          sa: st.sa ? it(tt, st.sa, 0, degToRads, nt) : rt,
          s: st.s ? it(tt, st.s, 1, 0.01, nt) : rt,
          a: st.a ? it(tt, st.a, 1, 0, nt) : rt,
          o: st.o ? it(tt, st.o, 0, 0.01, nt) : rt,
          p: st.p ? it(tt, st.p, 1, 0, nt) : rt,
          sw: st.sw ? it(tt, st.sw, 0, 0, nt) : rt,
          sc: st.sc ? it(tt, st.sc, 1, 0, nt) : rt,
          fc: st.fc ? it(tt, st.fc, 1, 0, nt) : rt,
          fh: st.fh ? it(tt, st.fh, 0, 0, nt) : rt,
          fs: st.fs ? it(tt, st.fs, 0, 0.01, nt) : rt,
          fb: st.fb ? it(tt, st.fb, 0, 0.01, nt) : rt,
          t: st.t ? it(tt, st.t, 0, 0, nt) : rt,
        }),
          (this.s = TextSelectorProp.getTextSelectorProp(tt, et.s, nt)),
          (this.s.t = et.s.t);
      }
      function TextAnimatorProperty(tt, et, nt) {
        (this._isFirstFrame = !0),
          (this._hasMaskedPath = !1),
          (this._frameId = -1),
          (this._textData = tt),
          (this._renderType = et),
          (this._elem = nt),
          (this._animatorsData = createSizedArray(this._textData.a.length)),
          (this._pathData = {}),
          (this._moreOptions = { alignment: {} }),
          (this.renderedLetters = []),
          (this.lettersChangedFlag = !1),
          this.initDynamicPropertyContainer(nt);
      }
      (TextAnimatorProperty.prototype.searchProperties = function () {
        var tt,
          et = this._textData.a.length,
          nt,
          rt = PropertyFactory.getProp;
        for (tt = 0; tt < et; tt += 1)
          (nt = this._textData.a[tt]),
            (this._animatorsData[tt] = new TextAnimatorDataProperty(
              this._elem,
              nt,
              this
            ));
        this._textData.p && "m" in this._textData.p
          ? ((this._pathData = {
              a: rt(this._elem, this._textData.p.a, 0, 0, this),
              f: rt(this._elem, this._textData.p.f, 0, 0, this),
              l: rt(this._elem, this._textData.p.l, 0, 0, this),
              r: rt(this._elem, this._textData.p.r, 0, 0, this),
              p: rt(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
            }),
            (this._hasMaskedPath = !0))
          : (this._hasMaskedPath = !1),
          (this._moreOptions.alignment = rt(
            this._elem,
            this._textData.m.a,
            1,
            0,
            this
          ));
      }),
        (TextAnimatorProperty.prototype.getMeasures = function (tt, et) {
          if (
            ((this.lettersChangedFlag = et),
            !(
              !this._mdf &&
              !this._isFirstFrame &&
              !et &&
              (!this._hasMaskedPath || !this._pathData.m._mdf)
            ))
          ) {
            this._isFirstFrame = !1;
            var nt = this._moreOptions.alignment.v,
              rt = this._animatorsData,
              it = this._textData,
              st = this.mHelper,
              ot = this._renderType,
              at = this.renderedLetters.length,
              lt,
              ct,
              ut,
              ft,
              ht = tt.l,
              mt,
              vt,
              yt,
              Et,
              pt,
              xt,
              St,
              At,
              Ct,
              Mt,
              wt,
              Bt,
              It,
              Ft,
              Vt;
            if (this._hasMaskedPath) {
              if (
                ((Vt = this._pathData.m),
                !this._pathData.n || this._pathData._mdf)
              ) {
                var $t = Vt.v;
                this._pathData.r.v && ($t = $t.reverse()),
                  (mt = { tLength: 0, segments: [] }),
                  (ft = $t._length - 1);
                var Kt;
                for (Bt = 0, ut = 0; ut < ft; ut += 1)
                  (Kt = bez.buildBezierData(
                    $t.v[ut],
                    $t.v[ut + 1],
                    [$t.o[ut][0] - $t.v[ut][0], $t.o[ut][1] - $t.v[ut][1]],
                    [
                      $t.i[ut + 1][0] - $t.v[ut + 1][0],
                      $t.i[ut + 1][1] - $t.v[ut + 1][1],
                    ]
                  )),
                    (mt.tLength += Kt.segmentLength),
                    mt.segments.push(Kt),
                    (Bt += Kt.segmentLength);
                (ut = ft),
                  Vt.v.c &&
                    ((Kt = bez.buildBezierData(
                      $t.v[ut],
                      $t.v[0],
                      [$t.o[ut][0] - $t.v[ut][0], $t.o[ut][1] - $t.v[ut][1]],
                      [$t.i[0][0] - $t.v[0][0], $t.i[0][1] - $t.v[0][1]]
                    )),
                    (mt.tLength += Kt.segmentLength),
                    mt.segments.push(Kt),
                    (Bt += Kt.segmentLength)),
                  (this._pathData.pi = mt);
              }
              if (
                ((mt = this._pathData.pi),
                (vt = this._pathData.f.v),
                (St = 0),
                (xt = 1),
                (Et = 0),
                (pt = !0),
                (Mt = mt.segments),
                vt < 0 && Vt.v.c)
              )
                for (
                  mt.tLength < Math.abs(vt) &&
                    (vt = -Math.abs(vt) % mt.tLength),
                    St = Mt.length - 1,
                    Ct = Mt[St].points,
                    xt = Ct.length - 1;
                  vt < 0;

                )
                  (vt += Ct[xt].partialLength),
                    (xt -= 1),
                    xt < 0 &&
                      ((St -= 1), (Ct = Mt[St].points), (xt = Ct.length - 1));
              (Ct = Mt[St].points),
                (At = Ct[xt - 1]),
                (yt = Ct[xt]),
                (wt = yt.partialLength);
            }
            (ft = ht.length), (lt = 0), (ct = 0);
            var Ht = tt.finalSize * 1.2 * 0.714,
              Wt = !0,
              kt,
              Gt,
              Pt,
              Rt,
              Nt;
            Rt = rt.length;
            var Dt,
              zt = -1,
              Yt,
              qt,
              Zt,
              Jt = vt,
              mn = St,
              ln = xt,
              bn = -1,
              Bn,
              gn,
              jt,
              yn,
              pn,
              vn,
              xn,
              Fn,
              _n = "",
              Dn = this.defaultPropsArray,
              Tn;
            if (tt.j === 2 || tt.j === 1) {
              var An = 0,
                Wn = 0,
                Xt = tt.j === 2 ? -0.5 : -1,
                Ut = 0,
                hn = !0;
              for (ut = 0; ut < ft; ut += 1)
                if (ht[ut].n) {
                  for (An && (An += Wn); Ut < ut; )
                    (ht[Ut].animatorJustifyOffset = An), (Ut += 1);
                  (An = 0), (hn = !0);
                } else {
                  for (Pt = 0; Pt < Rt; Pt += 1)
                    (kt = rt[Pt].a),
                      kt.t.propType &&
                        (hn && tt.j === 2 && (Wn += kt.t.v * Xt),
                        (Gt = rt[Pt].s),
                        (Dt = Gt.getMult(
                          ht[ut].anIndexes[Pt],
                          it.a[Pt].s.totalChars
                        )),
                        Dt.length
                          ? (An += kt.t.v * Dt[0] * Xt)
                          : (An += kt.t.v * Dt * Xt));
                  hn = !1;
                }
              for (An && (An += Wn); Ut < ut; )
                (ht[Ut].animatorJustifyOffset = An), (Ut += 1);
            }
            for (ut = 0; ut < ft; ut += 1) {
              if ((st.reset(), (Bn = 1), ht[ut].n))
                (lt = 0),
                  (ct += tt.yOffset),
                  (ct += Wt ? 1 : 0),
                  (vt = Jt),
                  (Wt = !1),
                  this._hasMaskedPath &&
                    ((St = mn),
                    (xt = ln),
                    (Ct = Mt[St].points),
                    (At = Ct[xt - 1]),
                    (yt = Ct[xt]),
                    (wt = yt.partialLength),
                    (Et = 0)),
                  (_n = ""),
                  (Fn = ""),
                  (vn = ""),
                  (Tn = ""),
                  (Dn = this.defaultPropsArray);
              else {
                if (this._hasMaskedPath) {
                  if (bn !== ht[ut].line) {
                    switch (tt.j) {
                      case 1:
                        vt += Bt - tt.lineWidths[ht[ut].line];
                        break;
                      case 2:
                        vt += (Bt - tt.lineWidths[ht[ut].line]) / 2;
                        break;
                    }
                    bn = ht[ut].line;
                  }
                  zt !== ht[ut].ind &&
                    (ht[zt] && (vt += ht[zt].extra),
                    (vt += ht[ut].an / 2),
                    (zt = ht[ut].ind)),
                    (vt += nt[0] * ht[ut].an * 0.005);
                  var Ln = 0;
                  for (Pt = 0; Pt < Rt; Pt += 1)
                    (kt = rt[Pt].a),
                      kt.p.propType &&
                        ((Gt = rt[Pt].s),
                        (Dt = Gt.getMult(
                          ht[ut].anIndexes[Pt],
                          it.a[Pt].s.totalChars
                        )),
                        Dt.length
                          ? (Ln += kt.p.v[0] * Dt[0])
                          : (Ln += kt.p.v[0] * Dt)),
                      kt.a.propType &&
                        ((Gt = rt[Pt].s),
                        (Dt = Gt.getMult(
                          ht[ut].anIndexes[Pt],
                          it.a[Pt].s.totalChars
                        )),
                        Dt.length
                          ? (Ln += kt.a.v[0] * Dt[0])
                          : (Ln += kt.a.v[0] * Dt));
                  for (
                    pt = !0,
                      this._pathData.a.v &&
                        ((vt =
                          ht[0].an * 0.5 +
                          ((Bt -
                            this._pathData.f.v -
                            ht[0].an * 0.5 -
                            ht[ht.length - 1].an * 0.5) *
                            zt) /
                            (ft - 1)),
                        (vt += this._pathData.f.v));
                    pt;

                  )
                    Et + wt >= vt + Ln || !Ct
                      ? ((It = (vt + Ln - Et) / yt.partialLength),
                        (qt = At.point[0] + (yt.point[0] - At.point[0]) * It),
                        (Zt = At.point[1] + (yt.point[1] - At.point[1]) * It),
                        st.translate(
                          -nt[0] * ht[ut].an * 0.005,
                          -(nt[1] * Ht) * 0.01
                        ),
                        (pt = !1))
                      : Ct &&
                        ((Et += yt.partialLength),
                        (xt += 1),
                        xt >= Ct.length &&
                          ((xt = 0),
                          (St += 1),
                          Mt[St]
                            ? (Ct = Mt[St].points)
                            : Vt.v.c
                            ? ((xt = 0), (St = 0), (Ct = Mt[St].points))
                            : ((Et -= yt.partialLength), (Ct = null))),
                        Ct &&
                          ((At = yt), (yt = Ct[xt]), (wt = yt.partialLength)));
                  (Yt = ht[ut].an / 2 - ht[ut].add), st.translate(-Yt, 0, 0);
                } else
                  (Yt = ht[ut].an / 2 - ht[ut].add),
                    st.translate(-Yt, 0, 0),
                    st.translate(
                      -nt[0] * ht[ut].an * 0.005,
                      -nt[1] * Ht * 0.01,
                      0
                    );
                for (Pt = 0; Pt < Rt; Pt += 1)
                  (kt = rt[Pt].a),
                    kt.t.propType &&
                      ((Gt = rt[Pt].s),
                      (Dt = Gt.getMult(
                        ht[ut].anIndexes[Pt],
                        it.a[Pt].s.totalChars
                      )),
                      (lt !== 0 || tt.j !== 0) &&
                        (this._hasMaskedPath
                          ? Dt.length
                            ? (vt += kt.t.v * Dt[0])
                            : (vt += kt.t.v * Dt)
                          : Dt.length
                          ? (lt += kt.t.v * Dt[0])
                          : (lt += kt.t.v * Dt)));
                for (
                  tt.strokeWidthAnim && (jt = tt.sw || 0),
                    tt.strokeColorAnim &&
                      (tt.sc
                        ? (gn = [tt.sc[0], tt.sc[1], tt.sc[2]])
                        : (gn = [0, 0, 0])),
                    tt.fillColorAnim &&
                      tt.fc &&
                      (yn = [tt.fc[0], tt.fc[1], tt.fc[2]]),
                    Pt = 0;
                  Pt < Rt;
                  Pt += 1
                )
                  (kt = rt[Pt].a),
                    kt.a.propType &&
                      ((Gt = rt[Pt].s),
                      (Dt = Gt.getMult(
                        ht[ut].anIndexes[Pt],
                        it.a[Pt].s.totalChars
                      )),
                      Dt.length
                        ? st.translate(
                            -kt.a.v[0] * Dt[0],
                            -kt.a.v[1] * Dt[1],
                            kt.a.v[2] * Dt[2]
                          )
                        : st.translate(
                            -kt.a.v[0] * Dt,
                            -kt.a.v[1] * Dt,
                            kt.a.v[2] * Dt
                          ));
                for (Pt = 0; Pt < Rt; Pt += 1)
                  (kt = rt[Pt].a),
                    kt.s.propType &&
                      ((Gt = rt[Pt].s),
                      (Dt = Gt.getMult(
                        ht[ut].anIndexes[Pt],
                        it.a[Pt].s.totalChars
                      )),
                      Dt.length
                        ? st.scale(
                            1 + (kt.s.v[0] - 1) * Dt[0],
                            1 + (kt.s.v[1] - 1) * Dt[1],
                            1
                          )
                        : st.scale(
                            1 + (kt.s.v[0] - 1) * Dt,
                            1 + (kt.s.v[1] - 1) * Dt,
                            1
                          ));
                for (Pt = 0; Pt < Rt; Pt += 1) {
                  if (
                    ((kt = rt[Pt].a),
                    (Gt = rt[Pt].s),
                    (Dt = Gt.getMult(
                      ht[ut].anIndexes[Pt],
                      it.a[Pt].s.totalChars
                    )),
                    kt.sk.propType &&
                      (Dt.length
                        ? st.skewFromAxis(-kt.sk.v * Dt[0], kt.sa.v * Dt[1])
                        : st.skewFromAxis(-kt.sk.v * Dt, kt.sa.v * Dt)),
                    kt.r.propType &&
                      (Dt.length
                        ? st.rotateZ(-kt.r.v * Dt[2])
                        : st.rotateZ(-kt.r.v * Dt)),
                    kt.ry.propType &&
                      (Dt.length
                        ? st.rotateY(kt.ry.v * Dt[1])
                        : st.rotateY(kt.ry.v * Dt)),
                    kt.rx.propType &&
                      (Dt.length
                        ? st.rotateX(kt.rx.v * Dt[0])
                        : st.rotateX(kt.rx.v * Dt)),
                    kt.o.propType &&
                      (Dt.length
                        ? (Bn += (kt.o.v * Dt[0] - Bn) * Dt[0])
                        : (Bn += (kt.o.v * Dt - Bn) * Dt)),
                    tt.strokeWidthAnim &&
                      kt.sw.propType &&
                      (Dt.length
                        ? (jt += kt.sw.v * Dt[0])
                        : (jt += kt.sw.v * Dt)),
                    tt.strokeColorAnim && kt.sc.propType)
                  )
                    for (pn = 0; pn < 3; pn += 1)
                      Dt.length
                        ? (gn[pn] += (kt.sc.v[pn] - gn[pn]) * Dt[0])
                        : (gn[pn] += (kt.sc.v[pn] - gn[pn]) * Dt);
                  if (tt.fillColorAnim && tt.fc) {
                    if (kt.fc.propType)
                      for (pn = 0; pn < 3; pn += 1)
                        Dt.length
                          ? (yn[pn] += (kt.fc.v[pn] - yn[pn]) * Dt[0])
                          : (yn[pn] += (kt.fc.v[pn] - yn[pn]) * Dt);
                    kt.fh.propType &&
                      (Dt.length
                        ? (yn = addHueToRGB(yn, kt.fh.v * Dt[0]))
                        : (yn = addHueToRGB(yn, kt.fh.v * Dt))),
                      kt.fs.propType &&
                        (Dt.length
                          ? (yn = addSaturationToRGB(yn, kt.fs.v * Dt[0]))
                          : (yn = addSaturationToRGB(yn, kt.fs.v * Dt))),
                      kt.fb.propType &&
                        (Dt.length
                          ? (yn = addBrightnessToRGB(yn, kt.fb.v * Dt[0]))
                          : (yn = addBrightnessToRGB(yn, kt.fb.v * Dt)));
                  }
                }
                for (Pt = 0; Pt < Rt; Pt += 1)
                  (kt = rt[Pt].a),
                    kt.p.propType &&
                      ((Gt = rt[Pt].s),
                      (Dt = Gt.getMult(
                        ht[ut].anIndexes[Pt],
                        it.a[Pt].s.totalChars
                      )),
                      this._hasMaskedPath
                        ? Dt.length
                          ? st.translate(
                              0,
                              kt.p.v[1] * Dt[0],
                              -kt.p.v[2] * Dt[1]
                            )
                          : st.translate(0, kt.p.v[1] * Dt, -kt.p.v[2] * Dt)
                        : Dt.length
                        ? st.translate(
                            kt.p.v[0] * Dt[0],
                            kt.p.v[1] * Dt[1],
                            -kt.p.v[2] * Dt[2]
                          )
                        : st.translate(
                            kt.p.v[0] * Dt,
                            kt.p.v[1] * Dt,
                            -kt.p.v[2] * Dt
                          ));
                if (
                  (tt.strokeWidthAnim && (vn = jt < 0 ? 0 : jt),
                  tt.strokeColorAnim &&
                    (xn =
                      "rgb(" +
                      Math.round(gn[0] * 255) +
                      "," +
                      Math.round(gn[1] * 255) +
                      "," +
                      Math.round(gn[2] * 255) +
                      ")"),
                  tt.fillColorAnim &&
                    tt.fc &&
                    (Fn =
                      "rgb(" +
                      Math.round(yn[0] * 255) +
                      "," +
                      Math.round(yn[1] * 255) +
                      "," +
                      Math.round(yn[2] * 255) +
                      ")"),
                  this._hasMaskedPath)
                ) {
                  if (
                    (st.translate(0, -tt.ls),
                    st.translate(0, nt[1] * Ht * 0.01 + ct, 0),
                    this._pathData.p.v)
                  ) {
                    Ft =
                      (yt.point[1] - At.point[1]) / (yt.point[0] - At.point[0]);
                    var Cn = (Math.atan(Ft) * 180) / Math.PI;
                    yt.point[0] < At.point[0] && (Cn += 180),
                      st.rotate((-Cn * Math.PI) / 180);
                  }
                  st.translate(qt, Zt, 0),
                    (vt -= nt[0] * ht[ut].an * 0.005),
                    ht[ut + 1] &&
                      zt !== ht[ut + 1].ind &&
                      ((vt += ht[ut].an / 2),
                      (vt += tt.tr * 0.001 * tt.finalSize));
                } else {
                  switch (
                    (st.translate(lt, ct, 0),
                    tt.ps && st.translate(tt.ps[0], tt.ps[1] + tt.ascent, 0),
                    tt.j)
                  ) {
                    case 1:
                      st.translate(
                        ht[ut].animatorJustifyOffset +
                          tt.justifyOffset +
                          (tt.boxWidth - tt.lineWidths[ht[ut].line]),
                        0,
                        0
                      );
                      break;
                    case 2:
                      st.translate(
                        ht[ut].animatorJustifyOffset +
                          tt.justifyOffset +
                          (tt.boxWidth - tt.lineWidths[ht[ut].line]) / 2,
                        0,
                        0
                      );
                      break;
                  }
                  st.translate(0, -tt.ls),
                    st.translate(Yt, 0, 0),
                    st.translate(
                      nt[0] * ht[ut].an * 0.005,
                      nt[1] * Ht * 0.01,
                      0
                    ),
                    (lt += ht[ut].l + tt.tr * 0.001 * tt.finalSize);
                }
                ot === "html"
                  ? (_n = st.toCSS())
                  : ot === "svg"
                  ? (_n = st.to2dCSS())
                  : (Dn = [
                      st.props[0],
                      st.props[1],
                      st.props[2],
                      st.props[3],
                      st.props[4],
                      st.props[5],
                      st.props[6],
                      st.props[7],
                      st.props[8],
                      st.props[9],
                      st.props[10],
                      st.props[11],
                      st.props[12],
                      st.props[13],
                      st.props[14],
                      st.props[15],
                    ]),
                  (Tn = Bn);
              }
              at <= ut
                ? ((Nt = new LetterProps(Tn, vn, xn, Fn, _n, Dn)),
                  this.renderedLetters.push(Nt),
                  (at += 1),
                  (this.lettersChangedFlag = !0))
                : ((Nt = this.renderedLetters[ut]),
                  (this.lettersChangedFlag =
                    Nt.update(Tn, vn, xn, Fn, _n, Dn) ||
                    this.lettersChangedFlag));
            }
          }
        }),
        (TextAnimatorProperty.prototype.getValue = function () {
          this._elem.globalData.frameId !== this._frameId &&
            ((this._frameId = this._elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        (TextAnimatorProperty.prototype.mHelper = new Matrix()),
        (TextAnimatorProperty.prototype.defaultPropsArray = []),
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {}
      (ITextElement.prototype.initElement = function (tt, et, nt) {
        (this.lettersChangedFlag = !0),
          this.initFrame(),
          this.initBaseData(tt, et, nt),
          (this.textProperty = new TextProperty(
            this,
            tt.t,
            this.dynamicProperties
          )),
          (this.textAnimator = new TextAnimatorProperty(
            tt.t,
            this.renderType,
            this
          )),
          this.initTransform(tt, et, nt),
          this.initHierarchy(),
          this.initRenderable(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          this.createContent(),
          this.hide(),
          this.textAnimator.searchProperties(this.dynamicProperties);
      }),
        (ITextElement.prototype.prepareFrame = function (tt) {
          (this._mdf = !1),
            this.prepareRenderableFrame(tt),
            this.prepareProperties(tt, this.isInRange);
        }),
        (ITextElement.prototype.createPathShape = function (tt, et) {
          var nt,
            rt = et.length,
            it,
            st = "";
          for (nt = 0; nt < rt; nt += 1)
            et[nt].ty === "sh" &&
              ((it = et[nt].ks.k),
              (st += buildShapeString(it, it.i.length, !0, tt)));
          return st;
        }),
        (ITextElement.prototype.updateDocumentData = function (tt, et) {
          this.textProperty.updateDocumentData(tt, et);
        }),
        (ITextElement.prototype.canResizeFont = function (tt) {
          this.textProperty.canResizeFont(tt);
        }),
        (ITextElement.prototype.setMinimumFontSize = function (tt) {
          this.textProperty.setMinimumFontSize(tt);
        }),
        (ITextElement.prototype.applyTextPropertiesToMatrix = function (
          tt,
          et,
          nt,
          rt,
          it
        ) {
          switch (
            (tt.ps && et.translate(tt.ps[0], tt.ps[1] + tt.ascent, 0),
            et.translate(0, -tt.ls, 0),
            tt.j)
          ) {
            case 1:
              et.translate(
                tt.justifyOffset + (tt.boxWidth - tt.lineWidths[nt]),
                0,
                0
              );
              break;
            case 2:
              et.translate(
                tt.justifyOffset + (tt.boxWidth - tt.lineWidths[nt]) / 2,
                0,
                0
              );
              break;
          }
          et.translate(rt, it, 0);
        }),
        (ITextElement.prototype.buildColor = function (tt) {
          return (
            "rgb(" +
            Math.round(tt[0] * 255) +
            "," +
            Math.round(tt[1] * 255) +
            "," +
            Math.round(tt[2] * 255) +
            ")"
          );
        }),
        (ITextElement.prototype.emptyProp = new LetterProps()),
        (ITextElement.prototype.destroy = function () {}),
        (ITextElement.prototype.validateText = function () {
          (this.textProperty._mdf || this.textProperty._isFirstFrame) &&
            (this.buildNewText(),
            (this.textProperty._isFirstFrame = !1),
            (this.textProperty._mdf = !1));
        });
      var emptyShapeData = { shapes: [] };
      function SVGTextLottieElement(tt, et, nt) {
        (this.textSpans = []),
          (this.renderType = "svg"),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        SVGTextLottieElement
      ),
        (SVGTextLottieElement.prototype.createContent = function () {
          this.data.singleShape &&
            !this.globalData.fontManager.chars &&
            (this.textContainer = createNS("text"));
        }),
        (SVGTextLottieElement.prototype.buildTextContents = function (tt) {
          for (var et = 0, nt = tt.length, rt = [], it = ""; et < nt; )
            tt[et] === String.fromCharCode(13) ||
            tt[et] === String.fromCharCode(3)
              ? (rt.push(it), (it = ""))
              : (it += tt[et]),
              (et += 1);
          return rt.push(it), rt;
        }),
        (SVGTextLottieElement.prototype.buildShapeData = function (tt, et) {
          if (tt.shapes && tt.shapes.length) {
            var nt = tt.shapes[0];
            if (nt.it) {
              var rt = nt.it[nt.it.length - 1];
              rt.s && ((rt.s.k[0] = et), (rt.s.k[1] = et));
            }
          }
          return tt;
        }),
        (SVGTextLottieElement.prototype.buildNewText = function () {
          this.addDynamicProperty(this);
          var tt,
            et,
            nt = this.textProperty.currentData;
          (this.renderedLetters = createSizedArray(nt ? nt.l.length : 0)),
            nt.fc
              ? this.layerElement.setAttribute("fill", this.buildColor(nt.fc))
              : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            nt.sc &&
              (this.layerElement.setAttribute("stroke", this.buildColor(nt.sc)),
              this.layerElement.setAttribute("stroke-width", nt.sw)),
            this.layerElement.setAttribute("font-size", nt.finalSize);
          var rt = this.globalData.fontManager.getFontByName(nt.f);
          if (rt.fClass) this.layerElement.setAttribute("class", rt.fClass);
          else {
            this.layerElement.setAttribute("font-family", rt.fFamily);
            var it = nt.fWeight,
              st = nt.fStyle;
            this.layerElement.setAttribute("font-style", st),
              this.layerElement.setAttribute("font-weight", it);
          }
          this.layerElement.setAttribute("aria-label", nt.t);
          var ot = nt.l || [],
            at = !!this.globalData.fontManager.chars;
          et = ot.length;
          var lt,
            ct = this.mHelper,
            ut = "",
            ft = this.data.singleShape,
            ht = 0,
            mt = 0,
            vt = !0,
            yt = nt.tr * 0.001 * nt.finalSize;
          if (ft && !at && !nt.sz) {
            var Et = this.textContainer,
              pt = "start";
            switch (nt.j) {
              case 1:
                pt = "end";
                break;
              case 2:
                pt = "middle";
                break;
              default:
                pt = "start";
                break;
            }
            Et.setAttribute("text-anchor", pt),
              Et.setAttribute("letter-spacing", yt);
            var xt = this.buildTextContents(nt.finalText);
            for (
              et = xt.length, mt = nt.ps ? nt.ps[1] + nt.ascent : 0, tt = 0;
              tt < et;
              tt += 1
            )
              (lt = this.textSpans[tt].span || createNS("tspan")),
                (lt.textContent = xt[tt]),
                lt.setAttribute("x", 0),
                lt.setAttribute("y", mt),
                (lt.style.display = "inherit"),
                Et.appendChild(lt),
                this.textSpans[tt] ||
                  (this.textSpans[tt] = { span: null, glyph: null }),
                (this.textSpans[tt].span = lt),
                (mt += nt.finalLineHeight);
            this.layerElement.appendChild(Et);
          } else {
            var St = this.textSpans.length,
              At;
            for (tt = 0; tt < et; tt += 1) {
              if (
                (this.textSpans[tt] ||
                  (this.textSpans[tt] = {
                    span: null,
                    childSpan: null,
                    glyph: null,
                  }),
                !at || !ft || tt === 0)
              ) {
                if (
                  ((lt =
                    St > tt
                      ? this.textSpans[tt].span
                      : createNS(at ? "g" : "text")),
                  St <= tt)
                ) {
                  if (
                    (lt.setAttribute("stroke-linecap", "butt"),
                    lt.setAttribute("stroke-linejoin", "round"),
                    lt.setAttribute("stroke-miterlimit", "4"),
                    (this.textSpans[tt].span = lt),
                    at)
                  ) {
                    var Ct = createNS("g");
                    lt.appendChild(Ct), (this.textSpans[tt].childSpan = Ct);
                  }
                  (this.textSpans[tt].span = lt),
                    this.layerElement.appendChild(lt);
                }
                lt.style.display = "inherit";
              }
              if (
                (ct.reset(),
                ft &&
                  (ot[tt].n &&
                    ((ht = -yt),
                    (mt += nt.yOffset),
                    (mt += vt ? 1 : 0),
                    (vt = !1)),
                  this.applyTextPropertiesToMatrix(nt, ct, ot[tt].line, ht, mt),
                  (ht += ot[tt].l || 0),
                  (ht += yt)),
                at)
              ) {
                At = this.globalData.fontManager.getCharData(
                  nt.finalText[tt],
                  rt.fStyle,
                  this.globalData.fontManager.getFontByName(nt.f).fFamily
                );
                var Mt;
                if (At.t === 1)
                  Mt = new SVGCompElement(At.data, this.globalData, this);
                else {
                  var wt = emptyShapeData;
                  At.data &&
                    At.data.shapes &&
                    (wt = this.buildShapeData(At.data, nt.finalSize)),
                    (Mt = new SVGShapeElement(wt, this.globalData, this));
                }
                if (this.textSpans[tt].glyph) {
                  var Bt = this.textSpans[tt].glyph;
                  this.textSpans[tt].childSpan.removeChild(Bt.layerElement),
                    Bt.destroy();
                }
                (this.textSpans[tt].glyph = Mt),
                  (Mt._debug = !0),
                  Mt.prepareFrame(0),
                  Mt.renderFrame(),
                  this.textSpans[tt].childSpan.appendChild(Mt.layerElement),
                  At.t === 1 &&
                    this.textSpans[tt].childSpan.setAttribute(
                      "transform",
                      "scale(" +
                        nt.finalSize / 100 +
                        "," +
                        nt.finalSize / 100 +
                        ")"
                    );
              } else
                ft &&
                  lt.setAttribute(
                    "transform",
                    "translate(" + ct.props[12] + "," + ct.props[13] + ")"
                  ),
                  (lt.textContent = ot[tt].val),
                  lt.setAttributeNS(
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    "preserve"
                  );
            }
            ft && lt && lt.setAttribute("d", ut);
          }
          for (; tt < this.textSpans.length; )
            (this.textSpans[tt].span.style.display = "none"), (tt += 1);
          this._sizeChanged = !0;
        }),
        (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
          if (
            (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged)
          ) {
            this._sizeChanged = !1;
            var tt = this.layerElement.getBBox();
            this.bbox = {
              top: tt.y,
              left: tt.x,
              width: tt.width,
              height: tt.height,
            };
          }
          return this.bbox;
        }),
        (SVGTextLottieElement.prototype.getValue = function () {
          var tt,
            et = this.textSpans.length,
            nt;
          for (
            this.renderedFrame = this.comp.renderedFrame, tt = 0;
            tt < et;
            tt += 1
          )
            (nt = this.textSpans[tt].glyph),
              nt &&
                (nt.prepareFrame(this.comp.renderedFrame - this.data.st),
                nt._mdf && (this._mdf = !0));
        }),
        (SVGTextLottieElement.prototype.renderInnerContent = function () {
          if (
            (this.validateText(),
            (!this.data.singleShape || this._mdf) &&
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag))
          ) {
            this._sizeChanged = !0;
            var tt,
              et,
              nt = this.textAnimator.renderedLetters,
              rt = this.textProperty.currentData.l;
            et = rt.length;
            var it, st, ot;
            for (tt = 0; tt < et; tt += 1)
              rt[tt].n ||
                ((it = nt[tt]),
                (st = this.textSpans[tt].span),
                (ot = this.textSpans[tt].glyph),
                ot && ot.renderFrame(),
                it._mdf.m && st.setAttribute("transform", it.m),
                it._mdf.o && st.setAttribute("opacity", it.o),
                it._mdf.sw && st.setAttribute("stroke-width", it.sw),
                it._mdf.sc && st.setAttribute("stroke", it.sc),
                it._mdf.fc && st.setAttribute("fill", it.fc));
          }
        });
      function ISolidElement(tt, et, nt) {
        this.initElement(tt, et, nt);
      }
      extendPrototype([IImageElement], ISolidElement),
        (ISolidElement.prototype.createContent = function () {
          var tt = createNS("rect");
          tt.setAttribute("width", this.data.sw),
            tt.setAttribute("height", this.data.sh),
            tt.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(tt);
        });
      function NullElement(tt, et, nt) {
        this.initFrame(),
          this.initBaseData(tt, et, nt),
          this.initFrame(),
          this.initTransform(tt, et, nt),
          this.initHierarchy();
      }
      (NullElement.prototype.prepareFrame = function (tt) {
        this.prepareProperties(tt, !0);
      }),
        (NullElement.prototype.renderFrame = function () {}),
        (NullElement.prototype.getBaseElement = function () {
          return null;
        }),
        (NullElement.prototype.destroy = function () {}),
        (NullElement.prototype.sourceRectAtTime = function () {}),
        (NullElement.prototype.hide = function () {}),
        extendPrototype(
          [BaseElement, TransformElement, HierarchyElement, FrameElement],
          NullElement
        );
      function SVGRendererBase() {}
      extendPrototype([BaseRenderer], SVGRendererBase),
        (SVGRendererBase.prototype.createNull = function (tt) {
          return new NullElement(tt, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createShape = function (tt) {
          return new SVGShapeElement(tt, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createText = function (tt) {
          return new SVGTextLottieElement(tt, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createImage = function (tt) {
          return new IImageElement(tt, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createSolid = function (tt) {
          return new ISolidElement(tt, this.globalData, this);
        }),
        (SVGRendererBase.prototype.configAnimation = function (tt) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute(
              "xmlns:xlink",
              "http://www.w3.org/1999/xlink"
            ),
            this.renderConfig.viewBoxSize
              ? this.svgElement.setAttribute(
                  "viewBox",
                  this.renderConfig.viewBoxSize
                )
              : this.svgElement.setAttribute(
                  "viewBox",
                  "0 0 " + tt.w + " " + tt.h
                ),
            this.renderConfig.viewBoxOnly ||
              (this.svgElement.setAttribute("width", tt.w),
              this.svgElement.setAttribute("height", tt.h),
              (this.svgElement.style.width = "100%"),
              (this.svgElement.style.height = "100%"),
              (this.svgElement.style.transform = "translate3d(0,0,0)"),
              (this.svgElement.style.contentVisibility =
                this.renderConfig.contentVisibility)),
            this.renderConfig.width &&
              this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height &&
              this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className &&
              this.svgElement.setAttribute(
                "class",
                this.renderConfig.className
              ),
            this.renderConfig.id &&
              this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 &&
              this.svgElement.setAttribute(
                "focusable",
                this.renderConfig.focusable
              ),
            this.svgElement.setAttribute(
              "preserveAspectRatio",
              this.renderConfig.preserveAspectRatio
            ),
            this.animationItem.wrapper.appendChild(this.svgElement);
          var et = this.globalData.defs;
          this.setupGlobalData(tt, et),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.data = tt);
          var nt = createNS("clipPath"),
            rt = createNS("rect");
          rt.setAttribute("width", tt.w),
            rt.setAttribute("height", tt.h),
            rt.setAttribute("x", 0),
            rt.setAttribute("y", 0);
          var it = createElementID();
          nt.setAttribute("id", it),
            nt.appendChild(rt),
            this.layerElement.setAttribute(
              "clip-path",
              "url(" + getLocationHref() + "#" + it + ")"
            ),
            et.appendChild(nt),
            (this.layers = tt.layers),
            (this.elements = createSizedArray(tt.layers.length));
        }),
        (SVGRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.layerElement = null),
            (this.globalData.defs = null);
          var tt,
            et = this.layers ? this.layers.length : 0;
          for (tt = 0; tt < et; tt += 1)
            this.elements[tt] &&
              this.elements[tt].destroy &&
              this.elements[tt].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (SVGRendererBase.prototype.updateContainerSize = function () {}),
        (SVGRendererBase.prototype.findIndexByInd = function (tt) {
          var et = 0,
            nt = this.layers.length;
          for (et = 0; et < nt; et += 1)
            if (this.layers[et].ind === tt) return et;
          return -1;
        }),
        (SVGRendererBase.prototype.buildItem = function (tt) {
          var et = this.elements;
          if (!(et[tt] || this.layers[tt].ty === 99)) {
            et[tt] = !0;
            var nt = this.createItem(this.layers[tt]);
            if (
              ((et[tt] = nt),
              getExpressionsPlugin() &&
                (this.layers[tt].ty === 0 &&
                  this.globalData.projectInterface.registerComposition(nt),
                nt.initExpressions()),
              this.appendElementInPos(nt, tt),
              this.layers[tt].tt)
            ) {
              var rt =
                "tp" in this.layers[tt]
                  ? this.findIndexByInd(this.layers[tt].tp)
                  : tt - 1;
              if (rt === -1) return;
              if (!this.elements[rt] || this.elements[rt] === !0)
                this.buildItem(rt), this.addPendingElement(nt);
              else {
                var it = et[rt],
                  st = it.getMatte(this.layers[tt].tt);
                nt.setMatte(st);
              }
            }
          }
        }),
        (SVGRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var tt = this.pendingElements.pop();
            if ((tt.checkParenting(), tt.data.tt))
              for (var et = 0, nt = this.elements.length; et < nt; ) {
                if (this.elements[et] === tt) {
                  var rt =
                      "tp" in tt.data
                        ? this.findIndexByInd(tt.data.tp)
                        : et - 1,
                    it = this.elements[rt],
                    st = it.getMatte(this.layers[et].tt);
                  tt.setMatte(st);
                  break;
                }
                et += 1;
              }
          }
        }),
        (SVGRendererBase.prototype.renderFrame = function (tt) {
          if (!(this.renderedFrame === tt || this.destroyed)) {
            tt === null ? (tt = this.renderedFrame) : (this.renderedFrame = tt),
              (this.globalData.frameNum = tt),
              (this.globalData.frameId += 1),
              (this.globalData.projectInterface.currentFrame = tt),
              (this.globalData._mdf = !1);
            var et,
              nt = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(tt), et = nt - 1;
              et >= 0;
              et -= 1
            )
              (this.completeLayers || this.elements[et]) &&
                this.elements[et].prepareFrame(tt - this.layers[et].st);
            if (this.globalData._mdf)
              for (et = 0; et < nt; et += 1)
                (this.completeLayers || this.elements[et]) &&
                  this.elements[et].renderFrame();
          }
        }),
        (SVGRendererBase.prototype.appendElementInPos = function (tt, et) {
          var nt = tt.getBaseElement();
          if (nt) {
            for (var rt = 0, it; rt < et; )
              this.elements[rt] &&
                this.elements[rt] !== !0 &&
                this.elements[rt].getBaseElement() &&
                (it = this.elements[rt].getBaseElement()),
                (rt += 1);
            it
              ? this.layerElement.insertBefore(nt, it)
              : this.layerElement.appendChild(nt);
          }
        }),
        (SVGRendererBase.prototype.hide = function () {
          this.layerElement.style.display = "none";
        }),
        (SVGRendererBase.prototype.show = function () {
          this.layerElement.style.display = "block";
        });
      function ICompElement() {}
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        ICompElement
      ),
        (ICompElement.prototype.initElement = function (tt, et, nt) {
          this.initFrame(),
            this.initBaseData(tt, et, nt),
            this.initTransform(tt, et, nt),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !et.progressiveLoad) && this.buildAllItems(),
            this.hide();
        }),
        (ICompElement.prototype.prepareFrame = function (tt) {
          if (
            ((this._mdf = !1),
            this.prepareRenderableFrame(tt),
            this.prepareProperties(tt, this.isInRange),
            !(!this.isInRange && !this.data.xt))
          ) {
            if (this.tm._placeholder) this.renderedFrame = tt / this.data.sr;
            else {
              var et = this.tm.v;
              et === this.data.op && (et = this.data.op - 1),
                (this.renderedFrame = et);
            }
            var nt,
              rt = this.elements.length;
            for (
              this.completeLayers || this.checkLayers(this.renderedFrame),
                nt = rt - 1;
              nt >= 0;
              nt -= 1
            )
              (this.completeLayers || this.elements[nt]) &&
                (this.elements[nt].prepareFrame(
                  this.renderedFrame - this.layers[nt].st
                ),
                this.elements[nt]._mdf && (this._mdf = !0));
          }
        }),
        (ICompElement.prototype.renderInnerContent = function () {
          var tt,
            et = this.layers.length;
          for (tt = 0; tt < et; tt += 1)
            (this.completeLayers || this.elements[tt]) &&
              this.elements[tt].renderFrame();
        }),
        (ICompElement.prototype.setElements = function (tt) {
          this.elements = tt;
        }),
        (ICompElement.prototype.getElements = function () {
          return this.elements;
        }),
        (ICompElement.prototype.destroyElements = function () {
          var tt,
            et = this.layers.length;
          for (tt = 0; tt < et; tt += 1)
            this.elements[tt] && this.elements[tt].destroy();
        }),
        (ICompElement.prototype.destroy = function () {
          this.destroyElements(), this.destroyBaseElement();
        });
      function SVGCompElement(tt, et, nt) {
        (this.layers = tt.layers),
          (this.supports3d = !0),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(tt, et, nt),
          (this.tm = tt.tm
            ? PropertyFactory.getProp(this, tt.tm, 0, et.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [SVGRendererBase, ICompElement, SVGBaseElement],
        SVGCompElement
      ),
        (SVGCompElement.prototype.createComp = function (tt) {
          return new SVGCompElement(tt, this.globalData, this);
        });
      function SVGRenderer(tt, et) {
        (this.animationItem = tt),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.svgElement = createNS("svg"));
        var nt = "";
        if (et && et.title) {
          var rt = createNS("title"),
            it = createElementID();
          rt.setAttribute("id", it),
            (rt.textContent = et.title),
            this.svgElement.appendChild(rt),
            (nt += it);
        }
        if (et && et.description) {
          var st = createNS("desc"),
            ot = createElementID();
          st.setAttribute("id", ot),
            (st.textContent = et.description),
            this.svgElement.appendChild(st),
            (nt += " " + ot);
        }
        nt && this.svgElement.setAttribute("aria-labelledby", nt);
        var at = createNS("defs");
        this.svgElement.appendChild(at);
        var lt = createNS("g");
        this.svgElement.appendChild(lt),
          (this.layerElement = lt),
          (this.renderConfig = {
            preserveAspectRatio:
              (et && et.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (et && et.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (et && et.contentVisibility) || "visible",
            progressiveLoad: (et && et.progressiveLoad) || !1,
            hideOnTransparent: !(et && et.hideOnTransparent === !1),
            viewBoxOnly: (et && et.viewBoxOnly) || !1,
            viewBoxSize: (et && et.viewBoxSize) || !1,
            className: (et && et.className) || "",
            id: (et && et.id) || "",
            focusable: et && et.focusable,
            filterSize: {
              width: (et && et.filterSize && et.filterSize.width) || "100%",
              height: (et && et.filterSize && et.filterSize.height) || "100%",
              x: (et && et.filterSize && et.filterSize.x) || "0%",
              y: (et && et.filterSize && et.filterSize.y) || "0%",
            },
            width: et && et.width,
            height: et && et.height,
            runExpressions:
              !et || et.runExpressions === void 0 || et.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            defs: at,
            renderConfig: this.renderConfig,
          }),
          (this.elements = []),
          (this.pendingElements = []),
          (this.destroyed = !1),
          (this.rendererType = "svg");
      }
      extendPrototype([SVGRendererBase], SVGRenderer),
        (SVGRenderer.prototype.createComp = function (tt) {
          return new SVGCompElement(tt, this.globalData, this);
        });
      function ShapeTransformManager() {
        (this.sequences = {}),
          (this.sequenceList = []),
          (this.transform_key_count = 0);
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function (et) {
          var nt,
            rt = et.length,
            it = "_";
          for (nt = 0; nt < rt; nt += 1) it += et[nt].transform.key + "_";
          var st = this.sequences[it];
          return (
            st ||
              ((st = {
                transforms: [].concat(et),
                finalTransform: new Matrix(),
                _mdf: !1,
              }),
              (this.sequences[it] = st),
              this.sequenceList.push(st)),
            st
          );
        },
        processSequence: function (et, nt) {
          for (
            var rt = 0, it = et.transforms.length, st = nt;
            rt < it && !nt;

          ) {
            if (et.transforms[rt].transform.mProps._mdf) {
              st = !0;
              break;
            }
            rt += 1;
          }
          if (st)
            for (et.finalTransform.reset(), rt = it - 1; rt >= 0; rt -= 1)
              et.finalTransform.multiply(et.transforms[rt].transform.mProps.v);
          et._mdf = st;
        },
        processSequences: function (et) {
          var nt,
            rt = this.sequenceList.length;
          for (nt = 0; nt < rt; nt += 1)
            this.processSequence(this.sequenceList[nt], et);
        },
        getNewKey: function () {
          return (
            (this.transform_key_count += 1), "_" + this.transform_key_count
          );
        },
      };
      var lumaLoader = function () {
        var et = "__lottie_element_luma_buffer",
          nt = null,
          rt = null,
          it = null;
        function st() {
          var lt = createNS("svg"),
            ct = createNS("filter"),
            ut = createNS("feColorMatrix");
          return (
            ct.setAttribute("id", et),
            ut.setAttribute("type", "matrix"),
            ut.setAttribute("color-interpolation-filters", "sRGB"),
            ut.setAttribute(
              "values",
              "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"
            ),
            ct.appendChild(ut),
            lt.appendChild(ct),
            lt.setAttribute("id", et + "_svg"),
            featureSupport.svgLumaHidden && (lt.style.display = "none"),
            lt
          );
        }
        function ot() {
          nt ||
            ((it = st()),
            document.body.appendChild(it),
            (nt = createTag("canvas")),
            (rt = nt.getContext("2d")),
            (rt.filter = "url(#" + et + ")"),
            (rt.fillStyle = "rgba(0,0,0,0)"),
            rt.fillRect(0, 0, 1, 1));
        }
        function at(lt) {
          return (
            nt || ot(),
            (nt.width = lt.width),
            (nt.height = lt.height),
            (rt.filter = "url(#" + et + ")"),
            nt
          );
        }
        return { load: ot, get: at };
      };
      function createCanvas(tt, et) {
        if (featureSupport.offscreenCanvas) return new OffscreenCanvas(tt, et);
        var nt = createTag("canvas");
        return (nt.width = tt), (nt.height = et), nt;
      }
      var assetLoader = (function () {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas,
          };
        })(),
        registeredEffects = {};
      function CVEffects(tt) {
        var et,
          nt = tt.data.ef ? tt.data.ef.length : 0;
        this.filters = [];
        var rt;
        for (et = 0; et < nt; et += 1) {
          rt = null;
          var it = tt.data.ef[et].ty;
          if (registeredEffects[it]) {
            var st = registeredEffects[it].effect;
            rt = new st(tt.effectsManager.effectElements[et], tt);
          }
          rt && this.filters.push(rt);
        }
        this.filters.length && tt.addRenderableComponent(this);
      }
      (CVEffects.prototype.renderFrame = function (tt) {
        var et,
          nt = this.filters.length;
        for (et = 0; et < nt; et += 1) this.filters[et].renderFrame(tt);
      }),
        (CVEffects.prototype.getEffects = function (tt) {
          var et,
            nt = this.filters.length,
            rt = [];
          for (et = 0; et < nt; et += 1)
            this.filters[et].type === tt && rt.push(this.filters[et]);
          return rt;
        });
      function registerEffect(tt, et) {
        registeredEffects[tt] = { effect: et };
      }
      function CVMaskElement(tt, et) {
        (this.data = tt),
          (this.element = et),
          (this.masksProperties = this.data.masksProperties || []),
          (this.viewData = createSizedArray(this.masksProperties.length));
        var nt,
          rt = this.masksProperties.length,
          it = !1;
        for (nt = 0; nt < rt; nt += 1)
          this.masksProperties[nt].mode !== "n" && (it = !0),
            (this.viewData[nt] = ShapePropertyFactory.getShapeProp(
              this.element,
              this.masksProperties[nt],
              3
            ));
        (this.hasMasks = it), it && this.element.addRenderableComponent(this);
      }
      (CVMaskElement.prototype.renderFrame = function () {
        if (this.hasMasks) {
          var tt = this.element.finalTransform.mat,
            et = this.element.canvasContext,
            nt,
            rt = this.masksProperties.length,
            it,
            st,
            ot;
          for (et.beginPath(), nt = 0; nt < rt; nt += 1)
            if (this.masksProperties[nt].mode !== "n") {
              this.masksProperties[nt].inv &&
                (et.moveTo(0, 0),
                et.lineTo(this.element.globalData.compSize.w, 0),
                et.lineTo(
                  this.element.globalData.compSize.w,
                  this.element.globalData.compSize.h
                ),
                et.lineTo(0, this.element.globalData.compSize.h),
                et.lineTo(0, 0)),
                (ot = this.viewData[nt].v),
                (it = tt.applyToPointArray(ot.v[0][0], ot.v[0][1], 0)),
                et.moveTo(it[0], it[1]);
              var at,
                lt = ot._length;
              for (at = 1; at < lt; at += 1)
                (st = tt.applyToTriplePoints(ot.o[at - 1], ot.i[at], ot.v[at])),
                  et.bezierCurveTo(st[0], st[1], st[2], st[3], st[4], st[5]);
              (st = tt.applyToTriplePoints(ot.o[at - 1], ot.i[0], ot.v[0])),
                et.bezierCurveTo(st[0], st[1], st[2], st[3], st[4], st[5]);
            }
          this.element.globalData.renderer.save(!0), et.clip();
        }
      }),
        (CVMaskElement.prototype.getMaskProperty =
          MaskElement.prototype.getMaskProperty),
        (CVMaskElement.prototype.destroy = function () {
          this.element = null;
        });
      function CVBaseElement() {}
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out",
      };
      (CVBaseElement.prototype = {
        createElements: function () {},
        initRendererElement: function () {},
        createContainerElements: function () {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var et = this.globalData.canvasContext,
              nt = assetLoader.createCanvas(et.canvas.width, et.canvas.height);
            this.buffers.push(nt);
            var rt = assetLoader.createCanvas(
              et.canvas.width,
              et.canvas.height
            );
            this.buffers.push(rt),
              this.data.tt >= 3 &&
                !document._isProxy &&
                assetLoader.loadLumaCanvas();
          }
          (this.canvasContext = this.globalData.canvasContext),
            (this.transformCanvas = this.globalData.transformCanvas),
            (this.renderableEffectsManager = new CVEffects(this)),
            this.searchEffectTransforms();
        },
        createContent: function () {},
        setBlendMode: function () {
          var et = this.globalData;
          if (et.blendMode !== this.data.bm) {
            et.blendMode = this.data.bm;
            var nt = getBlendMode(this.data.bm);
            et.canvasContext.globalCompositeOperation = nt;
          }
        },
        createRenderableComponents: function () {
          (this.maskManager = new CVMaskElement(this.data, this)),
            (this.transformEffects = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            ));
        },
        hideElement: function () {
          !this.hidden &&
            (!this.isInRange || this.isTransparent) &&
            (this.hidden = !0);
        },
        showElement: function () {
          this.isInRange &&
            !this.isTransparent &&
            ((this.hidden = !1),
            (this._isFirstFrame = !0),
            (this.maskManager._isFirstFrame = !0));
        },
        clearCanvas: function (et) {
          et.clearRect(
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            this.transformCanvas.w * this.transformCanvas.sx,
            this.transformCanvas.h * this.transformCanvas.sy
          );
        },
        prepareLayer: function () {
          if (this.data.tt >= 1) {
            var et = this.buffers[0],
              nt = et.getContext("2d");
            this.clearCanvas(nt),
              nt.drawImage(this.canvasContext.canvas, 0, 0),
              (this.currentTransform = this.canvasContext.getTransform()),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function () {
          if (this.data.tt >= 1) {
            var et = this.buffers[1],
              nt = et.getContext("2d");
            this.clearCanvas(nt),
              nt.drawImage(this.canvasContext.canvas, 0, 0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
            var rt = this.comp.getElementById(
              "tp" in this.data ? this.data.tp : this.data.ind - 1
            );
            if (
              (rt.renderFrame(!0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.data.tt >= 3 && !document._isProxy)
            ) {
              var it = assetLoader.getLumaCanvas(this.canvasContext.canvas),
                st = it.getContext("2d");
              st.drawImage(this.canvasContext.canvas, 0, 0),
                this.clearCanvas(this.canvasContext),
                this.canvasContext.drawImage(it, 0, 0);
            }
            (this.canvasContext.globalCompositeOperation =
              operationsMap[this.data.tt]),
              this.canvasContext.drawImage(et, 0, 0),
              (this.canvasContext.globalCompositeOperation =
                "destination-over"),
              this.canvasContext.drawImage(this.buffers[0], 0, 0),
              this.canvasContext.setTransform(this.currentTransform),
              (this.canvasContext.globalCompositeOperation = "source-over");
          }
        },
        renderFrame: function (et) {
          if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !et)) {
            this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.setBlendMode();
            var nt = this.data.ty === 0;
            this.prepareLayer(),
              this.globalData.renderer.save(nt),
              this.globalData.renderer.ctxTransform(
                this.finalTransform.localMat.props
              ),
              this.globalData.renderer.ctxOpacity(
                this.finalTransform.localOpacity
              ),
              this.renderInnerContent(),
              this.globalData.renderer.restore(nt),
              this.exitLayer(),
              this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
              this._isFirstFrame && (this._isFirstFrame = !1);
          }
        },
        destroy: function () {
          (this.canvasContext = null),
            (this.data = null),
            (this.globalData = null),
            this.maskManager.destroy();
        },
        mHelper: new Matrix(),
      }),
        (CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement),
        (CVBaseElement.prototype.show = CVBaseElement.prototype.showElement);
      function CVShapeData(tt, et, nt, rt) {
        (this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0]);
        var it = 4;
        et.ty === "rc"
          ? (it = 5)
          : et.ty === "el"
          ? (it = 6)
          : et.ty === "sr" && (it = 7),
          (this.sh = ShapePropertyFactory.getShapeProp(tt, et, it, tt));
        var st,
          ot = nt.length,
          at;
        for (st = 0; st < ot; st += 1)
          nt[st].closed ||
            ((at = {
              transforms: rt.addTransformSequence(nt[st].transforms),
              trNodes: [],
            }),
            this.styledShapes.push(at),
            nt[st].elements.push(at));
      }
      CVShapeData.prototype.setAsAnimated =
        SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(tt, et, nt) {
        (this.shapes = []),
          (this.shapesData = tt.shapes),
          (this.stylesList = []),
          (this.itemsData = []),
          (this.prevViewData = []),
          (this.shapeModifiers = []),
          (this.processedElements = []),
          (this.transformsManager = new ShapeTransformManager()),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVShapeElement
      ),
        (CVShapeElement.prototype.initElement =
          RenderableDOMElement.prototype.initElement),
        (CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }),
        (CVShapeElement.prototype.dashResetter = []),
        (CVShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            !0,
            []
          );
        }),
        (CVShapeElement.prototype.createStyleElement = function (tt, et) {
          var nt = {
              data: tt,
              type: tt.ty,
              preTransforms: this.transformsManager.addTransformSequence(et),
              transforms: [],
              elements: [],
              closed: tt.hd === !0,
            },
            rt = {};
          if (
            (tt.ty === "fl" || tt.ty === "st"
              ? ((rt.c = PropertyFactory.getProp(this, tt.c, 1, 255, this)),
                rt.c.k ||
                  (nt.co =
                    "rgb(" +
                    bmFloor(rt.c.v[0]) +
                    "," +
                    bmFloor(rt.c.v[1]) +
                    "," +
                    bmFloor(rt.c.v[2]) +
                    ")"))
              : (tt.ty === "gf" || tt.ty === "gs") &&
                ((rt.s = PropertyFactory.getProp(this, tt.s, 1, null, this)),
                (rt.e = PropertyFactory.getProp(this, tt.e, 1, null, this)),
                (rt.h = PropertyFactory.getProp(
                  this,
                  tt.h || { k: 0 },
                  0,
                  0.01,
                  this
                )),
                (rt.a = PropertyFactory.getProp(
                  this,
                  tt.a || { k: 0 },
                  0,
                  degToRads,
                  this
                )),
                (rt.g = new GradientProperty(this, tt.g, this))),
            (rt.o = PropertyFactory.getProp(this, tt.o, 0, 0.01, this)),
            tt.ty === "st" || tt.ty === "gs")
          ) {
            if (
              ((nt.lc = lineCapEnum[tt.lc || 2]),
              (nt.lj = lineJoinEnum[tt.lj || 2]),
              tt.lj == 1 && (nt.ml = tt.ml),
              (rt.w = PropertyFactory.getProp(this, tt.w, 0, null, this)),
              rt.w.k || (nt.wi = rt.w.v),
              tt.d)
            ) {
              var it = new DashProperty(this, tt.d, "canvas", this);
              (rt.d = it),
                rt.d.k ||
                  ((nt.da = rt.d.dashArray), (nt.do = rt.d.dashoffset[0]));
            }
          } else nt.r = tt.r === 2 ? "evenodd" : "nonzero";
          return this.stylesList.push(nt), (rt.style = nt), rt;
        }),
        (CVShapeElement.prototype.createGroupElement = function () {
          var tt = { it: [], prevViewData: [] };
          return tt;
        }),
        (CVShapeElement.prototype.createTransformElement = function (tt) {
          var et = {
            transform: {
              opacity: 1,
              _opMdf: !1,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, tt.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(
                this,
                tt,
                this
              ),
            },
          };
          return et;
        }),
        (CVShapeElement.prototype.createShapeElement = function (tt) {
          var et = new CVShapeData(
            this,
            tt,
            this.stylesList,
            this.transformsManager
          );
          return this.shapes.push(et), this.addShapeToModifiers(et), et;
        }),
        (CVShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var tt,
            et = this.itemsData.length;
          for (tt = 0; tt < et; tt += 1)
            this.prevViewData[tt] = this.itemsData[tt];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              !0,
              []
            ),
              et = this.dynamicProperties.length,
              tt = 0;
            tt < et;
            tt += 1
          )
            this.dynamicProperties[tt].getValue();
          this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame);
        }),
        (CVShapeElement.prototype.addTransformToStyleList = function (tt) {
          var et,
            nt = this.stylesList.length;
          for (et = 0; et < nt; et += 1)
            this.stylesList[et].closed ||
              this.stylesList[et].transforms.push(tt);
        }),
        (CVShapeElement.prototype.removeTransformFromStyleList = function () {
          var tt,
            et = this.stylesList.length;
          for (tt = 0; tt < et; tt += 1)
            this.stylesList[tt].closed || this.stylesList[tt].transforms.pop();
        }),
        (CVShapeElement.prototype.closeStyles = function (tt) {
          var et,
            nt = tt.length;
          for (et = 0; et < nt; et += 1) tt[et].closed = !0;
        }),
        (CVShapeElement.prototype.searchShapes = function (tt, et, nt, rt, it) {
          var st,
            ot = tt.length - 1,
            at,
            lt,
            ct = [],
            ut = [],
            ft,
            ht,
            mt,
            vt = [].concat(it);
          for (st = ot; st >= 0; st -= 1) {
            if (
              ((ft = this.searchProcessedElement(tt[st])),
              ft ? (et[st] = nt[ft - 1]) : (tt[st]._shouldRender = rt),
              tt[st].ty === "fl" ||
                tt[st].ty === "st" ||
                tt[st].ty === "gf" ||
                tt[st].ty === "gs")
            )
              ft
                ? (et[st].style.closed = !1)
                : (et[st] = this.createStyleElement(tt[st], vt)),
                ct.push(et[st].style);
            else if (tt[st].ty === "gr") {
              if (!ft) et[st] = this.createGroupElement(tt[st]);
              else
                for (lt = et[st].it.length, at = 0; at < lt; at += 1)
                  et[st].prevViewData[at] = et[st].it[at];
              this.searchShapes(
                tt[st].it,
                et[st].it,
                et[st].prevViewData,
                rt,
                vt
              );
            } else
              tt[st].ty === "tr"
                ? (ft ||
                    ((mt = this.createTransformElement(tt[st])), (et[st] = mt)),
                  vt.push(et[st]),
                  this.addTransformToStyleList(et[st]))
                : tt[st].ty === "sh" ||
                  tt[st].ty === "rc" ||
                  tt[st].ty === "el" ||
                  tt[st].ty === "sr"
                ? ft || (et[st] = this.createShapeElement(tt[st]))
                : tt[st].ty === "tm" ||
                  tt[st].ty === "rd" ||
                  tt[st].ty === "pb" ||
                  tt[st].ty === "zz" ||
                  tt[st].ty === "op"
                ? (ft
                    ? ((ht = et[st]), (ht.closed = !1))
                    : ((ht = ShapeModifiers.getModifier(tt[st].ty)),
                      ht.init(this, tt[st]),
                      (et[st] = ht),
                      this.shapeModifiers.push(ht)),
                  ut.push(ht))
                : tt[st].ty === "rp" &&
                  (ft
                    ? ((ht = et[st]), (ht.closed = !0))
                    : ((ht = ShapeModifiers.getModifier(tt[st].ty)),
                      (et[st] = ht),
                      ht.init(this, tt, st, et),
                      this.shapeModifiers.push(ht),
                      (rt = !1)),
                  ut.push(ht));
            this.addProcessedElement(tt[st], st + 1);
          }
          for (
            this.removeTransformFromStyleList(),
              this.closeStyles(ct),
              ot = ut.length,
              st = 0;
            st < ot;
            st += 1
          )
            ut[st].closed = !0;
        }),
        (CVShapeElement.prototype.renderInnerContent = function () {
          (this.transformHelper.opacity = 1),
            (this.transformHelper._opMdf = !1),
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(
              this.transformHelper,
              this.shapesData,
              this.itemsData,
              !0
            );
        }),
        (CVShapeElement.prototype.renderShapeTransform = function (tt, et) {
          (tt._opMdf || et.op._mdf || this._isFirstFrame) &&
            ((et.opacity = tt.opacity),
            (et.opacity *= et.op.v),
            (et._opMdf = !0));
        }),
        (CVShapeElement.prototype.drawLayer = function () {
          var tt,
            et = this.stylesList.length,
            nt,
            rt,
            it,
            st,
            ot,
            at,
            lt = this.globalData.renderer,
            ct = this.globalData.canvasContext,
            ut,
            ft;
          for (tt = 0; tt < et; tt += 1)
            if (
              ((ft = this.stylesList[tt]),
              (ut = ft.type),
              !(
                ((ut === "st" || ut === "gs") && ft.wi === 0) ||
                !ft.data._shouldRender ||
                ft.coOp === 0 ||
                this.globalData.currentGlobalAlpha === 0
              ))
            ) {
              for (
                lt.save(),
                  ot = ft.elements,
                  ut === "st" || ut === "gs"
                    ? (lt.ctxStrokeStyle(ut === "st" ? ft.co : ft.grd),
                      lt.ctxLineWidth(ft.wi),
                      lt.ctxLineCap(ft.lc),
                      lt.ctxLineJoin(ft.lj),
                      lt.ctxMiterLimit(ft.ml || 0))
                    : lt.ctxFillStyle(ut === "fl" ? ft.co : ft.grd),
                  lt.ctxOpacity(ft.coOp),
                  ut !== "st" && ut !== "gs" && ct.beginPath(),
                  lt.ctxTransform(ft.preTransforms.finalTransform.props),
                  rt = ot.length,
                  nt = 0;
                nt < rt;
                nt += 1
              ) {
                for (
                  (ut === "st" || ut === "gs") &&
                    (ct.beginPath(),
                    ft.da &&
                      (ct.setLineDash(ft.da), (ct.lineDashOffset = ft.do))),
                    at = ot[nt].trNodes,
                    st = at.length,
                    it = 0;
                  it < st;
                  it += 1
                )
                  at[it].t === "m"
                    ? ct.moveTo(at[it].p[0], at[it].p[1])
                    : at[it].t === "c"
                    ? ct.bezierCurveTo(
                        at[it].pts[0],
                        at[it].pts[1],
                        at[it].pts[2],
                        at[it].pts[3],
                        at[it].pts[4],
                        at[it].pts[5]
                      )
                    : ct.closePath();
                (ut === "st" || ut === "gs") &&
                  (lt.ctxStroke(), ft.da && ct.setLineDash(this.dashResetter));
              }
              ut !== "st" &&
                ut !== "gs" &&
                this.globalData.renderer.ctxFill(ft.r),
                lt.restore();
            }
        }),
        (CVShapeElement.prototype.renderShape = function (tt, et, nt, rt) {
          var it,
            st = et.length - 1,
            ot;
          for (ot = tt, it = st; it >= 0; it -= 1)
            et[it].ty === "tr"
              ? ((ot = nt[it].transform), this.renderShapeTransform(tt, ot))
              : et[it].ty === "sh" ||
                et[it].ty === "el" ||
                et[it].ty === "rc" ||
                et[it].ty === "sr"
              ? this.renderPath(et[it], nt[it])
              : et[it].ty === "fl"
              ? this.renderFill(et[it], nt[it], ot)
              : et[it].ty === "st"
              ? this.renderStroke(et[it], nt[it], ot)
              : et[it].ty === "gf" || et[it].ty === "gs"
              ? this.renderGradientFill(et[it], nt[it], ot)
              : et[it].ty === "gr"
              ? this.renderShape(ot, et[it].it, nt[it].it)
              : et[it].ty;
          rt && this.drawLayer();
        }),
        (CVShapeElement.prototype.renderStyledShape = function (tt, et) {
          if (this._isFirstFrame || et._mdf || tt.transforms._mdf) {
            var nt = tt.trNodes,
              rt = et.paths,
              it,
              st,
              ot,
              at = rt._length;
            nt.length = 0;
            var lt = tt.transforms.finalTransform;
            for (ot = 0; ot < at; ot += 1) {
              var ct = rt.shapes[ot];
              if (ct && ct.v) {
                for (st = ct._length, it = 1; it < st; it += 1)
                  it === 1 &&
                    nt.push({
                      t: "m",
                      p: lt.applyToPointArray(ct.v[0][0], ct.v[0][1], 0),
                    }),
                    nt.push({
                      t: "c",
                      pts: lt.applyToTriplePoints(
                        ct.o[it - 1],
                        ct.i[it],
                        ct.v[it]
                      ),
                    });
                st === 1 &&
                  nt.push({
                    t: "m",
                    p: lt.applyToPointArray(ct.v[0][0], ct.v[0][1], 0),
                  }),
                  ct.c &&
                    st &&
                    (nt.push({
                      t: "c",
                      pts: lt.applyToTriplePoints(
                        ct.o[it - 1],
                        ct.i[0],
                        ct.v[0]
                      ),
                    }),
                    nt.push({ t: "z" }));
              }
            }
            tt.trNodes = nt;
          }
        }),
        (CVShapeElement.prototype.renderPath = function (tt, et) {
          if (tt.hd !== !0 && tt._shouldRender) {
            var nt,
              rt = et.styledShapes.length;
            for (nt = 0; nt < rt; nt += 1)
              this.renderStyledShape(et.styledShapes[nt], et.sh);
          }
        }),
        (CVShapeElement.prototype.renderFill = function (tt, et, nt) {
          var rt = et.style;
          (et.c._mdf || this._isFirstFrame) &&
            (rt.co =
              "rgb(" +
              bmFloor(et.c.v[0]) +
              "," +
              bmFloor(et.c.v[1]) +
              "," +
              bmFloor(et.c.v[2]) +
              ")"),
            (et.o._mdf || nt._opMdf || this._isFirstFrame) &&
              (rt.coOp = et.o.v * nt.opacity);
        }),
        (CVShapeElement.prototype.renderGradientFill = function (tt, et, nt) {
          var rt = et.style,
            it;
          if (
            !rt.grd ||
            et.g._mdf ||
            et.s._mdf ||
            et.e._mdf ||
            (tt.t !== 1 && (et.h._mdf || et.a._mdf))
          ) {
            var st = this.globalData.canvasContext,
              ot = et.s.v,
              at = et.e.v;
            if (tt.t === 1)
              it = st.createLinearGradient(ot[0], ot[1], at[0], at[1]);
            else {
              var lt = Math.sqrt(
                  Math.pow(ot[0] - at[0], 2) + Math.pow(ot[1] - at[1], 2)
                ),
                ct = Math.atan2(at[1] - ot[1], at[0] - ot[0]),
                ut = et.h.v;
              ut >= 1 ? (ut = 0.99) : ut <= -1 && (ut = -0.99);
              var ft = lt * ut,
                ht = Math.cos(ct + et.a.v) * ft + ot[0],
                mt = Math.sin(ct + et.a.v) * ft + ot[1];
              it = st.createRadialGradient(ht, mt, 0, ot[0], ot[1], lt);
            }
            var vt,
              yt = tt.g.p,
              Et = et.g.c,
              pt = 1;
            for (vt = 0; vt < yt; vt += 1)
              et.g._hasOpacity &&
                et.g._collapsable &&
                (pt = et.g.o[vt * 2 + 1]),
                it.addColorStop(
                  Et[vt * 4] / 100,
                  "rgba(" +
                    Et[vt * 4 + 1] +
                    "," +
                    Et[vt * 4 + 2] +
                    "," +
                    Et[vt * 4 + 3] +
                    "," +
                    pt +
                    ")"
                );
            rt.grd = it;
          }
          rt.coOp = et.o.v * nt.opacity;
        }),
        (CVShapeElement.prototype.renderStroke = function (tt, et, nt) {
          var rt = et.style,
            it = et.d;
          it &&
            (it._mdf || this._isFirstFrame) &&
            ((rt.da = it.dashArray), (rt.do = it.dashoffset[0])),
            (et.c._mdf || this._isFirstFrame) &&
              (rt.co =
                "rgb(" +
                bmFloor(et.c.v[0]) +
                "," +
                bmFloor(et.c.v[1]) +
                "," +
                bmFloor(et.c.v[2]) +
                ")"),
            (et.o._mdf || nt._opMdf || this._isFirstFrame) &&
              (rt.coOp = et.o.v * nt.opacity),
            (et.w._mdf || this._isFirstFrame) && (rt.wi = et.w.v);
        }),
        (CVShapeElement.prototype.destroy = function () {
          (this.shapesData = null),
            (this.globalData = null),
            (this.canvasContext = null),
            (this.stylesList.length = 0),
            (this.itemsData.length = 0);
        });
      function CVTextElement(tt, et, nt) {
        (this.textSpans = []),
          (this.yOffset = 0),
          (this.fillColorAnim = !1),
          (this.strokeColorAnim = !1),
          (this.strokeWidthAnim = !1),
          (this.stroke = !1),
          (this.fill = !1),
          (this.justifyOffset = 0),
          (this.currentRender = null),
          (this.renderType = "canvas"),
          (this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: "",
          }),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
          ITextElement,
        ],
        CVTextElement
      ),
        (CVTextElement.prototype.tHelper =
          createTag("canvas").getContext("2d")),
        (CVTextElement.prototype.buildNewText = function () {
          var tt = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(tt.l ? tt.l.length : 0);
          var et = !1;
          tt.fc
            ? ((et = !0), (this.values.fill = this.buildColor(tt.fc)))
            : (this.values.fill = "rgba(0,0,0,0)"),
            (this.fill = et);
          var nt = !1;
          tt.sc &&
            ((nt = !0),
            (this.values.stroke = this.buildColor(tt.sc)),
            (this.values.sWidth = tt.sw));
          var rt = this.globalData.fontManager.getFontByName(tt.f),
            it,
            st,
            ot = tt.l,
            at = this.mHelper;
          (this.stroke = nt),
            (this.values.fValue =
              tt.finalSize +
              "px " +
              this.globalData.fontManager.getFontByName(tt.f).fFamily),
            (st = tt.finalText.length);
          var lt,
            ct,
            ut,
            ft,
            ht,
            mt,
            vt,
            yt,
            Et,
            pt,
            xt = this.data.singleShape,
            St = tt.tr * 0.001 * tt.finalSize,
            At = 0,
            Ct = 0,
            Mt = !0,
            wt = 0;
          for (it = 0; it < st; it += 1) {
            (lt = this.globalData.fontManager.getCharData(
              tt.finalText[it],
              rt.fStyle,
              this.globalData.fontManager.getFontByName(tt.f).fFamily
            )),
              (ct = (lt && lt.data) || {}),
              at.reset(),
              xt &&
                ot[it].n &&
                ((At = -St), (Ct += tt.yOffset), (Ct += Mt ? 1 : 0), (Mt = !1)),
              (ht = ct.shapes ? ct.shapes[0].it : []),
              (vt = ht.length),
              at.scale(tt.finalSize / 100, tt.finalSize / 100),
              xt &&
                this.applyTextPropertiesToMatrix(tt, at, ot[it].line, At, Ct),
              (Et = createSizedArray(vt - 1));
            var Bt = 0;
            for (mt = 0; mt < vt; mt += 1)
              if (ht[mt].ty === "sh") {
                for (
                  ft = ht[mt].ks.k.i.length, yt = ht[mt].ks.k, pt = [], ut = 1;
                  ut < ft;
                  ut += 1
                )
                  ut === 1 &&
                    pt.push(
                      at.applyToX(yt.v[0][0], yt.v[0][1], 0),
                      at.applyToY(yt.v[0][0], yt.v[0][1], 0)
                    ),
                    pt.push(
                      at.applyToX(yt.o[ut - 1][0], yt.o[ut - 1][1], 0),
                      at.applyToY(yt.o[ut - 1][0], yt.o[ut - 1][1], 0),
                      at.applyToX(yt.i[ut][0], yt.i[ut][1], 0),
                      at.applyToY(yt.i[ut][0], yt.i[ut][1], 0),
                      at.applyToX(yt.v[ut][0], yt.v[ut][1], 0),
                      at.applyToY(yt.v[ut][0], yt.v[ut][1], 0)
                    );
                pt.push(
                  at.applyToX(yt.o[ut - 1][0], yt.o[ut - 1][1], 0),
                  at.applyToY(yt.o[ut - 1][0], yt.o[ut - 1][1], 0),
                  at.applyToX(yt.i[0][0], yt.i[0][1], 0),
                  at.applyToY(yt.i[0][0], yt.i[0][1], 0),
                  at.applyToX(yt.v[0][0], yt.v[0][1], 0),
                  at.applyToY(yt.v[0][0], yt.v[0][1], 0)
                ),
                  (Et[Bt] = pt),
                  (Bt += 1);
              }
            xt && ((At += ot[it].l), (At += St)),
              this.textSpans[wt]
                ? (this.textSpans[wt].elem = Et)
                : (this.textSpans[wt] = { elem: Et }),
              (wt += 1);
          }
        }),
        (CVTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var tt = this.canvasContext;
          (tt.font = this.values.fValue),
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape ||
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              );
          var et,
            nt,
            rt,
            it,
            st,
            ot,
            at = this.textAnimator.renderedLetters,
            lt = this.textProperty.currentData.l;
          nt = lt.length;
          var ct,
            ut = null,
            ft = null,
            ht = null,
            mt,
            vt,
            yt = this.globalData.renderer;
          for (et = 0; et < nt; et += 1)
            if (!lt[et].n) {
              if (
                ((ct = at[et]),
                ct && (yt.save(), yt.ctxTransform(ct.p), yt.ctxOpacity(ct.o)),
                this.fill)
              ) {
                for (
                  ct && ct.fc
                    ? ut !== ct.fc && (yt.ctxFillStyle(ct.fc), (ut = ct.fc))
                    : ut !== this.values.fill &&
                      ((ut = this.values.fill),
                      yt.ctxFillStyle(this.values.fill)),
                    mt = this.textSpans[et].elem,
                    it = mt.length,
                    this.globalData.canvasContext.beginPath(),
                    rt = 0;
                  rt < it;
                  rt += 1
                )
                  for (
                    vt = mt[rt],
                      ot = vt.length,
                      this.globalData.canvasContext.moveTo(vt[0], vt[1]),
                      st = 2;
                    st < ot;
                    st += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      vt[st],
                      vt[st + 1],
                      vt[st + 2],
                      vt[st + 3],
                      vt[st + 4],
                      vt[st + 5]
                    );
                this.globalData.canvasContext.closePath(), yt.ctxFill();
              }
              if (this.stroke) {
                for (
                  ct && ct.sw
                    ? ht !== ct.sw && ((ht = ct.sw), yt.ctxLineWidth(ct.sw))
                    : ht !== this.values.sWidth &&
                      ((ht = this.values.sWidth),
                      yt.ctxLineWidth(this.values.sWidth)),
                    ct && ct.sc
                      ? ft !== ct.sc && ((ft = ct.sc), yt.ctxStrokeStyle(ct.sc))
                      : ft !== this.values.stroke &&
                        ((ft = this.values.stroke),
                        yt.ctxStrokeStyle(this.values.stroke)),
                    mt = this.textSpans[et].elem,
                    it = mt.length,
                    this.globalData.canvasContext.beginPath(),
                    rt = 0;
                  rt < it;
                  rt += 1
                )
                  for (
                    vt = mt[rt],
                      ot = vt.length,
                      this.globalData.canvasContext.moveTo(vt[0], vt[1]),
                      st = 2;
                    st < ot;
                    st += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      vt[st],
                      vt[st + 1],
                      vt[st + 2],
                      vt[st + 3],
                      vt[st + 4],
                      vt[st + 5]
                    );
                this.globalData.canvasContext.closePath(), yt.ctxStroke();
              }
              ct && this.globalData.renderer.restore();
            }
        });
      function CVImageElement(tt, et, nt) {
        (this.assetData = et.getAssetData(tt.refId)),
          (this.img = et.imageLoader.getAsset(this.assetData)),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVImageElement
      ),
        (CVImageElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVImageElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVImageElement.prototype.createContent = function () {
          if (
            this.img.width &&
            (this.assetData.w !== this.img.width ||
              this.assetData.h !== this.img.height)
          ) {
            var tt = createTag("canvas");
            (tt.width = this.assetData.w), (tt.height = this.assetData.h);
            var et = tt.getContext("2d"),
              nt = this.img.width,
              rt = this.img.height,
              it = nt / rt,
              st = this.assetData.w / this.assetData.h,
              ot,
              at,
              lt =
                this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio;
            (it > st && lt === "xMidYMid slice") ||
            (it < st && lt !== "xMidYMid slice")
              ? ((at = rt), (ot = at * st))
              : ((ot = nt), (at = ot / st)),
              et.drawImage(
                this.img,
                (nt - ot) / 2,
                (rt - at) / 2,
                ot,
                at,
                0,
                0,
                this.assetData.w,
                this.assetData.h
              ),
              (this.img = tt);
          }
        }),
        (CVImageElement.prototype.renderInnerContent = function () {
          this.canvasContext.drawImage(this.img, 0, 0);
        }),
        (CVImageElement.prototype.destroy = function () {
          this.img = null;
        });
      function CVSolidElement(tt, et, nt) {
        this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVSolidElement
      ),
        (CVSolidElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVSolidElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVSolidElement.prototype.renderInnerContent = function () {
          this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(
              0,
              0,
              this.data.sw,
              this.data.sh
            );
        });
      function CanvasRendererBase() {}
      extendPrototype([BaseRenderer], CanvasRendererBase),
        (CanvasRendererBase.prototype.createShape = function (tt) {
          return new CVShapeElement(tt, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createText = function (tt) {
          return new CVTextElement(tt, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createImage = function (tt) {
          return new CVImageElement(tt, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createSolid = function (tt) {
          return new CVSolidElement(tt, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (CanvasRendererBase.prototype.ctxTransform = function (tt) {
          (tt[0] === 1 &&
            tt[1] === 0 &&
            tt[4] === 0 &&
            tt[5] === 1 &&
            tt[12] === 0 &&
            tt[13] === 0) ||
            this.canvasContext.transform(
              tt[0],
              tt[1],
              tt[4],
              tt[5],
              tt[12],
              tt[13]
            );
        }),
        (CanvasRendererBase.prototype.ctxOpacity = function (tt) {
          this.canvasContext.globalAlpha *= tt < 0 ? 0 : tt;
        }),
        (CanvasRendererBase.prototype.ctxFillStyle = function (tt) {
          this.canvasContext.fillStyle = tt;
        }),
        (CanvasRendererBase.prototype.ctxStrokeStyle = function (tt) {
          this.canvasContext.strokeStyle = tt;
        }),
        (CanvasRendererBase.prototype.ctxLineWidth = function (tt) {
          this.canvasContext.lineWidth = tt;
        }),
        (CanvasRendererBase.prototype.ctxLineCap = function (tt) {
          this.canvasContext.lineCap = tt;
        }),
        (CanvasRendererBase.prototype.ctxLineJoin = function (tt) {
          this.canvasContext.lineJoin = tt;
        }),
        (CanvasRendererBase.prototype.ctxMiterLimit = function (tt) {
          this.canvasContext.miterLimit = tt;
        }),
        (CanvasRendererBase.prototype.ctxFill = function (tt) {
          this.canvasContext.fill(tt);
        }),
        (CanvasRendererBase.prototype.ctxFillRect = function (tt, et, nt, rt) {
          this.canvasContext.fillRect(tt, et, nt, rt);
        }),
        (CanvasRendererBase.prototype.ctxStroke = function () {
          this.canvasContext.stroke();
        }),
        (CanvasRendererBase.prototype.reset = function () {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          this.contextData.reset();
        }),
        (CanvasRendererBase.prototype.save = function () {
          this.canvasContext.save();
        }),
        (CanvasRendererBase.prototype.restore = function (tt) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          tt && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(tt);
        }),
        (CanvasRendererBase.prototype.configAnimation = function (tt) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var et = this.animationItem.container.style;
            (et.width = "100%"), (et.height = "100%");
            var nt = "0px 0px 0px";
            (et.transformOrigin = nt),
              (et.mozTransformOrigin = nt),
              (et.webkitTransformOrigin = nt),
              (et["-webkit-transform"] = nt),
              (et.contentVisibility = this.renderConfig.contentVisibility),
              this.animationItem.wrapper.appendChild(
                this.animationItem.container
              ),
              (this.canvasContext =
                this.animationItem.container.getContext("2d")),
              this.renderConfig.className &&
                this.animationItem.container.setAttribute(
                  "class",
                  this.renderConfig.className
                ),
              this.renderConfig.id &&
                this.animationItem.container.setAttribute(
                  "id",
                  this.renderConfig.id
                );
          } else this.canvasContext = this.renderConfig.context;
          this.contextData.setContext(this.canvasContext),
            (this.data = tt),
            (this.layers = tt.layers),
            (this.transformCanvas = {
              w: tt.w,
              h: tt.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0,
            }),
            this.setupGlobalData(tt, document.body),
            (this.globalData.canvasContext = this.canvasContext),
            (this.globalData.renderer = this),
            (this.globalData.isDashed = !1),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.globalData.transformCanvas = this.transformCanvas),
            (this.elements = createSizedArray(tt.layers.length)),
            this.updateContainerSize();
        }),
        (CanvasRendererBase.prototype.updateContainerSize = function (tt, et) {
          this.reset();
          var nt, rt;
          tt
            ? ((nt = tt),
              (rt = et),
              (this.canvasContext.canvas.width = nt),
              (this.canvasContext.canvas.height = rt))
            : (this.animationItem.wrapper && this.animationItem.container
                ? ((nt = this.animationItem.wrapper.offsetWidth),
                  (rt = this.animationItem.wrapper.offsetHeight))
                : ((nt = this.canvasContext.canvas.width),
                  (rt = this.canvasContext.canvas.height)),
              (this.canvasContext.canvas.width = nt * this.renderConfig.dpr),
              (this.canvasContext.canvas.height = rt * this.renderConfig.dpr));
          var it, st;
          if (
            this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 ||
            this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
          ) {
            var ot = this.renderConfig.preserveAspectRatio.split(" "),
              at = ot[1] || "meet",
              lt = ot[0] || "xMidYMid",
              ct = lt.substr(0, 4),
              ut = lt.substr(4);
            (it = nt / rt),
              (st = this.transformCanvas.w / this.transformCanvas.h),
              (st > it && at === "meet") || (st < it && at === "slice")
                ? ((this.transformCanvas.sx =
                    nt / (this.transformCanvas.w / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    nt / (this.transformCanvas.w / this.renderConfig.dpr)))
                : ((this.transformCanvas.sx =
                    rt / (this.transformCanvas.h / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    rt / (this.transformCanvas.h / this.renderConfig.dpr))),
              ct === "xMid" &&
              ((st < it && at === "meet") || (st > it && at === "slice"))
                ? (this.transformCanvas.tx =
                    ((nt -
                      this.transformCanvas.w * (rt / this.transformCanvas.h)) /
                      2) *
                    this.renderConfig.dpr)
                : ct === "xMax" &&
                  ((st < it && at === "meet") || (st > it && at === "slice"))
                ? (this.transformCanvas.tx =
                    (nt -
                      this.transformCanvas.w * (rt / this.transformCanvas.h)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.tx = 0),
              ut === "YMid" &&
              ((st > it && at === "meet") || (st < it && at === "slice"))
                ? (this.transformCanvas.ty =
                    ((rt -
                      this.transformCanvas.h * (nt / this.transformCanvas.w)) /
                      2) *
                    this.renderConfig.dpr)
                : ut === "YMax" &&
                  ((st > it && at === "meet") || (st < it && at === "slice"))
                ? (this.transformCanvas.ty =
                    (rt -
                      this.transformCanvas.h * (nt / this.transformCanvas.w)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.ty = 0);
          } else
            this.renderConfig.preserveAspectRatio === "none"
              ? ((this.transformCanvas.sx =
                  nt / (this.transformCanvas.w / this.renderConfig.dpr)),
                (this.transformCanvas.sy =
                  rt / (this.transformCanvas.h / this.renderConfig.dpr)),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0))
              : ((this.transformCanvas.sx = this.renderConfig.dpr),
                (this.transformCanvas.sy = this.renderConfig.dpr),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0));
          (this.transformCanvas.props = [
            this.transformCanvas.sx,
            0,
            0,
            0,
            0,
            this.transformCanvas.sy,
            0,
            0,
            0,
            0,
            1,
            0,
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            0,
            1,
          ]),
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(
              0,
              0,
              this.transformCanvas.w,
              this.transformCanvas.h
            ),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0);
        }),
        (CanvasRendererBase.prototype.destroy = function () {
          this.renderConfig.clearCanvas &&
            this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = "");
          var tt,
            et = this.layers ? this.layers.length : 0;
          for (tt = et - 1; tt >= 0; tt -= 1)
            this.elements[tt] &&
              this.elements[tt].destroy &&
              this.elements[tt].destroy();
          (this.elements.length = 0),
            (this.globalData.canvasContext = null),
            (this.animationItem.container = null),
            (this.destroyed = !0);
        }),
        (CanvasRendererBase.prototype.renderFrame = function (tt, et) {
          if (
            !(
              (this.renderedFrame === tt &&
                this.renderConfig.clearCanvas === !0 &&
                !et) ||
              this.destroyed ||
              tt === -1
            )
          ) {
            (this.renderedFrame = tt),
              (this.globalData.frameNum =
                tt - this.animationItem._isFirstFrame),
              (this.globalData.frameId += 1),
              (this.globalData._mdf = !this.renderConfig.clearCanvas || et),
              (this.globalData.projectInterface.currentFrame = tt);
            var nt,
              rt = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(tt), nt = rt - 1;
              nt >= 0;
              nt -= 1
            )
              (this.completeLayers || this.elements[nt]) &&
                this.elements[nt].prepareFrame(tt - this.layers[nt].st);
            if (this.globalData._mdf) {
              for (
                this.renderConfig.clearCanvas === !0
                  ? this.canvasContext.clearRect(
                      0,
                      0,
                      this.transformCanvas.w,
                      this.transformCanvas.h
                    )
                  : this.save(),
                  nt = rt - 1;
                nt >= 0;
                nt -= 1
              )
                (this.completeLayers || this.elements[nt]) &&
                  this.elements[nt].renderFrame();
              this.renderConfig.clearCanvas !== !0 && this.restore();
            }
          }
        }),
        (CanvasRendererBase.prototype.buildItem = function (tt) {
          var et = this.elements;
          if (!(et[tt] || this.layers[tt].ty === 99)) {
            var nt = this.createItem(this.layers[tt], this, this.globalData);
            (et[tt] = nt), nt.initExpressions();
          }
        }),
        (CanvasRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var tt = this.pendingElements.pop();
            tt.checkParenting();
          }
        }),
        (CanvasRendererBase.prototype.hide = function () {
          this.animationItem.container.style.display = "none";
        }),
        (CanvasRendererBase.prototype.show = function () {
          this.animationItem.container.style.display = "block";
        });
      function CanvasContext() {
        (this.opacity = -1),
          (this.transform = createTypedArray("float32", 16)),
          (this.fillStyle = ""),
          (this.strokeStyle = ""),
          (this.lineWidth = ""),
          (this.lineCap = ""),
          (this.lineJoin = ""),
          (this.miterLimit = ""),
          (this.id = Math.random());
      }
      function CVContextData() {
        (this.stack = []), (this.cArrPos = 0), (this.cTr = new Matrix());
        var tt,
          et = 15;
        for (tt = 0; tt < et; tt += 1) {
          var nt = new CanvasContext();
          this.stack[tt] = nt;
        }
        (this._length = et),
          (this.nativeContext = null),
          (this.transformMat = new Matrix()),
          (this.currentOpacity = 1),
          (this.currentFillStyle = ""),
          (this.appliedFillStyle = ""),
          (this.currentStrokeStyle = ""),
          (this.appliedStrokeStyle = ""),
          (this.currentLineWidth = ""),
          (this.appliedLineWidth = ""),
          (this.currentLineCap = ""),
          (this.appliedLineCap = ""),
          (this.currentLineJoin = ""),
          (this.appliedLineJoin = ""),
          (this.appliedMiterLimit = ""),
          (this.currentMiterLimit = "");
      }
      (CVContextData.prototype.duplicate = function () {
        var tt = this._length * 2,
          et = 0;
        for (et = this._length; et < tt; et += 1)
          this.stack[et] = new CanvasContext();
        this._length = tt;
      }),
        (CVContextData.prototype.reset = function () {
          (this.cArrPos = 0),
            this.cTr.reset(),
            (this.stack[this.cArrPos].opacity = 1);
        }),
        (CVContextData.prototype.restore = function (tt) {
          this.cArrPos -= 1;
          var et = this.stack[this.cArrPos],
            nt = et.transform,
            rt,
            it = this.cTr.props;
          for (rt = 0; rt < 16; rt += 1) it[rt] = nt[rt];
          if (tt) {
            this.nativeContext.restore();
            var st = this.stack[this.cArrPos + 1];
            (this.appliedFillStyle = st.fillStyle),
              (this.appliedStrokeStyle = st.strokeStyle),
              (this.appliedLineWidth = st.lineWidth),
              (this.appliedLineCap = st.lineCap),
              (this.appliedLineJoin = st.lineJoin),
              (this.appliedMiterLimit = st.miterLimit);
          }
          this.nativeContext.setTransform(
            nt[0],
            nt[1],
            nt[4],
            nt[5],
            nt[12],
            nt[13]
          ),
            (tt || (et.opacity !== -1 && this.currentOpacity !== et.opacity)) &&
              ((this.nativeContext.globalAlpha = et.opacity),
              (this.currentOpacity = et.opacity)),
            (this.currentFillStyle = et.fillStyle),
            (this.currentStrokeStyle = et.strokeStyle),
            (this.currentLineWidth = et.lineWidth),
            (this.currentLineCap = et.lineCap),
            (this.currentLineJoin = et.lineJoin),
            (this.currentMiterLimit = et.miterLimit);
        }),
        (CVContextData.prototype.save = function (tt) {
          tt && this.nativeContext.save();
          var et = this.cTr.props;
          this._length <= this.cArrPos && this.duplicate();
          var nt = this.stack[this.cArrPos],
            rt;
          for (rt = 0; rt < 16; rt += 1) nt.transform[rt] = et[rt];
          this.cArrPos += 1;
          var it = this.stack[this.cArrPos];
          (it.opacity = nt.opacity),
            (it.fillStyle = nt.fillStyle),
            (it.strokeStyle = nt.strokeStyle),
            (it.lineWidth = nt.lineWidth),
            (it.lineCap = nt.lineCap),
            (it.lineJoin = nt.lineJoin),
            (it.miterLimit = nt.miterLimit);
        }),
        (CVContextData.prototype.setOpacity = function (tt) {
          this.stack[this.cArrPos].opacity = tt;
        }),
        (CVContextData.prototype.setContext = function (tt) {
          this.nativeContext = tt;
        }),
        (CVContextData.prototype.fillStyle = function (tt) {
          this.stack[this.cArrPos].fillStyle !== tt &&
            ((this.currentFillStyle = tt),
            (this.stack[this.cArrPos].fillStyle = tt));
        }),
        (CVContextData.prototype.strokeStyle = function (tt) {
          this.stack[this.cArrPos].strokeStyle !== tt &&
            ((this.currentStrokeStyle = tt),
            (this.stack[this.cArrPos].strokeStyle = tt));
        }),
        (CVContextData.prototype.lineWidth = function (tt) {
          this.stack[this.cArrPos].lineWidth !== tt &&
            ((this.currentLineWidth = tt),
            (this.stack[this.cArrPos].lineWidth = tt));
        }),
        (CVContextData.prototype.lineCap = function (tt) {
          this.stack[this.cArrPos].lineCap !== tt &&
            ((this.currentLineCap = tt),
            (this.stack[this.cArrPos].lineCap = tt));
        }),
        (CVContextData.prototype.lineJoin = function (tt) {
          this.stack[this.cArrPos].lineJoin !== tt &&
            ((this.currentLineJoin = tt),
            (this.stack[this.cArrPos].lineJoin = tt));
        }),
        (CVContextData.prototype.miterLimit = function (tt) {
          this.stack[this.cArrPos].miterLimit !== tt &&
            ((this.currentMiterLimit = tt),
            (this.stack[this.cArrPos].miterLimit = tt));
        }),
        (CVContextData.prototype.transform = function (tt) {
          this.transformMat.cloneFromProps(tt);
          var et = this.cTr;
          this.transformMat.multiply(et),
            et.cloneFromProps(this.transformMat.props);
          var nt = et.props;
          this.nativeContext.setTransform(
            nt[0],
            nt[1],
            nt[4],
            nt[5],
            nt[12],
            nt[13]
          );
        }),
        (CVContextData.prototype.opacity = function (tt) {
          var et = this.stack[this.cArrPos].opacity;
          (et *= tt < 0 ? 0 : tt),
            this.stack[this.cArrPos].opacity !== et &&
              (this.currentOpacity !== tt &&
                ((this.nativeContext.globalAlpha = tt),
                (this.currentOpacity = tt)),
              (this.stack[this.cArrPos].opacity = et));
        }),
        (CVContextData.prototype.fill = function (tt) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fill(tt);
        }),
        (CVContextData.prototype.fillRect = function (tt, et, nt, rt) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fillRect(tt, et, nt, rt);
        }),
        (CVContextData.prototype.stroke = function () {
          this.appliedStrokeStyle !== this.currentStrokeStyle &&
            ((this.appliedStrokeStyle = this.currentStrokeStyle),
            (this.nativeContext.strokeStyle = this.appliedStrokeStyle)),
            this.appliedLineWidth !== this.currentLineWidth &&
              ((this.appliedLineWidth = this.currentLineWidth),
              (this.nativeContext.lineWidth = this.appliedLineWidth)),
            this.appliedLineCap !== this.currentLineCap &&
              ((this.appliedLineCap = this.currentLineCap),
              (this.nativeContext.lineCap = this.appliedLineCap)),
            this.appliedLineJoin !== this.currentLineJoin &&
              ((this.appliedLineJoin = this.currentLineJoin),
              (this.nativeContext.lineJoin = this.appliedLineJoin)),
            this.appliedMiterLimit !== this.currentMiterLimit &&
              ((this.appliedMiterLimit = this.currentMiterLimit),
              (this.nativeContext.miterLimit = this.appliedMiterLimit)),
            this.nativeContext.stroke();
        });
      function CVCompElement(tt, et, nt) {
        (this.completeLayers = !1),
          (this.layers = tt.layers),
          (this.pendingElements = []),
          (this.elements = createSizedArray(this.layers.length)),
          this.initElement(tt, et, nt),
          (this.tm = tt.tm
            ? PropertyFactory.getProp(this, tt.tm, 0, et.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [CanvasRendererBase, ICompElement, CVBaseElement],
        CVCompElement
      ),
        (CVCompElement.prototype.renderInnerContent = function () {
          var tt = this.canvasContext;
          tt.beginPath(),
            tt.moveTo(0, 0),
            tt.lineTo(this.data.w, 0),
            tt.lineTo(this.data.w, this.data.h),
            tt.lineTo(0, this.data.h),
            tt.lineTo(0, 0),
            tt.clip();
          var et,
            nt = this.layers.length;
          for (et = nt - 1; et >= 0; et -= 1)
            (this.completeLayers || this.elements[et]) &&
              this.elements[et].renderFrame();
        }),
        (CVCompElement.prototype.destroy = function () {
          var tt,
            et = this.layers.length;
          for (tt = et - 1; tt >= 0; tt -= 1)
            this.elements[tt] && this.elements[tt].destroy();
          (this.layers = null), (this.elements = null);
        }),
        (CVCompElement.prototype.createComp = function (tt) {
          return new CVCompElement(tt, this.globalData, this);
        });
      function CanvasRenderer(tt, et) {
        (this.animationItem = tt),
          (this.renderConfig = {
            clearCanvas: et && et.clearCanvas !== void 0 ? et.clearCanvas : !0,
            context: (et && et.context) || null,
            progressiveLoad: (et && et.progressiveLoad) || !1,
            preserveAspectRatio:
              (et && et.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (et && et.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (et && et.contentVisibility) || "visible",
            className: (et && et.className) || "",
            id: (et && et.id) || "",
            runExpressions:
              !et || et.runExpressions === void 0 || et.runExpressions,
          }),
          (this.renderConfig.dpr = (et && et.dpr) || 1),
          this.animationItem.wrapper &&
            (this.renderConfig.dpr =
              (et && et.dpr) || window.devicePixelRatio || 1),
          (this.renderedFrame = -1),
          (this.globalData = {
            frameNum: -1,
            _mdf: !1,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1,
          }),
          (this.contextData = new CVContextData()),
          (this.elements = []),
          (this.pendingElements = []),
          (this.transformMat = new Matrix()),
          (this.completeLayers = !1),
          (this.rendererType = "canvas"),
          this.renderConfig.clearCanvas &&
            ((this.ctxTransform = this.contextData.transform.bind(
              this.contextData
            )),
            (this.ctxOpacity = this.contextData.opacity.bind(this.contextData)),
            (this.ctxFillStyle = this.contextData.fillStyle.bind(
              this.contextData
            )),
            (this.ctxStrokeStyle = this.contextData.strokeStyle.bind(
              this.contextData
            )),
            (this.ctxLineWidth = this.contextData.lineWidth.bind(
              this.contextData
            )),
            (this.ctxLineCap = this.contextData.lineCap.bind(this.contextData)),
            (this.ctxLineJoin = this.contextData.lineJoin.bind(
              this.contextData
            )),
            (this.ctxMiterLimit = this.contextData.miterLimit.bind(
              this.contextData
            )),
            (this.ctxFill = this.contextData.fill.bind(this.contextData)),
            (this.ctxFillRect = this.contextData.fillRect.bind(
              this.contextData
            )),
            (this.ctxStroke = this.contextData.stroke.bind(this.contextData)),
            (this.save = this.contextData.save.bind(this.contextData)));
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer),
        (CanvasRenderer.prototype.createComp = function (tt) {
          return new CVCompElement(tt, this.globalData, this);
        });
      function HBaseElement() {}
      (HBaseElement.prototype = {
        checkBlendMode: function () {},
        initRendererElement: function () {
          (this.baseElement = createTag(this.data.tg || "div")),
            this.data.hasMask
              ? ((this.svgElement = createNS("svg")),
                (this.layerElement = createNS("g")),
                (this.maskedElement = this.layerElement),
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement))
              : (this.layerElement = this.baseElement),
            styleDiv(this.baseElement);
        },
        createContainerElements: function () {
          (this.renderableEffectsManager = new CVEffects(this)),
            (this.transformedElement = this.baseElement),
            (this.maskedElement = this.layerElement),
            this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          var et = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var nt = this.finalTransform.mat.toCSS();
            (et.transform = nt), (et.webkitTransform = nt);
          }
          this.finalTransform._opMdf &&
            (et.opacity = this.finalTransform.mProp.o.v);
        },
        renderFrame: function () {
          this.data.hd ||
            this.hidden ||
            (this.renderTransform(),
            this.renderRenderable(),
            this.renderElement(),
            this.renderInnerContent(),
            this._isFirstFrame && (this._isFirstFrame = !1));
        },
        destroy: function () {
          (this.layerElement = null),
            (this.transformedElement = null),
            this.matteElement && (this.matteElement = null),
            this.maskManager &&
              (this.maskManager.destroy(), (this.maskManager = null));
        },
        createRenderableComponents: function () {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function () {},
        setMatte: function () {},
      }),
        (HBaseElement.prototype.getBaseElement =
          SVGBaseElement.prototype.getBaseElement),
        (HBaseElement.prototype.destroyBaseElement =
          HBaseElement.prototype.destroy),
        (HBaseElement.prototype.buildElementParenting =
          BaseRenderer.prototype.buildElementParenting);
      function HSolidElement(tt, et, nt) {
        this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        HSolidElement
      ),
        (HSolidElement.prototype.createContent = function () {
          var tt;
          this.data.hasMask
            ? ((tt = createNS("rect")),
              tt.setAttribute("width", this.data.sw),
              tt.setAttribute("height", this.data.sh),
              tt.setAttribute("fill", this.data.sc),
              this.svgElement.setAttribute("width", this.data.sw),
              this.svgElement.setAttribute("height", this.data.sh))
            : ((tt = createTag("div")),
              (tt.style.width = this.data.sw + "px"),
              (tt.style.height = this.data.sh + "px"),
              (tt.style.backgroundColor = this.data.sc)),
            this.layerElement.appendChild(tt);
        });
      function HShapeElement(tt, et, nt) {
        (this.shapes = []),
          (this.shapesData = tt.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          (this.shapesContainer = createNS("g")),
          this.initElement(tt, et, nt),
          (this.prevViewData = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HSolidElement,
          SVGShapeElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HShapeElement
      ),
        (HShapeElement.prototype._renderShapeFrame =
          HShapeElement.prototype.renderInnerContent),
        (HShapeElement.prototype.createContent = function () {
          var tt;
          if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
            this.layerElement.appendChild(this.shapesContainer),
              (tt = this.svgElement);
          else {
            tt = createNS("svg");
            var et = this.comp.data ? this.comp.data : this.globalData.compSize;
            tt.setAttribute("width", et.w),
              tt.setAttribute("height", et.h),
              tt.appendChild(this.shapesContainer),
              this.layerElement.appendChild(tt);
          }
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.shapesContainer,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes(),
            (this.shapeCont = tt);
        }),
        (HShapeElement.prototype.getTransformedPoint = function (tt, et) {
          var nt,
            rt = tt.length;
          for (nt = 0; nt < rt; nt += 1)
            et = tt[nt].mProps.v.applyToPointArray(et[0], et[1], 0);
          return et;
        }),
        (HShapeElement.prototype.calculateShapeBoundingBox = function (tt, et) {
          var nt = tt.sh.v,
            rt = tt.transformers,
            it,
            st = nt._length,
            ot,
            at,
            lt,
            ct;
          if (!(st <= 1)) {
            for (it = 0; it < st - 1; it += 1)
              (ot = this.getTransformedPoint(rt, nt.v[it])),
                (at = this.getTransformedPoint(rt, nt.o[it])),
                (lt = this.getTransformedPoint(rt, nt.i[it + 1])),
                (ct = this.getTransformedPoint(rt, nt.v[it + 1])),
                this.checkBounds(ot, at, lt, ct, et);
            nt.c &&
              ((ot = this.getTransformedPoint(rt, nt.v[it])),
              (at = this.getTransformedPoint(rt, nt.o[it])),
              (lt = this.getTransformedPoint(rt, nt.i[0])),
              (ct = this.getTransformedPoint(rt, nt.v[0])),
              this.checkBounds(ot, at, lt, ct, et));
          }
        }),
        (HShapeElement.prototype.checkBounds = function (tt, et, nt, rt, it) {
          this.getBoundsOfCurve(tt, et, nt, rt);
          var st = this.shapeBoundingBox;
          (it.x = bmMin(st.left, it.x)),
            (it.xMax = bmMax(st.right, it.xMax)),
            (it.y = bmMin(st.top, it.y)),
            (it.yMax = bmMax(st.bottom, it.yMax));
        }),
        (HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
        }),
        (HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0,
        }),
        (HShapeElement.prototype.getBoundsOfCurve = function (tt, et, nt, rt) {
          for (
            var it = [
                [tt[0], rt[0]],
                [tt[1], rt[1]],
              ],
              st,
              ot,
              at,
              lt,
              ct,
              ut,
              ft,
              ht = 0;
            ht < 2;
            ++ht
          )
            (ot = 6 * tt[ht] - 12 * et[ht] + 6 * nt[ht]),
              (st = -3 * tt[ht] + 9 * et[ht] - 9 * nt[ht] + 3 * rt[ht]),
              (at = 3 * et[ht] - 3 * tt[ht]),
              (ot |= 0),
              (st |= 0),
              (at |= 0),
              (st === 0 && ot === 0) ||
                (st === 0
                  ? ((lt = -at / ot),
                    lt > 0 &&
                      lt < 1 &&
                      it[ht].push(this.calculateF(lt, tt, et, nt, rt, ht)))
                  : ((ct = ot * ot - 4 * at * st),
                    ct >= 0 &&
                      ((ut = (-ot + bmSqrt(ct)) / (2 * st)),
                      ut > 0 &&
                        ut < 1 &&
                        it[ht].push(this.calculateF(ut, tt, et, nt, rt, ht)),
                      (ft = (-ot - bmSqrt(ct)) / (2 * st)),
                      ft > 0 &&
                        ft < 1 &&
                        it[ht].push(this.calculateF(ft, tt, et, nt, rt, ht)))));
          (this.shapeBoundingBox.left = bmMin.apply(null, it[0])),
            (this.shapeBoundingBox.top = bmMin.apply(null, it[1])),
            (this.shapeBoundingBox.right = bmMax.apply(null, it[0])),
            (this.shapeBoundingBox.bottom = bmMax.apply(null, it[1]));
        }),
        (HShapeElement.prototype.calculateF = function (
          tt,
          et,
          nt,
          rt,
          it,
          st
        ) {
          return (
            bmPow(1 - tt, 3) * et[st] +
            3 * bmPow(1 - tt, 2) * tt * nt[st] +
            3 * (1 - tt) * bmPow(tt, 2) * rt[st] +
            bmPow(tt, 3) * it[st]
          );
        }),
        (HShapeElement.prototype.calculateBoundingBox = function (tt, et) {
          var nt,
            rt = tt.length;
          for (nt = 0; nt < rt; nt += 1)
            tt[nt] && tt[nt].sh
              ? this.calculateShapeBoundingBox(tt[nt], et)
              : tt[nt] && tt[nt].it
              ? this.calculateBoundingBox(tt[nt].it, et)
              : tt[nt] &&
                tt[nt].style &&
                tt[nt].w &&
                this.expandStrokeBoundingBox(tt[nt].w, et);
        }),
        (HShapeElement.prototype.expandStrokeBoundingBox = function (tt, et) {
          var nt = 0;
          if (tt.keyframes) {
            for (var rt = 0; rt < tt.keyframes.length; rt += 1) {
              var it = tt.keyframes[rt].s;
              it > nt && (nt = it);
            }
            nt *= tt.mult;
          } else nt = tt.v * tt.mult;
          (et.x -= nt), (et.xMax += nt), (et.y -= nt), (et.yMax += nt);
        }),
        (HShapeElement.prototype.currentBoxContains = function (tt) {
          return (
            this.currentBBox.x <= tt.x &&
            this.currentBBox.y <= tt.y &&
            this.currentBBox.width + this.currentBBox.x >= tt.x + tt.width &&
            this.currentBBox.height + this.currentBBox.y >= tt.y + tt.height
          );
        }),
        (HShapeElement.prototype.renderInnerContent = function () {
          if (
            (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf))
          ) {
            var tt = this.tempBoundingBox,
              et = 999999;
            if (
              ((tt.x = et),
              (tt.xMax = -et),
              (tt.y = et),
              (tt.yMax = -et),
              this.calculateBoundingBox(this.itemsData, tt),
              (tt.width = tt.xMax < tt.x ? 0 : tt.xMax - tt.x),
              (tt.height = tt.yMax < tt.y ? 0 : tt.yMax - tt.y),
              this.currentBoxContains(tt))
            )
              return;
            var nt = !1;
            if (
              (this.currentBBox.w !== tt.width &&
                ((this.currentBBox.w = tt.width),
                this.shapeCont.setAttribute("width", tt.width),
                (nt = !0)),
              this.currentBBox.h !== tt.height &&
                ((this.currentBBox.h = tt.height),
                this.shapeCont.setAttribute("height", tt.height),
                (nt = !0)),
              nt || this.currentBBox.x !== tt.x || this.currentBBox.y !== tt.y)
            ) {
              (this.currentBBox.w = tt.width),
                (this.currentBBox.h = tt.height),
                (this.currentBBox.x = tt.x),
                (this.currentBBox.y = tt.y),
                this.shapeCont.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                );
              var rt = this.shapeCont.style,
                it =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
              (rt.transform = it), (rt.webkitTransform = it);
            }
          }
        });
      function HTextElement(tt, et, nt) {
        (this.textSpans = []),
          (this.textPaths = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }),
          (this.renderType = "svg"),
          (this.isMasked = !1),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        HTextElement
      ),
        (HTextElement.prototype.createContent = function () {
          if (((this.isMasked = this.checkMasks()), this.isMasked)) {
            (this.renderType = "svg"),
              (this.compW = this.comp.data.w),
              (this.compH = this.comp.data.h),
              this.svgElement.setAttribute("width", this.compW),
              this.svgElement.setAttribute("height", this.compH);
            var tt = createNS("g");
            this.maskedElement.appendChild(tt), (this.innerElem = tt);
          } else
            (this.renderType = "html"), (this.innerElem = this.layerElement);
          this.checkParenting();
        }),
        (HTextElement.prototype.buildNewText = function () {
          var tt = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(tt.l ? tt.l.length : 0);
          var et = this.innerElem.style,
            nt = tt.fc ? this.buildColor(tt.fc) : "rgba(0,0,0,0)";
          (et.fill = nt),
            (et.color = nt),
            tt.sc &&
              ((et.stroke = this.buildColor(tt.sc)),
              (et.strokeWidth = tt.sw + "px"));
          var rt = this.globalData.fontManager.getFontByName(tt.f);
          if (!this.globalData.fontManager.chars)
            if (
              ((et.fontSize = tt.finalSize + "px"),
              (et.lineHeight = tt.finalSize + "px"),
              rt.fClass)
            )
              this.innerElem.className = rt.fClass;
            else {
              et.fontFamily = rt.fFamily;
              var it = tt.fWeight,
                st = tt.fStyle;
              (et.fontStyle = st), (et.fontWeight = it);
            }
          var ot,
            at,
            lt = tt.l;
          at = lt.length;
          var ct,
            ut,
            ft,
            ht = this.mHelper,
            mt,
            vt = "",
            yt = 0;
          for (ot = 0; ot < at; ot += 1) {
            if (
              (this.globalData.fontManager.chars
                ? (this.textPaths[yt]
                    ? (ct = this.textPaths[yt])
                    : ((ct = createNS("path")),
                      ct.setAttribute("stroke-linecap", lineCapEnum[1]),
                      ct.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                      ct.setAttribute("stroke-miterlimit", "4")),
                  this.isMasked ||
                    (this.textSpans[yt]
                      ? ((ut = this.textSpans[yt]), (ft = ut.children[0]))
                      : ((ut = createTag("div")),
                        (ut.style.lineHeight = 0),
                        (ft = createNS("svg")),
                        ft.appendChild(ct),
                        styleDiv(ut))))
                : this.isMasked
                ? (ct = this.textPaths[yt]
                    ? this.textPaths[yt]
                    : createNS("text"))
                : this.textSpans[yt]
                ? ((ut = this.textSpans[yt]), (ct = this.textPaths[yt]))
                : ((ut = createTag("span")),
                  styleDiv(ut),
                  (ct = createTag("span")),
                  styleDiv(ct),
                  ut.appendChild(ct)),
              this.globalData.fontManager.chars)
            ) {
              var Et = this.globalData.fontManager.getCharData(
                  tt.finalText[ot],
                  rt.fStyle,
                  this.globalData.fontManager.getFontByName(tt.f).fFamily
                ),
                pt;
              if (
                (Et ? (pt = Et.data) : (pt = null),
                ht.reset(),
                pt &&
                  pt.shapes &&
                  pt.shapes.length &&
                  ((mt = pt.shapes[0].it),
                  ht.scale(tt.finalSize / 100, tt.finalSize / 100),
                  (vt = this.createPathShape(ht, mt)),
                  ct.setAttribute("d", vt)),
                this.isMasked)
              )
                this.innerElem.appendChild(ct);
              else {
                if ((this.innerElem.appendChild(ut), pt && pt.shapes)) {
                  document.body.appendChild(ft);
                  var xt = ft.getBBox();
                  ft.setAttribute("width", xt.width + 2),
                    ft.setAttribute("height", xt.height + 2),
                    ft.setAttribute(
                      "viewBox",
                      xt.x -
                        1 +
                        " " +
                        (xt.y - 1) +
                        " " +
                        (xt.width + 2) +
                        " " +
                        (xt.height + 2)
                    );
                  var St = ft.style,
                    At = "translate(" + (xt.x - 1) + "px," + (xt.y - 1) + "px)";
                  (St.transform = At),
                    (St.webkitTransform = At),
                    (lt[ot].yOffset = xt.y - 1);
                } else
                  ft.setAttribute("width", 1), ft.setAttribute("height", 1);
                ut.appendChild(ft);
              }
            } else if (
              ((ct.textContent = lt[ot].val),
              ct.setAttributeNS(
                "http://www.w3.org/XML/1998/namespace",
                "xml:space",
                "preserve"
              ),
              this.isMasked)
            )
              this.innerElem.appendChild(ct);
            else {
              this.innerElem.appendChild(ut);
              var Ct = ct.style,
                Mt = "translate3d(0," + -tt.finalSize / 1.2 + "px,0)";
              (Ct.transform = Mt), (Ct.webkitTransform = Mt);
            }
            this.isMasked
              ? (this.textSpans[yt] = ct)
              : (this.textSpans[yt] = ut),
              (this.textSpans[yt].style.display = "block"),
              (this.textPaths[yt] = ct),
              (yt += 1);
          }
          for (; yt < this.textSpans.length; )
            (this.textSpans[yt].style.display = "none"), (yt += 1);
        }),
        (HTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var tt;
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute(
                "viewBox",
                -this.finalTransform.mProp.p.v[0] +
                  " " +
                  -this.finalTransform.mProp.p.v[1] +
                  " " +
                  this.compW +
                  " " +
                  this.compH
              ),
                (tt = this.svgElement.style);
              var et =
                "translate(" +
                -this.finalTransform.mProp.p.v[0] +
                "px," +
                -this.finalTransform.mProp.p.v[1] +
                "px)";
              (tt.transform = et), (tt.webkitTransform = et);
            }
          }
          if (
            (this.textAnimator.getMeasures(
              this.textProperty.currentData,
              this.lettersChangedFlag
            ),
            !(
              !this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag
            ))
          ) {
            var nt,
              rt,
              it = 0,
              st = this.textAnimator.renderedLetters,
              ot = this.textProperty.currentData.l;
            rt = ot.length;
            var at, lt, ct;
            for (nt = 0; nt < rt; nt += 1)
              ot[nt].n
                ? (it += 1)
                : ((lt = this.textSpans[nt]),
                  (ct = this.textPaths[nt]),
                  (at = st[it]),
                  (it += 1),
                  at._mdf.m &&
                    (this.isMasked
                      ? lt.setAttribute("transform", at.m)
                      : ((lt.style.webkitTransform = at.m),
                        (lt.style.transform = at.m))),
                  (lt.style.opacity = at.o),
                  at.sw && at._mdf.sw && ct.setAttribute("stroke-width", at.sw),
                  at.sc && at._mdf.sc && ct.setAttribute("stroke", at.sc),
                  at.fc &&
                    at._mdf.fc &&
                    (ct.setAttribute("fill", at.fc), (ct.style.color = at.fc)));
            if (
              this.innerElem.getBBox &&
              !this.hidden &&
              (this._isFirstFrame || this._mdf)
            ) {
              var ut = this.innerElem.getBBox();
              this.currentBBox.w !== ut.width &&
                ((this.currentBBox.w = ut.width),
                this.svgElement.setAttribute("width", ut.width)),
                this.currentBBox.h !== ut.height &&
                  ((this.currentBBox.h = ut.height),
                  this.svgElement.setAttribute("height", ut.height));
              var ft = 1;
              if (
                this.currentBBox.w !== ut.width + ft * 2 ||
                this.currentBBox.h !== ut.height + ft * 2 ||
                this.currentBBox.x !== ut.x - ft ||
                this.currentBBox.y !== ut.y - ft
              ) {
                (this.currentBBox.w = ut.width + ft * 2),
                  (this.currentBBox.h = ut.height + ft * 2),
                  (this.currentBBox.x = ut.x - ft),
                  (this.currentBBox.y = ut.y - ft),
                  this.svgElement.setAttribute(
                    "viewBox",
                    this.currentBBox.x +
                      " " +
                      this.currentBBox.y +
                      " " +
                      this.currentBBox.w +
                      " " +
                      this.currentBBox.h
                  ),
                  (tt = this.svgElement.style);
                var ht =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
                (tt.transform = ht), (tt.webkitTransform = ht);
              }
            }
          }
        });
      function HCameraElement(tt, et, nt) {
        this.initFrame(), this.initBaseData(tt, et, nt), this.initHierarchy();
        var rt = PropertyFactory.getProp;
        if (
          ((this.pe = rt(this, tt.pe, 0, 0, this)),
          tt.ks.p.s
            ? ((this.px = rt(this, tt.ks.p.x, 1, 0, this)),
              (this.py = rt(this, tt.ks.p.y, 1, 0, this)),
              (this.pz = rt(this, tt.ks.p.z, 1, 0, this)))
            : (this.p = rt(this, tt.ks.p, 1, 0, this)),
          tt.ks.a && (this.a = rt(this, tt.ks.a, 1, 0, this)),
          tt.ks.or.k.length && tt.ks.or.k[0].to)
        ) {
          var it,
            st = tt.ks.or.k.length;
          for (it = 0; it < st; it += 1)
            (tt.ks.or.k[it].to = null), (tt.ks.or.k[it].ti = null);
        }
        (this.or = rt(this, tt.ks.or, 1, degToRads, this)),
          (this.or.sh = !0),
          (this.rx = rt(this, tt.ks.rx, 0, degToRads, this)),
          (this.ry = rt(this, tt.ks.ry, 0, degToRads, this)),
          (this.rz = rt(this, tt.ks.rz, 0, degToRads, this)),
          (this.mat = new Matrix()),
          (this._prevMat = new Matrix()),
          (this._isFirstFrame = !0),
          (this.finalTransform = { mProp: this });
      }
      extendPrototype(
        [BaseElement, FrameElement, HierarchyElement],
        HCameraElement
      ),
        (HCameraElement.prototype.setup = function () {
          var tt,
            et = this.comp.threeDElements.length,
            nt,
            rt,
            it;
          for (tt = 0; tt < et; tt += 1)
            if (((nt = this.comp.threeDElements[tt]), nt.type === "3d")) {
              (rt = nt.perspectiveElem.style), (it = nt.container.style);
              var st = this.pe.v + "px",
                ot = "0px 0px 0px",
                at = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              (rt.perspective = st),
                (rt.webkitPerspective = st),
                (it.transformOrigin = ot),
                (it.mozTransformOrigin = ot),
                (it.webkitTransformOrigin = ot),
                (rt.transform = at),
                (rt.webkitTransform = at);
            }
        }),
        (HCameraElement.prototype.createElements = function () {}),
        (HCameraElement.prototype.hide = function () {}),
        (HCameraElement.prototype.renderFrame = function () {
          var tt = this._isFirstFrame,
            et,
            nt;
          if (this.hierarchy)
            for (nt = this.hierarchy.length, et = 0; et < nt; et += 1)
              tt = this.hierarchy[et].finalTransform.mProp._mdf || tt;
          if (
            tt ||
            this.pe._mdf ||
            (this.p && this.p._mdf) ||
            (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
            this.rx._mdf ||
            this.ry._mdf ||
            this.rz._mdf ||
            this.or._mdf ||
            (this.a && this.a._mdf)
          ) {
            if ((this.mat.reset(), this.hierarchy))
              for (nt = this.hierarchy.length - 1, et = nt; et >= 0; et -= 1) {
                var rt = this.hierarchy[et].finalTransform.mProp;
                this.mat.translate(-rt.p.v[0], -rt.p.v[1], rt.p.v[2]),
                  this.mat
                    .rotateX(-rt.or.v[0])
                    .rotateY(-rt.or.v[1])
                    .rotateZ(rt.or.v[2]),
                  this.mat.rotateX(-rt.rx.v).rotateY(-rt.ry.v).rotateZ(rt.rz.v),
                  this.mat.scale(1 / rt.s.v[0], 1 / rt.s.v[1], 1 / rt.s.v[2]),
                  this.mat.translate(rt.a.v[0], rt.a.v[1], rt.a.v[2]);
              }
            if (
              (this.p
                ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
                : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
              this.a)
            ) {
              var it;
              this.p
                ? (it = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2],
                  ])
                : (it = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2],
                  ]);
              var st = Math.sqrt(
                  Math.pow(it[0], 2) + Math.pow(it[1], 2) + Math.pow(it[2], 2)
                ),
                ot = [it[0] / st, it[1] / st, it[2] / st],
                at = Math.sqrt(ot[2] * ot[2] + ot[0] * ot[0]),
                lt = Math.atan2(ot[1], at),
                ct = Math.atan2(ot[0], -ot[2]);
              this.mat.rotateY(ct).rotateX(-lt);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
              this.mat
                .rotateX(-this.or.v[0])
                .rotateY(-this.or.v[1])
                .rotateZ(this.or.v[2]),
              this.mat.translate(
                this.globalData.compSize.w / 2,
                this.globalData.compSize.h / 2,
                0
              ),
              this.mat.translate(0, 0, this.pe.v);
            var ut = !this._prevMat.equals(this.mat);
            if ((ut || this.pe._mdf) && this.comp.threeDElements) {
              nt = this.comp.threeDElements.length;
              var ft, ht, mt;
              for (et = 0; et < nt; et += 1)
                if (((ft = this.comp.threeDElements[et]), ft.type === "3d")) {
                  if (ut) {
                    var vt = this.mat.toCSS();
                    (mt = ft.container.style),
                      (mt.transform = vt),
                      (mt.webkitTransform = vt);
                  }
                  this.pe._mdf &&
                    ((ht = ft.perspectiveElem.style),
                    (ht.perspective = this.pe.v + "px"),
                    (ht.webkitPerspective = this.pe.v + "px"));
                }
              this.mat.clone(this._prevMat);
            }
          }
          this._isFirstFrame = !1;
        }),
        (HCameraElement.prototype.prepareFrame = function (tt) {
          this.prepareProperties(tt, !0);
        }),
        (HCameraElement.prototype.destroy = function () {}),
        (HCameraElement.prototype.getBaseElement = function () {
          return null;
        });
      function HImageElement(tt, et, nt) {
        (this.assetData = et.getAssetData(tt.refId)),
          this.initElement(tt, et, nt);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HSolidElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HImageElement
      ),
        (HImageElement.prototype.createContent = function () {
          var tt = this.globalData.getAssetsPath(this.assetData),
            et = new Image();
          this.data.hasMask
            ? ((this.imageElem = createNS("image")),
              this.imageElem.setAttribute("width", this.assetData.w + "px"),
              this.imageElem.setAttribute("height", this.assetData.h + "px"),
              this.imageElem.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                "href",
                tt
              ),
              this.layerElement.appendChild(this.imageElem),
              this.baseElement.setAttribute("width", this.assetData.w),
              this.baseElement.setAttribute("height", this.assetData.h))
            : this.layerElement.appendChild(et),
            (et.crossOrigin = "anonymous"),
            (et.src = tt),
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
        });
      function HybridRendererBase(tt, et) {
        (this.animationItem = tt),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (et && et.className) || "",
            imagePreserveAspectRatio:
              (et && et.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(et && et.hideOnTransparent === !1),
            filterSize: {
              width: (et && et.filterSize && et.filterSize.width) || "400%",
              height: (et && et.filterSize && et.filterSize.height) || "400%",
              x: (et && et.filterSize && et.filterSize.x) || "-100%",
              y: (et && et.filterSize && et.filterSize.y) || "-100%",
            },
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([BaseRenderer], HybridRendererBase),
        (HybridRendererBase.prototype.buildItem =
          SVGRenderer.prototype.buildItem),
        (HybridRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var tt = this.pendingElements.pop();
            tt.checkParenting();
          }
        }),
        (HybridRendererBase.prototype.appendElementInPos = function (tt, et) {
          var nt = tt.getBaseElement();
          if (nt) {
            var rt = this.layers[et];
            if (!rt.ddd || !this.supports3d)
              if (this.threeDElements) this.addTo3dContainer(nt, et);
              else {
                for (var it = 0, st, ot, at; it < et; )
                  this.elements[it] &&
                    this.elements[it] !== !0 &&
                    this.elements[it].getBaseElement &&
                    ((ot = this.elements[it]),
                    (at = this.layers[it].ddd
                      ? this.getThreeDContainerByPos(it)
                      : ot.getBaseElement()),
                    (st = at || st)),
                    (it += 1);
                st
                  ? (!rt.ddd || !this.supports3d) &&
                    this.layerElement.insertBefore(nt, st)
                  : (!rt.ddd || !this.supports3d) &&
                    this.layerElement.appendChild(nt);
              }
            else this.addTo3dContainer(nt, et);
          }
        }),
        (HybridRendererBase.prototype.createShape = function (tt) {
          return this.supports3d
            ? new HShapeElement(tt, this.globalData, this)
            : new SVGShapeElement(tt, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createText = function (tt) {
          return this.supports3d
            ? new HTextElement(tt, this.globalData, this)
            : new SVGTextLottieElement(tt, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createCamera = function (tt) {
          return (
            (this.camera = new HCameraElement(tt, this.globalData, this)),
            this.camera
          );
        }),
        (HybridRendererBase.prototype.createImage = function (tt) {
          return this.supports3d
            ? new HImageElement(tt, this.globalData, this)
            : new IImageElement(tt, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createSolid = function (tt) {
          return this.supports3d
            ? new HSolidElement(tt, this.globalData, this)
            : new ISolidElement(tt, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (HybridRendererBase.prototype.getThreeDContainerByPos = function (tt) {
          for (var et = 0, nt = this.threeDElements.length; et < nt; ) {
            if (
              this.threeDElements[et].startPos <= tt &&
              this.threeDElements[et].endPos >= tt
            )
              return this.threeDElements[et].perspectiveElem;
            et += 1;
          }
          return null;
        }),
        (HybridRendererBase.prototype.createThreeDContainer = function (
          tt,
          et
        ) {
          var nt = createTag("div"),
            rt,
            it;
          styleDiv(nt);
          var st = createTag("div");
          if ((styleDiv(st), et === "3d")) {
            (rt = nt.style),
              (rt.width = this.globalData.compSize.w + "px"),
              (rt.height = this.globalData.compSize.h + "px");
            var ot = "50% 50%";
            (rt.webkitTransformOrigin = ot),
              (rt.mozTransformOrigin = ot),
              (rt.transformOrigin = ot),
              (it = st.style);
            var at = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            (it.transform = at), (it.webkitTransform = at);
          }
          nt.appendChild(st);
          var lt = {
            container: st,
            perspectiveElem: nt,
            startPos: tt,
            endPos: tt,
            type: et,
          };
          return this.threeDElements.push(lt), lt;
        }),
        (HybridRendererBase.prototype.build3dContainers = function () {
          var tt,
            et = this.layers.length,
            nt,
            rt = "";
          for (tt = 0; tt < et; tt += 1)
            this.layers[tt].ddd && this.layers[tt].ty !== 3
              ? (rt !== "3d" &&
                  ((rt = "3d"), (nt = this.createThreeDContainer(tt, "3d"))),
                (nt.endPos = Math.max(nt.endPos, tt)))
              : (rt !== "2d" &&
                  ((rt = "2d"), (nt = this.createThreeDContainer(tt, "2d"))),
                (nt.endPos = Math.max(nt.endPos, tt)));
          for (et = this.threeDElements.length, tt = et - 1; tt >= 0; tt -= 1)
            this.resizerElem.appendChild(
              this.threeDElements[tt].perspectiveElem
            );
        }),
        (HybridRendererBase.prototype.addTo3dContainer = function (tt, et) {
          for (var nt = 0, rt = this.threeDElements.length; nt < rt; ) {
            if (et <= this.threeDElements[nt].endPos) {
              for (var it = this.threeDElements[nt].startPos, st; it < et; )
                this.elements[it] &&
                  this.elements[it].getBaseElement &&
                  (st = this.elements[it].getBaseElement()),
                  (it += 1);
              st
                ? this.threeDElements[nt].container.insertBefore(tt, st)
                : this.threeDElements[nt].container.appendChild(tt);
              break;
            }
            nt += 1;
          }
        }),
        (HybridRendererBase.prototype.configAnimation = function (tt) {
          var et = createTag("div"),
            nt = this.animationItem.wrapper,
            rt = et.style;
          (rt.width = tt.w + "px"),
            (rt.height = tt.h + "px"),
            (this.resizerElem = et),
            styleDiv(et),
            (rt.transformStyle = "flat"),
            (rt.mozTransformStyle = "flat"),
            (rt.webkitTransformStyle = "flat"),
            this.renderConfig.className &&
              et.setAttribute("class", this.renderConfig.className),
            nt.appendChild(et),
            (rt.overflow = "hidden");
          var it = createNS("svg");
          it.setAttribute("width", "1"),
            it.setAttribute("height", "1"),
            styleDiv(it),
            this.resizerElem.appendChild(it);
          var st = createNS("defs");
          it.appendChild(st),
            (this.data = tt),
            this.setupGlobalData(tt, it),
            (this.globalData.defs = st),
            (this.layers = tt.layers),
            (this.layerElement = this.resizerElem),
            this.build3dContainers(),
            this.updateContainerSize();
        }),
        (HybridRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.animationItem.container = null),
            (this.globalData.defs = null);
          var tt,
            et = this.layers ? this.layers.length : 0;
          for (tt = 0; tt < et; tt += 1)
            this.elements[tt] &&
              this.elements[tt].destroy &&
              this.elements[tt].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (HybridRendererBase.prototype.updateContainerSize = function () {
          var tt = this.animationItem.wrapper.offsetWidth,
            et = this.animationItem.wrapper.offsetHeight,
            nt = tt / et,
            rt = this.globalData.compSize.w / this.globalData.compSize.h,
            it,
            st,
            ot,
            at;
          rt > nt
            ? ((it = tt / this.globalData.compSize.w),
              (st = tt / this.globalData.compSize.w),
              (ot = 0),
              (at =
                (et -
                  this.globalData.compSize.h *
                    (tt / this.globalData.compSize.w)) /
                2))
            : ((it = et / this.globalData.compSize.h),
              (st = et / this.globalData.compSize.h),
              (ot =
                (tt -
                  this.globalData.compSize.w *
                    (et / this.globalData.compSize.h)) /
                2),
              (at = 0));
          var lt = this.resizerElem.style;
          (lt.webkitTransform =
            "matrix3d(" +
            it +
            ",0,0,0,0," +
            st +
            ",0,0,0,0,1,0," +
            ot +
            "," +
            at +
            ",0,1)"),
            (lt.transform = lt.webkitTransform);
        }),
        (HybridRendererBase.prototype.renderFrame =
          SVGRenderer.prototype.renderFrame),
        (HybridRendererBase.prototype.hide = function () {
          this.resizerElem.style.display = "none";
        }),
        (HybridRendererBase.prototype.show = function () {
          this.resizerElem.style.display = "block";
        }),
        (HybridRendererBase.prototype.initItems = function () {
          if ((this.buildAllItems(), this.camera)) this.camera.setup();
          else {
            var tt = this.globalData.compSize.w,
              et = this.globalData.compSize.h,
              nt,
              rt = this.threeDElements.length;
            for (nt = 0; nt < rt; nt += 1) {
              var it = this.threeDElements[nt].perspectiveElem.style;
              (it.webkitPerspective =
                Math.sqrt(Math.pow(tt, 2) + Math.pow(et, 2)) + "px"),
                (it.perspective = it.webkitPerspective);
            }
          }
        }),
        (HybridRendererBase.prototype.searchExtraCompositions = function (tt) {
          var et,
            nt = tt.length,
            rt = createTag("div");
          for (et = 0; et < nt; et += 1)
            if (tt[et].xt) {
              var it = this.createComp(tt[et], rt, this.globalData.comp, null);
              it.initExpressions(),
                this.globalData.projectInterface.registerComposition(it);
            }
        });
      function HCompElement(tt, et, nt) {
        (this.layers = tt.layers),
          (this.supports3d = !tt.hasMask),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(tt, et, nt),
          (this.tm = tt.tm
            ? PropertyFactory.getProp(this, tt.tm, 0, et.frameRate, this)
            : { _placeholder: !0 });
      }
      extendPrototype(
        [HybridRendererBase, ICompElement, HBaseElement],
        HCompElement
      ),
        (HCompElement.prototype._createBaseContainerElements =
          HCompElement.prototype.createContainerElements),
        (HCompElement.prototype.createContainerElements = function () {
          this._createBaseContainerElements(),
            this.data.hasMask
              ? (this.svgElement.setAttribute("width", this.data.w),
                this.svgElement.setAttribute("height", this.data.h),
                (this.transformedElement = this.baseElement))
              : (this.transformedElement = this.layerElement);
        }),
        (HCompElement.prototype.addTo3dContainer = function (tt, et) {
          for (var nt = 0, rt; nt < et; )
            this.elements[nt] &&
              this.elements[nt].getBaseElement &&
              (rt = this.elements[nt].getBaseElement()),
              (nt += 1);
          rt
            ? this.layerElement.insertBefore(tt, rt)
            : this.layerElement.appendChild(tt);
        }),
        (HCompElement.prototype.createComp = function (tt) {
          return this.supports3d
            ? new HCompElement(tt, this.globalData, this)
            : new SVGCompElement(tt, this.globalData, this);
        });
      function HybridRenderer(tt, et) {
        (this.animationItem = tt),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (et && et.className) || "",
            imagePreserveAspectRatio:
              (et && et.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(et && et.hideOnTransparent === !1),
            filterSize: {
              width: (et && et.filterSize && et.filterSize.width) || "400%",
              height: (et && et.filterSize && et.filterSize.height) || "400%",
              x: (et && et.filterSize && et.filterSize.x) || "-100%",
              y: (et && et.filterSize && et.filterSize.y) || "-100%",
            },
            runExpressions:
              !et || et.runExpressions === void 0 || et.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([HybridRendererBase], HybridRenderer),
        (HybridRenderer.prototype.createComp = function (tt) {
          return this.supports3d
            ? new HCompElement(tt, this.globalData, this)
            : new SVGCompElement(tt, this.globalData, this);
        });
      var CompExpressionInterface = (function () {
        return function (tt) {
          function et(nt) {
            for (var rt = 0, it = tt.layers.length; rt < it; ) {
              if (tt.layers[rt].nm === nt || tt.layers[rt].ind === nt)
                return tt.elements[rt].layerInterface;
              rt += 1;
            }
            return null;
          }
          return (
            Object.defineProperty(et, "_name", { value: tt.data.nm }),
            (et.layer = et),
            (et.pixelAspect = 1),
            (et.height = tt.data.h || tt.globalData.compSize.h),
            (et.width = tt.data.w || tt.globalData.compSize.w),
            (et.pixelAspect = 1),
            (et.frameDuration = 1 / tt.globalData.frameRate),
            (et.displayStartTime = 0),
            (et.numLayers = tt.layers.length),
            et
          );
        };
      })();
      function _typeof$2(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$2 = function (nt) {
                return typeof nt;
              })
            : (_typeof$2 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$2(tt)
        );
      }
      function seedRandom(tt, et) {
        var nt = this,
          rt = 256,
          it = 6,
          st = 52,
          ot = "random",
          at = et.pow(rt, it),
          lt = et.pow(2, st),
          ct = lt * 2,
          ut = rt - 1,
          ft;
        function ht(St, At, Ct) {
          var Mt = [];
          At = At === !0 ? { entropy: !0 } : At || {};
          var wt = Et(
              yt(At.entropy ? [St, xt(tt)] : St === null ? pt() : St, 3),
              Mt
            ),
            Bt = new mt(Mt),
            It = function () {
              for (var Vt = Bt.g(it), $t = at, Kt = 0; Vt < lt; )
                (Vt = (Vt + Kt) * rt), ($t *= rt), (Kt = Bt.g(1));
              for (; Vt >= ct; ) (Vt /= 2), ($t /= 2), (Kt >>>= 1);
              return (Vt + Kt) / $t;
            };
          return (
            (It.int32 = function () {
              return Bt.g(4) | 0;
            }),
            (It.quick = function () {
              return Bt.g(4) / 4294967296;
            }),
            (It.double = It),
            Et(xt(Bt.S), tt),
            (
              At.pass ||
              Ct ||
              function (Ft, Vt, $t, Kt) {
                return (
                  Kt &&
                    (Kt.S && vt(Kt, Bt),
                    (Ft.state = function () {
                      return vt(Bt, {});
                    })),
                  $t ? ((et[ot] = Ft), Vt) : Ft
                );
              }
            )(It, wt, "global" in At ? At.global : this == et, At.state)
          );
        }
        et["seed" + ot] = ht;
        function mt(St) {
          var At,
            Ct = St.length,
            Mt = this,
            wt = 0,
            Bt = (Mt.i = Mt.j = 0),
            It = (Mt.S = []);
          for (Ct || (St = [Ct++]); wt < rt; ) It[wt] = wt++;
          for (wt = 0; wt < rt; wt++)
            (It[wt] = It[(Bt = ut & (Bt + St[wt % Ct] + (At = It[wt])))]),
              (It[Bt] = At);
          Mt.g = function (Ft) {
            for (var Vt, $t = 0, Kt = Mt.i, Ht = Mt.j, Wt = Mt.S; Ft--; )
              (Vt = Wt[(Kt = ut & (Kt + 1))]),
                ($t =
                  $t * rt +
                  Wt[
                    ut & ((Wt[Kt] = Wt[(Ht = ut & (Ht + Vt))]) + (Wt[Ht] = Vt))
                  ]);
            return (Mt.i = Kt), (Mt.j = Ht), $t;
          };
        }
        function vt(St, At) {
          return (At.i = St.i), (At.j = St.j), (At.S = St.S.slice()), At;
        }
        function yt(St, At) {
          var Ct = [],
            Mt = _typeof$2(St),
            wt;
          if (At && Mt == "object")
            for (wt in St)
              try {
                Ct.push(yt(St[wt], At - 1));
              } catch {}
          return Ct.length ? Ct : Mt == "string" ? St : St + "\0";
        }
        function Et(St, At) {
          for (var Ct = St + "", Mt, wt = 0; wt < Ct.length; )
            At[ut & wt] = ut & ((Mt ^= At[ut & wt] * 19) + Ct.charCodeAt(wt++));
          return xt(At);
        }
        function pt() {
          try {
            var St = new Uint8Array(rt);
            return (nt.crypto || nt.msCrypto).getRandomValues(St), xt(St);
          } catch {
            var At = nt.navigator,
              Ct = At && At.plugins;
            return [+new Date(), nt, Ct, nt.screen, xt(tt)];
          }
        }
        function xt(St) {
          return String.fromCharCode.apply(0, St);
        }
        Et(et.random(), tt);
      }
      function initialize$2(tt) {
        seedRandom([], tt);
      }
      var propTypes = { SHAPE: "shape" };
      function _typeof$1(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$1 = function (nt) {
                return typeof nt;
              })
            : (_typeof$1 = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof$1(tt)
        );
      }
      var ExpressionManager = (function () {
          var ob = {},
            Math = BMMath,
            window = null,
            document = null,
            XMLHttpRequest = null,
            fetch = null,
            frames = null,
            _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
            _lottieGlobal = {};
          }
          function $bm_isInstanceOfArray(tt) {
            return tt.constructor === Array || tt.constructor === Float32Array;
          }
          function isNumerable(tt, et) {
            return (
              tt === "number" ||
              et instanceof Number ||
              tt === "boolean" ||
              tt === "string"
            );
          }
          function $bm_neg(tt) {
            var et = _typeof$1(tt);
            if (et === "number" || tt instanceof Number || et === "boolean")
              return -tt;
            if ($bm_isInstanceOfArray(tt)) {
              var nt,
                rt = tt.length,
                it = [];
              for (nt = 0; nt < rt; nt += 1) it[nt] = -tt[nt];
              return it;
            }
            return tt.propType ? tt.v : -tt;
          }
          var easeInBez = BezierFactory.getBezierEasing(
              0.333,
              0,
              0.833,
              0.833,
              "easeIn"
            ).get,
            easeOutBez = BezierFactory.getBezierEasing(
              0.167,
              0.167,
              0.667,
              1,
              "easeOut"
            ).get,
            easeInOutBez = BezierFactory.getBezierEasing(
              0.33,
              0,
              0.667,
              1,
              "easeInOut"
            ).get;
          function sum(tt, et) {
            var nt = _typeof$1(tt),
              rt = _typeof$1(et);
            if (
              (isNumerable(nt, tt) && isNumerable(rt, et)) ||
              nt === "string" ||
              rt === "string"
            )
              return tt + et;
            if ($bm_isInstanceOfArray(tt) && isNumerable(rt, et))
              return (tt = tt.slice(0)), (tt[0] += et), tt;
            if (isNumerable(nt, tt) && $bm_isInstanceOfArray(et))
              return (et = et.slice(0)), (et[0] = tt + et[0]), et;
            if ($bm_isInstanceOfArray(tt) && $bm_isInstanceOfArray(et)) {
              for (
                var it = 0, st = tt.length, ot = et.length, at = [];
                it < st || it < ot;

              )
                (typeof tt[it] == "number" || tt[it] instanceof Number) &&
                (typeof et[it] == "number" || et[it] instanceof Number)
                  ? (at[it] = tt[it] + et[it])
                  : (at[it] = et[it] === void 0 ? tt[it] : tt[it] || et[it]),
                  (it += 1);
              return at;
            }
            return 0;
          }
          var add = sum;
          function sub(tt, et) {
            var nt = _typeof$1(tt),
              rt = _typeof$1(et);
            if (isNumerable(nt, tt) && isNumerable(rt, et))
              return (
                nt === "string" && (tt = parseInt(tt, 10)),
                rt === "string" && (et = parseInt(et, 10)),
                tt - et
              );
            if ($bm_isInstanceOfArray(tt) && isNumerable(rt, et))
              return (tt = tt.slice(0)), (tt[0] -= et), tt;
            if (isNumerable(nt, tt) && $bm_isInstanceOfArray(et))
              return (et = et.slice(0)), (et[0] = tt - et[0]), et;
            if ($bm_isInstanceOfArray(tt) && $bm_isInstanceOfArray(et)) {
              for (
                var it = 0, st = tt.length, ot = et.length, at = [];
                it < st || it < ot;

              )
                (typeof tt[it] == "number" || tt[it] instanceof Number) &&
                (typeof et[it] == "number" || et[it] instanceof Number)
                  ? (at[it] = tt[it] - et[it])
                  : (at[it] = et[it] === void 0 ? tt[it] : tt[it] || et[it]),
                  (it += 1);
              return at;
            }
            return 0;
          }
          function mul(tt, et) {
            var nt = _typeof$1(tt),
              rt = _typeof$1(et),
              it;
            if (isNumerable(nt, tt) && isNumerable(rt, et)) return tt * et;
            var st, ot;
            if ($bm_isInstanceOfArray(tt) && isNumerable(rt, et)) {
              for (
                ot = tt.length, it = createTypedArray("float32", ot), st = 0;
                st < ot;
                st += 1
              )
                it[st] = tt[st] * et;
              return it;
            }
            if (isNumerable(nt, tt) && $bm_isInstanceOfArray(et)) {
              for (
                ot = et.length, it = createTypedArray("float32", ot), st = 0;
                st < ot;
                st += 1
              )
                it[st] = tt * et[st];
              return it;
            }
            return 0;
          }
          function div(tt, et) {
            var nt = _typeof$1(tt),
              rt = _typeof$1(et),
              it;
            if (isNumerable(nt, tt) && isNumerable(rt, et)) return tt / et;
            var st, ot;
            if ($bm_isInstanceOfArray(tt) && isNumerable(rt, et)) {
              for (
                ot = tt.length, it = createTypedArray("float32", ot), st = 0;
                st < ot;
                st += 1
              )
                it[st] = tt[st] / et;
              return it;
            }
            if (isNumerable(nt, tt) && $bm_isInstanceOfArray(et)) {
              for (
                ot = et.length, it = createTypedArray("float32", ot), st = 0;
                st < ot;
                st += 1
              )
                it[st] = tt / et[st];
              return it;
            }
            return 0;
          }
          function mod(tt, et) {
            return (
              typeof tt == "string" && (tt = parseInt(tt, 10)),
              typeof et == "string" && (et = parseInt(et, 10)),
              tt % et
            );
          }
          var $bm_sum = sum,
            $bm_sub = sub,
            $bm_mul = mul,
            $bm_div = div,
            $bm_mod = mod;
          function clamp(tt, et, nt) {
            if (et > nt) {
              var rt = nt;
              (nt = et), (et = rt);
            }
            return Math.min(Math.max(tt, et), nt);
          }
          function radiansToDegrees(tt) {
            return tt / degToRads;
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(tt) {
            return tt * degToRads;
          }
          var degrees_to_radians = radiansToDegrees,
            helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(tt, et) {
            if (typeof tt == "number" || tt instanceof Number)
              return (et = et || 0), Math.abs(tt - et);
            et || (et = helperLengthArray);
            var nt,
              rt = Math.min(tt.length, et.length),
              it = 0;
            for (nt = 0; nt < rt; nt += 1) it += Math.pow(et[nt] - tt[nt], 2);
            return Math.sqrt(it);
          }
          function normalize(tt) {
            return div(tt, length(tt));
          }
          function rgbToHsl(tt) {
            var et = tt[0],
              nt = tt[1],
              rt = tt[2],
              it = Math.max(et, nt, rt),
              st = Math.min(et, nt, rt),
              ot,
              at,
              lt = (it + st) / 2;
            if (it === st) (ot = 0), (at = 0);
            else {
              var ct = it - st;
              switch (
                ((at = lt > 0.5 ? ct / (2 - it - st) : ct / (it + st)), it)
              ) {
                case et:
                  ot = (nt - rt) / ct + (nt < rt ? 6 : 0);
                  break;
                case nt:
                  ot = (rt - et) / ct + 2;
                  break;
                case rt:
                  ot = (et - nt) / ct + 4;
                  break;
              }
              ot /= 6;
            }
            return [ot, at, lt, tt[3]];
          }
          function hue2rgb(tt, et, nt) {
            return (
              nt < 0 && (nt += 1),
              nt > 1 && (nt -= 1),
              nt < 1 / 6
                ? tt + (et - tt) * 6 * nt
                : nt < 1 / 2
                ? et
                : nt < 2 / 3
                ? tt + (et - tt) * (2 / 3 - nt) * 6
                : tt
            );
          }
          function hslToRgb(tt) {
            var et = tt[0],
              nt = tt[1],
              rt = tt[2],
              it,
              st,
              ot;
            if (nt === 0) (it = rt), (ot = rt), (st = rt);
            else {
              var at = rt < 0.5 ? rt * (1 + nt) : rt + nt - rt * nt,
                lt = 2 * rt - at;
              (it = hue2rgb(lt, at, et + 1 / 3)),
                (st = hue2rgb(lt, at, et)),
                (ot = hue2rgb(lt, at, et - 1 / 3));
            }
            return [it, st, ot, tt[3]];
          }
          function linear(tt, et, nt, rt, it) {
            if (
              ((rt === void 0 || it === void 0) &&
                ((rt = et), (it = nt), (et = 0), (nt = 1)),
              nt < et)
            ) {
              var st = nt;
              (nt = et), (et = st);
            }
            if (tt <= et) return rt;
            if (tt >= nt) return it;
            var ot = nt === et ? 0 : (tt - et) / (nt - et);
            if (!rt.length) return rt + (it - rt) * ot;
            var at,
              lt = rt.length,
              ct = createTypedArray("float32", lt);
            for (at = 0; at < lt; at += 1)
              ct[at] = rt[at] + (it[at] - rt[at]) * ot;
            return ct;
          }
          function random(tt, et) {
            if (
              (et === void 0 &&
                (tt === void 0
                  ? ((tt = 0), (et = 1))
                  : ((et = tt), (tt = void 0))),
              et.length)
            ) {
              var nt,
                rt = et.length;
              tt || (tt = createTypedArray("float32", rt));
              var it = createTypedArray("float32", rt),
                st = BMMath.random();
              for (nt = 0; nt < rt; nt += 1)
                it[nt] = tt[nt] + st * (et[nt] - tt[nt]);
              return it;
            }
            tt === void 0 && (tt = 0);
            var ot = BMMath.random();
            return tt + ot * (et - tt);
          }
          function createPath(tt, et, nt, rt) {
            var it,
              st = tt.length,
              ot = shapePool.newElement();
            ot.setPathData(!!rt, st);
            var at = [0, 0],
              lt,
              ct;
            for (it = 0; it < st; it += 1)
              (lt = et && et[it] ? et[it] : at),
                (ct = nt && nt[it] ? nt[it] : at),
                ot.setTripleAt(
                  tt[it][0],
                  tt[it][1],
                  ct[0] + tt[it][0],
                  ct[1] + tt[it][1],
                  lt[0] + tt[it][0],
                  lt[1] + tt[it][1],
                  it,
                  !0
                );
            return ot;
          }
          function initiateExpression(elem, data, property) {
            function noOp(tt) {
              return tt;
            }
            if (!elem.globalData.renderConfig.runExpressions) return noOp;
            var val = data.x,
              needsVelocity = /velocity(?![\w\d])/.test(val),
              _needsRandom = val.indexOf("random") !== -1,
              elemType = elem.data.ty,
              transform,
              $bm_transform,
              content,
              effect,
              thisProperty = property;
            (thisProperty.valueAtTime = thisProperty.getValueAtTime),
              Object.defineProperty(thisProperty, "value", {
                get: function () {
                  return thisProperty.v;
                },
              }),
              (elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate),
              (elem.comp.displayStartTime = 0);
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
              outPoint = elem.data.op / elem.comp.globalData.frameRate,
              width = elem.data.sw ? elem.data.sw : 0,
              height = elem.data.sh ? elem.data.sh : 0,
              name = elem.data.nm,
              loopIn,
              loop_in,
              loopOut,
              loop_out,
              smooth,
              toWorld,
              fromWorld,
              fromComp,
              toComp,
              fromCompToSurface,
              position,
              rotation,
              anchorPoint,
              scale,
              thisLayer,
              thisComp,
              mask,
              valueAtTime,
              velocityAtTime,
              scoped_bm_rt,
              expression_function = eval(
                "[function _expression_function(){" +
                  val +
                  ";scoped_bm_rt=$bm_rt}]"
              )[0],
              numKeys = property.kf ? data.k.length : 0,
              active = !this.data || this.data.hd !== !0,
              wiggle = function tt(et, nt) {
                var rt,
                  it,
                  st = this.pv.length ? this.pv.length : 1,
                  ot = createTypedArray("float32", st);
                et = 5;
                var at = Math.floor(time * et);
                for (rt = 0, it = 0; rt < at; ) {
                  for (it = 0; it < st; it += 1)
                    ot[it] += -nt + nt * 2 * BMMath.random();
                  rt += 1;
                }
                var lt = time * et,
                  ct = lt - Math.floor(lt),
                  ut = createTypedArray("float32", st);
                if (st > 1) {
                  for (it = 0; it < st; it += 1)
                    ut[it] =
                      this.pv[it] +
                      ot[it] +
                      (-nt + nt * 2 * BMMath.random()) * ct;
                  return ut;
                }
                return this.pv + ot[0] + (-nt + nt * 2 * BMMath.random()) * ct;
              }.bind(this);
            thisProperty.loopIn &&
              ((loopIn = thisProperty.loopIn.bind(thisProperty)),
              (loop_in = loopIn)),
              thisProperty.loopOut &&
                ((loopOut = thisProperty.loopOut.bind(thisProperty)),
                (loop_out = loopOut)),
              thisProperty.smooth &&
                (smooth = thisProperty.smooth.bind(thisProperty));
            function loopInDuration(tt, et) {
              return loopIn(tt, et, !0);
            }
            function loopOutDuration(tt, et) {
              return loopOut(tt, et, !0);
            }
            this.getValueAtTime &&
              (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime &&
                (velocityAtTime = this.getVelocityAtTime.bind(this));
            var comp = elem.comp.globalData.projectInterface.bind(
              elem.comp.globalData.projectInterface
            );
            function lookAt(tt, et) {
              var nt = [et[0] - tt[0], et[1] - tt[1], et[2] - tt[2]],
                rt =
                  Math.atan2(nt[0], Math.sqrt(nt[1] * nt[1] + nt[2] * nt[2])) /
                  degToRads,
                it = -Math.atan2(nt[1], nt[2]) / degToRads;
              return [it, rt, 0];
            }
            function easeOut(tt, et, nt, rt, it) {
              return applyEase(easeOutBez, tt, et, nt, rt, it);
            }
            function easeIn(tt, et, nt, rt, it) {
              return applyEase(easeInBez, tt, et, nt, rt, it);
            }
            function ease(tt, et, nt, rt, it) {
              return applyEase(easeInOutBez, tt, et, nt, rt, it);
            }
            function applyEase(tt, et, nt, rt, it, st) {
              it === void 0
                ? ((it = nt), (st = rt))
                : (et = (et - nt) / (rt - nt)),
                et > 1 ? (et = 1) : et < 0 && (et = 0);
              var ot = tt(et);
              if ($bm_isInstanceOfArray(it)) {
                var at,
                  lt = it.length,
                  ct = createTypedArray("float32", lt);
                for (at = 0; at < lt; at += 1)
                  ct[at] = (st[at] - it[at]) * ot + it[at];
                return ct;
              }
              return (st - it) * ot + it;
            }
            function nearestKey(tt) {
              var et,
                nt = data.k.length,
                rt,
                it;
              if (!data.k.length || typeof data.k[0] == "number")
                (rt = 0), (it = 0);
              else if (
                ((rt = -1),
                (tt *= elem.comp.globalData.frameRate),
                tt < data.k[0].t)
              )
                (rt = 1), (it = data.k[0].t);
              else {
                for (et = 0; et < nt - 1; et += 1)
                  if (tt === data.k[et].t) {
                    (rt = et + 1), (it = data.k[et].t);
                    break;
                  } else if (tt > data.k[et].t && tt < data.k[et + 1].t) {
                    tt - data.k[et].t > data.k[et + 1].t - tt
                      ? ((rt = et + 2), (it = data.k[et + 1].t))
                      : ((rt = et + 1), (it = data.k[et].t));
                    break;
                  }
                rt === -1 && ((rt = et + 1), (it = data.k[et].t));
              }
              var st = {};
              return (
                (st.index = rt),
                (st.time = it / elem.comp.globalData.frameRate),
                st
              );
            }
            function key(tt) {
              var et, nt, rt;
              if (!data.k.length || typeof data.k[0] == "number")
                throw new Error("The property has no keyframe at index " + tt);
              (tt -= 1),
                (et = {
                  time: data.k[tt].t / elem.comp.globalData.frameRate,
                  value: [],
                });
              var it = Object.prototype.hasOwnProperty.call(data.k[tt], "s")
                ? data.k[tt].s
                : data.k[tt - 1].e;
              for (rt = it.length, nt = 0; nt < rt; nt += 1)
                (et[nt] = it[nt]), (et.value[nt] = it[nt]);
              return et;
            }
            function framesToTime(tt, et) {
              return et || (et = elem.comp.globalData.frameRate), tt / et;
            }
            function timeToFrames(tt, et) {
              return (
                !tt && tt !== 0 && (tt = time),
                et || (et = elem.comp.globalData.frameRate),
                tt * et
              );
            }
            function seedRandom(tt) {
              BMMath.seedrandom(randSeed + tt);
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime();
            }
            function substring(tt, et) {
              return typeof value == "string"
                ? et === void 0
                  ? value.substring(tt)
                  : value.substring(tt, et)
                : "";
            }
            function substr(tt, et) {
              return typeof value == "string"
                ? et === void 0
                  ? value.substr(tt)
                  : value.substr(tt, et)
                : "";
            }
            function posterizeTime(tt) {
              (time = tt === 0 ? 0 : Math.floor(time * tt) / tt),
                (value = valueAtTime(time));
            }
            var time,
              velocity,
              value,
              text,
              textIndex,
              textTotal,
              selectorValue,
              index = elem.data.ind,
              hasParent = !!(elem.hierarchy && elem.hierarchy.length),
              parent,
              randSeed = Math.floor(Math.random() * 1e6),
              globalData = elem.globalData;
            function executeExpression(tt) {
              return (
                (value = tt),
                this.frameExpressionId === elem.globalData.frameId &&
                this.propType !== "textSelector"
                  ? value
                  : (this.propType === "textSelector" &&
                      ((textIndex = this.textIndex),
                      (textTotal = this.textTotal),
                      (selectorValue = this.selectorValue)),
                    thisLayer ||
                      ((text = elem.layerInterface.text),
                      (thisLayer = elem.layerInterface),
                      (thisComp = elem.comp.compInterface),
                      (toWorld = thisLayer.toWorld.bind(thisLayer)),
                      (fromWorld = thisLayer.fromWorld.bind(thisLayer)),
                      (fromComp = thisLayer.fromComp.bind(thisLayer)),
                      (toComp = thisLayer.toComp.bind(thisLayer)),
                      (mask = thisLayer.mask
                        ? thisLayer.mask.bind(thisLayer)
                        : null),
                      (fromCompToSurface = fromComp)),
                    transform ||
                      ((transform = elem.layerInterface(
                        "ADBE Transform Group"
                      )),
                      ($bm_transform = transform),
                      transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 &&
                      !content &&
                      (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    (hasParent = !!(elem.hierarchy && elem.hierarchy.length)),
                    hasParent &&
                      !parent &&
                      (parent = elem.hierarchy[0].layerInterface),
                    (time =
                      this.comp.renderedFrame / this.comp.globalData.frameRate),
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    (this.frameExpressionId = elem.globalData.frameId),
                    (scoped_bm_rt =
                      scoped_bm_rt.propType === propTypes.SHAPE
                        ? scoped_bm_rt.v
                        : scoped_bm_rt),
                    scoped_bm_rt)
              );
            }
            return (
              (executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData,
              ]),
              executeExpression
            );
          }
          return (
            (ob.initiateExpression = initiateExpression),
            (ob.__preventDeadCodeRemoval = [
              window,
              document,
              XMLHttpRequest,
              fetch,
              frames,
              $bm_neg,
              add,
              $bm_sum,
              $bm_sub,
              $bm_mul,
              $bm_div,
              $bm_mod,
              clamp,
              radians_to_degrees,
              degreesToRadians,
              degrees_to_radians,
              normalize,
              rgbToHsl,
              hslToRgb,
              linear,
              random,
              createPath,
              _lottieGlobal,
            ]),
            (ob.resetFrame = resetFrame),
            ob
          );
        })(),
        Expressions = (function () {
          var tt = {};
          (tt.initExpressions = et),
            (tt.resetFrame = ExpressionManager.resetFrame);
          function et(nt) {
            var rt = 0,
              it = [];
            function st() {
              rt += 1;
            }
            function ot() {
              (rt -= 1), rt === 0 && lt();
            }
            function at(ct) {
              it.indexOf(ct) === -1 && it.push(ct);
            }
            function lt() {
              var ct,
                ut = it.length;
              for (ct = 0; ct < ut; ct += 1) it[ct].release();
              it.length = 0;
            }
            (nt.renderer.compInterface = CompExpressionInterface(nt.renderer)),
              nt.renderer.globalData.projectInterface.registerComposition(
                nt.renderer
              ),
              (nt.renderer.globalData.pushExpression = st),
              (nt.renderer.globalData.popExpression = ot),
              (nt.renderer.globalData.registerExpressionProperty = at);
          }
          return tt;
        })(),
        MaskManagerInterface = (function () {
          function tt(nt, rt) {
            (this._mask = nt), (this._data = rt);
          }
          Object.defineProperty(tt.prototype, "maskPath", {
            get: function () {
              return (
                this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
              );
            },
          }),
            Object.defineProperty(tt.prototype, "maskOpacity", {
              get: function () {
                return (
                  this._mask.op.k && this._mask.op.getValue(),
                  this._mask.op.v * 100
                );
              },
            });
          var et = function (rt) {
            var it = createSizedArray(rt.viewData.length),
              st,
              ot = rt.viewData.length;
            for (st = 0; st < ot; st += 1)
              it[st] = new tt(rt.viewData[st], rt.masksProperties[st]);
            var at = function (ct) {
              for (st = 0; st < ot; ) {
                if (rt.masksProperties[st].nm === ct) return it[st];
                st += 1;
              }
              return null;
            };
            return at;
          };
          return et;
        })(),
        ExpressionPropertyInterface = (function () {
          var tt = { pv: 0, v: 0, mult: 1 },
            et = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };
          function nt(ot, at, lt) {
            Object.defineProperty(ot, "velocity", {
              get: function () {
                return at.getVelocityAtTime(at.comp.currentFrame);
              },
            }),
              (ot.numKeys = at.keyframes ? at.keyframes.length : 0),
              (ot.key = function (ct) {
                if (!ot.numKeys) return 0;
                var ut = "";
                "s" in at.keyframes[ct - 1]
                  ? (ut = at.keyframes[ct - 1].s)
                  : "e" in at.keyframes[ct - 2]
                  ? (ut = at.keyframes[ct - 2].e)
                  : (ut = at.keyframes[ct - 2].s);
                var ft =
                  lt === "unidimensional"
                    ? new Number(ut)
                    : Object.assign({}, ut);
                return (
                  (ft.time =
                    at.keyframes[ct - 1].t / at.elem.comp.globalData.frameRate),
                  (ft.value = lt === "unidimensional" ? ut[0] : ut),
                  ft
                );
              }),
              (ot.valueAtTime = at.getValueAtTime),
              (ot.speedAtTime = at.getSpeedAtTime),
              (ot.velocityAtTime = at.getVelocityAtTime),
              (ot.propertyGroup = at.propertyGroup);
          }
          function rt(ot) {
            (!ot || !("pv" in ot)) && (ot = tt);
            var at = 1 / ot.mult,
              lt = ot.pv * at,
              ct = new Number(lt);
            return (
              (ct.value = lt),
              nt(ct, ot, "unidimensional"),
              function () {
                return (
                  ot.k && ot.getValue(),
                  (lt = ot.v * at),
                  ct.value !== lt &&
                    ((ct = new Number(lt)),
                    (ct.value = lt),
                    nt(ct, ot, "unidimensional")),
                  ct
                );
              }
            );
          }
          function it(ot) {
            (!ot || !("pv" in ot)) && (ot = et);
            var at = 1 / ot.mult,
              lt = (ot.data && ot.data.l) || ot.pv.length,
              ct = createTypedArray("float32", lt),
              ut = createTypedArray("float32", lt);
            return (
              (ct.value = ut),
              nt(ct, ot, "multidimensional"),
              function () {
                ot.k && ot.getValue();
                for (var ft = 0; ft < lt; ft += 1)
                  (ut[ft] = ot.v[ft] * at), (ct[ft] = ut[ft]);
                return ct;
              }
            );
          }
          function st() {
            return tt;
          }
          return function (ot) {
            return ot
              ? ot.propType === "unidimensional"
                ? rt(ot)
                : it(ot)
              : st;
          };
        })(),
        TransformExpressionInterface = (function () {
          return function (tt) {
            function et(ot) {
              switch (ot) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return et.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return et.rotation;
                case "ADBE Rotate X":
                  return et.xRotation;
                case "ADBE Rotate Y":
                  return et.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return et.position;
                case "ADBE Position_0":
                  return et.xPosition;
                case "ADBE Position_1":
                  return et.yPosition;
                case "ADBE Position_2":
                  return et.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return et.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return et.opacity;
                default:
                  return null;
              }
            }
            Object.defineProperty(et, "rotation", {
              get: ExpressionPropertyInterface(tt.r || tt.rz),
            }),
              Object.defineProperty(et, "zRotation", {
                get: ExpressionPropertyInterface(tt.rz || tt.r),
              }),
              Object.defineProperty(et, "xRotation", {
                get: ExpressionPropertyInterface(tt.rx),
              }),
              Object.defineProperty(et, "yRotation", {
                get: ExpressionPropertyInterface(tt.ry),
              }),
              Object.defineProperty(et, "scale", {
                get: ExpressionPropertyInterface(tt.s),
              });
            var nt, rt, it, st;
            return (
              tt.p
                ? (st = ExpressionPropertyInterface(tt.p))
                : ((nt = ExpressionPropertyInterface(tt.px)),
                  (rt = ExpressionPropertyInterface(tt.py)),
                  tt.pz && (it = ExpressionPropertyInterface(tt.pz))),
              Object.defineProperty(et, "position", {
                get: function () {
                  return tt.p ? st() : [nt(), rt(), it ? it() : 0];
                },
              }),
              Object.defineProperty(et, "xPosition", {
                get: ExpressionPropertyInterface(tt.px),
              }),
              Object.defineProperty(et, "yPosition", {
                get: ExpressionPropertyInterface(tt.py),
              }),
              Object.defineProperty(et, "zPosition", {
                get: ExpressionPropertyInterface(tt.pz),
              }),
              Object.defineProperty(et, "anchorPoint", {
                get: ExpressionPropertyInterface(tt.a),
              }),
              Object.defineProperty(et, "opacity", {
                get: ExpressionPropertyInterface(tt.o),
              }),
              Object.defineProperty(et, "skew", {
                get: ExpressionPropertyInterface(tt.sk),
              }),
              Object.defineProperty(et, "skewAxis", {
                get: ExpressionPropertyInterface(tt.sa),
              }),
              Object.defineProperty(et, "orientation", {
                get: ExpressionPropertyInterface(tt.or),
              }),
              et
            );
          };
        })(),
        LayerExpressionInterface = (function () {
          function tt(ct) {
            var ut = new Matrix();
            if (ct !== void 0) {
              var ft = this._elem.finalTransform.mProp.getValueAtTime(ct);
              ft.clone(ut);
            } else {
              var ht = this._elem.finalTransform.mProp;
              ht.applyToMatrix(ut);
            }
            return ut;
          }
          function et(ct, ut) {
            var ft = this.getMatrix(ut);
            return (
              (ft.props[12] = 0),
              (ft.props[13] = 0),
              (ft.props[14] = 0),
              this.applyPoint(ft, ct)
            );
          }
          function nt(ct, ut) {
            var ft = this.getMatrix(ut);
            return this.applyPoint(ft, ct);
          }
          function rt(ct, ut) {
            var ft = this.getMatrix(ut);
            return (
              (ft.props[12] = 0),
              (ft.props[13] = 0),
              (ft.props[14] = 0),
              this.invertPoint(ft, ct)
            );
          }
          function it(ct, ut) {
            var ft = this.getMatrix(ut);
            return this.invertPoint(ft, ct);
          }
          function st(ct, ut) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var ft,
                ht = this._elem.hierarchy.length;
              for (ft = 0; ft < ht; ft += 1)
                this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(ct);
            }
            return ct.applyToPointArray(ut[0], ut[1], ut[2] || 0);
          }
          function ot(ct, ut) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var ft,
                ht = this._elem.hierarchy.length;
              for (ft = 0; ft < ht; ft += 1)
                this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(ct);
            }
            return ct.inversePoint(ut);
          }
          function at(ct) {
            var ut = new Matrix();
            if (
              (ut.reset(),
              this._elem.finalTransform.mProp.applyToMatrix(ut),
              this._elem.hierarchy && this._elem.hierarchy.length)
            ) {
              var ft,
                ht = this._elem.hierarchy.length;
              for (ft = 0; ft < ht; ft += 1)
                this._elem.hierarchy[ft].finalTransform.mProp.applyToMatrix(ut);
              return ut.inversePoint(ct);
            }
            return ut.inversePoint(ct);
          }
          function lt() {
            return [1, 1, 1, 1];
          }
          return function (ct) {
            var ut;
            function ft(yt) {
              mt.mask = new MaskManagerInterface(yt, ct);
            }
            function ht(yt) {
              mt.effect = yt;
            }
            function mt(yt) {
              switch (yt) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return mt.shapeInterface;
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return ut;
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return mt.effect;
                case "ADBE Text Properties":
                  return mt.textInterface;
                default:
                  return null;
              }
            }
            (mt.getMatrix = tt),
              (mt.invertPoint = ot),
              (mt.applyPoint = st),
              (mt.toWorld = nt),
              (mt.toWorldVec = et),
              (mt.fromWorld = it),
              (mt.fromWorldVec = rt),
              (mt.toComp = nt),
              (mt.fromComp = at),
              (mt.sampleImage = lt),
              (mt.sourceRectAtTime = ct.sourceRectAtTime.bind(ct)),
              (mt._elem = ct),
              (ut = TransformExpressionInterface(ct.finalTransform.mProp));
            var vt = getDescriptor(ut, "anchorPoint");
            return (
              Object.defineProperties(mt, {
                hasParent: {
                  get: function () {
                    return ct.hierarchy.length;
                  },
                },
                parent: {
                  get: function () {
                    return ct.hierarchy[0].layerInterface;
                  },
                },
                rotation: getDescriptor(ut, "rotation"),
                scale: getDescriptor(ut, "scale"),
                position: getDescriptor(ut, "position"),
                opacity: getDescriptor(ut, "opacity"),
                anchorPoint: vt,
                anchor_point: vt,
                transform: {
                  get: function () {
                    return ut;
                  },
                },
                active: {
                  get: function () {
                    return ct.isInRange;
                  },
                },
              }),
              (mt.startTime = ct.data.st),
              (mt.index = ct.data.ind),
              (mt.source = ct.data.refId),
              (mt.height = ct.data.ty === 0 ? ct.data.h : 100),
              (mt.width = ct.data.ty === 0 ? ct.data.w : 100),
              (mt.inPoint = ct.data.ip / ct.comp.globalData.frameRate),
              (mt.outPoint = ct.data.op / ct.comp.globalData.frameRate),
              (mt._name = ct.data.nm),
              (mt.registerMaskInterface = ft),
              (mt.registerEffectsInterface = ht),
              mt
            );
          };
        })(),
        propertyGroupFactory = (function () {
          return function (tt, et) {
            return function (nt) {
              return (nt = nt === void 0 ? 1 : nt), nt <= 0 ? tt : et(nt - 1);
            };
          };
        })(),
        PropertyInterface = (function () {
          return function (tt, et) {
            var nt = { _name: tt };
            function rt(it) {
              return (it = it === void 0 ? 1 : it), it <= 0 ? nt : et(it - 1);
            }
            return rt;
          };
        })(),
        EffectsExpressionInterface = (function () {
          var tt = { createEffectsInterface: et };
          function et(it, st) {
            if (it.effectsManager) {
              var ot = [],
                at = it.data.ef,
                lt,
                ct = it.effectsManager.effectElements.length;
              for (lt = 0; lt < ct; lt += 1)
                ot.push(
                  nt(at[lt], it.effectsManager.effectElements[lt], st, it)
                );
              var ut = it.data.ef || [],
                ft = function (mt) {
                  for (lt = 0, ct = ut.length; lt < ct; ) {
                    if (
                      mt === ut[lt].nm ||
                      mt === ut[lt].mn ||
                      mt === ut[lt].ix
                    )
                      return ot[lt];
                    lt += 1;
                  }
                  return null;
                };
              return (
                Object.defineProperty(ft, "numProperties", {
                  get: function () {
                    return ut.length;
                  },
                }),
                ft
              );
            }
            return null;
          }
          function nt(it, st, ot, at) {
            function lt(mt) {
              for (var vt = it.ef, yt = 0, Et = vt.length; yt < Et; ) {
                if (mt === vt[yt].nm || mt === vt[yt].mn || mt === vt[yt].ix)
                  return vt[yt].ty === 5 ? ut[yt] : ut[yt]();
                yt += 1;
              }
              throw new Error();
            }
            var ct = propertyGroupFactory(lt, ot),
              ut = [],
              ft,
              ht = it.ef.length;
            for (ft = 0; ft < ht; ft += 1)
              it.ef[ft].ty === 5
                ? ut.push(
                    nt(
                      it.ef[ft],
                      st.effectElements[ft],
                      st.effectElements[ft].propertyGroup,
                      at
                    )
                  )
                : ut.push(rt(st.effectElements[ft], it.ef[ft].ty, at, ct));
            return (
              it.mn === "ADBE Color Control" &&
                Object.defineProperty(lt, "color", {
                  get: function () {
                    return ut[0]();
                  },
                }),
              Object.defineProperties(lt, {
                numProperties: {
                  get: function () {
                    return it.np;
                  },
                },
                _name: { value: it.nm },
                propertyGroup: { value: ct },
              }),
              (lt.enabled = it.en !== 0),
              (lt.active = lt.enabled),
              lt
            );
          }
          function rt(it, st, ot, at) {
            var lt = ExpressionPropertyInterface(it.p);
            function ct() {
              return st === 10 ? ot.comp.compInterface(it.p.v) : lt();
            }
            return (
              it.p.setGroupProperty &&
                it.p.setGroupProperty(PropertyInterface("", at)),
              ct
            );
          }
          return tt;
        })(),
        ShapePathInterface = (function () {
          return function (et, nt, rt) {
            var it = nt.sh;
            function st(at) {
              return at === "Shape" ||
                at === "shape" ||
                at === "Path" ||
                at === "path" ||
                at === "ADBE Vector Shape" ||
                at === 2
                ? st.path
                : null;
            }
            var ot = propertyGroupFactory(st, rt);
            return (
              it.setGroupProperty(PropertyInterface("Path", ot)),
              Object.defineProperties(st, {
                path: {
                  get: function () {
                    return it.k && it.getValue(), it;
                  },
                },
                shape: {
                  get: function () {
                    return it.k && it.getValue(), it;
                  },
                },
                _name: { value: et.nm },
                ix: { value: et.ix },
                propertyIndex: { value: et.ix },
                mn: { value: et.mn },
                propertyGroup: { value: rt },
              }),
              st
            );
          };
        })(),
        ShapeExpressionInterface = (function () {
          function tt(vt, yt, Et) {
            var pt = [],
              xt,
              St = vt ? vt.length : 0;
            for (xt = 0; xt < St; xt += 1)
              vt[xt].ty === "gr"
                ? pt.push(nt(vt[xt], yt[xt], Et))
                : vt[xt].ty === "fl"
                ? pt.push(rt(vt[xt], yt[xt], Et))
                : vt[xt].ty === "st"
                ? pt.push(ot(vt[xt], yt[xt], Et))
                : vt[xt].ty === "tm"
                ? pt.push(at(vt[xt], yt[xt], Et))
                : vt[xt].ty === "tr" ||
                  (vt[xt].ty === "el"
                    ? pt.push(ct(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "sr"
                    ? pt.push(ut(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "sh"
                    ? pt.push(ShapePathInterface(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "rc"
                    ? pt.push(ft(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "rd"
                    ? pt.push(ht(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "rp"
                    ? pt.push(mt(vt[xt], yt[xt], Et))
                    : vt[xt].ty === "gf"
                    ? pt.push(it(vt[xt], yt[xt], Et))
                    : pt.push(st(vt[xt], yt[xt])));
            return pt;
          }
          function et(vt, yt, Et) {
            var pt,
              xt = function (Ct) {
                for (var Mt = 0, wt = pt.length; Mt < wt; ) {
                  if (
                    pt[Mt]._name === Ct ||
                    pt[Mt].mn === Ct ||
                    pt[Mt].propertyIndex === Ct ||
                    pt[Mt].ix === Ct ||
                    pt[Mt].ind === Ct
                  )
                    return pt[Mt];
                  Mt += 1;
                }
                return typeof Ct == "number" ? pt[Ct - 1] : null;
              };
            (xt.propertyGroup = propertyGroupFactory(xt, Et)),
              (pt = tt(vt.it, yt.it, xt.propertyGroup)),
              (xt.numProperties = pt.length);
            var St = lt(
              vt.it[vt.it.length - 1],
              yt.it[yt.it.length - 1],
              xt.propertyGroup
            );
            return (
              (xt.transform = St),
              (xt.propertyIndex = vt.cix),
              (xt._name = vt.nm),
              xt
            );
          }
          function nt(vt, yt, Et) {
            var pt = function (Ct) {
              switch (Ct) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return pt.content;
                default:
                  return pt.transform;
              }
            };
            pt.propertyGroup = propertyGroupFactory(pt, Et);
            var xt = et(vt, yt, pt.propertyGroup),
              St = lt(
                vt.it[vt.it.length - 1],
                yt.it[yt.it.length - 1],
                pt.propertyGroup
              );
            return (
              (pt.content = xt),
              (pt.transform = St),
              Object.defineProperty(pt, "_name", {
                get: function () {
                  return vt.nm;
                },
              }),
              (pt.numProperties = vt.np),
              (pt.propertyIndex = vt.ix),
              (pt.nm = vt.nm),
              (pt.mn = vt.mn),
              pt
            );
          }
          function rt(vt, yt, Et) {
            function pt(xt) {
              return xt === "Color" || xt === "color"
                ? pt.color
                : xt === "Opacity" || xt === "opacity"
                ? pt.opacity
                : null;
            }
            return (
              Object.defineProperties(pt, {
                color: { get: ExpressionPropertyInterface(yt.c) },
                opacity: { get: ExpressionPropertyInterface(yt.o) },
                _name: { value: vt.nm },
                mn: { value: vt.mn },
              }),
              yt.c.setGroupProperty(PropertyInterface("Color", Et)),
              yt.o.setGroupProperty(PropertyInterface("Opacity", Et)),
              pt
            );
          }
          function it(vt, yt, Et) {
            function pt(xt) {
              return xt === "Start Point" || xt === "start point"
                ? pt.startPoint
                : xt === "End Point" || xt === "end point"
                ? pt.endPoint
                : xt === "Opacity" || xt === "opacity"
                ? pt.opacity
                : null;
            }
            return (
              Object.defineProperties(pt, {
                startPoint: { get: ExpressionPropertyInterface(yt.s) },
                endPoint: { get: ExpressionPropertyInterface(yt.e) },
                opacity: { get: ExpressionPropertyInterface(yt.o) },
                type: {
                  get: function () {
                    return "a";
                  },
                },
                _name: { value: vt.nm },
                mn: { value: vt.mn },
              }),
              yt.s.setGroupProperty(PropertyInterface("Start Point", Et)),
              yt.e.setGroupProperty(PropertyInterface("End Point", Et)),
              yt.o.setGroupProperty(PropertyInterface("Opacity", Et)),
              pt
            );
          }
          function st() {
            function vt() {
              return null;
            }
            return vt;
          }
          function ot(vt, yt, Et) {
            var pt = propertyGroupFactory(wt, Et),
              xt = propertyGroupFactory(Mt, pt);
            function St(Bt) {
              Object.defineProperty(Mt, vt.d[Bt].nm, {
                get: ExpressionPropertyInterface(yt.d.dataProps[Bt].p),
              });
            }
            var At,
              Ct = vt.d ? vt.d.length : 0,
              Mt = {};
            for (At = 0; At < Ct; At += 1)
              St(At), yt.d.dataProps[At].p.setGroupProperty(xt);
            function wt(Bt) {
              return Bt === "Color" || Bt === "color"
                ? wt.color
                : Bt === "Opacity" || Bt === "opacity"
                ? wt.opacity
                : Bt === "Stroke Width" || Bt === "stroke width"
                ? wt.strokeWidth
                : null;
            }
            return (
              Object.defineProperties(wt, {
                color: { get: ExpressionPropertyInterface(yt.c) },
                opacity: { get: ExpressionPropertyInterface(yt.o) },
                strokeWidth: { get: ExpressionPropertyInterface(yt.w) },
                dash: {
                  get: function () {
                    return Mt;
                  },
                },
                _name: { value: vt.nm },
                mn: { value: vt.mn },
              }),
              yt.c.setGroupProperty(PropertyInterface("Color", pt)),
              yt.o.setGroupProperty(PropertyInterface("Opacity", pt)),
              yt.w.setGroupProperty(PropertyInterface("Stroke Width", pt)),
              wt
            );
          }
          function at(vt, yt, Et) {
            function pt(St) {
              return St === vt.e.ix || St === "End" || St === "end"
                ? pt.end
                : St === vt.s.ix
                ? pt.start
                : St === vt.o.ix
                ? pt.offset
                : null;
            }
            var xt = propertyGroupFactory(pt, Et);
            return (
              (pt.propertyIndex = vt.ix),
              yt.s.setGroupProperty(PropertyInterface("Start", xt)),
              yt.e.setGroupProperty(PropertyInterface("End", xt)),
              yt.o.setGroupProperty(PropertyInterface("Offset", xt)),
              (pt.propertyIndex = vt.ix),
              (pt.propertyGroup = Et),
              Object.defineProperties(pt, {
                start: { get: ExpressionPropertyInterface(yt.s) },
                end: { get: ExpressionPropertyInterface(yt.e) },
                offset: { get: ExpressionPropertyInterface(yt.o) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          function lt(vt, yt, Et) {
            function pt(St) {
              return vt.a.ix === St || St === "Anchor Point"
                ? pt.anchorPoint
                : vt.o.ix === St || St === "Opacity"
                ? pt.opacity
                : vt.p.ix === St || St === "Position"
                ? pt.position
                : vt.r.ix === St ||
                  St === "Rotation" ||
                  St === "ADBE Vector Rotation"
                ? pt.rotation
                : vt.s.ix === St || St === "Scale"
                ? pt.scale
                : (vt.sk && vt.sk.ix === St) || St === "Skew"
                ? pt.skew
                : (vt.sa && vt.sa.ix === St) || St === "Skew Axis"
                ? pt.skewAxis
                : null;
            }
            var xt = propertyGroupFactory(pt, Et);
            return (
              yt.transform.mProps.o.setGroupProperty(
                PropertyInterface("Opacity", xt)
              ),
              yt.transform.mProps.p.setGroupProperty(
                PropertyInterface("Position", xt)
              ),
              yt.transform.mProps.a.setGroupProperty(
                PropertyInterface("Anchor Point", xt)
              ),
              yt.transform.mProps.s.setGroupProperty(
                PropertyInterface("Scale", xt)
              ),
              yt.transform.mProps.r.setGroupProperty(
                PropertyInterface("Rotation", xt)
              ),
              yt.transform.mProps.sk &&
                (yt.transform.mProps.sk.setGroupProperty(
                  PropertyInterface("Skew", xt)
                ),
                yt.transform.mProps.sa.setGroupProperty(
                  PropertyInterface("Skew Angle", xt)
                )),
              yt.transform.op.setGroupProperty(
                PropertyInterface("Opacity", xt)
              ),
              Object.defineProperties(pt, {
                opacity: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.o),
                },
                position: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.p),
                },
                anchorPoint: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.a),
                },
                scale: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.s),
                },
                rotation: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.r),
                },
                skew: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.sk),
                },
                skewAxis: {
                  get: ExpressionPropertyInterface(yt.transform.mProps.sa),
                },
                _name: { value: vt.nm },
              }),
              (pt.ty = "tr"),
              (pt.mn = vt.mn),
              (pt.propertyGroup = Et),
              pt
            );
          }
          function ct(vt, yt, Et) {
            function pt(At) {
              return vt.p.ix === At
                ? pt.position
                : vt.s.ix === At
                ? pt.size
                : null;
            }
            var xt = propertyGroupFactory(pt, Et);
            pt.propertyIndex = vt.ix;
            var St = yt.sh.ty === "tm" ? yt.sh.prop : yt.sh;
            return (
              St.s.setGroupProperty(PropertyInterface("Size", xt)),
              St.p.setGroupProperty(PropertyInterface("Position", xt)),
              Object.defineProperties(pt, {
                size: { get: ExpressionPropertyInterface(St.s) },
                position: { get: ExpressionPropertyInterface(St.p) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          function ut(vt, yt, Et) {
            function pt(At) {
              return vt.p.ix === At
                ? pt.position
                : vt.r.ix === At
                ? pt.rotation
                : vt.pt.ix === At
                ? pt.points
                : vt.or.ix === At || At === "ADBE Vector Star Outer Radius"
                ? pt.outerRadius
                : vt.os.ix === At
                ? pt.outerRoundness
                : vt.ir &&
                  (vt.ir.ix === At || At === "ADBE Vector Star Inner Radius")
                ? pt.innerRadius
                : vt.is && vt.is.ix === At
                ? pt.innerRoundness
                : null;
            }
            var xt = propertyGroupFactory(pt, Et),
              St = yt.sh.ty === "tm" ? yt.sh.prop : yt.sh;
            return (
              (pt.propertyIndex = vt.ix),
              St.or.setGroupProperty(PropertyInterface("Outer Radius", xt)),
              St.os.setGroupProperty(PropertyInterface("Outer Roundness", xt)),
              St.pt.setGroupProperty(PropertyInterface("Points", xt)),
              St.p.setGroupProperty(PropertyInterface("Position", xt)),
              St.r.setGroupProperty(PropertyInterface("Rotation", xt)),
              vt.ir &&
                (St.ir.setGroupProperty(PropertyInterface("Inner Radius", xt)),
                St.is.setGroupProperty(
                  PropertyInterface("Inner Roundness", xt)
                )),
              Object.defineProperties(pt, {
                position: { get: ExpressionPropertyInterface(St.p) },
                rotation: { get: ExpressionPropertyInterface(St.r) },
                points: { get: ExpressionPropertyInterface(St.pt) },
                outerRadius: { get: ExpressionPropertyInterface(St.or) },
                outerRoundness: { get: ExpressionPropertyInterface(St.os) },
                innerRadius: { get: ExpressionPropertyInterface(St.ir) },
                innerRoundness: { get: ExpressionPropertyInterface(St.is) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          function ft(vt, yt, Et) {
            function pt(At) {
              return vt.p.ix === At
                ? pt.position
                : vt.r.ix === At
                ? pt.roundness
                : vt.s.ix === At ||
                  At === "Size" ||
                  At === "ADBE Vector Rect Size"
                ? pt.size
                : null;
            }
            var xt = propertyGroupFactory(pt, Et),
              St = yt.sh.ty === "tm" ? yt.sh.prop : yt.sh;
            return (
              (pt.propertyIndex = vt.ix),
              St.p.setGroupProperty(PropertyInterface("Position", xt)),
              St.s.setGroupProperty(PropertyInterface("Size", xt)),
              St.r.setGroupProperty(PropertyInterface("Rotation", xt)),
              Object.defineProperties(pt, {
                position: { get: ExpressionPropertyInterface(St.p) },
                roundness: { get: ExpressionPropertyInterface(St.r) },
                size: { get: ExpressionPropertyInterface(St.s) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          function ht(vt, yt, Et) {
            function pt(At) {
              return vt.r.ix === At || At === "Round Corners 1"
                ? pt.radius
                : null;
            }
            var xt = propertyGroupFactory(pt, Et),
              St = yt;
            return (
              (pt.propertyIndex = vt.ix),
              St.rd.setGroupProperty(PropertyInterface("Radius", xt)),
              Object.defineProperties(pt, {
                radius: { get: ExpressionPropertyInterface(St.rd) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          function mt(vt, yt, Et) {
            function pt(At) {
              return vt.c.ix === At || At === "Copies"
                ? pt.copies
                : vt.o.ix === At || At === "Offset"
                ? pt.offset
                : null;
            }
            var xt = propertyGroupFactory(pt, Et),
              St = yt;
            return (
              (pt.propertyIndex = vt.ix),
              St.c.setGroupProperty(PropertyInterface("Copies", xt)),
              St.o.setGroupProperty(PropertyInterface("Offset", xt)),
              Object.defineProperties(pt, {
                copies: { get: ExpressionPropertyInterface(St.c) },
                offset: { get: ExpressionPropertyInterface(St.o) },
                _name: { value: vt.nm },
              }),
              (pt.mn = vt.mn),
              pt
            );
          }
          return function (vt, yt, Et) {
            var pt;
            function xt(At) {
              if (typeof At == "number")
                return (
                  (At = At === void 0 ? 1 : At), At === 0 ? Et : pt[At - 1]
                );
              for (var Ct = 0, Mt = pt.length; Ct < Mt; ) {
                if (pt[Ct]._name === At) return pt[Ct];
                Ct += 1;
              }
              return null;
            }
            function St() {
              return Et;
            }
            return (
              (xt.propertyGroup = propertyGroupFactory(xt, St)),
              (pt = tt(vt, yt, xt.propertyGroup)),
              (xt.numProperties = pt.length),
              (xt._name = "Contents"),
              xt
            );
          };
        })(),
        TextExpressionInterface = (function () {
          return function (tt) {
            var et;
            function nt(rt) {
              switch (rt) {
                case "ADBE Text Document":
                  return nt.sourceText;
                default:
                  return null;
              }
            }
            return (
              Object.defineProperty(nt, "sourceText", {
                get: function () {
                  tt.textProperty.getValue();
                  var it = tt.textProperty.currentData.t;
                  return (
                    (!et || it !== et.value) &&
                      ((et = new String(it)),
                      (et.value = it || new String(it)),
                      Object.defineProperty(et, "style", {
                        get: function () {
                          return { fillColor: tt.textProperty.currentData.fc };
                        },
                      })),
                    et
                  );
                },
              }),
              nt
            );
          };
        })();
      function _typeof(tt) {
        "@babel/helpers - typeof";
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof = function (nt) {
                return typeof nt;
              })
            : (_typeof = function (nt) {
                return nt &&
                  typeof Symbol == "function" &&
                  nt.constructor === Symbol &&
                  nt !== Symbol.prototype
                  ? "symbol"
                  : typeof nt;
              }),
          _typeof(tt)
        );
      }
      var FootageInterface = (function () {
          var tt = function (rt) {
              var it = "",
                st = rt.getFootageData();
              function ot() {
                return (it = ""), (st = rt.getFootageData()), at;
              }
              function at(lt) {
                if (st[lt])
                  return (
                    (it = lt), (st = st[lt]), _typeof(st) === "object" ? at : st
                  );
                var ct = lt.indexOf(it);
                if (ct !== -1) {
                  var ut = parseInt(lt.substr(ct + it.length), 10);
                  return (st = st[ut]), _typeof(st) === "object" ? at : st;
                }
                return "";
              }
              return ot;
            },
            et = function (rt) {
              function it(st) {
                return st === "Outline" ? it.outlineInterface() : null;
              }
              return (it._name = "Outline"), (it.outlineInterface = tt(rt)), it;
            };
          return function (nt) {
            function rt(it) {
              return it === "Data" ? rt.dataInterface : null;
            }
            return (rt._name = "Data"), (rt.dataInterface = et(nt)), rt;
          };
        })(),
        interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface,
        };
      function getInterface(tt) {
        return interfaces[tt] || null;
      }
      var expressionHelpers = (function () {
        function tt(ot, at, lt) {
          at.x &&
            ((lt.k = !0),
            (lt.x = !0),
            (lt.initiateExpression = ExpressionManager.initiateExpression),
            lt.effectsSequence.push(
              lt.initiateExpression(ot, at, lt).bind(lt)
            ));
        }
        function et(ot) {
          return (
            (ot *= this.elem.globalData.frameRate),
            (ot -= this.offsetTime),
            ot !== this._cachingAtTime.lastFrame &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastFrame < ot
                  ? this._cachingAtTime.lastIndex
                  : 0),
              (this._cachingAtTime.value = this.interpolateValue(
                ot,
                this._cachingAtTime
              )),
              (this._cachingAtTime.lastFrame = ot)),
            this._cachingAtTime.value
          );
        }
        function nt(ot) {
          var at = -0.01,
            lt = this.getValueAtTime(ot),
            ct = this.getValueAtTime(ot + at),
            ut = 0;
          if (lt.length) {
            var ft;
            for (ft = 0; ft < lt.length; ft += 1)
              ut += Math.pow(ct[ft] - lt[ft], 2);
            ut = Math.sqrt(ut) * 100;
          } else ut = 0;
          return ut;
        }
        function rt(ot) {
          if (this.vel !== void 0) return this.vel;
          var at = -0.001,
            lt = this.getValueAtTime(ot),
            ct = this.getValueAtTime(ot + at),
            ut;
          if (lt.length) {
            ut = createTypedArray("float32", lt.length);
            var ft;
            for (ft = 0; ft < lt.length; ft += 1)
              ut[ft] = (ct[ft] - lt[ft]) / at;
          } else ut = (ct - lt) / at;
          return ut;
        }
        function it() {
          return this.pv;
        }
        function st(ot) {
          this.propertyGroup = ot;
        }
        return {
          searchExpressions: tt,
          getSpeedAtTime: nt,
          getVelocityAtTime: rt,
          getValueAtTime: et,
          getStaticValueAtTime: it,
          setGroupProperty: st,
        };
      })();
      function addPropertyDecorator() {
        function tt(ht, mt, vt) {
          if (!this.k || !this.keyframes) return this.pv;
          ht = ht ? ht.toLowerCase() : "";
          var yt = this.comp.renderedFrame,
            Et = this.keyframes,
            pt = Et[Et.length - 1].t;
          if (yt <= pt) return this.pv;
          var xt, St;
          vt
            ? (mt
                ? (xt = Math.abs(pt - this.elem.comp.globalData.frameRate * mt))
                : (xt = Math.max(0, pt - this.elem.data.ip)),
              (St = pt - xt))
            : ((!mt || mt > Et.length - 1) && (mt = Et.length - 1),
              (St = Et[Et.length - 1 - mt].t),
              (xt = pt - St));
          var At, Ct, Mt;
          if (ht === "pingpong") {
            var wt = Math.floor((yt - St) / xt);
            if (wt % 2 !== 0)
              return this.getValueAtTime(
                (xt - ((yt - St) % xt) + St) / this.comp.globalData.frameRate,
                0
              );
          } else if (ht === "offset") {
            var Bt = this.getValueAtTime(
                St / this.comp.globalData.frameRate,
                0
              ),
              It = this.getValueAtTime(pt / this.comp.globalData.frameRate, 0),
              Ft = this.getValueAtTime(
                (((yt - St) % xt) + St) / this.comp.globalData.frameRate,
                0
              ),
              Vt = Math.floor((yt - St) / xt);
            if (this.pv.length) {
              for (
                Mt = new Array(Bt.length), Ct = Mt.length, At = 0;
                At < Ct;
                At += 1
              )
                Mt[At] = (It[At] - Bt[At]) * Vt + Ft[At];
              return Mt;
            }
            return (It - Bt) * Vt + Ft;
          } else if (ht === "continue") {
            var $t = this.getValueAtTime(
                pt / this.comp.globalData.frameRate,
                0
              ),
              Kt = this.getValueAtTime(
                (pt - 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                Mt = new Array($t.length), Ct = Mt.length, At = 0;
                At < Ct;
                At += 1
              )
                Mt[At] =
                  $t[At] +
                  (($t[At] - Kt[At]) *
                    ((yt - pt) / this.comp.globalData.frameRate)) /
                    5e-4;
              return Mt;
            }
            return $t + ($t - Kt) * ((yt - pt) / 0.001);
          }
          return this.getValueAtTime(
            (((yt - St) % xt) + St) / this.comp.globalData.frameRate,
            0
          );
        }
        function et(ht, mt, vt) {
          if (!this.k) return this.pv;
          ht = ht ? ht.toLowerCase() : "";
          var yt = this.comp.renderedFrame,
            Et = this.keyframes,
            pt = Et[0].t;
          if (yt >= pt) return this.pv;
          var xt, St;
          vt
            ? (mt
                ? (xt = Math.abs(this.elem.comp.globalData.frameRate * mt))
                : (xt = Math.max(0, this.elem.data.op - pt)),
              (St = pt + xt))
            : ((!mt || mt > Et.length - 1) && (mt = Et.length - 1),
              (St = Et[mt].t),
              (xt = St - pt));
          var At, Ct, Mt;
          if (ht === "pingpong") {
            var wt = Math.floor((pt - yt) / xt);
            if (wt % 2 === 0)
              return this.getValueAtTime(
                (((pt - yt) % xt) + pt) / this.comp.globalData.frameRate,
                0
              );
          } else if (ht === "offset") {
            var Bt = this.getValueAtTime(
                pt / this.comp.globalData.frameRate,
                0
              ),
              It = this.getValueAtTime(St / this.comp.globalData.frameRate, 0),
              Ft = this.getValueAtTime(
                (xt - ((pt - yt) % xt) + pt) / this.comp.globalData.frameRate,
                0
              ),
              Vt = Math.floor((pt - yt) / xt) + 1;
            if (this.pv.length) {
              for (
                Mt = new Array(Bt.length), Ct = Mt.length, At = 0;
                At < Ct;
                At += 1
              )
                Mt[At] = Ft[At] - (It[At] - Bt[At]) * Vt;
              return Mt;
            }
            return Ft - (It - Bt) * Vt;
          } else if (ht === "continue") {
            var $t = this.getValueAtTime(
                pt / this.comp.globalData.frameRate,
                0
              ),
              Kt = this.getValueAtTime(
                (pt + 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                Mt = new Array($t.length), Ct = Mt.length, At = 0;
                At < Ct;
                At += 1
              )
                Mt[At] = $t[At] + (($t[At] - Kt[At]) * (pt - yt)) / 0.001;
              return Mt;
            }
            return $t + (($t - Kt) * (pt - yt)) / 0.001;
          }
          return this.getValueAtTime(
            (xt - (((pt - yt) % xt) + pt)) / this.comp.globalData.frameRate,
            0
          );
        }
        function nt(ht, mt) {
          if (!this.k) return this.pv;
          if (((ht = (ht || 0.4) * 0.5), (mt = Math.floor(mt || 5)), mt <= 1))
            return this.pv;
          var vt = this.comp.renderedFrame / this.comp.globalData.frameRate,
            yt = vt - ht,
            Et = vt + ht,
            pt = mt > 1 ? (Et - yt) / (mt - 1) : 1,
            xt = 0,
            St = 0,
            At;
          this.pv.length
            ? (At = createTypedArray("float32", this.pv.length))
            : (At = 0);
          for (var Ct; xt < mt; ) {
            if (((Ct = this.getValueAtTime(yt + xt * pt)), this.pv.length))
              for (St = 0; St < this.pv.length; St += 1) At[St] += Ct[St];
            else At += Ct;
            xt += 1;
          }
          if (this.pv.length)
            for (St = 0; St < this.pv.length; St += 1) At[St] /= mt;
          else At /= mt;
          return At;
        }
        function rt(ht) {
          this._transformCachingAtTime ||
            (this._transformCachingAtTime = { v: new Matrix() });
          var mt = this._transformCachingAtTime.v;
          if (
            (mt.cloneFromProps(this.pre.props), this.appliedTransformations < 1)
          ) {
            var vt = this.a.getValueAtTime(ht);
            mt.translate(
              -vt[0] * this.a.mult,
              -vt[1] * this.a.mult,
              vt[2] * this.a.mult
            );
          }
          if (this.appliedTransformations < 2) {
            var yt = this.s.getValueAtTime(ht);
            mt.scale(
              yt[0] * this.s.mult,
              yt[1] * this.s.mult,
              yt[2] * this.s.mult
            );
          }
          if (this.sk && this.appliedTransformations < 3) {
            var Et = this.sk.getValueAtTime(ht),
              pt = this.sa.getValueAtTime(ht);
            mt.skewFromAxis(-Et * this.sk.mult, pt * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var xt = this.r.getValueAtTime(ht);
            mt.rotate(-xt * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var St = this.rz.getValueAtTime(ht),
              At = this.ry.getValueAtTime(ht),
              Ct = this.rx.getValueAtTime(ht),
              Mt = this.or.getValueAtTime(ht);
            mt.rotateZ(-St * this.rz.mult)
              .rotateY(At * this.ry.mult)
              .rotateX(Ct * this.rx.mult)
              .rotateZ(-Mt[2] * this.or.mult)
              .rotateY(Mt[1] * this.or.mult)
              .rotateX(Mt[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var wt = this.px.getValueAtTime(ht),
              Bt = this.py.getValueAtTime(ht);
            if (this.data.p.z) {
              var It = this.pz.getValueAtTime(ht);
              mt.translate(
                wt * this.px.mult,
                Bt * this.py.mult,
                -It * this.pz.mult
              );
            } else mt.translate(wt * this.px.mult, Bt * this.py.mult, 0);
          } else {
            var Ft = this.p.getValueAtTime(ht);
            mt.translate(
              Ft[0] * this.p.mult,
              Ft[1] * this.p.mult,
              -Ft[2] * this.p.mult
            );
          }
          return mt;
        }
        function it() {
          return this.v.clone(new Matrix());
        }
        var st = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function (ht, mt, vt) {
          var yt = st(ht, mt, vt);
          return (
            yt.dynamicProperties.length
              ? (yt.getValueAtTime = rt.bind(yt))
              : (yt.getValueAtTime = it.bind(yt)),
            (yt.setGroupProperty = expressionHelpers.setGroupProperty),
            yt
          );
        };
        var ot = PropertyFactory.getProp;
        PropertyFactory.getProp = function (ht, mt, vt, yt, Et) {
          var pt = ot(ht, mt, vt, yt, Et);
          pt.kf
            ? (pt.getValueAtTime = expressionHelpers.getValueAtTime.bind(pt))
            : (pt.getValueAtTime =
                expressionHelpers.getStaticValueAtTime.bind(pt)),
            (pt.setGroupProperty = expressionHelpers.setGroupProperty),
            (pt.loopOut = tt),
            (pt.loopIn = et),
            (pt.smooth = nt),
            (pt.getVelocityAtTime =
              expressionHelpers.getVelocityAtTime.bind(pt)),
            (pt.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(pt)),
            (pt.numKeys = mt.a === 1 ? mt.k.length : 0),
            (pt.propertyIndex = mt.ix);
          var xt = 0;
          return (
            vt !== 0 &&
              (xt = createTypedArray(
                "float32",
                mt.a === 1 ? mt.k[0].s.length : mt.k.length
              )),
            (pt._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: xt,
            }),
            expressionHelpers.searchExpressions(ht, mt, pt),
            pt.k && Et.addDynamicProperty(pt),
            pt
          );
        };
        function at(ht) {
          return (
            this._cachingAtTime ||
              (this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame,
              }),
            (ht *= this.elem.globalData.frameRate),
            (ht -= this.offsetTime),
            ht !== this._cachingAtTime.lastTime &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastTime < ht
                  ? this._caching.lastIndex
                  : 0),
              (this._cachingAtTime.lastTime = ht),
              this.interpolateShape(
                ht,
                this._cachingAtTime.shapeValue,
                this._cachingAtTime
              )),
            this._cachingAtTime.shapeValue
          );
        }
        var lt = ShapePropertyFactory.getConstructorFunction(),
          ct = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ut() {}
        (ut.prototype = {
          vertices: function (mt, vt) {
            this.k && this.getValue();
            var yt = this.v;
            vt !== void 0 && (yt = this.getValueAtTime(vt, 0));
            var Et,
              pt = yt._length,
              xt = yt[mt],
              St = yt.v,
              At = createSizedArray(pt);
            for (Et = 0; Et < pt; Et += 1)
              mt === "i" || mt === "o"
                ? (At[Et] = [xt[Et][0] - St[Et][0], xt[Et][1] - St[Et][1]])
                : (At[Et] = [xt[Et][0], xt[Et][1]]);
            return At;
          },
          points: function (mt) {
            return this.vertices("v", mt);
          },
          inTangents: function (mt) {
            return this.vertices("i", mt);
          },
          outTangents: function (mt) {
            return this.vertices("o", mt);
          },
          isClosed: function () {
            return this.v.c;
          },
          pointOnPath: function (mt, vt) {
            var yt = this.v;
            vt !== void 0 && (yt = this.getValueAtTime(vt, 0)),
              this._segmentsLength ||
                (this._segmentsLength = bez.getSegmentsLength(yt));
            for (
              var Et = this._segmentsLength,
                pt = Et.lengths,
                xt = Et.totalLength * mt,
                St = 0,
                At = pt.length,
                Ct = 0,
                Mt;
              St < At;

            ) {
              if (Ct + pt[St].addedLength > xt) {
                var wt = St,
                  Bt = yt.c && St === At - 1 ? 0 : St + 1,
                  It = (xt - Ct) / pt[St].addedLength;
                Mt = bez.getPointInSegment(
                  yt.v[wt],
                  yt.v[Bt],
                  yt.o[wt],
                  yt.i[Bt],
                  It,
                  pt[St]
                );
                break;
              } else Ct += pt[St].addedLength;
              St += 1;
            }
            return (
              Mt ||
                (Mt = yt.c
                  ? [yt.v[0][0], yt.v[0][1]]
                  : [yt.v[yt._length - 1][0], yt.v[yt._length - 1][1]]),
              Mt
            );
          },
          vectorOnPath: function (mt, vt, yt) {
            mt == 1 ? (mt = this.v.c) : mt == 0 && (mt = 0.999);
            var Et = this.pointOnPath(mt, vt),
              pt = this.pointOnPath(mt + 0.001, vt),
              xt = pt[0] - Et[0],
              St = pt[1] - Et[1],
              At = Math.sqrt(Math.pow(xt, 2) + Math.pow(St, 2));
            if (At === 0) return [0, 0];
            var Ct =
              yt === "tangent" ? [xt / At, St / At] : [-St / At, xt / At];
            return Ct;
          },
          tangentOnPath: function (mt, vt) {
            return this.vectorOnPath(mt, vt, "tangent");
          },
          normalOnPath: function (mt, vt) {
            return this.vectorOnPath(mt, vt, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime,
        }),
          extendPrototype([ut], lt),
          extendPrototype([ut], ct),
          (ct.prototype.getValueAtTime = at),
          (ct.prototype.initiateExpression =
            ExpressionManager.initiateExpression);
        var ft = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function (ht, mt, vt, yt, Et) {
          var pt = ft(ht, mt, vt, yt, Et);
          return (
            (pt.propertyIndex = mt.ix),
            (pt.lock = !1),
            vt === 3
              ? expressionHelpers.searchExpressions(ht, mt.pt, pt)
              : vt === 4 && expressionHelpers.searchExpressions(ht, mt.ks, pt),
            pt.k && ht.addDynamicProperty(pt),
            pt
          );
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function tt() {
          return this.data.d.x
            ? ((this.calculateExpression =
                ExpressionManager.initiateExpression.bind(this)(
                  this.elem,
                  this.data.d,
                  this
                )),
              this.addEffect(this.getExpressionValue.bind(this)),
              !0)
            : null;
        }
        (TextProperty.prototype.getExpressionValue = function (et, nt) {
          var rt = this.calculateExpression(nt);
          if (et.t !== rt) {
            var it = {};
            return (
              this.copyData(it, et),
              (it.t = rt.toString()),
              (it.__complete = !1),
              it
            );
          }
          return et;
        }),
          (TextProperty.prototype.searchProperty = function () {
            var et = this.searchKeyframes(),
              nt = this.searchExpressions();
            return (this.kf = et || nt), this.kf;
          }),
          (TextProperty.prototype.searchExpressions = tt);
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {}
      SVGComposableEffect.prototype = {
        createMergeNode: function tt(et, nt) {
          var rt = createNS("feMerge");
          rt.setAttribute("result", et);
          var it, st;
          for (st = 0; st < nt.length; st += 1)
            (it = createNS("feMergeNode")),
              it.setAttribute("in", nt[st]),
              rt.appendChild(it),
              rt.appendChild(it);
          return rt;
        },
      };
      var linearFilterValue =
        "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(tt, et, nt, rt, it) {
        this.filterManager = et;
        var st = createNS("feColorMatrix");
        st.setAttribute("type", "matrix"),
          st.setAttribute("color-interpolation-filters", "linearRGB"),
          st.setAttribute("values", linearFilterValue + " 1 0"),
          (this.linearFilter = st),
          st.setAttribute("result", rt + "_tint_1"),
          tt.appendChild(st),
          (st = createNS("feColorMatrix")),
          st.setAttribute("type", "matrix"),
          st.setAttribute("color-interpolation-filters", "sRGB"),
          st.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          st.setAttribute("result", rt + "_tint_2"),
          tt.appendChild(st),
          (this.matrixFilter = st);
        var ot = this.createMergeNode(rt, [it, rt + "_tint_1", rt + "_tint_2"]);
        tt.appendChild(ot);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter),
        (SVGTintFilter.prototype.renderFrame = function (tt) {
          if (tt || this.filterManager._mdf) {
            var et = this.filterManager.effectElements[0].p.v,
              nt = this.filterManager.effectElements[1].p.v,
              rt = this.filterManager.effectElements[2].p.v / 100;
            this.linearFilter.setAttribute(
              "values",
              linearFilterValue + " " + rt + " 0"
            ),
              this.matrixFilter.setAttribute(
                "values",
                nt[0] -
                  et[0] +
                  " 0 0 0 " +
                  et[0] +
                  " " +
                  (nt[1] - et[1]) +
                  " 0 0 0 " +
                  et[1] +
                  " " +
                  (nt[2] - et[2]) +
                  " 0 0 0 " +
                  et[2] +
                  " 0 0 0 1 0"
              );
          }
        });
      function SVGFillFilter(tt, et, nt, rt) {
        this.filterManager = et;
        var it = createNS("feColorMatrix");
        it.setAttribute("type", "matrix"),
          it.setAttribute("color-interpolation-filters", "sRGB"),
          it.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          it.setAttribute("result", rt),
          tt.appendChild(it),
          (this.matrixFilter = it);
      }
      SVGFillFilter.prototype.renderFrame = function (tt) {
        if (tt || this.filterManager._mdf) {
          var et = this.filterManager.effectElements[2].p.v,
            nt = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute(
            "values",
            "0 0 0 0 " +
              et[0] +
              " 0 0 0 0 " +
              et[1] +
              " 0 0 0 0 " +
              et[2] +
              " 0 0 0 " +
              nt +
              " 0"
          );
        }
      };
      function SVGStrokeEffect(tt, et, nt) {
        (this.initialized = !1),
          (this.filterManager = et),
          (this.elem = nt),
          (this.paths = []);
      }
      (SVGStrokeEffect.prototype.initialize = function () {
        var tt =
            this.elem.layerElement.children ||
            this.elem.layerElement.childNodes,
          et,
          nt,
          rt,
          it;
        for (
          this.filterManager.effectElements[1].p.v === 1
            ? ((it = this.elem.maskManager.masksProperties.length), (rt = 0))
            : ((rt = this.filterManager.effectElements[0].p.v - 1),
              (it = rt + 1)),
            nt = createNS("g"),
            nt.setAttribute("fill", "none"),
            nt.setAttribute("stroke-linecap", "round"),
            nt.setAttribute("stroke-dashoffset", 1),
            rt;
          rt < it;
          rt += 1
        )
          (et = createNS("path")),
            nt.appendChild(et),
            this.paths.push({ p: et, m: rt });
        if (this.filterManager.effectElements[10].p.v === 3) {
          var st = createNS("mask"),
            ot = createElementID();
          st.setAttribute("id", ot),
            st.setAttribute("mask-type", "alpha"),
            st.appendChild(nt),
            this.elem.globalData.defs.appendChild(st);
          var at = createNS("g");
          for (
            at.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + ot + ")"
            );
            tt[0];

          )
            at.appendChild(tt[0]);
          this.elem.layerElement.appendChild(at),
            (this.masker = st),
            nt.setAttribute("stroke", "#fff");
        } else if (
          this.filterManager.effectElements[10].p.v === 1 ||
          this.filterManager.effectElements[10].p.v === 2
        ) {
          if (this.filterManager.effectElements[10].p.v === 2)
            for (
              tt =
                this.elem.layerElement.children ||
                this.elem.layerElement.childNodes;
              tt.length;

            )
              this.elem.layerElement.removeChild(tt[0]);
          this.elem.layerElement.appendChild(nt),
            this.elem.layerElement.removeAttribute("mask"),
            nt.setAttribute("stroke", "#fff");
        }
        (this.initialized = !0), (this.pathMasker = nt);
      }),
        (SVGStrokeEffect.prototype.renderFrame = function (tt) {
          this.initialized || this.initialize();
          var et,
            nt = this.paths.length,
            rt,
            it;
          for (et = 0; et < nt; et += 1)
            if (
              this.paths[et].m !== -1 &&
              ((rt = this.elem.maskManager.viewData[this.paths[et].m]),
              (it = this.paths[et].p),
              (tt || this.filterManager._mdf || rt.prop._mdf) &&
                it.setAttribute("d", rt.lastPath),
              tt ||
                this.filterManager.effectElements[9].p._mdf ||
                this.filterManager.effectElements[4].p._mdf ||
                this.filterManager.effectElements[7].p._mdf ||
                this.filterManager.effectElements[8].p._mdf ||
                rt.prop._mdf)
            ) {
              var st;
              if (
                this.filterManager.effectElements[7].p.v !== 0 ||
                this.filterManager.effectElements[8].p.v !== 100
              ) {
                var ot =
                    Math.min(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  at =
                    Math.max(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  lt = it.getTotalLength();
                st = "0 0 0 " + lt * ot + " ";
                var ct = lt * (at - ot),
                  ut =
                    1 +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01,
                  ft = Math.floor(ct / ut),
                  ht;
                for (ht = 0; ht < ft; ht += 1)
                  st +=
                    "1 " +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01 +
                    " ";
                st += "0 " + lt * 10 + " 0 0";
              } else
                st =
                  "1 " +
                  this.filterManager.effectElements[4].p.v *
                    2 *
                    this.filterManager.effectElements[9].p.v *
                    0.01;
              it.setAttribute("stroke-dasharray", st);
            }
          if (
            ((tt || this.filterManager.effectElements[4].p._mdf) &&
              this.pathMasker.setAttribute(
                "stroke-width",
                this.filterManager.effectElements[4].p.v * 2
              ),
            (tt || this.filterManager.effectElements[6].p._mdf) &&
              this.pathMasker.setAttribute(
                "opacity",
                this.filterManager.effectElements[6].p.v
              ),
            (this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2) &&
              (tt || this.filterManager.effectElements[3].p._mdf))
          ) {
            var mt = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute(
              "stroke",
              "rgb(" +
                bmFloor(mt[0] * 255) +
                "," +
                bmFloor(mt[1] * 255) +
                "," +
                bmFloor(mt[2] * 255) +
                ")"
            );
          }
        });
      function SVGTritoneFilter(tt, et, nt, rt) {
        this.filterManager = et;
        var it = createNS("feColorMatrix");
        it.setAttribute("type", "matrix"),
          it.setAttribute("color-interpolation-filters", "linearRGB"),
          it.setAttribute(
            "values",
            "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
          ),
          tt.appendChild(it);
        var st = createNS("feComponentTransfer");
        st.setAttribute("color-interpolation-filters", "sRGB"),
          st.setAttribute("result", rt),
          (this.matrixFilter = st);
        var ot = createNS("feFuncR");
        ot.setAttribute("type", "table"),
          st.appendChild(ot),
          (this.feFuncR = ot);
        var at = createNS("feFuncG");
        at.setAttribute("type", "table"),
          st.appendChild(at),
          (this.feFuncG = at);
        var lt = createNS("feFuncB");
        lt.setAttribute("type", "table"),
          st.appendChild(lt),
          (this.feFuncB = lt),
          tt.appendChild(st);
      }
      SVGTritoneFilter.prototype.renderFrame = function (tt) {
        if (tt || this.filterManager._mdf) {
          var et = this.filterManager.effectElements[0].p.v,
            nt = this.filterManager.effectElements[1].p.v,
            rt = this.filterManager.effectElements[2].p.v,
            it = rt[0] + " " + nt[0] + " " + et[0],
            st = rt[1] + " " + nt[1] + " " + et[1],
            ot = rt[2] + " " + nt[2] + " " + et[2];
          this.feFuncR.setAttribute("tableValues", it),
            this.feFuncG.setAttribute("tableValues", st),
            this.feFuncB.setAttribute("tableValues", ot);
        }
      };
      function SVGProLevelsFilter(tt, et, nt, rt) {
        this.filterManager = et;
        var it = this.filterManager.effectElements,
          st = createNS("feComponentTransfer");
        (it[10].p.k ||
          it[10].p.v !== 0 ||
          it[11].p.k ||
          it[11].p.v !== 1 ||
          it[12].p.k ||
          it[12].p.v !== 1 ||
          it[13].p.k ||
          it[13].p.v !== 0 ||
          it[14].p.k ||
          it[14].p.v !== 1) &&
          (this.feFuncR = this.createFeFunc("feFuncR", st)),
          (it[17].p.k ||
            it[17].p.v !== 0 ||
            it[18].p.k ||
            it[18].p.v !== 1 ||
            it[19].p.k ||
            it[19].p.v !== 1 ||
            it[20].p.k ||
            it[20].p.v !== 0 ||
            it[21].p.k ||
            it[21].p.v !== 1) &&
            (this.feFuncG = this.createFeFunc("feFuncG", st)),
          (it[24].p.k ||
            it[24].p.v !== 0 ||
            it[25].p.k ||
            it[25].p.v !== 1 ||
            it[26].p.k ||
            it[26].p.v !== 1 ||
            it[27].p.k ||
            it[27].p.v !== 0 ||
            it[28].p.k ||
            it[28].p.v !== 1) &&
            (this.feFuncB = this.createFeFunc("feFuncB", st)),
          (it[31].p.k ||
            it[31].p.v !== 0 ||
            it[32].p.k ||
            it[32].p.v !== 1 ||
            it[33].p.k ||
            it[33].p.v !== 1 ||
            it[34].p.k ||
            it[34].p.v !== 0 ||
            it[35].p.k ||
            it[35].p.v !== 1) &&
            (this.feFuncA = this.createFeFunc("feFuncA", st)),
          (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) &&
            (st.setAttribute("color-interpolation-filters", "sRGB"),
            tt.appendChild(st)),
          (it[3].p.k ||
            it[3].p.v !== 0 ||
            it[4].p.k ||
            it[4].p.v !== 1 ||
            it[5].p.k ||
            it[5].p.v !== 1 ||
            it[6].p.k ||
            it[6].p.v !== 0 ||
            it[7].p.k ||
            it[7].p.v !== 1) &&
            ((st = createNS("feComponentTransfer")),
            st.setAttribute("color-interpolation-filters", "sRGB"),
            st.setAttribute("result", rt),
            tt.appendChild(st),
            (this.feFuncRComposed = this.createFeFunc("feFuncR", st)),
            (this.feFuncGComposed = this.createFeFunc("feFuncG", st)),
            (this.feFuncBComposed = this.createFeFunc("feFuncB", st)));
      }
      (SVGProLevelsFilter.prototype.createFeFunc = function (tt, et) {
        var nt = createNS(tt);
        return nt.setAttribute("type", "table"), et.appendChild(nt), nt;
      }),
        (SVGProLevelsFilter.prototype.getTableValue = function (
          tt,
          et,
          nt,
          rt,
          it
        ) {
          for (
            var st = 0,
              ot = 256,
              at,
              lt = Math.min(tt, et),
              ct = Math.max(tt, et),
              ut = Array.call(null, { length: ot }),
              ft,
              ht = 0,
              mt = it - rt,
              vt = et - tt;
            st <= 256;

          )
            (at = st / 256),
              at <= lt
                ? (ft = vt < 0 ? it : rt)
                : at >= ct
                ? (ft = vt < 0 ? rt : it)
                : (ft = rt + mt * Math.pow((at - tt) / vt, 1 / nt)),
              (ut[ht] = ft),
              (ht += 1),
              (st += 256 / (ot - 1));
          return ut.join(" ");
        }),
        (SVGProLevelsFilter.prototype.renderFrame = function (tt) {
          if (tt || this.filterManager._mdf) {
            var et,
              nt = this.filterManager.effectElements;
            this.feFuncRComposed &&
              (tt ||
                nt[3].p._mdf ||
                nt[4].p._mdf ||
                nt[5].p._mdf ||
                nt[6].p._mdf ||
                nt[7].p._mdf) &&
              ((et = this.getTableValue(
                nt[3].p.v,
                nt[4].p.v,
                nt[5].p.v,
                nt[6].p.v,
                nt[7].p.v
              )),
              this.feFuncRComposed.setAttribute("tableValues", et),
              this.feFuncGComposed.setAttribute("tableValues", et),
              this.feFuncBComposed.setAttribute("tableValues", et)),
              this.feFuncR &&
                (tt ||
                  nt[10].p._mdf ||
                  nt[11].p._mdf ||
                  nt[12].p._mdf ||
                  nt[13].p._mdf ||
                  nt[14].p._mdf) &&
                ((et = this.getTableValue(
                  nt[10].p.v,
                  nt[11].p.v,
                  nt[12].p.v,
                  nt[13].p.v,
                  nt[14].p.v
                )),
                this.feFuncR.setAttribute("tableValues", et)),
              this.feFuncG &&
                (tt ||
                  nt[17].p._mdf ||
                  nt[18].p._mdf ||
                  nt[19].p._mdf ||
                  nt[20].p._mdf ||
                  nt[21].p._mdf) &&
                ((et = this.getTableValue(
                  nt[17].p.v,
                  nt[18].p.v,
                  nt[19].p.v,
                  nt[20].p.v,
                  nt[21].p.v
                )),
                this.feFuncG.setAttribute("tableValues", et)),
              this.feFuncB &&
                (tt ||
                  nt[24].p._mdf ||
                  nt[25].p._mdf ||
                  nt[26].p._mdf ||
                  nt[27].p._mdf ||
                  nt[28].p._mdf) &&
                ((et = this.getTableValue(
                  nt[24].p.v,
                  nt[25].p.v,
                  nt[26].p.v,
                  nt[27].p.v,
                  nt[28].p.v
                )),
                this.feFuncB.setAttribute("tableValues", et)),
              this.feFuncA &&
                (tt ||
                  nt[31].p._mdf ||
                  nt[32].p._mdf ||
                  nt[33].p._mdf ||
                  nt[34].p._mdf ||
                  nt[35].p._mdf) &&
                ((et = this.getTableValue(
                  nt[31].p.v,
                  nt[32].p.v,
                  nt[33].p.v,
                  nt[34].p.v,
                  nt[35].p.v
                )),
                this.feFuncA.setAttribute("tableValues", et));
          }
        });
      function SVGDropShadowEffect(tt, et, nt, rt, it) {
        var st = et.container.globalData.renderConfig.filterSize,
          ot = et.data.fs || st;
        tt.setAttribute("x", ot.x || st.x),
          tt.setAttribute("y", ot.y || st.y),
          tt.setAttribute("width", ot.width || st.width),
          tt.setAttribute("height", ot.height || st.height),
          (this.filterManager = et);
        var at = createNS("feGaussianBlur");
        at.setAttribute("in", "SourceAlpha"),
          at.setAttribute("result", rt + "_drop_shadow_1"),
          at.setAttribute("stdDeviation", "0"),
          (this.feGaussianBlur = at),
          tt.appendChild(at);
        var lt = createNS("feOffset");
        lt.setAttribute("dx", "25"),
          lt.setAttribute("dy", "0"),
          lt.setAttribute("in", rt + "_drop_shadow_1"),
          lt.setAttribute("result", rt + "_drop_shadow_2"),
          (this.feOffset = lt),
          tt.appendChild(lt);
        var ct = createNS("feFlood");
        ct.setAttribute("flood-color", "#00ff00"),
          ct.setAttribute("flood-opacity", "1"),
          ct.setAttribute("result", rt + "_drop_shadow_3"),
          (this.feFlood = ct),
          tt.appendChild(ct);
        var ut = createNS("feComposite");
        ut.setAttribute("in", rt + "_drop_shadow_3"),
          ut.setAttribute("in2", rt + "_drop_shadow_2"),
          ut.setAttribute("operator", "in"),
          ut.setAttribute("result", rt + "_drop_shadow_4"),
          tt.appendChild(ut);
        var ft = this.createMergeNode(rt, [rt + "_drop_shadow_4", it]);
        tt.appendChild(ft);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        (SVGDropShadowEffect.prototype.renderFrame = function (tt) {
          if (tt || this.filterManager._mdf) {
            if (
              ((tt || this.filterManager.effectElements[4].p._mdf) &&
                this.feGaussianBlur.setAttribute(
                  "stdDeviation",
                  this.filterManager.effectElements[4].p.v / 4
                ),
              tt || this.filterManager.effectElements[0].p._mdf)
            ) {
              var et = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute(
                "flood-color",
                rgbToHex(
                  Math.round(et[0] * 255),
                  Math.round(et[1] * 255),
                  Math.round(et[2] * 255)
                )
              );
            }
            if (
              ((tt || this.filterManager.effectElements[1].p._mdf) &&
                this.feFlood.setAttribute(
                  "flood-opacity",
                  this.filterManager.effectElements[1].p.v / 255
                ),
              tt ||
                this.filterManager.effectElements[2].p._mdf ||
                this.filterManager.effectElements[3].p._mdf)
            ) {
              var nt = this.filterManager.effectElements[3].p.v,
                rt =
                  (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                it = nt * Math.cos(rt),
                st = nt * Math.sin(rt);
              this.feOffset.setAttribute("dx", it),
                this.feOffset.setAttribute("dy", st);
            }
          }
        });
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(tt, et, nt) {
        (this.initialized = !1),
          (this.filterManager = et),
          (this.filterElem = tt),
          (this.elem = nt),
          (nt.matteElement = createNS("g")),
          nt.matteElement.appendChild(nt.layerElement),
          nt.matteElement.appendChild(nt.transformedElement),
          (nt.baseElement = nt.matteElement);
      }
      (SVGMatte3Effect.prototype.findSymbol = function (tt) {
        for (var et = 0, nt = _svgMatteSymbols.length; et < nt; ) {
          if (_svgMatteSymbols[et] === tt) return _svgMatteSymbols[et];
          et += 1;
        }
        return null;
      }),
        (SVGMatte3Effect.prototype.replaceInParent = function (tt, et) {
          var nt = tt.layerElement.parentNode;
          if (nt) {
            for (
              var rt = nt.children, it = 0, st = rt.length;
              it < st && rt[it] !== tt.layerElement;

            )
              it += 1;
            var ot;
            it <= st - 2 && (ot = rt[it + 1]);
            var at = createNS("use");
            at.setAttribute("href", "#" + et),
              ot ? nt.insertBefore(at, ot) : nt.appendChild(at);
          }
        }),
        (SVGMatte3Effect.prototype.setElementAsMask = function (tt, et) {
          if (!this.findSymbol(et)) {
            var nt = createElementID(),
              rt = createNS("mask");
            rt.setAttribute("id", et.layerId),
              rt.setAttribute("mask-type", "alpha"),
              _svgMatteSymbols.push(et);
            var it = tt.globalData.defs;
            it.appendChild(rt);
            var st = createNS("symbol");
            st.setAttribute("id", nt),
              this.replaceInParent(et, nt),
              st.appendChild(et.layerElement),
              it.appendChild(st);
            var ot = createNS("use");
            ot.setAttribute("href", "#" + nt),
              rt.appendChild(ot),
              (et.data.hd = !1),
              et.show();
          }
          tt.setMatte(et.layerId);
        }),
        (SVGMatte3Effect.prototype.initialize = function () {
          for (
            var tt = this.filterManager.effectElements[0].p.v,
              et = this.elem.comp.elements,
              nt = 0,
              rt = et.length;
            nt < rt;

          )
            et[nt] &&
              et[nt].data.ind === tt &&
              this.setElementAsMask(this.elem, et[nt]),
              (nt += 1);
          this.initialized = !0;
        }),
        (SVGMatte3Effect.prototype.renderFrame = function () {
          this.initialized || this.initialize();
        });
      function SVGGaussianBlurEffect(tt, et, nt, rt) {
        tt.setAttribute("x", "-100%"),
          tt.setAttribute("y", "-100%"),
          tt.setAttribute("width", "300%"),
          tt.setAttribute("height", "300%"),
          (this.filterManager = et);
        var it = createNS("feGaussianBlur");
        it.setAttribute("result", rt),
          tt.appendChild(it),
          (this.feGaussianBlur = it);
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function (tt) {
        if (tt || this.filterManager._mdf) {
          var et = 0.3,
            nt = this.filterManager.effectElements[0].p.v * et,
            rt = this.filterManager.effectElements[1].p.v,
            it = rt == 3 ? 0 : nt,
            st = rt == 2 ? 0 : nt;
          this.feGaussianBlur.setAttribute("stdDeviation", it + " " + st);
          var ot =
            this.filterManager.effectElements[2].p.v == 1
              ? "wrap"
              : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", ot);
        }
      };
      function TransformEffect() {}
      (TransformEffect.prototype.init = function (tt) {
        (this.effectsManager = tt),
          (this.type = effectTypes.TRANSFORM_EFFECT),
          (this.matrix = new Matrix()),
          (this.opacity = -1),
          (this._mdf = !1),
          (this._opMdf = !1);
      }),
        (TransformEffect.prototype.renderFrame = function (tt) {
          if (
            ((this._opMdf = !1),
            (this._mdf = !1),
            tt || this.effectsManager._mdf)
          ) {
            var et = this.effectsManager.effectElements,
              nt = et[0].p.v,
              rt = et[1].p.v,
              it = et[2].p.v === 1,
              st = et[3].p.v,
              ot = it ? st : et[4].p.v,
              at = et[5].p.v,
              lt = et[6].p.v,
              ct = et[7].p.v;
            this.matrix.reset(),
              this.matrix.translate(-nt[0], -nt[1], nt[2]),
              this.matrix.scale(ot * 0.01, st * 0.01, 1),
              this.matrix.rotate(-ct * degToRads),
              this.matrix.skewFromAxis(-at * degToRads, (lt + 90) * degToRads),
              this.matrix.translate(rt[0], rt[1], 0),
              (this._mdf = !0),
              this.opacity !== et[8].p.v &&
                ((this.opacity = et[8].p.v), (this._opMdf = !0));
          }
        });
      function SVGTransformEffect(tt, et) {
        this.init(et);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(tt) {
        this.init(tt);
      }
      return (
        extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
      );
    });
})(lottie, lottie.exports);
const ThreeComponent = () => {
  const tt = useDispatch(),
    { showLedger: et, showCancelAlert: nt } = useSelector(
      (it) => it.DoubleSpendingReducer
    ),
    rt = () => {
      tt(startAnimation()),
        tt(updateRquest("cancel")),
        tt(updateInstruction([])),
        tt(updateShowAlert(!1));
    };
  return React.createElement(
    "div",
    { style: { height: "100%", position: "relative" } },
    React.createElement(
      Snackbar$1,
      {
        open: nt,
        severity: "info",
        anchorOrigin: { vertical: "top", horizontal: "center" },
      },
      React.createElement(
        Alert$1,
        { severity: "success", sx: { width: "100%" } },
        "Confirm the cancellation of the DD request?",
        React.createElement(
          "div",
          {
            style: { marginTop: 10, display: "flex", justifyContent: "center" },
          },
          React.createElement(
            "button",
            { onClick: rt, style: { width: 150, padding: 2 } },
            "Confirm"
          )
        )
      )
    ),
    React.createElement(Scene, null),
    et && React.createElement(Ledger, null)
  );
};
function RadioButtons() {
  const { radioClicked: tt } = useSelector((rt) => rt.DoubleSpendingReducer),
    et = useDispatch(),
    nt = (rt) => {
      et(updateRadionChange(rt.target.value)), et(updateShowSideOption(!0));
    };
  return reactExports.createElement(
    "div",
    { style: { display: "flex", justifyContent: "space-around" } },
    reactExports.createElement(
      "div",
      { style: { display: "flex", alignItems: "center" } },
      reactExports.createElement(Radio$1, {
        checked: tt === "conventional",
        onChange: nt,
        value: "conventional",
        name: "radio-buttons",
        sx: { color: blue$1[500], "&.Mui-checked": { color: blue$1[600] } },
      }),
      reactExports.createElement(
        Typography$1,
        { style: { color: "white" } },
        "Conventional"
      )
    ),
    reactExports.createElement(
      "div",
      { style: { display: "flex", alignItems: "center" } },
      reactExports.createElement(Radio$1, {
        checked: tt === "blockChain",
        onChange: nt,
        value: "blockChain",
        name: "radio-buttons",
        sx: { color: blue$1[500], "&.Mui-checked": { color: blue$1[600] } },
      }),
      reactExports.createElement(
        Typography$1,
        { style: { color: "white" } },
        "BlockChain"
      )
    )
  );
}
const DefinitionCard = ({ text: tt, onClick: et, isConventional: nt = !1 }) => (
  console.log(nt),
  React.createElement(
    "div",
    {
      style: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
      },
    },
    nt
      ? React.createElement(
          "p",
          {
            style: {
              padding: 5,
              color: "white",
              fontFamily: "sans-serif",
              fontSize: 15,
              lineHeight: 1.4,
            },
          },
          "In a centralized banking system,When you make a payment or transfer money, the bank central authority keeps a ledger of all transactions. It ensures that you cannot spend the same money twice because it deducts the exact amount from your account when you make a payment. The bank has full control over the ledger and the ability to verify the authenticity of each transaction, so double spending is not a significant concern in this context."
        )
      : React.createElement(
          "p",
          {
            style: {
              padding: 5,
              color: "white",
              fontFamily: "sans-serif",
              fontSize: 15,
              lineHeight: 1.4,
            },
          },
          "In a blockchain-based system, when you make a payment or transfer digital assets, the ledger is decentralized and distributed across a network of nodes. This technology ensures that you cannot spend the same digital assets twice because it records the transaction on a public ledger. The blockchain network collectively verifies the authenticity of each transaction, making it highly resistant to double spending, as there is no central authority controlling the ledger."
        ),
    React.createElement(
      Button$1,
      {
        style: { width: "100px", backgroundColor: "white", height: 40 },
        onClick: () => et(nt),
      },
      React.createElement(PlayArrowRounded, null),
      React.createElement("p", null, "Play")
    )
  )
);
var getDefaultStyle = function (tt) {
    return { display: tt ? "flex" : "none" };
  },
  DEFAULT_COLOR = "#4fa94d",
  DEFAULT_WAI_ARIA_ATTRIBUTE = { "aria-busy": !0, role: "status" },
  __assign$w =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$w =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$w.apply(this, arguments)
      );
    },
  __assign$v =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$v =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$v.apply(this, arguments)
      );
    },
  __assign$u =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$u =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$u.apply(this, arguments)
      );
    },
  __assign$t =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$t =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$t.apply(this, arguments)
      );
    },
  __assign$s =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$s =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$s.apply(this, arguments)
      );
    },
  __assign$r =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$r =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$r.apply(this, arguments)
      );
    },
  __assign$q =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$q =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$q.apply(this, arguments)
      );
    };
function stylis_min(tt) {
  function et(zt, Yt, qt, Zt, Jt) {
    for (
      var mn = 0,
        ln = 0,
        bn = 0,
        Bn = 0,
        gn,
        jt,
        yn = 0,
        pn = 0,
        vn,
        xn = (vn = gn = 0),
        Fn = 0,
        _n = 0,
        Dn = 0,
        Tn = 0,
        An = qt.length,
        Wn = An - 1,
        Xt,
        Ut = "",
        hn = "",
        Ln = "",
        Cn = "",
        Mn;
      Fn < An;

    ) {
      if (
        ((jt = qt.charCodeAt(Fn)),
        Fn === Wn &&
          ln + Bn + bn + mn !== 0 &&
          (ln !== 0 && (jt = ln === 47 ? 10 : 47),
          (Bn = bn = mn = 0),
          An++,
          Wn++),
        ln + Bn + bn + mn === 0)
      ) {
        if (
          Fn === Wn &&
          (0 < _n && (Ut = Ut.replace(ht, "")), 0 < Ut.trim().length)
        ) {
          switch (jt) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              Ut += qt.charAt(Fn);
          }
          jt = 59;
        }
        switch (jt) {
          case 123:
            for (
              Ut = Ut.trim(), gn = Ut.charCodeAt(0), vn = 1, Tn = ++Fn;
              Fn < An;

            ) {
              switch ((jt = qt.charCodeAt(Fn))) {
                case 123:
                  vn++;
                  break;
                case 125:
                  vn--;
                  break;
                case 47:
                  switch ((jt = qt.charCodeAt(Fn + 1))) {
                    case 42:
                    case 47:
                      e: {
                        for (xn = Fn + 1; xn < Wn; ++xn)
                          switch (qt.charCodeAt(xn)) {
                            case 47:
                              if (
                                jt === 42 &&
                                qt.charCodeAt(xn - 1) === 42 &&
                                Fn + 2 !== xn
                              ) {
                                Fn = xn + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (jt === 47) {
                                Fn = xn + 1;
                                break e;
                              }
                          }
                        Fn = xn;
                      }
                  }
                  break;
                case 91:
                  jt++;
                case 40:
                  jt++;
                case 34:
                case 39:
                  for (; Fn++ < Wn && qt.charCodeAt(Fn) !== jt; );
              }
              if (vn === 0) break;
              Fn++;
            }
            switch (
              ((vn = qt.substring(Tn, Fn)),
              gn === 0 && (gn = (Ut = Ut.replace(ft, "").trim()).charCodeAt(0)),
              gn)
            ) {
              case 64:
                switch (
                  (0 < _n && (Ut = Ut.replace(ht, "")),
                  (jt = Ut.charCodeAt(1)),
                  jt)
                ) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    _n = Yt;
                    break;
                  default:
                    _n = kt;
                }
                if (
                  ((vn = et(Yt, _n, vn, jt, Jt + 1)),
                  (Tn = vn.length),
                  0 < Pt &&
                    ((_n = nt(kt, Ut, Dn)),
                    (Mn = at(3, vn, _n, Yt, Kt, $t, Tn, jt, Jt, Zt)),
                    (Ut = _n.join("")),
                    Mn !== void 0 &&
                      (Tn = (vn = Mn.trim()).length) === 0 &&
                      ((jt = 0), (vn = ""))),
                  0 < Tn)
                )
                  switch (jt) {
                    case 115:
                      Ut = Ut.replace(Mt, ot);
                    case 100:
                    case 109:
                    case 45:
                      vn = Ut + "{" + vn + "}";
                      break;
                    case 107:
                      (Ut = Ut.replace(xt, "$1 $2")),
                        (vn = Ut + "{" + vn + "}"),
                        (vn =
                          Wt === 1 || (Wt === 2 && st("@" + vn, 3))
                            ? "@-webkit-" + vn + "@" + vn
                            : "@" + vn);
                      break;
                    default:
                      (vn = Ut + vn), Zt === 112 && (vn = ((hn += vn), ""));
                  }
                else vn = "";
                break;
              default:
                vn = et(Yt, nt(Yt, Ut, Dn), vn, Zt, Jt + 1);
            }
            (Ln += vn),
              (vn = Dn = _n = xn = gn = 0),
              (Ut = ""),
              (jt = qt.charCodeAt(++Fn));
            break;
          case 125:
          case 59:
            if (
              ((Ut = (0 < _n ? Ut.replace(ht, "") : Ut).trim()),
              1 < (Tn = Ut.length))
            )
              switch (
                (xn === 0 &&
                  ((gn = Ut.charCodeAt(0)),
                  gn === 45 || (96 < gn && 123 > gn)) &&
                  (Tn = (Ut = Ut.replace(" ", ":")).length),
                0 < Pt &&
                  (Mn = at(1, Ut, Yt, zt, Kt, $t, hn.length, Zt, Jt, Zt)) !==
                    void 0 &&
                  (Tn = (Ut = Mn.trim()).length) === 0 &&
                  (Ut = "\0\0"),
                (gn = Ut.charCodeAt(0)),
                (jt = Ut.charCodeAt(1)),
                gn)
              ) {
                case 0:
                  break;
                case 64:
                  if (jt === 105 || jt === 99) {
                    Cn += Ut + qt.charAt(Fn);
                    break;
                  }
                default:
                  Ut.charCodeAt(Tn - 1) !== 58 &&
                    (hn += it(Ut, gn, jt, Ut.charCodeAt(2)));
              }
            (Dn = _n = xn = gn = 0), (Ut = ""), (jt = qt.charCodeAt(++Fn));
        }
      }
      switch (jt) {
        case 13:
        case 10:
          ln === 47
            ? (ln = 0)
            : 1 + gn === 0 &&
              Zt !== 107 &&
              0 < Ut.length &&
              ((_n = 1), (Ut += "\0")),
            0 < Pt * Nt && at(0, Ut, Yt, zt, Kt, $t, hn.length, Zt, Jt, Zt),
            ($t = 1),
            Kt++;
          break;
        case 59:
        case 125:
          if (ln + Bn + bn + mn === 0) {
            $t++;
            break;
          }
        default:
          switch (($t++, (Xt = qt.charAt(Fn)), jt)) {
            case 9:
            case 32:
              if (Bn + mn + ln === 0)
                switch (yn) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    Xt = "";
                    break;
                  default:
                    jt !== 32 && (Xt = " ");
                }
              break;
            case 0:
              Xt = "\\0";
              break;
            case 12:
              Xt = "\\f";
              break;
            case 11:
              Xt = "\\v";
              break;
            case 38:
              Bn + ln + mn === 0 && ((_n = Dn = 1), (Xt = "\f" + Xt));
              break;
            case 108:
              if (Bn + ln + mn + Ht === 0 && 0 < xn)
                switch (Fn - xn) {
                  case 2:
                    yn === 112 && qt.charCodeAt(Fn - 3) === 58 && (Ht = yn);
                  case 8:
                    pn === 111 && (Ht = pn);
                }
              break;
            case 58:
              Bn + ln + mn === 0 && (xn = Fn);
              break;
            case 44:
              ln + bn + Bn + mn === 0 && ((_n = 1), (Xt += "\r"));
              break;
            case 34:
            case 39:
              ln === 0 && (Bn = Bn === jt ? 0 : Bn === 0 ? jt : Bn);
              break;
            case 91:
              Bn + ln + bn === 0 && mn++;
              break;
            case 93:
              Bn + ln + bn === 0 && mn--;
              break;
            case 41:
              Bn + ln + mn === 0 && bn--;
              break;
            case 40:
              if (Bn + ln + mn === 0) {
                if (gn === 0)
                  switch (2 * yn + 3 * pn) {
                    case 533:
                      break;
                    default:
                      gn = 1;
                  }
                bn++;
              }
              break;
            case 64:
              ln + bn + Bn + mn + xn + vn === 0 && (vn = 1);
              break;
            case 42:
            case 47:
              if (!(0 < Bn + mn + bn))
                switch (ln) {
                  case 0:
                    switch (2 * jt + 3 * qt.charCodeAt(Fn + 1)) {
                      case 235:
                        ln = 47;
                        break;
                      case 220:
                        (Tn = Fn), (ln = 42);
                    }
                    break;
                  case 42:
                    jt === 47 &&
                      yn === 42 &&
                      Tn + 2 !== Fn &&
                      (qt.charCodeAt(Tn + 2) === 33 &&
                        (hn += qt.substring(Tn, Fn + 1)),
                      (Xt = ""),
                      (ln = 0));
                }
          }
          ln === 0 && (Ut += Xt);
      }
      (pn = yn), (yn = jt), Fn++;
    }
    if (((Tn = hn.length), 0 < Tn)) {
      if (
        ((_n = Yt),
        0 < Pt &&
          ((Mn = at(2, hn, _n, zt, Kt, $t, Tn, Zt, Jt, Zt)),
          Mn !== void 0 && (hn = Mn).length === 0))
      )
        return Cn + hn + Ln;
      if (((hn = _n.join(",") + "{" + hn + "}"), Wt * Ht !== 0)) {
        switch ((Wt !== 2 || st(hn, 2) || (Ht = 0), Ht)) {
          case 111:
            hn = hn.replace(At, ":-moz-$1") + hn;
            break;
          case 112:
            hn =
              hn.replace(St, "::-webkit-input-$1") +
              hn.replace(St, "::-moz-$1") +
              hn.replace(St, ":-ms-input-$1") +
              hn;
        }
        Ht = 0;
      }
    }
    return Cn + hn + Ln;
  }
  function nt(zt, Yt, qt) {
    var Zt = Yt.trim().split(Et);
    Yt = Zt;
    var Jt = Zt.length,
      mn = zt.length;
    switch (mn) {
      case 0:
      case 1:
        var ln = 0;
        for (zt = mn === 0 ? "" : zt[0] + " "; ln < Jt; ++ln)
          Yt[ln] = rt(zt, Yt[ln], qt).trim();
        break;
      default:
        var bn = (ln = 0);
        for (Yt = []; ln < Jt; ++ln)
          for (var Bn = 0; Bn < mn; ++Bn)
            Yt[bn++] = rt(zt[Bn] + " ", Zt[ln], qt).trim();
    }
    return Yt;
  }
  function rt(zt, Yt, qt) {
    var Zt = Yt.charCodeAt(0);
    switch ((33 > Zt && (Zt = (Yt = Yt.trim()).charCodeAt(0)), Zt)) {
      case 38:
        return Yt.replace(pt, "$1" + zt.trim());
      case 58:
        return zt.trim() + Yt.replace(pt, "$1" + zt.trim());
      default:
        if (0 < 1 * qt && 0 < Yt.indexOf("\f"))
          return Yt.replace(
            pt,
            (zt.charCodeAt(0) === 58 ? "" : "$1") + zt.trim()
          );
    }
    return zt + Yt;
  }
  function it(zt, Yt, qt, Zt) {
    var Jt = zt + ";",
      mn = 2 * Yt + 3 * qt + 4 * Zt;
    if (mn === 944) {
      zt = Jt.indexOf(":", 9) + 1;
      var ln = Jt.substring(zt, Jt.length - 1).trim();
      return (
        (ln = Jt.substring(0, zt).trim() + ln + ";"),
        Wt === 1 || (Wt === 2 && st(ln, 1)) ? "-webkit-" + ln + ln : ln
      );
    }
    if (Wt === 0 || (Wt === 2 && !st(Jt, 1))) return Jt;
    switch (mn) {
      case 1015:
        return Jt.charCodeAt(10) === 97 ? "-webkit-" + Jt + Jt : Jt;
      case 951:
        return Jt.charCodeAt(3) === 116 ? "-webkit-" + Jt + Jt : Jt;
      case 963:
        return Jt.charCodeAt(5) === 110 ? "-webkit-" + Jt + Jt : Jt;
      case 1009:
        if (Jt.charCodeAt(4) !== 100) break;
      case 969:
      case 942:
        return "-webkit-" + Jt + Jt;
      case 978:
        return "-webkit-" + Jt + "-moz-" + Jt + Jt;
      case 1019:
      case 983:
        return "-webkit-" + Jt + "-moz-" + Jt + "-ms-" + Jt + Jt;
      case 883:
        if (Jt.charCodeAt(8) === 45) return "-webkit-" + Jt + Jt;
        if (0 < Jt.indexOf("image-set(", 11))
          return Jt.replace(Vt, "$1-webkit-$2") + Jt;
        break;
      case 932:
        if (Jt.charCodeAt(4) === 45)
          switch (Jt.charCodeAt(5)) {
            case 103:
              return (
                "-webkit-box-" +
                Jt.replace("-grow", "") +
                "-webkit-" +
                Jt +
                "-ms-" +
                Jt.replace("grow", "positive") +
                Jt
              );
            case 115:
              return (
                "-webkit-" + Jt + "-ms-" + Jt.replace("shrink", "negative") + Jt
              );
            case 98:
              return (
                "-webkit-" +
                Jt +
                "-ms-" +
                Jt.replace("basis", "preferred-size") +
                Jt
              );
          }
        return "-webkit-" + Jt + "-ms-" + Jt + Jt;
      case 964:
        return "-webkit-" + Jt + "-ms-flex-" + Jt + Jt;
      case 1023:
        if (Jt.charCodeAt(8) !== 99) break;
        return (
          (ln = Jt.substring(Jt.indexOf(":", 15))
            .replace("flex-", "")
            .replace("space-between", "justify")),
          "-webkit-box-pack" + ln + "-webkit-" + Jt + "-ms-flex-pack" + ln + Jt
        );
      case 1005:
        return vt.test(Jt)
          ? Jt.replace(mt, ":-webkit-") + Jt.replace(mt, ":-moz-") + Jt
          : Jt;
      case 1e3:
        switch (
          ((ln = Jt.substring(13).trim()),
          (Yt = ln.indexOf("-") + 1),
          ln.charCodeAt(0) + ln.charCodeAt(Yt))
        ) {
          case 226:
            ln = Jt.replace(Ct, "tb");
            break;
          case 232:
            ln = Jt.replace(Ct, "tb-rl");
            break;
          case 220:
            ln = Jt.replace(Ct, "lr");
            break;
          default:
            return Jt;
        }
        return "-webkit-" + Jt + "-ms-" + ln + Jt;
      case 1017:
        if (Jt.indexOf("sticky", 9) === -1) break;
      case 975:
        switch (
          ((Yt = (Jt = zt).length - 10),
          (ln = (Jt.charCodeAt(Yt) === 33 ? Jt.substring(0, Yt) : Jt)
            .substring(zt.indexOf(":", 7) + 1)
            .trim()),
          (mn = ln.charCodeAt(0) + (ln.charCodeAt(7) | 0)))
        ) {
          case 203:
            if (111 > ln.charCodeAt(8)) break;
          case 115:
            Jt = Jt.replace(ln, "-webkit-" + ln) + ";" + Jt;
            break;
          case 207:
          case 102:
            Jt =
              Jt.replace(ln, "-webkit-" + (102 < mn ? "inline-" : "") + "box") +
              ";" +
              Jt.replace(ln, "-webkit-" + ln) +
              ";" +
              Jt.replace(ln, "-ms-" + ln + "box") +
              ";" +
              Jt;
        }
        return Jt + ";";
      case 938:
        if (Jt.charCodeAt(5) === 45)
          switch (Jt.charCodeAt(6)) {
            case 105:
              return (
                (ln = Jt.replace("-items", "")),
                "-webkit-" + Jt + "-webkit-box-" + ln + "-ms-flex-" + ln + Jt
              );
            case 115:
              return (
                "-webkit-" + Jt + "-ms-flex-item-" + Jt.replace(Bt, "") + Jt
              );
            default:
              return (
                "-webkit-" +
                Jt +
                "-ms-flex-line-pack" +
                Jt.replace("align-content", "").replace(Bt, "") +
                Jt
              );
          }
        break;
      case 973:
      case 989:
        if (Jt.charCodeAt(3) !== 45 || Jt.charCodeAt(4) === 122) break;
      case 931:
      case 953:
        if (Ft.test(zt) === !0)
          return (ln = zt.substring(zt.indexOf(":") + 1)).charCodeAt(0) === 115
            ? it(zt.replace("stretch", "fill-available"), Yt, qt, Zt).replace(
                ":fill-available",
                ":stretch"
              )
            : Jt.replace(ln, "-webkit-" + ln) +
                Jt.replace(ln, "-moz-" + ln.replace("fill-", "")) +
                Jt;
        break;
      case 962:
        if (
          ((Jt =
            "-webkit-" +
            Jt +
            (Jt.charCodeAt(5) === 102 ? "-ms-" + Jt : "") +
            Jt),
          qt + Zt === 211 &&
            Jt.charCodeAt(13) === 105 &&
            0 < Jt.indexOf("transform", 10))
        )
          return (
            Jt.substring(0, Jt.indexOf(";", 27) + 1).replace(
              yt,
              "$1-webkit-$2"
            ) + Jt
          );
    }
    return Jt;
  }
  function st(zt, Yt) {
    var qt = zt.indexOf(Yt === 1 ? ":" : "{"),
      Zt = zt.substring(0, Yt !== 3 ? qt : 10);
    return (
      (qt = zt.substring(qt + 1, zt.length - 1)),
      Rt(Yt !== 2 ? Zt : Zt.replace(It, "$1"), qt, Yt)
    );
  }
  function ot(zt, Yt) {
    var qt = it(Yt, Yt.charCodeAt(0), Yt.charCodeAt(1), Yt.charCodeAt(2));
    return qt !== Yt + ";"
      ? qt.replace(wt, " or ($1)").substring(4)
      : "(" + Yt + ")";
  }
  function at(zt, Yt, qt, Zt, Jt, mn, ln, bn, Bn, gn) {
    for (var jt = 0, yn = Yt, pn; jt < Pt; ++jt)
      switch ((pn = Gt[jt].call(ut, zt, yn, qt, Zt, Jt, mn, ln, bn, Bn, gn))) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          yn = pn;
      }
    if (yn !== Yt) return yn;
  }
  function lt(zt) {
    switch (zt) {
      case void 0:
      case null:
        Pt = Gt.length = 0;
        break;
      default:
        if (typeof zt == "function") Gt[Pt++] = zt;
        else if (typeof zt == "object")
          for (var Yt = 0, qt = zt.length; Yt < qt; ++Yt) lt(zt[Yt]);
        else Nt = !!zt | 0;
    }
    return lt;
  }
  function ct(zt) {
    return (
      (zt = zt.prefix),
      zt !== void 0 &&
        ((Rt = null),
        zt
          ? typeof zt != "function"
            ? (Wt = 1)
            : ((Wt = 2), (Rt = zt))
          : (Wt = 0)),
      ct
    );
  }
  function ut(zt, Yt) {
    var qt = zt;
    if (
      (33 > qt.charCodeAt(0) && (qt = qt.trim()),
      (Dt = qt),
      (qt = [Dt]),
      0 < Pt)
    ) {
      var Zt = at(-1, Yt, qt, qt, Kt, $t, 0, 0, 0, 0);
      Zt !== void 0 && typeof Zt == "string" && (Yt = Zt);
    }
    var Jt = et(kt, qt, Yt, 0, 0);
    return (
      0 < Pt &&
        ((Zt = at(-2, Jt, qt, qt, Kt, $t, Jt.length, 0, 0, 0)),
        Zt !== void 0 && (Jt = Zt)),
      (Dt = ""),
      (Ht = 0),
      ($t = Kt = 1),
      Jt
    );
  }
  var ft = /^\0+/g,
    ht = /[\0\r\f]/g,
    mt = /: */g,
    vt = /zoo|gra/,
    yt = /([,: ])(transform)/g,
    Et = /,\r+?/g,
    pt = /([\t\r\n ])*\f?&/g,
    xt = /@(k\w+)\s*(\S*)\s*/,
    St = /::(place)/g,
    At = /:(read-only)/g,
    Ct = /[svh]\w+-[tblr]{2}/,
    Mt = /\(\s*(.*)\s*\)/g,
    wt = /([\s\S]*?);/g,
    Bt = /-self|flex-/g,
    It = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
    Ft = /stretch|:\s*\w+\-(?:conte|avail)/,
    Vt = /([^-])(image-set\()/,
    $t = 1,
    Kt = 1,
    Ht = 0,
    Wt = 1,
    kt = [],
    Gt = [],
    Pt = 0,
    Rt = null,
    Nt = 0,
    Dt = "";
  return (ut.use = lt), (ut.set = ct), tt !== void 0 && ct(tt), ut;
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
};
function y() {
  return (y =
    Object.assign ||
    function (tt) {
      for (var et = 1; et < arguments.length; et++) {
        var nt = arguments[et];
        for (var rt in nt)
          Object.prototype.hasOwnProperty.call(nt, rt) && (tt[rt] = nt[rt]);
      }
      return tt;
    }).apply(this, arguments);
}
var v = function (tt, et) {
    for (var nt = [tt[0]], rt = 0, it = et.length; rt < it; rt += 1)
      nt.push(et[rt], tt[rt + 1]);
    return nt;
  },
  g = function (tt) {
    return (
      tt !== null &&
      typeof tt == "object" &&
      (tt.toString ? tt.toString() : Object.prototype.toString.call(tt)) ===
        "[object Object]" &&
      !reactIsExports.typeOf(tt)
    );
  },
  S = Object.freeze([]),
  w = Object.freeze({});
function E(tt) {
  return typeof tt == "function";
}
function b(tt) {
  return tt.displayName || tt.name || "Component";
}
function _(tt) {
  return tt && typeof tt.styledComponentId == "string";
}
var N =
    (typeof process < "u" &&
      process.env !== void 0 &&
      ({}.REACT_APP_SC_ATTR || {}.SC_ATTR)) ||
    "data-styled",
  C = typeof window < "u" && "HTMLElement" in window,
  I = !!(typeof SC_DISABLE_SPEEDY == "boolean"
    ? SC_DISABLE_SPEEDY
    : typeof process < "u" &&
      process.env !== void 0 &&
      ({}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
      {}.REACT_APP_SC_DISABLE_SPEEDY !== ""
        ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" &&
          {}.REACT_APP_SC_DISABLE_SPEEDY
        : {}.SC_DISABLE_SPEEDY !== void 0 &&
          {}.SC_DISABLE_SPEEDY !== "" &&
          {}.SC_DISABLE_SPEEDY !== "false" &&
          {}.SC_DISABLE_SPEEDY));
function D(tt) {
  for (
    var et = arguments.length, nt = new Array(et > 1 ? et - 1 : 0), rt = 1;
    rt < et;
    rt++
  )
    nt[rt - 1] = arguments[rt];
  throw new Error(
    "An error occurred. See https://git.io/JUIaE#" +
      tt +
      " for more information." +
      (nt.length > 0 ? " Args: " + nt.join(", ") : "")
  );
}
var j = (function () {
    function tt(nt) {
      (this.groupSizes = new Uint32Array(512)),
        (this.length = 512),
        (this.tag = nt);
    }
    var et = tt.prototype;
    return (
      (et.indexOfGroup = function (nt) {
        for (var rt = 0, it = 0; it < nt; it++) rt += this.groupSizes[it];
        return rt;
      }),
      (et.insertRules = function (nt, rt) {
        if (nt >= this.groupSizes.length) {
          for (var it = this.groupSizes, st = it.length, ot = st; nt >= ot; )
            (ot <<= 1) < 0 && D(16, "" + nt);
          (this.groupSizes = new Uint32Array(ot)),
            this.groupSizes.set(it),
            (this.length = ot);
          for (var at = st; at < ot; at++) this.groupSizes[at] = 0;
        }
        for (
          var lt = this.indexOfGroup(nt + 1), ct = 0, ut = rt.length;
          ct < ut;
          ct++
        )
          this.tag.insertRule(lt, rt[ct]) && (this.groupSizes[nt]++, lt++);
      }),
      (et.clearGroup = function (nt) {
        if (nt < this.length) {
          var rt = this.groupSizes[nt],
            it = this.indexOfGroup(nt),
            st = it + rt;
          this.groupSizes[nt] = 0;
          for (var ot = it; ot < st; ot++) this.tag.deleteRule(it);
        }
      }),
      (et.getGroup = function (nt) {
        var rt = "";
        if (nt >= this.length || this.groupSizes[nt] === 0) return rt;
        for (
          var it = this.groupSizes[nt],
            st = this.indexOfGroup(nt),
            ot = st + it,
            at = st;
          at < ot;
          at++
        )
          rt +=
            this.tag.getRule(at) +
            `/*!sc*/
`;
        return rt;
      }),
      tt
    );
  })(),
  T = new Map(),
  x = new Map(),
  k = 1,
  V = function (tt) {
    if (T.has(tt)) return T.get(tt);
    for (; x.has(k); ) k++;
    var et = k++;
    return T.set(tt, et), x.set(et, tt), et;
  },
  B = function (tt) {
    return x.get(tt);
  },
  z = function (tt, et) {
    et >= k && (k = et + 1), T.set(tt, et), x.set(et, tt);
  },
  M = "style[" + N + '][data-styled-version="5.3.11"]',
  G = new RegExp("^" + N + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
  L = function (tt, et, nt) {
    for (var rt, it = nt.split(","), st = 0, ot = it.length; st < ot; st++)
      (rt = it[st]) && tt.registerName(et, rt);
  },
  F = function (tt, et) {
    for (
      var nt = (et.textContent || "").split(`/*!sc*/
`),
        rt = [],
        it = 0,
        st = nt.length;
      it < st;
      it++
    ) {
      var ot = nt[it].trim();
      if (ot) {
        var at = ot.match(G);
        if (at) {
          var lt = 0 | parseInt(at[1], 10),
            ct = at[2];
          lt !== 0 &&
            (z(ct, lt), L(tt, ct, at[3]), tt.getTag().insertRules(lt, rt)),
            (rt.length = 0);
        } else rt.push(ot);
      }
    }
  },
  Y = function () {
    return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
  },
  q = function (tt) {
    var et = document.head,
      nt = tt || et,
      rt = document.createElement("style"),
      it = (function (at) {
        for (var lt = at.childNodes, ct = lt.length; ct >= 0; ct--) {
          var ut = lt[ct];
          if (ut && ut.nodeType === 1 && ut.hasAttribute(N)) return ut;
        }
      })(nt),
      st = it !== void 0 ? it.nextSibling : null;
    rt.setAttribute(N, "active"),
      rt.setAttribute("data-styled-version", "5.3.11");
    var ot = Y();
    return ot && rt.setAttribute("nonce", ot), nt.insertBefore(rt, st), rt;
  },
  H = (function () {
    function tt(nt) {
      var rt = (this.element = q(nt));
      rt.appendChild(document.createTextNode("")),
        (this.sheet = (function (it) {
          if (it.sheet) return it.sheet;
          for (
            var st = document.styleSheets, ot = 0, at = st.length;
            ot < at;
            ot++
          ) {
            var lt = st[ot];
            if (lt.ownerNode === it) return lt;
          }
          D(17);
        })(rt)),
        (this.length = 0);
    }
    var et = tt.prototype;
    return (
      (et.insertRule = function (nt, rt) {
        try {
          return this.sheet.insertRule(rt, nt), this.length++, !0;
        } catch {
          return !1;
        }
      }),
      (et.deleteRule = function (nt) {
        this.sheet.deleteRule(nt), this.length--;
      }),
      (et.getRule = function (nt) {
        var rt = this.sheet.cssRules[nt];
        return rt !== void 0 && typeof rt.cssText == "string" ? rt.cssText : "";
      }),
      tt
    );
  })(),
  $ = (function () {
    function tt(nt) {
      var rt = (this.element = q(nt));
      (this.nodes = rt.childNodes), (this.length = 0);
    }
    var et = tt.prototype;
    return (
      (et.insertRule = function (nt, rt) {
        if (nt <= this.length && nt >= 0) {
          var it = document.createTextNode(rt),
            st = this.nodes[nt];
          return this.element.insertBefore(it, st || null), this.length++, !0;
        }
        return !1;
      }),
      (et.deleteRule = function (nt) {
        this.element.removeChild(this.nodes[nt]), this.length--;
      }),
      (et.getRule = function (nt) {
        return nt < this.length ? this.nodes[nt].textContent : "";
      }),
      tt
    );
  })(),
  W = (function () {
    function tt(nt) {
      (this.rules = []), (this.length = 0);
    }
    var et = tt.prototype;
    return (
      (et.insertRule = function (nt, rt) {
        return (
          nt <= this.length && (this.rules.splice(nt, 0, rt), this.length++, !0)
        );
      }),
      (et.deleteRule = function (nt) {
        this.rules.splice(nt, 1), this.length--;
      }),
      (et.getRule = function (nt) {
        return nt < this.length ? this.rules[nt] : "";
      }),
      tt
    );
  })(),
  U = C,
  J = { isServer: !C, useCSSOMInjection: !I },
  X = (function () {
    function tt(nt, rt, it) {
      nt === void 0 && (nt = w),
        rt === void 0 && (rt = {}),
        (this.options = y({}, J, {}, nt)),
        (this.gs = rt),
        (this.names = new Map(it)),
        (this.server = !!nt.isServer),
        !this.server &&
          C &&
          U &&
          ((U = !1),
          (function (st) {
            for (
              var ot = document.querySelectorAll(M), at = 0, lt = ot.length;
              at < lt;
              at++
            ) {
              var ct = ot[at];
              ct &&
                ct.getAttribute(N) !== "active" &&
                (F(st, ct), ct.parentNode && ct.parentNode.removeChild(ct));
            }
          })(this));
    }
    tt.registerId = function (nt) {
      return V(nt);
    };
    var et = tt.prototype;
    return (
      (et.reconstructWithOptions = function (nt, rt) {
        return (
          rt === void 0 && (rt = !0),
          new tt(
            y({}, this.options, {}, nt),
            this.gs,
            (rt && this.names) || void 0
          )
        );
      }),
      (et.allocateGSInstance = function (nt) {
        return (this.gs[nt] = (this.gs[nt] || 0) + 1);
      }),
      (et.getTag = function () {
        return (
          this.tag ||
          (this.tag =
            ((it = (rt = this.options).isServer),
            (st = rt.useCSSOMInjection),
            (ot = rt.target),
            (nt = it ? new W(ot) : st ? new H(ot) : new $(ot)),
            new j(nt)))
        );
        var nt, rt, it, st, ot;
      }),
      (et.hasNameForId = function (nt, rt) {
        return this.names.has(nt) && this.names.get(nt).has(rt);
      }),
      (et.registerName = function (nt, rt) {
        if ((V(nt), this.names.has(nt))) this.names.get(nt).add(rt);
        else {
          var it = new Set();
          it.add(rt), this.names.set(nt, it);
        }
      }),
      (et.insertRules = function (nt, rt, it) {
        this.registerName(nt, rt), this.getTag().insertRules(V(nt), it);
      }),
      (et.clearNames = function (nt) {
        this.names.has(nt) && this.names.get(nt).clear();
      }),
      (et.clearRules = function (nt) {
        this.getTag().clearGroup(V(nt)), this.clearNames(nt);
      }),
      (et.clearTag = function () {
        this.tag = void 0;
      }),
      (et.toString = function () {
        return (function (nt) {
          for (
            var rt = nt.getTag(), it = rt.length, st = "", ot = 0;
            ot < it;
            ot++
          ) {
            var at = B(ot);
            if (at !== void 0) {
              var lt = nt.names.get(at),
                ct = rt.getGroup(ot);
              if (lt && ct && lt.size) {
                var ut = N + ".g" + ot + '[id="' + at + '"]',
                  ft = "";
                lt !== void 0 &&
                  lt.forEach(function (ht) {
                    ht.length > 0 && (ft += ht + ",");
                  }),
                  (st +=
                    "" +
                    ct +
                    ut +
                    '{content:"' +
                    ft +
                    `"}/*!sc*/
`);
              }
            }
          }
          return st;
        })(this);
      }),
      tt
    );
  })(),
  Z = /(a)(d)/gi,
  K = function (tt) {
    return String.fromCharCode(tt + (tt > 25 ? 39 : 97));
  };
function Q(tt) {
  var et,
    nt = "";
  for (et = Math.abs(tt); et > 52; et = (et / 52) | 0) nt = K(et % 52) + nt;
  return (K(et % 52) + nt).replace(Z, "$1-$2");
}
var ee = function (tt, et) {
    for (var nt = et.length; nt; ) tt = (33 * tt) ^ et.charCodeAt(--nt);
    return tt;
  },
  te = function (tt) {
    return ee(5381, tt);
  };
function ne(tt) {
  for (var et = 0; et < tt.length; et += 1) {
    var nt = tt[et];
    if (E(nt) && !_(nt)) return !1;
  }
  return !0;
}
var re = te("5.3.11"),
  oe = (function () {
    function tt(et, nt, rt) {
      (this.rules = et),
        (this.staticRulesId = ""),
        (this.isStatic = (rt === void 0 || rt.isStatic) && ne(et)),
        (this.componentId = nt),
        (this.baseHash = ee(re, nt)),
        (this.baseStyle = rt),
        X.registerId(nt);
    }
    return (
      (tt.prototype.generateAndInjectStyles = function (et, nt, rt) {
        var it = this.componentId,
          st = [];
        if (
          (this.baseStyle &&
            st.push(this.baseStyle.generateAndInjectStyles(et, nt, rt)),
          this.isStatic && !rt.hash)
        )
          if (this.staticRulesId && nt.hasNameForId(it, this.staticRulesId))
            st.push(this.staticRulesId);
          else {
            var ot = _e(this.rules, et, nt, rt).join(""),
              at = Q(ee(this.baseHash, ot) >>> 0);
            if (!nt.hasNameForId(it, at)) {
              var lt = rt(ot, "." + at, void 0, it);
              nt.insertRules(it, at, lt);
            }
            st.push(at), (this.staticRulesId = at);
          }
        else {
          for (
            var ct = this.rules.length,
              ut = ee(this.baseHash, rt.hash),
              ft = "",
              ht = 0;
            ht < ct;
            ht++
          ) {
            var mt = this.rules[ht];
            if (typeof mt == "string") ft += mt;
            else if (mt) {
              var vt = _e(mt, et, nt, rt),
                yt = Array.isArray(vt) ? vt.join("") : vt;
              (ut = ee(ut, yt + ht)), (ft += yt);
            }
          }
          if (ft) {
            var Et = Q(ut >>> 0);
            if (!nt.hasNameForId(it, Et)) {
              var pt = rt(ft, "." + Et, void 0, it);
              nt.insertRules(it, Et, pt);
            }
            st.push(Et);
          }
        }
        return st.join(" ");
      }),
      tt
    );
  })(),
  se = /^\s*\/\/.*$/gm,
  ie = [":", "[", ".", "#"];
function ae(tt) {
  var et,
    nt,
    rt,
    it,
    st = tt === void 0 ? w : tt,
    ot = st.options,
    at = ot === void 0 ? w : ot,
    lt = st.plugins,
    ct = lt === void 0 ? S : lt,
    ut = new stylis_min(at),
    ft = [],
    ht = (function (yt) {
      function Et(pt) {
        if (pt)
          try {
            yt(pt + "}");
          } catch {}
      }
      return function (pt, xt, St, At, Ct, Mt, wt, Bt, It, Ft) {
        switch (pt) {
          case 1:
            if (It === 0 && xt.charCodeAt(0) === 64) return yt(xt + ";"), "";
            break;
          case 2:
            if (Bt === 0) return xt + "/*|*/";
            break;
          case 3:
            switch (Bt) {
              case 102:
              case 112:
                return yt(St[0] + xt), "";
              default:
                return xt + (Ft === 0 ? "/*|*/" : "");
            }
          case -2:
            xt.split("/*|*/}").forEach(Et);
        }
      };
    })(function (yt) {
      ft.push(yt);
    }),
    mt = function (yt, Et, pt) {
      return (Et === 0 && ie.indexOf(pt[nt.length]) !== -1) || pt.match(it)
        ? yt
        : "." + et;
    };
  function vt(yt, Et, pt, xt) {
    xt === void 0 && (xt = "&");
    var St = yt.replace(se, ""),
      At = Et && pt ? pt + " " + Et + " { " + St + " }" : St;
    return (
      (et = xt),
      (nt = Et),
      (rt = new RegExp("\\" + nt + "\\b", "g")),
      (it = new RegExp("(\\" + nt + "\\b){2,}")),
      ut(pt || !Et ? "" : Et, At)
    );
  }
  return (
    ut.use(
      [].concat(ct, [
        function (yt, Et, pt) {
          yt === 2 &&
            pt.length &&
            pt[0].lastIndexOf(nt) > 0 &&
            (pt[0] = pt[0].replace(rt, mt));
        },
        ht,
        function (yt) {
          if (yt === -2) {
            var Et = ft;
            return (ft = []), Et;
          }
        },
      ])
    ),
    (vt.hash = ct.length
      ? ct
          .reduce(function (yt, Et) {
            return Et.name || D(15), ee(yt, Et.name);
          }, 5381)
          .toString()
      : ""),
    vt
  );
}
var ce = React.createContext();
ce.Consumer;
var le = React.createContext(),
  de = (le.Consumer, new X()),
  he = ae();
function pe() {
  return reactExports.useContext(ce) || de;
}
function fe() {
  return reactExports.useContext(le) || he;
}
var ye = (function () {
    function tt(et, nt) {
      var rt = this;
      (this.inject = function (it, st) {
        st === void 0 && (st = he);
        var ot = rt.name + st.hash;
        it.hasNameForId(rt.id, ot) ||
          it.insertRules(rt.id, ot, st(rt.rules, ot, "@keyframes"));
      }),
        (this.toString = function () {
          return D(12, String(rt.name));
        }),
        (this.name = et),
        (this.id = "sc-keyframes-" + et),
        (this.rules = nt);
    }
    return (
      (tt.prototype.getName = function (et) {
        return et === void 0 && (et = he), this.name + et.hash;
      }),
      tt
    );
  })(),
  ve = /([A-Z])/,
  ge = /([A-Z])/g,
  Se = /^ms-/,
  we = function (tt) {
    return "-" + tt.toLowerCase();
  };
function Ee(tt) {
  return ve.test(tt) ? tt.replace(ge, we).replace(Se, "-ms-") : tt;
}
var be = function (tt) {
  return tt == null || tt === !1 || tt === "";
};
function _e(tt, et, nt, rt) {
  if (Array.isArray(tt)) {
    for (var it, st = [], ot = 0, at = tt.length; ot < at; ot += 1)
      (it = _e(tt[ot], et, nt, rt)) !== "" &&
        (Array.isArray(it) ? st.push.apply(st, it) : st.push(it));
    return st;
  }
  if (be(tt)) return "";
  if (_(tt)) return "." + tt.styledComponentId;
  if (E(tt)) {
    if (
      typeof (ct = tt) != "function" ||
      (ct.prototype && ct.prototype.isReactComponent) ||
      !et
    )
      return tt;
    var lt = tt(et);
    return _e(lt, et, nt, rt);
  }
  var ct;
  return tt instanceof ye
    ? nt
      ? (tt.inject(nt, rt), tt.getName(rt))
      : tt
    : g(tt)
    ? (function ut(ft, ht) {
        var mt,
          vt,
          yt = [];
        for (var Et in ft)
          ft.hasOwnProperty(Et) &&
            !be(ft[Et]) &&
            ((Array.isArray(ft[Et]) && ft[Et].isCss) || E(ft[Et])
              ? yt.push(Ee(Et) + ":", ft[Et], ";")
              : g(ft[Et])
              ? yt.push.apply(yt, ut(ft[Et], Et))
              : yt.push(
                  Ee(Et) +
                    ": " +
                    ((mt = Et),
                    (vt = ft[Et]) == null || typeof vt == "boolean" || vt === ""
                      ? ""
                      : typeof vt != "number" ||
                        vt === 0 ||
                        mt in unitlessKeys ||
                        mt.startsWith("--")
                      ? String(vt).trim()
                      : vt + "px") +
                    ";"
                ));
        return ht ? [ht + " {"].concat(yt, ["}"]) : yt;
      })(tt)
    : tt.toString();
}
var Ne = function (tt) {
  return Array.isArray(tt) && (tt.isCss = !0), tt;
};
function Ae(tt) {
  for (
    var et = arguments.length, nt = new Array(et > 1 ? et - 1 : 0), rt = 1;
    rt < et;
    rt++
  )
    nt[rt - 1] = arguments[rt];
  return E(tt) || g(tt)
    ? Ne(_e(v(S, [tt].concat(nt))))
    : nt.length === 0 && tt.length === 1 && typeof tt[0] == "string"
    ? tt
    : Ne(_e(v(tt, nt)));
}
var Oe = function (tt, et, nt) {
    return (
      nt === void 0 && (nt = w),
      (tt.theme !== nt.theme && tt.theme) || et || nt.theme
    );
  },
  Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  De = /(^-|-$)/g;
function je(tt) {
  return tt.replace(Re, "-").replace(De, "");
}
var Te = function (tt) {
  return Q(te(tt) >>> 0);
};
function xe(tt) {
  return typeof tt == "string" && !0;
}
var ke = function (tt) {
    return (
      typeof tt == "function" ||
      (typeof tt == "object" && tt !== null && !Array.isArray(tt))
    );
  },
  Ve = function (tt) {
    return tt !== "__proto__" && tt !== "constructor" && tt !== "prototype";
  };
function Be(tt, et, nt) {
  var rt = tt[nt];
  ke(et) && ke(rt) ? ze(rt, et) : (tt[nt] = et);
}
function ze(tt) {
  for (
    var et = arguments.length, nt = new Array(et > 1 ? et - 1 : 0), rt = 1;
    rt < et;
    rt++
  )
    nt[rt - 1] = arguments[rt];
  for (var it = 0, st = nt; it < st.length; it++) {
    var ot = st[it];
    if (ke(ot)) for (var at in ot) Ve(at) && Be(tt, ot[at], at);
  }
  return tt;
}
var Me = React.createContext();
Me.Consumer;
var Fe = {};
function Ye(tt, et, nt) {
  var rt = _(tt),
    it = !xe(tt),
    st = et.attrs,
    ot = st === void 0 ? S : st,
    at = et.componentId,
    lt =
      at === void 0
        ? (function (xt, St) {
            var At = typeof xt != "string" ? "sc" : je(xt);
            Fe[At] = (Fe[At] || 0) + 1;
            var Ct = At + "-" + Te("5.3.11" + At + Fe[At]);
            return St ? St + "-" + Ct : Ct;
          })(et.displayName, et.parentComponentId)
        : at,
    ct = et.displayName,
    ut =
      ct === void 0
        ? (function (xt) {
            return xe(xt) ? "styled." + xt : "Styled(" + b(xt) + ")";
          })(tt)
        : ct,
    ft =
      et.displayName && et.componentId
        ? je(et.displayName) + "-" + et.componentId
        : et.componentId || lt,
    ht =
      rt && tt.attrs
        ? Array.prototype.concat(tt.attrs, ot).filter(Boolean)
        : ot,
    mt = et.shouldForwardProp;
  rt &&
    tt.shouldForwardProp &&
    (mt = et.shouldForwardProp
      ? function (xt, St, At) {
          return (
            tt.shouldForwardProp(xt, St, At) && et.shouldForwardProp(xt, St, At)
          );
        }
      : tt.shouldForwardProp);
  var vt,
    yt = new oe(nt, ft, rt ? tt.componentStyle : void 0),
    Et = yt.isStatic && ot.length === 0,
    pt = function (xt, St) {
      return (function (At, Ct, Mt, wt) {
        var Bt = At.attrs,
          It = At.componentStyle,
          Ft = At.defaultProps,
          Vt = At.foldedComponentIds,
          $t = At.shouldForwardProp,
          Kt = At.styledComponentId,
          Ht = At.target,
          Wt = (function (Zt, Jt, mn) {
            Zt === void 0 && (Zt = w);
            var ln = y({}, Jt, { theme: Zt }),
              bn = {};
            return (
              mn.forEach(function (Bn) {
                var gn,
                  jt,
                  yn,
                  pn = Bn;
                for (gn in (E(pn) && (pn = pn(ln)), pn))
                  ln[gn] = bn[gn] =
                    gn === "className"
                      ? ((jt = bn[gn]),
                        (yn = pn[gn]),
                        jt && yn ? jt + " " + yn : jt || yn)
                      : pn[gn];
              }),
              [ln, bn]
            );
          })(Oe(Ct, reactExports.useContext(Me), Ft) || w, Ct, Bt),
          kt = Wt[0],
          Gt = Wt[1],
          Pt = (function (Zt, Jt, mn, ln) {
            var bn = pe(),
              Bn = fe(),
              gn = Jt
                ? Zt.generateAndInjectStyles(w, bn, Bn)
                : Zt.generateAndInjectStyles(mn, bn, Bn);
            return gn;
          })(It, wt, kt),
          Rt = Mt,
          Nt = Gt.$as || Ct.$as || Gt.as || Ct.as || Ht,
          Dt = xe(Nt),
          zt = Gt !== Ct ? y({}, Ct, {}, Gt) : Ct,
          Yt = {};
        for (var qt in zt)
          qt[0] !== "$" &&
            qt !== "as" &&
            (qt === "forwardedAs"
              ? (Yt.as = zt[qt])
              : ($t ? $t(qt, isPropValid, Nt) : !Dt || isPropValid(qt)) &&
                (Yt[qt] = zt[qt]));
        return (
          Ct.style &&
            Gt.style !== Ct.style &&
            (Yt.style = y({}, Ct.style, {}, Gt.style)),
          (Yt.className = Array.prototype
            .concat(Vt, Kt, Pt !== Kt ? Pt : null, Ct.className, Gt.className)
            .filter(Boolean)
            .join(" ")),
          (Yt.ref = Rt),
          reactExports.createElement(Nt, Yt)
        );
      })(vt, xt, St, Et);
    };
  return (
    (pt.displayName = ut),
    ((vt = React.forwardRef(pt)).attrs = ht),
    (vt.componentStyle = yt),
    (vt.displayName = ut),
    (vt.shouldForwardProp = mt),
    (vt.foldedComponentIds = rt
      ? Array.prototype.concat(tt.foldedComponentIds, tt.styledComponentId)
      : S),
    (vt.styledComponentId = ft),
    (vt.target = rt ? tt.target : tt),
    (vt.withComponent = function (xt) {
      var St = et.componentId,
        At = (function (Mt, wt) {
          if (Mt == null) return {};
          var Bt,
            It,
            Ft = {},
            Vt = Object.keys(Mt);
          for (It = 0; It < Vt.length; It++)
            (Bt = Vt[It]), wt.indexOf(Bt) >= 0 || (Ft[Bt] = Mt[Bt]);
          return Ft;
        })(et, ["componentId"]),
        Ct = St && St + "-" + (xe(xt) ? xt : je(b(xt)));
      return Ye(xt, y({}, At, { attrs: ht, componentId: Ct }), nt);
    }),
    Object.defineProperty(vt, "defaultProps", {
      get: function () {
        return this._foldedDefaultProps;
      },
      set: function (xt) {
        this._foldedDefaultProps = rt ? ze({}, tt.defaultProps, xt) : xt;
      },
    }),
    Object.defineProperty(vt, "toString", {
      value: function () {
        return "." + vt.styledComponentId;
      },
    }),
    it &&
      m$3(vt, tt, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
        withComponent: !0,
      }),
    vt
  );
}
var qe = function (tt) {
  return (function et(nt, rt, it) {
    if ((it === void 0 && (it = w), !reactIsExports.isValidElementType(rt)))
      return D(1, String(rt));
    var st = function () {
      return nt(rt, it, Ae.apply(void 0, arguments));
    };
    return (
      (st.withConfig = function (ot) {
        return et(nt, rt, y({}, it, {}, ot));
      }),
      (st.attrs = function (ot) {
        return et(
          nt,
          rt,
          y({}, it, {
            attrs: Array.prototype.concat(it.attrs, ot).filter(Boolean),
          })
        );
      }),
      st
    );
  })(Ye, tt);
};
[
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "textPath",
  "tspan",
].forEach(function (tt) {
  qe[tt] = qe(tt);
});
function We(tt) {
  for (
    var et = arguments.length, nt = new Array(et > 1 ? et - 1 : 0), rt = 1;
    rt < et;
    rt++
  )
    nt[rt - 1] = arguments[rt];
  var it = Ae.apply(void 0, [tt].concat(nt)).join(""),
    st = Te(it);
  return new ye(st, it);
}
const styled = qe;
var __makeTemplateObject$2 =
    (globalThis && globalThis.__makeTemplateObject) ||
    function (tt, et) {
      return (
        Object.defineProperty
          ? Object.defineProperty(tt, "raw", { value: et })
          : (tt.raw = et),
        tt
      );
    },
  len = 242.776657104492,
  time = 1.6,
  anim = We(
    templateObject_1$2 ||
      (templateObject_1$2 = __makeTemplateObject$2(
        [
          `
  12.5% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
  43.75% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
  100% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
`,
        ],
        [
          `
  12.5% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
  43.75% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
  100% {
    stroke-dasharray: `,
          "px, ",
          `px;
    stroke-dashoffset: -`,
          `px;
  }
`,
        ]
      )),
    len * 0.14,
    len,
    len * 0.11,
    len * 0.35,
    len,
    len * 0.35,
    len * 0.01,
    len,
    len * 0.99
  );
styled.path(
  templateObject_2$2 ||
    (templateObject_2$2 = __makeTemplateObject$2(
      [
        `
  stroke-dasharray: `,
        "px, ",
        `;
  stroke-dashoffset: 0;
  animation: `,
        " ",
        `s linear infinite;
`,
      ],
      [
        `
  stroke-dasharray: `,
        "px, ",
        `;
  stroke-dashoffset: 0;
  animation: `,
        " ",
        `s linear infinite;
`,
      ]
    )),
  len * 0.01,
  len,
  anim,
  time
);
var templateObject_1$2,
  templateObject_2$2,
  __assign$p =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$p =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$p.apply(this, arguments)
      );
    },
  __assign$o =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$o =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$o.apply(this, arguments)
      );
    },
  __assign$n =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$n =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$n.apply(this, arguments)
      );
    },
  RADIUS = 20,
  getPath = function (tt) {
    return ["M" + tt + " 0c0-9.94-8.06", tt, tt, tt].join("-");
  },
  getViewBoxSize = function (tt, et, nt) {
    var rt = Math.max(tt, et),
      it = -nt - rt / 2 + 1,
      st = nt * 2 + rt;
    return [it, it, st, st].join(" ");
  },
  Oval = function (tt) {
    var et = tt.height,
      nt = et === void 0 ? 80 : et,
      rt = tt.width,
      it = rt === void 0 ? 80 : rt,
      st = tt.color,
      ot = st === void 0 ? DEFAULT_COLOR : st,
      at = tt.secondaryColor,
      lt = at === void 0 ? DEFAULT_COLOR : at,
      ct = tt.ariaLabel,
      ut = ct === void 0 ? "oval-loading" : ct,
      ft = tt.wrapperStyle,
      ht = tt.wrapperClass,
      mt = tt.visible,
      vt = mt === void 0 ? !0 : mt,
      yt = tt.strokeWidth,
      Et = yt === void 0 ? 2 : yt,
      pt = tt.strokeWidthSecondary;
    return React.createElement(
      "div",
      __assign$n(
        {
          style: __assign$n(__assign$n({}, getDefaultStyle(vt)), ft),
          className: ht,
          "data-testid": "oval-loading",
          "aria-label": ut,
        },
        DEFAULT_WAI_ARIA_ATTRIBUTE
      ),
      React.createElement(
        "svg",
        {
          width: it,
          height: nt,
          viewBox: getViewBoxSize(Number(Et), Number(pt || Et), RADIUS),
          xmlns: "http://www.w3.org/2000/svg",
          stroke: ot,
          "data-testid": "oval-svg",
        },
        React.createElement(
          "g",
          { fill: "none", fillRule: "evenodd" },
          React.createElement(
            "g",
            {
              transform: "translate(1 1)",
              strokeWidth: Number(pt || Et),
              "data-testid": "oval-secondary-group",
            },
            React.createElement("circle", {
              strokeOpacity: ".5",
              cx: "0",
              cy: "0",
              r: RADIUS,
              stroke: lt,
              strokeWidth: Et,
            }),
            React.createElement(
              "path",
              { d: getPath(RADIUS) },
              React.createElement("animateTransform", {
                attributeName: "transform",
                type: "rotate",
                from: "0 0 0",
                to: "360 0 0",
                dur: "1s",
                repeatCount: "indefinite",
              })
            )
          )
        )
      )
    );
  },
  __assign$m =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$m =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$m.apply(this, arguments)
      );
    },
  __assign$l =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$l =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$l.apply(this, arguments)
      );
    },
  __assign$k =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$k =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$k.apply(this, arguments)
      );
    },
  __assign$j =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$j =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$j.apply(this, arguments)
      );
    },
  prop = function tt(et, nt) {
    return function () {
      var rt =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof rt[et] < "u") return rt[et];
      if (et && et.indexOf(".") > 0) {
        for (
          var it = et.split("."), st = it.length, ot = rt[it[0]], at = 1;
          ot != null && at < st;

        )
          (ot = ot[it[at]]), (at += 1);
        if (typeof ot < "u") return ot;
      }
      return nt;
    };
  },
  __makeTemplateObject$1 =
    (globalThis && globalThis.__makeTemplateObject) ||
    function (tt, et) {
      return (
        Object.defineProperty
          ? Object.defineProperty(tt, "raw", { value: et })
          : (tt.raw = et),
        tt
      );
    },
  __assign$i =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$i =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$i.apply(this, arguments)
      );
    },
  spin = We(
    templateObject_1$1 ||
      (templateObject_1$1 = __makeTemplateObject$1(
        [
          `
 to {
    transform: rotate(360deg);
  }
`,
        ],
        [
          `
 to {
    transform: rotate(360deg);
  }
`,
        ]
      ))
  );
styled.svg(
  templateObject_2$1 ||
    (templateObject_2$1 = __makeTemplateObject$1(
      [
        `
  animation: `,
        ` 0.75s steps(12, end) infinite;
  animation-duration: `,
        `s;
`,
      ],
      [
        `
  animation: `,
        ` 0.75s steps(12, end) infinite;
  animation-duration: `,
        `s;
`,
      ]
    )),
  spin,
  prop("speed", "0.75")
);
styled.polyline(
  templateObject_3$1 ||
    (templateObject_3$1 = __makeTemplateObject$1(
      [
        `
  stroke-width: `,
        `px;
  stroke-linecap: round;

  &:nth-child(12n + 0) {
    stroke-opacity: 0.08;
  }

  &:nth-child(12n + 1) {
    stroke-opacity: 0.17;
  }

  &:nth-child(12n + 2) {
    stroke-opacity: 0.25;
  }

  &:nth-child(12n + 3) {
    stroke-opacity: 0.33;
  }

  &:nth-child(12n + 4) {
    stroke-opacity: 0.42;
  }

  &:nth-child(12n + 5) {
    stroke-opacity: 0.5;
  }

  &:nth-child(12n + 6) {
    stroke-opacity: 0.58;
  }

  &:nth-child(12n + 7) {
    stroke-opacity: 0.66;
  }

  &:nth-child(12n + 8) {
    stroke-opacity: 0.75;
  }

  &:nth-child(12n + 9) {
    stroke-opacity: 0.83;
  }

  &:nth-child(12n + 11) {
    stroke-opacity: 0.92;
  }
`,
      ],
      [
        `
  stroke-width: `,
        `px;
  stroke-linecap: round;

  &:nth-child(12n + 0) {
    stroke-opacity: 0.08;
  }

  &:nth-child(12n + 1) {
    stroke-opacity: 0.17;
  }

  &:nth-child(12n + 2) {
    stroke-opacity: 0.25;
  }

  &:nth-child(12n + 3) {
    stroke-opacity: 0.33;
  }

  &:nth-child(12n + 4) {
    stroke-opacity: 0.42;
  }

  &:nth-child(12n + 5) {
    stroke-opacity: 0.5;
  }

  &:nth-child(12n + 6) {
    stroke-opacity: 0.58;
  }

  &:nth-child(12n + 7) {
    stroke-opacity: 0.66;
  }

  &:nth-child(12n + 8) {
    stroke-opacity: 0.75;
  }

  &:nth-child(12n + 9) {
    stroke-opacity: 0.83;
  }

  &:nth-child(12n + 11) {
    stroke-opacity: 0.92;
  }
`,
      ]
    )),
  function (tt) {
    return tt.width;
  }
);
var templateObject_1$1,
  templateObject_2$1,
  templateObject_3$1,
  __assign$h =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$h =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$h.apply(this, arguments)
      );
    },
  __assign$g =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$g =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$g.apply(this, arguments)
      );
    },
  __assign$f =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$f =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$f.apply(this, arguments)
      );
    },
  __makeTemplateObject =
    (globalThis && globalThis.__makeTemplateObject) ||
    function (tt, et) {
      return (
        Object.defineProperty
          ? Object.defineProperty(tt, "raw", { value: et })
          : (tt.raw = et),
        tt
      );
    },
  __assign$e =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$e =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$e.apply(this, arguments)
      );
    },
  dash = We(
    templateObject_1 ||
      (templateObject_1 = __makeTemplateObject(
        [
          `
 to {
    stroke-dashoffset: 136;
  }
`,
        ],
        [
          `
 to {
    stroke-dashoffset: 136;
  }
`,
        ]
      ))
  );
styled.polygon(
  templateObject_2 ||
    (templateObject_2 = __makeTemplateObject(
      [
        `
  stroke-dasharray: 17;
  animation: `,
        ` 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;
`,
      ],
      [
        `
  stroke-dasharray: 17;
  animation: `,
        ` 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;
`,
      ]
    )),
  dash
);
styled.svg(
  templateObject_3 ||
    (templateObject_3 = __makeTemplateObject(
      [
        `
  transform-origin: 50% 65%;
`,
      ],
      [
        `
  transform-origin: 50% 65%;
`,
      ]
    ))
);
var templateObject_1,
  templateObject_2,
  templateObject_3,
  __assign$d =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$d =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$d.apply(this, arguments)
      );
    },
  __assign$c =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$c =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$c.apply(this, arguments)
      );
    },
  __assign$b =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$b =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$b.apply(this, arguments)
      );
    },
  __assign$a =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$a =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$a.apply(this, arguments)
      );
    },
  __assign$9 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$9 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$9.apply(this, arguments)
      );
    },
  __assign$8 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$8 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$8.apply(this, arguments)
      );
    },
  __assign$7 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$7 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$7.apply(this, arguments)
      );
    },
  __assign$6 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$6 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$6.apply(this, arguments)
      );
    },
  __assign$5 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$5 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$5.apply(this, arguments)
      );
    },
  __assign$4 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$4 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$4.apply(this, arguments)
      );
    },
  __assign$3 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$3 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$3.apply(this, arguments)
      );
    },
  __assign$2 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$2 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$2.apply(this, arguments)
      );
    },
  __assign$1 =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign$1 =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign$1.apply(this, arguments)
      );
    },
  __assign =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (__assign =
          Object.assign ||
          function (tt) {
            for (var et, nt = 1, rt = arguments.length; nt < rt; nt++) {
              et = arguments[nt];
              for (var it in et)
                Object.prototype.hasOwnProperty.call(et, it) &&
                  (tt[it] = et[it]);
            }
            return tt;
          }),
        __assign.apply(this, arguments)
      );
    };
const PlayerGround = () => {
    const {
        userDetails: tt,
        userBalance: et,
        playBlockChain: nt,
        showCard: rt,
        isTransactionProgressing: it,
        showSideOption: st,
        instructionMessage: ot,
        radioClicked: at,
        clickedTime: lt,
        userBalanceBlockChain: ct,
        isRestart: ut,
      } = useSelector((Ct) => Ct.DoubleSpendingReducer),
      [ft, ht] = reactExports.useState({
        receiver: "",
        amount: 0,
        isErr: !1,
        isAmountErr: !1,
        showCard: !1,
        id: 1,
        clickedTime: 0,
      }),
      [mt, vt] = reactExports.useState(!1),
      [yt, Et] = reactExports.useState(""),
      pt = useDispatch(),
      xt = (Ct) => {
        const { name: Mt, value: wt } = Ct.target;
        ht((Bt) => ({ ...Bt, [Mt]: wt.toUpperCase() }));
      },
      St = () => {
        if (ft.receiver !== "" && ft.amount > "0") {
          const Ct = {
            id: ft.id,
            receiverName: ft.receiver,
            amount: Number(ft.amount),
          };
          ht((Mt) => ({ ...Mt, isErr: !1, isAmountErr: !1, id: ft.id + 1 })),
            at === "conventional"
              ? (pt(
                  updateInstruction([
                    ...ot,
                    `Ram has chosen to transmit ${ft.amount} rupees to ${ft.receiver} by means of a Demand Draft (DD).`,
                  ])
                ),
                pt(updateLedger(!0)),
                pt(sendReceiverName(ft.receiver)),
                pt(sendMoneyToReceiver(Ct)),
                pt(transactionProgresing()),
                pt(updateBalance(ft.amount)),
                pt(startAnimation()))
              : ["B", "C", "D", "E"].includes(ft.receiver)
              ? (pt(sendReceiverName(ft.receiver)),
                pt(updateBalanceBlockChain(ct - ft.amount)),
                pt(sendMoneyToReceiver(Ct)),
                pt(waitingStart(!0)),
                pt(transactionProgresing()),
                pt(updateLedgerAnimation(!1)),
                pt(onHandleChangeVerifer("W")),
                pt(updateClickTime(lt + 1)),
                lt >= 1
                  ? pt(
                      updateInstruction([
                        "Intially there will be five users, with each block repersenting distinct blocks in the blockchain ",
                        `A initiates a transfer of  Rs ${ft.amount}  to ${ft.receiver}`,
                      ])
                    )
                  : pt(
                      updateInstruction([
                        ...ot,
                        `A initiates a transfer of  Rs ${ft.amount}  to ${ft.receiver}`,
                      ])
                    ),
                ft.amount <= ct
                  ? (vt(!0),
                    setTimeout(() => {
                      vt(!1), Et("");
                    }, 8e3))
                  : (vt(!0),
                    setTimeout(() => {
                      vt(!1), Et("Rejected");
                    }, 8e3)))
              : ht((Mt) => ({ ...Mt, isErr: !0 }));
        }
        ft.receiver === "" && ht((Ct) => ({ ...Ct, isErr: !0 })),
          ft.amount === 0 && ht((Ct) => ({ ...Ct, isAmountErr: !0 }));
      };
    console.log(ft.amount);
    const At = () => {
      at !== "conventional"
        ? (pt(
            onHandlePlayBlokChain({ setType: "playBlockChain", showCard: !0 })
          ),
          pt(
            updateInstruction([
              ...ot,
              "Intially there will be five users, with each block repersenting distinct blocks in the blockchain ",
            ])
          ))
        : pt(onHandlePlayBlokChain({ setType: "conventional", showCard: !0 }));
    };
    return (
      reactExports.useEffect(() => {
        ht((Ct) => ({
          ...Ct,
          isAmountErr: !1,
          receiver: "",
          amount: 0,
          isErr: !1,
        }));
      }, [at, ut]),
      console.log(ft.isAmountErr, ft.isErr),
      React.createElement(
        "div",
        { style: { paddingBlock: 15, paddingInline: 10, borderWidth: 5 } },
        rt
          ? st
            ? React.createElement(
                "div",
                {
                  style: {
                    borderStyle: "solid",
                    borderWidth: "1px",
                    borderBlockColor: "#1BFAFF",
                    position: "relative",
                    borderInlineColor: "#1bfaff",
                  },
                },
                React.createElement(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      background: "#313b5d",
                      top: -25,
                      left: "35%",
                      width: 100,
                      padding: 3,
                      display: "flex",
                      justifyContent: "center",
                      borderRadius: 50,
                    },
                  },
                  React.createElement(
                    "p",
                    { style: { fontSize: 15, color: "white" } },
                    "User Account"
                  )
                ),
                React.createElement(
                  Card$1,
                  {
                    style: {
                      backgroundColor: "transparent",
                      border: "none",
                      boxShadow: "none",
                      display: "flex",
                      flexDirection: "column",
                    },
                  },
                  React.createElement(
                    CardContent$1,
                    null,
                    React.createElement(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "flex-end",
                          width: "100%",
                          paddingBlock: 15,
                        },
                      },
                      at !== "conventional" &&
                        React.createElement(
                          "div",
                          { style: { display: "flex" } },
                          React.createElement(
                            Typography$1,
                            { sx: { color: "white", fontSize: 15 } },
                            "Balance :",
                            "     "
                          ),
                          React.createElement(
                            Typography$1,
                            {
                              sx: {
                                color: "yellow",
                                fontWeight: 800,
                                fontSize: 16,
                              },
                            },
                            "      ",
                            ct,
                            " "
                          )
                        ),
                      React.createElement(
                        "div",
                        { style: { display: "flex" } },
                        React.createElement(
                          Typography$1,
                          { sx: { color: "white", fontSize: 15 } },
                          "Sender :",
                          "  "
                        ),
                        React.createElement(
                          Typography$1,
                          {
                            sx: {
                              color: "yellow",
                              fontWeight: 800,
                              fontSize: 16,
                            },
                          },
                          " ",
                          at === "conventional" ? "Ram" : " A"
                        )
                      )
                    )
                  ),
                  React.createElement(
                    CardContent$1,
                    null,
                    React.createElement(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                        },
                      },
                      React.createElement(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "flex-start",
                            marginBlock: 2,
                          },
                        },
                        React.createElement(
                          "label",
                          { style: { color: "white" } },
                          "Receiver"
                        ),
                        React.createElement("input", {
                          name: "receiver",
                          value: ft.receiver,
                          style: {
                            padding: 10,
                            border: "none",
                            outline: "none",
                            marginBlock: 5,
                            boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px",
                            width: 240,
                          },
                          placeholder: "Receiver",
                          onChange: xt,
                        }),
                        ft.isErr &&
                          at !== "conventional" &&
                          React.createElement(
                            "span",
                            { style: { color: "red" } },
                            !["B", "C", "D", "E"].includes(ft.receiver) &&
                              "Please Enter valid reciver name (B,C,D,E)"
                          ),
                        ft.isErr &&
                          at === "conventional" &&
                          React.createElement(
                            "span",
                            { style: { color: "red" } },
                            "Please enter receiver name"
                          )
                      ),
                      React.createElement(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "flex-start",
                            marginBlock: 2,
                          },
                        },
                        React.createElement(
                          "label",
                          { style: { color: "white" } },
                          "Amount"
                        ),
                        React.createElement("input", {
                          name: "amount",
                          value: ft.amount,
                          type: "number",
                          style: {
                            padding: 10,
                            border: "none",
                            outline: "none",
                            marginBlock: 5,
                            boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px",
                            width: 240,
                          },
                          placeholder: "Amount",
                          onChange: xt,
                        }),
                        ft.isAmountErr &&
                          React.createElement(
                            "span",
                            { style: { color: "red" } },
                            "Amount should be greater than 0"
                          )
                      )
                    )
                  ),
                  React.createElement(
                    CardActions$1,
                    null,
                    React.createElement(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          width: "100%",
                          flexDirection: "column",
                        },
                      },
                      React.createElement(
                        "button",
                        {
                          disabled: it,
                          style: {
                            backgroundColor: "#64aed0",
                            border: "none",
                            padding: 10,
                            borderRadius: 20,
                            width: "120px",
                            marginBottom: 10,
                            color: "white",
                            boxShadow: "rgba(149, 157, 165, 0.2) 0px 8px 24px",
                          },
                          onClick: St,
                        },
                        mt
                          ? React.createElement(
                              "div",
                              {
                                style: {
                                  width: "100%",
                                  display: "flex",
                                  justifyContent: "center",
                                },
                              },
                              React.createElement(Oval, {
                                height: 15,
                                width: 15,
                                color: "yellow",
                                wrapperStyle: {},
                                wrapperClass: "",
                                visible: !0,
                                ariaLabel: "oval-loading",
                                secondaryColor: "yellow",
                                strokeWidth: 2,
                                strokeWidthSecondary: 2,
                              }),
                              React.createElement(
                                "span",
                                { style: { marginLeft: 5 } },
                                "processing"
                              )
                            )
                          : "Send"
                      )
                    )
                  )
                )
              )
            : React.createElement(React.Fragment, null)
          : at !== "conventional"
          ? React.createElement(DefinitionCard, { onClick: At })
          : React.createElement(DefinitionCard, {
              onClick: At,
              isConventional: !0,
            })
      )
    );
  },
  ControlPanel = () => {
    const tt = useDispatch(),
      et = () => {
        tt(updateRetart());
      };
    return React.createElement(
      "div",
      {
        style: {
          background:
            "linear-gradient(170deg, rgb(56 68 139 / 59%) -70.38%, rgba(3, 124, 235, 0.00) 140.44%)",
          padding: 2,
          height: "100%",
        },
      },
      React.createElement(
        "div",
        { style: { backgroundColor: "white", position: "relative" } },
        React.createElement(
          "h4",
          {
            style: {
              textAlign: "center",
              margin: 0,
              paddingBlock: 15,
              textTransform: "uppercase",
              fontFamily: "sans-serif",
              fontSize: 15,
              color: "black",
            },
          },
          "Double Spending"
        ),
        React.createElement(
          IconButton$1,
          { onClick: et, style: { position: "absolute", right: 0, top: 2 } },
          React.createElement(
            Tooltip$1,
            { title: "restart" },
            React.createElement(RestartAlt, {
              style: { color: "#313b5e" },
              color: "#313b5e",
            })
          )
        )
      ),
      React.createElement(
        "div",
        { style: { paddingTop: 15, marginBottom: 40 } },
        React.createElement(RadioButtons, null)
      ),
      React.createElement(
        "div",
        { style: { height: "80%" } },
        React.createElement(PlayerGround, null)
      )
    );
  },
  MainContainer = () => {
    const {
        receiverName: tt,
        verifierName: et,
        selectedColor: nt,
        waiting: rt,
        radioClicked: it,
        showCard: st,
        clickedTime: ot,
        userBalanceBlockChain: at,
        instructionMessage: lt,
      } = useSelector((Mt) => Mt.DoubleSpendingReducer),
      ct = useDispatch(),
      { sender: ut, receiver: ft, verifier: ht } = nt,
      [mt, vt] = reactExports.useState(!1),
      [yt, Et] = reactExports.useState(!1),
      pt =
        tt === "B"
          ? `One among C,D,E is required to verify the transaction while A and ${tt} waits `
          : tt === "C"
          ? `One among ,B,D,E is required to verify the transaction while A and ${tt} waits`
          : tt === "D"
          ? `One among B,C,E is required to verify the transaction while A and ${tt} waits`
          : tt === "E"
          ? `One among B,C,D is required to verify the transaction while A and ${tt} waits`
          : "",
      xt =
        tt === "B"
          ? ["C", "D", "E"]
          : tt === "C"
          ? ["B", "D", "E"]
          : tt === "D"
          ? ["B", "C", "E"]
          : tt === "E"
          ? ["B", "C", "D"]
          : "",
      St = (Mt) => {
        const { name: wt, value: Bt } = Mt.target,
          It = { ...nt, [wt]: Bt };
        ct(updateSelectedColor(It));
      };
    reactExports.useEffect(() => {
      let Mt;
      if (rt && it !== "conventional")
        return (
          (Mt = setTimeout(() => {
            ct(updateInstruction([...lt, pt])), vt(!0), Et(!1);
          }, 2500)),
          () => {
            clearTimeout(Mt);
          }
        );
    }, [rt]),
      reactExports.useEffect(() => {
        let Mt;
        if (mt && it !== "conventional")
          return (
            (Mt = setTimeout(() => {
              ct(
                updateInstruction([
                  ...lt,
                  "select from one of the three option to act as the verifier    ",
                ])
              ),
                vt(!0);
            }, 1500)),
            () => {
              clearTimeout(Mt);
            }
          );
      }, [mt]);
    const At = (Mt) => {
        console.log(ot),
          ct(onHandleChangeVerifer(Mt)),
          ct(
            updateInstruction([
              ...lt,
              `User-${Mt} Verifing the transaction.... `,
            ])
          ),
          setTimeout(() => {
            ct(
              updateInstruction([
                ...lt,
                `User-${Mt} Verify the transaction to ensure it's valid and conforms to the network's rules, such as having sufficient funds in your account to make the transfer.`,
              ])
            );
          }, 2e3),
          setTimeout(() => {
            at < 0
              ? (ct(
                  updateInstruction([
                    ...lt,
                    `During the verification process, User-${Mt} detects that User A's account has insufficient balance to cover the transaction amount. `,
                    `User-${Mt} concludes that the transaction should be rejected due to insufficient balance, and they communicate this decision to the network.`,
                    `<span style="color: white; font-weight: bold; background-color: red; padding: 2px; border-radius: 5px;">The majority of nodes agree with User-${Mt}'s verification and reject the transaction. This consensus is crucial to prevent fraudulent or invalid transactions from being added to the ledger.</span>`,
                  ])
                ),
                ct(updateLedgerAnimation(!1)))
              : (ct(updateLedgerAnimation(!0)),
                ct(transactionProgresingStop()),
                ct(
                  updateInstruction([
                    ...lt,
                    `User-${Mt} confirms that the sender has enough balance to cover the transaction, the transaction is considered valid.`,
                  ])
                )),
              ct(waitingStart(!1)),
              vt(!1);
          }, 7e3),
          Et(!0);
      },
      Ct = it !== "conventional" && st ? 0.5 : 0.8;
    return React.createElement(
      "div",
      { style: { width: "100%", height: "100%", display: "flex" } },
      React.createElement(
        "div",
        { style: { flex: Ct, position: "relative" } },
        React.createElement(ThreeComponent, null)
      ),
      it !== "conventional" &&
        st &&
        React.createElement(
          "div",
          { style: { flex: 0.3, backgroundColor: "#1d273a" } },
          React.createElement(
            "div",
            { style: { display: "flex", flexDirection: "column" } },
            React.createElement(
              "div",
              {
                style: {
                  width: "100%",
                  display: "flex",
                  justifyContent: "flex-end",
                },
              },
              React.createElement(
                "div",
                {
                  style: {
                    padding: 5,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "flex-end",
                    paddingBlock: 15,
                    width: "150px",
                    marginTop: 25,
                    borderWidth: 1,
                    borderColor: "yellow",
                    borderStyle: "dashed",
                    marginRight: 5,
                  },
                },
                React.createElement(
                  "h4",
                  { style: { color: "white", textTransform: "capitalize" } },
                  "custom color"
                ),
                React.createElement(
                  "div",
                  { style: { padding: 2 } },
                  React.createElement(
                    "span",
                    { style: { color: "yellow", marginRight: 5 } },
                    "Sender :"
                  ),
                  React.createElement("input", {
                    onChange: St,
                    value: ut,
                    type: "color",
                    name: "sender",
                  })
                ),
                React.createElement(
                  "div",
                  { style: { padding: 2 } },
                  React.createElement(
                    "span",
                    { style: { color: "yellow", marginRight: 5 } },
                    "Receiver :"
                  ),
                  React.createElement("input", {
                    onChange: St,
                    value: ft,
                    name: "receiver",
                    type: "color",
                  })
                ),
                React.createElement(
                  "div",
                  { v: !0 },
                  React.createElement(
                    "span",
                    { style: { color: "yellow", marginRight: 5 } },
                    "Verifier :"
                  ),
                  React.createElement("input", {
                    onChange: St,
                    value: ht,
                    name: "verifier",
                    type: "color",
                  })
                )
              )
            ),
            React.createElement(
              "div",
              null,
              React.createElement(
                "div",
                null,
                React.createElement(
                  "h4",
                  {
                    style: {
                      color: "white",
                      textAlign: "center",
                      fontFamily: "sans-serif",
                    },
                  },
                  "Steps"
                ),
                React.createElement(
                  "div",
                  { style: { paddingLeft: 50 } },
                  lt.map((Mt, wt) =>
                    React.createElement(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          marginBlock: 9,
                          fontFamily: "sans-serif",
                        },
                      },
                      React.createElement(
                        "div",
                        {
                          style: {
                            display: "flex",
                            justifyContent: "flex-start",
                          },
                        },
                        React.createElement(
                          "span",
                          { style: { color: "yellow" } },
                          wt + 1,
                          React.createElement("span", null, ")")
                        ),
                        React.createElement("p", {
                          style: {
                            color: "yellow",
                            marginBlock: 0,
                            marginInline: 3,
                            textAlign: "start",
                          },
                          dangerouslySetInnerHTML: { __html: Mt },
                        })
                      ),
                      React.createElement(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "center",
                            width: "100%",
                            marginBlock: 5,
                          },
                        },
                        wt === 3 &&
                          xt.map((Bt) =>
                            React.createElement(
                              "div",
                              null,
                              React.createElement(
                                "button",
                                {
                                  style: {
                                    width: 50,
                                    background:
                                      yt && Bt !== et ? "grey" : "white",
                                    color: "black",
                                    borderRadius: 20,
                                    border: "none",
                                    marginInline: 2,
                                  },
                                  onClick: () => At(Bt),
                                  disabled: yt ? Bt !== et : !1,
                                },
                                Bt
                              )
                            )
                          )
                      )
                    )
                  )
                )
              )
            )
          )
        ),
      React.createElement(
        "div",
        { style: { flex: 0.2 } },
        React.createElement(ControlPanel, null)
      )
    );
  },
  store = configureStore({
    reducer: { DoubleSpendingReducer: DoubleSpendingReducer$1 },
  });
function App() {
  return React.createElement(
    "div",
    { style: { width: "100%", height: "98vh" } },
    React.createElement(
      Provider,
      { store },
      React.createElement(MainContainer, null)
    )
  );
}
const index = "";
client
  .createRoot(document.getElementById("root"))
  .render(
    React.createElement(React.StrictMode, null, React.createElement(App, null))
  );
